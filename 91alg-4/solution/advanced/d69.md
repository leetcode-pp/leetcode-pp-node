# 924. 尽量减少恶意软件的传播

## 入选理由

- 和昨天的题目类似，但是又不那么直接？毕竟是困难，要点面子不是？

## 题目地址

https://leetcode-cn.com/problems/minimize-malware-spread

## 题目内容

在节点网络中，只有当 graph[i][j] = 1 时，每个节点 i 能够直接连接到另一个节点 j。

一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。

假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。

我们可以从初始列表中删除一个节点。如果移除这一节点将最小化 M(initial)， 则返回该节点。如果有多个节点满足条件，就返回索引最小的节点。

请注意，如果某个节点已从受感染节点的列表 initial 中删除，它以后可能仍然因恶意软件传播而受到感染。

```
示例 1：

输入：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
输出：0
示例 2：

输入：graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
输出：0
示例 3：

输入：graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
输出：1


提示：

1 < graph.length = graph[0].length <= 300
0 <= graph[i][j] == graph[j][i] <= 1
graph[i][i] == 1
1 <= initial.length < graph.length
0 <= initial[i] < graph.length
```

## 思路

### 题解

这道题抽象一下就是在求联通分量

1. 根据 initial 节点去求联通分量
2. 如果两个 inittial 节点在同一个联通分量，这两个节点肯定不是答案，因为不管排除哪个，这个联通分量的节点都会被感染
3. 统计只含有一个初始节点的联通分量，找到联通分量中节点数最多的即可，如果有多个联通分量节点数最多，返回含有最小下标初始节点

上述过程就是找联通分量过程，并查集天然适合找联通分量。

### 并查集

```js
var minMalwareSpread = function (graph, initial) {
  const father = Array.from(graph, (v, i) => i);
  function find(v) {
    if (v === father[v]) {
      return v;
    }
    father[v] = find(father[v]);
    return father[v];
  }
  function union(x, y) {
    if (find(x) !== find(y)) {
      father[x] = find(y);
    }
  }

  for (let i = 0; i < graph.length; i++) {
    for (let j = 0; j < graph[0].length; j++) {
      if (graph[i][j]) {
        union(i, j);
      }
    }
  }

  initial.sort((a, b) => a - b);

  let counts = graph.reduce((acc, cur, index) => {
    let root = find(index);
    if (!acc[root]) {
      acc[root] = 0;
    }
    acc[root]++;
    return acc;
  }, {});

  let res = initial[0];
  let count = -Infinity;

  initial
    .map((v) => find(v))
    .forEach((item, index, arr) => {
      if (arr.indexOf(item) === arr.lastIndexOf(item)) {
        if (count === -Infinity || counts[item] > count) {
          res = initial[index];
          count = counts[item];
        }
      }
    });

  return res;
};
```

### DFS

```js
var minMalwareSpread = function (graph, initial) {
  const N = graph.length;
  initial.sort((a, b) => a - b);
  let colors = Array.from({ length: N }).fill(0);
  let curColor = 1;
  // 给联通分量标色
  for (let i = 0; i < N; i++) {
    if (colors[i] === 0) {
      dfs(i, curColor++);
    }
  }

  let counts = Array.from({ length: curColor }).fill(0);
  for (node of initial) {
    counts[colors[node]]++;
  }

  let maybe = [];
  for (node of initial) {
    if (counts[colors[node]] === 1) {
      maybe.push(node);
    }
  }

  counts.fill(0);

  for (let i = 0; i < N; i++) {
    counts[colors[i]]++;
  }

  let res = -1;
  let maxCount = -1;

  for (let node of maybe) {
    if (counts[colors[node]] > maxCount) {
      maxCount = counts[colors[node]];
      res = node;
    }
  }

  if (res === -1) {
    res = Math.min(...initial);
  }

  return res;

  function dfs(start, color) {
    colors[start] = color;
    for (let i = 0; i < N; i++) {
      if (graph[start][i] === 1 && colors[i] === 0) {
        dfs(i, color);
      }
    }
  }
};
```
