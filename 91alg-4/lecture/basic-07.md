# 模拟，枚举与递推

本篇讲义隶属于基础篇。 基础不意味着简单，有时候一道困难的题目也背后的算法也可能是基础算法。 因此我们需要做的是**熟悉各种基础数据结构和算法**，做到融会贯通，举一反三，这样面对复杂问题才能迎刄有余。

这里我们讲三种基础思想和方法，这几种方法将贯穿整个算法系列的始终，它们分别是模拟，枚举与递推。

模拟并不是一种算法，而是一种思维方式。枚举则是一个最基础的技能，但是枚举却不一定和你想象的一样简单。递推则是一种很重要的编程思想， 是递归，动态规划等高级主题的基础。

## 模拟

简单来说，我们这里的模拟指的就是**题目让你做什么，你就做什么**。即将题目描述翻译为可执行的代码。这在我们做工程的时候，将产品经理的需求转化为代码是类似的。

模拟并不是一类具体的算法，而是一种思想。

模拟指的是将题目描述转化为可执行的代码，其中我们会用到编程语言的基础内容，最常见的就是循环。

简单的题目，通常直接模拟就够了，比如 [874. 模拟行走机器人](https://leetcode-cn.com/problems/walking-robot-simulation/) 。

而如果是中等和困难的题目，除了使用模拟，我们还需要使用一些别的技巧。比如有的题目就是**模拟 + 堆**，这是因为模拟的过程我们需要动态获取极值。再比如 [799. 香槟塔](https://leetcode-solution-leetcode-pp.gitbook.io/leetcode-solution/medium/799.champagne-tower)，其实就是模拟 + 动态规划。可以看出，中等的题目通常模拟只是辅助，还需要结合其他知识。

那么是否所有的题目都是模拟？当然不是。比如动态规划的题目，这就不能说是模拟。因为题目并没有告诉你**明确的操作步骤**，而是需要你根据题目信息，**自己挖掘**转移方程进行求解。

## 枚举

枚举简单来说就是指尝试所有可能，是一种最基本的算法。

最常见的枚举就是暴力搜索。即在解空间中暴力枚举所有解空间中的值，并逐个判断其是否是答案。

枚举可以很简单。比如枚举一个数组的所有项。

```java
for(int i = 0;i < A.length();i++) {
    // 打印 A[i]
}

```

实际上枚举也可以很复杂。比如：

- 维度的上升（枚举 3 维数组）
- 方向的选择（从前往后还是从后往前）等。

而且同样是枚举，不同的枚举策略也可能有不同的结果和效率。关于这点，我们将在后面的剪枝专题给大家做更多介绍。

### 枚举三要素

枚举有三个东西需要考虑。

1. 状态。都有哪些状态需要我们枚举？
2. 不重不漏。如何枚举才不会重复，且不会漏过正确解？
3. 效率。采取怎么样的枚举策略可以最大化提供算法效果？

接下来，我们通过一个具体的例子，带大家领会这三点。

### 经典实例 - 枚举子集

比如需要枚举一个数字集合 S 的所有子集，你会如何做？

1. 状态。

我们可以用一个和 S 相同大小的数组 picked 记录每个数被选取的信息， 用 0 表示没有选取，用 1 表示选取。

比如 S 大小为 3， picked 数组 [1,1,0]，表示 S 中的第一项和第二项被选择（索引从 1 开始）。如果 S 的大小为 n，就需要用一个长度为 n 的数组来存储，那么就有 $2^n$ 种状态。

由于数组的值**不是 0 就是 1，满足二值性**，因此更多时候我们会使用**一个数字** y 来表示状态，而不是上面的 picked 数组。其中 y 的**二进制位**对应上面提到的 picked 数组中的一项。 比如如上的 picked 数组 [1,1,0] 可以用 ob110，也就是二进制的 6 来表示。

2. 不重不漏。

我们可以用一个数 x 来模拟集合 S，用 y 来模拟 picked 数组。这样问题就转化为两个数（x 和 y）的位运算。

由于我们使用 1 表示被选取， 0 表示选取。因此 如果 x 对应位为 0，其实 y 也只能是 0，而如果 x 对应位是 1，y 却可能是 0 或者 1。也就是说 y 一定小于等于 x， 因此可以枚举所有小于等于 x 的数的二进制，并逐个**判断其是否真的是 x 的子集**。

具体来说，我们可以令 n 为 x 的二进制位数。不难写出如下代码：

```js
// 外层枚举所有小于等于 x 的数
ans = [];
for (i = 1; i < 1 << n; i++) {
  if ((x | i) === x) ans.push(i);
}
// ans 就是所有非空子集
```

这种算法的复杂度大约是 $O(4^n)$，也就是说和 x 成正比。这种算法 n 最多取到 12 左右。

这样做不重不漏么？

答案是可以的。因为 (x | i) === x 就是 i 是 x 的子集的充要条件，当然你也可用 & ，即 (x | i) & i == i 来表示 i 是 x 的子集。

如果二进制你不好理解，其实你可以转化为十进制理解。比如我给你一个数 132，让你找 132 的子集，这里的子集我简单定义为当前位的数字是否小于等于原数字当前位的数字。这样我们就可以先从 1 枚举到 132，因为这些数潜在都可能是 132 的子集。如果我枚举了一个数字 030，由于 0 小于等于 1，3 小于等于 3，0 小于等于 2，因此 030 是 132 的子集。而如果我枚举了一个数字 040，由于 4 大于 3，因此 040 不是 132 的子集。

3. 效率。

上面的枚举方法虽然也可保证不重不漏，但是却不是最优的，这里介绍一种更好的枚举方法。

具体做法就是$x_i$和 x 进行&（与）运算。与运算可以**快速跳到下一个子集**。

```js
ans = [];
// 外层枚举所有小于等于 x 的数
for (i = x; i != 0; i = (i - 1) & x) {
  ans.push(i);
}
// ans 就是所有非空子集
```

这样做不重不漏么？算法的关键在于 `i = (i - 1) & x`。这个操作首先将 i - 1，从而把 i 最右边的 1 变成了 0，然后把这位之后的所有 0 变成了 1。经过这样的处理再与 x 求与，就保证了得到的结果是 x 的子集，并且一定是所有子集中小于 i 的最大的一个。直观来看就是倒序枚举除了所有非空子集。

对于有 n 个 1 的二进制数字，需要 $2^n$ 的时间复杂度。而有 n 个 1 的二进制数字有 $C(n,i)$ 个，所以这段代码的时间复杂度为 $\sum_{i=0}^{n} C(n,i)\times2^i$，大约是 $O(3^n)$。和上面一样，这种算法的时间复杂度也和 x 成正比。但是这种算法 n 最多取到 15 左右。

这种方法对题目有一定要求， 即：

1. 数据范围要合适，否则数字无法表示了。
2. 只能有两种状态，这样才可以用二进制位 0 和 1 进行模拟。

## 递推

高中的时候我们应该知道函数递推关系式，类似 f(n) = f(n-1) + n。

当我们能够得出函数的递推关系的时候，就可以根据递归关系一步步从 base case 逐步推导到原问题的解。

而上面的递推关系是最核心的，它可能是题目直接给出的递归关系，比如题目让你求 fibonacci 数列第 n 项。也有可能是需要自己挖掘，比如绝大多数的动态规划问题。

这里我们主要都假设已经递推关系的情况下，如果从 base case 递推到原问题。而关于递归关系的寻找，则放到后面的动态规划篇进行详细介绍。

仍然是上面的 f(n) = f(n-1) + n 为例。

如果题目让你求 f(100) 你会如何求？

首先需要明确的是，想这种递归关系的求解，一定要有一个 base case，否则会陷入无限循环。

那么 base case 是什么呢？我们可以先手动**随意选择一种情况**为 base case，这并不影响问题的求解。

比如我分别以：

- f(99)
- f(0)
- f(200)

为 base case。

那么计算的结果会有所不同呢？不会的。不同的只是我们的代码。

那么 f(99) 是多少呢？这不确定， 这需要从题目中挖掘。

比如 f(99) 是 4950，那么我们就可以写出如下代码：

```js
function f(n) {
  if (n == 99) return 4950;
  return f(n - 1) + n;
}
```

比如 f(0) 是 0，那么我们就可以写出如下代码：

```js
function f(n) {
  if (n == 0) return 0;
  return f(n - 1) + n;
}
```

比如 f(200) 是 4950，那么我们就可以写出如下代码：

```js
function f(n) {
  if (n == 99) return 20100;
  return f(n - 1) + n;
}
```

只不过上面的代码在特定的时候**可能** 有 bug。比如选择了 f(99) 为 base case，那么计算 f(98) 就会陷入无限循环。

如何解决呢？答案是**夹逼**。

- 如果 n 大于 base case，则减少 n 到 base case。
- 如果 n 小于 base case，则增大 n 到 base case。

![0 是 base case](https://tva1.sinaimg.cn/large/008i3skNly1gqnktu7b2ej30r80e2mxl.jpg)

![99 是 base case](https://tva1.sinaimg.cn/large/008i3skNly1gqnkuc7f4tj30of0e4q3k.jpg)

以这道题来说，递推关系为 f(n) = f(n-1) + n，那么移项得 f(n-1) = f(n) - n，将 n 用 n + 1 替换，n - 1 用 n 替换，得 f(n) = f(n + 1) - (n + 1)

代码：

```js
function f(n) {
  if (n == 99) return 4950;
  if (n > 99) return f(n - 1) + n;
  return f(n + 1) - (n + 1);
}
```

简单来说，我们的递归方向是**不断趋向 base case**的。

因此我们可以得出结论：如果 base case 选择的题目的取值范围的中间位置，那么代码会比较难写，需要考虑解的方向使用不同的递归公式。而如果 base case 选择在题目取值范围的端点，就可以很好的解决这个问题。

因此如果题目取值范围是 [0, 100000] ，那么选择 0 或者 100000 作为 base case 都是很方便的。类似地，如果题目取值范围是 [-10, 100] ，那么选择 -10 或者 100 都是很方便的。

递推应用的非常广泛。比如前面树专题中讲解的**求树的高度**。计算树的深度就利用了递推关系 f(x) = f(y) + 1，其中 x 为 y 的子节点，而 base case 就是 x 为根节点，此时 f(x) = 0。利用这个 base case 和递推关系就可以计算树中任意节点的深度。

由于计算树深度的 base case 是根节点，因此我们需要前序遍历自顶向下的计算。而如果计算某个节点的子节点个数。不难得出有如下递推关系 $f(x) = sum_{i=0}^{n}{f(a_i)}$ 其中 x 为树中的某一个节点，$a_i$ 为树中节点的子节点。而 base case 则是没有任何子节点(也就是叶子节点)，此时 $f(x) = 1$。 因此我们可以利用后序遍历自底向上来完成子节点个数的统计。

## 总结

模拟是一种常见的思想，简单题目很多都是直接模拟。对于中等和困难，如果需要模拟，则通常是模拟 + 一些其他知识点。不管是什么，对于模拟来说，我们要做的仅仅是将题目描述转化为代码，这考察了我们代码能力。

枚举就是列出所有的可能，有时候枚举可以很容易，而有时候也可以很困难。大家在做枚举的时候，要把握好三个要点，并明确枚举的方向。有的时候仅仅是枚举策略的不同，就会导致一个超时，而另一个通过。

递推则是建立原问题和子问题之间的递推关系，根据递推关系进行推导，逐步从 base case 推导到原问题进行求解。递推在递归，动态规划等高级算法主题中有着很重要的作用。
