# 字符串匹配专题

字符串匹配算法（String matching algorithms）是字符串问题下的一个**搜索问题**，因此它本质是一个搜索问题，不过和我们前面讲的 BFS，DFS ， 回溯不太一样，这些侧重的是对搜索树进行搜索，即状态空间是非线性的。而本章的状态空间是线性的。

## 什么是字符串匹配

字符串匹配用来在一长字符串或文章中，找出其是否包含某一个或多个字符串以及其位置的算法。该算法的应用非常广泛，比如：生物基因匹配、信息检索（比如编辑器的 ctrl + f 搜索功能）等。

用数学语言描述如下:

假设$T$是一个长度为$n$的文本串，$P$是长度为$m$的模式串。如果有 $0<=s<n-m$，使得$T[s, s+1,...,s+m]$等于$P$，则称$P$在$T$中出现且位移为$s$。

比如 T 为 "lucifer"， "lu"（开始位置为 0）， "cifer"（开始位置为 2） 在 T 中出现过。而 "xifa"， "hello" 等没有在 T 中出现过。

## 字符串匹配常见算法

### 暴力(Brute Force)

**核心思路**

在日常编码生活中，我们肯定会遇到类似的问题，大部分数据量其实**不大**，串长也**较短**，因此自然会想到**窗口大小固定的滑动窗口**找出所有子串并依次和模式串按字母顺序依次比对看是否匹配并记录。

> 这里的窗口大小就是模式串的长度

该方法可以抽象为以下几步：

0. 非法情况处理，如模式串长度大于待匹配串等（防御性编程)
1. 初始化大小为模式串长的滑窗
2. 固定当前窗口，将当前窗口的子串与模式串匹配
   2.1. 若匹配成功，则记录相关信息，如该位置下标
   2.2. 否则窗口向后移动一格

**伪代码**

```python
n = length[T]
m = length[P]

for s = 0 to n - m
  do if T[s..s+m] == P
    save info
```

时间复杂度$O(n*m)$, 空间复杂度$O(1)$

这种暴力算法对于数据规模小，串短的问题已经足够了，但是很多场景下数据规模很大，那暴力算法就显得捉襟见肘了，毕竟时间复杂度摆在那里，响应时间过长。

我们稍加分析其实不难发现，我们在每次窗口后移一位进行匹配的时候，实际上是把**上一个窗口的所有状态信息全部都丢掉不要了**，这会造成信息的浪费，那么都有哪些常见且优秀的解决方案呢？

核心其实还是前面讲滑动窗口提到的**变化仅仅是窗口边缘，窗口中间不变**。这就是 RK 算法的本质。

### Rabin-Karp 算法(RK)

**核心思路**

RK 算法主要是对$T$中每个长度为$m$的子字符串$T[s..s+m]$进行 hash 运算，生成 hash 值$h1$，对$P$进行 hash 运算，生成 hash 值$h2$, 比对$h1$和$h2$，如果两个 hash 值(不考虑冲突)相等，则判断$P$在$T$中出现，且位移为$s$。

该方法和暴力法主要步骤是一样的。如果每步都算子串的 hash 值，那么每步 hash 的时间复杂度为$O(m)$，那么最后的整体复杂度和 BF 一样都为$O(m*n)$。

RK 算法妙在滑动窗口的时候，设计了一个适合的哈希函数，有效保留了上一个状态的部分信息，这样第一次计算子串 hash 值时间复杂度为$O(m)$，而后续就可以达到$O(1)$，这就是**有效利用了前面计算的窗口信息，而不是全盘计算，这不就是滑动窗口的精髓么？**。因此 RK 算法最终的时间复杂度就降为$O(m+n)$。

该方法可以抽象为以下几步：

0. 非法情况处理，如模式串长度大于待匹配串等（防御性编程）
1. 计算出模式串 hash 值
2. 初始化大小为模式串长的滑窗并计算出 hash 值，判断当前 hash 值是否和模式串 hash 值相等。
   2.1. 若相等，则记录相关信息，如该位置下标
   2.2. 否则窗口向后移动一格，并再次计算 hash 值（此处利用上个状态可直接一步计算）

**伪代码**

```python

n = length[T]
m = length[P]
hp = hash(P)

for s = 0 to n - m
  hs = hash(T[s..s+m])
  if hp == hs and double check is right
    save info
```

![示意图](https://tva1.sinaimg.cn/large/0081Kckwly1glwvk2z36jj31y40kkdi3.jpg)

我们这里选取的哈希函数为

$f(P)=P表示的10进制值$

假设$P$和$T$全由$d$个字符组成的，则我们可以选择$d$进制表示$P$和$T$，再将$d$进制转为$10$进制便于计算。

为了简化说明，我们更特殊地假设$P$和$T$全由[0-9]10 个数字组成。

$P$的 10 进制为：

```
f(P) = P[0] * 10 ^ (m - 1) + P[1] * 10 ^ (m - 2) ... + P[1]
```

$T[s..s+m]$的 10 进制为:

```
f(T[s..s + m]) = T[s] * 10 ^ (m - 1) + T[s + 1] * 10 ^ (m - 2) ... + T[s + m]
```

$T[s+1..s+m+1]$可以根据$T[s..s+m]$推导

```
f(T[s+1..s + m + 1]) = T[s+1] * 10 ^ (m - 1) + T[s + 2] * 10 ^ (m - 2) ... + T[s + m + 1]
= (f(T[s..s + m]) - T[s] * 10 ^ (m - 1)) * 10 + T[s + m + 1]
```

这样就把以上 `hp === hs` 的哈希比较转化为正常的 10 进制比较。

到目前为止，以上假设我们回避的一个问题是如果$f(P)$或者$f(T)$计算的 10 进制过大，导致**运算溢出**怎么办？

这里我们通过选择一个比较大的素数$q$, 计算后的 10 进制数对$q$取模后再进行比较。但是这种方案并不完美，$f(P)%q==f(T[s])%q$并不能代表$f(P)==f(T[s])$。任何的$f(P)%q===f(T[s])%q$都需要额外进行再次验证, 这里我们通过检测$P==T[s..s+m]$来完成。

### KMP

**KMP 本质上是个预处理 + dp。**

- 预处理指的是经过这样的处理一个模式串会生成一个 **唯一的 next 数组**，从而可以去匹配任意的主串。

> 唯一指的是给定模式串，生成的 next 数组就是确定的。和主串是没有任何关系的。

- dp 指的是建立 next 数组的部分使用到了动态规划的算法。

而匹配的过程，赵丽算法中主串会有很多回溯，使用 KMP 可以**避免主串回溯，而只回溯模式串**。 形象地看就是模式串不停地在对齐主串。

**核心思路**

首先我们定义模式串的前缀函数 f(i) 为 模式串 P 中 P[1...i]相同前缀后缀的最大长度。对 P[1...m]中的每个 i，(i > 0 && i <= m), 用一个数组 next 记录。
KMP 算法由 Knuth，Morris 和 Pratt 三个大佬联合发明，KMP 算法名字由三个大佬名字首位字符组成。

首先我们定义模式串的函数$f(i)$为模式串$P$中$P[:i]$相同前缀后缀的最大长度。对$P$中的每个$i$的信息，用一个数组$next$统一记录。
KMP 算法在每次失配后，会根据上一次的比对信息跳转到相应的$s$处，借助的就是上述的$next$数组。
推导过程可以参考 [从头到尾彻底理解 KMP](https://blog.csdn.net/v_JULY_v/article/details/7041827)，个人觉得这篇讲的非常透彻，这里就不班门弄斧了。
该方法可以抽象为以下几步：

- 非法情况处理，如模式串长度大于待匹配串等（防御性编程）
- 计算出模式串的 next 数组。
- 开始从待匹配串开始进行匹配
- 若匹配成功，则记录相关信息；若失配，则按 next 数组回退到上一个待匹配状态继续进行匹配

以下是计算$next$数组的伪代码

```python

get_next(P):
  m  = P.length
  使得 next 为长度为m的数组
  next[1] = 0
  k = 0
  for i = 2 to m
    while(k > 0 并且 P[k+1] != P[i])
      k = next[k]
    if P[k+1] == P[i]
      k = k + 1
    next[i] = k
  return next
```

以下是 KMP 的伪代码

```python
KMP(T, P)
  n = T.length
  m = P.length
  next = getNext(P)
  q = 0
  for let i = 1 to n:
    while(q > 0 并且 P[q + 1] !== T[i])
      q = next[q]
    if P[q + 1] == T[i]
      q = q + 1
    if (q == m)
      找到匹配位移 s = i
```

## 总结

字符串匹配本质就是求一个模式串是否在主串中出现过，以及出现的具体位置。我们本章讲解了字符串匹配的三种常见方法：暴力法，RK 算法和 KMP 算法。

其中

- 暴力法简单直接
- RK 算法就是前面滑动窗口专题的应用，核心在于哈希函数的选择
- KMP 则是前面动态规划的应用，核心在于 next 数组的生成。

虽然本章是讲字符串的匹配，但是你可以将其进行简单的扩展，以实现知识的迁移。

比如给你两个数组 A 和 B，其中 A 为 [1,2,3,4,5] ，B 为 [2,8,9,10]。让你在 A 中 找到 B 的最长相似数组。其中相似数组指的是；如果数组 A[i], A[i+1] , ... A[j] 与 B[p], B[p+1] , ... B[q]，满足 A[i] == B[p] + x，A[i+1] == B[p+1] + x, .... A[j] == B[q] + x，其中 x 为任意数字。

这个题目可以将 A 和 B 做一个简单的变换，变换之后就可以看成是字符串匹配，即让你在 A 中找 B。

那么如何变化呢？答案是相邻项做差。

```py
for i in range(1, len(A)):
  A[i] -= A[i-1]
  B[i] -= B[i-1]
```

经过这样的处理 A 和 B 就变为了：

```py
A = [1,1,1,1,1]
B = [2,1,1,1]
```

可以看出除了首项外，A 和 B 相似数组的值是相同的。

我们先不看 A 和 B 的首项，这样的话我们只要在 A 中找到 [1,1,1] 就行了，最后在考虑首项即可。

此时我们就可以使用本章的方法来解决，比如 RK 算法（选择一个合适的哈希函数即可）。

## 参考

- [维基百科](https://zh.wikipedia.org/wiki/%E5%85%8B%E5%8A%AA%E6%96%AF-%E8%8E%AB%E9%87%8C%E6%96%AF-%E6%99%AE%E6%8B%89%E7%89%B9%E7%AE%97%E6%B3%95)
- [从头到尾彻底理解 KMP](https://blog.csdn.net/v_JULY_v/article/details/7041827)
- [Finite Automata algorithm for Pattern Searching](https://www.geeksforgeeks.org/finite-automata-algorithm-for-pattern-searching/)

## 扩展

### 基于有限自动机的字符串匹配

这个算法仅限了解即可，这里不做展开，感兴趣可以参考 [Finite Automata algorithm for Pattern Searching](https://www.geeksforgeeks.org/finite-automata-algorithm-for-pattern-searching/)

### 推荐学习视频(需翻墙)

- [油管 KMP 讲解](https://www.youtube.com/watch?v=GTJr8OvyEVQ)
