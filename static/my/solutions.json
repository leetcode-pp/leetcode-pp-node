{"1":[],"2":[],"3":[],"4":[],"5":[],"6":[],"7":[],"8":[],"9":[],"10":[],"11":[],"12":[],"13":[],"14":[],"15":[],"16":[],"17":[],"18":[],"19":[],"20":[],"21":[],"22":[],"23":[],"24":[],"25":[],"26":[],"27":[],"28":[],"29":[],"30":[],"31":[],"32":[],"33":[],"34":[],"35":[],"36":[],"37":[],"38":[],"39":[],"40":[],"41":[],"42":[],"43":[],"44":[],"45":[],"46":[],"47":[],"48":[],"49":[],"50":[],"51":[],"52":[],"53":[],"54":[],"55":[],"56":[],"57":[],"58":[],"59":[],"60":[],"61":[],"62":[],"63":[],"64":[],"65":[],"66":[],"67":[],"68":[],"69":[],"70":[],"71":[],"72":[],"73":[],"74":[],"75":[],"76":[],"77":[],"78":[],"79":[],"80":[],"81":[],"82":[],"83":[],"84":[],"85":[],"86":[],"87":[],"88":[],"89":[],"90":[],"91":[],"839781960":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"954545647":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"1541732340":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"michaelxi3":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"darknightwriter":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"findlayzhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laofuwf":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lbc546":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zch-bit":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"frankelzeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhaodev":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joeymoso":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hackbl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"q815101630":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiyishuoshuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aouos":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"thinkfurther":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wengzhouyunfan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whisht":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bzlff":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzzkains":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenmengyu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uancen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nuomituxedo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhongranherz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gr52":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hydelovegood":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nikojxie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fangxianshen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jokertzw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cyang258":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kernelsue":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erikahuang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kuang-mou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iloveqier":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duke-github":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"caterpillar-0":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ashleyyma6":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuki-yzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zpc7":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yujian920":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kiirii4":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ucashurui":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xixiao51":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"feikerwu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"heng518":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yaya-bb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tlntin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richypang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fenchuiyun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jerry-lllman":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nickyk319":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"herbertpan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wsmmxmm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fan-svg":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuzejia":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunnyyujf":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"phoenixflyingsky":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nehchsuy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lzyxts":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elainekuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ll491119940":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"2learnsomething":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ataraxyadong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wzasd":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miluowzt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maylinglin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weijie-he":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brodxie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"y525":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leungogogo":[{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/4#issuecomment-3074242240","body":"## Main Idea\nFirst, it looks like we can convert the array `num` to integer and add it to `k`, but `num.length <= 1E+4` so this approach will cause integer overflow. So we will have to do the addition in array form.\n\nThen the idea is to simulate the entire process, add each digit of `num` and `k` with a `carry` bit. We will terminate the loop when we run out of digits for both `num` and `k` and `carry == 0`.\n\n## Code\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n = num.length, carry = 0, i = n - 1;\n        List<Integer> res = new ArrayList<>();\n        \n        while (i >= 0 || k > 0 || carry > 0) {\n            int kDigit = k % 10;\n            k /= 10;\n            int sum = i >= 0 ? carry + kDigit + num[i] : carry + kDigit;\n            res.add(sum % 10);\n            carry = sum >= 10 ? 1 : 0;\n            --i;\n        }\n      \n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n## Complexity Analysis\nTime: `O(2*max(N, log(K)))`\n* Given a number `K`, its length will be `O(log_{2}(K))`, the time complexity depends on the length of `N` and `K`, whichever is longer.\n* Notice we want to insert digits at the end of the array and then reverse it after we finish the addition (reverse takes `O(res.size())`). If we insert at the head of array, then it will take `O(n^2)` of time.\n\nSpace: `O(1)`, as we didn't use additional spaces except the return array.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/5#issuecomment-3077454608","body":"#### Main Idea\nThe problem asks for the shortest distance from each character in a string s to a given character c. Since c may appear multiple times, we must compute the shortest distance to any occurrence of c for each index.\n\nThe key idea is to perform two passes over the string:\n\nLeft-to-right pass: Calculate distance from the nearest c to the left.\n\nRight-to-left pass: Refine the distance by checking for any closer c on the right.\n\nBy using two passes, we can efficiently compute the minimal distance to the nearest c for each character.\n\n#### Code\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] dist = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        for (int i = 0; i < n; ++i) {\n            if (s.charAt(i) == c) {\n                dist[i] = 0;\n            } else if (i > 0 && dist[i - 1] < Integer.MAX_VALUE) {\n                dist[i] = dist[i - 1] + 1;\n            }\n        }\n\n        for (int i = n - 1; i >= 0; --i) {\n            if (i < n - 1 && dist[i + 1] != Integer.MAX_VALUE) {\n                dist[i] = Math.min(dist[i], dist[i + 1] + 1);\n            }\n        }\n\n        return dist;\n    }\n}\n```\n\n#### Complexity\nTime: `O(n)`\nSpace: `O(n)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/6#issuecomment-3082949045","body":"## Main Idea\nA stack can be implemented with an array, but usually we only have access to stack top due to encapsulation, while we can actually access/modify any elements in the array internally.\n\nWe can implement the stack API with `array`:\n* `push()`: append at the end of array (`O(1)`)\n* `pop()`: remove the end of array (`O(1)`)\n* `increment()`: use a for loop to increment `array[0:k]` (`O(k)`).\n\n### Optimization. Range Update && Lazy Evaluation\nNotice the time complexity of `increment()` is too high due to range update, and we can use a difference array to optimize it.\n\nAlso we don't really care about the values of elements until we `pop` them, so we can evaluate them when we pop them out of the stack.\n\n## Code\n```java\nclass CustomStack {\n    private Deque<Integer> stack;\n    private int[] arr;\n    public CustomStack(int maxSize) {\n        stack = new ArrayDeque<>();\n        arr = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if (stack.size() < arr.length) {\n            stack.push(x);\n        } \n    }\n    \n    public int pop() {\n        if (stack.isEmpty()) {\n            return -1;\n        }\n        int index = stack.size() - 1, ret = stack.pop() + arr[index];\n        if (index > 0) {\n            arr[index - 1] += arr[index];\n        }\n        arr[index] = 0;\n        return ret;\n    }\n    \n    public void increment(int k, int val) {\n        k = Math.min(k - 1, stack.size() - 1);\n        if (k >= 0) {\n            arr[k] += val;\n        }\n    }\n}\n```\n## Complexity Analysis\nTime: `O(1)` for all operations\nSpace: `O(n)` as we used 2 arrays.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/7#issuecomment-3087312725","body":"### Main Idea\n\nStoring everything in one stack will lead to so many pushes/pops, so we can use two stacks, one stack for string, one stack for number.\n\nIterate the input string:\n\n* If `str[i]` is a number, parse the number, push that number to number stack, and push current string to string stack, then empty the string to start over.\n* If `str[i]` is a closed bracket, then we pop the number stack to get `count`, pop the string stack to get `str`, then append the current string with `count` times to the `str`.\n* Else, append the character to current string.\n\n### Code\n\n* Java\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        int n = s.length();\n        Deque<StringBuilder> strStack = new ArrayDeque<>();\n        Deque<Integer> numStack = new ArrayDeque<>();\n        StringBuilder sb = new StringBuilder();\n        \n        for (int i = 0; i < n; i++) {\n            if (Character.isDigit(s.charAt(i))) {\n                int j = i + 1;\n                while (Character.isDigit(s.charAt(j))) {\n                    j++;\n                }\n                int count = Integer.parseInt(s.substring(i, j));\n                numStack.push(count);\n                strStack.push(sb);\n                sb = new StringBuilder();\n                i = j - 1;\n            } else if (s.charAt(i) == ']') {\n                int count = numStack.pop();\n                StringBuilder top = strStack.isEmpty() ? new StringBuilder() : strStack.pop();\n                while (count-- > 0) {\n                    top.append(sb);\n                }\n                sb = top;\n            } else {\n                if (s.charAt(i) != '[') {\n                    sb.append(s.charAt(i));\n                }\n            }\n        }\n        \n        return sb.toString();\n    }\n}\n```\n\n### Complexity Analysis\n\nTime: `O(max(k) * n)`, each digit will be pushed/popped at most `max(k)` times","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/8#issuecomment-3092141722","body":"## Main Idea\nWe can use `stack1` as the input stack, and `stack2` as the output stack. \n\n* `push()`: Push to `stack1`, so this new element will be on the stack top of `stack1` (which is the end of our queue).\n* `pop()` and `peek()`: Since we use `stack2` as our output stack, when we call `pop()` or `peek()`:\n* If `stack2` is empty, we want to move all elements from `stack1` to `stack2`, and their order will be reversed, so the bottom of `stack1` will be the top of `stack2`, which is the head of our queue.\n* If not, then we have access to the top of `stack2` already.\n\n## Code\n\n```java\nclass MyQueue {\n    Deque<Integer> stack1;\n    Deque<Integer> stack2;\n    \n    public MyQueue() {\n        stack1 = new ArrayDeque<>();\n        stack2 = new ArrayDeque<>();\n    }\n    \n    public void push(int x) {\n        stack1.push(x);\n    }\n    \n    public int pop() {\n        if (stack2.isEmpty()) {\n            move();\n        }\n        return stack2.pop();\n    }\n    \n    public int peek() {\n        if (stack2.isEmpty()) {\n            move();\n        }\n        \n        return stack2.peek();\n    }\n    \n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n    \n    private void move() {\n        while (!stack1.isEmpty()) {\n            stack2.push(stack1.pop());\n        }\n    }\n}\n```\n## Complexity Analysis\nTime:\n* `push()`: `O(1)`\n* `pop()` and `peek()`: \n\t* The **worst case** of `pop()` and `peek()` will be `O(n)`, where we have to move all elements from `stack1` to `stack2`.\n\t* **Amortized Analysis**: Say we have `n` elements in `stack1`, and `0` elements in `stack2`, and we want to call `pop()` or `peek()` `n` times. The first call will take `n` operations to move all elements from `stack2` to `stack1`. But after the first call we will have at least `n - 1` elemetns in `stack2`, which makes the next `n - 1` calls  `O(1)`. So the amrotized time will be `O(n + 1 + 1 +...+1 / n) = O((2n-1)/n) = O(1)`.\n\nSpace: `O(1)`, the two stacks are given and we didn't use any extra spaces.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/9#issuecomment-3093992695","body":"### Main Idea\nFor chunks `[c1, c2, c3, ..., cn]`, we have to maintain the property: `max(ci) <= min(cj)` if `i < j`. So we can create a monotonously increasing stack `stack` to **keep track of the max value for each previous chunk**. \n\nIf `arr[i] >= stack.peek()`, we can greedily create a new chunk and `stack.push(arr[i])`. Else, we need to find the previous chunk with max value smaller or equal to `arr[i]`, say `ck`, and we need to merge all the chunks `[c_k+1, ... c_cur]` with `arr[i]`.\n\nTo merge chunks, we can just pop all the max values representing those chunks off the stack, and push back the max among them (in our case, it will be stack top cuz this stack is increasing) as the max of the new chunk. \n\nFinally the size of the stack will be the number of chunks.\n### Code\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int n = arr.length;\n        Deque<Integer> stack = new ArrayDeque<>();\n        for (int num : arr) {\n            int max = num;\n            while (!stack.isEmpty() && stack.peek() > num) {\n                max = Math.max(max, stack.pop());\n            }\n            stack.push(max);\n        }\n        return stack.size();\n    }\n}\n```\n### Complexity Analysis\nTime: `O(n)`\nSpace: `O(n)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/10#issuecomment-3095444824","body":"\n### Main Idea\n1. Find the length of the linked list. If `length == 0`, return `head`.\n2. If `k >= n`, then we can do `k = k % n` which doesn't affect the final result but reduce the number of rotations.\n3. Use two pointers to traverse the linked list to find the last kth element and its previous node.\n4. Modify the linked list.\n\n\n### Code\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        int n = getLength(head);\n        if (n == 0) return head;\n        k %= n;\n        \n        // Find the last kth element as new head\n        ListNode fast = head, slow = head;\n        for (int i = 0; i < k; ++i) {\n            fast = fast.next;\n        }\n        \n        while (fast.next != null) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        fast.next = head;\n        ListNode newHead = slow.next;\n        slow.next = null;\n        return newHead;\n        \n    }\n    \n    private int getLength(ListNode head) {\n        int len = 0;\n        while (head != null) {\n            ++len;\n            head = head.next;\n        }\n        return len;\n    }\n}\n```\n### Complexity Analysis\nTime: `O(n)`\nSpace: `O(1)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/11#issuecomment-3100701991","body":"### Main Idea\n1. If the current list has length smaller than 2, don't need to swap.\n2. Else, recursivly swap the list `head.next.next`, and the swap function should return the `next` node.\n3. Swap the current 2 nodes, `newHead = head.next`, `newHead.next = head` and `head.next = next`.\n\n### Code\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode next = swapPairs(head.next.next);\n        ListNode newHead = head.next;\n        newHead.next = head;\n        head.next = next;\n        return newHead;\n    }\n}\n```\n\n### Complexity Analysis\n* Time: `O(n)`\n* Space: `O(n)` for the recursive call.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/12#issuecomment-3109183645","body":"### Main Idea\n1. Define `inOrder(int i, int j)` to be the problem of  the converting `list[i:j]` to BST.\n2. Base case: if `i > j`, return `null`.\n3. Calculate `mid = i + (j - i) / 2`, left subtree will be `inOrder(i, mid - 1)`, and then we create our root with the current node `cur`, then the next node to create will be `cur.next`, and we build the right sutree with `inOrder(mid + 1, j)`.\n\n### Code\n```java\nclass Solution {\n    private ListNode cur;\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n        cur = head;\n        int n = getLength(head);\n        return inOrder(0, n - 1);\n    }\n\n    private TreeNode inOrder(int l, int r) {\n        if (l > r) return null;\n        int m = l + (r - l) / 2;\n        TreeNode left = inOrder(l, m - 1);\n        TreeNode root = new TreeNode(cur.val);\n        cur = cur.next;\n        TreeNode right = inOrder(m + 1, r);\n        root.left = left;\n        root.right = right;\n        return root;\n    }\n\n    private int getLength(ListNode head) {\n        int cnt = 0;\n        while (head != null) {\n            head = head.next;\n            ++cnt;\n        }\n        return cnt;\n    }\n}\n```\n### Complexity Analysis\nTime: `O(n)`\nSpace: `O(logn)` for recursive calls.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/13#issuecomment-3112278406","body":"Say the length of `a_1` to `a_i` is `a`, `b_1` to `b_i` is `b`, and `c_1` to `c_n` is `c`. If there is no interseciton, then `c = 0`. And `a + b = b + a`. If there is an intersection, then `a + c + b = b + c + a`, and the two pointers will meet at the intersection point.\n```\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode h1 = headA, h2 = headB;\n        while (h1 != h2) {\n\n            h1 = h1 == null ? headB : h1.next;\n            h2 = h2 == null ? headA : h2.next;\n        }\n        return h1;  \n    }\n```\n\nSo we can just go over both linked list once, and switch the pointers.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/14#issuecomment-3118087746","body":"### Main Idea\nDefine two pointers `fast` and `slow`, each iteration, `fast` moves 2 steps forward while `slow` moves 1 step. If there is a cycle, then `fast` will equals `slow` eventually, and if not, we will exit the loop.\n\nIf a cycle is detected, we need to find the starting point. \n\n```\nfast = 2 * slow\n\nfast = l + n1 * c + t\nslow = l + n2 * c + t\n\n\nl + n1 * c + t = 2 * l + 2 * n2 * c + 2 * t\nl = n1 * c - 2 * n2 * c = c * (n1 - 2 * n2) = n' * c - t\n```\n\n```\n     L\n--------   ----I-----\n           |         | D\n           ----------\n```\n### Code\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null) return null;\n        ListNode fast = head, slow = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) {\n                while (slow != head) {\n                    slow = slow.next;\n                    head = head.next;\n                }\n                return head;\n            }\n        }\n        return null;\n    }\n}\n```\n### Complexity Analysis\nTime: `O(n)`\nSpace: `O(1)`","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/17#issuecomment-3126063970","body":"### Main Idea\n* Base case 1, both `p` and `q` are `null`, return `true`.\n* Base case 2, else if either of them is `null` or their values are not equal, return `false`.\n* Recursive case: both left and right subtrees are equal.\n\n### Code\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        } else if (p == null || q == null || p.val != q.val) {\n            return false;\n        }\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n```\n\n### Complexity Analysis\nTime: `O(n)`\nSpace: `O(h) = O(n)`","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/19#issuecomment-3136827599","body":"### Main Idea\nThis problem is asking for the leftmost node of the last layer, and when it comes to traversal by layer, BFS comes in handy.\n\nIn a standard BFS algorithm, we use a queue to keep track of the nodes on each layer, we just need to modify the algorithm to record the first node of the current layer, and if we exit the loop from the current layer, that means this is the last layer, and the node we recorded will be the one we want to find.\n\n### Code\n```java\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        Queue<TreeNode> q = new ArrayDeque<>();\n        q.offer(root);\n        int res = 0;\n        while (!q.isEmpty()) {\n            res = q.peek().val;\n            int size = q.size();\n            for (int i = 0; i < size; ++i) {\n                TreeNode n = q.poll();\n                if (n.left != null) q.offer(n.left);\n                if (n.right != null) q.offer(n.right);\n            }\n        }\n        return res;\n    }\n}\n```\n### Complexity Analysis\nTime: `O(n)`\nSpace: `O(n)`","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/21#issuecomment-3144871038","body":"### main Idea\n1. We store `Pair<TreeNode, int[]>` in our pq, where `TreeNode` is the node and `int[]` is its coordinate.\n2. Since we want to maintain the row order, we compare pairs by their row order, smaller row has higher priority.\n3. If row numbers are the same, we compare values, since we don't really care about the order we process columns each row.\n4. Use a map that maps `col` to `list` to store the node values.\n\n\n### Code\n* Java\n\n```java\nclass Solution {\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        // column -> list\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        PriorityQueue<Pair<TreeNode, int[]>> queue = new PriorityQueue<>((p1, p2) -> {\n            int loc1[] = p1.getValue();\n            int loc2[] = p2.getValue();\n            if (loc1[0] == loc2[0]) {\n                return p1.getKey().val - p2.getKey().val;\n            } else {\n                return loc1[0] - loc2[0];\n            }\n        });\n        queue.offer(new Pair(root, new int[] {0, 0}));\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; ++i) {\n                Pair<TreeNode, int[]> p = queue.poll();\n                TreeNode node = p.getKey();\n                int loc[] = p.getValue();\n                List<Integer> list = map.getOrDefault(loc[1], new ArrayList<>());\n                list.add(node.val);\n                map.put(loc[1], list);\n                if (node.left != null) {\n                    queue.offer(new Pair(node.left, new int[] {loc[0] + 1, loc[1] - 1}));\n                }\n\n                if (node.right != null) {\n                    queue.offer(new Pair(node.right, new int[] {loc[0] + 1, loc[1] + 1}));\n                }\n            }\n        }\n\n        List<List<Integer>> res = new ArrayList<>();\n        for (int i = -1000; i <= 1000; ++i) {\n            if (map.containsKey(i)) {\n                res.add(map.get(i));\n            }\n        }\n        return res;\n    }\n}\n```\n### Complexity Analysis\nTime: `O(nlogn)`\nSpace: `O(n)`","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/27#issuecomment-3162435845","body":"```java\nclass Solution {\n    public int minSubarray(int[] nums, int p) {\n        int n = nums.length;\n        long arraySum = Arrays.stream(nums).asLongStream().sum(); \n        int targetRemainder = (int) (arraySum % p);\n        if (targetRemainder == 0) {\n            return 0;\n        } else if (arraySum < p) {\n            return -1;\n        }\n        \n        Map<Integer, Integer> remainderToIndex = new HashMap<>();\n        remainderToIndex.put(0, -1);\n        \n        long preSum = 0;\n        int minLen = Integer.MAX_VALUE;\n        for (int i = 0; i < n; ++i) {\n            preSum += nums[i];\n            int remainder = (int) (preSum % p);\n            int remainderToCheck = (int) (remainder - targetRemainder);\n            if (remainderToCheck < 0) {\n                remainderToCheck += p;\n            }\n            \n            if (remainderToIndex.containsKey(remainderToCheck)) {\n                int index = remainderToIndex.get(remainderToCheck);\n                minLen = Math.min(minLen, i - index);\n            }\n            \n            remainderToIndex.put(remainder, i);\n        }\n        \n        return minLen >= n ? -1 : minLen;\n    }\n}\n\n/*\n    [3, 1, 4, 2], p = 6\n    \n    arraySum = 10, targetRemainder = 4\n    \n    preSum = 3,\n\n    [3, 1, 4, 2] = 10\n    \n    [0, 3, 4, 8, 10]\n    \n    [7, ]\n    \n    Sum: 9 p=6\n    \n    a mod b = (a + b) mod b\n    \n    (S_j - S_i) mod p == sum mod p\n    \n    \n    x mod p = a\n    y mod p = b\n    \n    (x - y) mod p =  a - b (if a >= b)\n                     a - b + p (if a < b)\n*/\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/33#issuecomment-3182362544","body":"## Method 1. BFS\n### Main Idea\nBasically, this problem is asking if we can mark the graph with 2 colors, where adjacent vertices can't have the same color.\n\nSo we can apply BFS to traverse the graph, say we mark a vertex `v` with color 1, then we have to mark all its neighbors with color 2. If any of them was marked color 1, then we know it's impossible to mark the graph with 2 colors, so we can return `false`.\n\nIf no such contradictions found, that means the graph can be 2-colored, so return `true`.\n### Code\n* Java\n\n```java\nclass Solution {\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        List<Integer>[] graph = new ArrayList[n + 1];\n        for (int i = 0; i <= n; ++i) graph[i] = new ArrayList<>();\n        \n        for (int[] edge : dislikes) {\n            graph[edge[0]].add(edge[1]);\n            graph[edge[1]].add(edge[0]);\n        }\n        \n        int[] colors = new int[n + 1];\n        for (int i = 1; i <= n; ++i) {\n            if (colors[i] != 0) continue;\n            Queue<Integer> q = new ArrayDeque<>();\n            q.offer(i);\n            colors[i] = 1;\n            while (!q.isEmpty()) {\n                int size = q.size();\n                while (size-- > 0) {\n                    int v = q.poll(), c = colors[v];\n                    for (int nei : graph[v]) {\n                        if (colors[nei] == c) return false;\n                        if (colors[nei] != 0) continue;\n                        colors[nei] = -1 * c;\n                        q.offer(nei);\n                    }\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n### Complexity Analysis\nTime: `O(E + V)`\n\nSpace: `O(E + V)`","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suukii":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mirrors-cl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqy97":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jakkiabc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyoneday":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chouqin99":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhaogeg111":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnhu23":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ye2222":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uyplayer":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guixian001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"serena9":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"junzmer":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hx-code":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"admu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxiaomm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pgquestions":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eldinzhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiangwenzhe":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnwu6688":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tomtao626":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aiweng1981":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richard-lime":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"acoada":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duanyaqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ccslience":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaiykk":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cachezhou0617":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangtuo1999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cytrue":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyryan-web":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"naomiwufzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuajingliu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miss1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"johnxizhao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"incipe-win":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"revisegoal":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckysq999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dereklisdr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"perfqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mryao1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"likeyousmile":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhg1992":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liquanluo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aq666888":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"samlu-ecnu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhongxiangxiang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hatorimain":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"neado":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaojunjun1110":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wxleah":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunl1ght":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kerrhl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"orangejuz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flyzenr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"c1f2h3":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dlm001128":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuxy94":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aconcert":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linjunhe":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyqqq22":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yibenxiao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elon-lau":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nowkizzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gsgtgyb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"irenia111":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suiyi8760":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"saltychess":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rabbit2010520":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ellie-wu05":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yopming":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckytwj":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzz607":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zoulufeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxoojs":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"okkband":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wyz999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hacker90":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ricjli":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luhaoling":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flaming-cl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gelxgx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gaominghao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jessie725":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lsunxh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lanceli424":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qycoder":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qilin88":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hengheng-yun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"smz1995":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"size-of":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moyuanhua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"9vivian88":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guxuehua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kirosola":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biscuit279":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maoting":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"youzhaing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jawn-ha":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hanwangxxx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dujt-x":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"degndaixingqiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gzgzgzgzgzgz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gentleman-goodman":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xinyi-arch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zenwangzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"andyyxw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fourierhai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yangz001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mannnn6":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"haoyangxie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chjillout":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wenjialu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mhcn":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"coconutice":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jackgaoyuan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhan0312":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yufeng727":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fontendart":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yingchehu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cobayaz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tomato-tomato":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xfliudx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"djd28176":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xilutian":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xy147":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/8#issuecomment-3091443042","body":"### js代码\n```JavaScript\n\nvar MyQueue = function() {\n    this.inStack = [];\n    this.outStack = [];\n};\nMyQueue.prototype.push = function(x) {\n    this.inStack.push(x);\n};\n\nMyQueue.prototype.pop = function() {\n    if (!this.outStack.length) {\n        this.in2out();\n    }\n    return this.outStack.pop();\n};\n\nMyQueue.prototype.peek = function() {\n    if (!this.outStack.length) {\n        this.in2out();\n    }\n    return this.outStack[this.outStack.length - 1];\n};\n\nMyQueue.prototype.empty = function() {\n    return this.outStack.length === 0 && this.inStack.length === 0;\n};\n\nMyQueue.prototype.in2out = function() {\n    while (this.inStack.length) {\n        this.outStack.push(this.inStack.pop());\n    }\n};\n\n```\n\n### 复杂度分析\n时间复杂度：O(1)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/15#issuecomment-3120847716","body":"```\nclass ListNode {\n  constructor(key, value) {\n    this.key = key\n    this.value = value\n    this.next = null\n    this.prev = null\n  }\n}\n\nclass LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity\n    this.hash = {}\n    this.count = 0\n    this.dummyHead = new ListNode()\n    this.dummyTail = new ListNode()\n    this.dummyHead.next = this.dummyTail\n    this.dummyTail.prev = this.dummyHead\n  }\n\n  get(key) {\n    let node = this.hash[key]\n    if (node == null) return -1\n    this.moveToHead(node)\n    return node.value\n  }\n\n  put(key, value) {\n    let node = this.hash[key]\n    if (node == null) {\n      if (this.count == this.capacity) {\n        this.removeLRUItem()\n      }\n      let newNode = new ListNode(key, value)\n      this.hash[key] = newNode\n      this.addToHead(newNode)\n      this.count++\n    } else {\n      node.value = value\n      this.moveToHead(node)\n    }\n  }\n\n  moveToHead(node) {\n    this.removeFromList(node)\n    this.addToHead(node)\n  }\n  \n  removeFromList(node) {\n    let temp1 = node.prev\n    let temp2 = node.next\n    temp1.next = temp2\n    temp2.prev = temp1\n  }\n\n  addToHead(node) {\n    node.prev = this.dummyHead\n    node.next = this.dummyHead.next\n    this.dummyHead.next.prev = node\n    this.dummyHead.next = node\n  }\n\n  removeLRUItem() {\n    let tail = this.popTail()\n    delete this.hash[tail.key]\n    this.count--\n  }\n\n  popTail() {\n    let tail = this.dummyTail.prev\n    this.removeFromList(tail)\n    return tail\n  }\n}\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/22#issuecomment-3146107002","body":"```const twoSum = (nums, target) => {\n  const prevNums = {};\n\n  for (let i = 0; i < nums.length; i++) {\n    const curNum = nums[i];\n    const targetNum = target - curNum;\n    const targetNumIndex = prevNums[targetNum];\n    if (targetNumIndex !== undefined) {\n      return [targetNumIndex, i];\n    } else {\n      prevNums[curNum] = i;\n    }\n  }\n}```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/28#issuecomment-3167532564","body":"### js代码\n```JavaScript\nvar middleNode = function(head) {\n    let slow = fast = head\n    while(fast && fast.next){\n        slow = slow.next\n        fast = fast.next.next\n    }\n    return slow\n};\n\n```\n\n### 复杂度分析\n时间复杂度：O(N)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/35#issuecomment-3190926614","body":"### js代码\n```JavaScript\nvar judgeCircle = function(moves) {\n  return moves.split('L').length === moves.split('R').length && moves.split('U').length === moves.split('D').length\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"itsjacob":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shunanch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yppah-eb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"raychenlei":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"woshichuanqilz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"willuuu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"christina-soda":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jia98shanliang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"user-vannnn":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tobepellucid":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"johnvsd":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yueza":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawyuan97":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"victorhuang99":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cusanity":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jay-xzj":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiradaone":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xinyue-ma":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taojin1992":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joyce94":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"steven72574":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tian-pengfei":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asuka1h":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaowangcoding":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"james0608":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaneyang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"azl397985856":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whgsh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chengfengfengwang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bulingbulingbuling":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"c2tr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eden-ye":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"codingtrains":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"starorbiting":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mo-xiaoxiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"passengersa":[{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/4#issuecomment-3073445770","body":"思维：\n1、将数组num和k转换为字符，\n2、使用BigInt方法相加\n3、最后使用将相加得到转换为数字数组\n时间复杂度：O(n)\n代码：\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n    let numStr = num.join('')\n    let sum = BigInt(numStr) + BigInt(k)\n    return sum.toString().split('').map(Number)\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/6#issuecomment-3084084442","body":"时间复杂度：O(n)\n代码：\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n     if (this.stack.length < this.maxSize) {\n            this.stack.push(x);\n        }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (this.stack.length === 0) {\n            return -1;\n        }\n        return this.stack.pop();\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n     const len = this.stack.length;\n        const count = Math.min(k, len);\n        for (let i = 0; i < count; i++) {\n            this.stack[i] += val;\n        }\n};\n\n/** \n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/10#issuecomment-3097108121","body":"思路：\n首先，计算链表的长度 n。\n接着，将 k 对 n 取模，因为旋转 n 次后链表会回到原来的状态，所以取模可以避免不必要的旋转操作。\n然后，找到新的链表头节点和尾节点。新的链表头节点是原链表中第 n - k 个节点，新的链表尾节点是原链表的最后一个节点。\n最后，将原链表的尾节点连接到原链表的头节点，形成一个环形链表，再从新的链表头节点处断开，得到旋转后的链表。\n时间复杂度：O(n)，其中 n 是链表的长度。需要遍历链表两次，第一次计算链表的长度，第二次找到新的链表头节点的前一个节点。\n代码：\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n // 定义链表节点类\nclass ListNode {\n    constructor(val = 0, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n      if (!head || !head.next) return head;\n\n    // 计算链表的长度\n    let n = 1;\n    let tail = head;\n    while (tail.next) {\n        tail = tail.next;\n        n++;\n    }\n\n    // 对 k 取模\n    k %= n;\n\n    // 如果 k 为 0，说明不需要旋转，直接返回原链表\n    if (k === 0) return head;\n\n    // 找到新的链表头节点的前一个节点\n    let newTail = head;\n    for (let i = 0; i < n - k - 1; i++) {\n        newTail = newTail.next;\n    }\n\n    // 新的链表头节点\n    let newHead = newTail.next;\n\n    // 断开原链表，形成新的链表\n    newTail.next = null;\n    tail.next = head;\n\n    return newHead; \n};\n\n// 辅助函数：将数组转换为链表\nfunction arrayToList(arr) {\n    if (arr.length === 0) return null;\n    let head = new ListNode(arr[0]);\n    let current = head;\n    for (let i = 1; i < arr.length; i++) {\n        current.next = new ListNode(arr[i]);\n        current = current.next;\n    }\n    return head;\n}\n\n// 辅助函数：将链表转换为数组\nfunction listToArray(head) {\n    let result = [];\n    let current = head;\n    while (current) {\n        result.push(current.val);\n        current = current.next;\n    }\n    return result;\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shellylcooper":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"testplm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tom-zhouch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"skylarxu214":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taihui":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huaxueguakele":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yang-chenyu104":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mlking15":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"-3":[],"cyonline":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rzhao010":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zywang0":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jetery":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"klspta":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bookyue":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jancerwu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"buer1121":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ceramickitten":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gg925407590":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alyenor":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenming-cao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ggohem":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dark-volute":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ronething":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jmastella":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"paopaohua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dd2001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mayloveless":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuexi001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nineis7":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"abby-xu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gsw9818":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaomingshixiaotang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"snmyj":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flipn9":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wabw1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqmmy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a-pricity":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sclihuiming":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"amazeding":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"astrking":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tzuikuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ringo1597":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brucezhang-utf-8":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luanxing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moin-jer":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lihua1997":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cuizezhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xuanaxuan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tiandao043":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"restlessbreeze":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ruikiwi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huiminren":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"saitochen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wtdcai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"albert556":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wuxiaoshawn":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zrtch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhuzhu096":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whoam-challenge":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weisday":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"syh-coder":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaaller":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kyrie96521":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cavecrypto":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cxgbro":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erjian96":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a-polarbear":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alexno1no2":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yetfan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhiyuanpeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bwspsu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"arinzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mdge":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"allenfeng666":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yin02":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elsa-zhang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asur4s":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"littlesugarman":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhihaowan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"apockira":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guowei0223":[null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/5#issuecomment-3077086971","body":"```\n首先需要找到所有c出现的index，存在c_index list里为后续的pointer搜索做好准备\npointer = 0  定义好pointer的起点\n遍历s，在c_index的范围内，对比pointer和pointer + 1 和s中各个位置的绝对距离，如果发现pointer和s的距离大于pointer +1，那么说明s的index已经走到了离pointer+1更近的距离，那么这时候我们更新pointer，+ 1， 指到下一个c_index中c的位置。\nres.append（）c_index中pointer和s中index的距离\n\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        c_index = []\n        for i in range(len(s)):\n            if s[i] == c:\n                c_index.append(i)\n        pointer = 0\n        res = []\n        for i in range(len(s)):\n            if pointer < len(c_index) -1:\n                if abs(i-c_index[pointer])> abs(i-c_index[pointer+1]):\n                    pointer += 1\n            res.append(abs(i-c_index[pointer]))\n        return res\n\n因为用了指针，所以时间复杂度 O（n)。 空间复杂度 O（n)。 \n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/7#issuecomment-3087516204","body":"```\n使用栈的经典题型。遇见数字就num*10 + item处理。 遇见【 左括号说明要开始处理括号内部，用stack先存好之前已经处理的结果，遇见】后括号说明括号完成，则需要stack。pop()出保存的结果加上括号里的内容。是字母的话，则res+ item更新括号内信息。\n空间复杂度 O（n）\n时间复杂度 O（n）\n\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        res = \"\"\n        stack = []\n        num = 0\n        for item in s:\n            if item.isdigit():\n                num = num * 10 + int(item)\n            elif item == \"[\":\n                stack.append([num, res])\n                num = 0\n                res = \"\"\n            elif item == \"]\":\n                pre_num, pre_res = stack.pop()\n                res = pre_res + pre_num * res\n            else:\n                res += item\n        return res\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/11#issuecomment-3101341120","body":"还是链表的老套路，设置一个dummy head。 判断cur.next and cur.next.next: 是否存在，存在了再进行下一步。\n用tmp，tmp1 来保存cur。next和cur.next.next.next。 然后我们开始进行交换步骤。\n\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy_head = ListNode(next =head)\n        cur = dummy_head\n        while cur.next and cur.next.next:\n            temp = cur.next\n            temp1 = cur.next.next.next\n            cur.next = cur.next.next\n            cur.next.next = temp\n            temp.next = temp1\n            cur = cur.next.next\n        return dummy_head.next\n\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/17#issuecomment-3125611734","body":"可以利用bfs的方法解决。 把每个点放入queue中，然后popleft（）两个node进行比较。\n\n```\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        \n        que = deque([p,q])\n        \n        while que:\n            cur1 = que.popleft()\n            cur2 = que.popleft()\n            if not cur1 and not cur2:\n                continue\n\n            if not cur1 or not cur2 or cur1.val != cur2.val:\n                return False\n            \n            que.append(cur1.left)\n            que.append(cur2.left)\n            que.append(cur1.right)\n            que.append(cur2.right)\n        return True\n\n```\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/24#issuecomment-3148705374","body":"```\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ans = 0\n        for x1, y1 in points:\n            cnt = defaultdict(int)\n            for x2, y2 in points:\n                d2 = (x1 - x2) ** 2 + (y1 - y2) ** 2\n                ans += cnt[d2] * 2\n                cnt[d2] += 1\n        return ans\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shuqianyang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sj941127":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zjsuper":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yongxi-zhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"darwintk":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"h-steven":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mischaqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wurongronga":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miduoliu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyshenzhengkang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"y4h2":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yoco323":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"forschers":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shanshuiqiankun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"annabellhyx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hwfrankfung":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"frederickfan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huibinny":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ggmybro":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"myleetcodejourney":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"want2333":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"staringwhere":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"allenfeng8":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ryanbaiyansong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dou-yu-xuan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyxupup":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cs12300":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chiehw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aesir-idun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaldsk12":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hxj2001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"for123s":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzhilin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yfu6":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mengsixing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"import-ant":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joriscai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangqianqian202301":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"airwalkers":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhumengcheng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kofzhang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leonalhq":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hjy-u":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"csthaha":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zepherust":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"feefeefee":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hughlin07":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huizsh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chanceyliu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hshen11":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"horace7":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangzh0114":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dragonfcl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huifeng248":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sarah11qing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"el1as7":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zcytm3000":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pangjiadai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xb798298436":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ywang525":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"limbo42":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dorapocket":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zoeyzyzyzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jasonqiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lp1506947671":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"texamc2":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joemonkeylee":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"northseacoder":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dominique9898":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wl678":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"meisgithub":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sye9286":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fuku-l":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kangliqi1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richardtaok":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chocolate-emperor":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lydia61":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangjiahuan17":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"seanutf":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangyong-hub":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erquaner":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiujingxukong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"x1aox1a":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"drinkmorekaik":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dinjufen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuzmt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"munmust":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yan-jie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hktangshuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zpbc007":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linlizzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"krabbejing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"firehaosky":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chao-cc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jinjin680":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cruiseyugh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"quieter2018":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jadeliu13":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaoq777":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiangyanlineu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuxiner":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yufanzh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"franciszq":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kangqinsen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"manwzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jerry9926":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"soso1105":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pkuphy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhenya-zhu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wty9sky":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"skyoct":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bingzxy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaodingc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jyjsunny":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aoxiangw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"enrilwang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aswrise":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aneureka":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ljqchlsw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jingyuzhou123":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dianlandu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jameswangxin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhenxied":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nuozhouzhang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shin-guid":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bochengwan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kyo-tom":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uratora":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guitarys":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sosdogecoin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zol013":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lrwhc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wwewwt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cyk1337":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangyu1131":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"diana21170648":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"61hhh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"quaaaaaack":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"acy925":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bi9potato":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guangsizhongbin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhaoygcq":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"catkathy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yqycs":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhuxinyu-znb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"freesan44":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mo660":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sencc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"randong22":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"beginner-jamji":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yzhyzhyzh123":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunstrongchina":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dongzegithub":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"metsystem":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miller-em":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dorian-byte":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yizhewill":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qiaojunch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhouliuhuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"beanza":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kingxiaozhe":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ygnauh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wzbwzt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iambigchen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weiboshi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"master-guang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jennyjgao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangjay408":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chang-you":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rocjemaintiendrai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ainfinitedz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"christ36":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hengistchan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huiyingc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"andyli4":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"momogir":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jamjid":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"freeroo2":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ycan253":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laurallalala":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"danielyan86":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rennzhang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"larscheng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qingkediguo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"adfvcdxv":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"javajianghu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chloe-c11":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"verkru":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eggeggliu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dr-kkk":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jinhma":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"emergence23":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"0christ1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"junru281":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joe-the-plumber":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jsaki":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"witerth":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ludwig-ll":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luster-lyl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"smallppgirl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"realduxy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"awilekong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wwz223":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangjinzhepro":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"atom-set":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"coderxiaowq":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hillsonziqiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alexzhang-mini":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xil324":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bordergong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hawkins-hjq":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cathyshang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"greyqt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yanglimbo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rao-qianlin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dtjk":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"martina001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lxy1108":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"franklinsworld666":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brainlds":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huamulanyyds":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eclairs46":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maike-hps":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sanjiu81":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qinmengx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yashuning":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luzhaofeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lizhao-liu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yukibei":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hermione666":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yyyyytc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zin-next":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pandapls":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jackinai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"godkun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dadahui":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"akxuan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fightforcoding":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jialigogogo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"celestexiong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zjy-debug":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"peggyhao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sleepydog25":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"edwineo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"panfx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liudi9047":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"allanli-lhh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xchen172":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qiaoeve":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tangyi23":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shangjiaw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tongxw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"haodongwang1995":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shuichicx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qunshanhe":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hebingliang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"baiqz":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/8#issuecomment-3092397229","body":"\n### 思路：\n通过元素在栈之间的转移来模拟队列的先进先出。\n\n\n```python\nclass MyQueue:\n    \"\"\"使用两个栈实现的队列类\"\"\"\n\n    def __init__(self):\n        # 初始化两个栈：stack_in 用于入队操作，stack_out 用于出队操作\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x: int) -> None:\n        \"\"\"将元素 x 添加到队列的尾部\n        直接将元素压入 stack_in\n        \"\"\"\n        self.stack_in.append(x)\n\n    def pop(self) -> int:\n        \"\"\"移除并返回队列头部的元素\n        1. 如果 stack_out 为空，将 stack_in 中的所有元素弹出并压入 stack_out\n        2. 这样能确保元素以先进先出的顺序出栈\n        3. 弹出 stack_out 的栈顶元素\n        \"\"\"\n        if not self.stack_out:\n            while self.stack_in:\n                self.stack_out.append(self.stack_in.pop())\n        return self.stack_out.pop()\n\n    def peek(self) -> int:\n        \"\"\"返回队列头部的元素，但不删除它\n        复用 pop 方法获取队首元素，然后将其压回 stack_out 以保持队列状态不变\n        \"\"\"\n        res = self.pop()\n        self.stack_out.append(res)\n        return res\n\n    def empty(self) -> bool:\n        \"\"\"检查队列是否为空\n        当且仅当两个栈都为空时，队列为空\n        \"\"\"\n        return not (self.stack_in or self.stack_out)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaogaoddd":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tuuna":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lxy12l":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chxbilly":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sentiy-hub":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fea1220":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wtbkevin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"awenbocc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hallcia":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huzhipeng-hu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tongtz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lindo146":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"heye0507":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lmw6412036":[{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/1#issuecomment-3072932165","body":"@azl397985856 需要建day1啦","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/5#issuecomment-3076893308","body":"## 思路1\n\n枚举每个普通字符，分别找到其左侧，右侧**最近**特殊字符的位置，求出距离，并取最小值。\n\n1. 预处理每个特殊字符的位置，保存至数组data;\n2. 枚举每个普通字符，在data中查找其左侧，右侧**最近**特殊字符的位置，求出距离，并取最小值。查找过程用可以**二分**实现，也可以用\n   **单个指针记录最后一次位置**实现;\n3. 返回结果。\n\n## 思路1代码\n\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function (s, c) {\n        let n = s.length, data = [];\n        for (let i = 0; i < n; i++) {\n            if (s[i] === c) data.push(i);\n        }\n\n        // 双指针\n        // left 左侧最近的c索引\n        // right 右侧最近的c索引 right = left + 1\n        let left = -1, right = -1, m = data.length;\n        let ans = new Array(n).fill(0);\n        for (let i = 0; i < n; i++) {\n            let char = s[i];\n            if (char === c) continue;\n\n            let ldis = Infinity, rdis = Infinity;\n            // 在data中寻找左侧最近的c索引\n            // left 指针移动的条件：data[left + 1] < i，确保data[left] 是在i的左侧，距离i更近\n            while (left + 1 < m && data[left + 1] < i) left++;\n            if (left >= 0) ldis = i - data[left];\n            \n            right = left + 1;\n            if (right < m) rdis = data[right] - i;\n            ans[i] = Math.min(ldis, rdis);\n        }\n        return ans;\n    };\n```\n\n## 思路1复杂度分析\n\n- 时间复杂度：O(n + m)，n为字符串s的长度，m为data的长度，遍历字符串s2次,left也只是从左往右移动一次，为O(m)，所以总的时间复杂度为O(n + m)。\n- 空间复杂度：O(m)，m为data的长度，不考虑返回值的话，需要一个额外的长度为m的数组来保存c的位置，所以空间复杂度为O(m)；考虑返回值，需要一个额外的长度为n的数组来保存结果，间复杂度为O(n)。\n\n---\n\n## 思路2\n\n也可以枚举每个特殊字符c的位置，处理c往左、往右能覆盖的普通字符，记录每个普通字符的最小值即可。\n\n1. 预处理每个特殊字符的位置，保存至数组data;\n2. 从左往右遍历data，处理每个特殊字符c左侧的普通字符的距离，保存至数组答案ans；可以使用思路1单指针记录最后一个位置的方式，降低时间复杂度；具体可以看代码；\n3. 从右往左遍历data，处理每个特殊字符c右侧的普通字符的距离，与答案ans对应位置比较，取最小值;\n4. 返回答案ans。\n\n## 思路2代码\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function (s, c) {\n        let n = s.length, data = [], ans = new Array(n).fill(Infinity);\n        for (let i = 0; i < n; i++) {\n            if (s[i] === c) {\n                ans[i] = 0;\n                data.push(i);\n            }\n        }\n\n        const m = data.length;\n\n        // 从左往右遍历\n        let left = 0;//从左往右开始，第一个普通字符的索引\n        for (let j of data) {\n            while (left < n && s[left] === c) left++;\n            while (left < n && s[left] !== c && left < j) {\n                // console.log('处理left',left,j);\n                ans[left] = Math.min(ans[left], j - left);\n                left++;\n            }\n        }\n\n        // 从右往左遍历\n        let right = n - 1;// 从右往左开始，第一个普通字符的索引\n        for (let i = m - 1; i >= 0; i--) {\n            let j = data[i];\n            while (right >= 0 && s[right] === c) right--;\n            while (right >= 0 && s[right] !== c && right > j) {\n                ans[right] = Math.min(ans[right], right - j);\n                right--;\n            }\n        }\n        return ans;\n    };\n```\n## 思路2复杂度分析\n\n- 时间复杂度：O(n + m)，n为字符串s的长度,遍历字符串s1次,遍历data两次,left、right也只是各移动一次，所以总的时间复杂度为O(n + m)。\n- 空间复杂度：O(m)，m为data的长度，不考虑返回值的话，需要一个额外的长度为m的数组来保存c的位置，所以空间复杂度为O(m)；考虑返回值，需要一个额外的长度为n的数组来保存结果，间复杂度为O(n)。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/6#issuecomment-3082655797","body":"## 思路1\n这是一个典型的栈设计题，数据规模不大的情况下，按照常规操作即可。可以使用数组或链表来存储。\n## 代码1\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.data = []\n    this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.data.length < this.maxSize) this.data.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.data.length === 0) return -1;\n    return this.data.pop(); \n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let n = this.data.length;\n    for(let i = 0;i < k;i++){\n        if(i < n) this.data[i] += val;\n        else break;\n    }\n};\n\n/** \n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n## 复杂度分析1\n* 时间复杂度：O(n*k)。n表示操作次数。插入和删除的时间复杂度都是O(1)，每次increment都要遍历数组，时间复杂度是O(k)；所以总的复杂度为O(n*k)。\n* 空间复杂度：O(n)。n为maxSize。\n---\n## 思路2\n如果k较大，increment是个非常耗时的操作，所以我们需要优化increment的操作。\n优化思路：increment是批量更新的，可以用差分数组来实现。但是又要支持高效的查询与删除操作，所以可以用树状数组来维护这个差分数组。\n## 代码2\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n    this.cnt = 0;\n    this.data = new Array(maxSize + 1).fill(0);\n    this.maxSize = maxSize;\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n    if (this.cnt === this.maxSize) return;\n    this.cnt++;\n    this.update(this.cnt - 1, x);\n    if(this.cnt <= this.maxSize - 1) this.update(this.cnt, -x);\n    //console.log('push ',x,this.data);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n    if(this.cnt === 0) return -1;\n    let ans = this.query(this.cnt - 1);\n    this.update(this.cnt - 1, -ans);\n    if(this.cnt <= this.maxSize - 1) this.update(this.cnt,ans);\n    this.cnt--;\n    //console.log('pop ',ans,this.data);\n    return ans;\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n    if(this.cnt === 0) return;\n    this.update(0, val);\n    let r = Math.min(k,this.maxSize,this.cnt);\n    if(r <= this.maxSize - 1) this.update(r,-val);\n};\n\n\nCustomStack.prototype.query = function (i) {\n    i = i + 1;\n    let ans = 0;\n    while (i) {\n        ans += this.data[i];\n        i -= this.lowbit(i);\n    }\n    return ans;\n}\n\nCustomStack.prototype.update = function (i, val) {\n    i = i + 1;\n    while (i <= this.maxSize) {\n        this.data[i] += val;\n        i += this.lowbit(i);\n    }\n}\n\n\nCustomStack.prototype.lowbit = function (i) {\n    return i & (-i);\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n```\n\n## 复杂度分析2\n* 时间复杂度：O(n*log(maxSize))。n表示操作次数。插入、删除、批量更新的时间复杂度都是O(log(maxSize))；所以总的复杂度为O(n*log(maxSize))。\n* 空间复杂度：O(n)。n为maxSize。\n---\n## 思路3\n有没有保持插入，删除O(1),批量更新O(1)的算法呢？官方题解给出了一个懒删除的技巧。小伙伴们可以尝试一下。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/7#issuecomment-3087040795","body":"## 思路一：栈\n这是一个典型的括号匹配问题，可以用栈来解决。  \n步骤：\n1. 创建一个栈sStack，栈顶元素标示当前答案，初始元素为空字符串；\n2. 创建一个栈nStack，存储需要重复的数字k；\n3. 声明一个全局变量num，用来记录数字。遍历字符串：\n    1. 如果当前字符为数字，追加到num中；\n    2. 如果当前字符为左括号，将num压入栈nStack，将一个新的空字符串压入栈sStack，并清空num。**遇到左括号表示要开启新一轮的字符串重复过程，因此数字栈压入需要重复的数字k，字符串栈压入一个空字符串来存储本轮重复过程产生的答案**；\n    3. 如果当前字符为字母，追加到栈sStack的栈顶元素中；\n    4. 如果当前字符为右括号，取出栈sStack的栈顶元素s，取出栈nStack的栈顶元素k，s重复k次；并追加到栈sStack的栈顶元素中。**遇到右括号表示本轮重复过程结束，因此将栈sStack的栈顶元素重复k次，并追加到栈sStack的栈顶元素中，继续前一轮的重复**。\n    5. 最后栈sStack的栈顶元素即为结果。\n## 代码一\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n        let sStack = [''],nStack = [],n = s.length;\n        let num = 0;\n        for(let i = 0;i < n;i++){\n            let c = s[i];\n            if(/\\d/.test(c)) num = num * 10 + Number(c);\n            else if(c === '[') {\n                nStack.push(num);\n                num = 0;\n                sStack.push('');\n            }else if(/[a-z]/.test(c)){\n                // console.log(sStack)\n                sStack[sStack.length - 1] += c;\n            }else{\n                let s = sStack.pop(),k = nStack.pop();\n                // console.log(s,k);\n                if(s) s = s.repeat(k);\n                sStack[sStack.length - 1] += s;\n                // console.log(sStack)\n            }\n        }\n        return sStack[0];\n    };\n```\n## 复杂度分析一\n* 时间复杂度：O(n)，其中n为字符串s的长度。\n* 空间复杂度：O(n)，需要两个最长长度为n的栈保存答案及数字，其中n为字符串s的长度。\n--- \n## 思路二：递归\n括号匹配问题，一般可以用递归来解决。  \n步骤：\n1. 预处理字符串s，记录与每个“\\[”匹配的“\\]”的位置，保存至数组left中。\n> 预处理匹配括号位置是这类递归问题常见的技巧。\n2. 从左往右遍历字符串s： \n    1. 如果当前字符为字母，则将当前字符添加到结果res中；\n    2. 如果当前字符为数字，则将数字保存在变量num中；\n    3. 如果当前字符为左括号，递归调用f，处理\\[i + 1, left\\[i] - 1]的子串，得到的结果重复num次，并追加到结果res中；num清空；\n4. 返回res。\n\n## 代码二\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    let stack = [],n = s.length,left = new Array(n).fill(-1);\n    for(let i = 0;i < n;i++){\n        let c = s[i];\n        if(c === '[') stack.push(i);\n        else if(c === ']') left[stack.pop()] = i;\n    }\n    return f(0,n - 1);\n    // -----------------------------------\n    function f(l,r){\n        let ans = '',num = 0;\n        for(let i = l;i <= r;i++){\n            let c = s[i];\n            if(/\\d/.test(c)) num = num * 10 + Number(c);\n            else if(c === '['){\n                ans += f(i + 1,left[i] - 1).repeat(num);\n                num = 0;\n                i = left[i];\n            }else if(/[a-z]/.test(c)) ans += c;\n        }\n        return ans;\n    }\n};\n```\n\n## 复杂度分析二\n* 时间复杂度：O(n)，其中n为字符串s的长度。\n* 空间复杂度：O(n)，即递归栈深度，最大为n，其中n为字符串s的长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/8#issuecomment-3091479392","body":"## 思路\n1. 设计双栈，一个用于存放入队数据，一个用于存放出队数据。\n2. 各个操作的实现思路：\n    1. push：将数据压入pushData栈中。\n    2. pop：如果popData栈为空，则将pushData栈中的数据全部弹出并压入popData栈中。然后弹出popData栈的栈顶元素。\n    3. peek：同pop操作，最后一步返回popData栈的栈顶元素。 \n    4. empty：判断两个栈是否为空。 \n\n> js中可以用数组模拟栈。\n## 代码\n```javascript\nvar MyQueue = function() {\n   this.pushData = []\n   this.popData = [] \n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.pushData.push(x)    \n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.popData.length === 0 && this.pushData.length) while(this.pushData.length) this.popData.push(this.pushData.pop());\n    return this.popData.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(this.popData.length === 0 && this.pushData.length) while(this.pushData.length) this.popData.push(this.pushData.pop());\n    return this.popData[this.popData.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.pushData.length === 0 && this.popData.length === 0\n};\n\n/** \n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n## 复杂度分析\n- 时间复杂度：O(1)：插入、删除、查找操作的均摊时间复杂度都是O(1)\n- 空间复杂度：O(n)：栈的存储空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/9#issuecomment-3094576990","body":"## 思路\n比较容易的思路是，排序后，每个块和排序前元素的种类和数量完全相同，可以用哈希表或前缀和来求解。此思路的时间复杂度是O(n)，空间复杂度是O(nlog(n))。  \n后来看了看题解，发现可以用单调栈或维护前后缀的思路来求解。\n\n### 排序块性质\n**我们要想划分最多的块，并且保证排序后的结果和原数组的排序结果相同，则块中的元素必须保证，块中的最大值都比右边的元素小或者相同，块中的最小值都比左边的元素大或者相同。**\n则我们维护一个前缀最大值和后缀最小值两个数组，只要前缀的最大值，小于等于后缀的最小值，则可划分（相当于给数组划一条线）。\n## 代码\n```javascript\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    let n = arr.length, prefixMax = new Array(n).fill(-Infinity),suffixMin = new Array(n).fill(Infinity);\n    for(let i = 0;i < n;i++){\n        prefixMax[i] = Math.max(i ? prefixMax[i - 1] : -Infinity,arr[i]);\n        let j = n - 1 - i;\n        suffixMin[j] = Math.min(j + 1 < n ? suffixMin[j + 1] : Infinity,arr[j]);\n    }\n\n    let ans = 1;\n    for(let i = 0;i < n - 1;i++){\n          if(prefixMax[i] <= suffixMin[i + 1]) ans++;\n    }\n    return ans\n};\n```\n## 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n\n## 参考题解\n[https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/solutions/1/zui-duo-neng-wan-cheng-pai-xu-de-kuai-by-z0wz/](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/solutions/1/zui-duo-neng-wan-cheng-pai-xu-de-kuai-by-z0wz/)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/10#issuecomment-3095130877","body":"## 思路\n旋转链表的本质上是将链表尾部k个节点移动到链表头部。按照这个思路步骤如下：\n1. 计算链表长度l；\n2. 如果 k % l === 0 或者 l === 0，即k为l的整数倍，或者链表为空，则不需要旋转，直接返回head；否则 k = k % l；\n3. 声明两个指针fast、slow，fast先移动k步；\n4. fast、slow同时移动，直到fast到达链表末尾；\n5. 此时：\n   1. slow的下一个节点即为新的头结点\n   2. slow.next 指向 null\n   3. fast.next 指向 head\n   4. 返回新的头结点\n\n## JavaScript代码\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if(!head || k === 0) return head;\n    let l = 0,curr = head;\n    while(curr){\n        l++;\n        curr = curr.next;\n    }\n    k = k % l;\n    if(k === 0) return head;\n    let fast = head,slow = head;\n    while(k){\n        fast = fast.next;\n        k--;\n    }\n\n    while(fast.next){\n        fast = fast.next;\n        slow = slow.next;\n    }\n\n    let newHead = slow.next;\n    slow.next = null;\n    fast.next = head;\n    return newHead;\n\n};\n```\n\n## 复杂度分析\n- 时间复杂度：O(n)，其中n为链表的长度。\n- 空间复杂度：O(1)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/11#issuecomment-3100439586","body":"## 思路\n因为是两两交换，所以可以声明四个指针记录涉及到交换的节点，修改相关指针的next指向即可。具体步骤如下：\n1. 特判：链表为空或链表只有一个节点，直接返回原链表。\n2. 为了简化代码，声明一个哨兵节点dummy,dummy.next = head,方便统一处理。\n3. 声明指针prev，指向前一次交换后的结束节点；声明指针curr，指向本次交换的开始节点。初始值prev = dummy,curr = head,开始循环：\n   1. 循环终止条件：curr为空或者curr的下一个节点为空（即curr没有可以交换的节点了）。\n   2. 声明next指针，next = curr.next；声明nextCurr指针，nextCurr = curr.next.next；\n   3. 两两交换：curr.next = nextCurr,next.next = curr；\n   4. 重新设置头尾指向，确保下一轮循环正确执行：prev.next = next;\n   5. 重新设置prev，curr：prev = curr; curr = nextCurr;继续循环，直到循环终止条件。\n## 代码\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    if(!head || !head.next) return head;\n    const dummy = new ListNode();\n    dummy.next = head;\n    \n    let prev = dummy,curr = dummy.next;\n    while(curr && curr.next){\n        let next = curr.next,nextCurr = next.next;\n        curr.next = nextCurr;\n        next.next = curr;\n        \n        prev.next = next;\n\n        prev = curr;\n        curr = curr.next;\n    }\n\n    return dummy.next;\n};\n```\n## 复杂度分析\n- 时间复杂度：O(n)，其中 n 是链表的长度。\n- 空间复杂度：O(1)，仅使用有限个指针。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/12#issuecomment-3105520636","body":"## 思路\n* 本题目标是将一个有序单链表（升序排列）转换为一棵高度平衡的二叉搜索树（Height Balanced Binary Search Tree）。\n* 核心思想是使用递归方式构建树，每次选择链表的中间节点作为当前子树的根节点，以保证左右子树的高度差不超过 1。\n* 利用快慢指针（slow 和 fast）找到链表的中间节点，并将链表分割为左子链表和右子链表，分别递归构建左右子树。\n* 实现步骤如下：\n    1. 递归终止条件：\n        * 如果链表为空（!head），返回 null。\n        * 如果只有一个节点（!head.next），直接构建一个 TreeNode 返回。\n    2. 寻找中间节点：\n        * 使用快慢指针法，fast 每次走两步，slow 每次走一步，当 fast 到达末尾时，slow 正好指向中间节点。使用一个临时变量 prev 记录 slow 的前一个节点，方便后续断开连接。\n    3. 分割链表：\n        * 将 slow 前面的节点作为左子链表，断开连接。\n        * slow.next 作为右子链表继续递归处理。\n    4. 构建树节点：\n        * 当前 slow.val 作为根节点，递归构建左右子树。\n## 代码\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    if(!head) return head;\n    // display(head)\n    if(!head.next) return new TreeNode(head.val);\n\n    // 寻找中间节点\n    let slow = head,fast = head,prev = null;\n    while(fast.next && fast.next.next){\n        fast = fast.next.next;\n        prev = slow;\n        slow = slow.next;\n    }\n    // 此时，slow是中间节点,slow.next是右子树的根\n    let next = slow.next;\n    if(prev) prev.next = null;\n    slow.next = null;\n\n    const root = new TreeNode(slow.val);\n    root.left = sortedListToBST(prev ? head : null);\n    root.right = sortedListToBST(next);\n    return root;\n};\n\nfunction display(head){\n    let ans = [],p = head;\n    while(p){\n        ans.push(p.val);\n        p = p.next;\n    }\n    console.log('处理的树：',ans)\n}\n```\n## 复杂度分析\n* 时间复杂度：O(n log n)\n    * 每一层递归都需要遍历链表的一半来找中间节点（O(n)），递归深度为 log n，因此总时间复杂度为 O(n log n)。\n* 空间复杂度：O(log n)\n    * 主要是递归调用栈的空间，取决于树的高度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/13#issuecomment-3111762311","body":"## 思路\n- 定义两个指针 `pA` 和 `pB`，分别从 `headA` 和 `headB` 开始遍历。\n- 当 `pA` 和 `pB` 不相遇时，它们会继续向前移动：\n    - 如果 `pA` 到达末尾 (`null`)，则跳转到 `headB`。\n    - 如果 `pB` 到达末尾 (`null`)，则跳转到 `headA`。\n- 这样，两个指针最终会在相交点相遇，或者同时到达末尾 (`null`)，从而退出循环。\n- 返回 `pA`，即相交节点或 `null`。\n## 代码\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function (headA, headB) {\n    let pA = headA, pB = headB;\n    while (pA !== pB) {\n        pA = pA ? pA.next : headB;\n        pB = pB ? pB.next : headA;\n    }\n    return pA;\n};\n```\n## 复杂度分析\n- 时间复杂度：O(n + m)，其中 n 和 m 分别为链表 headA 和 headB 的长度。\n- 空间复杂度：O(1)，只使用了两个指针变量，没有额外的空间。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/14#issuecomment-3116200386","body":"## 思路\n- 首先处理边界情况：如果head为空，直接返回\n- 快慢指针同时遍历链表，快指针每次走两步，慢指针每次走一步\n- 当两指针相遇时停止第一阶段\n- 如果fast为null，说明无环，返回null\n- 将slow重置为head，两个指针以相同速度继续移动直到相遇\n- 相遇点即为环的起始节点\n## 代码\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    if(!head) return head;\n    let slow = head,fast = head;\n    while(fast){\n        fast = fast.next;\n        if(fast) fast = fast.next;\n\n        slow = slow.next;\n\n        if(slow === fast) break;\n    }\n\n    if(!fast) return fast;\n\n    slow = head;\n\n    while(slow !== fast){\n        slow = slow.next;\n        fast = fast.next;\n    }\n\n    return slow\n};\n```\n## 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/15#issuecomment-3125594702","body":"## LRU Cache 算法思路分析\n\nLRU (Least Recently Used) 缓存是一种常用的缓存淘汰策略，当缓存满时，会优先淘汰最近最少使用的元素。\n\n### 核心数据结构\n\n1. **双向链表**：维护元素的访问顺序，头部是最近最少使用的元素，尾部是最近使用的元素\n2. **哈希表(Map)**：提供O(1)时间复杂度的元素查找\n\n### 主要操作实现\n\n#### 1. 初始化\n- 设置缓存容量\n- 初始化当前元素计数器\n- 创建哈希表存储键值对\n- 创建虚拟头节点和尾节点，方便操作\n\n#### 2. 获取元素get\n- 如果元素不存在，返回-1\n- 如果元素存在：\n    - 将该节点从当前位置删除\n    - 将该节点插入到链表尾部（标记为最近使用）\n    - 返回节点值\n\n#### 3. 插入/更新元素put\n- **新元素插入**：\n    - 如果缓存已满，删除链表头部节点（最近最少使用的元素）\n    - 创建新节点并添加到哈希表\n    - 将新节点插入链表尾部\n- **更新元素**：\n    - 更新节点值\n    - 将节点从当前位置删除并移到链表尾部\n\n#### 4. 辅助方法\n- insertToTail：将节点插入链表尾部\n- deleteFromHead：删除链表头部节点\n- deleteNode：删除指定节点\n\n## 代码\n```javascript\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.capacity = capacity;\n    this.cnt = 0;\n    this.map = new Map();\n    this.head = new DoubleNode();\n    this.tail = new DoubleNode();\n    this.head.next = this.tail;\n    this.tail.prev = this.head;    \n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    // console.log('get',key)\n    \n    if(this.map.has(key) === false) return -1;\n    let node = this.map.get(key);\n\n    this.deleteNode(node);\n    \n    this.insertToTail(node);\n    // this.map.set(key,node);\n    \n    // this.display();\n\n    return node.val;\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    if(this.map.has(key) === false){// 插入操作\n        let node = new DoubleNode(key,value);\n        if(this.cnt === this.capacity) this.deleteFromHead(); \n        else this.cnt++\n        this.map.set(key,node);\n        this.insertToTail(node);\n    }else{\n        let node = this.map.get(key);\n        node.val = value;\n\n        this.deleteNode(node);\n\n        this.insertToTail(node);\n        // this.map.set(key,node);\n    }\n\n    // console.log('put',key,value);\n    // this.display();\n};\n\nLRUCache.prototype.insertToTail = function(node){\n    let prev = this.tail.prev;\n    \n    prev.next = node;\n    node.next = this.tail;\n    \n    this.tail.prev = node;\n    node.prev = prev;\n}\n\nLRUCache.prototype.deleteFromHead = function(){\n    let node = this.head.next;\n    let next = node.next;\n    \n    this.head.next = next;\n    next.prev = this.head;\n\n    this.map.delete(node.key);\n}\n\nLRUCache.prototype.deleteNode = function(node){\n    let prev = node.prev,next = node.next;\n    prev.next = next;\n    next.prev = prev;\n\n    node.prev = null;\n    node.next = null;\n\n    // this.map.delete(node.key);\n}\n\nLRUCache.prototype.display = function(){\n    let k = this.cnt,p = this.head.next;\n    let ans = []\n    while(k){\n        ans.push(p.key + '=>' + p.val);\n        k--;\n        p = p.next;\n    }\n    console.log(ans);\n}\n\nfunction DoubleNode(key,val){\n    this.key = key;\n    this.val = val;\n    this.next = null;\n    this.prev = null;\n}\n\n\n/** \n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n```\n## 复杂度分析\n### 时间复杂度\n- get操作：O(1)\n- put操作：O(1)\n\n### 空间复杂度\n- O(capacity)，需要存储最多capacity个元素\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/16#issuecomment-3123739061","body":"## 思路\n\n使用了递归的思想来解决问题：\n\n1. **基础情况(Base Case)**：如果当前节点为空（`!root`），则返回深度0，因为空节点没有深度。\n\n2. **递归关系(Recursive Relation)**：\n   - 分别计算左子树和右子树的最大深度：`maxDepth(root.left)` 和 `maxDepth(root.right)`\n   - 取两者中的较大值：`Math.max(maxDepth(root.left), maxDepth(root.right))`\n   - 加上当前节点的1层高度：`+1`\n\n### 算法执行过程\n\n1. 对于任意节点，先递归计算其左子树的最大深度\n2. 再递归计算其右子树的最大深度\n3. 比较左右子树的深度，取较大值\n4. 将较大值加1（代表当前节点所在的层），作为以当前节点为根的子树的最大深度\n\n## 代码\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    if(!root) return 0;\n    return Math.max(maxDepth(root.left),maxDepth(root.right))+1;\n};\n```\n\n## 复杂度分析\n\n- **时间复杂度**：O(n)，其中n是二叉树的节点数。因为需要遍历每个节点一次。\n- **空间复杂度**：O(h)，其中h是二叉树的高度。这是由于递归调用栈的深度，最坏情况下（完全不平衡的树）可能达到O(n)，最好情况下（完全平衡的树）为O(log n)。\n\n这是一个典型的分治算法应用，将问题分解为更小的子问题（左右子树的深度），然后合并结果得到最终答案。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/17#issuecomment-3125568669","body":"## 代码思路分析\n\n这是一个经典的二叉树递归问题，采用深度优先搜索(DFS)的方式解决：\n\n1. **基本情况处理**：\n    - 如果两个节点都为null，则认为相同，返回true\n    - 如果其中一个节点为null，另一个不是，则不同，返回false\n\n2. **递归比较**：\n    - 比较当前节点的值是否相等\n    - 递归比较左子树是否相同\n    - 递归比较右子树是否相同\n    - 只有当值相等且左右子树都相同时，才返回true\n\n## 代码实现\n\n```javascript\nvar isSameTree = function(p, q) {\n    // 如果两个节点都为空，则相同\n    if(p===null && q===null) return true;\n    // 如果只有一个节点为空，则不同\n    if(p===null) return false;\n    if(q===null) return false;\n    // 比较当前节点值，并递归比较左右子树\n    return p.val===q.val && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n};\n```\n\n\n## 复杂度分析\n\n- **时间复杂度**：O(min(m,n))，其中m和n分别是两个二叉树的节点数。在最坏情况下，需要遍历两个树中所有节点。\n- **空间复杂度**：O(min(m,n))，递归调用的层数最多为较小树的高度，最坏情况下为O(min(m,n))。\n\n这个算法通过递归方式同时遍历两棵树的相同位置节点，并比较它们的值是否相等，从而判断两棵树是否完全相同。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/18#issuecomment-3130348089","body":"## 思路\n\n### 核心思路\n- 使用深度优先搜索(DFS)遍历二叉树\n- 在遍历过程中维护从根节点到当前节点形成的数字\n- 当到达叶节点时，将形成的数字加到结果中\n\n### 具体实现\n\n1. **函数定义与参数**：\n    - `sumNumbers(root, prev = 0)` 接收当前节点 `root` 和之前形成的数字 `prev`\n    - `prev` 参数有默认值 0，用于累积从根到当前节点的数字\n\n2. **边界条件处理**：\n   ```javascript\n   if(!root) return 0;\n   ```\n\n    - 如果当前节点为空，返回 0\n\n3. **数字累积**：\n   ```javascript\n   prev = prev * 10 + root.val;\n   ```\n\n    - 将当前节点值添加到路径数字中\n    - 通过 `prev * 10 + root.val` 实现数字的逐位构建\n\n4. **叶节点判断**：\n   ```javascript\n   if(!root.left && !root.right) return prev;\n   ```\n\n    - 如果当前节点是叶节点（无左右子节点），返回累积的数字\n\n5. **递归处理**：\n   ```javascript\n   return sumNumbers(root.left,prev) + sumNumbers(root.right,prev);\n   ```\n\n    - 分别递归处理左右子树\n    - 将左右子树的结果相加返回\n\n## 代码\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root,prev = 0) {\n    if(!root) return 0;\n    prev = prev * 10 + root.val;\n    if(!root.left && !root.right) return prev;\n    return sumNumbers(root.left,prev) + sumNumbers(root.right,prev);\n};\n```\n\n## 复杂度分析\n\n- **时间复杂度**：O(n)，其中 n 是二叉树的节点数，需要遍历每个节点一次\n- **空间复杂度**：O(h)，其中 h 是二叉树的高度，主要是递归调用栈的空间\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/19#issuecomment-3134622736","body":"## 思路\n\n### 1. 核心思想\n使用深度优先搜索（DFS）遍历二叉树，记录每一层最左边的节点值。\n\n### 2. 关键实现点\n\n- **层级记录**：通过 `level` 参数跟踪当前节点所在的层级\n- **每层只记录一次**：利用 `level === left.length` 条件确保每层只记录第一个访问的节点值\n- **先左后右遍历**：先遍历左子树再遍历右子树，保证每层第一个访问的是最左边的节点\n\n## 代码\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar findBottomLeftValue = function(root) {\n    let left = [];\n    dfs(root,0)\n    return left[left.length - 1];\n    // ----------------------\n    function dfs(root,level){\n        if(!root) return;\n        if(level === left.length) left.push(root.val);\n        dfs(root.left,level + 1);\n        dfs(root.right,level + 1);\n    }\n};\n```\n## 优化后的代码\n优化思路：没必要用数组保存整个左侧值，只需要记录左侧值第一次出现即可\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar findBottomLeftValue = function(root) {\n    let left = 0,ans;\n    dfs(root,0)\n    return ans;\n    // ----------------------\n    function dfs(root,level){\n        if(!root) return;\n        if(level === left) {\n            left++;\n            ans = root.val;\n        }\n        dfs(root.left,level + 1);\n        dfs(root.right,level + 1);\n    }\n};\n```\n\n\n## 复杂度分析\n- **时间复杂度**：O(n)，其中 n 是二叉树的节点数，需要遍历每个节点一次\n- **空间复杂度**：O(h)，其中 h 是二叉树的高度，主要是递归调用栈的空间开销","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/20#issuecomment-3138308014","body":"## 思路\n\n### 1. 序列化 (`serialize`)\n- 使用前序遍历（根-左-右）遍历二叉树\n- 对于每个节点：\n    - 如果节点为空，将 `null` 添加到结果数组\n    - 如果节点不为空，将节点值添加到结果数组，然后递归处理左右子树\n- 最后将数组转换为 JSON 字符串返回\n\n### 2. 反序列化 (`deserialize`)\n- 将 JSON 字符串解析为数组\n- 使用递归方式重建二叉树：\n    - 按顺序读取数组元素\n    - 如果当前元素是 `null`，返回 `null`\n    - 如果当前元素不是 `null`，创建新节点，并递归构建左右子树\n    - 利用前序遍历的特点，按顺序处理就能重建原来的树结构\n\n## 关键特点\n\n1. **前序遍历**：保证了根节点在子节点之前被处理，便于重建时确定父子关系\n2. **空节点标记**：用 `null` 标记空节点，确保能完全还原树的结构\n3. **递归实现**：两个函数都使用递归方式实现，代码简洁清晰\n\n## 示例说明\n\n假设有一棵二叉树：\n```\n    1\n   / \\\n  2   3\n     / \\\n    4   5\n```\n\n\n- 序列化结果：`[1,2,null,null,3,4,null,null,5,null,null]`\n- 反序列化时按此顺序重建树结构\n\n\n## 代码\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n    let ans = [];\n    dfs(root);\n    return JSON.stringify(ans);\n    // -----------------\n    function dfs(root){\n        if(!root){\n            ans.push(null);\n            return;\n        }\n        ans.push(root.val);\n        dfs(root.left);\n        dfs(root.right);\n    }\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n   let arr = JSON.parse(data),i = 0;\n   //console.log(arr);\n   return dfs();\n   // if(arr.length === 0) return null;\n   // ---------------------\n   function dfs(){\n    let node;\n    // console.log(i,arr[i]);\n    if(arr[i] === null) node = null;\n    else node = new TreeNode(arr[i]);\n    i++;\n    if(node) {\n        node.left = dfs();\n        node.right = dfs();\n    }\n    return node;\n   }\n};\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n```\n\n## 复杂度分析\n- 时间复杂度：序列化和反序列化的时间复杂度都是 O(n)，其中 n 是二叉树的节点数。\n- 空间复杂度：考虑到返回值的话，序列化和反序列化的空间复杂度都是 O(n)，其中 n 是二叉树的节点数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/21#issuecomment-3141895435","body":"## 思路\n\n### 具体实现步骤\n\n1. **数据结构选择**\n    - 使用一个大小为2001的数组 cols 每个元素是一个优先队列 `PriorityQueue`\n    - 优先队列用于处理同一列中节点的排序问题\n\n2. **排序规则**\n    - 主要按行号 row 排序（上到下）\n    - 行号相同时按节点值 `node.val` 排序\n\n3. **DFS遍历**\n    - 通过 dfs 函数遍历整个二叉树\n    - 将每个节点按其列号存入对应的优先队列中\n    - 列号通过 `col + 1000` 映射到数组索引，处理负数列号\n\n4. **结果构建**\n    - 遍历 cols 数组，跳过空队列\n    - 从每个非空队列中依次取出元素，构建每列的结果\n    - 按列顺序组合成最终结果\n\n## 关键点\n\n- **坐标系统**：以根节点为原点(0,0)，向左列号减1，向右列号加1，向下行号加1\n- **偏移处理**：通过 `col + 1000` 将可能的负数列号映射到正数索引\n- **排序逻辑**：同一位置优先按行排序，其次按值排序\n\n这种方法确保了垂直遍历的正确顺序。\n\n## 代码\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar verticalTraversal = function(root) {\n    let cols = new Array(2000 + 1).fill(0).map(()=>new PriorityQueue((a,b)=>{\n        if(a[0] !== b[0]) return a[0] - b[0];\n        return a[2] - b[2];\n    }));\n\n    dfs(root,0,0);\n    let ans = [];\n    for(let i = 0;i <= 2000;i++){\n        let data = cols[i];\n        if(data.size() === 0) continue;\n        let temp = []\n        while(data.size()) temp.push(data.dequeue()[2]);\n        ans.push(temp);\n    }\n    return ans;\n\n    // --------------------------------\n    function dfs(node,row,col){\n        if(!node) return;\n        cols[col + 1000].enqueue([row,col,node.val]);\n        dfs(node.left,row + 1,col - 1);\n        dfs(node.right,row + 1,col + 1);\n    }\n    \n};\n```\n\n## 复杂度分析\n\n### 时间复杂度\n\n1. **初始化阶段**\n    - 创建大小为2001的数组并初始化优先队列：O(2001) = O(1)\n\n2. **DFS遍历阶段**\n    - 对每个节点执行一次 dfs 调用\n    - 假设树有 N 个节点，则 DFS 总共执行 N 次\n    - 每次 enqueue 操作在优先队列中的时间复杂度为 O(log M)，其中 M 是队列中元素个数\n    - 最坏情况下，所有节点都在同一列，M 最大为 N\n    - 因此 DFS 阶段时间复杂度为 O(N log N)\n\n3. **结果构建阶段**\n    - 遍历2001个位置的数组：O(2001) = O(1)\n    - 从优先队列中 dequeue 所有元素：每个元素 dequeue 一次，总共 N 个元素\n    - 每次 dequeue 操作为 O(log M)\n    - 总时间复杂度为 O(N log N)\n\n**总时间复杂度：O(N log N)**，其中 N 是二叉树中节点的数量\n\n### 空间复杂度\n\n1. **存储结构**\n    - cols 数组：大小固定为 2001，每个元素是一个优先队列\n    - 所有优先队列总共存储 N 个节点信息：O(N)\n    - 每个节点信息是一个包含3个元素的数组：O(1) 每节点\n\n2. **递归调用栈**\n    - dfs 函数的递归深度最多为树的高度 H\n    - 在最坏情况下（树退化为链表），H = N\n    - 平均情况下，对于平衡二叉树，H = log N\n\n3. **结果数组**\n    - ans 数组存储最终结果：O(N)\n\n**总空间复杂度：O(N)**，其中 N 是二叉树中节点的数量\n\n### 总结\n\n- **时间复杂度：O(N log N)**\n- **空间复杂度：O(N)**\n\n其中 N 为二叉树的节点总数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/22#issuecomment-3146457266","body":"## 思路：\n\n1. **使用哈希表存储已遍历元素**：\n    - 创建一个空对象 [map](file://E:\\力扣刷题\\algorithm_exercises\\周赛\\454\\2.js#L5-L5) 作为哈希表\n    - 用于存储已经遍历过的元素值和其对应的索引\n\n2. **一次遍历查找**：\n    - 遍历数组中的每个元素 `nums[i]`，记为 [a](file://E:\\力扣刷题\\algorithm_exercises\\周赛\\452\\1.js#L14-L14)\n    - 计算目标差值 `b = target - a`\n    - 检查 `b` 是否已经在哈希表中存在\n        - 如果存在，说明找到了两个数，它们的和等于目标值，直接返回这两个数的索引 `[map[b], i]`\n        - 如果不存在，将当前元素 [a](file://E:\\力扣刷题\\algorithm_exercises\\周赛\\452\\1.js#L14-L14) 和它的索引 [i](file://E:\\力扣刷题\\algorithm_exercises\\周赛\\451\\2.js#L22-L22) 存入哈希表，继续遍历\n\n### 算法优势：\n1. **时间复杂度优化**：从暴力解法的 O(n²) 降低到 O(n)\n2. **空间换时间**：使用额外的哈希表存储，换取查找时间的优化\n3. **一次遍历**：只需要遍历一次数组就能得到结果\n\n\n## 代码\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    let map = {}\n    for(let i = 0;i < nums.length;i++){\n        let a = nums[i],b = target - a;\n        if(map[b] !== undefined) return [map[b],i];\n        map[a] = i;\n    }\n};\n```\n\n## 复杂度分析\n- 时间复杂度：O(n)，其中 n 是数组的长度。\n- 空间复杂度：O(n)，哈希表 map 的大小为 n。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/23#issuecomment-3146924002","body":"## 思路\n### 主要步骤：\n\n1. **统计频次**：使用 [map](file:///E:/力扣刷题/algorithm_exercises/程序员面试金典/面试题04.01.节点间通路/main.js#L13-L13) 对象统计每个数字在数组中出现的频次\n   ```javascript\n   let map = {};\n   for(let i of nums) map[i] = (map[i] || 0) + 1;\n   ```\n\n\n2. **维护大小为 K 的最小堆**：使用最小堆来保存频率最高的 K 个元素\n   ```javascript\n   let q = new MinPriorityQueue(v=>v[1]); // 基于元素出现频次的优先队列\n   ```\n\n\n遍历统计结果，将元素和其频次作为数组加入堆中，当堆的大小超过 K 时，移除堆顶（即当前堆中频次最低的元素）：\n   ```javascript\n   for(let key in map){\n     q.enqueue([+key,map[key]]);\n     if(q.size() > k) q.dequeue();\n   }\n   ```\n\n\n3. **构建结果数组**：依次从堆中取出元素，因为是最小堆，所以频次低的先出堆，最终得到的就是频次最高的 K 个元素\n   ```javascript\n   let ans = [];\n   while(q.size()){\n     ans.push(q.dequeue()[0]);\n   }\n   ```\n\n\n## 代码\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar topKFrequent = function(nums, k) {\n  let q = new MinPriorityQueue(v=>v[1]);\n  let map = {};\n  for(let i of nums) map[i] = (map[i] || 0) + 1;\n  for(let key in map){\n    q.enqueue([+key,map[key]]);\n    if(q.size() > k) q.dequeue();\n  }  \n  let ans = [];\n  while(q.size()){\n    ans.push(q.dequeue()[0]);\n  }\n  return ans;\n};\n```\n\n## 复杂度分析\n- 时间复杂度：O(N log K)，其中 N 是数组的长度\n- 空间复杂度：O(N)，用于存储频次映射表","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/24#issuecomment-3148902680","body":"## 思路\n\n### 1. 数据结构选择\n- 使用 [map](file://E:\\其他项目\\algorithm_exercises\\周赛\\459\\2.js#L5-L5) 数组存储每个点到其他点的距离统计\n- `map[i]` 是一个 Map，记录第 [i](file://E:\\其他项目\\algorithm_exercises\\91天学算法\\day1\\js.js#L6-L6) 个点到其他各点的距离及出现次数\n\n### 2. 核心逻辑\n- **距离计算**：遍历所有点对，计算两点间距离的平方（避免开根号运算）\n- **距离统计**：将每对点的距离信息分别记录到两个点的统计中\n- **结果计算**：对于每个点，如果到其他点有相同距离的点超过1个，则可以组成回旋镖\n\n### 3. 关键步骤详解\n\n```javascript\n// 计算两点间距离的平方\nfunction calc(i,j){\n    let a = Math.abs(points[i][0] - points[j][0]),b = Math.abs(points[i][1] - points[j][1]);\n    return a * a + b * b;\n}\n```\n这段代码计算两个点之间的欧几里得距离的平方，使用平方避免浮点运算。\n\n```javascript\n// 统计每个点到其他点的距离\nfunction addMap(i,dis){\n    let m = map[i];\n    m.set(dis,(m.get(dis) || 0) + 1);\n}\n```\n将距离信息记录到对应点的统计Map中。\n\n### 4. 结果计算原理\n\n对于每个点 [i](file://E:\\其他项目\\algorithm_exercises\\91天学算法\\day1\\js.js#L6-L6)，如果存在 `v` 个点与它距离相同（`v>1`），则可以从这 `v` 个点中选择 2 个点与点 [i](file://E:\\其他项目\\algorithm_exercises\\91天学算法\\day1\\js.js#L6-L6) 组成回旋镖，选择方式有 `v*(v-1)` 种。\n\n\n## 代码\n```javascript\n/**\n * @param {number[][]} points\n * @return {number}\n */\nvar numberOfBoomerangs = function(points) {\n    let n = points.length;\n    if(n < 3) return 0;\n    let map = new Array(n).fill(0).map(()=>new Map());\n    for(let i = 0;i < n;i++){\n        for(let j = i + 1;j < n;j++){\n            let dis = calc(i,j);\n            addMap(i,dis);\n            addMap(j,dis);\n        }\n    }\n    let ans = 0;\n    for(let i = 0;i < n;i++){\n        for(let [k,v] of map[i]){\n            if(v <= 1) continue;\n            ans += v * (v - 1);\n        }\n    }\n\n    return ans;\n\n    \n\n\n    // ------------------------------\n    function calc(i,j){\n        let a = Math.abs(points[i][0] - points[j][0]),b = Math.abs(points[i][1] - points[j][1]);\n        return a * a + b * b;\n    }\n\n    function addMap(i,dis){\n        let m = map[i];\n        m.set(dis,(m.get(dis) || 0) + 1);\n\n    }\n};\n```\n\n## 算法复杂度\n- 时间复杂度：O(n²)\n- 空间复杂度：O(n²)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/25#issuecomment-3152979976","body":"## 思路\n\n### 核心思想\n使用**滑动窗口**（Sliding Window）技术配合**哈希表**来解决这个问题。\n\n### 关键变量说明\n- [l](file://E:\\其他项目\\algorithm_exercises\\周赛\\447\\1.js#L31-L31): 滑动窗口的左边界\n- [i](file://E:\\其他项目\\algorithm_exercises\\91天学算法\\day1\\js.js#L6-L6): 滑动窗口的右边界（循环变量）\n- [map](file://E:\\其他项目\\algorithm_exercises\\周赛\\459\\2.js#L5-L5): 用于记录窗口内每个字符出现的次数\n- `ans`: 记录最长无重复子串的长度\n\n### 算法步骤\n\n1. **初始化**：设置左边界 `l = 0`，创建字符计数的 [map](file://E:\\其他项目\\algorithm_exercises\\周赛\\459\\2.js#L5-L5)，初始化结果 `ans = 0`\n\n2. **扩展窗口**：使用 [i](file://E:\\其他项目\\algorithm_exercises\\91天学算法\\day1\\js.js#L6-L6) 从左到右遍历字符串，逐步扩展窗口右边界\n\n3. **处理重复字符**：\n    - 当遇到重复字符时（`map.has(c)` 为 true），不断右移左边界 [l](file://E:\\其他项目\\algorithm_exercises\\周赛\\447\\1.js#L31-L31)\n    - 移动过程中减少对应字符的计数，如果计数为0则从 [map](file://E:\\其他项目\\algorithm_exercises\\周赛\\459\\2.js#L5-L5) 中删除\n    - 直到窗口中不再包含当前字符为止\n\n4. **更新结果**：\n    - 计算当前窗口长度 `i - l + 1`\n    - 与历史最大值比较，更新 `ans`\n\n5. **维护窗口状态**：将当前字符加入 [map](file://E:\\其他项目\\algorithm_exercises\\周赛\\459\\2.js#L5-L5) 并增加其计数\n\n## 代码\n```javascript\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    let l = 0, map = new Map(),n = s.length,ans = 0;\n    for(let i = 0;i < n;i++){\n        let c = s[i]\n        while(map.has(c)){\n            map.set(s[l],map.get(s[l]) - 1);\n            if(map.get(s[l]) === 0) map.delete(s[l]);\n            l++;\n        }\n        // console.log(l,i,s.slice(l,i + 1));\n        ans = Math.max(i - l + 1,ans);\n        map.set(c,(map.get(c) || 0 ) + 1)\n    }\n    return ans;\n};\n```\n\n\n## 复杂度分析\n- **时间复杂度**: O(n)，其中 n 是字符串长度，每个字符最多被访问两次\n- **空间复杂度**: O(min(m,n))，其中 m 是字符集大小","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/26#issuecomment-3157255368","body":"## 思路\n\n### 1. 建立单词频次映射\n```javascript\nlet map = new Map();\nwords.forEach((word,i)=>{\n    map.set(word,(map.get(word) || 0) + 1);\n});\n```\n\n- 使用 `Map` 统计 `words` 数组中每个单词的出现次数\n- 处理 `words` 中可能存在重复单词的情况\n\n### 2. 初始化参数\n```javascript\nlet n = s.length,m = words.length,k = words[0].length,l = k * m;\n```\n\n- [n](file://E:\\其他项目\\algorithm_exercises\\91天学算法\\day2\\js.js#L6-L6): 字符串 [s](file://E:\\其他项目\\algorithm_exercises\\1.js) 的长度\n- `m`: 单词数组的长度\n- `k`: 每个单词的长度（题目保证所有单词等长）\n- [l](file://E:\\其他项目\\algorithm_exercises\\周赛\\447\\1.js#L31-L31): 所有单词连接后的总长度\n\n### 3. 遍历可能的起始位置\n```javascript\nfor(let i = 0;i <= n - l;i++){}\n```\n\n- 只需检查到 `n - l` 位置，因为更后面不可能容纳完整的连接串\n\n### 4. 检查每个窗口\n```javascript\nlet j = i,result = new Map(),total = 0;\nwhile(j < i + l){\n    let c = s.slice(j,j + k);\n    if(map.has(c) === false) break;\n    let found = false;\n    result.set(c,(result.get(c) || 0) + 1);\n    if(result.get(c) <= map.get(c)) found = true;\n    if(found === false) break;\n    j += k;\n    total++;\n}\n```\n\n- 从位置 [i](file://E:\\其他项目\\algorithm_exercises\\91天学算法\\day1\\js.js#L6-L6) 开始，每次取长度为 `k` 的子串进行匹配\n- 使用 `result` 记录当前窗口中各单词的出现次数\n- 如果遇到不在 `words` 中的单词或某个单词出现次数超过要求，则提前终止\n- `total` 记录成功匹配的单词数\n\n### 5. 判断结果\n```javascript\nif(total === m) ans.push(i);\n```\n\n- 当成功匹配的单词数等于 `words` 长度时，说明找到了一个有效子串\n\n\n## 代码\n```javascript\n/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nvar findSubstring = function(s, words) {\n    let map = new Map();\n    words.forEach((word,i)=>{\n        map.set(word,(map.get(word) || 0) + 1);\n    });\n    let n = s.length,m = words.length,k = words[0].length,l = k * m;\n    if(n < l) return [];\n    let ans = [];\n    for(let i = 0;i <= n - l;i++){\n        let j = i,result = new Map(),total = 0;\n        while(j < i + l){\n            // console.log('check',s.slice(i,i + m * k));\n            let c = s.slice(j,j + k);\n            if(map.has(c) === false) break;\n            let found = false;\n            result.set(c,(result.get(c) || 0) + 1);\n            if(result.get(c) <= map.get(c)) found = true;\n            if(found === false) break;\n            j += k;\n            total++;\n        }\n        if(total === m) ans.push(i); \n    }\n    return ans;\n};\n```\n## 复杂度分析\n### 时间复杂度\n- 外层循环: O(n - l)\n- 内层循环: O(m)\n- 总体复杂度: O((n - l) × m)\n### 空间复杂度\nO(n)：存储单词频次映射和结果数组\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/27#issuecomment-3162347437","body":"## 思路\n\n使用前缀和 + 哈希表的方法，基于以下数学原理：\n\n1. 如果总和 `totalSum % p = delta`，我们需要找到一个子数组，其和模 `p` 也等于 `delta`\n2. 这样删除该子数组后，剩余元素和就能被 `p` 整除\n\n## 代码步骤分析\n\n### 1. 前缀和计算\n```javascript\nlet n = nums.length, sum = new Array(n + 1).fill(0);\nfor(let i = 0; i < n; i++) sum[i + 1] = sum[i] + nums[i];\n```\n\n- 构建前缀和数组 `sum`，其中 `sum[i]` 表示前 [i](file://E:\\其他项目\\algorithm_exercises\\91天学算法\\day1\\js.js#L6-L6) 个元素的和\n- `sum[0] = 0`，`sum[i] = nums[0] + nums[1] + ... + nums[i-1]`\n\n### 2. 计算目标余数\n```javascript\nlet delta = sum[n] % p;\nif(delta === 0) return 0;\n```\n\n- `sum[n]` 是所有元素的总和\n- `delta` 是总和对 `p` 的余数\n- 如果 `delta` 为 0，说明总和已能被 `p` 整除，返回 0\n\n### 3. 寻找最短子数组\n```javascript\nlet ans = Infinity;\nlet map = new Map();\nfor(let i = 0; i <= n; i++){\n    let b = sum[i], a = (b % p - delta % p + p) % p;\n    map.set(b % p, i);\n    if(map.has(a)) ans = Math.min(ans, i - map.get(a));\n}\n```\n\n\n关键数学关系：\n- 对于子数组 `nums[j...i-1]`，其和为 `sum[i] - sum[j]`\n- 我们希望 `(sum[i] - sum[j]) % p = delta`\n- 即 `sum[i] % p = (sum[j] + delta) % p`\n- 变形得：`sum[j] % p = (sum[i] % p - delta) % p`\n\n具体实现：\n- `b = sum[i]`：当前前缀和\n- `a = (b % p - delta % p + p) % p`：需要找到的前缀和余数\n- 用 [map](file://E:\\其他项目\\algorithm_exercises\\周赛\\459\\2.js#L5-L5) 记录每个余数值最后一次出现的位置\n- 如果找到对应的余数 [a](file://E:\\其他项目\\algorithm_exercises\\周赛\\459\\2.js#L27-L27)，则更新最短长度\n\n### 4. 返回结果\n```javascript\nreturn ans === n ? -1 : ans;\n```\n\n- 如果最短长度等于数组长度，说明需要删除整个数组，返回 -1\n- 否则返回找到的最短子数组长度\n\n## 代码\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} p\n * @return {number}\n */\nvar minSubarray = function(nums, p) {\n    let n = nums.length,sum = new Array(n + 1).fill(0);\n    for(let i = 0;i < n;i++) sum[i + 1] = sum[i] + (nums[i]);\n    // p = BigInt(p);\n    let delta = sum[n] % p;\n    if(delta === 0) return 0;\n    let ans = Infinity;\n    let map = new Map();\n    for(let i = 0;i <= n;i++){\n        let b = sum[i],a = (b % p - delta % p + p) % p;\n        map.set(b % p,i);\n        if(map.has(a)) ans = Math.min(ans,i - map.get(a));\n    }\n    return ans === n ? -1 : ans;\n};\n```\n\n## 复杂度分析\n- 时间复杂度：O(n)，只需遍历一次数组\n- 空间复杂度：O(n)，用于存储前缀和数组和哈希表","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/28#issuecomment-3166424389","body":"\n## 思路\n使用了经典的**快慢指针**（龟兔赛跑）算法。\n\n1. **双指针技巧**：\n    - `slow` 指针每次移动一步\n    - `fast` 指针每次移动两步\n    - 当 `fast` 到达链表末尾时，`slow` 正好在中间位置\n\n## 代码执行流程\n\n- **初始化**：两个指针 `slow` 和 `fast` 都指向链表头节点 [head](file://E:\\其他项目\\algorithm_exercises\\程序员面试金典\\面试题02.04.分割链表\\main.js#L50-L50)\n- **循环条件**：`while (fast && fast.next)` 确保 `fast` 可以安全地移动两步\n- **指针移动**：\n    - `fast` 连续移动两步：`fast = fast.next; fast = fast.next;`\n    - `slow` 移动一步：`slow = slow.next;`\n- **返回结果**：当循环结束时，`slow` 指向中间节点\n\n## 处理奇偶数节点的情况\n\n- **奇数个节点**：返回正中间的节点\n- **偶数个节点**：返回第二个中间节点（如链表有4个节点，则返回第3个节点）\n\n\n## 代码\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function(head) {\n    let slow = head,fast = head;\n    while(fast && fast.next){\n        fast = fast.next;\n        fast = fast.next;\n        slow = slow.next;\n    }\n    return slow;\n};\n```\n\n## 复杂度分析\n- 时间复杂度：O(n)，其中 n 是链表的节点数。\n- 空间复杂度：O(1)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/29#issuecomment-3169628215","body":"## 思路\n\n1. 使用双指针技术：\n    - [r](file:///E:/力扣刷题/algorithm_exercises/周赛/456/2.js#L10-L17) 指针（慢指针）：指向不重复序列的最后一个元素位置\n    - [i](file:///E:/力扣刷题/algorithm_exercises/程序员面试金典/面试题08.07.无重复字符串的排列组合/main.js#L9-L22) 指针（快指针）：用于遍历整个数组\n\n2. 初始化：\n    - [r](file:///E:/力扣刷题/algorithm_exercises/周赛/456/2.js#L10-L17) 从 0 开始，表示第一个元素肯定是要保留的\n    - [i](file:///E:/力扣刷题/algorithm_exercises/程序员面试金典/面试题08.07.无重复字符串的排列组合/main.js#L9-L22) 从 1 开始遍历\n\n3. 核心逻辑：\n    - 当 `nums[i] > nums[r]` 时，说明找到了一个新的不重复元素\n    - 此时将 [r](file:///E:/力扣刷题/algorithm_exercises/周赛/456/2.js#L10-L17) 向前移动一位，并将 `nums[i]` 与 `nums[r]` 交换\n    - 由于数组是排序的，所以只需要比较大小就能判断是否是新元素\n\n4. 返回值：\n    - 返回 [r](file:///E:/力扣刷题/algorithm_exercises/周赛/456/2.js#L10-L17) + 1，即不重复元素的个数\n\n### 示例演示：\n\n假设数组为 [0, 0, 1, 1, 2, 2]：\n\n1. 初始：r = 0, i = 1，nums[1] = 0, nums[0] = 0，不满足 `nums[i] > nums[r]`\n2. i = 2，nums[2] = 1, nums[0] = 0，满足 `nums[2] > nums[0]`，r 变为 1，交换 nums[2] 和 nums[1]\n    - 数组变为 [0, 1, 0, 1, 2, 2]，r = 1\n3. i = 3，nums[3] = 1, nums[1] = 1，不满足 `nums[i] > nums[r]`\n4. i = 4，nums[4] = 2, nums[1] = 1，满足 `nums[4] > nums[1]`，r 变为 2，交换 nums[4] 和 nums[2]\n    - 数组变为 [0, 1, 2, 1, 0, 2]，r = 2\n5. i = 5，nums[5] = 2, nums[2] = 2，不满足 `nums[i] > nums[r]`\n6. 结束，返回 r + 1 = 3\n\n\n## 代码\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    let n = nums.length,r = 0;\n    for(let i = 1;i < n;i++){\n        if(nums[i] > nums[r]) {\n            r++;\n            swap(i,r);\n        }\n        //console.log(nums);\n    }\n    return r + 1;\n    // ------------------------\n    function swap(i,j){\n        [nums[i],nums[j]] = [nums[j],nums[i]]\n    }\n};\n```\n\n### 复杂度分析：\n\n- 时间复杂度：O(n)，只需要遍历一次数组\n- 空间复杂度：O(1)，只使用了常数级别的额外空间\n- 利用了数组已经排序的特性，通过比较大小判断是否重复\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/30#issuecomment-3172297646","body":"## 思路\n经典的二分查找算法，用于在有序数组中找到目标值的插入位置\n1. **初始化变量**：\n    - `n`：数组长度\n    - `l`：左边界，初始为0\n    - `r`：右边界，初始为n-1\n    - `ans`：结果位置，初始为n（表示插入到数组末尾）\n\n2. **二分查找逻辑**：\n    - 使用标准二分查找模板，当`l <= r`时继续查找\n    - `mid = (l + r) >> 1`：计算中间位置（相当于除以2取整）\n    - 关键判断：`if(nums[mid] >= target)`\n        - 如果中间元素大于等于目标值，说明目标值应该在左半部分（包括mid位置）\n        - 更新`ans = mid`，并将右边界移动到`mid - 1`\n        - 否则，目标值在右半部分，将左边界移动到`mid + 1`\n\n3. **返回结果**：\n    - 返回找到的插入位置`ans`\n\n### 特殊情况处理\n\n- 如果target小于所有元素，ans保持为0（正确位置）\n- 如果target大于所有元素，ans保持为n（数组长度，正确位置）\n- 如果target等于某个元素，ans为该元素的索引\n- 如果target介于两个元素之间，ans为较大元素的位置\n\n这个实现非常优雅，通过一个变量ans记录可能的答案，避免了在循环外再进行额外判断，使得代码简洁且易于理解。\n## 代码\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchInsert = function(nums, target) {\n    let n = nums.length;\n    let l = 0, r = n - 1,ans = n;\n    while(l <= r){\n        let mid = (l + r) >> 1;\n        if(nums[mid] >= target){\n            ans = mid;\n            r = mid - 1;\n        }else l = mid + 1;\n    }\n    return ans;\n};\n```\n\n### 复杂度分析\n\n1. **时间复杂度**：O(log n)，典型的二分查找时间复杂度\n2. **空间复杂度**：O(1)，只使用了常数级别的额外空间\n3. **核心思想**：寻找第一个大于等于target的元素位置","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/31#issuecomment-3173065451","body":"## 思路\n\n这段代码使用**单调队列**（双端队列）来解决滑动窗口最大值问题，时间复杂度为 O(n)。\n\n### 实现步骤\n\n1. **数据结构选择**\n    - 使用 `q` 数组作为双端队列，存储数组元素的**索引**\n    - 队列中保持索引对应的值**单调递减**的特性\n\n2. **维护单调性**\n   ```javascript\n   while(q.length && back() < nums[i]) q.pop();\n   q.push(i);\n   ```\n\n    - 在每次添加新元素前，移除队尾所有小于当前元素的索引\n    - 这样保证队首始终是当前窗口的最大值索引\n\n3. **窗口处理**\n   ```javascript\n   if(i >= k - 1){\n       ans.push(nums[q[0]]);  // 队首即为窗口最大值\n       if(i - q[0] + 1 === k) q.shift();  // 移除窗口外的元素\n   }\n   ```\n\n    - 当达到窗口大小时开始记录结果\n    - 及时移除超出窗口范围的索引\n\n### 关键技巧\n\n- 存储索引而非值，便于判断元素是否在窗口范围内\n- 利用单调性快速获取窗口最大值（队首元素）\n- 通过索引差值判断元素是否需要移出窗口\n\n### 缺陷\n在javascript中，使用数组模拟双端队列，队首出队、入队的时间复杂度均为O(n)，性能较差，可以考虑手动实现一个双端队列，例如使用双向链表，优化性能。\n\n## 代码\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar maxSlidingWindow = function(nums, k) {\n    let q = [],n = nums.length;\n    let ans = [];\n    for(let i = 0;i < n;i++){\n        while(q.length && back() < nums[i]) q.pop();\n        q.push(i);\n        if(i >= k - 1){\n            ans.push(nums[q[0]]);\n            if(i - q[0] + 1 === k) q.shift();\n        }\n    }\n    return ans;\n    // ------------------------\n    function back(){\n        return nums[q[q.length - 1]];\n    }\n};\n```\n\n## 复杂度分析\n- 时间复杂度：O(n)，其中 n 是数组的长度。单调队列的维护时间复杂度为 O(n)，窗口处理时间复杂度为 O(n)，因此总时间复杂度为 O(n)。\n- 空间复杂度：O(n)，单调队列最多存储 n 个元素，因此空间复杂度为 O(n)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/32#issuecomment-3177500710","body":"## 思路\n\n### 1. 数据结构设计\n- 使用两个数组 `ind` 和 `outd` 分别记录每个人的入度和出度\n- 数组长度为 `n+1` 是为了方便使用1到n的索引对应人编号\n\n### 2. 统计过程\n```javascript\nfor(let [a,b] of trust){\n    outd[a]++;  // a相信别人，出度+1\n    ind[b]++;   // b被别人相信，入度+1\n}\n```\n\n- 遍历信任关系数组，统计每个人的入度和出度\n\n### 3. 法官判断\n```javascript\nfor(let i = 1;i <= n;i++){\n    if(outd[i] === 0 && ind[i] === n - 1) return i;\n}\n```\n\n- 遍历所有人，寻找满足条件的人：\n    - `outd[i] === 0`：不相信任何人\n    - `ind[i] === n - 1`：被其他所有人相信\n\n这是典型的图论中利用入度出度解决问题的方法。\n\n## 代码\n```javascript\n/**\n * @param {number} n\n * @param {number[][]} trust\n * @return {number}\n */\nvar findJudge = function(n, trust) {\n    let ind = new Array(n + 1).fill(0),// 入度\n    outd = new Array(n + 1).fill(0);// 出度\n    for(let [a,b] of trust){\n        outd[a]++;\n        ind[b]++;\n    }\n    for(let i = 1;i <= n;i++){\n        if(outd[i] === 0 && ind[i] === n - 1) return i;\n    }\n    return -1;\n};\n```\n\n## 复杂度分析\n- 时间复杂度：O(T + N)，其中T是信任关系数，N是人数\n- 空间复杂度：O(N)，用于存储入度和出度数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/33#issuecomment-3182022991","body":"## 思路\n\n### 1. 图的构建\n- 使用邻接表`g`存储不喜欢关系\n- 对于每一对`[a,b]`，在[a](file://E:\\其他项目\\algorithm_exercises\\周赛\\459\\2.js#L27-L27)的邻接表中添加`b`，在`b`的邻接表中添加[a](file://E:\\其他项目\\algorithm_exercises\\周赛\\459\\2.js#L27-L27)\n- 这样构建出一个无向图，表示不喜欢关系\n\n### 2. 二分图判断\n- 使用染色法判断是否为二分图\n- `color`数组记录每个节点的颜色状态：\n    - `0`表示未染色\n    - `1`表示第一组\n    - `2`表示第二组\n\n### 3. DFS遍历\n- 遍历所有节点，对未染色节点开始DFS\n- [f(i, val)](file://E:\\其他项目\\algorithm_exercises\\19.js#L10-L17)函数：\n    - 将节点[i](file://E:\\其他项目\\algorithm_exercises\\91天学算法\\day1\\js.js#L6-L6)染成颜色[val](file://E:\\其他项目\\algorithm_exercises\\libs\\LinkedList.js#L34-L34)\n    - 遍历[i](file://E:\\其他项目\\algorithm_exercises\\91天学算法\\day1\\js.js#L6-L6)的所有邻居节点`j`\n    - 如果邻居`j`已有颜色且与[i](file://E:\\其他项目\\algorithm_exercises\\91天学算法\\day1\\js.js#L6-L6)相同，返回`false`\n    - 如果邻居`j`未染色，递归将其染成相反颜色\n    - 所有情况满足则返回`true`\n\n### 4. 核心逻辑\n- 主函数中遍历所有节点，对未染色节点调用[f](file://E:\\其他项目\\algorithm_exercises\\19.js#L10-L17)函数\n- 如果任何一次调用返回`false`，说明无法二分，返回`false`\n- 全部成功则返回`true`\n\n这是典型的二分图判定问题，通过图的遍历和染色来解决。\n## 代码\n```javascript\n/**\n * @param {number} n\n * @param {number[][]} dislikes\n * @return {boolean}\n */\nvar possibleBipartition = function(n, dislikes) {\n    let g = new Array(n + 1).fill(0).map(()=>[]);\n    for(let [a,b] of dislikes){\n        g[a].push(b);\n        g[b].push(a);\n    }\n    let color = new Array(n + 1).fill(0);\n    for(let i = 1;i <= n;i++){\n        if(color[i] === 0 && !f(i,1)) return false;\n    }\n    return true;\n\n    // ------------------------\n    function f(i,val){\n        color[i] = val;\n        for(let j of g[i]){\n            if(color[j] && color[j] === val) return false;\n            if(!color[j] && !f(j,val === 1 ? 2 : 1)) return false;        \n        }\n        return true;\n    }\n};\n```\n## 复杂度分析\n- 时间复杂度：O(n + dislikes.length) - 线性时间复杂度\n- 空间复杂度：O(n + dislikes.length) - 主要用于存储图结构和递归栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/34#issuecomment-3186678361","body":"## 主要思路\n\n### 1. 预处理阶段\n- **处理未分配项目**：将 `group[i] === -1` 的项目分配给新的虚拟组\n- **构建组内项目映射**：建立 `groupItems` 数组，记录每个组包含的项目\n\n### 2. 构建依赖图\n- **项目依赖图** (`itemG`)：记录项目间的依赖关系\n- **小组依赖图** (`groupG`)：记录小组间的依赖关系\n- **计算入度**：\n    - `inID`：每个项目的入度\n    - `inGD`：每个小组的入度\n\n### 3. 双层拓扑排序\n- **组间拓扑排序**：先对小组进行拓扑排序\n- **组内拓扑排序**：对每个小组内的项目进行拓扑排序\n\n## 关键函数分析\n\n### 主函数流程\n```javascript\n// 初始化和构建图结构\n// ...\n\n// 组间拓扑排序\nfor(let i = 0;i <= m;i++){\n    if(inGD[i] === 0) qG.enqueue(i);\n}\nwhile(qG.size()){\n    let i = qG.dequeue();\n    getItemsFromGroup(i);  // 处理组内项目\n    // 更新小组依赖\n}\n```\n\n\n### 组内拓扑排序函数 `getItemsFromGroup`\n```javascript\nfunction getItemsFromGroup(g){\n    // 对特定组内的项目进行拓扑排序\n    // 只处理组内依赖关系\n}\n```\n\n## 核心思想\n采用**分层拓扑排序**策略：\n1. 先确保小组间的依赖关系满足\n2. 再确保每个小组内部的项目依赖关系满足\n3. 通过双层 BFS 实现完整的排序逻辑\n\n这种解法有效地将复杂的依赖关系分解为两个相对简单的拓扑排序问题。\n\n## 代码\n```javascript\n/**\n * @param {number} n\n * @param {number} m\n * @param {number[]} group\n * @param {number[][]} beforeItems\n * @return {number[]}\n */\nvar sortItems = function(n, m, group, beforeItems) {\n        for(let i = 0;i < n;i++){\n            if(group[i] === -1) group[i] = m++;\n        }\n\n        let groupItems = new Array(m).fill(0).map(()=>[]);\n        for(let i = 0;i < n;i++){\n            groupItems[group[i]].push(i);\n        }\n\n\n\n        let itemG = new Array(n).fill(0).map(()=>[]);// 项目依赖关系建图\n        let groupG = new Array(m).fill(0).map(()=>new Set());// 小组依赖关系建图\n        let inID = new Array(n).fill(0);//每个项目的入度\n        let inGD = new Array(m).fill(0);//每个小组的入度\n        beforeItems.forEach((prevs,curr)=>{\n            inID[curr] += prevs.length;\n            for(let prev of prevs) {\n                itemG[prev].push(curr);\n                let u = group[prev],v = group[curr];\n                if(u === v) continue;\n                if(groupG[u].has(v)) continue;\n                groupG[u].add(v);\n                inGD[v]++;\n            }\n        });\n\n        //console.log('小组依赖',groupG,groupItems);\n\n        let ans = [],qG = new Queue();\n\n\n        for(let i = 0;i <= m;i++){\n            if(inGD[i] === 0) qG.enqueue(i);\n        }\n        while(qG.size()){\n            let i = qG.dequeue();\n            getItemsFromGroup(i);\n            for(let j of groupG[i]){\n                inGD[j]--;\n                if(inGD[j] === 0) qG.enqueue(j);\n            }\n        }\n        return ans.length === n ? ans : [];\n\n        // ---------------------------------\n        function getItemsFromGroup(g){\n            let items = groupItems[g];\n            let qI = new Queue();\n            for(let i of items){\n                if(inID[i] === 0) qI.enqueue(i);\n            }\n            while(qI.size()){\n                let i = qI.dequeue();\n                ans.push(i);\n                for(let j of itemG[i]){\n                    inID[j]--;\n                    if(inID[j] === 0 && group[j] === g) qI.enqueue(j);\n                }\n            }\n        }\n\n    };\n```\n## 复杂度分析\n- **时间复杂度**：O(n + m + |beforeItems|) - 每个项目和依赖关系只被处理一次\n- **空间复杂度**：O(n + m) - 存储图结构和队列","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/35#issuecomment-3190382685","body":"## 思路\n没啥好说的，模拟就完了\n## 代码\n```javascript\n/**\n * @param {string} moves\n * @return {boolean}\n */\nvar judgeCircle = function(moves) {\n  let x = 0,y = 0;\n  for(let move of moves){\n    if(move === 'U') x--;\n    else if(move === 'D') x++;\n    else if(move === 'L') y--;\n    else y++;\n  }  \n  return x === 0 && y === 0\n};\n```\n## 复杂度分析\n- 时间复杂度O(n)\n- 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/36#issuecomment-3193453621","body":"## 思路\n\n### 主要步骤：\n\n1. **数据预处理**：\n    - 将原始任务数组 [enqueueTime, processingTime] 扩展为 [enqueueTime, processingTime, index]，保留原始索引信息\n    - 按照入队时间（enqueueTime）对任务进行排序\n\n2. **使用优先队列**：\n    - 创建一个优先队列，排序规则是：\n        - 首先按处理时间（processingTime）升序排列\n        - 如果处理时间相同，则按下标（index）升序排列\n\n3. **任务处理逻辑**：\n    - 初始化结果数组和当前时间点（end）\n    - 当还有未处理任务或优先队列不为空时：\n        - 如果优先队列为空，将当前时间点更新为下一个任务的入队时间\n        - 将所有在当前时间点之前或刚好到达的未处理任务加入优先队列\n        - 从优先队列中取出优先级最高的任务执行\n        - 更新当前时间点（加上该任务的处理时间）\n        - 将该任务的原始索引加入结果数组\n\n### 关键点解释：\n\n- **优先队列的作用**：确保在可执行的任务中，总是选择处理时间最短的任务执行（最短作业优先调度算法）\n- **时间管理**：通过 [end] 变量追踪当前时间点，确保任务按时间顺序被考虑\n- **边界处理**：当优先队列为空时，直接跳转到下一个任务的入队时间，避免不必要的循环\n\n## 代码\n```javascript\n/**\n * @param {number[][]} tasks\n * @return {number[]}\n */\nvar getOrder = function(tasks) {\n    let data = [],n = tasks.length;\n    // 按任务入队时间排序，同时不丢失下标信息。\n    tasks.forEach((v,i)=>data.push([...v,i])); \n    data.sort((a,b)=>a[0] - b[0]);\n    // 优先队列，优先级为：先按任务时长，再按下标\n    let i = 0,q = new PriorityQueue((a,b)=>{\n        if(a[1] !== b[1]) return a[1] - b[1];\n        return a[2] - b[2];\n    });\n\n    let ans = [],end = 0;\n    while(i < n || q.size()){\n        if(q.size() === 0) end = Math.max(end,data[i][0]);\n        while(i < n && data[i][0] <= end) q.enqueue(data[i++]);\n        let [_,p,index] = q.dequeue();\n        ans.push(index);\n        end += p;\n    }\n    return ans;\n};\n```\n\n## 复杂度分析\n### 时间复杂度：\n- 排序：O(n log n)\n- 优先队列操作：每个任务最多入队和出队一次，每次操作 O(log n)\n- 总体复杂度：O(n log n)\n### 空间复杂度：\n- 需要一个优先队列及一个数组保存数据，空间复杂度为 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/37#issuecomment-3194152066","body":"## 思路\n\n### 主要函数功能\n\n1. [numberOfRounds](file:///E:/力扣刷题/algorithm_exercises/.md#L4-L13) - 主函数，计算从登录到登出之间的完整游戏回合数\n2. [parseTime](file:///E:/力扣刷题/algorithm_exercises/.md#L16-L18) - 辅助函数，将时间字符串解析为小时和分钟\n3. [calc](file:///E:/力扣刷题/algorithm_exercises/.md#L20-L37) - 核心计算函数，计算两个时间之间的回合数\n\n### 解题思路\n\n1. **时间解析**：首先将登录时间和登出时间解析为小时和分钟的数组\n2. **跨天处理**：如果登出时间早于登录时间，说明跨越了午夜，需要在登出时间上加24小时\n3. **回合计算**：\n    - 将登录时间向上取整到最近的15分钟倍数（下一回合开始时间）\n    - 计算登出时间和登录时间之间的15分钟间隔数\n    - 如果结果为负数，则返回0\n\n### 代码细节\n\n```javascript\n// 时间取整逻辑\nif(m1 <= 0) m1 = 0;\nelse if(m1 <= 15) m1 = 15;\nelse if(m1 <= 30) m1 = 30;\nelse if(m1 <= 45) m1 = 45;\nelse {\n    m1 = 0;\n    h1++;\n}\n```\n\n这个逻辑将登录时间向上取整到下一个回合开始时间（每15分钟为一个回合）。\n\n```javascript\nlet ans = Math.floor((h2 * 60 + m2 - (h1 * 60 + m1)) / 15);\n```\n这行代码计算两个时间点之间有多少个完整的15分钟时间段。\n\n## 代码\n```javascript\n/**\n * @param {string} loginTime\n * @param {string} logoutTime\n * @return {number}\n */\nvar numberOfRounds = function(loginTime, logoutTime) {\n    let [h1,m1] = parseTime(loginTime),[h2,m2] = parseTime(logoutTime);\n    if(h1 < h2 || h1 === h2 && m1 < m2) return calc(h1,m1,h2,m2);\n    return calc(h1,m1,h2 + 24,m2);\n    // -------------------------\n    function parseTime(time){\n        return time.split(':').map(v=>Number(v));\n    }\n\n    function calc(h1,m1,h2,m2){\n        if(m1 <= 0) m1 = 0;\n        else if(m1 <= 15) m1 = 15;\n        else if(m1 <= 30) m1 = 30;\n        else if(m1 <= 45) m1 = 45;\n        else {\n            m1 = 0;\n            h1++;\n        }\n        // console.log(h1,m1,h2,m2)\n        let ans = Math.floor((h2 * 60 + m2 - (h1 * 60 + m1)) / 15);\n        if(ans < 0) return 0;\n        return ans;\n    }\n};\n```\n\n## 复杂度分析\n- 时间复杂度：O(1)，因为解析时间和计算都是常数时间操作。\n- 空间复杂度：O(1)，因为只使用了常数个变量。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/38#issuecomment-3195140726","body":"## 思路\n\n### 主函数 `minCharacters`\n- 通过比较三种情况的最小值来得到最终答案：\n    - `altb(a,b)`: 使 a 中所有字符 < b 中所有字符需要的操作数\n    - `altb(b,a)`: 使 b 中所有字符 < a 中所有字符需要的操作数\n    - `aeqb(a,b)`: 使两个字符串都由同一字符组成需要的操作数\n\n### 辅助函数分析\n\n1. **`altb(a,b)` 函数**\n    - 遍历分割点 [i](file://E:\\其他项目\\algorithm_exercises\\91天学算法\\day1\\js.js#L6-L6) (1-25，对应字符 'b'-'z')\n    - 计算需要修改的字符数：\n        - [a](file://E:\\其他项目\\algorithm_exercises\\周赛\\459\\2.js#L27-L27) 中所有 ≥ i 的字符都需要修改\n        - `b` 中所有 < i 的字符都需要修改\n    - 返回最小操作数\n\n2. **`aeqb(a,b)` 函数**\n    - 统计两个字符串中各字符出现次数\n    - 找到出现频率最高的字符\n    - 将其他所有字符都修改为该字符即为最少操作数\n\n3. **`getCharValue` 函数**\n    - 将字符转换为对应的数值 (a=0, b=1, ..., z=25)\n\n## 代码\n```javascript\n/**\n * @param {string} a\n * @param {string} b\n * @return {number}\n */\nvar minCharacters = function(a, b) {\n    return Math.min(altb(a,b),altb(b,a),aeqb(a,b));\n    // --------------------------------------\n    function altb(a,b){\n        let ans = Infinity;\n        for(let i = 1;i < 26;i++){\n            let temp = 0;\n            for(let c of a) if(getCharValue(c) >= i) temp++;\n            for(let c of b) if(getCharValue(c) < i) temp++;\n            ans = Math.min(ans,temp);\n        }\n        return ans;\n    }\n\n    function aeqb(a,b){\n        let data = new Array(26).fill(0);\n        for(let c of a) data[getCharValue(c)]++;\n        for(let c of b) data[getCharValue(c)]++;\n        let max = data.reduce((a,b)=>Math.max(a,b),0);\n        return a.length + b.length - max;\n    }\n\nfunction getCharValue(char){\n        return char.charCodeAt(0) - 'a'.charCodeAt(0);\n    }\n};\n```\n\n\n## 复杂度分析\n- 时间复杂度：O((m+n)×26) = O(m+n)，其中 m 和 n 分别是字符串 a 和 b 的长度\n- 空间复杂度：O(1)，只使用了固定大小的额外空间\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/39#issuecomment-3199063845","body":"## 思路\n使用**三路快排（Three-way QuickSort）**的实现，主要通过以下步骤完成排序：\n1. **选择基准值（pivot）**：使用 `viot` 函数选择一个合适的基准值\n2. **分区操作（partition）**：将数组分为三部分：小于基准值、等于基准值、大于基准值\n3. **递归排序**：对小于和大于基准值的两个子数组递归进行快排\n\n## 关键函数分析\n\n### 1. 主排序函数 `quickSort`\n```javascript\nfunction quickSort(l,r){\n    if(l >= r) return;\n    let i = viot(l,r);        // 选择基准值位置\n    if(r - l === 1) return;\n    if(i !== l) swap(i,l);    // 将基准值移到最左边\n    let [low,up] = partition(l,r);  // 三路分区\n    quickSort(l,low - 1);     // 递归排序小于基准值的部分\n    quickSort(up + 1,r);      // 递归排序大于基准值的部分\n}\n```\n\n\n### 2. 基准值选择 `viot`\n```javascript\nfunction viot(l,r){\n    // 选择左、中、右三个元素作为候选\n    let a = nums[l], c = nums[r];\n    let mid = (l + r) >> 1, b = nums[mid];\n    \n    // 通过比较这三个值选择一个较优的基准值位置\n    // 实现了三数取中法的思想\n}\n```\n\n\n### 3. 三路分区 [partition](file://E:\\其他项目\\algorithm_exercises\\程序员面试金典\\面试题02.04.分割链表\\main.js#L15-L48)\n```javascript\nfunction partition(i,j){\n    let viot = nums[i], l = i - 1, r = j + 1;\n    for(let k = i; k < r; k++){\n        let c = nums[k];\n        if(c > viot){\n            r--;\n            swap(k,r);\n            k--;  // 交换后需要重新检查当前位置\n        }else if(c < viot){\n            l++;\n            swap(k,l);\n        }\n        // c === viot 时，元素保持在中间区域\n    }\n    return [l + 1, r - 1];  // 返回等于基准值的区间边界\n}\n```\n\n## 代码\n```javascript\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar sortArray = function(nums) {\n        quickSort(0,nums.length - 1);\n        return nums;\n        // -------------------------\n        function quickSort(l,r){\n            if(l >= r) return;\n            // console.log(l,r,nums);\n            // 找基准值位置\n            let i = viot(l,r);\n            if(r - l === 1) return;\n            if(i !== l) swap(i,l);\n            // console.log('viot',nums[l]);\n            let [low,up] = partition(l,r);\n            // console.log(mid,nums);\n            quickSort(l,low - 1);\n            quickSort(up + 1,r);\n        }\n\n        function partition(i,j){\n            let viot = nums[i],l = i - 1,r = j + 1;\n            for(let k = i;k < r;k++){\n                let c = nums[k];\n                if(c > viot){\n                    r--;\n                    swap(k,r);\n                    k--;\n                }else if(c < viot){\n                    l++;\n                    swap(k,l);\n                }\n            }\n            return [l + 1,r - 1];\n        }\n\n        function viot(l,r){\n            let a = nums[l],c = nums[r];\n            if(a > c){\n                swap(l,r);\n                a = nums[l];\n                c = nums[r];\n            }\n            if(r - l === 1) return;\n            let mid = (l + r) >> 1,b = nums[mid];\n            // if(a === c && a === b) return l;\n            if(a === c) return a < b ? l : mid;\n            if(b === a || b === c) return l;\n            else if(b < a) return l;\n            else if(b > a && b < c) return mid;\n            return r;\n        }\n\n        function swap(l,r){\n            [nums[l],nums[r]] = [nums[r],nums[l]];\n        }\n    };\n```\n\n## 复杂度分析\n- **三路快排**：能够很好地处理有重复元素的数组，将相等元素聚集在一起\n- **优化的基准值选择**：使用三数取中法减少最坏情况的发生\n- **原地排序**：不需要额外的存储空间\n- **时间复杂度**：平均 O(n log n)，最坏 O(n²)\n- **空间复杂度**：O(log n)（递归调用栈）\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"haoyuliaocurb":[{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/4#issuecomment-3073435345","body":"```\n// Time Complexity: O(max(num.length, k))\n// Space Complexity: O(max(num.length, k))\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    const num1 = num;\n    const num2 = String(k).split('').map(v => Number(v));\n    const sum = [];\n\n    for (let i = 0; i < Math.max(num1.length, num2.length); i += 1) {\n        const s = (num1[num1.length - 1 - i] ?? 0) + (num2[num2.length - 1 - i] ?? 0) + (sum[i] ?? 0);\n\n        sum[i] = s % 10;\n        sum[i + 1] = (s - (s % 10)) / 10;\n    }\n\n    if (sum[sum.length - 1] === 0) sum.pop();\n    sum.reverse();\n\n    return sum;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/5#issuecomment-3078842293","body":"【解題方向】\n\n第一想法：對於每一個 s[i] 都遍歷一次找最近的 c，Time Complexity 為 O(n^2) \n\n第二想法：先遍歷一遍 s 找到所有的 c，然後從所有的 c 開始向兩邊走\n\t=> 不過想到如何記錄狀態就覺得太複雜，而且可能最糟情況還是 Time Complexity 為 O(n^2) \n\n第三想法：看了提示，想到正向遍歷、反向遍歷一次，記錄 s[i] 與左右兩邊的 c 的最小距離\n\t=> 由於題目保證至少有一個 s 中至少有一個 c，對於每個 s[i]，其左或右必然會有一個 c\n\n【程式碼】\n```\n// Time Complexity: O(n), n = s.length;\n// Space Complexity: O(n), n = s.length;\n\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    const chars = s.split('');\n    const res = new Array(chars.length).fill(Infinity);\n\n    let leftTargetCharIndex = -1;\n    for (let i = 0; i < chars.length; i += 1) {\n        if (chars[i] === c) leftTargetCharIndex = i;\n        if (leftTargetCharIndex > -1) {\n            res[i] = Math.min(res[i], Math.abs(leftTargetCharIndex - i));\n        }\n    }\n\n    let rightTargetCharIndex = -1;\n    for (let i = chars.length - 1; i > -1; i -= 1) {\n        if (chars[i] === c) rightTargetCharIndex = i;\n        if (rightTargetCharIndex > -1) {\n            res[i] = Math.min(res[i], Math.abs(rightTargetCharIndex - i));\n        }\n    }\n\n    return res;\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/7#issuecomment-3089452516","body":"1. 第一個直覺是用 recursion 來解題，不過過程中會遇到很多 edge case 沒有考慮到而 error thrown\n2. 後來改用 stack 來實踐，也很清楚，不過需要搞懂什麼應該被放進 stack，以及 pop and push 的時機\n\n```\n// Time Complexity: O(n)\n// Space Complexity: O(n)\n\n/**\n * Recursive version of decodeString\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    const helper = (str, index) => {\n        let result = '';\n        let num = 0;\n        \n        while (index < str.length) {\n            const char = str[index];\n            \n            if (char >= '0' && char <= '9') {\n                num = num * 10 + parseInt(char);\n                index++;\n            } else if (char === '[') {\n                // Recursively decode the content inside brackets\n                const [decodedStr, newIndex] = helper(str, index + 1);\n                result += decodedStr.repeat(num);\n                num = 0; // Reset number after using it\n                index = newIndex;\n            } else if (char === ']') {\n                // End of current bracket section - return result and current index\n                return [result, index + 1];\n            } else {\n                // Regular character\n                result += char;\n                index++;\n            }\n        }\n        \n        return [result, index];\n    };\n    \n    return helper(s, 0)[0];\n};\n\n// Time Complexity: O(n)\n// Space Complexity: O(n)\n\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    const stack = [];\n    let currentStr = '';\n    let currentNum = 0;\n    \n    for (let i = 0; i < s.length; i++) {\n        const char = s[i];\n        \n        if (char >= '0' && char <= '9') {\n            currentNum = currentNum * 10 + parseInt(char);\n        } else if (char === '[') {\n            // Push current state to stack\n            stack.push([currentStr, currentNum]);\n            currentStr = '';\n            currentNum = 0;\n        } else if (char === ']') {\n            // Pop from stack and decode\n            const [prevStr, num] = stack.pop();\n            currentStr = prevStr + currentStr.repeat(num);\n        } else {\n            // Regular character\n            currentStr += char;\n        }\n    }\n    \n    return currentStr;\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/8#issuecomment-3091467280","body":"透過第二個 stack 倒轉第一個 in-stack 的順序，以達到 FIFO 的效果\n```\n// Time Complexity: O(1) for push, pop, peek, empty;\n// Space Complexity: O(n)\n\nclass MyQueue {\n    constructor() {\n        this.inStack = [];\n        this.outStack = [];\n    }\n\n    /** \n     * @param {number} x\n     * @return {void}\n     */\n    push(x) {\n        this.inStack.push(x);\n    }\n\n    /**\n     * @return {number}\n     */\n    pop() {\n        if (!this.outStack.length) {\n            this.pushToOutStack();\n        }\n\n        return this.outStack.pop();\n    }\n\n    /**\n     * @return {number}\n     */\n    peek() {\n        if (!this.outStack.length) {\n            this.pushToOutStack();\n        }\n\n        return this.outStack[this.outStack.length - 1];\n    }\n\n    /**\n     * @return {boolean}\n     */\n    empty() {\n        return this.peek() === undefined;\n    }\n\n    pushToOutStack() {\n        while (this.inStack.length) {\n            this.outStack.push(this.inStack.pop());\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/9#issuecomment-3094426027","body":"// Time Complexity: O(n);\n// Space Complexity: O(n);\n\n```\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    const sortedArr = [...arr].sort((a, b) => a - b);\n    let counts = {};\n    let chunkAmount = 0;\n\n    for (let i = 0; i < arr.length; i += 1) {\n        counts[arr[i]] = (counts[arr[i]] ?? 0) + 1;\n        counts[sortedArr[i]] = (counts[sortedArr[i]] ?? 0) - 1;\n\n        if (Object.values(counts).every((value) => value === 0)) {\n            chunkAmount += 1;\n        }\n    }\n\n    return chunkAmount;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/10#issuecomment-3095908728","body":"```\n// Time Complexity: O(n);\n// Space Complexity: O(1);\n\nvar rotateRight = function (head, k) {\n  if (!head || !head.next) return head;\n\n  let length = 0;\n  let cur = head;\n\n  while (cur) {\n    cur = cur.next;\n    length += 1;\n  }\n\n  k = k % length;\n  let left = head;\n  let right = head;\n\n  while (right.next) {\n    if (k <= 0) left = left.next;\n    right = right.next;\n    k -= 1;\n  }\n\n  right.next = head; // Handle the case when left and right point to the same node.\n  let res = left.next;\n  left.next = null;\n\n  return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/11#issuecomment-3102283858","body":"建立一個 dummy 連結在 head 之前，便可以將 head 當作中間節點處理。每次互換節點會牽涉四個節點，pre, cur, next, next.next，其中 pre 的初始值為 dummy，因此在每個迴圈保證有值，而真正要互換的 cur, next，其兩有值為 while 迴圈繼續的必要條件，next.next 為 null 則沒關係。\n\n```\n// Time Complexity: O(n);\n// Space Complexity: O(1);\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    const dummy = { val: 0, next: head };\n\n    let pre = dummy;\n    let cur = pre.next;\n    let next = cur?.next;\n\n    while (cur && next) {\n        pre.next = next;\n        cur.next = next.next;\n        next.next = cur;\n\n        [pre, cur, next] = [cur, cur.next, cur.next?.next];\n    }\n\n    return dummy.next;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/12#issuecomment-3105649705","body":"# 想法\n轉換成 Height Balanced Binary Search Tree 會需要進行 Binary Search，考慮到單向鏈錶不方便直接存取 node，因此直接將鏈錶轉成數組，並直接以數組配合 Binary Search 遞迴建立樹。\n\n```\n\n// Time Complexity: O(n);\n// Space Complexity: O(n);\n\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    if (head === null) return null;\n\n    const dummy = new ListNode(0, head);\n    const arr = [];\n\n    let tail = dummy;\n\n    while (tail) {\n        const next = tail.next;\n        next && arr.push(next.val);\n        tail = next;\n    }\n\n    const inner = (l, r) => {\n        if (l > r) return null;\n        if (l === r) return new TreeNode(arr[r]);\n\n        const m = Math.ceil((l + r) / 2);\n\n        return new TreeNode(arr[m], inner(l, m - 1), inner(m + 1, r));\n    };\n\n    return inner(0, arr.length - 1);\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/13#issuecomment-3112936097","body":"## 思考方向\n### 雙指針\n用兩個指針分別從 headA, headB 開始走，走到盡頭換到另一個 head。過程中若指向同一個點則為兩鏈錶的交點，若皆遍歷一遍後無交點，則兩鏈錶無相交。\n\n```\n// Time Complexity: O(n);\n// Space Complexity: O(1);\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    let pointerA = headA;\n    let pointerB = headB;\n    let switchCounts = 0;\n\n    while (switchCounts < 3) {\n        if (pointerA === pointerB) return pointerA;\n\n        if (pointerA?.next) {\n            pointerA = pointerA.next;\n        } else {\n            switchCounts += 1;\n            pointerA = headB;\n        }\n\n        if (pointerB?.next) {\n            pointerB = pointerB.next;\n        } else {\n            switchCounts += 1;\n            pointerB = headA;\n        }\n    }\n\n    return null;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/14#issuecomment-3116343077","body":"## 解題方向\n- 快慢指針法\n\n## Edge Cases\n- 當快指針走到 null 代表沒有環\n\n```\n// Time Complexity: O(n);\n// Space Complexity: O(1);\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    let fast = head;\n    let slow = head;\n\n    do {\n        if (fast === null) return null;\n\n        fast = fast?.next?.next ?? null;\n        slow = slow?.next ?? null;\n    } while (fast !== slow);\n\n    fast = head;\n\n    while (fast !== slow) {\n        fast = fast?.next ?? null;\n        slow = slow?.next ?? null;\n    }\n\n    return fast;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/15#issuecomment-3121584769","body":"## 解題方向\n- 看到 FISO 的第一個想法是用 Queue，搭配 hash 也可以達到 get O(1) 的要求，不過 put 更新既有的值，就沒辦法 O(1)。\n若是 put 更新既有的值要 O(1)，還是需要使用鏈表。\n- 中間有一度 debug 卡關，主要是原本在 put 時無論如何都先把既有的 node 刪掉再新增，但這可能造成一些 state 更新上的錯誤，後來簡化為直接移動 node 才 AC。\n\n```\n// Time Complexity: O(1) for LRUCache.prototype.get, put\n// Space Complexity: O(n)\n\nfunction ListNode(key, val) {\n    this.key = key;\n    this.val = val;\n    this.next = null;\n    this.pre = null;\n }\n\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.capacity = capacity;\n    this.length = 0;\n    this.head = new ListNode();\n    this.tail = new ListNode();\n    this.head.next = this.tail;\n    this.tail.pre = this.head;\n    this.map = {};\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    const node = this.map[key];\n\n    if (node !== undefined) {\n        this.appendToTail(this.remove(node));\n        return node.val\n    };\n\n    return -1;\n};\n\n/** \n * @param {number} key \n * @param {number} val\n * @return {void}\n */\nLRUCache.prototype.put = function(key, val) {\n    const node = this.map[key];\n\n    if (node !== undefined) {\n        node.val = val;\n        this.appendToTail(this.remove(node));\n    } else {\n        if (this.length === this.capacity) {\n            const old = this.head.next;\n            delete this.map[old.key];\n            this.length -= 1;\n            this.remove(old);\n        }\n\n        const node = new ListNode(key, val);\n        this.map[key] = node;\n        this.length += 1;\n        this.appendToTail(node);\n    }\n};\n\nLRUCache.prototype.appendToTail = function(node) {\n    if (node.pre) node.pre.next = node.next;\n    if (node.next) node.next.pre = node.pre;\n    this.tail.pre.next = node;\n    node.pre = this.tail.pre;\n    node.next = this.tail;\n    this.tail.pre = node;\n}\n\nLRUCache.prototype.remove = function(node) {\n    node.pre.next = node.next;\n    node.next.pre = node.pre;\n    node.pre = null;\n    node.next = null;\n\n    return node;\n}\n\n/** \n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/16#issuecomment-3123752698","body":"## 解題方向\n### DFS\n- 需注意當 helper 的 params root 為 null 時，應回傳 0\n\n```\n// Time Complexity: O(n), n for numbers of nodes.\n// Space Complexity: O(h), h for the max depth of tree.\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    const helper = (root) => {\n        if (!root) return 0;\n        if (!root.left && !root.right) return 1;\n        return Math.max(helper(root.left), helper(root.right)) + 1;\n    };\n\n    return helper(root);\n};\n```\n\n### Layer Iteration\n- 由於 stack 的起始值就有一個 root node，因此要先處理 root 為 null 的狀況\n\n```\n// Time Complexity: O(n), n for numbers of nodes.\n// Space Complexity: O(w), w for the max numbers of nodes in the same layer of tree.\n\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    if (!root) return 0;\n\n    const stack = [{ node: root, depth: 1 }];\n    let maxDepth = 0;\n\n    while (stack.length) {\n        const { node, depth } = stack.shift();\n        if (node.left) stack.push({ node: node.left, depth: depth + 1 });\n        if (node.right) stack.push({ node: node.right, depth: depth + 1 });\n        maxDepth = Math.max(maxDepth, depth);\n    }\n\n    return maxDepth;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/17#issuecomment-3125050709","body":"## 解題方向\n- 須理解兩棵樹一樣的意思是，其遍歷的結果會一樣，又題目有提到左右節點位置不同也不行，因此可以用多個遍歷結果來確認，或者可以將中間的空節點印出。可優化空間是不需要若於遍歷過程比較兩棵樹的節點，就不需要儲存遍歷結果。\n\n```javascript\n// Time Complexity: O(m + n), m, n are numbers of two tree nodes respectively.\n// Space Complexity: O(m + n)\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n    const iterate = (root) => {\n        const arr = [];\n        const stack = [root];\n\n        while (stack.length) {\n            const node = stack.shift();\n\n            arr.push(node?.val);\n\n            if (node?.left || node?.right) {\n                stack.push(node?.left);\n                stack.push(node?.right);\n            }\n        }\n\n        return arr;\n    };\n\n    return JSON.stringify(iterate(p)) === JSON.stringify(iterate(q));\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/18#issuecomment-3131156971","body":"## 解題方向\n- 需要計算所有從 root 走到 leaf 的路線，這可以用 Recursion 來完成（回溯）\n- 用一個數字來紀錄 state：增加位數為「runningNumber * 10 + node.val」，減去位數為「Math.floor(runningNumber / 10)」\n\n```javascript\n// Time Complexity: O(n), n is the number of the tree nodes\n// Space Complexity: O(d), d is the depth of the tree\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root) {\n    let sum = 0;\n    let runningNumber = 0;\n\n    const inner = (root) => {\n        if (root) {\n            runningNumber = runningNumber * 10 + root.val;\n\n            if (!root.left && !root.right) {\n                sum += runningNumber;\n            } else {\n                inner(root.left);\n                inner(root.right);\n            }\n\n            runningNumber = Math.floor(runningNumber / 10);\n        }\n    };\n\n    inner(root);\n\n    return sum;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/19#issuecomment-3134845036","body":"## 解題方向\n- 可以使用 DFS 或 BFS 來解題\n- DFS 記錄最深深度的第一個節點數值，深度可作為參數於每次遞迴時傳遞\n- BFS 紀錄每層第一個節點數值\n- 題目保證 root 一定不為 null\n\n### DFS\n```javascript\n// Time Complexity: O(n), n is the number of tree nodes.\n// Space Complexity: O(d), d is the max depth of tree.\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar findBottomLeftValue = function(root) {\n    let maxDepth = 0;\n    let res = null;\n\n    const dfs = (root, depth) => {\n        if (depth > maxDepth) {\n            maxDepth = depth;\n            res = root.val;\n        }\n\n        root.left && dfs(root.left, depth + 1);\n        root.right && dfs(root.right, depth + 1);\n    };\n\n    dfs(root, 1);\n\n    return res;\n};\n```\n\n### BFS\n```javascript\n// Time Complexity: O(n), n is the number of tree nodes.\n// Space Complexity: O(w), w is the max width of tree.\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar findBottomLeftValue = function(root) {\n    const stack = [[root]];\n    let res = null;\n\n    while (stack.length) {\n        const nodes = stack.pop();\n\n        res = nodes[0].val;\n\n        const nextNodes = [];\n\n        for (const node of nodes) {\n            node.left && nextNodes.push(node.left);\n            node.right && nextNodes.push(node.right);\n        }\n\n        nextNodes.length && stack.push(nextNodes);\n    }\n\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/20#issuecomment-3138426787","body":"## 解題方向\n* 使用 DNS 前序遍歷，在 deserialize 時透過遞迴建立樹會較 BFS 容易。\n* 使用原生的 JSON.stringify and JSON.parse 來轉換 array 及 string\n* 優化方向：優化 Space Complexity 至 O(h)，h 為樹的高度\n    * 能直接產生 serialized string 而非在最後轉化\n    * 一邊 deserialize 需要的 string 部分，而不需要在一開始開一個 array 儲存\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\n// Time Complexity: O(n), n is number of tree nodes.\n// Space Complexity: O(n), n is number of tree nodes.\n\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n    const preOrder = [];\n    const dns = (root) => {\n        preOrder.push(root?.val);\n        if (root) {\n            dns(root.left);\n            dns(root.right);\n        }\n    };\n    dns(root);\n\n    return JSON.stringify(preOrder);\n};\n\n// Time Complexity: O(n), n is number of tree nodes.\n// Space Complexity: O(n), n is number of tree nodes.\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n    const preOrder = JSON.parse(data);\n\n    if (preOrder[0] === null || preOrder[0] === undefined) return preOrder[0];\n\n    const createNode = () => {\n        const val = preOrder.shift();\n\n        if (val === null) return null;\n\n        const node = new TreeNode(val);\n        node.left = createNode();\n        node.right = createNode();\n        return node;\n    };\n\n    return createNode();\n};\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/21#issuecomment-3144639245","body":"## 解題方向\n- 不一樣的遍歷方式會有差嗎？ => 由於打算取值後再排序，因此沒差\n- 如何儲存最後的輸出最省力 => 用 hashmap\n\n```javascript\n// Time Complexity: O(nlogn), n is the number of tree.\n// Space Complexity: O(n), n is the number of tree.\n\n// /**\n//  * Definition for a binary tree node.\n//  * function TreeNode(val, left, right) {\n//  *     this.val = (val===undefined ? 0 : val)\n//  *     this.left = (left===undefined ? null : left)\n//  *     this.right = (right===undefined ? null : right)\n//  * }\n//  */\n// /**\n//  * @param {TreeNode} root\n//  * @return {number[][]}\n//  */\nvar verticalTraversal = function(root) {\n    const map = {};\n\n    const traverse = (root, row, col) => {\n        if (!root) return;\n\n        if (!map[col]) {\n            map[col] = [];\n        }\n\n        map[col].push([row, root.val]);\n        traverse(root.left, row + 1, col - 1);\n        traverse(root.right, row + 1, col + 1);\n    };\n\n    traverse(root, 0, 0);\n\n    const keys = Object.keys(map).sort((a, b) => a - b);\n\n    const res = keys.map((k) => {\n        const arr = map[k];\n\n        return arr.sort(([rowA, valA], [rowB, valB]) => {\n            if (rowA === rowB) return valA - valB;\n            return rowA - rowB;\n        }).map(([,val]) => val);\n    });\n\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/22#issuecomment-3146092009","body":"## 解題方向\n- 遍歷 nums 時使用 hashmap 來記錄曾出現過的數字及其 index，並看 hashmap 是否記錄 target - nums[i] 是否曾出現過\n- 可以特別注意題目要求同個元素不能被使用兩次，所以應將配對到的元素移出 hashmap（不過因為題目也說只有一組數字為答案，所以不做也沒關係）\n\n```javascript\n// Time Complexity: O(n), n is nums.length.\n// Space Complexity: O(1) \n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    const map = {};\n    const res = [];\n\n    for (let i = 0; i < nums.length; i += 1) {\n        const num = nums[i];\n\n        if (map[target - num] !== undefined) {\n            res.push(i, map[target - num]);\n            delete map[target - num];\n        } else {\n            map[num] = i;\n        }\n    }\n\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/23#issuecomment-3146907342","body":"## 解法\n- 第一個想法是遍歷後得到 num 與其 frequency 的 hashmap，將其轉成 array 後排序並取前 k 者\n- 看了題解後可優化部分是，由於題目允許回傳值不需要依據 frequency 排序，因此可將原解法 sort 的部分改成 quick selection，將平均時間複查度從 O(nlogn) 將至 O(n)\n```javascript\n// Time Complexity: O(nlogn), n is nums.length.\n// Space Complexity: O(n), n is nums.length.\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar topKFrequent = function (nums, k) {\n  const map = {};\n\n  for (const num of nums) {\n    map[num] = (map[num] ?? 0) + 1;\n  }\n\n  return Object.entries(map)\n    .sort(([numA, freqA], [numB, freqB]) => {\n      return freqB - freqA;\n    })\n    .filter((_, i) => i < k)\n    .map(([num]) => Number(num));\n};\n```\n\n## 解法\n- 找 max frequent num\n- 回傳 left, right index range\n- 需要考慮當兩個 num frequency 相等時，應保留 range 較小者！\n```javascript\n// Time Complexity: O(n), n is nums.length.\n// Space Complexity: O(n), n is nums.length.\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findShortestSubArray = function (nums) {\n  let maxFreqNum = nums[0];\n  const map = {};\n\n  for (let i = 0; i < nums.length; i += 1) {\n    const num = nums[i];\n    const { freq, left, right } = map[num] ?? { freq: 0, left: i, right: i };\n    map[num] = {\n      freq: freq + 1,\n      left: i < left ? i : left,\n      right: i > right ? i : right,\n    };\n\n    if (map[num].freq > map[maxFreqNum].freq) {\n      maxFreqNum = num;\n    } else if (map[num].freq === map[maxFreqNum].freq) {\n      if (\n        map[num].right - map[num].left <\n        map[maxFreqNum].right - map[maxFreqNum].left\n      ) {\n        maxFreqNum = num;\n      }\n    }\n  }\n\n  const { left, right } = map[maxFreqNum];\n\n  return right - left + 1;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/24#issuecomment-3149617346","body":"```javascript\n// Time Complexity: O(n^2), n is points.length.\n// Space Complexity: O(n), n is points.length.\n\n/**\n * @param {number[][]} points\n * @return {number}\n */\nfunction numberOfBoomerangs(points) {\n    const n = points.length;\n    let ans = 0;\n    \n    for (let i = 0; i < n; i++) {\n        const distanceMap = {};\n        \n        for (let j = 0; j < n; j++) {\n            const dist = Math.pow(points[i][0] - points[j][0], 2) + Math.pow(points[i][1] - points[j][1], 2);\n            distanceMap[dist] = (distanceMap[dist] ?? 0) + 1;\n        }\n        \n        for (const count of Object.values(distanceMap)) {\n            ans += count * (count - 1);\n        }\n    }\n    \n    return ans;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/25#issuecomment-3153048738","body":"## 解法\n- 經典的滑動視窗題目，與用 hashmap 紀錄字元的出現次數，並於迴圈中判斷下個字元是否已出現過，無則加入，有則刪除。\n- 需要特別注意\n- (1) 迴圈的邊界條件應為 right < s.length - 1，不然會讓 right 跑到 s.length\n- (2) 應先刪掉 map[s[left]] 再 left++\n\n```javascript\n// Time Complexity: O(n), n is s.length.\n// Space Complexity: O(m), m is types of characters in s.\n\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    if (!s.length) return 0;\n    \n    const chars = new Map();\n    chars.set(s[0], 1);\n\n    let max = 1;\n    let left = 0;\n    let right = 0;\n\n    while (right < s.length - 1) {\n        const cond = !chars.has(s[right + 1]);\n        if (!chars.has(s[right + 1])) {\n            right++;\n            chars.set(s[right], 1);\n        } else {\n            chars.delete(s[left]);\n            left++;\n        }\n\n        const number = right - left + 1;\n        if (number > max) max = number;\n    }\n\n    return max;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/26#issuecomment-3160434225","body":"## 解法\n- 一開始分析方向錯了，以為每個 substring 間不可重疊\n- 之後想到的是用 hashmap 存可能 substring 的結果，再遍歷一次，但是時間複雜度為階乘\n- 最後則是直接遍歷，再驗證 substring 是否正確，然而需考慮 words 的 element 是否會重複\n\n```javascript\n// Time Complexity: O(n * m * k), n is s.length, m is words[0].length, k is words.lenght.\n// Space Complexity: O(m).\n\n/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nvar findSubstring = function(s, words) {\n    const defaultMap = (() => {\n        const m = {};\n        for (const word of words) {\n            m[word] = (m[word] ?? 0) + 1;\n        }\n        return m;\n    })();\n    let map = JSON.parse(JSON.stringify(defaultMap));\n    const wordLength = words[0].length;\n    const substringLength = wordLength * words.length;\n\n    const validate = (substring) => {\n        let cur = 0;\n        map = JSON.parse(JSON.stringify(defaultMap));\n\n        while (cur < substring.length) {\n            const target = substring.substring(cur, cur + wordLength);\n            if (map[target]) {\n                map[target] -= 1;\n                cur += wordLength;\n            } else return false;\n        }\n\n        return true;\n    };\n\n    const res = []\n\n    for (let i = 0; i < s.length - substringLength + 1; i++) {\n        const substring = s.substring(i, i + substringLength);\n        if (validate(substring)) res.push(i);\n    }\n\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/27#issuecomment-3164019442","body":"## 解法\n- 一開始漏看了連續短數組的條件，之後想到暴力法，也有個感覺優化必定涉及數學技巧，因此直接看題解\n- 需要理解兩個技巧：負數取模 floorMod 和 map.set(0, -1) 以處理欲從 sum[i] - sum[j] 計算 i 至 j 範圍時，當 j 為 0 遇到的計算問題\n\n```javasciprt\n// Time Complexity: O(n), n is nums.length.\n// Space Complexity: O(min(n, k))\n\n/**\n * @param {number[]} nums\n * @param {number} p\n * @return {number}\n */\nvar floorMod = function (a, b) {\n  return ((a % b) + b) % b;\n};\n\nfunction minSubarray(nums, k) {\n  var map = new Map();\n  map.set(0, -1);\n  var res = nums.length;\n  var target = 0;\n  var currSum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    target += nums[i];\n  }\n  target = target % k;\n  if (target === 0) return 0;\n  for (let i = 0; i < nums.length; i++) {\n    currSum = (nums[i] + currSum) % k;\n\n    var prevSum = floorMod(currSum - target, k);\n    if (map.has(prevSum)) {\n      res = Math.min(res, i - map.get(prevSum));\n    }\n    map.set(currSum, i);\n  }\n  return res === nums.length ? -1 : res;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/28#issuecomment-3168248088","body":"## 解法\n- 窮舉前面的例子就可以得到規律：先處理只有一個 node 的 edge case，當 fast.next?.next 不為 null，即存在下下個 node 的情況下移動快慢指針，不然慢指針的下個 node 即是中間節點。\n```javascript\n// 1 => 1\n\n// 1, 2 => 2 => slow 1, fast 2\n// 1, 2, 3 => 2 => slow 1, fast 2\n\n// 1, 2, 3, 4 => 3 => slow 2, fast 4\n// 1, 2, 3, 4, 5 => 3 => slow 2, fast 4\n\n// 1, 2, 3, 4, 5, 6 => 4\n// 1, 2, 3, 4, 5, 6, 7 => 4\n\n// 1, 2, 3, 4, 5, 6, 7, 8 => 5\n// 1, 2, 3, 4, 5, 6, 7, 8, 9 => 5\n```\n\n```javascript\n// Time Complexity: O(n), n is linked list length,\n// Space Complexity: O(1)\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function(head) {\n    if (!head.next) return head;\n\n    let slow = head;\n    let fast = head.next;\n\n    while (fast.next?.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    };\n\n    return slow.next;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/29#issuecomment-3170547569","body":"## 解法\n- 一開始沒注意到 Space Complexity O(1) 的要求，因此用 map 來記錄曾遍歷過的數字，並使用 nums.splice 來原地刪除重複元素\n- 若限制 Space Complexity 為 O(1)，則需要如題解用快慢指針來做\n\n```javascript\n// Time Complexity: O(n), n is nums.length\n// Space Complexity: O(1)\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    let slow = 0;\n    let fast = 0;\n\n    while (fast < nums.length) {\n        if (nums[fast] !== nums[slow]) {\n            slow++;\n            nums[slow] = nums[fast];\n        }\n        \n        fast++;\n    }\n\n    return slow + 1;\n};\n\n// Time Complexity: O(n), n is nums.length\n// Space Complexity: O(n)\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    const map = {};\n    let res = 0;\n    let i = nums.length - 1;\n\n    while (i >= 0) {\n        const num = nums[i];\n\n        if (map[num]) {\n            nums.splice(i, 1);\n        } else {\n            map[num] = 1;\n            res += 1;\n        };\n\n        i--;\n    }\n\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/30#issuecomment-3172259657","body":"## 解法\n- 經典的二分查找，需注意沒有找到 target 的 edge case\n\n```javascript\n// Time Complexity: O(logn), n is nums.length\n// Space Complexity: O(1)\n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchInsert = function(nums, target) {\n    let l = 0;\n    let r = nums.length - 1;\n    let m = -1;\n\n    while (l <= r) {\n        m = l + Math.floor((r - l) / 2);\n\n        if (nums[m] === target) return m;\n        else if (nums[m] > target) r = m - 1;\n        else l = m + 1;\n    }\n\n    return l;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/31#issuecomment-3173778506","body":"## 解法\n- 第一泡茶的確是暴力解，之後會想到 max heap，但每次 push 仍需要耗費 O(logn)\n- 有想過使用 monotonic stack 來做，但卡沒仔細想就覺得可能無法正確排除 sliding window 外的元素而作罷，而這其實可以靠題解中的 shift 來完成，又因為不是嚴格遞增棧，所以遇到相等數值時，前者仍會被保留，而確保 shift 的操作都是正確的\n\n```javascript\n// Time Complexity: O(n), n is nums.length\n// Space Complexity: O(k)\n\nvar maxSlidingWindow = function (nums, k) {\n  const res = [];\n  const dequeue = new Dequeue([]);\n\n  for (let i = 0; i < k - 1; i++) {\n    dequeue.push(nums[i]);\n  }\n\n  for (let i = k - 1; i < nums.length; i++) {\n    dequeue.push(nums[i]);\n    res.push(dequeue.max());\n    dequeue.shift(nums[i - k + 1]);\n  }\n\n  return res;\n};\n\nclass Dequeue {\n  constructor(nums) {\n    this.list = nums; // Should be implemented as a linked list to make time complexity of dequeue.shift() as O(1).\n  }\n\n  push(val) {\n    const nums = this.list;\n\n    while (nums[nums.length - 1] < val) {\n      nums.pop();\n    }\n\n    nums.push(val);\n  }\n\n  shift(val) {\n    let nums = this.list;\n\n    if (nums[0] === val) {\n      nums.shift();\n    }\n  }\n\n  max() {\n    return this.list[0];\n  }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/32#issuecomment-3178234382","body":"## 解法\n- 第一泡茶，可以透過紀錄一個人信任及被信任的人數來解題。其中可以不斷紀錄目前被信任人數最高者方便最後判斷是否為法官\n- 看了題解後發現可以用圖來解，之後補上\n\n```javascript\n// Time Complexity: O(n)\n// Space Complexity: O(n)\n\n/**\n * @param {number} n\n * @param {number[][]} trust\n * @return {number}\n */\nvar findJudge = function(n, trust) {\n    const trustFroms = new Array(n).fill(0);\n    const trustTos = new Array(n).fill(0);\n    let maybeJudge = { index: 0, trustTo: 0 };\n\n    for (const t of trust) {\n        const [from, to] = [t[0] - 1, t[1] - 1];\n        trustFroms[from]++;\n        trustTos[to]++;\n        if (trustTos[to] > maybeJudge.trustTo) maybeJudge = { index: to, trustTo: trustTos[to] };\n    }\n\n    if (maybeJudge.trustTo === n - 1) {\n        if (trustFroms[maybeJudge.index] === 0) return maybeJudge.index + 1;\n    }\n\n    return -1;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/33#issuecomment-3184149014","body":"```javascript\n// Time Complexity: O(v + e)\n// Space Complexity: O(v  + e)\n\n/**\n * @param {number} n\n * @param {number[][]} dislikes\n * @return {boolean}\n */\nconst possibleBipartition = (n, dislikes) => {\n  const graph = new Array(n + 1).fill().map(() => new Array())\n  const colors = new Array(n + 1).fill(-1);\n\n  for (const [a, b] of dislikes) {\n    graph[a].push(b);\n    graph[b].push(a);\n  }\n\n  const dfs = (cur, color = 0) => {\n    colors[cur] = color;\n\n    for (const nxt of graph[cur]) {\n      if (colors[nxt] !== -1 && colors[nxt] === color) return false;\n      if (colors[nxt] === -1 && !dfs(nxt, color ^ 1)) return false;\n    }\n\n    return true;\n  };\n\n  for (let i = 0; i < n + 1; i++) {\n    if (colors[i] === -1 && !dfs(i, 0)) return false;\n  }\n\n  return true;\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/34#issuecomment-3186799518","body":"```javascript\n// Time Complexity: O(n + e), e is sum of beforeItems.flat().length\n// Space Complexity: O(n + e)\n\n/**\n * @param {number} n\n * @param {number} m\n * @param {number[]} group\n * @param {number[][]} beforeItems\n * @return {number[]}\n */\nvar sortItems = function(n, m, group, beforeItems) {\n    const topologicalSort = (items, indegree, neighbors) => {\n        const queue = [];\n        const result = [];\n        \n        for (const item of items) {\n            if (indegree[item] === 0) {\n                queue.push(item);\n            }\n        }\n        \n        while (queue.length > 0) {\n            const current = queue.shift();\n            result.push(current);\n            \n            const currentNeighbors = neighbors[current] || [];\n            for (const neighbor of currentNeighbors) {\n                indegree[neighbor]--;\n                if (indegree[neighbor] === 0) {\n                    queue.push(neighbor);\n                }\n            }\n        }\n        \n        return result;\n    };\n    \n    let maxGroupId = m;\n    for (let item = 0; item < n; item++) {\n        if (group[item] === -1) {\n            group[item] = maxGroupId;\n            maxGroupId++;\n        }\n    }\n    \n    const itemIndegree = Array.from({length: n}, () => 0);\n    const groupIndegree = Array.from({length: maxGroupId}, () => 0);\n    const itemNeighbors = Array.from({length: n}, () => []);\n    const groupNeighbors = Array.from({length: maxGroupId}, () => []);\n    const groupItems = Array.from({length: maxGroupId}, () => []);\n    \n    for (let item = 0; item < n; item++) {\n        groupItems[group[item]].push(item);\n    }\n    \n    for (let item = 0; item < n; item++) {\n        const dependencies = beforeItems[item] || [];\n        \n        for (const dependency of dependencies) {\n            if (group[dependency] !== group[item]) {\n                groupIndegree[group[item]]++;\n                groupNeighbors[group[dependency]].push(group[item]);\n            } else {\n                itemIndegree[item]++;\n                itemNeighbors[dependency].push(item);\n            }\n        }\n    }\n    \n    const groups = Array.from({length: maxGroupId}, (_, i) => i);\n    const sortedGroups = topologicalSort(groups, groupIndegree, groupNeighbors);\n    \n    if (sortedGroups.length !== maxGroupId) {\n        return [];\n    }\n    \n    const result = [];\n    \n    for (const groupId of sortedGroups) {\n        const items = groupItems[groupId];\n        const sorteditems = topologicalSort(items, itemIndegree, itemNeighbors);\n    \n        if (sorteditems.length !== items.length) {\n            return [];\n        }\n        \n        result.push(...sorteditems);\n    }\n    \n    return result;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/35#issuecomment-3190479297","body":"```javascript\n// Time Complexity: O(n), n is moves.length\n// Space Complexity: O(1)\n\n/**\n * @param {string} moves\n * @return {boolean}\n */\nvar judgeCircle = function(moves) {\n    let [x, y] = [0, 0];\n\n    for (let i = 0; i < moves.length; i++) {\n        const action = moves.substring(i, i + 1);\n        if (action === 'R') x++;\n        if (action === 'L') x--;\n        if (action === 'U') y++;\n        if (action === 'D') y--;\n    }\n\n    return x === 0 && y === 0;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/36#issuecomment-3193447956","body":"## 題解\n- 一開始使用 Array + Sort 的方法實作，不過由於 Time Complexity 為 O(n^2logn)，在資料量 1 <= n <= 10^5 的條件下，會沒辦法 AC\n- 需要將資料結構改成 Min Heap 來降低時間複雜度\n\n```javascript\n// Min Heap\n// Time Complexity: O(nlogn)\n// Space Complexity: O(logn)\n\n/**\n * @param {number[][]} tasks\n * @return {number[]}\n */\nvar getOrder = function (tasks) {\n    const indices = Array.from({ length: tasks.length }, (_, i) => i);\n\n    indices.sort((a, b) => { return tasks[a][0] - tasks[b][0] });\n\n    const minHeap = new PriorityQueue((a, b) => {\n        if (tasks[a][1] !== tasks[b][1]) {\n            return tasks[a][1] - tasks[b][1];\n        }\n        return a - b;\n    });\n\n    const res = [];\n    let time = 0;\n    let i = 0;\n\n    while (!minHeap.isEmpty() || i < tasks.length) {\n        while (i < tasks.length && tasks[indices[i]][0] <= time) {\n            minHeap.enqueue(indices[i]);\n            i++;\n        }\n\n        if (minHeap.size() === 0) {\n            time = tasks[indices[i]][0];\n        } else {\n            const nextIndex = minHeap.dequeue();\n            time += tasks[nextIndex][1];\n            res.push(nextIndex);\n        }\n    }\n\n    return res;\n};\n\n// Array + Sort\n// Time Complexity: O(n^2logn)\n// Space Complexity: O(n)\n\n/**\n * @param {number[][]} tasks\n * @return {number[]}\n */\nvar getOrder = function(tasks) {\n    tasks = tasks.map((t, i) => [...t, i]);\n    tasks.sort((a, b) => a[0] === b[0] ? a[2] - b[2] : a[0] - b[0]);\n\n    let i = 0;\n    let curTime = 0;\n    const queue = [];\n    const res = [];\n\n    while (i < tasks.length || queue.length) {\n        while (i < tasks.length && tasks[i][0] <= curTime) {\n            queue.push(tasks[i]);\n            queue.sort((a, b) => a[1] === b[1] ? a[2] - b[2] : a[1] - b [1]);\n            i++;\n        }\n\n        if (!queue.length) {\n            curTime = tasks[i][0];\n        } else {\n            const curTask = queue.shift();\n            res.push(curTask[2]);\n            curTime += curTask[1];\n        }\n    }\n\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/37#issuecomment-3194091917","body":"```javascript\n// Time Complexity: O(1)\n// Space Complexity: O(1)\n\n/**\n * @param {string} loginTime\n * @param {string} logoutTime\n * @return {number}\n */\nvar numberOfRounds = function(loginTime, logoutTime) {\n    const getMinSum = (time, carry) => {\n        let [hour, min] = time.split(':').map(s => Number(s));\n        const remainer = min % 15;\n        const q = (min - remainer) / 15;\n\n        if (!carry) {\n            return (hour * 60) + min;\n        } else if (remainer && carry === 'ceil') {\n            return (hour * 4 + q + 1) * 15;\n        } else {\n            return (hour * 4 + q) * 15;\n        }\n    };\n\n    let [loginMinSum, logoutMinSum] = [getMinSum(loginTime, 'ceil'), getMinSum(logoutTime, 'floor')];\n\n    if (getMinSum(loginTime) > getMinSum(logoutTime)) {\n        logoutMinSum += 24 * 60;\n    }\n\n    return Math.max((logoutMinSum - loginMinSum) / 15, 0)\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/38#issuecomment-3196057927","body":"## 題解\n- 原本想針對三種狀況，直接找 a 和 b 中最符合的 char 來做計算，但會發現很多 edge case 要考量，要一直修正\n- 看題解之後，在有限的解空間中（頂多常數 26），枚舉的確是一個簡單、可讀性更好的做法\n\n```javascript\n// Time Complexity: O(n + m), n is a.length, m is b.length\n// Space Complexity: O(26)\n\n/**\n * @param {string} a\n * @param {string} b\n * @return {number}\n */\nvar minCharacters = function(a, b) {\n    const createCounter = (str) => {\n        const counter = {};\n\n        for (let i = 0; i < 26; i++) {\n            counter[String.fromCharCode(97 + i)] = 0;\n        }\n\n        for (const char of str) {\n            counter[char]++;\n        }\n        return counter;\n    };\n    \n    const ca = createCounter(a);\n    const cb = createCounter(b);\n\n    const greaterCost = (ca, cb) => {\n        let ans = Infinity;\n\n        for (let i = 1; i < 26; i++) {\n            let count = 0;\n            \n            for (let j = 0; j < i; j++) {\n                count += ca[String.fromCharCode(97 + j)];\n            }\n            \n            for (let j = i; j < 26; j++) {\n                count += cb[String.fromCharCode(97 + j)];\n            }\n            ans = Math.min(ans, count);\n        }\n        return ans;\n    };\n    \n    const equalCost = (ca, cb) => {\n        let ans = Infinity;\n        for (let i = 0; i < 26; i++) {\n            const char = String.fromCharCode(97 + i);\n            ans = Math.min(ans, a.length + b.length - ca[char] - cb[char]);\n        }\n        return ans;\n    };\n    \n    return Math.min(\n        greaterCost(ca, cb),\n        greaterCost(cb, ca),\n        equalCost(ca, cb)\n    );\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/39#issuecomment-3199125049","body":"## 題解\n- 直覺就是用快速排序來做，不過實踐上，這次發現 partition 有兩種方法可以做：hoarePartition、lomutoPartition。其中 lomutoPartition 普遍認為較簡單，但因為交換數值的次數較多，會遇到 TLE，因此此題需用 hoarePartition 來做。\n\n```javascript\nconst lomutoPartition = (nums, left, right) => {\n    const pivot = nums[right];\n    let i = left - 1;\n\n    for (let j = left; j < right; j++) {\n        if (nums[j] <= pivot) {\n            i++;\n            [nums[i], nums[j]] = [nums[j], nums[i]];\n        }\n    }\n\n    i++;\n    [nums[i], nums[right]] = [nums[right], nums[i]];\n\n    return i;\n};\n\nconst hoarePartition = (nums, left, right) => {\n    const p = left + ((right - left) >>> 1);\n    const pivot = nums[p];\n    let [i, j] = [left, right];\n\n    while (i <= j) {\n        while (nums[i] < pivot) i++;\n        while (nums[j] > pivot) j--;\n        if (i <= j) {\n            [nums[i], nums[j]] = [nums[j], nums[i]];\n            i++;\n            j--;\n        }\n    }\n\n    return [i, j];\n};\n\nconst quickSort = (nums, left, right) => {\n    // if (left < right) {\n    //     const p = lomutoPartition(nums, left, right);\n    //     quickSort(nums, left, p - 1);\n    //     quickSort(nums, p + 1, right);\n    // }\n\n    if (left < right) {\n        const [i, j] = hoarePartition(nums, left, right);\n        quickSort(nums, left, j);\n        quickSort(nums, i, right);\n    }\n};\n\n// Time Complexity: O(nlogn), n is nums.length\n// Space Complexity: O(logn)\n\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar sortArray = function (nums) {\n  quickSort(nums, 0, nums.length - 1);\n  return nums;\n};\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wutxuan":[{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/4#issuecomment-3073568207","body":"第一次思路：将num数组转换为int数字A，计算A+K，将A+K结果转换为List类型，但没有观察数据范围，导致int类型溢出，没有通过全部样例\n第二次思路：从后往前，逐位相加K%10，直到遍历完全部数组，再判断K是否还有，通过全部样例\n第三次思路：看完题解后，学习到了可以将k和某一位看作一个整体，不用每次计算k%10，而是k+num[i]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/5#issuecomment-3078154786","body":"第一次思路：遍历每个字符，在每个字符上向左向右移动，直到找到字符c，继续遍历下一个字符，但想到时间复杂度一定很高，因此继续想其他方法\n\n第二次思路：先遍历字符串，用List先记录每个字符c的索引。然后遍历字符串每个字符，计算这个字符的位置距离List中位置的最小距离，通过全部用例，时间复杂度O(N*K) N为字符串长度，K为c在字符串中出现的次数\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        List<Integer> indexList = new ArrayList<>();\n        for(int i = 0;i < s.length();i++){\n            if(s.charAt(i) == c){\n                indexList.add(i);\n            }\n        }\n\n        int[] res = new int[s.length()];\n        Arrays.fill(res,10001);\n        for(int i = 0;i < res.length;i++){\n            for(int index : indexList){\n                res[i] = Math.min(res[i],Math.abs(i - index));\n            }\n            \n        }\n        return res;\n    }\n}\n\n```\n第三次思路：看完题解后，学习到了两次遍历求解，从左到右记录每个字符左侧最近的字符c的距离，记为left数组，从右到左记录每个字符右侧最近的字符c的距离，记为right数组。再遍历一遍整个字符串，在left数组和right数组中取最小值为最终结果。在代码实现时，省去了记录right数组再比较，而是直接比较。时间复杂度O(N)\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int index = -s.length();\n        int[] left = new int[s.length()];\n        for(int i = 0;i < s.length();i++){\n            if(s.charAt(i) == c){\n                index = i;\n            }\n            left[i] = i - index;\n        }\n\n        index = 2 * s.length();\n        for(int i = s.length() - 1;i >= 0;i--){\n            if(s.charAt(i) == c){\n                index = i;\n            }\n            left[i] = Math.min(left[i],index - i);\n        }\n        return left;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/6#issuecomment-3083567541","body":"因为要设计的栈有最大长度，因此使用数组来模拟栈。否则使用栈或List来模拟。\n使用数组模拟：使用一个指针变量，指向当前栈顶。入栈时，val存入栈顶处，指针++，出栈时，指针- -，返回栈顶元素。实现inc函数时，只需要对数组中0-k位置的数每个+val即可。通过全部样例\n```java\nclass CustomStack {\n    int size = 0; // 指向第一个空位置\n    int[] arr;\n\n    public CustomStack(int maxSize) {\n        arr = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(size < arr.length){\n            arr[size] = x;\n            size++;\n        }\n    }\n    \n    public int pop() {\n        if(size > 0){\n            size--;\n            return arr[size];\n        }else{\n            return -1;\n        }\n    }\n    \n    public void increment(int k, int val) {\n        int cut = Math.min(k,size);\n\n        for(int i = 0;i < cut;i++){\n            arr[i] += val;\n        }\n    }\n}\n```\n\n看完题解后学会了前缀和方法：- 因为每次的increment函数都会对栈底[0,k]的数据val操作，而是否val操作了只有在pop时才会体现。所以我们可以通过一个数组incremental记录每个val，即第i位置下面的元素都要加incremental[i]。在pop第i个数的时候加上它需要加的所有val，即incremental[i]。 所以increment函数只需要维护incremental数组。但要记得记得pop后，incremental函数用过的地方要清零，并且得累加到前面一位\n\n```java\nclass CustomStack {\n\n    Stack<Integer> stack;\n    int[] incremental;\n\n    public CustomStack(int maxSize) {\n        stack = new Stack<Integer>();\n        incremental = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(stack.size() < incremental.length){\n            stack.push(x);\n        }\n    }\n    \n    public int pop() {\n        int cut = stack.size() - 1;\n        if(cut < 0) return -1;\n\n        int res = stack.pop() + incremental[cut];\n\n        if(cut > 0){\n            incremental[cut-1] += incremental[cut]; \n        }\n        incremental[cut] = 0;\n        return res;\n\n    }\n    \n    public void increment(int k, int val) {\n        int cut = Math.min(k,stack.size())-1;\n        if(cut >= 0){\n            incremental[cut] += val;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/7#issuecomment-3089071815","body":"看到有括号，需要对括号匹配，则优先想到栈。遍历字符串，当遇到非】字符时，全部入栈。当遇到】字符时，开始向回看，取出字符c，构成字符串s。再向回看，取出数字x，重复x次字符串s得到字符串ss，再将ss入栈，继续遍历，直到遍历结束。\n    \n最后得到的栈，就是存储了最终解码后的字符串。取出栈后记得反转字符串\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n        for(int i = 0;i < s.length();i++){\n            if(s.charAt(i) == ']'){\n                StringBuilder sb = new StringBuilder();\n                StringBuilder count = new StringBuilder();\n\n                while(!stack.isEmpty() && stack.peek() != '['){\n                    sb.append(stack.pop());\n                }  \n                sb.reverse();\n                stack.pop();\n                while(!stack.isEmpty() && stack.peek() >= '0' && stack.peek() <= '9'){\n                    count.append(stack.pop());\n                }\n                count.reverse();\n                int t = Integer.valueOf(count.toString());\n                StringBuilder res = new StringBuilder();\n                res.repeat(sb,t);\n\n                for(char c : res.toString().toCharArray()){\n                    stack.push(c);\n                }\n                \n            }else{\n                stack.push(s.charAt(i));\n            }\n        }\n        StringBuilder re = new StringBuilder();\n        while(!stack.isEmpty()){\n            re.append(stack.pop());\n        }\n        re.reverse();\n        return re.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/8#issuecomment-3095194789","body":"- push操作：输入栈入栈\n- pop操作：如果输出栈不为空，则直接输出输出栈的元素。如果输出栈为空，则把输入栈的数据全部导入到输出栈中\n- peek操作：如果输出栈不为空，则直接peek输出栈的元素。如果输出栈为空，则把输入栈的数据全部导出到输入栈中\n```java\nclass MyQueue {\n    Stack<Integer> stackIn;\n    Stack<Integer> stackOut;\n\n    public MyQueue() {\n        stackIn = new Stack<>();\n        stackOut = new Stack<>();\n    }\n    \n    public void push(int x) {\n        stackIn.push(x);\n    }\n    \n    public int pop() {\n        refresh();\n        return stackOut.pop();\n    }\n    \n    public int peek() {\n        refresh();\n        return stackOut.peek();\n    }\n    \n    public boolean empty() {\n        return stackIn.isEmpty() && stackOut.isEmpty();\n    }\n\n    public void refresh(){\n        if(!stackOut.isEmpty()){\n            return;\n        }\n        while(!stackIn.isEmpty()){\n            stackOut.push(stackIn.pop());\n        }\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/9#issuecomment-3094513644","body":"想象成将原始数组和排序后的数组并列排在一起，切一刀。如果这刀的左侧两个数组的数字出现的频次相同，那么右侧的频次也一定相同。这里就是一个分割点。\n继续向右，有同样情况就切一刀。直到走到最后，一定会切最后一刀。记录的每一个分割点，就是分的组数。\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer,Integer> map = new HashMap<>();\n        int[] sortedArr = new int[arr.length];\n        for(int i = 0;i < arr.length;i++){\n            sortedArr[i] = arr[i];\n        }\n        Arrays.sort(sortedArr);\n\n        int res = 0;\n        for(int i = 0;i < arr.length;i++){\n            map.put(arr[i],map.getOrDefault(arr[i],0) + 1);\n            if(map.get(arr[i]) == 0){\n                map.remove(arr[i]);\n            }\n            map.put(sortedArr[i],map.getOrDefault(sortedArr[i],0) - 1);\n            if(map.get(sortedArr[i]) == 0){\n                map.remove(sortedArr[i]);\n            }\n            if(map.isEmpty()){\n                res++;\n            }\n        }\n        return res;\n    }\n}\n```\n因为存在sort排序，时间复杂度O(NlogN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/10#issuecomment-3095217604","body":"先将链表连成一个环，再找到需要断开的位置断开即可\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null) return null;\n        ListNode dummy = head;\n        int count = 1;\n        while(dummy.next != null){\n            count++;\n            dummy = dummy.next;\n        }\n        dummy.next = head;\n\n        k = k % count;\n        dummy = head;\n        count = count - k;\n        for(int i = 1;i < count;i++){\n            dummy = dummy.next;\n        }\n        ListNode res = dummy.next;\n        dummy.next = null;\n        return res;\n    }\n}\n```\n\n因为遍历了链表，时间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/11#issuecomment-3100949135","body":"因为要交换两个节点，所以需要记录两个节点+两个节点前的节点+两个节点后的节点，一共四个节点。分别用cur，one，two，three记录\n交换完后，cur指向下一组需要交换节点的前一个节点\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode cur = dummy;\n        ListNode one = null;\n        ListNode two = null;\n        ListNode three = null;\n        while(cur.next != null && cur.next.next != null)\n        {\n            one = cur.next;\n            two = cur.next.next;\n            three = cur.next.next.next;\n            cur.next = two;\n            cur.next.next = one;\n            cur.next.next.next = three;\n            cur = cur.next.next;\n        }\n        return dummy.next;\n    }\n}\n```\n遍历了链表，时间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/12#issuecomment-3105789931","body":"考验的是二分查找和分治构建二叉树，中间大小的数构成root根节点，左侧的数组部分分治构成左节点，右侧的数组部分分治构成右节点。这里用的是链表，只需要额外增加一些链表的操作（getMid函数）。也可以将链表转化为数组，再构造，查找起来就很快。以空间换时间\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        ListNode dummy = head;\n        int end = 0;\n        while(head != null){\n            end++;\n            head = head.next;\n        }\n\n        return dfs(dummy,0,end);\n    }\n\n    public TreeNode dfs(ListNode head,int start,int end){\n        if(start >= end) return null;\n        int mid = start + (end - start) / 2;\n        ListNode midNode = getMid(head,mid);\n        TreeNode node = new TreeNode(midNode.val);\n        node.left = dfs(head,start,mid);\n        node.right = dfs(head,mid+1,end);\n\n        return node;\n    }\n    \n    public ListNode getMid(ListNode head,int mid){\n        while(mid > 0){\n            mid--;\n            head = head.next;\n        }\n        return head;\n    }\n}\n```\n时间复杂度O(NlogN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/13#issuecomment-3111943009","body":"两个指针从head出发同时往前移动，当某一个指针指向null的时候，使其指向另一个head。直至两个指针相遇，该节点为相遇节点。直到相遇，第一个指针走了A+C+B的路程，另一个指针走了B+C+A的路程\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode A = headA;\n        ListNode B = headB;\n        while(A != B)\n        {\n            if(A == null) A = headB;\n            else A = A.next;\n            if(B == null) B = headA;\n            else B = B.next;\n        }\n        return A;\n    }\n}\n```\n时间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/14#issuecomment-3116973002","body":"- 判断是否有环：两个快慢指针分别从头节点出发，慢指针一次走一格，快指针一次走两个，如果有环，则二者一定会在环内相遇，如果没环，则快指针会先到达null处。可以类比于跑步，跑得快的会套跑的慢的一圈\n- 判断环入口：快指针和慢指针相遇的时候，慢指针走了x+y步，快指针走了x+y+n*(y+z)步骤，n为圈数，大于等于1，如图所示，图片节选自代码随想录。因为快指针是慢指针的两倍速，所以2x+2y=x+y+n*(y+z)。化简后发现当n=1时，x=z，当n大于1时，x=z+(n-1)(y+z)。也就是说，头节点到环入口的距离等于z或z+多圈。因此，用两个指针，一个从头节点出发，一个从相遇节点出发，最终一定会相遇在环入口，无论第二个指针在环里绕了多少圈\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast != null && fast.next != null)\n        {\n            slow = slow.next;\n            fast = fast.next.next;\n            if(slow == fast){\n                ListNode index1 = head;\n                ListNode index2 = slow;\n                while(index1 != index2)\n                {\n                    index1 = index1.next;\n                    index2 = index2.next;\n                }\n                return index1;\n            }\n        }\n        return null;\n    }\n}\n```\n时间复杂度O(N) 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/15#issuecomment-3121046113","body":"Java可以使用LinkedHashMap实现LRU，内置的函数就可以实现按插入顺序排列的hashmap，手动实现LinkedHashMap代码如下：\n```java\npublic class LRUCache {\n    class DLinkedNode {\n        int key;\n        int value;\n        DLinkedNode prev;\n        DLinkedNode next;\n        public DLinkedNode() {}\n        public DLinkedNode(int _key, int _value) {key = _key; value = _value;}\n    }\n\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size;\n    private int capacity;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity;\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            return -1;\n        }\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            cache.put(key, newNode);\n            addToHead(newNode);\n            ++size;\n            if (size > capacity) {\n                DLinkedNode tail = removeTail();\n                cache.remove(tail.key);\n                --size;\n            }\n        }\n        else {\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DLinkedNode node) {\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DLinkedNode node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail() {\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/16#issuecomment-3123845190","body":"递归，每一层返回max（左子树深度，右子树深度）+1\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int leftDepth = maxDepth(root.left);\n        int rightDepth = maxDepth(root.right);\n        return Math.max(leftDepth, rightDepth) + 1;\n    }\n}\n```\n层序遍历，使用队列。每遍历一层，深度+1，直到遍历到最下面一层\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) return 0;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        int depth = 0;\n        while(!queue.isEmpty())\n        {\n            int size = queue.size();\n            for(int i = 0;i < size;i++){\n                TreeNode node = queue.poll();\n                if(node.left != null) queue.add(node.left);\n                if(node.right != null) queue.add(node.right);\n            }\n            depth++;\n        }\n\n        return depth;\n    }\n}\n```\n时间复杂度O(N) N为二叉树节点个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/17#issuecomment-3125223416","body":"先判断当前两个节点是否相同，如果不同，直接返回false。如果相同无法得出最终结论，需要递归进入下一层继续判断子树\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q != null) return false;\n        if(p != null && q == null) return false;\n        if(p == null && q == null) return true;\n        if(p.val != q.val) return false;\n\n        boolean l = isSameTree(p.left,q.left);\n        boolean r = isSameTree(p.right,q.right);\n\n        return l && r;\n    }\n}\n```\n时间复杂度O(N) N为树的节点数量","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/18#issuecomment-3130457949","body":"回溯维护一个List，当递归到叶子节点时，List中保存的数字就是一路从root到当前根节点的所有数字。使用StringBbuilder拼接所有数字，即是当前路径表示的数字\n\n```java\nclass Solution {\n    List<Integer> path = new ArrayList<>();\n    int res = 0;\n    public int sumNumbers(TreeNode root) {\n        path.add(root.val);\n        recursion(root);\n        return res;\n    }\n\n    public void recursion(TreeNode root){\n        if(root.left == null && root.right == null){\n            StringBuilder sb = new StringBuilder();\n            for(int num : path){\n                sb.append(num);\n            }\n            res += Integer.parseInt(sb.toString());\n            return;\n        }\n\n        if(root.left != null){\n            path.add(root.left.val);\n            recursion(root.left);\n            path.remove(path.size() - 1);\n        }\n\n        if(root.right != null){\n            path.add(root.right.val);\n            recursion(root.right);\n            path.remove(path.size() - 1);\n        }\n    }\n}\n```\n时间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/19#issuecomment-3134853681","body":"层序遍历，记录每一层的最左侧的值，不断覆盖变量，最终记录的是最深一层的最左侧的值\n```java\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        int res = 0;\n        while(!queue.isEmpty())\n        {\n            int size = queue.size();\n            for(int i = 0;i < size;i++){\n                TreeNode node = queue.poll();\n                if(i == 0){\n                    res = node.val;\n                }\n                if(node.left != null) queue.add(node.left);\n                if(node.right != null) queue.add(node.right);\n            }\n        }\n\n        return res;\n    }\n}\n```\n时间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/20#issuecomment-3138992061","body":"序列化时：前序遍历记录每个节点用逗号分开，空节点记为#\n反序列化：将序列化结果以逗号分开，存储进队列，用队列递归构造树\n```java\npublic class Codec {\n    StringBuilder sb = new StringBuilder();\n    int count = 1;\n\n    public String serialize(TreeNode root) {\n        if(root == null){\n            sb.append(\"#\").append(\",\");\n            return sb.toString();\n        }\n\n        sb.append(root.val).append(\",\");\n        serialize(root.left);\n        serialize(root.right);\n        return sb.toString();\n    }\n\n    public TreeNode deserialize(String data) {\n        Queue<String> queue = new LinkedList<>();\n        String[] pre = data.split(\",\");\n        for(String s : pre){\n            queue.offer(s);\n        }\n        return build(queue);\n    }\n\n    public TreeNode build(Queue<String> queue){\n        if(queue.isEmpty()) return null;\n        String rootStringVal = queue.poll();\n        if(rootStringVal.equals(\"#\")) return null;\n        int rootVal = Integer.parseInt(rootStringVal);\n        \n        TreeNode root = new TreeNode(rootVal);\n        root.left = build(queue);\n        root.right = build(queue);\n\n        return root;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/21#issuecomment-3142198278","body":"遍历二叉树，记录一个三元组<col,row,value>，分别表示列、行和节点的值。再按照要求进行排序，列升序，行升序，值升序。最后按规则放入List\n```java\nclass Solution {\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<int[]> nodes = new ArrayList<int[]>();\n        dfs(root, 0, 0, nodes);\n        Collections.sort(nodes, new Comparator<int[]>() {\n            public int compare(int[] tuple1, int[] tuple2) {\n                if (tuple1[0] != tuple2[0]) {\n                    return tuple1[0] - tuple2[0];\n                } else if (tuple1[1] != tuple2[1]) {\n                    return tuple1[1] - tuple2[1];\n                } else {\n                    return tuple1[2] - tuple2[2];\n                }\n            }\n        });\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        int size = 0;\n        int lastcol = Integer.MIN_VALUE;\n        for (int[] tuple : nodes) {\n            int col = tuple[0], row = tuple[1], value = tuple[2];\n            if (col != lastcol) {\n                lastcol = col;\n                ans.add(new ArrayList<Integer>());\n                size++;\n            }\n            ans.get(size - 1).add(value);\n        }\n        return ans;\n    }\n\n    public void dfs(TreeNode node, int row, int col, List<int[]> nodes) {\n        if (node == null) {\n            return;\n        }\n        nodes.add(new int[]{col, row, node.val});\n        dfs(node.left, row + 1, col - 1, nodes);\n        dfs(node.right, row + 1, col + 1, nodes);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/22#issuecomment-3146508830","body":"先将数组中所有值和其对应索引存入hashmap，再遍历一遍数组，如果遍历到的num对应的target-num在map中，即是找到的两个索引。注意要避免一个数算两次\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer,Integer> map = new HashMap<>();\n        for(int i = 0;i < nums.length;i++){\n            map.put(nums[i],i);\n        }\n\n        for(int i = 0;i < nums.length;i++){\n            if(map.containsKey(target - nums[i]) && map.get(target - nums[i]) != i){\n                int[] res = new int[2];\n                res[0] = i;\n                res[1] = map.get(target - nums[i]);\n                return res;\n            }\n        }\n        return null;\n    }\n}\n```\n时间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/23#issuecomment-3148286271","body":"遍历数组，先用hashmap记录每个数字出现的次数。用优先队列定义好排序规则，将map中的内容放入优先队列中，再按照要求从队列中取\n```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer,Integer> map = new HashMap<>();\n        for(int num : nums){\n            map.put(num,map.getOrDefault(num,0)+1);\n        }\n        PriorityQueue<int[]> p = new PriorityQueue<>((a,b) -> (b[1]-a[1]));\n        for(Map.Entry<Integer,Integer> m : map.entrySet()){\n            p.add(new int[]{m.getKey(),m.getValue()});\n        }\n        int[] result = new int[k];\n        for(int i = 0;i < k;i++){\n            result[i] = p.poll()[0];\n        }\n        return result;\n    }\n}\n```\n时间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/24#issuecomment-3149131512","body":"二层遍历，第一层遍历i，第二层遍历，使用map记录每个元组与第一层的i的距离dis出现的次数time。最终由i组成的回旋镖数量为time*（time-1）\n```java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int res = 0;\n        for(int[] a : points){\n            Map<Integer,Integer> map = new HashMap<>();\n            for(int[] b : points){\n                int dis = (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]);\n                map.put(dis,map.getOrDefault(dis,0) + 1);\n            }\n            for(int key : map.keySet()){\n                int val = map.get(key);\n                res += val * (val - 1);\n            }\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/25#issuecomment-3153104469","body":"滑动窗口，定义left指针和right指针，两个指针窗口内即是符合题目要求的子串。不断向右移right指针，如果窗口内的子串不符合题目要求了，就右移left指针缩小窗口直到符合题目要求。\n在遍历过程中，记录窗口长度最大值\n使用hashSet判断窗口内是否符合题目要求\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Set<Character> set = new HashSet<>();\n        int left = 0;\n        int res = 0;\n        for(int right = 0;right < s.length();right++){\n            char c = s.charAt(right);\n            while(set.contains(c)){\n                set.remove(s.charAt(left));\n                left++;\n            }\n\n            set.add(c);\n            res = Math.max(res,right - left + 1);      \n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/26#issuecomment-3157250607","body":"滑动窗口\n```java\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        int wordLen = words[0].length(); \n        int windowLen = wordLen * words.length; \n\n        Map<String, Integer> targetCnt = new HashMap<>();\n        for (String w : words) {\n            targetCnt.put(w,targetCnt.getOrDefault(w,0) + 1);\n        }\n\n        List<Integer> ans = new ArrayList<>();\n        for (int start = 0; start < wordLen; start++) {\n            Map<String, Integer> cnt = new HashMap<>();\n            int overload = 0;\n            for (int right = start + wordLen; right <= s.length(); right += wordLen) {\n                String inWord = s.substring(right - wordLen, right);\n                if (cnt.getOrDefault(inWord, 0).equals(targetCnt.getOrDefault(inWord, 0))) {\n                    overload++;\n                }\n                cnt.merge(inWord, 1, Integer::sum); \n\n                int left = right - windowLen;\n                if (left < 0) { \n                    continue;\n                }\n                if (overload == 0) {\n                    ans.add(left);\n                }\n\n                String outWord = s.substring(left, left + wordLen);\n                cnt.merge(outWord, -1, Integer::sum); \n                if (cnt.get(outWord).equals(targetCnt.getOrDefault(outWord, 0))) {\n                    overload--;\n                }\n            }\n        }\n\n        return ans;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/27#issuecomment-3162563860","body":"前缀和\n```java\nclass Solution {\n    public int minSubarray(int[] nums, int p) {\n        int n = nums.length;\n        int[] s = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            s[i + 1] = (s[i] + nums[i]) % p;\n        }\n        int x = s[n];\n        if (x == 0) {\n            return 0; \n        }\n\n        int ans = n;\n        Map<Integer, Integer> last = new HashMap<>();\n        for (int i = 0; i <= n; i++) {\n            last.put(s[i], i);\n            int j = last.getOrDefault((s[i] - x + p) % p, -n);\n            ans = Math.min(ans, i - j);\n        }\n        return ans < n ? ans : -1;\n    }\n}\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/29#issuecomment-3170443755","body":"双指针，慢指针用于存数字，快指针用于检验数字是否重复\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        if(nums.length == 1) return 1;\n        int slow = 0;\n        for(int fast = 1;fast<nums.length;fast++){\n            if(nums[slow] != nums[fast]){\n                nums[++slow] = nums[fast];\n            }\n        }\n        return slow + 1;\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/30#issuecomment-3172468917","body":"二分查找，如果查找到了则返回当前下标。如果没找到，则最后left指针的地方就是要其应该插入的地方\n```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length;\n        while(left < right)\n        {\n            int middle = left + (right - left) / 2;\n            if(nums[middle]>target){\n                right = middle;\n            }else if(nums[middle]<target){\n                left = middle + 1;\n            }else{\n                return middle;\n            }\n        }\n    \n        return left;\n           \n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/31#issuecomment-3173062612","body":"滑动窗口，重点在于窗口滑动时，如何判断最大值，可以使用优先队列，或自己构造一个队列，维护这个队列，使得最大值在最前\n```java\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int[] res = new int[nums.length - k + 1];\n        MyQueue queue = new MyQueue();\n        for(int i = 0;i < k;i++){\n            queue.add(nums[i]);\n        }\n        int count = 0;\n        res[count++] = queue.max();\n        for(int i = k;i < nums.length;i++){\n            queue.poll(nums[i - k]);\n            queue.add(nums[i]);\n            res[count++] = queue.max();\n        }\n        return res;\n    }\n}\n\nclass MyQueue{\n    Deque<Integer> queue;\n    public MyQueue(){\n        queue = new LinkedList<>();\n    } \n\n    public void add(int val){\n        while(!queue.isEmpty() && val > queue.getLast()){\n            queue.removeLast();\n        }\n        queue.add(val);\n    }\n\n    public void poll(int val){\n        if(queue.peek() == val){\n            queue.poll();\n        }\n    }\n\n    public int max(){\n        return queue.peek();\n    }\n}\n```\n时间复杂度O(nlogn)\n优先队列插入的复杂度是logn","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/32#issuecomment-3177951924","body":"两个数组计算每个人的入度和出度\n```java\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[] inDegrees = new int[n + 1];\n        int[] outDegrees = new int[n + 1];\n        for (int[] edge : trust) {\n            int x = edge[0], y = edge[1];\n            ++inDegrees[y];\n            ++outDegrees[x];\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (inDegrees[i] == n - 1 && outDegrees[i] == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/33#issuecomment-3182597716","body":"染色法，如果染色过程冲突，则无法实现、返回false\n```java\nclass Solution {\n    boolean[] visited;\n    boolean[] color;\n    boolean flag = false;\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        List<Integer>[] graph = build(dislikes,n);\n        visited = new boolean[graph.length];\n        color = new boolean[graph.length];\n        for(int i = 1;i < graph.length;i++){\n            if(visited[i] == false){\n                traverse(graph,i);\n            }\n        }\n        return !flag;\n    }\n\n    public List<Integer>[] build(int[][] dislikes,int n){\n        List<Integer>[] graph = new List[n + 1];\n        for(int i = 0;i < n + 1;i++){\n            graph[i] = new LinkedList<>();\n        }\n\n        for(int[] edge : dislikes){\n            int x = edge[0];\n            int y = edge[1];\n            graph[x].add(y);\n            graph[y].add(x);\n        }\n        return graph;\n    }\n\n    public void traverse(List<Integer>[] graph,int s){\n        if(flag) return;\n        visited[s] = true;\n        for(int x : graph[s]){\n            if(visited[x] == false){\n                color[x] = !color[s];\n                traverse(graph,x);\n            }else{\n                if(color[x] == color[s]) flag = true;\n            }\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/34#issuecomment-3186848399","body":"拓扑排序\n```java\nclass Solution {\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\n        List<List<Integer>> groupItem = new ArrayList<List<Integer>>();\n        for (int i = 0; i < n + m; ++i) {\n            groupItem.add(new ArrayList<Integer>());\n        }\n\n        // 组间和组内依赖图\n        List<List<Integer>> groupGraph = new ArrayList<List<Integer>>();\n        for (int i = 0; i < n + m; ++i) {\n            groupGraph.add(new ArrayList<Integer>());\n        }\n        List<List<Integer>> itemGraph = new ArrayList<List<Integer>>();\n        for (int i = 0; i < n; ++i) {\n            itemGraph.add(new ArrayList<Integer>());\n        }\n\n        // 组间和组内入度数组\n        int[] groupDegree = new int[n + m];\n        int[] itemDegree = new int[n];\n        \n        List<Integer> id = new ArrayList<Integer>();\n        for (int i = 0; i < n + m; ++i) {\n            id.add(i);\n        }\n\n        int leftId = m;\n        // 给未分配的 item 分配一个 groupId\n        for (int i = 0; i < n; ++i) {\n            if (group[i] == -1) {\n                group[i] = leftId;\n                leftId += 1;\n            }\n            groupItem.get(group[i]).add(i);\n        }\n        // 依赖关系建图\n        for (int i = 0; i < n; ++i) {\n            int curGroupId = group[i];\n            for (int item : beforeItems.get(i)) {\n                int beforeGroupId = group[item];\n                if (beforeGroupId == curGroupId) {\n                    itemDegree[i] += 1;\n                    itemGraph.get(item).add(i);   \n                } else {\n                    groupDegree[curGroupId] += 1;\n                    groupGraph.get(beforeGroupId).add(curGroupId);\n                }\n            }\n        }\n\n        // 组间拓扑关系排序\n        List<Integer> groupTopSort = topSort(groupDegree, groupGraph, id); \n        if (groupTopSort.size() == 0) {\n            return new int[0];\n        }\n        int[] ans = new int[n];\n        int index = 0;\n        // 组内拓扑关系排序\n        for (int curGroupId : groupTopSort) {\n            int size = groupItem.get(curGroupId).size();\n            if (size == 0) {\n                continue;\n            }\n            List<Integer> res = topSort(itemDegree, itemGraph, groupItem.get(curGroupId));\n            if (res.size() == 0) {\n                return new int[0];\n            }\n            for (int item : res) {\n                ans[index++] = item;\n            }\n        }\n        return ans;\n    }\n\n    public List<Integer> topSort(int[] deg, List<List<Integer>> graph, List<Integer> items) {\n        Queue<Integer> queue = new LinkedList<Integer>();\n        for (int item : items) {\n            if (deg[item] == 0) {\n                queue.offer(item);\n            }\n        }\n        List<Integer> res = new ArrayList<Integer>();\n        while (!queue.isEmpty()) {\n            int u = queue.poll(); \n            res.add(u);\n            for (int v : graph.get(u)) {\n                if (--deg[v] == 0) {\n                    queue.offer(v);\n                }\n            }\n        }\n        return res.size() == items.size() ? res : new ArrayList<Integer>();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/35#issuecomment-3190861492","body":"模拟机器人移动\n```java\nclass Solution {\n    public boolean judgeCircle(String moves) {\n        int x = 0, y = 0;\n        int length = moves.length();\n        for (int i = 0; i < length; i++) {\n            char move = moves.charAt(i);\n            if (move == 'U') {\n                y--;\n            } else if (move == 'D') {\n                y++;\n            } else if (move == 'L') {\n                x--;\n            } else if (move == 'R') {\n                x++;\n            }\n        }\n        return x == 0 && y == 0;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/36#issuecomment-3193745750","body":"模拟\n```java\nclass Solution {\n    public int[] getOrder(int[][] ts) {\n        int n = ts.length;\n        // 将 ts 转存成 nts，保留任务编号\n        int[][] nts = new int[n][3];\n        for (int i = 0; i < n; i++) nts[i] = new int[]{ts[i][0], ts[i][1], i};\n        // 根据任务入队时间进行排序\n        Arrays.sort(nts, (a,b)->a[0]-b[0]);\n        // 根据题意，先按照「持续时间」排序，再根据「任务编号」排序\n        PriorityQueue<int[]> q = new PriorityQueue<>((a,b)->{\n            if (a[1] != b[1]) return a[1] - b[1];\n            return a[2] - b[2];\n        });\n        int[] ans = new int[n];\n        for (int time = 1, j = 0, idx = 0; idx < n; ) {\n        \t// 如果当前任务可以添加到「队列」中（满足入队时间）则进行入队\n            while (j < n && nts[j][0] <= time) q.add(nts[j++]);\n            if (q.isEmpty()) {\n\t            // 如果当前「队列」没有任务，直接跳到下个任务的入队时间\n                time = nts[j][0];\n            } else {\n            \t// 如果有可执行任务的话，根据优先级将任务出队（记录下标），并跳到该任务完成时间点\n                int[] cur = q.poll();\n                ans[idx++] = cur[2];\n                time += cur[1];\n            }\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/37#issuecomment-3194379645","body":"转化为分钟\n```java\nclass Solution {\n    public int numberOfRounds(String loginTime, String logoutTime) {\n        int loginHour = Integer.parseInt(loginTime.substring(0, 2));\n        int loginMinute = Integer.parseInt(loginTime.substring(3));\n        int logoutHour = Integer.parseInt(logoutTime.substring(0, 2));\n        int logoutMinute = Integer.parseInt(logoutTime.substring(3));\n        int loginTotalMinute = loginHour * 60 + loginMinute;\n        int logoutTotalMinute = logoutHour * 60 + logoutMinute;\n        if (loginTotalMinute > logoutTotalMinute) {\n            logoutTotalMinute += 1440;\n        }\n        if (loginTotalMinute % 15 != 0) {\n            loginTotalMinute += 15 - loginTotalMinute % 15;\n        }\n        logoutTotalMinute -= logoutTotalMinute % 15;\n        return Math.max((logoutTotalMinute - loginTotalMinute) / 15, 0);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/38#issuecomment-3195332635","body":"分别模拟三个情况\n```java\nclass Solution {\n    public int minCharacters(String a, String b) {\n        int n = a.length(), m = b.length(), ans = 0x3f3f3f3f;\n        int[] c1 = new int[26], c2 = new int[26];\n        for (char c : a.toCharArray()) c1[c - 'a']++;\n        for (char c : b.toCharArray()) c2[c - 'a']++;\n        for (int i = 0; i < 26 && ans != 0; i++) {\n            // 3\n            int ca = n - c1[i], cb = m - c2[i];\n            ans = Math.min(ans, ca + cb);\n            if (i == 0) continue;\n            int r1 = 0, r2 = 0;\n            // 1\n            for (int j = i; j < 26; j++) r1 += c1[j];\n            for (int j = 0; j < i; j++) r1 += c2[j];\n            // 2\n            for (int j = i; j < 26; j++) r2 += c2[j];\n            for (int j = 0; j < i; j++) r2 += c1[j];\n            ans = Math.min(ans, Math.min(r1, r2));\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/39#issuecomment-3199298563","body":"归并排序\n\n```java\nclass Solution {\n    public int[] sortArray(int[] nums) {\n        sort(nums,0,nums.length - 1);\n        return nums;\n    }\n\n    public void sort(int[] nums,int start,int end){\n        if(start >= end) return;\n        int p = para(nums,start,end);\n\n        sort(nums,start,p - 1);\n        sort(nums,p + 1,end);\n    }\n\n    public int para(int[] nums,int l,int h){\n\n        int x = nums[l];\n        int i = l,j = h;\n        while(i < j)\n        {\n            while(i < j && nums[j] >= x) j--;\n            if(i < j) nums[i++] = nums[j];\n\n            while(i < j && nums[i] < x) i++;\n            if(i < j) nums[j--] = nums[i];\n        }\n\n        nums[i] = x;\n        return i;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"falsity":[{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/4#issuecomment-3073705405","body":"# 思路\n\n从低位往高位计算, 每次计算保留进位数据,本位留下余数\n\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        i = len(num) - 1\n        while i >=0 or k > 0:\n            if i >= 0:\n                k += num[i]\n                i -= 1\n            result.append(k % 10)\n            k = k // 10\n        return result[::-1]\n```\n\n时间复杂度: O(n)\n\n空间复杂度: O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/5#issuecomment-3079013152","body":"# 【Day 2】821. 字符的最短距离\n\n## 思路\n\n先遍历一遍获取c的位置列表, 再遍历每个位置计算最近的距离\n\n```python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        locations = []\n        result = []\n        for i, char in enumerate(s):\n            if char == c:\n                locations.append(i)\n        \n        for i in range(len(s)):\n            shortest = min(abs(i - location) for location in locations)\n            result.append(shortest)\n        return result\n```\n\n时间复杂度: O(n*m), m为字符c出现次数,最差为O(n^2)\n\n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/6#issuecomment-3084580543","body":"**【Day 3】1381. 设计一个支持增量操作的栈**\n\n*** 思路***\n\n用数组模拟栈\n\n```python\nclass CustomStack(object):\n\n    # 时间复杂度: O(1)\n    # 空间复杂度: O(n)\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.stack = [0] * maxSize\n        self.top = -1\n        \n    # 时间复杂度: O(1)\n    # 空间复杂度: O(n)\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if self.top < len(self.stack) - 1:\n            self.top += 1\n            self.stack[self.top] = x\n        \n     # 时间复杂度: O(1)\n    # 空间复杂度: O(n)\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.top == -1:\n            return -1\n        value = self.stack[self.top]\n        self.top -= 1\n        return value\n        \n    # 时间复杂度: O(k)\n    # 空间复杂度: O(n)\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        lim = min(k, self.top + 1)\n        for i in range(lim):\n            self.stack[i] += val\n        \n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/7#issuecomment-3089882117","body":"**【Day 4】394. 字符串解码**\n\n**思路**\n\n参照[Krahets的字符串解码题解](https://leetcode.cn/problems/decode-string/solutions/19447/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/)中的辅助栈解法,利用栈来存储每一层[]中的字符串和需要重复的次数逐层拼接字符串,最后得到结果.\n\n**代码**\n\n```python\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        stack, res, multi = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append([multi, res])\n                res, multi = \"\", 0\n            elif c == ']':\n                cur_multi, last_res = stack.pop()\n                res = last_res + cur_multi * res\n            elif '0' <= c <= '9':\n                multi = multi * 10 + int(c)\n            else:\n                res += c\n        return res \n```\n\n**复杂度分析**\n\n时间复杂度: O(N)\n空间复杂度: O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/8#issuecomment-3092420487","body":"**【Day 5】232. 用栈实现队列**\n\n**思路**\n\n利用栈先进后出的性质,通过stack1完成元素的倒序放置,再将stack1的元素放入stack2中,前面的元素就放在了栈顶. 此时经过两次入栈出栈的操作stack2中的元素就满足了先进先出的要求.\n\n但是要注意以下问题:\n\n1. 只有在stack2中元素为空时才能将stack1中的元素放入stack2中,这样才能保证有序性\n2. 遍历list元素要使用while, 不能用for,否则会有元素被跳过\n\n**代码**\n\n```python\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1, self.stack2 = [], []\n        \n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.stack1.append(x)\n        \n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        res = self.peek()\n        return self.stack2.pop()\n        \n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.stack2:\n            return self.stack2[-1]\n        elif self.stack1:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n            return self.stack2[-1]\n        else:\n            return -1\n        \n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return not self.stack1 and not self.stack2\n        \n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n**复杂度分析**\n\n时间复杂度: push, empty 是O(1), pop, peek是O(N)\n空间复杂度: O(N)\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/10#issuecomment-3097331008","body":"**【Day 7】61. 旋转链表**\n\n**思路**\n\nk可能会大于链表长度导致循环遍历链表. 所以真实的旋转偏移是k%n,n为链表长度. 使用双指针找到需要断开的节点位置,将链表进行断开和重新拼接即可得到结果\n\n```pyth\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :type k: int\n        :rtype: Optional[ListNode]\n        \"\"\"\n        if k == 0 or not head or not head.next:\n            return head\n\n        node = head\n        l = 0\n        while node:\n            l += 1\n            node = node.next\n        \n        if k % l == 0:\n            return head\n        k = k % l\n        slow = fast = head\n        for i in range(k):\n            fast = fast.next\n        \n        while fast.next:\n            slow = slow.next\n            fast = fast.next\n\n        new_head = slow.next\n        slow.next = None\n        fast.next = head\n        return new_head\n```\n\n**复杂度分析**\n\n时间复杂度: O(N)\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/11#issuecomment-3103411213","body":"**【Day 8】24. 两两交换链表中的节点**\n\n**思路**\n\n类似于反转链表, 用两个指针来对链表指向进行修改,唯一的区别是cur需要间隔一个进行遍历,而不是逐个遍历\n\n```python\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        dummy = ListNode()\n        dummy.next = head\n        pre = dummy\n        cur = head\n        while cur and cur.next:\n            nxt = cur.next\n            cur.next = nxt.next\n            nxt.next = cur\n            pre.next = nxt\n            pre = cur\n            cur = cur.next\n            \n        return dummy.next\n```\n\n**复杂度分析**\n\n时间复杂度: O(N)\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/12#issuecomment-3109176294","body":"**【Day 9】109. 有序链表转换二叉搜索树**\n\n**思路**\n\n首先获取链表的长度,再根据二叉树的中序遍历方式递归构建BST, 根节点的值在遍历完左子树后刚好移动了m次到达中间节点,即根节点位置\n\n\n\n```python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        def getLength(head: ListNode) -> int:\n            count = 0\n            while head:\n                count += 1\n                head = head.next\n            return count\n\n        def buildBST(left: int, right: int) -> TreeNode:\n            if left > right:\n                return None\n            m = (left + right) // 2\n            root = TreeNode()\n            left_node = buildBST(left, m - 1)\n            nonlocal head\n            root.val = head.val\n            head = head.next\n            \n            right_node = buildBST(m+1, right)\n            root.left = left_node\n            root.right = right_node\n            return root\n\n        l = getLength(head)\n        return buildBST(0, l - 1)\n```\n\n**复杂度分析**\n\n时间复杂度: O(n)\n空间复杂度: O(log n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/15#issuecomment-3122088595","body":"**【Day 12】146. LRU 缓存机制**\n\n**思路**\n\n`get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行, 说明需要使用到map. 需要记录关键字使用过的顺序需要使用到链表\n\nget方法需要查询map, 如果key存在则返回值,如果不存在则返回-1. 查询完成后,需要把该节点移动到队首(删除后再插入队首)\n\nput方法需要先查询map容量,如果容量已满,需要通过list找到队尾元素删除, 并将新元素插入队首\n\nnode需要知道前后节点,所以使用双向链表,map和node之间建立映射方便查询数据\n\n\n\n需要的内部函数: 删除元素, 将元素插入队首\n\n```python\nclass LRUCache:\n    class Node:\n        def __init__(self, key: int, val: int):\n            self.key = key\n            self.val = val\n            self.pre = pre\n            self.next = next\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.dummy = self.Node(-1, -1)\n        self.dummy.pre = self.dummy\n        self.dummy.next = self.dummy\n        self.map = {}\n\n    def add_node_to_head(self, node: Node):\n        node.pre = self.dummy\n        node.next = self.dummy.next\n        self.dummy.next.pre = node\n        self.dummy.next = node\n\n    def remove_node(self, node: Node):\n        node.pre.next = node.next\n        node.next.pre = node.pre\n\n    def get(self, key: int) -> int:\n        if key not in self.map:\n            return -1\n\n        node = self.map[key]\n        self.remove_node(node)\n        self.add_node_to_head(node)\n        return node.val\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.map:\n            node = self.map[key]\n            node.val = value\n            self.remove_node(node)\n            self.add_node_to_head(node)\n            return\n\n        new_node = self.Node(key, value)\n        self.map[key] = new_node\n        self.add_node_to_head(new_node)\n\n        if len(self.map) > self.capacity:\n            tail = self.dummy.pre\n            del self.map[tail.key]\n            self.remove_node(tail)\n\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/16#issuecomment-3124440801","body":"**【Day 13】104. 二叉树的最大深度**\n\n**思路**\n\n二叉树的最大深度为max(左子树深度, 右子树深度) + 1, 这就变成了一个递归问题\n\n```python\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        if root is None:\n            return 0\n        if root is not None and root.left is None and root.right is None:\n            return 1\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\n\n```\n\n**复杂度分析**\n\n时间复杂度: O(N)\n空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/17#issuecomment-3127200969","body":"**【Day 14】100. 相同的树**\n\n**思路**\n\n相同的树一定根节点相同,并且左子树和右子树都相同, 可以进行递归判断所有子树是否相同\n\n```python\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p is None or q is None:\n            return p is q\n        \n        if p.val == q.val:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n        else:\n            return False\n```\n\n**复杂度分析**\n\n时间复杂度: O(min(m,n)) m为p节点个数,n为q节点个数\n空间复杂度: O(min(m,n)) m为p节点个数,n为q节点个数","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/19#issuecomment-3136787502","body":"**【Day 16】513. 找树左下角的值**\n\n**思路**\n\n从右往左层序遍历,最后一个节点就是左下角的点\n\n```python\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        q = deque([root])\n        while q:\n            node = q.popleft()\n            if node.right: q.append(node.right)\n            if node.left: q.append(node.left)\n        return node.val\n```\n\n**复杂度分析**\n\n时间复杂度: O(n) \n空间复杂度: O(n)\n\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/24#issuecomment-3151014729","body":"**【Day 21】447. 回旋镖的数量**\n\n**思路**\n\n首先计算距离相等的点的数量,在计算相同距离点之间的排列组合数量\n\n```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        res = 0\n        n = len(points)\n        if n < 3:\n            return 0\n        \n        for i in range(n):\n            x0, y0 = points[i]\n            dist_count = {}\n            \n            for j in range(n):\n                if i == j:\n                    continue\n                \n                x1, y1 = points[j]\n                dx = x1 - x0\n                dy = y1 - y0\n                dist_sq = dx * dx + dy * dy\n                \n                dist_count[dist_sq] = dist_count.get(dist_sq, 0) + 1\n            \n            for cnt in dist_count.values():\n                res += cnt * (cnt - 1)\n        \n        return res\n```\n\n时间复杂度: O(n ^ 2)\n\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/31#issuecomment-3175046868","body":"**【Day 28】239. 滑动窗口最大值**\n\n```python\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        if n == 0 or k == 0:\n            return []\n        \n        res = []\n        q = deque()  \n        for i in range(n):\n            while q and q[0] < i - k + 1:\n                q.popleft()\n            while q and nums[q[-1]] < nums[i]:\n                q.pop()\n            q.append(i)\n            if i >= k - 1:\n                res.append(nums[q[0]])\n        return res\n```\n\n时间复杂度: O(n)\n\n空间复杂度: O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/32#issuecomment-3179722453","body":"\n\n```python\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        in_list = [0] * (n + 1)\n        out_list = [0] * (n + 1)\n        for i in trust:\n            in_list[i[1]] += 1\n            out_list[i[0]] += 1\n\n        for i in range(1, n+1):\n            if in_list[i] == n - 1 and out_list[i] == 0:\n                return i\n\n        return -1\n```\n\n时间复杂度: O(n + m), m为trust列表长度\n\n空间复杂度: O(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/37#issuecomment-3194443006","body":"```python\nclass Solution:\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\n        start = 60 * int(loginTime[:2]) + int(loginTime[3:])\n        end = 60 * int(logoutTime[:2]) + int(logoutTime[3:])\n        if start > end:\n            end += 24 * 60\n        start = math.ceil(start / 15) * 15\n        end = end // 15 * 15\n        return max(0, (end - start) // 15)\n```\n\n时间复杂度: O(1)\n\n空间复杂度: O(1)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuetong3yu":[{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/4#issuecomment-3073754281","body":"```js\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(nums, k) {\n    let str1 = '', str2 = String(k)\n    for(let i = 0; i < nums.length; i++) {\n        str1 += nums[i];\n    }\n    // swap to make sure str1 is longer than str2\n    if (str1.length < str2.length) {\n        const t = str1;\n        str1 = str2;\n        str2 = t;\n    }\n    const res = new Array(str1.length).fill(0);\n    let p1 = str1.length - 1, p2 = str2.length - 1;\n    while(p1 >= 0) {\n        res[p1] = Number(str1[p1]) + Number(str2[p2] ?? 0);\n        p1 --, p2 --;\n    }\n    const len = res.length\n    let need_shift = false\n    for (let i = len - 1; i >= 0; i--) {\n        if (res[i] >= 10) {\n            if (i === 0) {\n                need_shift = true\n            } else {\n                res[i - 1] = res[i - 1] + 1;\n            }\n            res[i] = res[i] % 10\n        }\n    }\n    if (need_shift) res.unshift(1)\n    return res;\n};\n```\n\n尝试了几个不同的方法。。。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/5#issuecomment-3078802551","body":"模拟题意AC，但感觉第二遍 for 循环没必要循环整个 indexes 数组，indexes 数组是天然有序的，应该可以用双指针优化\n\n```js\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    const indexes = []\n    for(let i = 0; i < s.length; i++) {\n        if (s[i] === c) indexes.push(i);\n    }\n    const res = [];\n    for(let i = 0; i < s.length; i++) {\n        let min = Infinity\n        for(let j = 0; j < indexes.length; j++) {\n            min = Math.min(min, Math.abs(i - indexes[j]));\n        }\n        res.push(min)\n    }\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/6#issuecomment-3082104676","body":"思路一直接模拟题意，increment 操作循环遍历一遍让元素自增：\n\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.stack = []\n    this.size = 0\n    this.maxSize = maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.size === this.maxSize) return;\n    this.stack.push(x);\n    this.size ++\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (this.size === 0) return -1\n    const res = this.stack.pop();\n    this.size --\n    return res;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(let i = 0; i < this.size;i ++) {\n        if (i < k) {\n            this.stack[i] += val;\n        }\n    }\n};\n\n/** \n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n---\n\n\n思路二使用一个 hashmap 维护自增量，只有在 pop 操作的时候才去运算：\n\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.stack = []\n    this.size = 0\n    this.maxSize = maxSize\n    this.map = {}\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.size === this.maxSize) return;\n    this.stack.push(x);\n    this.size ++\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (this.size === 0) return -1\n    const inc = this.map[this.size - 1] || 0;\n    const res = this.stack.pop();\n    // update inc\n    if (inc) {\n        this.map[this.size - 1] = 0;\n        this.map[this.size - 2] = this.map[this.size - 2] ? this.map[this.size - 2] + inc : inc;\n    }\n    this.size --\n\n    return res + inc;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    const key = Math.min(k - 1, this.size - 1);\n    this.map[key] = this.map[key] ? this.map[key] + val : val;\n};\n\n/** \n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n🥲 结果跑出来只打败了 18% 的人，应该是题目给的数据量量太小了 <= 1000，操作 hashmap 的 cost 超过了循环 stack 的时间，不如方法一暴力循环。。。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/7#issuecomment-3089570929","body":"用栈秒了\n\n```js\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    const stack = [];\n    let i = 0;\n    while(i < s.length) {\n        const char = s[i];\n        if (char !== ']') {\n            stack.push(char)\n            i ++\n        } else {\n            let repeatStr = ''\n            while(stack[stack.length - 1] !== '[') {\n                const new_char = stack.pop();\n                repeatStr = new_char + repeatStr;\n            }\n            // pop '['\n            stack.pop()\n            // get number \n            let repeat_times = ''\n            while(/[0-9]/.test(stack[stack.length - 1])) {\n                repeat_times = stack.pop() + repeat_times\n            }\n            repeat_times = Number(repeat_times)\n            stack.push(repeatStr.repeat(repeat_times));\n            i ++\n        }\n    }\n    let res = ''\n    while(stack.length) {\n        res = stack.pop() + res;\n    }\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/8#issuecomment-3091373955","body":"思路：用两个栈模拟操作，在 peek 的时候出第二个栈的顶部即可\n\n\n```js\nvar MyQueue = function() {\n    this.a = [];\n    this.b = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.a.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    this.peek();\n    return this.b.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if (this.b.length) {\n        return this.b[this.b.length - 1]\n    } else {\n        while(this.a.length) {\n            this.b.push(this.a.pop())\n        }\n        return this.peek()\n    }\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.a.length && !this.b.length\n};\n\n/** \n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/9#issuecomment-3094511265","body":"用了一个简单的前缀和 AC 了，时间复杂度也是 NlogN\n\n```js\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    const sorted_arr = [...arr].sort((a, b) =>  a - b);\n    let count_a = count_b = res = 0;\n\n    for(let i = 0; i < arr.length;i ++) {\n        count_a += sorted_arr[i];\n        count_b += arr[i];\n\n        if (count_a === count_b) res ++ \n    }\n\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/10#issuecomment-3096927980","body":"```js\nvar rotateRight = function(head, k) {\n  if (!head || !head.next || k === 0) return head;\n\n  // Count the length of the list\n  let length = 1;\n  let tail = head;\n  while (tail.next) {\n    tail = tail.next;\n    length++;\n  }\n\n  // Normalize k\n  k %= length;\n  if (k === 0) return head;\n\n  // Find the new tail: (length - k - 1)th node\n  let newTail = head;\n  for (let i = 0; i < length - k - 1; i++) {\n    newTail = newTail.next;\n  }\n\n  // Rotate\n  let newHead = newTail.next;\n  newTail.next = null;\n  tail.next = head;\n\n  return newHead;\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/11#issuecomment-3100186608","body":"考察交换链表节点的基本操作，需要注意的是“什么时候使用 dummy 节点”的技巧。我的理解是在需要涉及到头节点操作的时候，就创建 dummy 节点。比如这一题 - 交换头两个节点的时候就会涉及到头节点的变更。\n\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    const dummy = new ListNode(null, head);\n    let p = dummy;\n    while(p.next && p.next.next) {\n        const p1 = p.next, p2 = p.next.next;\n        p.next = p2;\n        p1.next = p2.next;\n        p2.next = p1;\n        p = p1\n    }\n    return dummy.next;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/12#issuecomment-3108866758","body":"Same solution with Problem108. But this problem is giving List instead plain array. So will need to use the trick of two pointers to get the mid node of a Single List.\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    if (!head) return null\n    return helper(head, null)\n\n    function helper(head, tail) {\n        if (head === tail) return null;\n        let fast = head;\n        let slow = head;\n        while(fast !== tail && fast.next !== tail) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        const root = new TreeNode(slow.val);\n        root.left = helper(head, slow);\n        root.right = helper(slow.next, tail);\n        return root\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/13#issuecomment-3111667789","body":"A small trick here is `pa !== pb` and `return pa`. For negative scenarios, if given Lists were not intersected, then one of the Lists must be pointing to `null`, and then returning `null` is expected answer. \n\n```js\nvar getIntersectionNode = function(headA, headB) {\n    let pa = headA, pb = headB;\n    while(pa !== pb) {\n        pa = pa ? pa.next : headB;\n        pb = pb ? pb.next : headA;\n    }\n    return pa\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/14#issuecomment-3115364562","body":"Find the intersection node first, and move the slow pointer to the head, and slowly move both of the pointers till they meet each other(can be proved)\n\n```js\nvar detectCycle = function(head) {\n    if (!head) return head;\n    let fast = head, slow = head;\n    // step1: find the intersection node\n    while(fast && fast.next) {\n        fast = fast.next.next;\n        slow = slow.next;\n        // step2: find the entry of the cycle\n        if (fast === slow) {\n            slow = head;\n            while(fast !== slow) {\n                fast = fast.next\n                slow = slow.next\n            }\n            return slow;\n        }\n    }\n    return null;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/15#issuecomment-3120830111","body":"In JS, we need to build a double linked list data structure by our own. The rest of the logic is quite straight forward - which use hashmap to save key-node, and use linked list to store access frequency. \n\n```js\nclass DoubleLinkedListNode {\n    constructor(key, value) {\n        this.key = key;\n        this.value = value;\n        this.prev = null;\n        this.next = null;\n    }\n}\n\nclass LRUCache {\n    constructor(capacity) {\n        this.capacity = capacity;\n        this.usedSpace = 0;\n\n        this.hashmap = {};\n        this.dummyHead = new DoubleLinkedListNode(null, null);\n        this.dummyTail = new DoubleLinkedListNode(null, null);\n        this.dummyHead.next = this.dummyTail;\n        this.dummyTail.prev = this.dummyHead;\n    }\n\n    _isFull() {\n        return this.usedSpace === this.capacity;\n    }\n    _addToHead(node) {\n        const currentHead = this.dummyHead.next;\n\n        node.next = currentHead;\n        node.prev = this.dummyHead;\n        currentHead.prev = node;\n        this.dummyHead.next = node;\n\n        return node;\n    }\n    _removeNode(node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n        node.next = null\n        node.prev = null\n        return node\n    }\n\n    get(key) {\n        if (this.hashmap[key] !== undefined) {\n            const node = this.hashmap[key];\n            this._addToHead(this._removeNode(node));\n            return node.value\n        } else {\n            return -1\n        }\n    }\n    put(key, value) {\n        if (this.hashmap[key] !== undefined) {\n            const node = this.hashmap[key];\n            node.value = value;\n            this._addToHead(this._removeNode(node))\n        } else {\n            if (this._isFull()) {\n                const nodeNeedToEvict = this.dummyTail.prev;\n                delete this.hashmap[nodeNeedToEvict.key];\n                this._removeNode(nodeNeedToEvict);\n                this.usedSpace --\n            }\n            const node = new DoubleLinkedListNode(key, value);\n            this.hashmap[key] = node;\n            this._addToHead(node);\n            this.usedSpace ++\n        }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/16#issuecomment-3123671763","body":"Easy\n\n```js\nvar maxDepth = function(root) {\n    if (!root) return 0\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/17#issuecomment-3124879038","body":"DFS\n\n```js\nvar isSameTree = function(p, q) {\n    if (!p && !q) return true\n    if (!p || !q) return false\n    return p.val === q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/18#issuecomment-3130312988","body":"DFS will be much simpler. BFS will need to pass a lot of context(params) into helper function which I don't like and not maintainable as well.\n\n\n```js\nvar sumNumbers = function(root) {\n    const res = [];\n    dfs(root, '')\n    return res.reduce((prev, cur) => prev + cur, 0);\n\n\n    function dfs(node, str) {\n        if (!node.left && !node.right) {\n            res.push(+`${str}${node.val}`);\n            return;\n        }\n        if (node.left) dfs(node.left, `${str}${node.val}`);\n        if (node.right) dfs(node.right, `${str}${node.val}`);\n    }  \n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/19#issuecomment-3135220392","body":"Using BFS when accessing the first in the queue, that's the leftest node. And because BFS is looping thru by level, so the last time going thru the queue is the most bottom level. \n\n```js\nvar findBottomLeftValue = function(root) {\n    const queue = [root];\n    let min = null;\n    while(queue.length) {\n        const size = queue.length;\n        for(let i = 0; i < size; i++) {\n            const node = queue.shift();\n            if (i === 0) min = node.val\n            \n\n            if (node.left) queue.push(node.left);\n            if (node.right) queue.push(node.right);\n        }\n    }\n    return min;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/20#issuecomment-3138261960","body":"Can use either `DFS` or `BFS` to solve the problem. DFS is more simple to me: \n\n```js\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n    let res = [];\n    function dfs(node) {\n        if (!node) {\n            res.push('null');\n            return;\n        }\n        res.push(String(node.val));\n        dfs(node.left)\n        dfs(node.right)\n    }\n    dfs(root);\n    console.log(res.join(','))\n    return res.join(',')\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n    const datas = data.split(',');\n    let i = 0;\n    return dfs()\n\n    function dfs() {\n        const char = datas[i];\n        if (char === 'null') {\n            i ++\n            return null\n        }\n        const node = new TreeNode(+char);\n        i ++\n        node.left = dfs()\n        node.right = dfs()\n        return node;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/21#issuecomment-3144933267","body":"Use BFS to save the row and column as index, and then sort these indexes. I think the complexity of this problem is how to mange those keys, 2 dimensions keys are quite intricate. \n\nRuntime complexity: O(nlogn), looping over the nodes is O(n), and using `sort` functions are O(nlogn), the bottle neck is sorting functions\nMemory complexity: O(n), use a hashmap to store all nodes\n\n```js\nvar verticalTraversal = function(root) {\n    const map = {}\n    const queue = [{\n        node: root,\n        col: 0,\n    }];\n    let row = 0;;\n    while(queue.length) {\n        const size = queue.length;\n        for(let i = 0; i < size; i++) {\n            const cur = queue.shift();\n            const node = cur.node;\n            if (map[cur.col]?.[row] === undefined) {\n                map[cur.col] = {\n                    ...map[cur.col],\n                    [row]: [node.val]\n                }\n            } else {\n                map[cur.col][row].push(node.val);\n            }\n            if (node.left) queue.push({\n                node: node.left, \n                col: cur.col - 1,\n            })\n            if (node.right) queue.push({\n                node: node.right,\n                col: cur.col + 1\n            })\n        }\n        row ++\n    }\n    const orderByColumn = Object.entries(map).sort(([key1, _], [key2, __]) => Number(key1) - Number(key2));\n    const flatternByColumn = orderByColumn.map(i => {\n        const column = i[1];\n        const arr = [];\n        Object.entries(column).sort(([row1], [row2]) => row1 - row2).forEach(([_row, nodes]) => {\n            const orderedNodes = nodes.sort((a, b) => a - b);\n            arr.push(...orderedNodes)\n        })\n        return arr\n    })\n    return flatternByColumn\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/22#issuecomment-3146516199","body":"```js\nvar twoSum = function(nums, target) {\n    const map = {}\n    for(let i = 0; i < nums.length; i ++) {\n        const num = nums[i];\n        const diff = target - num\n        if (map[diff] !== undefined) {\n            return [map[diff], i];\n        } else {\n            map[num] = i;\n        }\n    }\n    return [-1, -1]\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/23#issuecomment-3148419003","body":"```js\nvar topKFrequent = function(nums, k) {\n    const map = {};\n    for(let i = 0; i < nums.length; i++) {\n        map[nums[i]] = map[nums[i]] ? map[nums[i]] + 1 : 1;\n    }\n    const maxCnt = Math.max(...Object.values(map));\n\n    const buckets = Array.from({length: maxCnt + 1}, () => []);\n    for(let [num, count] of Object.entries(map)) {\n        buckets[count].push(num);\n    }\n\n    const res = [];\n    for(let i = maxCnt; i >= 0 && res.length < k; i--) {\n        res.push(...buckets[i])\n    }\n    \n    return res.map(i => +i)\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/24#issuecomment-3149124973","body":"Using brute force at the beginning, and didn't think of can use map to reduce runtime: \n\n```js\nvar numberOfBoomerangs = function(points) {\n    let res = 0;\n    let map = {}\n    for(let [x1, y1] of points) {\n        map = {}\n        for(let [x2, y2] of points) {\n            const distance = (x1 - x2) ** 2 + (y1 - y2) ** 2;\n            const count = map[distance] ?? 0;\n            res += count * 2;\n            map[distance] = count + 1 \n        }\n    }\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/25#issuecomment-3155367267","body":"Two pointers classic problem (sliding window): \n\n```js\nvar lengthOfLongestSubstring = function(s) {\n    let left = 0, right = 0, res = 0\n    const window = {};\n    while(right < s.length) {\n        const right_char = s[right ++];\n        window[right_char] = window[right_char] ? window[right_char] + 1 : 1;\n        while (window[right_char] > 1) {\n            let remove_char = s[left ++];\n            window[remove_char] --;\n        }\n        res = Math.max(right - left, res);\n    }\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/26#issuecomment-3160227870","body":"so hard: \n\n\n```js\nvar findSubstring = function(s, words) {\n\n    const wordLen = words[0].length;\n    const numWords = words.length;\n    const totalLen = wordLen * numWords;\n    const n = s.length;\n    const res = [];\n\n    if (n < totalLen) return [];\n\n    const wordCount = new Map();\n    for (let word of words) {\n        wordCount.set(word, (wordCount.get(word) || 0) + 1);\n    }\n\n    // we loop over wordLen offsets\n    for (let offset = 0; offset < wordLen; offset++) {\n        let left = offset, count = 0;\n        const seen = new Map();\n\n        for (let right = offset; right + wordLen <= n; right += wordLen) {\n            const word = s.slice(right, right + wordLen);\n\n            if (wordCount.has(word)) {\n                seen.set(word, (seen.get(word) || 0) + 1);\n                count++;\n\n                // we shrink window if word is overused\n                while (seen.get(word) > wordCount.get(word)) {\n                    const leftWord = s.slice(left, left + wordLen);\n                    seen.set(leftWord, seen.get(leftWord) - 1);\n                    left += wordLen;\n                    count--;\n                }\n\n                // Valid window\n                if (count === numWords) {\n                    res.push(left);\n                    const firstWord = s.slice(left, left + wordLen);\n                    seen.set(firstWord, seen.get(firstWord) - 1);\n                    left += wordLen;\n                    count--;\n                }\n            } else {\n                seen.clear();\n                count = 0;\n                left = right + wordLen;\n            }\n        }\n    }\n\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/27#issuecomment-3164450266","body":"```js\nvar minSubarray = function(nums, p) {\n    let totalSum = nums.reduce((a, b) => a + b, 0);\n\n    // Find the remainder when total sum is divided by p\n    let rem = totalSum % p;\n    if (rem === 0) return 0;  // If the remainder is 0, no subarray needs to be removed\n\n    let prefixMod = new Map();\n    prefixMod.set(0, -1);  // Initialize to handle full prefix\n    let prefixSum = 0;\n    let minLength = nums.length;\n\n    for (let i = 0; i < nums.length; i++) {\n        prefixSum += nums[i];\n        let currentMod = prefixSum % p;\n        let targetMod = (currentMod - rem + p) % p;\n\n        if (prefixMod.has(targetMod)) {\n            minLength = Math.min(minLength, i - prefixMod.get(targetMod));\n        }\n\n        prefixMod.set(currentMod, i);\n    }\n\n    return minLength === nums.length ? -1 : minLength;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/28#issuecomment-3168150001","body":"```js\nvar middleNode = function(head) {\n    if (!head || !head.next) return head;\n    let fast = head, slow = head;\n    while(fast && fast.next) {\n        fast = fast.next.next;\n        slow = slow.next\n    } \n    return slow;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/29#issuecomment-3170748221","body":"```js\nvar removeDuplicates = function(nums) {\n    let fast = 0, slow = 0;\n    while(fast < nums.length) {\n        if (nums[slow] !== nums[fast]) {\n            nums[++slow] = nums[fast];\n        }\n        fast ++\n    }\n    return slow + 1\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/30#issuecomment-3172646559","body":"Binary Search\n\n```js\nvar searchInsert = function(nums, target) {\n    let left = 0, right = nums.length;\n    while(left < right) {\n        const mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] >= target) {\n            right = mid\n        } else {\n            left = mid + 1\n        }\n    }\n    return left;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/31#issuecomment-3173319860","body":" Too long to put down DeQueue implementation in JS. Don't think this will be asked in an interview: \n\n```js\nvar maxSlidingWindow = function (nums, k) {\n  const res = [];\n  const dequeue = new Dequeue([]);\n  // 前 k - 1 个数入队\n  for (let i = 0; i < k - 1; i++) {\n    dequeue.push(nums[i]);\n  }\n\n  // 滑动窗口\n  for (let i = k - 1; i < nums.length; i++) {\n    dequeue.push(nums[i]);\n    res.push(dequeue.max());\n    dequeue.shift(nums[i - k + 1]);\n  }\n  return res;\n};\n\nclass Dequeue {\n  constructor(nums) {\n    this.list = nums;\n  }\n\n  push(val) {\n    const nums = this.list;\n    // 保证数据从队头到队尾递减\n    while (nums[nums.length - 1] < val) {\n      nums.pop();\n    }\n    nums.push(val);\n  }\n\n  // 队头出队\n  shift(val) {\n    let nums = this.list;\n    if (nums[0] === val) {\n      // 这里的js实现shift()理论上复杂度应该是O(k), 就不去真实实现一个O(1)出队的队列了，意思到位即可\n      nums.shift();\n    }\n  }\n\n  max() {\n    return this.list[0];\n  }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/32#issuecomment-3179501468","body":"```js\nvar findJudge = function (n, trust) {\n  const count = new Array(n + 1).fill(0);\n  for (const edge of trust) {\n    const x = edge[0];\n    const y = edge[1];\n    count[y]++;\n    count[x]--;\n  }\n  for (let i = 1; i <= n; ++i) {\n    if (count[i] === n - 1) {\n      return i;\n    }\n  }\n  return -1;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/33#issuecomment-3184086046","body":"```js\nvar possibleBipartition = function(N, dislikes) {\n    const graph = [...Array(N+1)].map(() => []);\n    const visited = Array(N+1).fill(false);\n    const color = Array(N+1).fill(0);\n\n    for(let [u, v] of dislikes) {\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n\n    for(let i = 1; i <= N; i++) {\n        if(!colorNodes(i)) return false;\n    }\n    return true;\n\n    function colorNodes(node) {\n        if(visited[node]) return true;\n        const currColor = new Set([1, 2]);\n\n\t\t// remove colors used by neighbors\n        for(let child of graph[node]) {\n            if(color[child] === 1) currColor.delete(1);\n            if(color[child] === 2) currColor.delete(2);\n        }\n\n\t\t// no color is available return false\n        if(currColor.size === 0) return false;\n\t\t\n\t\t// assign the smallest available color\n        color[node] = Math.min(...currColor);\n        visited[node] = true;  \n\n        for(let child of graph[node]) {\n            if(!colorNodes(child)) return false; \n        }\n        return true;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"stonehl":[{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/4#issuecomment-3073791924","body":"C++代码:\n`class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for (int i=n-1; i>=0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            res.push_back(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};`","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/10#issuecomment-3097159903","body":"### 思路：\n1. 异常情况判断；\n2. 统计链表长度， 同时将链表的收尾相连；\n3. 将k对链表长度取余，余数为0表示刚好旋转了链表长度的整数倍，链表节点位置不变；\n4. 新的链表头节点是原链表中第 n - k 个节点。\n### C++代码\n```\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (head == nullptr || head->next == nullptr || k == 0)\n            return head;\n        int count = 1;  // 用来统计链表长度\n        ListNode* tmp = head;\n        while (tmp->next != nullptr) {\n            count++;\n            tmp = tmp->next;    // 滑动到链表尾部\n        }\n        k %= count;\n        //如果刚好是链表长度的倍数，则不进行旋转\n        if (k == 0)\n            return head;\n        tmp->next = head;\n        // \n        for (int i=0; i < count - k; i++) {\n            tmp = tmp->next;\n        }\n        ListNode* newHead = tmp->next;\n        tmp->next = nullptr;\n        return newHead;\n    }\n};\n```\n### 时间复杂度\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/11#issuecomment-3103550594","body":"### 思路：\n使用递归的方法解题\n1. 找递归终止条件，当链表为空或链表只有一个元素时，没法交换，终止递归，返回当前节点；\n2. 每一次递归需要返回的值是交换后的子链表的头节点；\n\n### 代码：\n```\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) {\n            return head;\n        }\n        ListNode* next = head->next;\n        head->next = swapPairs(next->next);\n        next->next = head;\n        return next;\n    }\n};\n\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/17#issuecomment-3127754666","body":"### 思路：\n使用深度优先搜索的方法，\n1. 先找返回条件， 如果两个节点都为空，则返回true;\n2. 如果两个节点都不为空，并且这两个节点的值相等则分别递归判断这两个节点的左子树和右子树的值是否相等，如果相等，则返回true, 否则返回false。\n\n### 代码：\n```\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(p==nullptr && q==nullptr) {\n            return true;\n        }\n        if (p && q && (p->val == q->val)) {\n            return isSameTree(p->right, q->right) && isSameTree(p->left, q->left);\n        }\n        return false;\n\n    }\n};\n```\n### 复杂度分析：\n时间复杂度O(N)，N为两棵树节点的最小值","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/24#issuecomment-3151160755","body":"### 思路：\n将每个距离的出现次数记录在哈希表中，然后遍历哈希表，计算并累加回旋镖的个数。\n\n### 代码：\n```\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        int n = points.size();\n        int res = 0;\n        if (n < 3)\n            return res;\n\n        int ans = 0;\n        for (auto &p : points) {\n            unordered_map<int, int> cnt;\n            for (auto &q : points) {\n                int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n                ++cnt[dis];\n            }\n            for (auto &[_, m] : cnt) {\n                ans += m * (m - 1);\n            }\n        }\n        return ans;\n\n    }\n};\n```\n时间复杂度：O(n2)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/31#issuecomment-3174960911","body":"### 思路：\n使用双端队列来维护滑动窗口内的最大值\n### 代码：\n```\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        deque<int> q;\n        int n = nums.size();\n        vector<int> res;\n        for(int i = 0; i < n; i++) {\n            if(q.size() && i - q.front() >= k)\n                q.pop_front();\n            while(q.size() && nums[q.back()] <= nums[i]) q.pop_back();\n            q.push_back(i);\n            if(i >= k - 1) {\n                res.push_back(nums[q.front()]);\n            }\n        }\n        return res;\n    }\n};\n```\n### 复杂度：\n时间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shuyuanzhang118":[{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/4#issuecomment-3074090351","body":"## 算法思路分析\n\n这是一个将数组形式的整数与普通整数相加的算法，采用了模拟手工加法的思路：\n\n### 核心思路\n1. **从右到左逐位相加**：模拟手工加法，从最低位开始处理\n2. **处理进位**：当两位数字相加结果 ≥ 10 时，产生进位\n3. **处理不同长度**：通过 `num[len-1] || 0` 处理数组已遍历完的情况\n4. **逆序构建结果**：由于是从低位到高位计算，最后需要反转数组\n\n```JavaScript\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let res = []\n    let len = num.length\n    let carry = 0\n    while(len > 0 || k > 0) {\n        let a = num[len - 1] || 0\n        let b = k % 10\n        let sum = a + b + carry\n        res.push(sum % 10)\n        carry = sum >= 10 ? 1 : 0\n        len--\n        k = Math.floor(k / 10)\n    }\n    if (carry) {\n        res.push(1)\n    }\n    return res.reverse()\n};\n```\n\n### 时间复杂度\n**O(max(N, log K))**\n- N 是数组 `num` 的长度\n- log K 是整数 k 的位数\n- 循环次数取决于较长的那个数\n\n### 空间复杂度\n**O(max(N, log K))**\n- 结果数组 `res` 的长度最多为 max(N, log K) + 1\n- 其他变量占用常数空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/5#issuecomment-3079209775","body":"## 算法思路分析\n核心思想：双向遍历\n\n这个算法使用了一种巧妙的双向遍历方法来解决问题：\n\n1. 第一次遍历（从左到右） ：\n   \n   - 记录每个位置到其左边最近字符c的距离\n   - 使用变量 prev 记录上一个字符c的位置\n   - 对于每个位置i，距离为 i - prev\n2. 第二次遍历（从右到左） ：\n   \n   - 计算每个位置到其右边最近字符c的距离\n   - 与第一次遍历的结果取最小值，得到最终答案\n   - 对于每个位置i，距离为 prev - i\n\n## 代码\n```Javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    const n = s.length;\n    const answer = new Array(n).fill(Infinity);\n    \n    // 第一次遍历：从左到右，记录每个位置到左边最近字符c的距离\n    let prev = -Infinity;\n    for (let i = 0; i < n; i++) {\n        if (s[i] === c) {\n            prev = i;\n        }\n        answer[i] = i - prev;\n    }\n    \n    // 第二次遍历：从右到左，更新每个位置到右边最近字符c的距离\n    prev = Infinity;\n    for (let i = n - 1; i >= 0; i--) {\n        if (s[i] === c) {\n            prev = i;\n        }\n        answer[i] = Math.min(answer[i], prev - i);\n    }\n    \n    return answer;\n};\n```\n\n## 复杂度分析\n\n时间复杂度：O(n)\n- 需要遍历字符串两次，每次遍历都是O(n)\n- 总时间复杂度为O(n) + O(n) = O(n)\n- 这是最优的时间复杂度，因为至少需要访问每个字符一次\n\n空间复杂度：O(n)\n- 需要创建一个长度为n的结果数组 answer\n- 除了结果数组外，只使用了常数个额外变量（ prev , i , n ）\n- 如果不计算返回值所需的空间，额外空间复杂度为O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/6#issuecomment-3084609047","body":"### 算法设计思路\n\n**核心数据结构：**\n- 使用数组 `stack` 作为底层存储结构\n- 使用 `maxSize` 记录栈的最大容量\n- 数组索引 0 为栈底，数组末尾为栈顶\n\n### 代码\n\n```JavaScript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.stack.length < this.maxSize) {\n        this.stack.push(x);\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (this.stack.length === 0) {\n        return -1;\n    }\n    return this.stack.pop();\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    // 对栈底的k个元素进行增量操作\n    // 如果栈中元素总数小于k，则对所有元素进行增量操作\n    const elementsToIncrement = Math.min(k, this.stack.length);\n    for (let i = 0; i < elementsToIncrement; i++) {\n        this.stack[i] += val;\n    }\n};\n\n/** \n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n### 时间复杂度分析\n\n| 方法 | 时间复杂度 | 分析 |\n|------|------------|------|\n| **构造函数** | O(1) | 仅初始化两个变量 |\n| **push(x)** | O(1) | 数组末尾添加元素，均摊时间复杂度为 O(1) |\n| **pop()** | O(1) | 数组末尾删除元素 |\n| **increment(k, val)** | O(min(k, n)) | 需要遍历栈底的 k 个元素，n 为当前栈大小 |\n\n### 空间复杂度分析\n\n| 方面 | 空间复杂度 | 分析 |\n|------|------------|------|\n| **整体空间** | O(maxSize) | 最坏情况下数组存储 maxSize 个元素 |\n| **辅助空间** | O(1) | 除了存储栈元素外，只使用常数额外空间 |\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/7#issuecomment-3092430277","body":"### 算法思路分析\n\n**核心思想：使用栈处理嵌套结构**\n\n这是一个典型的括号匹配问题，需要处理嵌套的编码结构。算法的关键在于：\n1. **识别模式** - `k[encoded_string]` 表示重复 k 次\n2. **处理嵌套** - 可能存在多层嵌套，如 `3[a2[c]]`\n3. **状态管理** - 需要记录当前的数字、字符串和历史状态\n\n**算法步骤：**\n1. 遍历字符串的每个字符\n2. 遇到数字：累积构建重复次数（支持多位数）\n3. 遇到 `[`：将当前状态（字符串和数字）压入栈，重置当前状态\n4. 遇到 `]`：从栈中弹出之前的状态，重复当前字符串并拼接\n5. 遇到字母：直接添加到当前字符串\n\n### 代码实现\n\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    const stack = [];\n    let currentNum = 0;\n    let currentStr = '';\n    \n    for (let i = 0; i < s.length; i++) {\n        const char = s[i];\n        \n        if (char >= '0' && char <= '9') {\n            // 构建数字（可能是多位数）\n            currentNum = currentNum * 10 + parseInt(char);\n        } else if (char === '[') {\n            // 遇到左括号，将当前状态入栈\n            stack.push([currentStr, currentNum]);\n            currentStr = '';\n            currentNum = 0;\n        } else if (char === ']') {\n            // 遇到右括号，出栈并重复字符串\n            const [prevStr, num] = stack.pop();\n            currentStr = prevStr + currentStr.repeat(num);\n        } else {\n            // 普通字符，直接添加到当前字符串\n            currentStr += char;\n        }\n    }\n    \n    return currentStr;\n};\n```\n\n### 复杂度分析\n\n**时间复杂度：O(n + m)**\n- n：输入字符串长度\n- m：输出字符串长度\n- 每个字符最多被处理一次\n- 字符串重复操作的总时间与最终输出长度成正比\n\n**空间复杂度：O(n + m)**\n- **栈空间**：O(d) - d 为最大嵌套深度，最坏情况 O(n)\n- **字符串存储**：O(m) - 存储中间结果和最终结果\n- **总空间**：O(n + m)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/8#issuecomment-3092434643","body":"## 核心算法思路\n\n使用两个栈实现队列：\n- `inStack`: 用于接收新元素的输入\n- `outStack`: 用于输出元素\n\n当需要 pop 或 peek 时，如果 outStack 为空，就将 inStack 中的所有元素转移到 outStack 中，这样就实现了先入先出的特性。\n\n## 代码实现\n\n```javascript\n\nvar MyQueue = function() {\n    this.inStack = [];  // 用于输入的栈\n    this.outStack = []; // 用于输出的栈\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.inStack.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if (this.outStack.length === 0) {\n        // 将inStack中的所有元素转移到outStack\n        while (this.inStack.length > 0) {\n            this.outStack.push(this.inStack.pop());\n        }\n    }\n    return this.outStack.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if (this.outStack.length === 0) {\n        // 将inStack中的所有元素转移到outStack\n        while (this.inStack.length > 0) {\n            this.outStack.push(this.inStack.pop());\n        }\n    }\n    return this.outStack[this.outStack.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.inStack.length === 0 && this.outStack.length === 0;\n};\n\n/** \n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n\n## 复杂度分析\n\n**时间复杂度**：\n- push: O(1)\n- pop: 均摊 O(1)\n- peek: 均摊 O(1) \n- empty: O(1)\n\n**空间复杂度**: O(n)\n\n**均摊 O(1) 的原理**：虽然单次 pop 或 peek 操作在最坏情况下可能需要 O(n) 时间，但每个元素最多只会被转移一次，所以 n 个操作的总时间复杂度为 O(n)，均摊下来每个操作为 O(1)。\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/9#issuecomment-3094581867","body":"## 算法思路\n- 关键观察：如果前缀[0...i]的最大值 ≤ 后缀[i+1...n-1]的最小值，则可以在位置i处分块\n- 这保证了前面块的所有元素都不大于后面块的任何元素，分别排序后连接仍然有序\n\n## 代码\n```javascript\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    const n = arr.length;\n    if (n <= 1) return n;\n    \n    // 计算前缀最大值数组\n    const prefixMax = new Array(n);\n    prefixMax[0] = arr[0];\n    for (let i = 1; i < n; i++) {\n        prefixMax[i] = Math.max(prefixMax[i-1], arr[i]);\n    }\n    \n    // 计算后缀最小值数组\n    const suffixMin = new Array(n);\n    suffixMin[n-1] = arr[n-1];\n    for (let i = n-2; i >= 0; i--) {\n        suffixMin[i] = Math.min(suffixMin[i+1], arr[i]);\n    }\n    \n    let chunks = 1; // 至少有一个分块\n    \n    // 检查每个可能的分块点\n    for (let i = 0; i < n-1; i++) {\n        // 如果前缀最大值 <= 后缀最小值，可以在i处分块\n        if (prefixMax[i] <= suffixMin[i+1]) {\n            chunks++;\n        }\n    }\n    \n    return chunks;\n};\n```\n\n## 复杂度分析\n- 时间复杂度：O(n) - 需要三次遍历数组\n- 空间复杂度：O(n) - 需要两个额外数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/10#issuecomment-3097244383","body":"## 核心思路 ：\n-  计算链表长度并找到尾节点\n-   优化k值避免重复旋转\n-  找到新的尾节点（第length-k个节点）\n-  重新连接：断开新尾节点与新头节点，原尾节点连接原头节点\n\n## 代码：\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    // 边界情况处理\n    if (!head || !head.next || k === 0) {\n        return head;\n    }\n    \n    // 1. 计算链表长度并找到尾节点\n    let length = 1;\n    let tail = head;\n    while (tail.next) {\n        tail = tail.next;\n        length++;\n    }\n    \n    // 2. 优化k值，避免不必要的旋转\n    k = k % length;\n    if (k === 0) {\n        return head;\n    }\n    \n    // 3. 找到新的尾节点（从头开始第length-k个节点）\n    let newTail = head;\n    for (let i = 0; i < length - k - 1; i++) {\n        newTail = newTail.next;\n    }\n    \n    // 4. 新的头节点是新尾节点的下一个节点\n    let newHead = newTail.next;\n    \n    // 5. 断开连接并重新连接\n    newTail.next = null;  // 断开新尾节点与新头节点的连接\n    tail.next = head;     // 原尾节点连接到原头节点\n    \n    return newHead;\n};\n```\n\n## 复杂度分析 ：\n- 时间复杂度 ：O(n) - 需要遍历链表计算长度和找到切分点\n- 空间复杂度 ：O(1) - 只使用常数个额外变量","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/11#issuecomment-3103625610","body":"## 算法思路\n- 虚拟头节点技巧: 简化边界条件处理\n- 三指针法: prev, first, second 精确控制交换过程\n- 原地交换: 只修改指针，不创建新节点\n- 边界处理: 空链表和单节点的特殊情况\n\n## 代码实现\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    // 边界情况：空链表或只有一个节点\n    if (!head || !head.next) {\n        return head;\n    }\n    \n    // 创建虚拟头节点，简化操作\n    let dummy = new ListNode(0);\n    dummy.next = head;\n    let prev = dummy;\n    \n    // 当存在至少两个节点时进行交换\n    while (prev.next && prev.next.next) {\n        // 定义要交换的两个节点\n        let first = prev.next;\n        let second = prev.next.next;\n        \n        // 执行交换操作\n        // 步骤：prev -> first -> second -> ... \n        // 变为：prev -> second -> first -> ...\n        prev.next = second;\n        first.next = second.next;\n        second.next = first;\n        \n        // 移动prev指针到已交换的第二个节点（现在是first）\n        prev = first;\n    }\n    \n    return dummy.next;\n};\n```\n\n## 复杂度分析\n- 时间复杂度：O(n) \n- 空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/12#issuecomment-3109219828","body":"## 算法思路\n- 算法的核心思想是利用有序链表的特性：\n- 选择中间节点作为根节点，保证树的平衡性\n- 递归地将左半部分构建为左子树，右半部分构建为右子树\n- 最优解使用中序遍历的特性，避免重复遍历链表\n\n## 代码\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    // 计算链表长度\n    function getLength(head) {\n        let length = 0;\n        while (head) {\n            length++;\n            head = head.next;\n        }\n        return length;\n    }\n    \n    const length = getLength(head);\n    let current = head;\n    \n    // 中序遍历构建BST\n    function buildBST(start, end) {\n        if (start > end) return null;\n        \n        const mid = Math.floor((start + end) / 2);\n        \n        // 先构建左子树\n        const left = buildBST(start, mid - 1);\n        \n        // 创建根节点（当前链表节点）\n        const root = new TreeNode(current.val);\n        current = current.next;\n        \n        // 再构建右子树\n        const right = buildBST(mid + 1, end);\n        \n        root.left = left;\n        root.right = right;\n        \n        return root;\n    }\n    \n    return buildBST(0, length - 1);\n};\n```\n\n## 复杂度分析\n- 时间复杂度：O(n) - 每个节点只访问一次\n- 空间复杂度：O(log n) - 仅递归栈深度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/13#issuecomment-3117083288","body":"## 算法思路\n双指针法 ：让两个指针分别从两个链表头部开始遍历，当指针到达链表末尾时跳转到另一个链表的头部。这样可以消除两个链表的长度差异，如果有交点，两个指针会在交点相遇；如果没有交点，两个指针最终都会变成 null。\n\n## 代码\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    // 如果任一链表为空，直接返回null\n    if (!headA || !headB) {\n        return null;\n    }\n    \n    // 双指针法：让两个指针分别遍历两个链表\n    // 当指针到达链表末尾时，跳转到另一个链表的头部\n    // 这样可以消除长度差，如果有交点，两指针会在交点相遇\n    let pA = headA;\n    let pB = headB;\n    \n    // 当两个指针不相等时继续遍历\n    while (pA !== pB) {\n        // 如果pA到达末尾，跳转到headB；否则继续下一个节点\n        pA = pA === null ? headB : pA.next;\n        // 如果pB到达末尾，跳转到headA；否则继续下一个节点\n        pB = pB === null ? headA : pB.next;\n    }\n    \n    // 返回交点（如果没有交点，两指针都会变成null）\n    return pA;\n};\n```\n\n## 复杂度分析\n- 时间复杂度 ：O(m + n)，其中 m 和 n 分别是两个链表的长度。每个指针最多遍历两个链表一次。\n- 空间复杂度 ：O(1)，只使用了两个指针变量，没有使用额外的数据结构。","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/14#issuecomment-3117100989","body":"## 算法思路\n- 第一阶段 ：使用快慢指针检测是否有环\n- 慢指针每次移动1步，快指针每次移动2步\n- 如果有环，快慢指针必定会相遇\n- 第二阶段 ：找到环的起始节点\n- 基于数学原理：从头节点到环入口的距离等于从相遇点到环入口的距离\n- 将一个指针重置到头节点，两指针同速移动直到相遇\n\n## 代码\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    // 边界情况：空链表或只有一个节点且无环\n    if (!head || !head.next) {\n        return null;\n    }\n    \n    // 第一阶段：使用快慢指针检测是否有环\n    let slow = head;\n    let fast = head;\n    \n    // 快指针每次走两步，慢指针每次走一步\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n        \n        // 如果快慢指针相遇，说明存在环\n        if (slow === fast) {\n            break;\n        }\n    }\n    \n    // 如果没有环，返回null\n    if (!fast || !fast.next) {\n        return null;\n    }\n    \n    // 第二阶段：找到环的起始节点\n    // 将一个指针重置到头节点，两个指针同时以相同速度移动\n    // 它们相遇的地方就是环的起始节点\n    slow = head;\n    while (slow !== fast) {\n        slow = slow.next;\n        fast = fast.next;\n    }\n    \n    return slow; // 返回环的起始节点\n};\n```\n\n## 复杂度分析\n- 时间复杂度 ：O(n) - 最多遍历链表两次\n- 空间复杂度 ：O(1) - 只使用常数个额外变量，满足进阶要求","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/15#issuecomment-3124469572","body":"## 算法思路\n这个LRU（Least Recently Used）缓存实现采用了 哈希表 + 双向链表 的经典设计模式：\n数据结构组合 ：\n - Map ：用于O(1)时间复杂度的键值查找\n - 双向链表：用于维护访问顺序，支持O(1)的插入和删除操作\n - 虚拟头尾节点：简化边界条件处理\n\n## 代码\n```javascript\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map(); // 使用Map存储键值对\n    this.head = {}; // 虚拟头节点\n    this.tail = {}; // 虚拟尾节点\n    this.head.next = this.tail;\n    this.tail.prev = this.head;\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if (!this.cache.has(key)) {\n        return -1;\n    }\n    \n    // 存在则将节点移到链表头部（表示最近使用）\n    const node = this.cache.get(key);\n    this.removeFromList(node);\n    this.addToHead(node);\n    \n    return node.value;\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    // 如果已存在，先删除旧节点\n    if (this.cache.has(key)) {\n        const oldNode = this.cache.get(key);\n        this.removeFromList(oldNode);\n        this.cache.delete(key);\n    }\n    \n    // 创建新节点并添加到头部\n    const newNode = { key, value, prev: null, next: null };\n    this.cache.set(key, newNode);\n    this.addToHead(newNode);\n    \n    // 如果超出容量，删除尾部节点（最久未使用）\n    if (this.cache.size > this.capacity) {\n        const tailNode = this.tail.prev;\n        this.removeFromList(tailNode);\n        this.cache.delete(tailNode.key);\n    }\n};\n\n// 辅助方法：将节点添加到链表头部\nLRUCache.prototype.addToHead = function(node) {\n    node.next = this.head.next;\n    node.prev = this.head;\n    this.head.next.prev = node;\n    this.head.next = node;\n};\n\n// 辅助方法：从链表中删除节点\nLRUCache.prototype.removeFromList = function(node) {\n    node.prev.next = node.next;\n    node.next.prev = node.prev;\n};\n\n/** \n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n```\n\n## 复杂度分析\n- 时间复杂度：O(1)\n- 空间复杂度：O(capacity)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/16#issuecomment-3124496973","body":"## 算法思路\n使用广度优先搜索（BFS）的方法来计算二叉树的最大深度：\n- 初始化 ：如果根节点为空，直接返回0\n- 队列存储 ：使用队列存储节点和对应的深度信息，初始将根节点和深度1入队\n- 层序遍历 ：通过队列进行层序遍历，每次取出队首元素\n- 深度更新 ：更新最大深度值，并将当前节点的左右子节点（如果存在）连同深度+1一起入队\n- 返回结果 ：遍历完成后返回记录的最大深度\n\n## 代码\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    if (!root) return 0;\n    let queue = [[root, 1]];\n    let maxDepth = 0;\n\n    while (queue.length > 0) {\n        let [node, depth] = queue.shift();\n        if (node) {\n            maxDepth = Math.max(maxDepth, depth);\n            if (node.left) queue.push([node.left, depth + 1]);\n            if (node.right) queue.push([node.right, depth + 1]);\n        }\n    }\n\n    return maxDepth;\n};\n```\n\n## 复杂度分析\n- 时间复杂度 O(n) ，其中n是二叉树中节点的总数\n- 空间复杂度 O(w) ，其中w是二叉树的最大宽度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/17#issuecomment-3126191127","body":"## 算法思路\n使用递归的深度优先搜索（DFS）方法：\n- 基本情况 ：如果两个节点都为空，返回 true\n- 边界情况 ：如果只有一个节点为空，返回 false\n- 值比较 ：如果两个节点的值不相等，返回 false\n- 递归检查 ：同时检查左子树和右子树是否相同\n\n## 代码\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n    if (p === null && q === null) {\n        return true;\n    }\n    if (p === null || q === null || p.val !== q.val) {\n        return false;\n    }\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n};\n```\n\n## 复杂度分析\n- 时间复杂度：O(min(m, n))，其中 m 和 n 分别是两棵树的节点数。在最坏情况下需要遍历较小树的所有节点。\n- 空间复杂度 ：O(min(m, n))，递归调用栈的深度取决于树的高度。在完全平衡的树中为 O(log(min(m, n)))，在完全不平衡的树中为 O(min(m, n))。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/18#issuecomment-3133136375","body":"## 算法思路\n这是一个典型的二叉树深度优先搜索（DFS）问题。核心思想是：\n- 从根节点开始，沿着每条路径向下遍历\n- 在遍历过程中，将当前路径形成的数字逐步构建（当前数字 = 之前数字 × 10 + 当前节点值）\n- 当到达叶节点时，将该路径形成的完整数字加入总和\n- 递归处理左右子树，最终返回所有路径数字的总和\n\n## 代码\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root) {\n    // 深度优先搜索函数\n    function dfs(node, currentSum) {\n        // 如果节点为空，返回0\n        if (!node) {\n            return 0;\n        }\n        \n        // 计算当前路径的数字：之前的数字*10 + 当前节点值\n        currentSum = currentSum * 10 + node.val;\n        \n        // 如果是叶节点（没有左右子树），返回当前路径形成的数字\n        if (!node.left && !node.right) {\n            return currentSum;\n        }\n        \n        // 递归计算左右子树的路径数字之和\n        return dfs(node.left, currentSum) + dfs(node.right, currentSum);\n    }\n    \n    return dfs(root, 0);\n};\n```\n\n## 复杂度分析\n- 时间复杂度：O(n) ，其中 n 是二叉树中节点的数量，需要访问每个节点一次\n- 空间复杂度：O(h) ，其中 h 是二叉树的高度，递归调用栈的深度等于树的高度\n  - 最坏情况（完全不平衡的树）：O(n)\n  - 最好情况（完全平衡的树）：O(log n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/19#issuecomment-3136794752","body":"## 算法思路\n广度优先搜索（BFS）\n- 使用层序遍历，从右到左遍历每一层\n- 通过队列实现，先添加右子节点再添加左子节点\n- 最后访问到的节点就是最底层最左边的节点\n\n## 代码\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar findBottomLeftValue = function(root) {\n    // 使用层序遍历（BFS）从右到左遍历每一层\n    // 最后访问到的节点就是最底层最左边的节点\n    let queue = [root];\n    let result = root.val;\n    \n    while (queue.length > 0) {\n        let levelSize = queue.length;\n        \n        // 遍历当前层的所有节点\n        for (let i = 0; i < levelSize; i++) {\n            let node = queue.shift();\n            result = node.val; // 更新结果为当前节点值\n            \n            // 先添加右子节点，再添加左子节点\n            // 这样在同一层中，左边的节点会后被访问到\n            if (node.right) {\n                queue.push(node.right);\n            }\n            if (node.left) {\n                queue.push(node.left);\n            }\n        }\n    }\n    \n    return result;\n};\n```\n\n## 复杂度分析\n- 时间复杂度：O(n)，需要遍历所有节点\n- 空间复杂度：O(w)，w为树的最大宽度（队列空间）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/20#issuecomment-3140223821","body":"## 算法思路\n序列化过程 ：\n- 采用前序遍历（根-左-右）的方式遍历二叉树\n- 空节点用 'null' 字符串表示\n- 所有节点值用逗号连接成字符串\n- 前序遍历的优势是根节点总在最前面，便于重构\n\n反序列化过程 ：\n- 将字符串按逗号分割成数组\n- 使用递归按前序遍历顺序重构二叉树\n- 维护索引指针依次处理数组元素\n- 遇到 'null' 返回空节点，否则创建新节点并递归构建左右子树\n\n## 代码\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n    const result = [];\n    \n    function preorder(node) {\n        if (node === null) {\n            result.push('null');\n            return;\n        }\n        \n        result.push(node.val.toString());\n        preorder(node.left);\n        preorder(node.right);\n    }\n    \n    preorder(root);\n    return result.join(',');\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n    if (!data || data === 'null') {\n        return null;\n    }\n    \n    const values = data.split(',');\n    let index = 0;\n    \n    function buildTree() {\n        if (index >= values.length || values[index] === 'null') {\n            index++;\n            return null;\n        }\n        \n        const node = new TreeNode(parseInt(values[index]));\n        index++;\n        \n        node.left = buildTree();\n        node.right = buildTree();\n        \n        return node;\n    }\n    \n    return buildTree();\n};\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n```\n\n## 复杂度分析\n时间复杂度 ：\n- 序列化：O(n) - 需要访问每个节点一次\n- 反序列化：O(n) - 需要处理每个序列化值一次\n\n空间复杂度 ：\n- 序列化：O(n) - 递归栈深度最坏情况为O(n)，结果数组大小为O(n)\n- 反序列化：O(n) - 递归栈深度最坏情况为O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/21#issuecomment-3148418818","body":"## 算法思路\n- DFS遍历 ：使用深度优先搜索遍历二叉树，记录每个节点的坐标(row, col)和值\n- 坐标规则 ：根据题目要求，左子节点坐标为(row+1, col-1)，右子节点坐标为(row+1, col+1)\n- 分组排序 ：将节点按列索引分组，对每列内的节点先按行排序，同行按值排序\n- 结果输出 ：按列索引从小到大的顺序返回垂序遍历结果\n\n## 代码\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar verticalTraversal = function(root) {\n    if (!root) return [];\n    \n    // 存储节点信息：[row, col, val]\n    const nodes = [];\n    \n    // DFS遍历，记录每个节点的坐标和值\n    function dfs(node, row, col) {\n        if (!node) return;\n        \n        nodes.push([row, col, node.val]);\n        \n        // 左子节点：row+1, col-1\n        dfs(node.left, row + 1, col - 1);\n        // 右子节点：row+1, col+1\n        dfs(node.right, row + 1, col + 1);\n    }\n    \n    // 从根节点开始遍历，根节点坐标为(0, 0)\n    dfs(root, 0, 0);\n    \n    // 按列索引分组\n    const columnMap = new Map();\n    for (const [row, col, val] of nodes) {\n        if (!columnMap.has(col)) {\n            columnMap.set(col, []);\n        }\n        columnMap.get(col).push([row, val]);\n    }\n    \n    // 获取所有列索引并排序\n    const columns = Array.from(columnMap.keys()).sort((a, b) => a - b);\n    \n    const result = [];\n    for (const col of columns) {\n        const columnNodes = columnMap.get(col);\n        // 对每列内的节点排序：先按行排序，同行按值排序\n        columnNodes.sort((a, b) => {\n            if (a[0] !== b[0]) {\n                return a[0] - b[0]; // 按行排序\n            }\n            return a[1] - b[1]; // 同行按值排序\n        });\n        \n        // 提取值\n        result.push(columnNodes.map(node => node[1]));\n    }\n    \n    return result;\n};\n```\n\n## 复杂度分析\n- 时间复杂度 ：O(n log n)，其中n是节点数，主要消耗在排序操作\n- 空间复杂度 ：O(n)，用于存储节点信息和分组数据","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/22#issuecomment-3148426517","body":"## 算法思路\n- 使用哈希表存储已遍历的数值和索引\n- 对每个数值计算其配对数值，在哈希表中O(1)时间查找\n\n## 代码\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    // 创建哈希表，key为数值，value为索引\n    const map = new Map();\n    \n    for (let i = 0; i < nums.length; i++) {\n        // 计算当前数值需要配对的数值\n        const complement = target - nums[i];\n        \n        // 在哈希表中查找配对数值\n        if (map.has(complement)) {\n            // 找到配对，返回两个索引\n            return [map.get(complement), i];\n        }\n        \n        // 将当前数值和索引存入哈希表\n        map.set(nums[i], i);\n    }\n    \n    return []; // 题目保证有解，这里不会执行到\n};\n```\n\n## 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/23#issuecomment-3148432520","body":"## 算法思路\n采用桶排序的思想来实现：\n- 频率统计 ：使用哈希表统计每个元素的出现频率\n- 桶排序 ：创建频率桶，桶的索引表示频率，桶中存储具有该频率的元素\n- 结果收集 ：从最高频率的桶开始遍历，收集前k个元素\n\n## 代码\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar topKFrequent = function(nums, k) {\n    // 步骤1: 统计频率\n    const freqMap = new Map();\n    for (const num of nums) {\n        freqMap.set(num, (freqMap.get(num) || 0) + 1);\n    }\n    \n    // 步骤2: 创建频率桶\n    // 桶的索引表示频率，桶中存储具有该频率的元素\n    const buckets = new Array(nums.length + 1).fill(null).map(() => []);\n    \n    for (const [num, freq] of freqMap) {\n        buckets[freq].push(num);\n    }\n    \n    // 步骤3: 从高频率到低频率收集前k个元素\n    const result = [];\n    for (let i = buckets.length - 1; i >= 0 && result.length < k; i--) {\n        if (buckets[i].length > 0) {\n            result.push(...buckets[i]);\n        }\n    }\n    \n    // 返回前k个元素\n    return result.slice(0, k);\n};\n```\n\n## 复杂度分析\n- 时间复杂度 ：O(n) - 满足题目要求的优于O(n log n)\n- 统计频率：O(n)\n- 创建桶并填充：O(n)\n- 收集结果：O(n)\n\n- 空间复杂度 ：O(n)\n- 哈希表：O(n)\n- 桶数组：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/24#issuecomment-3153115326","body":"## 算法思路\n- 核心思想 ：枚举每个点作为回旋镖的中心点i\n- 距离计算 ：计算中心点到所有其他点的欧式距离（使用距离平方避免开方运算）\n- 哈希统计 ：使用Map统计相同距离的点的数量\n- 组合计算 ：如果有n个点到中心点距离相同，可形成n×(n-1)个回旋镖\n- 顺序考虑 ：回旋镖(i,j,k)和(i,k,j)是不同的，需要考虑j和k的顺序\n\n## 代码\n```javascript\n/**\n * @param {number[][]} points\n * @return {number}\n */\nvar numberOfBoomerangs = function(points) {\n    let count = 0;\n    \n    // 遍历每个点作为回旋镖的中心点i\n    for (let i = 0; i < points.length; i++) {\n        // 使用Map记录从点i到其他点的距离及对应的点的数量\n        const distanceMap = new Map();\n        \n        // 计算点i到其他所有点的距离\n        for (let j = 0; j < points.length; j++) {\n            if (i !== j) {\n                // 计算欧式距离的平方（避免开方运算，提高效率）\n                const distance = getDistanceSquared(points[i], points[j]);\n                \n                // 记录该距离对应的点的数量\n                distanceMap.set(distance, (distanceMap.get(distance) || 0) + 1);\n            }\n        }\n        \n        // 对于每个距离，如果有n个点，则可以形成n*(n-1)个回旋镖\n        // 因为回旋镖(i,j,k)中j和k的顺序是有意义的\n        for (const [distance, pointCount] of distanceMap) {\n            if (pointCount >= 2) {\n                count += pointCount * (pointCount - 1);\n            }\n        }\n    }\n    \n    return count;\n};\n\n/**\n * 计算两点间欧式距离的平方\n * @param {number[]} point1 \n * @param {number[]} point2 \n * @return {number}\n */\nfunction getDistanceSquared(point1, point2) {\n    const dx = point1[0] - point2[0];\n    const dy = point1[1] - point2[1];\n    return dx * dx + dy * dy;\n}\n```\n\n## 复杂度分析\n- 时间复杂度 ：O(n²) - 外层循环n次，内层循环n-1次\n- 空间复杂度 ：O(n) - 最坏情况下Map存储n-1个不同距离","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/25#issuecomment-3153126755","body":"## 算法思路\n- 滑动窗口技术 ：使用双指针 left 和 right 构成滑动窗口\n- 哈希表优化 ：记录每个字符最后出现的位置\n- 动态调整 ：遇到重复字符时，将左指针移动到重复字符的下一个位置\n- 实时更新 ：持续更新最大长度\n\n## 代码\n```javascript\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    if (s.length === 0) return 0;\n    \n    let left = 0;  // 滑动窗口左指针\n    let maxLength = 0;  // 记录最大长度\n    let charMap = new Map();  // 哈希表：字符 -> 最后出现的索引\n    \n    for (let right = 0; right < s.length; right++) {\n        const char = s[right];\n        \n        // 如果字符已存在且在当前窗口内，移动左指针\n        if (charMap.has(char) && charMap.get(char) >= left) {\n            left = charMap.get(char) + 1;\n        }\n        \n        // 更新字符的最新位置\n        charMap.set(char, right);\n        \n        // 更新最大长度\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n    \n    return maxLength;\n};\n```\n\n## 复杂度分析\n- 时间复杂度 ：O(n) - 每个字符最多被访问两次\n- 空间复杂度 ：O(min(m,n)) - m是字符集大小，n是字符串长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/26#issuecomment-3158322222","body":"## 算法思路\n- 滑动窗口 + 哈希表 ：避免生成所有排列组合，直接在原字符串上滑动匹配\n- 分层遍历 ：由于words中所有单词长度相同，按单词长度为步长进行遍历\n- 频次匹配 ：使用哈希表记录words中单词频次，滑动窗口中维护当前单词频次\n- 智能重置 ：遇到不在words中的单词时，直接重置窗口位置\n\n## 代码\n```javascript\n/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nvar findSubstring = function(s, words) {\n    if (!s || !words || words.length === 0) return [];\n    \n    const wordLen = words[0].length;\n    const totalLen = wordLen * words.length;\n    const result = [];\n    \n    // 创建words的频次映射\n    const wordCount = new Map();\n    for (const word of words) {\n        wordCount.set(word, (wordCount.get(word) || 0) + 1);\n    }\n    \n    // 对于每个可能的起始位置（0到wordLen-1），使用滑动窗口\n    for (let i = 0; i < wordLen; i++) {\n        let left = i;\n        let right = i;\n        let validWords = 0;\n        const windowCount = new Map();\n        \n        while (right + wordLen <= s.length) {\n            // 扩展右边界，添加新单词\n            const rightWord = s.substring(right, right + wordLen);\n            right += wordLen;\n            \n            if (wordCount.has(rightWord)) {\n                windowCount.set(rightWord, (windowCount.get(rightWord) || 0) + 1);\n                if (windowCount.get(rightWord) <= wordCount.get(rightWord)) {\n                    validWords++;\n                }\n                \n                // 如果窗口大小超过目标长度，收缩左边界\n                while (right - left > totalLen) {\n                    const leftWord = s.substring(left, left + wordLen);\n                    left += wordLen;\n                    \n                    if (wordCount.has(leftWord)) {\n                        if (windowCount.get(leftWord) <= wordCount.get(leftWord)) {\n                            validWords--;\n                        }\n                        windowCount.set(leftWord, windowCount.get(leftWord) - 1);\n                    }\n                }\n                \n                // 检查是否找到有效的串联子串\n                if (validWords === words.length && right - left === totalLen) {\n                    result.push(left);\n                }\n            } else {\n                // 遇到不在words中的单词，重置窗口\n                windowCount.clear();\n                validWords = 0;\n                left = right;\n            }\n        }\n    }\n    \n    return result;\n};\n```\n\n## 复杂度分析\n- 时间复杂度 ：O(n × m)，其中n是字符串s的长度，m是单词长度\n- 外层循环m次（每个可能的起始偏移）\n- 内层每个字符最多被访问2次（加入和移出窗口）\n\n- 空间复杂度 ：O(k)，其中k是words数组的长度\n- 主要用于存储单词频次的哈希表","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/27#issuecomment-3162949952","body":"## 算法思路\n- 数学原理 ：如果数组总和 sum % p = remainder ，需要找到一个子数组，其和也等于 remainder ，移除后剩余部分就能被p整除\n- 技术方案 ：使用前缀和 + 哈希表来高效查找目标子数组\n- 关键公式 ： prefixSum[i] % p = (prefixSum[j] % p - remainder + p) % p\n\n## 代码\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} p\n * @return {number}\n */\nvar minSubarray = function(nums, p) {\n    // 计算数组总和\n    const totalSum = nums.reduce((sum, num) => sum + num, 0);\n    \n    // 如果总和已经能被p整除，不需要移除任何元素\n    const remainder = totalSum % p;\n    if (remainder === 0) {\n        return 0;\n    }\n    \n    // 使用哈希表记录前缀和的余数及其对应的索引\n    const prefixMap = new Map();\n    prefixMap.set(0, -1); // 初始化，前缀和为0时索引为-1\n    \n    let prefixSum = 0;\n    let minLength = nums.length; // 初始化为数组长度（最坏情况）\n    \n    for (let i = 0; i < nums.length; i++) {\n        prefixSum += nums[i];\n        const currentRemainder = prefixSum % p;\n        \n        // 我们需要找到一个前缀和，使得当前前缀和减去它等于remainder\n        // 即：currentRemainder - targetRemainder = remainder (mod p)\n        // 所以：targetRemainder = (currentRemainder - remainder + p) % p\n        const targetRemainder = (currentRemainder - remainder + p) % p;\n        \n        if (prefixMap.has(targetRemainder)) {\n            const prevIndex = prefixMap.get(targetRemainder);\n            const subarrayLength = i - prevIndex;\n            minLength = Math.min(minLength, subarrayLength);\n        }\n        \n        // 更新当前前缀和余数的索引\n        prefixMap.set(currentRemainder, i);\n    }\n    \n    // 如果最小长度等于数组长度，说明无法找到合适的子数组\n    return minLength === nums.length ? -1 : minLength;\n};\n```\n\n## 复杂度分析\n- 时间复杂度 ：O(n) - 只需要遍历数组一次，哈希表操作为O(1)\n- 空间复杂度 ：O(min(n, p)) - 哈希表最多存储min(n, p)个不同的余数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/28#issuecomment-3166733694","body":"## 算法思路\n使用 快慢指针 （Floyd's Tortoise and Hare Algorithm）技术：\n- 设置两个指针：慢指针每次移动一步，快指针每次移动两步\n- 当快指针到达链表末尾时，慢指针恰好位于链表的中间位置\n- 对于偶数长度的链表，返回第二个中间节点\n\n## 代码\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function(head) {\n    // 使用快慢指针法（Floyd's Tortoise and Hare Algorithm）\n    // 慢指针每次移动一步，快指针每次移动两步\n    // 当快指针到达链表末尾时，慢指针正好在中间位置\n    \n    let slow = head;  // 慢指针\n    let fast = head;  // 快指针\n    \n    // 当快指针和快指针的下一个节点都不为空时继续循环\n    while (fast !== null && fast.next !== null) {\n        slow = slow.next;      // 慢指针移动一步\n        fast = fast.next.next; // 快指针移动两步\n    }\n    \n    // 当循环结束时，slow指针指向中间节点\n    // 如果链表长度为奇数，slow指向唯一的中间节点\n    // 如果链表长度为偶数，slow指向第二个中间节点\n    return slow;\n};\n```\n\n## 复杂度分析\n- 时间复杂度：O(n) - 需要遍历链表一次，其中n是链表的长度\n- 空间复杂度：O(1) - 只使用了两个额外的指针变量，不随输入规模增长","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/29#issuecomment-3172634872","body":"## 算法思路\n- 双指针技术 ：使用 slow 指针指向当前不重复元素的位置， fast 指针遍历数组\n- 原地修改 ：当发现不重复元素时，将其复制到 slow+1 位置\n- 利用排序特性 ：由于数组已排序，相同元素必然相邻，只需比较相邻元素\n\n## 代码\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    // 边界情况：空数组或只有一个元素\n    if (nums.length <= 1) {\n        return nums.length;\n    }\n    \n    // slow指针指向当前不重复元素的位置\n    let slow = 0;\n    \n    // fast指针遍历数组，从第二个元素开始\n    for (let fast = 1; fast < nums.length; fast++) {\n        // 如果当前元素与前一个不重复元素不同\n        if (nums[fast] !== nums[slow]) {\n            // 将slow指针向前移动一位\n            slow++;\n            // 将当前不重复元素复制到slow位置\n            nums[slow] = nums[fast];\n        }\n        // 如果相同，fast继续向前，slow保持不变\n    }\n    \n    // 返回不重复元素的个数（slow指向最后一个不重复元素的索引）\n    return slow + 1;\n};\n```\n\n## 复杂度分析\n- 时间复杂度 ：O(n) - 只需遍历数组一次\n- 空间复杂度 ：O(1) - 只使用常数额外空间，符合原地修改要求","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/30#issuecomment-3172638327","body":"## 算法思路\n- 二分查找核心思想 ：通过比较中间元素与目标值，每次排除一半搜索空间\n- 查找逻辑 ：如果找到目标值返回索引，否则返回应插入的位置\n- 关键实现 ：循环结束时left指针就是插入位置\n\n## 代码\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchInsert = function(nums, target) {\n    let left = 0;\n    let right = nums.length - 1;\n    \n    // 二分查找\n    while (left <= right) {\n        // 计算中间位置，避免整数溢出\n        let mid = Math.floor(left + (right - left) / 2);\n        \n        if (nums[mid] === target) {\n            // 找到目标值，返回索引\n            return mid;\n        } else if (nums[mid] < target) {\n            // 目标值在右半部分\n            left = mid + 1;\n        } else {\n            // 目标值在左半部分\n            right = mid - 1;\n        }\n    }\n    \n    // 没找到目标值，left就是应该插入的位置\n    return left;\n};\n```\n\n## 复杂度分析\n- 时间复杂度 ：O(log n) - 满足题目要求，每次迭代将搜索范围缩小一半\n- 空间复杂度 ：O(1) - 只使用常数级别的额外变量","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/31#issuecomment-3174034461","body":"## 算法思路\n使用双端队列维护一个单调递减的队列，队列中存储数组元素的索引：\n\n- 队首始终是当前窗口的最大值索引\n- 移除超出窗口范围的元素\n- 维护单调性：移除队尾所有小于等于当前元素的索引\n- 当窗口形成时，队首就是最大值\n\n## 代码\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar maxSlidingWindow = function(nums, k) {\n    if (!nums || nums.length === 0 || k <= 0) {\n        return [];\n    }\n    \n    const result = [];\n    const deque = []; // 存储数组索引的双端队列\n    \n    for (let i = 0; i < nums.length; i++) {\n        // 移除队列中超出窗口范围的元素\n        while (deque.length > 0 && deque[0] <= i - k) {\n            deque.shift();\n        }\n        \n        // 维护单调递减队列：移除队尾所有小于当前元素的索引\n        while (deque.length > 0 && nums[deque[deque.length - 1]] <= nums[i]) {\n            deque.pop();\n        }\n        \n        // 将当前元素索引加入队尾\n        deque.push(i);\n        \n        // 当窗口大小达到k时，开始记录结果\n        if (i >= k - 1) {\n            result.push(nums[deque[0]]); // 队首是当前窗口最大值\n        }\n    }\n    \n    return result;\n};\n```\n\n## 复杂度分析\n- 时间复杂度 ：O(n) - 每个元素最多进队列和出队列各一次\n- 空间复杂度 ：O(k) - 队列最多存储k个元素","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/32#issuecomment-3178188012","body":"## 算法思路：\n- 使用度数统计法，将问题转化为图论中的入度和出度计算\n- 法官的特征：不信任任何人（出度=0）+ 被所有其他人信任（入度=n-1）\n- 通过计算每个人的\"信任度\"（入度-出度）来找到法官\n\n## 代码\n```javascript\n/**\n * @param {number} n\n * @param {number[][]} trust\n * @return {number}\n */\nvar findJudge = function(n, trust) {\n    // 特殊情况：只有一个人且没有信任关系，那么这个人就是法官\n    if (n === 1 && trust.length === 0) {\n        return 1;\n    }\n    \n    // 初始化信任度数组，trustScore[i] = 入度 - 出度\n    const trustScore = new Array(n + 1).fill(0);\n    \n    // 遍历所有信任关系\n    for (const [a, b] of trust) {\n        trustScore[a]--; // a信任别人，出度+1，所以信任度-1\n        trustScore[b]++; // b被信任，入度+1，所以信任度+1\n    }\n    \n    // 查找信任度为n-1的人（法官候选人）\n    for (let i = 1; i <= n; i++) {\n        if (trustScore[i] === n - 1) {\n            return i;\n        }\n    }\n    \n    // 没有找到法官\n    return -1;\n};\n```\n\n## 算法复杂度分析\n- 时间复杂度： O(E + n)\n- 遍历trust数组：O(E)，其中E是信任关系数量\n- 查找法官：O(n)\n\n- 空间复杂度： O(n)\n- 需要额外的信任度数组存储每个人的统计信息","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/33#issuecomment-3182100538","body":"## 算法思路\n这是一个经典的二分图判断问题。核心思想是：\n\n- 将问题转化为图着色问题\n- 构建无向图，其中dislikes数组中的每一对表示图中的一条边\n- 使用DFS图着色算法判断是否能用两种颜色给所有节点着色\n- 如果相邻节点都能着不同颜色，则可以分成两组\n\n## 代码\n```javascript\n/**\n * @param {number} n\n * @param {number[][]} dislikes\n * @return {boolean}\n */\nvar possibleBipartition = function(n, dislikes) {\n    // 构建邻接表表示图\n    const graph = new Array(n + 1).fill(null).map(() => []);\n    for (const [a, b] of dislikes) {\n        graph[a].push(b);\n        graph[b].push(a);\n    }\n    \n    // 用于记录每个节点的颜色，0表示未着色，1和-1表示两种不同的颜色\n    const colors = new Array(n + 1).fill(0);\n    \n    // DFS着色函数\n    const dfs = (node, color) => {\n        colors[node] = color;\n        \n        // 遍历所有邻接节点\n        for (const neighbor of graph[node]) {\n            if (colors[neighbor] === 0) {\n                // 如果邻接节点未着色，给它着相反的颜色\n                if (!dfs(neighbor, -color)) {\n                    return false;\n                }\n            } else if (colors[neighbor] === color) {\n                // 如果邻接节点已经着色且颜色相同，说明不能构成二分图\n                return false;\n            }\n        }\n        return true;\n    };\n    \n    // 遍历所有节点，处理可能存在的多个连通分量\n    for (let i = 1; i <= n; i++) {\n        if (colors[i] === 0) {\n            if (!dfs(i, 1)) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n};\n```\n\n## 复杂度分析\n- 时间复杂度 ：O(V + E)，其中V是节点数量（n个人），E是边的数量（dislikes数组长度）\n- 空间复杂度 ：O(V + E)，主要用于邻接表存储、颜色数组和DFS递归栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/34#issuecomment-3186630947","body":"## 算法思路分析：\n这是一个双层拓扑排序问题\n- 首先需要对小组进行拓扑排序，确保依赖的小组在前面\n- 然后对每个小组内的项目进行拓扑排序\n- 最后按小组顺序合并结果\n\n## 代码\n```javascript\n/**\n * @param {number} n\n * @param {number} m\n * @param {number[]} group\n * @param {number[][]} beforeItems\n * @return {number[]}\n */\nvar sortItems = function(n, m, group, beforeItems) {\n    // 为没有小组的项目分配虚拟小组ID\n    let groupId = m;\n    for (let i = 0; i < n; i++) {\n        if (group[i] === -1) {\n            group[i] = groupId++;\n        }\n    }\n    \n    // 构建小组图和项目图\n    const groupGraph = new Array(groupId).fill(0).map(() => []);\n    const groupIndegree = new Array(groupId).fill(0);\n    const itemGraph = new Array(n).fill(0).map(() => []);\n    const itemIndegree = new Array(n).fill(0);\n    \n    // 构建依赖关系图\n    const groupEdges = new Set(); // 用于去重小组间的边\n    \n    for (let i = 0; i < n; i++) {\n        for (const beforeItem of beforeItems[i]) {\n            const beforeGroup = group[beforeItem];\n            const currentGroup = group[i];\n            \n            // 项目依赖关系\n            itemGraph[beforeItem].push(i);\n            itemIndegree[i]++;\n            \n            // 小组依赖关系（只有当项目属于不同小组时）\n            if (beforeGroup !== currentGroup) {\n                const edgeKey = `${beforeGroup}->${currentGroup}`;\n                if (!groupEdges.has(edgeKey)) {\n                    groupEdges.add(edgeKey);\n                    groupGraph[beforeGroup].push(currentGroup);\n                    groupIndegree[currentGroup]++;\n                }\n            }\n        }\n    }\n    \n    // 拓扑排序函数\n    function topologicalSort(graph, indegree) {\n        const queue = [];\n        const result = [];\n        \n        // 找到所有入度为0的节点\n        for (let i = 0; i < indegree.length; i++) {\n            if (indegree[i] === 0) {\n                queue.push(i);\n            }\n        }\n        \n        while (queue.length > 0) {\n            const node = queue.shift();\n            result.push(node);\n            \n            // 更新相邻节点的入度\n            for (const neighbor of graph[node]) {\n                indegree[neighbor]--;\n                if (indegree[neighbor] === 0) {\n                    queue.push(neighbor);\n                }\n            }\n        }\n        \n        return result.length === graph.length ? result : [];\n    }\n    \n    // 对小组进行拓扑排序\n    const sortedGroups = topologicalSort(groupGraph, [...groupIndegree]);\n    if (sortedGroups.length === 0) {\n        return []; // 小组间存在循环依赖\n    }\n    \n    // 对项目进行拓扑排序\n    const sortedItems = topologicalSort(itemGraph, [...itemIndegree]);\n    if (sortedItems.length === 0) {\n        return []; // 项目间存在循环依赖\n    }\n    \n    // 按小组分类项目\n    const groupToItems = new Map();\n    for (const item of sortedItems) {\n        const itemGroup = group[item];\n        if (!groupToItems.has(itemGroup)) {\n            groupToItems.set(itemGroup, []);\n        }\n        groupToItems.get(itemGroup).push(item);\n    }\n    \n    // 按小组顺序合并结果\n    const result = [];\n    for (const groupId of sortedGroups) {\n        if (groupToItems.has(groupId)) {\n            result.push(...groupToItems.get(groupId));\n        }\n    }\n    \n    return result;\n};\n```\n\n## 复杂度分析\n时间复杂度：O(n + E)\n- 构建图：O(E)，E为所有依赖关系总数\n- 小组拓扑排序：O(V_g + E_g)\n- 项目拓扑排序：O(V_i + E_i)\n- 结果合并：O(n)\n\n空间复杂度：O(n + E + m)\n- 图存储：O(n + E)\n- 入度数组：O(n + m)\n- 辅助数据结构：O(n + m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/35#issuecomment-3191484423","body":"## 算法思路\n机器人要回到原点(0,0)，必须满足两个条件：\n- 向左移动的次数 = 向右移动的次数\n- 向上移动的次数 = 向下移动的次数\n\n## 代码\n```javascript\n/**\n * @param {string} moves\n * @return {boolean}\n */\nvar judgeCircle = function(moves) {\n    let x = 0, y = 0; // 当前坐标\n    \n    for (let move of moves) {\n        switch (move) {\n            case 'L':\n                x--;\n                break;\n            case 'R':\n                x++;\n                break;\n            case 'U':\n                y++;\n                break;\n            case 'D':\n                y--;\n                break;\n        }\n    }\n    \n    return x === 0 && y === 0;\n};\n```\n\n## 复杂度分析\n- 时间复杂度 ：O(n)，其中n是moves字符串的长度，需要遍历一次字符串\n- 空间复杂度 ：O(1)，只使用了常数个额外变量，不随输入规模变化","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/36#issuecomment-3194108225","body":"## 算法思路\n- 预处理 ：为每个任务添加原始索引，按进入时间排序\n- 模拟执行 ：使用最小堆维护可执行任务队列，按执行时间最短优先、索引最小优先的规则选择任务\n- 时间管理 ：CPU空闲时直接跳转到下一个任务的进入时间，避免无效等待\n\n## 代码\n```javascript\n/**\n * @param {number[][]} tasks\n * @return {number[]}\n */\nvar getOrder = function(tasks) {\n    const n = tasks.length;\n    \n    // 为每个任务添加原始索引，然后按进入时间排序\n    const taskWithIndex = tasks.map((task, index) => [task[0], task[1], index]);\n    taskWithIndex.sort((a, b) => a[0] - b[0]); // 按enqueueTime排序\n    \n    const result = [];\n    // 优先队列：按执行时间升序，相同时按索引升序\n    const availableTasks = new MinHeap((a, b) => {\n        if (a[0] !== b[0]) {\n            return a[0] - b[0]; // 按processingTime升序\n        }\n        return a[1] - b[1]; // 按originalIndex升序\n    });\n    \n    let currentTime = 0;\n    let taskIndex = 0; // 指向下一个要加入队列的任务\n    \n    while (result.length < n) {\n        // 将所有在当前时间或之前进入队列的任务加入可执行队列\n        while (taskIndex < n && taskWithIndex[taskIndex][0] <= currentTime) {\n            const [enqueueTime, processingTime, originalIndex] = taskWithIndex[taskIndex];\n            availableTasks.push([processingTime, originalIndex]);\n            taskIndex++;\n        }\n        \n        if (availableTasks.size() === 0) {\n            // CPU空闲，直接跳到下一个任务的进入时间\n            if (taskIndex < n) {\n                currentTime = taskWithIndex[taskIndex][0];\n            }\n        } else {\n            // 从可执行任务中选择执行时间最短的（相同时选择索引最小的）\n            const [processingTime, originalIndex] = availableTasks.pop();\n            result.push(originalIndex);\n            currentTime += processingTime;\n        }\n    }\n    \n    return result;\n};\n\n// 最小堆实现\nclass MinHeap {\n    constructor(compareFn) {\n        this.heap = [];\n        this.compare = compareFn || ((a, b) => a - b);\n    }\n    \n    push(val) {\n        this.heap.push(val);\n        this.bubbleUp(this.heap.length - 1);\n    }\n    \n    pop() {\n        if (this.heap.length === 0) return undefined;\n        if (this.heap.length === 1) return this.heap.pop();\n        \n        const top = this.heap[0];\n        this.heap[0] = this.heap.pop();\n        this.bubbleDown(0);\n        return top;\n    }\n    \n    size() {\n        return this.heap.length;\n    }\n    \n    bubbleUp(index) {\n        while (index > 0) {\n            const parentIndex = Math.floor((index - 1) / 2);\n            if (this.compare(this.heap[index], this.heap[parentIndex]) >= 0) break;\n            \n            [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n            index = parentIndex;\n        }\n    }\n    \n    bubbleDown(index) {\n        while (true) {\n            let minIndex = index;\n            const leftChild = 2 * index + 1;\n            const rightChild = 2 * index + 2;\n            \n            if (leftChild < this.heap.length && \n                this.compare(this.heap[leftChild], this.heap[minIndex]) < 0) {\n                minIndex = leftChild;\n            }\n            \n            if (rightChild < this.heap.length && \n                this.compare(this.heap[rightChild], this.heap[minIndex]) < 0) {\n                minIndex = rightChild;\n            }\n            \n            if (minIndex === index) break;\n            \n            [this.heap[index], this.heap[minIndex]] = [this.heap[minIndex], this.heap[index]];\n            index = minIndex;\n        }\n    }\n}\n```\n\n## 复杂度分析\n- 时间复杂度 ：O(n log n)\n  - 排序：O(n log n)\n  - 堆操作：每个任务最多进出堆一次，总计O(n log n)\n- 空间复杂度 ：O(n)\n  - 存储任务信息、最小堆和结果数组","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/37#issuecomment-3194111949","body":"## 算法核心思路\n- 1.时间转换 ：将 \"HH:MM\" 格式转换为分钟数便于计算\n- 2.对局编号计算 ：\n   - 开始时间： Math.ceil(minutes / 15) 确保只计算完整参与的对局\n   - 结束时间： Math.floor(minutes / 15) 确保只计算完整参与的对局\n- 3.分情况处理 ：\n   - 同一天：结束时间对局编号 - 开始时间对局编号\n   - 跨夜：(96 - 开始时间对局编号) + 结束时间对局编号\n\n## 代码\n```javascript\n/**\n * @param {string} loginTime\n * @param {string} logoutTime\n * @return {number}\n */\nvar numberOfRounds = function(loginTime, logoutTime) {\n    // 将时间字符串转换为分钟数\n    function timeToMinutes(time) {\n        const [hours, minutes] = time.split(':').map(Number);\n        return hours * 60 + minutes;\n    }\n    \n    const startMinutes = timeToMinutes(loginTime);\n    const endMinutes = timeToMinutes(logoutTime);\n    \n    // 如果结束时间早于开始时间，说明跨越了午夜\n    if (endMinutes < startMinutes) {\n        // 跨夜情况：从开始时间到午夜 + 从午夜到结束时间\n        // 计算从开始时间到午夜能完成的对局数\n        const roundsBeforeMidnight = 96 - Math.ceil(startMinutes / 15);\n        // 计算从午夜到结束时间能完成的对局数\n        const roundsAfterMidnight = Math.floor(endMinutes / 15);\n        return roundsBeforeMidnight + roundsAfterMidnight;\n    } else {\n        // 同一天情况\n        // 能完成的对局数 = 结束时间所在的对局编号 - 开始时间所在的对局编号\n        const result = Math.floor(endMinutes / 15) - Math.ceil(startMinutes / 15);\n        return Math.max(0, result); // 确保不返回负数\n    }\n};\n```\n\n## 复杂度分析\n- 时间复杂度 ：O(1) - 所有操作都是常数时间的数学计算\n- 空间复杂度 ：O(1) - 只使用固定数量的变量","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/38#issuecomment-3197064559","body":"## 算法思路\n- 1.统计字符频率\n- 2.条件三：变成同一个字母\n- 3.条件一 & 条件二：字母严格大小比较\n- 4.综合最优解\n\n## 代码\n```javascript\n/**\n * @param {string} a\n * @param {string} b\n * @return {number}\n */\nvar minCharacters = function(a, b) {\n    let n = a.length, m = b.length;\n\n    let freqA = new Array(26).fill(0);\n    let freqB = new Array(26).fill(0);\n\n    for (let ch of a) freqA[ch.charCodeAt(0) - 97]++;\n    for (let ch of b) freqB[ch.charCodeAt(0) - 97]++;\n\n    // 前缀和\n    let prefixA = new Array(27).fill(0);\n    let prefixB = new Array(27).fill(0);\n    for (let i = 0; i < 26; i++) {\n        prefixA[i+1] = prefixA[i] + freqA[i];\n        prefixB[i+1] = prefixB[i] + freqB[i];\n    }\n\n    // 条件三：相同字母\n    let ops3 = Infinity;\n    for (let i = 0; i < 26; i++) {\n        ops3 = Math.min(ops3, n + m - (freqA[i] + freqB[i]));\n    }\n\n    // 条件一 & 二\n    let ops1 = Infinity, ops2 = Infinity;\n    for (let c = 0; c < 25; c++) { // 0~24，分割点\n        // a < b\n        ops1 = Math.min(ops1, (n - prefixA[c+1]) + prefixB[c+1]);\n        // b < a\n        ops2 = Math.min(ops2, (m - prefixB[c+1]) + prefixA[c+1]);\n    }\n\n    return Math.min(ops1, ops2, ops3);\n};\n```\n\n## 复杂度分析\n- 时间复杂度：O(n + m)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/39#issuecomment-3199072283","body":"## 算法思路\n- 1.将数组构建为一个 最大堆（heapify）\n     最大堆性质：父节点值 ≥ 子节点值。\n- 2.交换堆顶（最大值）和堆尾元素，把最大值放到最终位置。\n- 3.缩小堆的范围（长度减 1），重新 heapify。\n- 4.重复步骤 2–3，直到整个数组有序。\n\n## 代码\n```javascript\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar sortArray = function(nums) {\n    let n = nums.length;\n\n    // 建堆（从最后一个非叶子节点开始向下调整）\n    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {\n        heapify(nums, n, i);\n    }\n\n    // 不断取出堆顶（最大值）放到数组末尾\n    for (let i = n - 1; i > 0; i--) {\n        // 交换堆顶和堆尾\n        [nums[0], nums[i]] = [nums[i], nums[0]];\n        // 调整剩余部分\n        heapify(nums, i, 0);\n    }\n\n    return nums;\n};\n\n// 调整为最大堆\nfunction heapify(arr, heapSize, root) {\n    let largest = root;\n    let left = 2 * root + 1;\n    let right = 2 * root + 2;\n\n    if (left < heapSize && arr[left] > arr[largest]) {\n        largest = left;\n    }\n\n    if (right < heapSize && arr[right] > arr[largest]) {\n        largest = right;\n    }\n\n    if (largest !== root) {\n        [arr[root], arr[largest]] = [arr[largest], arr[root]];\n        heapify(arr, heapSize, largest);\n    }\n}\n```\n\n## 复杂度分析\n- 时间复杂度\n建堆：O(n)\n每次取出最大值并 heapify：O(log n)，共 n 次\n总计：O(n log n)\n- 空间复杂度\n堆排序在原数组上操作，只需要 O(1) 额外空间","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ariana850409":[{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/4#issuecomment-3074225557","body":"思維：\n以十進位的相加方式，將 k 拆解成字串，從個位數開始與 num 相加，最後再處理一次 num 的進位\n\n代碼：\n```\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        k = str(k)\n        for i in range(-1, -(len(k)+1), -1):\n            number = int(k[i])\n            if abs(i) > len(num):\n                num.insert(0, number)\n            else:\n                num[i] = num[i] + number\n\n        for i in range(-1, -(len(num)+1), -1):\n            temp = num[i]\n            if temp >= 10:\n                num[i] = temp - 10\n                if abs(i-1) > len(num):\n                    num.insert(0, 1)\n                else:\n                    num[i-1] += 1\n\n        return num\n```\n\n時間複雜度：O(N) <br>\n空間複雜度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/5#issuecomment-3078087647","body":"思維：\n先找出所有符合字符 c 的 index，再判斷字符串 s 中每個字符跟要拿來比較的 index 的最短距離\n\n代碼：\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        target = []\n        for i, char in enumerate(s):\n                if char == c:\n                    target.append(i)\n\n        res = []\n        t = 0\n        for i in range(len(s)):\n            tar = target[t]\n            if i < tar:\n                    res.append(tar-i)\n            elif i == tar:\n                    res.append(0)\n            elif t+1 >= len(target):\n                    res.append(i-tar)\n            else:\n                    next_tar = target[t+1]\n                    res.append(min(i-tar, next_tar-i))\n                    if i == next_tar:\n                        t += 1\n        return res\n```\n\n時間複雜度：O(N) <br>\n空間複雜度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/6#issuecomment-3083166293","body":"思維一：單純依照題義用最直接的想法來實作各函式，increment 用遍歷去直接改變列表中的值\n\n代碼：\n```python\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n        \n    def push(self, x: int) -> None:\n        if if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        return self.stack.pop()\n        \n    def increment(self, k: int, val: int) -> None:\n        k = min(k, len(self.stack))\n        for i in range(k):\n            self.stack[i] += val\n```\n時間複雜度：push, pop: O(1) / increment: O(N)\n\n空間複雜度：O(N)\n\n-----\n思維二：優化 increment 的時間複雜度，將 increment value 另存在一個列表，等 pop 時才判斷需加多少值\n\n代碼：\n```python\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n        self.inc = [0] * maxSize\n        \n    def push(self, x: int) -> None:\n        if not len(self.stack) >= self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        inc_idx = len(self.stack)-1\n        inc_val = self.inc[inc_idx]\n        if inc_idx > 0:\n            self.inc[inc_idx-1] += inc_val\n        self.inc[inc_idx] = 0\n        return self.stack.pop() + inc_val\n        \n    def increment(self, k: int, val: int) -> None:\n        k = min(k, len(self.stack))\n        if k > 0:\n            self.inc[k-1] += val\n```\n時間複雜度：push, pop, increment: O(1)\n\n空間複雜度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/7#issuecomment-3087613442","body":"思維：使用兩個 stack 模擬進入與退出重複區塊的過程，每遇到 [ 就壓入當下狀態，遇到 ] 就彈出並拼接，逐步建立出完整的解碼字串\n\n代碼：\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        cnt_stack = []\n        str_stack = []\n        cnt = ''\n        temp = ''\n        for c in s:\n            if c.isdigit():\n                cnt += c\n            elif c == '[':\n                cnt_stack.append(int(cnt))\n                str_stack.append(temp)\n                cnt = ''\n                temp = ''\n            elif c == ']':\n                times = cnt_stack.pop()\n                prev_str = str_stack.pop()\n                temp = prev_str + temp * times\n            else:\n                temp += c\n\n        return temp\n```\n時間複雜度：O(N)\n\n空間複雜度：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/8#issuecomment-3091473302","body":"思維一：以暴力解的方式在 peek 或 pop 的操作時，用另一個陣列依序存目前 stack pop 出來的所有元素，操作結果後再依序新增回去，時間及空間複雜度皆為 O(N)（無實作）<br>\n思維二：使用兩個 stack 來操作存取，當有  peek 或 pop 的操作時，從 out_stack 拿取，判斷 out_stack 為空時再一次性的把當前 in_stack 的所有元素倒進 out_stack\n\n代碼：\n```python\nclass MyQueue(object):\n\n    def __init__(self):\n        self.in_stack = []\n        self.out_stack = []\n        \n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.in_stack.append(x)\n        \n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if not self.out_stack:\n            while self.in_stack:\n                self.out_stack.append(self.in_stack.pop())\n        return self.out_stack.pop()\n        \n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if not self.out_stack:\n            while self.in_stack:\n                self.out_stack.append(self.in_stack.pop())\n        return self.out_stack[-1]\n        \n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return not (self.in_stack + self.out_stack)\n```\n時間複雜度：O(1) (Amortized)\n\n空間複雜度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/10#issuecomment-3096165781","body":"思維：\n1. 空串列直接回傳\n2. 先計算鏈結長度 length\n3. 把 k 對 length 取餘，因為旋轉 length 次等於沒動\n4. 用兩個指針 slow 和 fast 找到新的頭 new_head 的位置\n5. 將鏈結斷開重新連接，完成旋轉\n\n代碼：\n```python\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :type k: int\n        :rtype: Optional[ListNode]\n        \"\"\"\n        if not head: \n            return head\n\n        length = 1\n        temp = head\n        while temp.next:\n            length += 1\n            temp = temp.next\n\n        slow, fast = head, head\n        for _ in range(k % length):\n            if fast.next:\n                fast = fast.next\n            else:\n                fast = head\n\n        if slow == fast: \n            return head\n\n        while fast.next:\n            slow = slow.next\n            fast = fast.next\n\n        new_head = slow.next\n        slow.next = None\n        fast.next = head\n        return new_head\n```\n時間複雜度：O(N)\n\n空間複雜度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/11#issuecomment-3100848058","body":"思維：先處理無需交換的情況，透過一個 dummy 節點統一處理頭節點與後續節點的交換邏輯，每次迴圈交換一對相鄰節點，並用 pre 將已處理區與未處理區銜接起來，最後回傳 dummy 的下一個節點作為新鏈表的頭\n\n代碼：\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n\n        left = head\n        right = head.next\n        dummy = ListNode(None, head)\n        pre = dummy\n        while right:\n            left.next = right.next\n            right.next = left\n            pre.next = right\n            pre = left\n            left = left.next\n            right = left.next if left else None\n\n        return dummy.next\n```\n時間複雜度：O(N)\n\n空間複雜度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/12#issuecomment-3109165432","body":"思維：有想到要計算遞迴的中心點，但一開始解不出來，參考官方題解的思路加上畫圖後思路有比較清晰\n\n代碼：\n```python\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        if not head:\n            return head\n\n        pre, slow, fast = None, head, head\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n            \n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n```\n時間複雜度：O(NlogN)\n\n空間複雜度：O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/13#issuecomment-3112948103","body":"思維：\n1. 使用兩個指標 a 和 b，分別從 headA 和 headB 開始走。\n2. 每當指標走到自己 linked list 的結尾時，跳到另一條 linked list 的頭部繼續走。\n3. 最終：<br>\n     a. 若兩條 list 有交點，a 和 b 會在同一個節點交會（因為走過的總長度相同）。<br>\n     b. 若沒有交點，a 和 b 都會變成 None，同時結束迴圈。\n\n代碼：\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        a, b = headA, headB\n        a_switch, b_switch = False, False\n        \n        while a and b:\n            if a == b:\n                return a\n\n            a = a.next if a.next else None\n            if not a and not a_switch:\n                a = headB\n                a_switch = True\n                \n            b = b.next if b.next else None\n            if not b and not b_switch:\n                b = headA\n                b_switch = True\n\n        return None\n```\n時間複雜度：O(N)\n\n空間複雜度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/14#issuecomment-3114228960","body":"思維：使用快慢指針來偵測是否有環存在，若有找到相遇點的話，把 fast 指針重新指向 head 後找環的起點，兩個指針 slow 和 fast 都改成一次走一步，再次相遇時就是環的起始節點\n\n代碼：\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return None\n\n        slow, fast = head, head\n        while fast:\n            slow = slow.next\n            fast = fast.next.next if fast.next else None\n            if slow and slow == fast:\n                fast = head \n                while fast != slow:\n                    fast = fast.next\n                    slow = slow.next\n                return fast\n\n        return None\n```\n時間複雜度：O(N)\n\n空間複雜度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/15#issuecomment-3122031171","body":"思維：使用雙向鏈表搭配 Hash Map 實作 LRU Cache，讓每次的 get 和 put 操作都能在 O(1) 時間內完成。最近使用的節點會被移到鏈表頭部，當容量超過時，就從尾部刪除最久未使用的節點。\n\n代碼：\n```python\nclass ListNode:\n    def __init__(self, key, value):\n        self.key = key\n        self.val = value\n        self.next = None\n        self.pre = None\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.length = 0\n        self.head = ListNode(None, None)\n        self.tail = ListNode(None, None)\n        self.head.next = self.tail\n        self.tail.pre = self.head\n        self.map = {}\n\n    def _add_to_head(self, key: int, value: int):\n        node = ListNode(key, value)\n        node.next = self.head.next\n        self.head.next = node\n        node.next.pre = node\n        node.pre = self.head\n        self.map[key] = node\n        self.length += 1\n\n    def _remove_from_tail(self, key: int):\n        remove_key = self.tail.pre.key\n        self.tail.pre = self.tail.pre.pre\n        self.tail.pre.next = self.tail\n        self.map.pop(remove_key)\n        self.length -= 1\n\n    def _move_node_to_head(self, node: ListNode):\n        node.pre.next = node.next\n        node.next.pre = node.pre\n        self.head.next.pre = node\n        node.pre = self.head\n        node.next = self.head.next\n        self.head.next = node\n        \n    def get(self, key: int) -> int:\n        if key in self.map:\n            node = self.map[key]\n            self._move_node_to_head(node)\n            return self.map[key].val\n        return -1\n        \n    def put(self, key: int, value: int) -> None:\n        node = self.map.get(key)\n        if node:\n            self._move_node_to_head(node)\n            node.val = value\n        else:\n            if self.length >= self.capacity:\n                self._remove_from_tail(key)            \n            self._add_to_head(key, value)\n```\n時間複雜度：O(1)\n\n空間複雜度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/16#issuecomment-3124493359","body":"思維：DFS，透過遞迴分別計算左右子樹的最大深度，然後回傳較大的一邊再加 1（代表當前節點這一層），最終得到整棵樹的最大深度。\n\n代碼：\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        return max(self.maxDepth(root.left), self.maxDepth(root.right))+1\n```\n時間複雜度：O(N)\n\n空間複雜度：O(h) (max depth of tree)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/17#issuecomment-3127762191","body":"思維：DFS，透過遞歸比對兩棵樹的每個對應節點是否完全一樣，一層層往下檢查，直到整棵樹都比對完或中途不符合就結束。\n\n代碼：\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        \n        if p and q and p.val == q.val:\n            res_left = self.isSameTree(p.left, q.left)\n            res_right = self.isSameTree(p.right, q.right)\n            return res_left and res_right\n\n        return False\n```\n時間複雜度：O(N)\n\n空間複雜度：O(h) (max depth of tree)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/18#issuecomment-3133090654","body":"思維：DFS，透過遞歸保存當前數字的狀態，每走到下一層就把目前的 current_num 乘上 10 再加上當前節點的值，當走到葉子節點時就可以回傳目前這條路徑的數字，最後把左右子樹的 dfs 結果加總起來。\n\n代碼：\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        def dfs(node, current_num):\n            if not node:\n                return 0\n            current_num = current_num * 10 + node.val\n            if not node.left and not node.right:\n                return current_num\n            return dfs(node.left, current_num) + dfs(node.right, current_num)\n        return dfs(root, 0)\n```\n時間複雜度：O(N)\n\n空間複雜度：O(d) (max depth of tree)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/19#issuecomment-3135855226","body":"思維一：BFS，使用廣度優先搜尋一層層遍歷二元樹節點，並記錄每一層最先遇到的節點。每當進入新的一層，就更新目前儲存的節點為該層最左側的節點。最終回傳的是最底層最左邊那個節點的值。\n\n代碼：\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        q = deque()\n        res = (root,0)\n        q.append((root,0))\n        while q:\n            node, level = q.popleft()\n            cur_level = res[1]\n            if level > cur_level:\n                res = (node, level)\n\n            if node.left:\n                q.append((node.left, level+1))\n            if node.right:\n                q.append((node.right, level+1))\n\n        return res[0].val\n```\n\n時間複雜度：O(N)\n\n空間複雜度：O(w) (max width of tree)\n\n---------\n思維二：DFS，使用深度優先搜尋遍歷整顆樹，每當遇到更深層的節點，就更新目前記錄的最左邊節點值，最終返回的是整棵樹最深層最左邊的節點值。\n\n代碼：\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        def dfs(node, cur_depth, leftmost, depthest):\n            if cur_depth > depthest:\n                leftmost = node.val\n                depthest = cur_depth\n\n            if node.left:\n                leftmost, depthest = dfs(node.left, cur_depth+1, leftmost, depthest)\n            if node.right:\n                leftmost, depthest = dfs(node.right, cur_depth+1, leftmost, depthest)\n            return leftmost, depthest\n\n        leftmost, depthest = dfs(root, 1, root.val, 1)\n        return leftmost\n```\n\n時間複雜度：O(N)\n\n空間複雜度：O(h) (max height of tree)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/20#issuecomment-3140470104","body":"思維一：DFS<br>\nserialize： 使用 前序遍歷（DFS） 將樹的結構與節點值轉成 list，再轉為 JSON 字串，None 用來記錄空節點保證可逆。<br>\ndeserialize： 根據前序順序，遇到 None 表示空節點，遞迴還原出整棵樹的結構。\n\n代碼：\n```python\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        res = []\n        def dfs(node):\n            if not node:\n                res.append(None)\n                return\n\n            res.append(node.val)\n            dfs(node.left)\n            dfs(node.right)\n\n        dfs(root)\n        return json.dumps(res)\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        data = deque(json.loads(data))\n        def dfs(data):\n            val = data.popleft()\n            if val is None:\n                return\n\n            node = TreeNode(val)\n            node.left = dfs(data)\n            node.right = dfs(data)\n            return node\n        \n        return dfs(data)\n\n# Your Codec object will be instantiated and called as such:\n# ser = Codec()\n# deser = Codec()\n# ans = deser.deserialize(ser.serialize(root))\n```\n\n時間複雜度：O(N)<br>\n空間複雜度：O(N)\n\n-----------------\n\n思維二：BFS<br>\nserialize：利用 BFS（層序遍歷）將每層節點值與空位（None）一起寫入 list，最後轉成 JSON 字串。<br>\ndeserialize：讀回字串後同樣使用 BFS，按順序建立節點並接上左右子節點，重建出原始二叉樹。\n\n代碼：\n```python\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        res = []\n        queue = deque([root])\n        while queue:\n            node = queue.popleft()\n            if node:\n                res.append(node.val)\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                res.append(None)\n\n        return json.dumps(res)\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        data = deque(json.loads(data))\n        root_val = data.popleft()\n        if root_val is None:\n            return None\n            \n        root = TreeNode(root_val)\n        queue = deque([root])\n        while queue:\n            node = queue.popleft()\n            if data:\n                left_val = data.popleft()\n                right_val = data.popleft()\n                if left_val is not None:\n                    left_node = TreeNode(left_val)\n                    node.left = left_node\n                    queue.append(left_node)\n                if right_val is not None:\n                    right_node = TreeNode(right_val)\n                    node.right = right_node\n                    queue.append(right_node)\n\n        return root\n\n# Your Codec object will be instantiated and called as such:\n# ser = Codec()\n# deser = Codec()\n# ans = deser.deserialize(ser.serialize(root))\n```\n\n時間複雜度：O(N)<br>\n空間複雜度：O(N)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/24#issuecomment-3148593193","body":"思維：\n1. 對每個點 i 當作中心，計算它與所有其他點的距離\n2. 用 distance_map 統計，有多少個點與 i 的距離相同（也就是距離為 d 的點出現了幾次）\n3. 如果某個距離出現了 count 次（基本上就是超過一次的次數才會被納入計算），就能組出 count * (count - 1) 種 (j, k) boomerang（因為 (j, k),  (k, j) 視為兩種組合，(count - 1) 為要扣掉已經放在前一個位置的元素）\n4. 最後把所有距離的組合數加總起來即可\n\n代碼：\n```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        res = 0\n        for i, x in enumerate(points):\n            distance_map = defaultdict(int)\n            for j, y in enumerate(points):\n                if i != j:\n                    distance_map[(y[0] - x[0])**2 + (y[1] - x[1])**2] += 1\n\n            for count in distance_map.values():\n                res += count * (count-1)\n\n        return res\n```\n時間複雜度：O(N^2)\n\n空間複雜度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/25#issuecomment-3153175756","body":"思維：\n1. 使用雙指針 left 和 right 維護一個「不含重複字元的滑動視窗」\n2. 不斷將 right 指向的字元加入 seen\n3. 一旦發現重複字元，就從 left 開始依序從 seen 移除字元，直到這個重複字元被清掉\n4. 每次 right 移動後，更新視窗大小 right - left，維護一個最大值 max_str\n\n代碼：\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        max_str = 0\n        left = 0\n        right = 0\n        seen = set()\n        while right < len(s):\n            while s[right] in seen:\n                seen.remove(s[left])\n                left += 1\n            seen.add(s[right])\n            right += 1\n            max_str = max(max_str, right-left)\n        return max_str\n```\n時間複雜度：O(N)\n\n空間複雜度：O(k) (k for number of character types)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/26#issuecomment-3160705635","body":"思維：\n1. 多組偏移掃描：使用 i in range(word_len) 對字串做「分組」掃描，防止錯過合法起始點\n2. 滑動視窗掃描：每次從 j 開始擷取一個單字（長度 word_len），如果這個字在 words 裡，放進 window_counter，若某個單字超出次數，移動 left（左指針）來縮小視窗，如果視窗內剛好有 word_count 個單字，加入結果\n3. 如果不是合法單字，清空 window_counter，重設 count 和 left（下一次從這個位置繼續）\n\n代碼：\n```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        word_len = len(words[0])\n        word_count = len(words)\n        total_len = word_len * word_count\n        target_counter = Counter(words)\n        res = []\n\n        for i in range(word_len):\n            left = i\n            window_counter = Counter()\n            count = 0\n\n            for j in range(i, len(s) - word_len + 1, word_len):\n                word = s[j:j+word_len]\n                if word in target_counter:\n                    window_counter[word] += 1\n                    count += 1\n\n                    while window_counter[word] > target_counter[word]:\n                        left_word = s[left:left+word_len]\n                        window_counter[left_word] -= 1\n                        count -= 1\n                        left += word_len\n\n                    if count == word_count:\n                        res.append(left)\n\n                else:\n                    window_counter.clear()\n                    count = 0\n                    left = j + word_len\n\n        return res\n```\n時間複雜度：O(N × W) (N is length of s, W is length of words)\n\n空間複雜度：O(W)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/28#issuecomment-3166506559","body":"思維：使用快慢指標 (two pointers) 技巧，設兩個指標 slow 和 fast 同時指向鏈表頭，每次 slow 走一步、fast 走兩步，當 fast 到達鏈表尾時，slow 正好在中間節點。\n\n代碼：\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        return slow        \n```\n時間複雜度：O(N)\n\n空間複雜度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/30#issuecomment-3172494360","body":"思維：使用雙指針來實行二分搜尋法，設定左右邊界取中間位置\n1. 如果 nums[mid] == target，直接回傳 mid（找到目標）。\n2. 如果 nums[mid] > target，代表目標在左半邊，更新 right = mid - 1。\n3. 如果 nums[mid] < target，代表目標在右半邊，更新 left = mid + 1。\n4. 迴圈結束後（left > right），left 就是目標應插入的位置。\n\n代碼：\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left = 0\n        right = len(nums)-1\n        while left <= right:\n            mid = (left+right)//2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n```\n時間複雜度：O(logN)\n\n空間複雜度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/31#issuecomment-3173687770","body":"思維：使用單調遞減隊列來維護視窗內最大值的 index\n1. 前 k 個元素先初始化隊列：維持隊列的遞減性，每次新來的元素會移除尾部比它小的元素，q[0] 永遠是最大值的 index\n2. 接下來從 k 到結尾，維持單調性並移除過期元素：新元素進來時維持單調隊列，移除滑出視窗的 index，每次把 nums[q[0]]（視窗最大值）加入結果\n\n代碼：\n```python\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        res = []\n        q = deque()\n        for i in range(k):\n            while q and nums[q[-1]] < nums[i]:\n                q.pop()\n            q.append(i)\n        res.append(nums[q[0]])\n\n        for i in range(k, len(nums)):\n            while q and nums[q[-1]] < nums[i]:\n                q.pop()\n            q.append(i)\n            while q[0] <= i-k:\n                q.popleft()\n            res.append(nums[q[0]])\n\n        return res\n```\n時間複雜度：O(N)\n\n空間複雜度：O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/32#issuecomment-3178842909","body":"思維：\n1. 使用兩個表分別紀錄信任他人及被信任的計數\n2. 之後尋找一個人 x，滿足：trusted_tables[x] == n - 1（被其他人信任）以及 trust_tables[x] == 0:（自己沒信任任何人）\n3. 若找到這樣的人，回傳他的編號；否則回傳 -1\n\n代碼：\n```python\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        if n == 1:\n            return 1\n\n        trust_tables = defaultdict(int)\n        trusted_tables = defaultdict(int)\n        for [trust_a, trust_b] in trust:\n            trust_tables[trust_a] += 1\n            trusted_tables[trust_b] += 1\n\n        for trusted_person, trusted_ticket in trusted_tables.items():\n            if trusted_ticket == n-1 and trust_tables[trusted_person] == 0:\n                return trusted_person\n        return -1\n```\n時間複雜度：O(N)\n\n空間複雜度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/34#issuecomment-3188960333","body":"思維：\n1. 把沒群組的 item 分配新的唯一群組：這樣後面只需處理群組 id，不用特別分支處理 -1。\n2. 建立 item graph：由 prev -> curr（prev 必須在 curr 前面）。\n3. 建立 group graph：當 prev 與 curr 屬不同群組時，建立 g_prev -> g_curr 的依賴邊；用 set 避免重複邊。\n4. 對 group graph 做拓撲排序：得出 group 的一個合法順序；若有 cycle，無解回 []。\n5. 對 item graph 做拓撲排序：得出 items 在全域上的合法相對順序（若有 cycle，無解回 []）。\n6. 把 items 按 item_order 分桶到對應 group，再按 group_order 串接：同 group items 會連在一起且保持 item 之間的依賴。\n\n代碼：\n```python\nclass Solution:\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\n        new_group_id = m\n        for i in range(n):\n            if group[i] == -1:\n                group[i] = new_group_id\n                new_group_id += 1\n        total_groups = new_group_id\n\n        item_adj = [[] for _ in range(n)]\n        item_indeg = [0] * n\n\n        group_adj = [[] for _ in range(total_groups)]\n        group_indeg = [0] * total_groups\n\n        added_group_edges = set()\n\n        for curr in range(n):\n            for prev in beforeItems[curr]:\n                item_adj[prev].append(curr)\n                item_indeg[curr] += 1\n\n                g_prev = group[prev]\n                g_curr = group[curr]\n                if g_prev != g_curr:\n                    if (g_prev, g_curr) not in added_group_edges:\n                        added_group_edges.add((g_prev, g_curr))\n                        group_adj[g_prev].append(g_curr)\n                        group_indeg[g_curr] += 1\n\n        def topo_sort(num_nodes, adj, indeg):\n            q = deque([i for i in range(num_nodes) if indeg[i] == 0])\n            order = []\n            while q:\n                u = q.popleft()\n                order.append(u)\n                for v in adj[u]:\n                    indeg[v] -= 1\n                    if indeg[v] == 0:\n                        q.append(v)\n            if len(order) == num_nodes:\n                return order\n            else:\n                return []\n\n        group_order = topo_sort(total_groups, group_adj, group_indeg[:])\n        if not group_order:\n            return []\n\n        item_order = topo_sort(n, item_adj, item_indeg[:])\n        if not item_order:\n            return []\n\n        items_by_group = defaultdict(list)\n        for item in item_order:\n            items_by_group[group[item]].append(item)\n\n        result = []\n        for g in group_order:\n            result.extend(items_by_group[g])\n\n        return result\n```\n時間複雜度：O(n + E)\n\n空間複雜度：O(n + m + E)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/35#issuecomment-3191064414","body":"思維：依照題意模擬路徑\n\n代碼：\n```python\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        spot = [0, 0]\n        for move in moves:\n            if move == 'R':\n                spot[0] += 1\n            elif move == 'L':\n                spot[0] -= 1\n            elif move == 'U':\n                spot[1] += 1\n            else:\n                spot[1] -= 1\n        \n        return spot == [0, 0]\n```\n時間複雜度：O(N)\n\n空間複雜度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/37#issuecomment-3194164140","body":"思維：\n1. 解析登入、登出時間（時、分），如果登出時間早於登入時間，代表跨過午夜就加 24 小時。\n2. 重新計算登入時間：向上取整到最近的 15 分鐘倍數（因為要等到下一個完整的 15 分鐘才算開始一局）。\n3. 重新計算登出時間：向下取整到最近的 15 分鐘倍數（因為超過的部分不算完整一局）。\n4. 計算完整局數，如果結果為負數則返回 0。\n\n這裡用 (logout_hour-login_hour)*4 - login_minute/15 + logout_minute/15 直接換算成以「15 分鐘為單位」的差距。\n\n代碼：\n```python\nclass Solution:\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\n        login_hour, login_minute = map(int, loginTime.split(':'))\n        logout_hour, logout_minute = map(int, logoutTime.split(':'))\n        if logout_hour < login_hour or logout_hour == login_hour and logout_minute < login_minute:\n            logout_hour += 24\n\n        login_hour, login_minute = self.narrow_down_time(login_hour, login_minute, True)\n        logout_hour, logout_minute = self.narrow_down_time(logout_hour, logout_minute, False)\n\n        return max(0, int((logout_hour-login_hour)*4 - login_minute/15 + logout_minute/15))\n\n    def narrow_down_time(self, login_hour: int, login_minute: int, is_login: bool):\n        if is_login:\n            login_minute = ceil(login_minute/15) * 15\n            if login_minute == 60:\n                login_hour += 1\n                login_minute = 0\n        else:\n            login_minute = floor(login_minute/15) * 15\n\n        return login_hour, login_minute\n```\n時間複雜度：O(1)\n\n空間複雜度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/38#issuecomment-3196258303","body":"思維：\n1. 函式 compare_less(a_counter, b_counter)：模擬條件 1、2，對所有可能分界點 ch（從 'b' 到 'z'）進行遍歷<br>\n讓 a 的所有字母 < ch，讓 b 的所有字母 ≥ ch，使用 prefix sum 避免重複運算，計算出最少需要修改的字元數\n2. 函式 compare_distinct(a_counter, b_counter)：模擬條件 3，讓兩字串變成同一種字母<br>\n對所有字母出現次數總和 Counter 做合併，找出現次數最多的字母後，將其餘字母通通改成這個字母，修改次數 = 總數量 - 該字母出現次數\n3. 分別計算三個條件需要的修改次數，回傳三者中的最小值\n\n代碼：\n```python\nclass Solution:\n    def minCharacters(self, a: str, b: str) -> int:\n        a_counter = Counter(ord(ch) for ch in a)\n        b_counter = Counter(ord(ch) for ch in b)\n\n        goal_a = self.compare_less(a_counter, b_counter)\n        goal_b = self.compare_less(b_counter, a_counter)\n        goal_c = self.compare_distinct(a_counter, b_counter)\n        return min(goal_a, goal_b, goal_c)\n\n    def compare_less(self, a_counter, b_counter):\n        a_freq = [0] * 26\n        b_freq = [0] * 26\n        for k, v in a_counter.items():\n            a_freq[k - ord('a')] = v\n        for k, v in b_counter.items():\n            b_freq[k - ord('a')] = v\n\n        a_prefix = list(itertools.accumulate(a_freq))\n        b_prefix = list(itertools.accumulate(b_freq))\n        move = float('inf')\n        for ch in range(1, 26):\n            move_a = a_prefix[25] - a_prefix[ch-1]\n            move_b = b_prefix[ch-1]\n            move = min(move, move_a + move_b)\n        return move\n\n    def compare_distinct(self, a_counter, b_counter):\n        all_counter = a_counter + b_counter\n        most_key = max(all_counter, key=all_counter.get)\n        total = sum(all_counter.values())\n        return total - all_counter[most_key]\n```\n時間複雜度：O(n+m)\n\n空間複雜度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zechengze":[{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/4#issuecomment-3074243047","body":"### Time complexity\nO(max(n, log₁₀(k)))\n\n### Space complexity\nO(max(n, log₁₀(k)))\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        ans = []\n        n = len(num)\n        carry = 0\n        i = n - 1\n        while k > 0 or i >= 0 or carry > 0:\n            sum = carry\n            if k > 0:\n                rem = k % 10\n                sum += rem\n                k //= 10\n            if i >= 0:\n                sum += num[i]\n                i -= 1\n            carry = sum // 10\n            ans.insert(0, sum % 10)\n        return ans","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/8#issuecomment-3092419843","body":"使用兩個 stack：\n- in_stack: 用來接收 push\n- out_stack: 用來處理 pop 和 peek\n- 當 out_stack 為空時，將 in_stack 的所有元素彈出並倒序放入 out_stack，用來模擬 queue 的 FIFO\n\n - push：O(1)\n - pop：O(1)\n - peek：O(1)\n - empty ：O(1)\n\n---\n\n### Python code\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.in_stack = []\n        self.out_stack = []\n\n    def push(self, x: int) -> None:\n        self.in_stack.append(x)\n\n    def pop(self) -> int:\n        self.peek()  # 確保 out_stack 有東西\n        return self.out_stack.pop()\n\n    def peek(self) -> int:\n        if not self.out_stack:\n            while self.in_stack:\n                self.out_stack.append(self.in_stack.pop())\n        return self.out_stack[-1]\n\n    def empty(self) -> bool:\n        return not self.in_stack and not self.out_stack","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/12#issuecomment-3109185662","body":"### 解題思路\n- 先統計整個 linked list 長度。\n- 使用遞迴，每次選擇區間的中間當作 root。\n- 左子樹遞迴後才處理當前節點。\n\n時間 O(n) 每個節點遍歷一次\n\n```python\nclass Solution:\n  def sortedListToBST(self, head: ListNode) -> TreeNode:\n      def getLength(node: ListNode) -> int:\n          length = 0\n          while node:\n              length += 1\n              node = node.next\n          return length\n\n      def buildBST(start: int, end: int) -> TreeNode:\n          nonlocal head\n          if start > end:\n              return None\n\n          mid = (start + end) // 2\n          # 先建左子樹\n          left = buildBST(start, mid - 1)\n\n          # 再建 root（中序）\n          root = TreeNode(head.val)\n          head = head.next\n\n          # 最後建右子樹\n          root.left = left\n          root.right = buildBST(mid + 1, end)\n          return root\n\n      length = getLength(head)\n      return buildBST(0, length - 1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/16#issuecomment-3124485354","body":"### 思路\n- 遞迴 DFS\n- 如果節點為空，深度為 0。\n- 遞迴左右子樹的最大深度，取最大值後 +1。\n\n---\n\n### 遞迴 DFS（Top-down）\n\n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/19#issuecomment-3136873834","body":"### BFS（反向遍歷）\n\n- 一般 BFS 是左先入，改為右先入左後入\n- 最後訪問的節點就是最底層最左側的節點\n- 每次 `popleft()` 拿出的節點覆蓋 `leftmost`\n- 時間複雜度 : O(n)\n---\n\n```python\n\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return None\n        \n        queue = deque([root])\n        leftmost = None\n\n        while queue:\n            leftmost = queue.popleft()\n            if leftmost.right:\n                queue.append(leftmost.right)\n            if leftmost.left:\n                queue.append(leftmost.left)\n\n        return leftmost.val\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/22#issuecomment-3146260024","body":"### 解題思路：哈希表（一次遍歷）\n\n1. 初始化一個空dict h\n2. 遍歷陣列 nums，對每個元素 nums[i]：\n   - 計算 plus = target - nums[i]\n   - 如果 plus 的值在字典中，回傳 [h[plus], i]\n   - else 將 nums[i] 存入 dict 中\n\n- 時間、空間複雜度：O(n)\n\n---\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        h = {}\n        for i in range(len(nums)):\n            plus = target - nums[i]\n            if plus in h:\n                return [h[plus], i]\n            else:\n                h[nums[i]] = i","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/23#issuecomment-3148509431","body":"### 解題思路：哈希表 + 排序\n\n1. 先用 dict 統計每個元素出現的次數\n2. 使用 sorted 對 dict 依據頻率降序排序\n3. 取出前 k 個 keys 回傳\n\n- 時間複雜度：O(n log n)\n\n---\n\n```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        h_map = {}\n        for i in nums:\n            if i in h_map:\n                h_map[i] += 1\n            else:\n                h_map[i] = 1\n\n        h_map = dict(sorted(h_map.items(), key=lambda x: x[1], reverse=True))\n        ans = list(h_map.keys())[:k]\n        return ans\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/29#issuecomment-3170662667","body":"## 解題思路\n陣列已排序，相同的元素一定會相鄰，因此可以使用雙指針：  \n1. 設定指標 `init` 指向下個唯一值要放置的位置，初始為 1。  \n2. 從第二個元素開始遍歷，若與前一個元素不同，則將該元素放到 `init` 位置並將 `init` 加 1。  \n3. 最後 `init` 即為去重後的長度。\n\n---\n\n## 時間複雜度\n- **O(n)**：只需遍歷一次陣列。\n\n## 空間複雜度\n- **O(1)**：在原陣列上進行操作，未使用額外空間。\n\n---\n\n## 程式碼\n```python\nfrom typing import List\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        init = 1\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[init] = nums[i]\n                init += 1\n        return init\n```\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/33#issuecomment-3182007045","body":"### 解題思路\n1. 將 `dislikes` 轉換為 **圖的鄰接表** `dislike_table`。\n2. 使用顏色標記（`BLUE = 1`, `GREEN = -1`）來表示兩組人。\n3. 對每個尚未染色的人進行 DFS：\n   - 將當前人染色為某一顏色。\n   - 對於他不喜歡的人，必須染成相反顏色。\n   - 如果發現相鄰節點顏色與自己相同，則表示無法二分。\n4. 如果所有人都能正確染色，則回傳 `True`。\n\n---\n\n```python\nfrom collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        BLUE, GREEN = 1, -1\n        \n        def draw(person_id, color):\n            color_of[person_id] = color\n            for the_other in dislike_table[person_id]:\n                if color_of[the_other] == color:\n                    return False\n                if not color_of[the_other] and not draw(the_other, -color):\n                    return False\n            return True\n        \n        if N == 1 or not dislikes:\n            return True\n        \n        dislike_table = defaultdict(list)\n        color_of = defaultdict(int)\n        \n        for p1, p2 in dislikes:\n            dislike_table[p1].append(p2)\n            dislike_table[p2].append(p1)\n        \n        for person_id in range(1, N + 1):\n            if not color_of[person_id] and not draw(person_id, BLUE):\n                return False\n        \n        return True","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mr-kient":[{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/4#issuecomment-3074503694","body":"### 【Day 1】989. 数组形式的整数加法\n\n#### Main Idea\n\n1. Since the length of `num` can reach 10000, a brute-force approach of adding each digit of `num` multiplied by 10^[n-i] to form a number and then adding it to K is not feasible, as it would cause an overflow.\n\n2. We can simulate manual vertical calculation by reversing the array and starting the addition from the last digit of both `num` and `k`.\n\n3. Set a global variable `ex` to determine if a carry is needed when adding each digit.\n\n   > [!NOTE]\n   > Remember to check if there is a carry after adding the first digit.\n\n4. If an array index exceeds the limit, treat it as 0; if `k` is shorter than `num`, treat the remaining digits of `k` as 0.\n\n\n#### Code\n\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int n = num.size();\n        vector<int> res;\n        int ex = 0;\n        int i = n - 1;\n\n        while (i >= 0 || k > 0) {\n            int x = (i >= 0) ? num[i] : 0; //k可能比num长\n            int y = k % 10;\n            int sum = x + y + ex;\n            res.push_back(sum % 10);\n            ex = sum / 10;\n            k /= 10;\n            i--;\n        }\n\n        if (ex)\n            res.push_back(ex);\n\n        reverse(res.begin(), res.end());\n\n        return res;\n    }\n};\n```\n\n#### Complexity\n\n$O(Max(num.size(),  log(k)))$","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/5#issuecomment-3076134448","body":"### **【Day 2】821. 字符的最短距离**\n\n#### Main idea\n\n1. Two linear traversals: The first one records the distance from each `s[i]` to the previous `c` from left to right; The second time, from right to left, update the minimum distance compared to the previous distance\n2. ⚠️ Note: During the two initializations, the first initialization should be very small because there will be no appearance of `c` after traversing to the right for a long time. If the setting is not small enough, it will result in an insufficiently large distance value, which will affect the update of the correct value from right to left in the second traversal\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> res(n, n);\n        int c_id = -n;\n\n        for (int i = 0; i < n; i++) {\n\n            if (s[i] == c) {\n                c_id = i;\n            }\n            res[i] = i - c_id;\n        }\n\n        c_id = 2 * n;\n\n        for (int j = n - 1; j >= 0; j--) {\n            if (s[j] == c) {\n                c_id = j;\n            }\n\n            res[j] = min(res[j], c_id - j);\n        }\n\n        return res;\n    }\n};\n```\n\n#### Complexity\n\nLoop twice: $O(2*s.szie())$","onTime":true},null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/16#issuecomment-3124415547","body":"### 【Day 13】[104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)\n\n#### Main Idea \n\n1. 首先考虑到递归即遍历二叉树的左右子树，计算每个节点的左右子树的最大深度\n\n   - **递归终止条件**：如果当前节点为空，则返回0（表示当前路径长度为0）。\n   - **递归逻辑**：对于当前节点，递归计算左子树的最大深度和右子树的最大深度，取较大值并加1（当前节点本身）\n   - **时间复杂度**：O(n)，其中n是二叉树的节点总数。每个节点被访问一次。\n\n2. DFS\n\n   ```c++\n   /**\n    * Definition for a binary tree node.\n    * struct TreeNode {\n    *     int val;\n    *     TreeNode *left;\n    *     TreeNode *right;\n    *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n    * };\n    */\n    \n   class Solution {\n   public:\n       int maxDepth(TreeNode* root) {\n           if (!root) return 0;\n           \n           std::stack<std::pair<TreeNode*, int>> s;\n           s.push({root, 1});\n           int max_depth = 0;\n    \n           while (!s.empty()) {\n               auto [node, depth] = s.top();\n               s.pop();\n               max_depth = std::max(max_depth, depth);\n    \n               if (node->left) {\n                   s.push({node->left, depth + 1});\n               }\n               if (node->right) {\n                   s.push({node->right, depth + 1});\n               }\n           }\n    \n           return max_depth;\n       }\n   };\n   ```\n\n   \n\n#### 时间复杂度\n\n要计算二叉树的最大深度，必须访问每一个节点一次，因为最长路径可能出现在任意位置。**没有比O(n)更优的时间复杂度**，因为无论如何都需要遍历所有节点以确认最长路径。","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/22#issuecomment-3146453148","body":"### 【Day 19】两数之和\n\n#### Main Idea\n\n1. **暴力枚举**\n   - 遍历数组中的每一个元素 `nums[i]`，再对其后续所有元素 `nums[j]`（`j > i`）进行遍历，判断 `nums[i] + nums[j] == target` 时返回 `[i, j]`。\n   - **时间复杂度**：O(n²)，最坏情况下需要检查所有的元素对。\n2. **哈希表（一遍扫描）**\n   - 利用一个哈希表 `mp` 存储 <数值 → 下标 >的映射。\n   - 遍历数组，令 `complement = target - nums[i]`：\n     - 如果哈希表中已存在 `complement`，说明之前遇到过这么一个数，二者之和等于 `target`，直接返回对应的下标。\n     - 否则将当前元素 `nums[i]` 及其下标 `i` 存入哈希表，继续扫描。\n   - **优点**：一次遍历搞定，时间和空间都最优。\n\n```c++\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int,int> mp;  // 存储 已访问的数值 → 下标\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            // 如果哈希表中已有 complement，则直接返回答案\n            if (mp.find(complement) != mp.end()) {\n                return { mp[complement], i };\n            }\n            // 否则将当前数及下标存入\n            mp[nums[i]] = i;\n        }\n        return {};  // 根据题意不会走到这里\n    }\n};\n```\n\n#### 时间复杂度\n\n- **哈希表解法**：O(n)，只需一次遍历即可完成查找与存储操作。\n- **空间复杂度**：O(n)，最坏情况下哈希表需存储 n 个元素。","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/28#issuecomment-3168242525","body":"Main Idea\n\n1. 快慢指针法\n\n设置两个指针 slow 和 fast，初始都指向链表头结点。\n\nfast 每次向前移动 两步，slow 每次向前移动 一步。\n\n当 fast 到达链表末尾时，slow 恰好位于链表的中间位置。\n\n由于题目要求 当有两个中间结点时返回第二个，快慢指针法天然满足这一条件：当链表长度为偶数时，fast 会先到 NULL，此时 slow 指向的就是第二个中间结点。\n\n\n\n2. 时间复杂度\n\nO(n)：每个结点最多被访问一次（快指针访问 n/2 次，慢指针访问 n 次）。\n\n\n\n3. 空间复杂度\n\nO(1)：只使用了两个额外指针，不需要额外的数据结构。\n\n\n\n\n\n---\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while (fast != nullptr && fast->next != nullptr) {\n            slow = slow->next;         // 慢指针走一步\n            fast = fast->next->next;   // 快指针走两步\n        }\n        return slow; // slow 即为中间结点\n    }\n};\n\n\n---\n\n时间复杂度分析\n\n访问链表的所有节点至少需要一次遍历，因此 没有比 O(n) 更优的时间复杂度。\n\n快慢指针法通过一次遍历同时得到中间节点，避免了额外的存储或两次遍历，比先统计长度再走一半更高效。\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/34#issuecomment-3188424726","body":"#### Main Idea\n\n1. **把未分组项目“补组”**：对 `group[i] == -1` 的项目，给它们分配新的组号（从 `m` 开始递增），这样每个项目都有归属组，最终组的总数记为 `G`。\n2. **两层拓扑排序（Group 拓扑 + Item 拓扑）**：\n\n   * **项目层图**：对每条依赖 `u ∈ beforeItems[v]`，连边 `u → v`，统计项目入度。\n   * **组层图**：若 `group[u] != group[v]`，再在组图里连边 `group[u] → group[v]`，统计组入度。\n   * **先对项目图做一次拓扑排序（得到全局项目顺序）**，再对组图做一次拓扑排序（得到组顺序）。\n3. **按组拼接**：将“项目拓扑序”按照其组别分桶（保持项目拓扑中的相对顺序），再按“组拓扑序”依次把每个桶拼接起来即为答案。\n4. **不可行判定**：任一拓扑排序失败（存在环）则返回空数组。\n\n* **关键点**：跨组依赖只影响组与组的先后关系（由组图保证），组内项目的详细先后由项目图保证。用“两层图”可同时满足“组块相邻”和“依赖有序”。\n\n---\n\n2. **实现**\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {\n        // 1) 给未分组的项目分配新组号\n        int gid = m;\n        for (int i = 0; i < n; ++i) {\n            if (group[i] == -1) group[i] = gid++;\n        }\n        int G = gid; // 组总数\n\n        // 2) 建立项目图 & 组图\n        vector<vector<int>> itemAdj(n), groupAdj(G);\n        vector<int> itemIn(n, 0), groupIn(G, 0);\n\n        for (int v = 0; v < n; ++v) {\n            for (int u : beforeItems[v]) {\n                itemAdj[u].push_back(v);\n                itemIn[v]++;\n                if (group[u] != group[v]) {\n                    groupAdj[group[u]].push_back(group[v]);\n                    groupIn[group[v]]++;\n                }\n            }\n        }\n\n        // 通用 Kahn 拓扑\n        auto topo = [](const vector<vector<int>>& adj, vector<int> indeg) -> vector<int> {\n            int N = (int)adj.size();\n            queue<int> q;\n            for (int i = 0; i < N; ++i) if (indeg[i] == 0) q.push(i);\n            vector<int> order;\n            order.reserve(N);\n            while (!q.empty()) {\n                int x = q.front(); q.pop();\n                order.push_back(x);\n                for (int y : adj[x]) {\n                    if (--indeg[y] == 0) q.push(y);\n                }\n            }\n            if ((int)order.size() != N) return {}; // 有环\n            return order;\n        };\n\n        // 3) 分别对 项目图、组图 做拓扑排序\n        vector<int> itemOrder = topo(itemAdj, itemIn);\n        if (itemOrder.empty()) return {};\n        vector<int> groupOrder = topo(groupAdj, groupIn);\n        if (groupOrder.empty()) return {};\n\n        // 4) 按项目拓扑序分桶到各组里，保持项目相对次序\n        vector<vector<int>> bucket(G);\n        for (int x : itemOrder) bucket[group[x]].push_back(x);\n\n        // 5) 按组拓扑序拼接\n        vector<int> ans;\n        ans.reserve(n);\n        for (int g : groupOrder) {\n            for (int x : bucket[g]) ans.push_back(x);\n        }\n        return ans;\n    }\n};\n```\n\n#### 时间复杂度\n\n* 建图与两次拓扑排序总计 **O(n + E)**，其中 `E = Σ |beforeItems[i]|`。\n* 额外空间用于邻接表、入度数组与分桶，均为 **O(n + E + G)**。\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leohongyi":[{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/4#issuecomment-3076771871","body":"【Day 1】989. 数组形式的整数加法\nmain idea 从最低位开始加,如果还有进位，将其添加到结果前面 使用逆序遍历 range(len(num) - 1, -1, -1) 从数组的最后一个元素（最低位）开始\ndivmod(num[i] + k, 10) 计算当前位置的数字与 k 相加后的结果，返回商和余数 如果处理完数组中所有位后仍有进位（k > 0）\n从 k 中提取最低位数字，并插入到数组最前面\n继续处理 k 的下一位，直到 k 变为 0\n余数 num[i] 保存在当前位置\n商 k 作为进位传递给下一个更高位\n整体时间复杂度为 O(max(n, log k))。\ncode\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        for i in range(len(num) - 1, -1, -1):\n            k, num[i] = divmod(num[i] + k, 10)\n        \n        while k > 0:\n            k, digit = divmod(k, 10)\n            num.insert(0, digit)\n        return num\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/5#issuecomment-3077014132","body":"main idea:\n创建 ret 数组，长度为len(s)\n再次遍历s的过程中，我们需要判断当满足以下两点条件时，指针 p 右移一位\np小于arr最大下标\n前下标i 到 p + 1的绝对距离比到 p 的绝对距离小\n每次将 p - i 的绝对距离添加至 ret[i] 中\n\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ret, p, arr = [], 0, [i for i in range(len(s)) if s[i] == c]\n        for i, j in enumerate(s):\n            if p < len(arr) - 1 and abs(arr[p] - i) > abs(arr[p + 1] - i):\n                p += 1\n            ret.append(abs(arr[p] - i))\n        return ret\nTime Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/6#issuecomment-3082831029","body":"使用数组的栈结构，self.top作为栈顶指针\n进出栈分别通过简单的数组赋值与读取进行操作\nincrement函数通过一个循环进行赋值操作\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = [0]*maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top < len(self.stack) - 1:\n            self.top += 1\n            self.stack[self.top] = x\n\n    def pop(self) -> int:\n        if self.top is -1:\n            return self.top\n        else:\n            self.top -= 1\n            return self.stack[self.top+1]\n        \n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, self.top + 1)):\n            self.stack[i] += val\n\n\n\nTime complexity: O（k）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/7#issuecomment-3092615113","body":"算法步骤：\n利用current string， current number 记录所有不同的括号层级内的string和num；\n使用stk来记录之前的数字和前置str；推荐先push num, 后push str 至 stack；\nO(n)\n代码：\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        cur_str, cur_num = \"\", \"\"\n        stk = []\n        for c in s:\n            if c.isdigit():\n                cur_num += c\n            elif c == '[':\n                stk.append(cur_str)\n                stk.append(cur_num)\n                cur_str, cur_num = \"\", \"\"\n            elif c == ']':\n                cur_str *= int(stk.pop())\n                cur_str = stk.pop() + cur_str\n            else:\n                cur_str += c\n        return cur_str\n\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/8#issuecomment-3092624509","body":"算法设计\n加入队尾 push() ： 将数字 val 加入栈 A 即可。\n获取队首元素 peek() ：\n当栈 B 不为空： B中仍有已完成倒序的元素，因此直接返回 B 的栈顶元素。\n否则，当 A 为空： 即两个栈都为空，无元素，因此返回 -1 。\n否则： 将栈 A 元素全部转移至栈 B 中，实现元素倒序，并返回栈 B 的栈顶元素。\n弹出队首元素 pop() ：\n执行 peek() ，获取队首元素。\n弹出 B 的栈顶元素。\n队列判空 empty() ： 当栈 A 和 B 都为空时，队列为空。\n\nclass MyQueue:\n\n    def __init__(self):\n        self.A, self.B = [], []\n\n    def push(self, x: int) -> None:\n        self.A.append(x)\n\n    def pop(self) -> int:\n        peek = self.peek()\n        self.B.pop()\n        return peek\n\n    def peek(self) -> int:\n        if self.B: return self.B[-1]\n        if not self.A: return -1\n        # 将栈 A 的元素依次移动至栈 B\n        while self.A:\n            self.B.append(self.A.pop())\n        return self.B[-1]\n    def empty(self) -> bool:\n        return not self.A and not self.B\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n时间复杂度： push(), empty() 函数的时间复杂度为 O(1) ；peek() , pop() 函数在 N 次队首元素删除操作中总共需完成 N 个元素的倒序，均摊时间复杂度为 O(1) 。\n\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/9#issuecomment-3105379844","body":"main: 如果当前元素大于或者等于maxx，入栈， 更新最大值maxx\n如果当前元素小于栈顶元素，循环弹出栈顶元素，直到当前元素大于或等于栈顶元素，注意不用将当前元素入栈！！不过要再将maxx压入栈，因为刚刚pop时肯定把maxx弹出栈了\n\n。class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        maxx, stk = arr[0], [arr[0]]\n        for i in range(1, len(arr)):\n            if arr[i] >= maxx:\n                maxx = arr[i]\n                stk.append(arr[i])\n            else:\n                while stk and stk[-1] > arr[i]:\n                    stk.pop()\n                stk.append(maxx)\n        return len(stk)\n        时间复杂度O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/10#issuecomment-3111913253","body":"找到尾结点 形成环形链表\n尾结点移动length - k 步 有移动k步 == 左移length - k 步\n找到头结点 断开头尾链接\n\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        tail = head\n        length = 1\n        while tail.next:\n            length += 1\n            tail = tail.next\n        tail.next = head\n\n        k = k % length\n        for _ in range(length - k):\n            tail = tail.next\n        \n        head = tail.next\n        tail.next = None\n        return head\n        ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/11#issuecomment-3111983736","body":"先交换以node3为头结点的链表 \nnode1指向地柜返回的链表头\n把node2指向node1\n返回node2 作为交换完成的链表头结点\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None or head.next is None:\n            return head\n        node1 = head\n        node2 = head.next\n        node3 = node2.next\n\n        node1.next = self.swapPairs(node3)\n        node2.next = node1\n\n        return node2\n        ","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dmax1314":[{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/4#issuecomment-3082278662","body":"1. 第一个想法是数组转换数字然后相加再转换回去\n时间和空间复杂度都应该是O(n)\n```python\nfrom typing import List\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        # 1. 数组 -> 字符串 -> 数字\n        # 首先将列表中的每个数字转换为字符串，然后拼接成一个完整的字符串\n        # [1, 2, 0, 0] -> [\"1\", \"2\", \"0\", \"0\"] -> \"1200\"\n        s = \"\".join(map(str, num))\n        \n        num_val = int(s)\n        \n        # 2. 数字相加\n        result_val = num_val + k\n        \n        # 3. 数字 -> 字符串 -> 数组\n        # 将结果数字转换回字符串\n        # 1234 -> \"1234\"\n        result_s = str(result_val)\n        \n        # 将结果字符串中的每个字符转换回整数，并放入列表中\n        # \"1234\" -> [\"1\", \"2\", \"3\", \"4\"] -> [1, 2, 3, 4]\n        result_array = [int(digit) for digit in result_s]\n        \n        return result_array\n```\n但是似乎换其他的语言会溢出\n2. 第二个想法就是模拟加法操作，从个位数加起，关键问题在于处理进位\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        result = []\n        carry = 0\n        i = len(num) - 1  # 指向 num 的最后一位\n        \n        while i >= 0 or k > 0 or carry > 0:\n            digit = carry  # 初始化为进位\n            \n            if i >= 0:  # 如果 num 中还有数字\n                digit += num[i]\n                i -= 1\n            \n            if k > 0:  # 如果 k 中还有数字\n                digit += k % 10\n                k //= 10  # 整个 k 除以 10\n            \n            # 处理进位\n            result.append(digit % 10)\n            carry = digit // 10\n        \n        result.reverse()  # 因为是从个位到十位添加的，最后需要反转\n        return result  # 返回结果\n```\n这里是要反转的 我一开始忘了这个事情，因为数组把个位的和放在了第一位和实际数字反过来了\n时间复杂度: O(max(N, M))，其中 N 是 num 的长度，M 是 k 的数字长度。我们需要遍历这两个数的每一位。\n空间复杂度: O(max(N, M))，用于存储结果数组。\n\n---\n在看lc题解的时候发现一个很有趣的模板可能以后会用到\n ```\nwhile ( A 没完 || B 没完)\n    A 的当前位\n    B 的当前位\n\n    和 = A 的当前位 + B 的当前位 + 进位carry\n\n    当前位 = 和 % 10;\n    进位 = 和 / 10;\n\n判断还有进位吗\n```\n>作者：lilyunoke\n>链接：https://leetcode.cn/problems/add-to-array-form-of-integer/solutions/570659/989-ji-zhu-zhe-ge-jia-fa-mo-ban-miao-sha-8y9r/\n>来源：力扣（LeetCode）\n>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n稍微改了一下得到一个python加法模板，\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = len(num)\n        res = []\n        i = n - 1\n        s = 0\n        carry = 0\n        while i >= 0 or k != 0:\n            x = num[i] if i >= 0 else 0\n            y = k % 10 if k != 0 else 0\n\n            s = x + y + carry\n            carry = s // 10\n            k //= 10\n\n            i -= 1\n            res.insert(0, s % 10)\n\n        if carry != 0:\n            res.insert(0, carry)\n        return res\n```\n据说这个模板还可以用到[2](https://leetcode.com/problems/add-two-numbers/description/),[165](https://leetcode.com/problems/compare-version-numbers/)和[809](https://leetcode.com/problems/expressive-words/)这周末抽空可以做一下","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/7#issuecomment-3086540520","body":"# 第四天\n构造栈结构，利用先入后出的特性来实现括号匹配\n大概做法就是\n1. 使用栈来存放数字、字符以及中间结果。\n2. 遇到数字时，解析出完整的k值（可能是多位数）。\n3. 遇到开括号 `[` 时，将当前构建的字符串入栈，重置字符串。\n4. 遇到闭括号 `]` 时，出栈，形成一个新的字符串并重复生成。\n5. 最终合并所有字符串返回结果。\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []  # 初始化栈\n        current_num = 0  # 当前数字\n        current_str = ''  # 当前构建的字符串\n\n        for char in s:\n            if char.isdigit():  # 如果是数字\n                current_num = current_num * 10 + int(char)  # 处理多位数\n            elif char == '[':  # 遇到左括号\n                stack.append(current_str)  # 存储当前字符串\n                stack.append(current_num)  # 存储当前数字\n                current_str = ''  # 重置字符串\n                current_num = 0  # 重置数字\n            elif char == ']':  # 遇到右括号\n                num = stack.pop()  # 弹出数字\n                prev_str = stack.pop()  # 弹出前一个字符串\n                current_str = prev_str + current_str * num  # 生成新的字符串\n            else:\n                current_str += char  # 累加字符\n\n        return current_str  # 返回解码后的字符串\n```\n时间复杂度是 O(n)，其中 n 是字符串 s 的长度。每个字符都被处理一次。\n空间复杂度是 O(n)，在最坏情况下，栈可能会存储所有字符和数字。\n\n---\n读了题解发现还存在递归法，也就是用[]来决定递归的开头和结束\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        def dfs(s,i):\n            res,multi='',0\n            while i<len(s):\n                if '0'<=s[i]<='9':\n                    multi=multi*10+int(s[i])\n                elif s[i]=='[':\n                    i+=1\n                    sub, i = dfs(s, i)  # 递归调用\n                    res+=multi*sub\n                    multi=0\n                elif s[i]==']':\n                    return res, i+1\n                else:\n                    res+=s[i]\n                i+=1\n            return res, i   \n\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        def dfs(s, i):\n            res, multi = \"\", 0\n            while i < len(s):\n                if '0' <= s[i] <= '9':\n                    multi = multi * 10 + int(s[i])\n                elif s[i] == '[':\n                    i, tmp = dfs(s, i + 1)\n                    res += multi * tmp\n                    multi = 0\n                elif s[i] == ']':\n                    return i, res\n                else:\n                    res += s[i]\n                i += 1\n            return res\n        return dfs(s,0)\n```\n时间复杂度是 O(n)，其中 n 是字符串 s 的长度。每个字符都被处理一次。\n空间复杂度是 O(n)，在最坏情况下，递归调用栈可能会存储所有字符和数字。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/8#issuecomment-3091499578","body":"用两个模拟栈的队列来实现栈的基本操作。一个用于添加尾部元素，另一个用于弹出头部元素。即一个近栈stack in和一个出栈stack out。\n```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        in主要负责push，out主要负责pop\n        \"\"\"\n        self.stack_in = []\n        self.stack_out = []\n\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        有新元素进来，就往in里面push\n        \"\"\"\n        self.stack_in.append(x)\n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if self.empty():\n            return None\n        \n        if self.stack_out:\n            return self.stack_out.pop()\n        else:\n            for i in range(len(self.stack_in)):\n                self.stack_out.append(self.stack_in.pop())\n            return self.stack_out.pop()\n\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        ans = self.pop()\n        self.stack_out.append(ans)\n        return ans\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        只要in或者out有元素，说明队列不为空\n        \"\"\"\n        return not (self.stack_in or self.stack_out)\n```\n时间复杂度：\n- `push` 操作的时间复杂度是 O(1)，因为我们只是将元素添加到 `stack_in` 的末尾。\n- `pop` 和 `peek` 操作的平均时间复杂度是 O(1)，但在最坏情况下（当 `stack_out` 为空时），需要将 `stack_in` 中的所有元素转移到 `stack_out`，这需要 O(n) 的时间，其中 n 是 `stack_in` 中的元素数量。然而，这种情况不会频繁发生，因此平均时间复杂度仍然是 O(1)。\n- `empty` 操作的时间复杂度是 O(1)，因为我们只是检查两个栈是否为空。\n\n空间复杂度是 O(n)，其中 n 是队列中的元素数量，因为我们需要存储所有元素在两个栈中。\n\n但是我有个问题，不知道为什么用lc自己的time complexity分析出来是O(n)的时间和空间复杂度，可能是因为lc的分析是基于最坏情况的分析？","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/9#issuecomment-3094285074","body":"题目的核心是找到最多的分块数量，使得将每个块独立排序后，拼接起来的结果与整个数组排序后的结果相同。\n\n第一个想法是利用排序后的性质。一个块可以被成功分割的条件是：块内所有元素的原数组最大值，小于等于它右边所有元素的最小值。如果满足这个条件，那么这个块排序后，所有元素就都会在它们最终应该在的位置的左边。\n\n为了实现这个想法，我们可以预处理两个数组：\n\n- max_of_left[i]：表示原数组 arr[0...i] 中的最大值。\n- min_of_right[i]：表示原数组 arr[i...n-1] 中的最小值。\n\n然后遍历数组，如果在 i 位置，满足 max_of_left[i] <= min_of_right[i+1]，就说明我们可以在 i 和 i+1 之间切一刀。\n```python\nfrom typing import List\n\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        n = len(arr)\n        if n <= 1:\n            return 1\n\n        # 1. 计算从左到右每个位置的最大值\n        max_of_left = [0] * n\n        max_of_left[0] = arr[0]\n        for i in range(1, n):\n            max_of_left[i] = max(max_of_left[i-1], arr[i])\n\n        # 2. 计算从右到左每个位置的最小值\n        min_of_right = [0] * n\n        min_of_right[n-1] = arr[n-1]\n        for i in range(n-2, -1, -1):\n            min_of_right[i] = min(min_of_right[i+1], arr[i])\n\n        # 3. 遍历查找可以分割的点\n        # 如果 max_of_left[i] <= min_of_right[i+1]，说明 arr[0...i] 的所有元素\n        # 都小于等于 arr[i+1...n-1] 的所有元素，可以切分\n        chunks = 0\n        for i in range(n - 1):\n            if max_of_left[i] <= min_of_right[i+1]:\n                chunks += 1\n\n        # 总块数 = 分割点数量 + 1\n        return chunks + 1\n```\n时间复杂度：O(N)，其中 N 是数组的长度。我们需要三次独立的 O(N) 遍历。\n空间复杂度：O(N)，用于存储 max_of_left 和 min_of_right 两个辅助数组。\n\n---\n在看题解的时候，发现了一个更巧妙的解法，虽然时间复杂度稍高，但是代码非常简洁。它的思路是比较原数组和排序后数组的元素和。\n\n如果 arr[0...i] 的元素和等于 sorted_arr[0...i] 的元素和，这意味着 arr[0...i] 中的元素集合和 sorted_arr[0...i] 中的元素集合是完全相同的（只是顺序不同）。因为 sorted_arr[0...i] 包含了整个数组中最小的 i+1 个元素，所以 arr[0...i] 也必然包含了这 i+1 个最小元素。这就保证了 arr[0...i] 中的任意元素都小于等于 arr[i+1...n-1] 中的任意元素，因此可以在 i 处进行分割。\n```python\nfrom typing import List\n\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        sorted_arr = sorted(arr)\n        \n        sum_arr = 0\n        sum_sorted = 0\n        chunks = 0\n        \n        for i in range(len(arr)):\n            sum_arr += arr[i]\n            sum_sorted += sorted_arr[i]\n            \n            if sum_arr == sum_sorted:\n                chunks += 1\n                \n        return chunks\n```\n时间复杂度：O(N log N)，瓶颈在于对数组的排序。\n\n空间复杂度：O(N)，用于存储排序后的数组副本。\n\n还有一个基于单调栈的解法，时间复杂度可以做到 O(N)。\n\n思路是遍历数组，用一个栈来维护每个块的最大值。\n\n1. 如果当前元素 num 大于或等于栈顶元素，说明 num 可以自己形成一个新的块（或者加入前一个块且不影响排序性），直接将 num 入栈。\n2. 如果当前元素 num 小于栈顶元素，说明 num 必须和前面的块合并，直到栈顶元素小于或等于 num。在合并过程中，需要记录被弹出的那些块中的最大值 head，因为这个 head 将成为合并后新块的最大值，然后将 head 入栈。\n\n最终栈的大小就是块的数量。\n```python\nfrom typing import List\n\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for num in arr:\n            if not stack or num >= stack[-1]:\n                stack.append(num)\n            else:\n                # 当前元素num比栈顶小，需要合并\n                head = stack.pop()\n                # 持续弹出所有大于num的元素\n                while stack and stack[-1] > num:\n                    stack.pop()\n                # 将原先这些块的最大值head作为新块的代表入栈\n                stack.append(head)\n        return len(stack)\n```\n\n时间复杂度：O(N)，因为每个元素最多入栈和出栈一次。\n\n空间复杂度：O(N)，在最坏的情况下（例如数组本身有序），栈的大小会等于数组长度。\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/13#issuecomment-3112533354","body":"双指针\n1. 创建两个指针 pA 和 pB，分别指向两个链表的头节点 headA 和 headB。\n2. 同时向前移动这两个指针，pA 每次走一步，pB 每次也走一步。\n3. 核心操作：如果 pA 指针走到了链表 A 的末尾（即 pA 变为 None），则将它重定向到链表 B 的头节点 headB。同样，如果 pB 指针走到了链表 B 的末尾，则将它重定向到链表 A 的头节点 headA。\n4. 两个指针最终会在相交点相遇。如果两个链表不相交，它们会同时在路径的最后变为 None，此时循环结束。\n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        if not headA or not headB:\n            return None\n\n        pA = headA\n        pB = headB\n\n        # 当 pA 和 pB 相等时循环终止（可能是在交点，也可能同为 None）\n        while pA is not pB:\n            # 如果pA走到头，就让他从headB开始走；否则，pA正常往下走\n            pA = headB if pA is None else pA.next\n            # 如果pB走到头，就让他从headA开始走；否则，pB正常往下走\n            pB = headA if pB is None else pB.next\n            \n        # 返回相遇点\n        return pA\n```\n时间复杂度：O(m+n)。在最坏的情况下（例如，两个链表不相交），每个指针都需要遍历两个链表的总长度。\n空间复杂度：O(1)。只使用了两个额外的指针，没有使用其他数据结构。","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/15#issuecomment-3121201700","body":"为了实现一个支持 O(1) 时间复杂度的查找插入和删除，可以用hash map去记录key和value之间的映射关系。但是hash map是无序的，没有办法记录各项的使用顺序，可以一个双向链表来记录使用顺序。这样就可以在插入和删除的时候，快速地调整链表的顺序。\n\n```python\nclass DLinkedNode:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache = dict()\n        self.capacity = capacity\n        # 使用伪头部和伪尾部节点，简化边界条件处理\n        self.head = DLinkedNode()\n        self.tail = DLinkedNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def _add_to_head(self, node: DLinkedNode):\n        # 将节点添加到头部\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n\n    def _remove_node(self, node: DLinkedNode):\n        # 从链表中删除一个节点\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def _move_to_head(self, node: DLinkedNode):\n        # 将一个存在的节点移动到头部\n        self._remove_node(node)\n        self._add_to_head(node)\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        \n        node = self.cache[key]\n        # 访问过后，变为最近使用，移动到头部\n        self._move_to_head(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            # 如果 key 存在，更新值并移动到头部\n            node = self.cache[key]\n            node.value = value\n            self._move_to_head(node)\n        else:\n            # 如果 key 不存在\n            if len(self.cache) == self.capacity:\n                # 缓存已满，淘汰最久未使用的节点（尾部节点）\n                removed_node = self.tail.prev\n                self._remove_node(removed_node)\n                # 不要忘了从哈希表中也删除\n                del self.cache[removed_node.key]\n\n            # 创建新节点并添加到头部\n            new_node = DLinkedNode(key, value)\n            self._add_to_head(new_node)\n            self.cache[key] = new_node\n```\n时间复杂度：get 和 put 操作都是 O(1)。所有操作都是哈希表查找和链表头尾操作的组合。\n空间复杂度：O(capacity)，因为哈希表和双向链表最多存储 capacity 个元素。","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/18#issuecomment-3132881592","body":"DFS - 递归\n这道题的结构天然适合使用递归来解决。我们可以定义一个函数，该函数接收一个节点和从根到该节点父节点所构成的数字。\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nfrom typing import Optional\n\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        \n        def dfs(node: Optional[TreeNode], current_path_sum: int) -> int:\n            if not node:\n                return 0\n            \n            # 计算到达当前节点的路径代表的数字\n            new_sum = current_path_sum * 10 + node.val\n            \n            # 如果是叶子节点，返回当前路径的数字\n            if not node.left and not node.right:\n                return new_sum\n            \n            # 如果不是叶子节点，返回左右子树的路径数字之和\n            else:\n                return dfs(node.left, new_sum) + dfs(node.right, new_sum)\n\n        return dfs(root, 0)\n```\n时间复杂度：O(N)，其中 N 是树中节点的数量。我们需要访问每个节点一次。\n空间复杂度：O(H)，其中 H 是树的高度。这部分空间用于递归调用栈。在最坏的情况下（树退化成链表），空间复杂度为 O(N)；在最好的情况下（完全二叉树），空间复杂度为 O(log N)。\n\n---\n\nDFS - 迭代\n> 递归可能导致的栈溢出问题（在树极深的情况下），我们可以将递归转换为迭代\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nfrom typing import Optional\n\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n            \n        total_sum = 0\n        stack = [(root, root.val)]  # 栈中存储 (节点, 到达该节点的路径数值)\n\n        while stack:\n            node, current_number = stack.pop()\n\n            # 如果是叶子节点，将路径数值加入总和\n            if not node.left and not node.right:\n                total_sum += current_number\n\n            # 将右子节点压栈\n            if node.right:\n                stack.append((node.right, current_number * 10 + node.right.val))\n            \n            # 将左子节点压栈\n            if node.left:\n                stack.append((node.left, current_number * 10 + node.left.val))\n        \n        return total_sum\n```\n时间复杂度：O(N)，每个节点入栈和出栈一次。\n空间复杂度：O(H)，栈在最坏情况下存储 H 个节点，H 是树的高度。与递归版本类似，最好情况 O(log N)，最坏情况 O(N)。\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/19#issuecomment-3134942374","body":"因为题目中提到了**行**，我们可以用bfs一行一行地处理树的节点\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nfrom typing import Optional\nimport collections\n\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        \n        queue = collections.deque([root])\n        bottom_left_val = 0\n        \n        while queue:\n            # 当前层的节点数量\n            level_size = len(queue)\n            \n            # 每一层的第一个节点就是该层的最左侧节点\n            # 我们只需要记录它，然后继续遍历\n            bottom_left_val = queue[0].val\n            \n            # 遍历当前层的所有节点\n            for _ in range(level_size):\n                node = queue.popleft()\n                \n                # 将下一层的节点加入队列\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n                    \n        return bottom_left_val\n```\n时间复杂度：O(N)，其中 N 是树中节点的总数。因为每个节点都会入队和出队一次。\n空间复杂度：O(W)，其中 W 是树的最大宽度。在最坏的情况下（一个完整的二叉树），队列的大小可以达到 N/2。\n\n---\n当然dfs也是可以做的，要记录目前为止发现的最深层级max_depth和最深层级最左边节点的值result_val，先左后右地进行递归\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nfrom typing import Optional\n\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        self.max_depth = -1  # 记录最大深度，初始化为-1\n        self.result_val = 0  # 记录结果值\n        \n        def dfs(node: Optional[TreeNode], current_depth: int):\n            if not node:\n                return\n            \n            # 如果当前深度大于已记录的最大深度\n            # 说明我们第一次到达这个新深度，且由于先序遍历的顺序，这一定是该层最左的节点\n            if current_depth > self.max_depth:\n                self.max_depth = current_depth\n                self.result_val = node.val\n            \n            # 必须先遍历左子树，再遍历右子树\n            dfs(node.left, current_depth + 1)\n            dfs(node.right, current_depth + 1)\n            \n        dfs(root, 0)\n        return self.result_val\n```\n时间复杂度：O(N)，因为我们仍然需要访问树中的每一个节点。\n空间复杂度：O(H)，其中 H 是树的高度。这部分空间是递归调用栈所占用的。最坏情况下，树呈链状，空间复杂度为 O(N)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/20#issuecomment-3146236433","body":"```python\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        res = []\n        def dfs(node):\n            if not node:\n                res.append(\"null\")\n                return\n            res.append(str(node.val))\n            dfs(node.left)\n            dfs(node.right)\n        \n        dfs(root)\n        return \",\".join(res)\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        if not data:\n            return None\n            \n        # 使用列表模拟一个队列，方便 pop(0)\n        node_list = data.split(',')\n        \n        def build_tree():\n            val = node_list.pop(0)\n            if val == \"null\":\n                return None\n            \n            node = TreeNode(int(val))\n            node.left = build_tree()\n            node.right = build_tree()\n            return node\n            \n        return build_tree()\n```\n复杂度 空间和时间都是 O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/21#issuecomment-3141867802","body":"坐标记录 + 排序\n为每一个节点确定其坐标 (row, col)，并记录下 (row, col, val) 这个三元组。最后BFS即可(DFS应该也行)\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nfrom typing import List, Optional\nimport collections\n\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        if not root:\n            return []\n            \n        # 1. 遍历与记录\n        # 使用 BFS 遍历树，记录每个节点的 (col, row, val)\n        nodes_info = []\n        queue = collections.deque([(root, 0, 0)]) # (node, row, col)\n        \n        while queue:\n            node, row, col = queue.popleft()\n            nodes_info.append((col, row, node.val))\n            \n            if node.left:\n                queue.append((node.left, row + 1, col - 1))\n            if node.right:\n                queue.append((node.right, row + 1, col + 1))\n        \n        # 2. 排序\n        # 对记录下来的节点信息进行排序\n        # Python 的元组排序默认按元素顺序比较，完美符合题目要求\n        nodes_info.sort()\n        \n        # 3. 分组\n        # 将排序后的结果按列分组\n        result_map = collections.OrderedDict()\n        for col, row, val in nodes_info:\n            if col not in result_map:\n                result_map[col] = []\n            result_map[col].append(val)\n            \n        return list(result_map.values())\n```\n时间复杂度：O(N log N)。\nBFS 遍历需要 O(N) 的时间，其中 N 是节点数。nodes_info.sort() 是整个算法的瓶颈，对 N 个元素排序需要 O(N log N) 的时间。最后的分组步骤需要 O(N) 的时间。\n因此，总时间复杂度为 O(N log N)。\n\n空间复杂度：O(N)。\nBFS 的队列在最坏情况下需要存储 O(W) 个节点，W 是树的最大宽度。nodes_info 列表需要存储所有 N 个节点的信息，因此需要 O(N) 的空间。result_map 也需要 O(N) 的空间来存储所有节点的值。\n因此，总空间复杂度为 O(N)。\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/22#issuecomment-3146235205","body":"```python\nfrom typing import List, Set\n\nclass Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        # 使用列表来模拟dp数组，每个元素是一个哈希集合\n        dp: List[Set[str]] = [set() for _ in range(n + 1)]\n        \n        # 基础情况：0对括号只有一种组合，即空字符串\n        dp[0].add(\"\")\n        \n        # 从1对括号开始，迭代到n对\n        for i in range(1, n + 1):\n            # 遍历所有可能的分割点 j\n            for j in range(i):\n                # A 部分有 j 对括号，B 部分有 i-1-j 对\n                list_p = dp[j]\n                list_q = dp[i - 1 - j]\n                \n                # 组合 p 和 q\n                for p in list_p:\n                    for q in list_q:\n                        # 使用哈希集合 dp[i] 自动去重\n                        dp[i].add(f\"({p}){q}\")\n                        \n        return list(dp[n])\n```\n复杂度好像有点难算 看看大家有没有什么想法 我再算一算","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/23#issuecomment-3147359265","body":"首先想到的是26字母那道题一样开一个数组然后建一个数组索引转换hash map去做 但是我不清楚是不是升序 所以要用min和max 那这样的效果肯定很差 内存会超 结果没想到居然能过\n```python\nfrom typing import List\n\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        if not nums:\n            return []\n        \n        # -----------------------------------------------------------------\n        # 步骤 1: 使用“数组哈希”（直接寻址法）统计频率\n        # -----------------------------------------------------------------\n        \n        # a. 找到数值范围以确定数组大小\n        min_val = min(nums)\n        max_val = max(nums)\n        \n        # b. 定义偏移量，将所有数值映射到数组的非负索引\n        offset = -min_val\n        \n        # c. 创建计数数组\n        count_array_size = max_val - min_val + 1\n        count_array = [0] * count_array_size\n        \n        # d. 遍历原数组，完成计数\n        for num in nums:\n            # 将 num 通过偏移量映射到数组索引\n            index = num + offset\n            count_array[index] += 1\n\n        # -----------------------------------------------------------------\n        # 步骤 2: 使用桶排序来找到前 K 个高频元素\n        # -----------------------------------------------------------------\n\n        # a. 创建桶，桶的索引代表频率\n        # 桶的数量是 len(nums) + 1，因为一个元素的频率不可能超过总数\n        buckets = [[] for _ in range(len(nums) + 1)]\n\n        # b. 遍历计数数组，将元素放入对应频率的桶中\n        for i in range(count_array_size):\n            freq = count_array[i]\n            if freq > 0:\n                # 将索引 i 转换回原始数字\n                num = i - offset\n                buckets[freq].append(num)\n\n        # -----------------------------------------------------------------\n        # 步骤 3: 从后往前收集结果\n        # -----------------------------------------------------------------\n        \n        result = []\n        # 从最高频率的桶开始遍历\n        for i in range(len(buckets) - 1, 0, -1):\n            # 如果当前频率的桶中有元素\n            if buckets[i]:\n                # 将这个桶里的所有元素加入结果集\n                result.extend(buckets[i])\n            \n            # 如果结果集大小已经足够，可以提前退出\n            if len(result) >= k:\n                break\n        \n        # 返回前 k 个元素，如果最后一个桶加入了多余元素，用切片保证只返回k个\n        return result[:k]\n```\n---\n然后我想到遍历数组 建一个hash map(元素，频率) 然后按频率降序排序提出来前k个\n```python\nimport collections\nfrom typing import List\n\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        # 1. 使用 collections.Counter 快速统计频率，O(N)\n        freq_map = collections.Counter(nums)\n        \n        # 2. 对哈希表按值（频率）进行排序\n        # sorted 函数的时间复杂度是 O(M log M)，其中 M 是不同元素的数量\n        # M <= N，所以最坏是 O(N log N)\n        sorted_items = sorted(freq_map.items(), key=lambda item: item[1], reverse=True)\n        \n        # 3. 提取前 k 个元素\n        result = [item[0] for item in sorted_items[:k]]\n        \n        return result\n```\n空间复杂度：O(N)\n时间复杂度：O(NlogN)。其中 N 是数组 nums 的长度。瓶颈在于排序那一步，即使只有 M 个独立元素，在最坏情况下 M 可能等于 N。这个复杂度不满足题目进阶要求。\n\n---\n可以看到关键问题在于排序，想办法避免排序 我就可以用最小堆来做\n维护一个最小的heapq 按频率存入 如果堆的大小超过k了就把频率最低的pop out就行\n```python\nimport collections\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        # 1. 统计频率，O(N)\n        freq_map = collections.Counter(nums)\n        \n        # 2. 维护一个大小为 k 的最小堆，O(M log k)，M是不同元素的数量\n        min_heap = []\n        for num, freq in freq_map.items():\n            # Python的heapq是最小堆，所以我们存入(频率, 数字)\n            # 这样堆会根据频率排序\n            heapq.heappush(min_heap, (freq, num))\n            if len(min_heap) > k:\n                heapq.heappop(min_heap) # pop out频率最小的元素\n        \n        # 3. 提取结果\n        # 此时堆中的k个元素就是频率最高的k个\n        result = [item[1] for item in min_heap]\n        return result\n```\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/25#issuecomment-3156822202","body":"双指针滑动窗口\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        # 哈希表存储 {字符: 最后出现的位置索引}\n        char_map = {}\n        max_len = 0\n        left = 0 # 窗口的左边界\n        \n        # right 是窗口的右边界，不断向右移动\n        for right in range(len(s)):\n            char = s[right]\n            \n            # 如果当前字符已经存在于哈希表中，并且其位置在当前窗口内\n            if char in char_map and char_map[char] >= left:\n                # 遇到重复字符，收缩窗口\n                # 将左边界移动到重复字符上一次出现位置的下一个位置\n                left = char_map[char] + 1\n            \n            # 更新字符的最新位置\n            char_map[char] = right\n            \n            # 更新最大长度\n            current_len = right - left + 1\n            max_len = max(max_len, current_len)\n            \n        return max_len\n```\n时间复杂度：O(N)。left 和 right 两个指针都只会从头到尾遍历字符串一次，每个字符最多被访问两次。\n\n空间复杂度：O(k)，其中 k 是字符串中不同字符的数量。在最坏的情况下（所有字符都不同），空间复杂度为 O(N)。如果字符集有限（例如 ASCII 码共 128 个），则空间复杂度为常数 O(128)。","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/26#issuecomment-3156831483","body":"这道题和上一题的区别一个是子字符串(3)一个是子序列(30)\n解法还是双指针滑动窗口 只不过需要改造一下，现在要独立扫描word_len 次\n即\n>第一次扫描：从索引 0 开始，窗口每次移动 word_len，检查的子串是 s[0...], s[word_len...], s[2*word_len...] ...\n第二次扫描：从索引 1 开始，窗口每次移动 word_len，检查的子串是 s[1...], s[1+word_len...], s[1+2*word_len...] ...\n\n```python\nimport collections\nfrom typing import List\n\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        if not s or not words:\n            return []\n\n        word_len = len(words[0])\n        num_words = len(words)\n        total_len = word_len * num_words\n        words_freq = collections.Counter(words)\n        result = []\n\n        # 我们需要进行 word_len 次扫描\n        for i in range(word_len):\n            left = i  # 当前扫描的窗口左边界\n            seen = collections.Counter() # 当前窗口内单词的频率\n            count = 0 # 当前窗口内有效单词的数量\n\n            # 窗口右边界以 word_len 为步长滑动\n            for j in range(i, len(s) - word_len + 1, word_len):\n                word = s[j : j + word_len]\n                \n                if word in words_freq:\n                    seen[word] += 1\n                    count += 1\n                    \n                    # 如果一个单词的数量超了，就从左边收缩窗口\n                    while seen[word] > words_freq[word]:\n                        left_word = s[left : left + word_len]\n                        seen[left_word] -= 1\n                        count -= 1\n                        left += word_len\n                    \n                    # 如果窗口内单词数量正好，说明找到了一个解\n                    if count == num_words:\n                        result.append(left)\n                        # 为了继续搜索，将窗口最左边的单词移出\n                        left_word = s[left : left + word_len]\n                        seen[left_word] -= 1\n                        count -= 1\n                        left += word_len\n\n                else:\n                    # 如果遇到的单词不在 words 列表中，则当前窗口作废\n                    # 直接将左边界移动到这个坏单词的后面\n                    seen.clear()\n                    count = 0\n                    left = j + word_len\n        \n        return result\n```\n时间复杂度O(N),N是字符串s的长度\n空间复杂度O(ML)，M是words列表里的单词数量 L是每个单词长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/27#issuecomment-3161453831","body":"```python\nfrom typing import List\n\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        n = len(nums)\n        # 1. 同余定理：计算目标余数\n        target_rem = sum(nums) % p\n        \n        # 如果总和已经能被 p 整除，无需移除\n        if target_rem == 0:\n            return 0\n        \n        # 2. 哈希表：存储 {余数: 最后一次出现的索引}\n        # 初始化 {0: -1} 来处理从开头开始的子数组\n        rem_map = {0: -1}\n        min_len = n  # 初始化为一个最大值\n        \n        # 3. 前缀和：用一个变量 current_sum 动态计算\n        current_sum = 0\n        \n        for i, num in enumerate(nums):\n            current_sum += num\n            current_rem = current_sum % p\n            \n            # 计算需要寻找的配对余数\n            needed_rem = (current_rem - target_rem + p) % p\n            \n            # 如果找到了配对\n            if needed_rem in rem_map:\n                prev_index = rem_map[needed_rem]\n                # 更新最短长度\n                min_len = min(min_len, i - prev_index)\n            \n            # 更新当前余数的最新索引\n            rem_map[current_rem] = i\n            \n        # 如果 min_len 没有被更新过，或者更新后的值等于n（意味着要移除整个数组）\n        # 则说明找不到合适的“真”子数组\n        return min_len if min_len < n else -1\n```\n时间复杂度：O(N)，因为我们只遍历了数组一次。\n空间复杂度：O(min(N,p))，因为哈希表中最多存储 p 个不同的余数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/28#issuecomment-3169922808","body":"双指针\n```python\nfrom typing import Optional\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # 初始化快慢指针\n        slow = head\n        fast = head\n        \n        # 当快指针没有走到链表末尾时\n        while fast and fast.next:\n            # 慢指针走一步\n            slow = slow.next\n            # 快指针走两步\n            fast = fast.next.next\n            \n        # 当循环结束时，慢指针正好在中间位置\n        return slow\n```\n时间复杂度：O(N)。虽然有两个指针，但我们只对链表进行了一次单向遍历。\n空间复杂度：O(1)。只使用了两个额外的指针变量，没有使用额外的存储空间。","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/29#issuecomment-3169886502","body":"双指针/快慢指针\n快的去遍历 慢的维护只出现一次的元素\n```python\nfrom typing import List\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        # 如果数组为空，直接返回 0\n        if not nums:\n            return 0\n        \n        # slow 指针指向下一个将要被赋值的、新的不重复元素的位置。\n        # nums[0] 默认是第一个不重复的元素，所以 slow 从 1 开始。\n        slow = 1\n        \n        # fast 指针从第二个元素开始，遍历整个数组\n        for fast in range(1, len(nums)):\n            if nums[fast] != nums[fast - 1]:\n                nums[slow] = nums[fast]\n                slow += 1\n        \n        return slow","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/31#issuecomment-3173197055","body":"我们可以用单调队列（双端队列 (deque)）来维护窗口内的“候选最大值”，使得获取当前最大值的操作是 O(1) 的\n>双端队列 (deque)\n队列中存储的是数组元素的索引，而不是元素本身。\n队列中的索引所对应的 nums 数组中的值，是从头到尾单调递减的。\n```python\nimport collections\nfrom typing import List\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        if n * k == 0:\n            return []\n        \n        # 单调队列，存储的是元素的索引\n        # 队列中的索引对应的 nums 值是单调递减的\n        deque = collections.deque()\n        result = []\n\n        for i in range(n):\n            # 1. 维护单调性：移除队尾所有小于当前值的元素\n            while deque and nums[deque[-1]] <= nums[i]:\n                deque.pop()\n            \n            # 2. 当前元素索引入队\n            deque.append(i)\n            \n            # 3. 维护窗口大小：移除已经滑出窗口的队头元素\n            if deque[0] <= i - k:\n                deque.popleft()\n            \n            # 4. 记录结果：当窗口完全形成后开始记录\n            if i >= k - 1:\n                # 队头元素永远是当前窗口的最大值\n                result.append(nums[deque[0]])\n                \n        return result\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/32#issuecomment-3187054447","body":"```python\nfrom typing import List\n\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        # 使用一个数组记录每个人的信任差额\n        trust_scores = [0] * (n + 1)\n        \n        for a, b in trust:\n            trust_scores[a] -= 1  # 信任别人，分数-1\n            trust_scores[b] += 1  # 被人信任，分数+1\n            \n        # 寻找分数为 n-1 的法官\n        for i in range(1, n + 1):\n            if trust_scores[i] == n - 1:\n                return i\n                \n        return -1\n```\n时间复杂度: O(n + m), m为trust列表长度\n空间复杂度: O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/33#issuecomment-3187045338","body":"这道题的本质是判断一个图是否为二分图 (Bipartite Graph)。\n n 个人看作是图的 n 个节点 (Vertex),每一对 dislike关系 [a, b] 看作是连接节点 a 和 b 的一条无向边 (Edge)。\n判断由人和他们之间的“不喜欢”关系构成的图，是否是一个二分图。\nDFS着色\n```python\nfrom typing import List\n\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        # 1. 构建图的邻接表\n        graph = [[] for _ in range(n + 1)]\n        for u, v in dislikes:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        # 2. 创建 colors 数组，0:未着色, 1:颜色A, -1:颜色B\n        colors = [0] * (n + 1)\n        \n        # 3. 遍历所有节点\n        for i in range(1, n + 1):\n            # 如果节点未被着色，从它开始进行DFS\n            if colors[i] == 0:\n                if not self.dfs(i, 1, colors, graph):\n                    return False\n        \n        return True\n\n    def dfs(self, node: int, color: int, colors: List[int], graph: List[List[int]]) -> bool:\n        # 给当前节点染色\n        colors[node] = color\n        \n        # 遍历所有邻居\n        for neighbor in graph[node]:\n            # 如果邻居颜色与当前节点相同，产生冲突\n            if colors[neighbor] == color:\n                return False\n            # 如果邻居未被染色，对其进行DFS\n            if colors[neighbor] == 0:\n                # 给邻居染上相反的颜色\n                if not self.dfs(neighbor, -color, colors, graph):\n                    return False\n        \n        return True\n```\nBFS着色\n```python\nimport collections\nfrom typing import List\n\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        # 1. 构建图的邻接表\n        graph = [[] for _ in range(n + 1)]\n        for u, v in dislikes:\n            graph[u].append(v)\n            graph[v].append(u)\n            \n        # 2. 创建 colors 数组\n        colors = [0] * (n + 1)\n        \n        # 3. 遍历所有节点\n        for i in range(1, n + 1):\n            if colors[i] == 0: # 未被染色，开始BFS\n                queue = collections.deque([i])\n                colors[i] = 1 # 染上颜色A\n                \n                while queue:\n                    node = queue.popleft()\n                    # 遍历邻居\n                    for neighbor in graph[node]:\n                        # 如果邻居颜色与当前节点相同，冲突\n                        if colors[neighbor] == colors[node]:\n                            return False\n                        # 如果邻居未染色，染上相反颜色并入队\n                        if colors[neighbor] == 0:\n                            colors[neighbor] = -colors[node]\n                            queue.append(neighbor)\n        \n        return True\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/34#issuecomment-3187051602","body":"双层拓扑排序 关键在于排序的规则\n```python\nimport collections\nfrom typing import List\n\nclass Solution:\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\n        \n        # 1. 数据预处理：为没有团队的项目分配新团队ID\n        new_group_id = m\n        for i in range(n):\n            if group[i] == -1:\n                group[i] = new_group_id\n                new_group_id += 1\n        \n        num_groups = new_group_id\n\n        # 2. 构建项目图和团队图及其入度数组\n        item_graph = [[] for _ in range(n)]\n        item_indegree = [0] * n\n        group_graph = [[] for _ in range(num_groups)]\n        group_indegree = [0] * num_groups\n\n        for i in range(n):\n            for prev_item in beforeItems[i]:\n                # 项目图依赖\n                item_graph[prev_item].append(i)\n                item_indegree[i] += 1\n                \n                # 如果属于不同团队，则产生团队图依赖\n                if group[prev_item] != group[i]:\n                    group_graph[group[prev_item]].append(group[i])\n                    group_indegree[group[i]] += 1\n\n        # 3. 通用的拓扑排序函数\n        def topological_sort(graph, indegree):\n            num_nodes = len(graph)\n            queue = collections.deque([i for i in range(num_nodes) if indegree[i] == 0])\n            sorted_order = []\n            while queue:\n                u = queue.popleft()\n                sorted_order.append(u)\n                for v in graph[u]:\n                    indegree[v] -= 1\n                    if indegree[v] == 0:\n                        queue.append(v)\n            \n            return sorted_order if len(sorted_order) == num_nodes else []\n\n        # 4. 执行两次拓扑排序\n        item_order = topological_sort(item_graph, item_indegree)\n        group_order = topological_sort(group_graph, group_indegree)\n\n        if not item_order or not group_order:\n            return []\n\n        # 5. 合并结果\n        # a. 将排好序的项目按团队分组\n        items_by_group = collections.defaultdict(list)\n        for item in item_order:\n            items_by_group[group[item]].append(item)\n        \n        # b. 根据团队顺序，拼接项目\n        final_result = []\n        for group_id in group_order:\n            final_result.extend(items_by_group[group_id])\n            \n        return final_result\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/35#issuecomment-3193081347","body":"模拟\n```python\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        # 初始化坐标\n        x, y = 0, 0\n        \n        # 遍历每一步\n        for move in moves:\n            if move == 'U':\n                y += 1\n            elif move == 'D':\n                y -= 1\n            elif move == 'L':\n                x -= 1\n            elif move == 'R':\n                x += 1\n        \n        # 检查最终位置是否为原点\n        return x == 0 and y == 0\n```\n或者直接看字符串里面是否满足U==D, L==R\n```python\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        # Python 的 count() 方法让这个思路的实现非常简洁\n        # 检查向上和向下的步数是否相等\n        vertical_balance = (moves.count('U') == moves.count('D'))\n        \n        # 检查向左和向右的步数是否相等\n        horizontal_balance = (moves.count('L') == moves.count('R'))\n        \n        return vertical_balance and horizontal_balance\n```\n两个复杂度是一样的\n时间复杂度：O(N)\n空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/36#issuecomment-3193084373","body":"排序 + 最小堆\nmin_heap存放已到达但未执行的任务(processingTime, original_index) 按照时间、索引排序\n```python\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        # 1. 数据预处理：附加原始索引并按入队时间排序\n        # tasks_with_indices 的格式: [[enqueueTime, processingTime, original_index], ...]\n        tasks_with_indices = sorted(\n            [(tasks[i][0], tasks[i][1], i) for i in range(len(tasks))]\n        )\n        \n        result_order = []\n        min_heap = []  # 优先队列，存储 (processingTime, original_index)\n        \n        task_pointer = 0  # 指向下一个要检查的任务\n        current_time = 0  # 当前时间\n        \n        # 当还有任务未处理或未入队时，循环继续\n        while task_pointer < len(tasks) or min_heap:\n            \n            # 如果CPU空闲且没有任务在等待，快进到下一个任务的到达时间\n            if not min_heap and current_time < tasks_with_indices[task_pointer][0]:\n                current_time = tasks_with_indices[task_pointer][0]\n\n            # 2. 将所有已到达的任务加入最小堆\n            while task_pointer < len(tasks) and tasks_with_indices[task_pointer][0] <= current_time:\n                enqueue_time, process_time, original_index = tasks_with_indices[task_pointer]\n                heapq.heappush(min_heap, (process_time, original_index))\n                task_pointer += 1\n            \n            # 3. 从堆中取出最优任务执行\n            if min_heap:\n                process_time, original_index = heapq.heappop(min_heap)\n                current_time += process_time\n                result_order.append(original_index)\n                \n        return result_order\n```\n复杂度：假设N个任务，那么时间复杂度是O(NlogN)有排序造成的,空间是O(N) tasks列表和min_heap都需要O（N）的空间","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gjwang224":[{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/4#issuecomment-3086564307","body":"## Code\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int len = num.size()-1;\n        vector<int> returnNum;\n        int tmp=0;\n        \n        while(k && len>=0){\n            returnNum.push_back((num[len] + k%10 + tmp)%10);\n            tmp = (num[len] + k%10 + tmp)/10;\n            len--;\n            k = k/10;\n        }\n\n        while(k){\n            returnNum.push_back((k%10 + tmp)%10);\n            tmp = (k%10 + tmp)/10;\n            k = k/10;\n        }\n        \n        while(len>=0){\n            returnNum.push_back((num[len] + tmp)%10);\n            tmp = (num[len] + tmp)/10;\n            len--;\n        }\n        \n        if(tmp) returnNum.push_back(tmp);\n        reverse(returnNum.begin(), returnNum.end());\n        return returnNum;\n    }\n};","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/5#issuecomment-3093190969","body":"#### C++\n``` C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> dis, rearr;\n        for(int i = 0; i < s.size(); i++) if(s.at(i) == c) dis.push_back(i);\n        for(int i = 0; i < s.size(); i++){\n            int minn = 1e5+5;\n            for(int j = 0; j < dis.size(); j++){\n                minn = min(minn, abs(i-dis.at(j)));\n            }\n            rearr.push_back(minn);\n        }\n        return rearr;\n    }\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/6#issuecomment-3087031064","body":"### C++ 代码\n``` C++\nclass CustomStack {\npublic:\n    int stack[1005];\n    int size = -1, mS;\n    CustomStack(int maxSize) {\n        mS = maxSize;\n    }\n    \n    void push(int x) {\n        if(size < mS-1){\n            stack[++size] = x;\n        }\n    }\n    \n    int pop() {\n        if(size < 0) return -1;\n        else return stack[size--];\n    }\n    \n    void increment(int k, int val) {\n        for(int i = 0; i < k; i++){\n            stack[i] += val;\n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/7#issuecomment-3086899860","body":"### 思路 \n遍历整个字符串，总共有四种可能，分别是   数字  字母  左括号  右括号\n1. 数字：定义`digit`存储读取到的数字\n2. 字母：可以直接读取累加至`res`\n3. 左括号：需要将前面的`res`和`digit`分别入栈，并将其赋为0和”“\n4. 右括号：读取栈顶元素，循环拼接后，累加至`res`\n### C++ 代码\n``` C++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<int> numStack;\n        stack<string> strStack;\n        int digit=0;\n        string res=\"\";\n\n        for(int i = 0; i < s.size(); i++){\n            if(s.at(i) >= '0' && s.at(i) <= '9'){// 数字\n                digit = digit*10+s.at(i)-'0';\n            } else if(s.at(i) >= 'a' && s.at(i) <= 'z'){// 字符\n                res += s.at(i);\n            } else if(s.at(i) == '['){// 左括号\n                numStack.push(digit);\n                strStack.push(res);\n                res = \"\";\n                digit=0;\n            } else {// 右括号\n                int count = numStack.top();\n                numStack.pop();\n                string outString = strStack.top();\n                strStack.pop();\n                for(int i = 0; i < count; i++) outString += res;\n                res = outString;\n            }\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/8#issuecomment-3092046146","body":"#### 思路\n\n1. `push`和`empty`可以直接进行操作。\n2. `pop`和 `peek`需要得到入栈的第一个元素，可以使用一个辅助栈，对第一个栈进行出栈同时第二个栈进行入栈操作，这样第二个栈`top`得到的元素就是第一个栈入栈的第一个元素。\n\n``` C++\nclass MyQueue {\npublic:\n    stack<int> tmp;\n    stack<int> stack;\n    MyQueue() {\n    }\n    \n    void push(int x) {\n        tmp.push(x);\n    }\n    \n    int pop() {\n        while(!tmp.empty()){\n            stack.push(tmp.top());\n            tmp.pop();\n        }\n        int a = stack.top();\n        stack.pop();\n        while(!stack.empty()){\n            tmp.push(stack.top());\n            stack.pop();\n        }\n        return a;\n    }\n    \n    int peek() {\n        while(!tmp.empty()){\n            stack.push(tmp.top());\n            tmp.pop();\n        }\n        int a = stack.top();\n        while(!stack.empty()){\n            tmp.push(stack.top());\n            stack.pop();\n        }\n        return a;\n    }\n    \n    bool empty() {\n        return tmp.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/9#issuecomment-3094511890","body":"#### 哈希\n\n```c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        unordered_map<int, int> ans;\n        vector<int> tmp = arr;\n        sort(tmp.begin(), tmp.end());\n        int cnt=0;\n        for(int i = 0; i < arr.size(); i++){\n            ans[arr[i]]++;\n            ans[tmp[i]]--;\n            if(ans[arr[i]]==0) ans.erase(arr[i]);\n            if(ans[tmp[i]]==0) ans.erase(tmp[i]);\n            if(ans.empty()) cnt++;\n        }\n        return cnt;\n    }\n};\n```\n时间复杂度 nlog(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/10#issuecomment-3095832085","body":"#### 思路\n\n先将链表变为首尾相连循环链表，然后通过`k`找到断开位置的前一个元素，断开，返回头节点即可。\n\n``` c\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* rotateRight(struct ListNode* head, int k) {\n    if(head==NULL || k==0) return head;\n    int len=1;\n    struct ListNode * p=head;\n    if(p) len=1;\n    while(p->next){\n        len++;\n        p = p->next;\n    }\n    //printf(\"%d\\n\", len);\n    p->next = head;\n    k = k%len;\n    for(int i = 0; i < len-k-1; i++){\n        head = head->next;\n    }\n    p = head->next;\n    head->next = NULL;\n    return p;\n}\n```\n\n时间复杂度O(n)\n\n空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/11#issuecomment-3102195778","body":"#### C代码\n\n``` c\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* swapPairs(struct ListNode* head) {\n    //struct ListNode Node;\n    //Node.next = head;\n    //struct ListNode* tmp = &Node;\n    struct ListNode* Node=(struct ListNode*)malloc(sizeof(struct ListNode));\n    Node->next = head;\n    struct ListNode* tmp = Node;\n    while(tmp->next && tmp->next->next){\n        struct ListNode* first = tmp->next;\n        struct ListNode* second = tmp->next->next;\n        tmp->next = second;\n        first->next = second->next;\n        second->next = first;\n        tmp = first;\n    }\n    return Node->next;\n}\n```\n\n时间复杂度O(n)\n\n空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/12#issuecomment-3106692662","body":"#### C++代码\n\n``` c\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if(head==NULL) return NULL;\n        int n = 0;\n        for(auto p=head; p; p=p->next){\n            n++;\n        }\n        if(n==1) return new TreeNode(head->val);\n        auto cur = head;\n        for(int i = 0; i < n/2-1; i++) cur = cur->next;\n        auto root = new TreeNode(cur->next->val);\n        root->right = sortedListToBST(cur->next->next);\n        cur->next = NULL;\n        root->left = sortedListToBST(head);\n        return root;\n    }\n};\n```\n\n时间复杂度O(nlog(n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/13#issuecomment-3112024319","body":"#### C++代码\n\n``` c\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if(headA==NULL || headB==NULL) return NULL;\n        ListNode *a = headA, *b = headB;\n        while(a!=b){\n            if(a == NULL) a = headB;\n            a = a->next;\n            if(b == NULL) b = headA;\n            b = b->next;\n        }\n        return a;\n    }\n};\n```\n\n时间复杂度O(n+m)\n\n空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/14#issuecomment-3116982615","body":"#### C++代码\n\n``` c\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        unordered_map<ListNode*, int> visit;\n        while(head){\n            visit[head]++;\n            if(visit[head]==2) return head;\n            head=head->next;\n        } \n        return NULL;\n    }\n};\n```\n\n时间复杂度O(n)\n\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/15#issuecomment-3121297965","body":"#### C++代码\n\n- hash表: `unordered_map<int, Node*> hash;`\n- 双向链表用来 将`Node` 根据 使用时间 进行排序。靠近左端表示最近使用，靠近右端表示较长时间没有使用。\n\n``` c\nclass LRUCache {\npublic:\n    struct Node {\n        int key, val;\n        Node *prev, *next;\n        Node(int _key, int _val): key(_key), val(_val), prev(NULL), next(NULL){}\n    }*L, *R; //L头节点  R尾节点\n\n    unordered_map<int, Node*> hash;\n    int n;\n\n    void delete_node(Node *p){\n        p->next->prev = p->prev;\n        p->prev->next = p->next;\n    }\n\n    void insert_node(Node *p){ //链表头插入\n        p->next = L->next;\n        L->next->prev = p;\n        p->prev = L;\n        L->next = p;\n    }\n\n    LRUCache(int capacity) {\n        n = capacity;\n        L = new Node(-1, -1);\n        R = new Node(-1, -1);\n        L->next = R;\n        R->prev = L;\n    }\n    \n    int get(int key) {\n        if(!hash.count(key)) return -1;\n        else{\n            auto p = hash[key];\n            delete_node(p);\n            insert_node(p);\n            return p->val;\n        }\n    }\n    \n    void put(int key, int value) {\n        if(!hash.count(key)){\n            if(hash.size()==n){\n                auto p = R->prev;\n                delete_node(p);\n                hash.erase(p->key);\n            }\n            auto p = new Node(key, value);\n            hash[key] = p;\n            insert_node(p);\n        }else {\n            auto p = hash[key];\n            p->val = value;\n            delete_node(p);\n            insert_node(p);\n        }\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n```\n\n时间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/16#issuecomment-3124142122","body":"#### C++代码\n\n``` c\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root == NULL) return 0;\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\n    }\n};\n```\n\n时间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/17#issuecomment-3125702334","body":"#### C++代码\n\n``` c\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(p==NULL && q==NULL) return true;\n        else if(p==NULL && q!=NULL) return false;\n        else if(p!=NULL && q==NULL) return false;\n        else if(q->val != p->val) return false;\n        else return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\n    }\n};\n```\n\n时间复杂度O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/18#issuecomment-3130752830","body":"#### C++代码\n\n``` c\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int dfs(TreeNode *root, int sum) {\n        if(root == nullptr) return 0;\n        int tmp = sum*10+root->val;\n        if(root->left==nullptr && root->right==nullptr) return tmp;\n        return dfs(root->left, tmp) + dfs(root->right, tmp);\n    }\n    int sumNumbers(TreeNode* root) {\n        return dfs(root, 0);\n    }\n};\n```\n\n时间复杂度O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/19#issuecomment-3135775890","body":"#### C++代码\n\n``` c\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void dfs(TreeNode* root, int height, int &curVal, int &curHeight){\n        if(root==nullptr) return ;\n        height++;\n        dfs(root->left, height, curVal, curHeight);\n        dfs(root->right, height, curVal, curHeight);\n        if (height > curHeight) {\n            curHeight = height;\n            curVal = root->val;\n        }\n    }\n    int findBottomLeftValue(TreeNode* root) {\n        int curVal=0, curHeight=0;\n        dfs(root, 0, curVal, curHeight);\n        return curVal;\n    }\n};\n```\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/20#issuecomment-3139476046","body":"#### C++代码\n\n``` c\nclass Codec {\npublic:\n\n    // Encodes a tree to a single string.\n    void rserialize(TreeNode* root, string& str) {\n        // 前序遍历（中左右，遇到空节点输入None），用逗号隔开\n        if (root == NULL) str += \"None,\";\n        else {\n            str += to_string(root->val) + \",\";\n            rserialize(root->left, str);\n            rserialize(root->right, str);\n        }      \n    }\n    string serialize(TreeNode* root) {\n        string ret;\n        rserialize(root, ret);\n        return ret;\n    }\n\n    // Decodes your encoded data to tree.\n\n    TreeNode* rdeserialize(list<string>& dataArray) {\n        if(dataArray.front() == \"None\") {\n            dataArray.erase(dataArray.begin());\n            return NULL;\n        }\n        // 前序遍历（中左右）恢复树结构\n        TreeNode* root = new TreeNode(stoi(dataArray.front()));\n        dataArray.erase(dataArray.begin());\n        root->left = rdeserialize(dataArray);\n        root->right = rdeserialize(dataArray);\n        return root;\n    }\n\n    TreeNode* deserialize(string data) {\n        list<string> dataArray;\n        string str;\n        // 添加各节点val\n        // 按引用传递，按值传递会增加耗时\n        for (auto& c : data) {\n            if (c == ',') {\n                // 以逗号作为节点分割\n                dataArray.push_back(str);\n                str.clear();\n            } else {\n                str.push_back(c);\n            }\n        }\n        // 添加尾部节点val\n        if (!str.empty()) {\n            dataArray.push_back(str);\n            str.clear();\n        }\n        return rdeserialize(dataArray);\n    }\n};\n\n\n//参考链接：https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/solutions/1536508/by-peaceful-thompsonfsu-8143/\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/21#issuecomment-3144061296","body":"#### C++代码\n\n``` c\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    // 深度优先搜索函数 参数：当前节点、当前行号、当前列号、存储节点信息的map\n    void dfs(TreeNode* node, int row, int col, map<int, vector<pair<int, int>>>& colNodes) {\n        // 若节点为空，直接返回\n        if (node == nullptr) {\n            return;\n        }\n        \n        // 记录当前节点的信息：(行号, 值) 存入对应列的列表中\n        colNodes[col].push_back({row, node->val});\n        \n        // 递归处理左子树：行号+1，列号-1\n        dfs(node->left, row + 1, col - 1, colNodes);\n        \n        // 递归处理右子树：行号+1，列号+1\n        dfs(node->right, row + 1, col + 1, colNodes);\n    }\n\n    // 自定义比较函数：用于对同一列的节点进行排序\n    static bool compareNodes(const pair<int, int>& a, const pair<int, int>& b) {\n        // 若行号相同，按节点值从小到大排序\n        if (a.first == b.first) {\n            return a.second < b.second;\n        }\n        // 否则按行号从小到大排序\n        return a.first < b.first;\n    }\n\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        // 存储列号到节点信息的映射：key=列号，value=该列所有节点的(行号, 值)\n        map<int, vector<pair<int, int>>> colNodes;\n        \n        // 深度优先遍历树，记录每个节点的位置和值\n        dfs(root, 0, 0, colNodes);\n        \n        // 最终结果容器\n        vector<vector<int>> result;\n        \n        // 遍历每一列\n        for (auto& entry : colNodes) {\n            // 对当前列的节点按规则排序（使用自定义比较函数）\n            sort(entry.second.begin(), entry.second.end(), compareNodes);\n            \n            // 提取排序后的节点值，组成当前列的结果\n            vector<int> colValues;\n            for (auto& node : entry.second) {\n                colValues.push_back(node.second); // node.second是节点值\n            }\n            result.push_back(colValues);\n        }\n        \n        return result;\n    }\n};\n\n//参考链接：https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/solutions/3739810/dui-wo-lai-shuo-huan-shi-fu-za-liao-xie-iar46/\n\n```\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/22#issuecomment-3146382948","body":"#### C++代码\n\n``` c\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int,int> hash;\n        for(int i = 0; i < nums.size(); i++){\n            auto iter = hash.find(target-nums[i]);\n            if(iter != hash.end()) return {iter->second, i};\n            hash[nums[i]] = i;\n        }\n        return {};\n    }\n};\n```\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/23#issuecomment-3148379333","body":"#### C++\n\n``` c\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        vector<int> ans;\n        unordered_map<int, int> f;\n        for(int i = 0;i < nums.size();i++) {\n            f[nums[i]]++;\n        }\n        priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > q;\n        for(auto& [num, count] : f) {\n            if(q.size() < k)\n                q.push({count, num});\n            else {\n                if(q.top().first < count) {\n                    q.pop();\n                    q.push({count, num});\n                }\n            }\n        }\n        while(!q.empty()) {\n            //cout<<q.top().first<<\" \"<<q.top().second<<\"\\n\";\n            ans.push_back(q.top().second);\n            q.pop();\n        }\n        return ans;\n    }\n};\n```\n\n时间复杂度：O(nlog(k))\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/24#issuecomment-3150432742","body":"#### C++\n\n``` c\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        int result=0;\n        for(vector<int> P : points){\n            unordered_map<int, int> map;\n            for(vector<int> Q : points){\n                int dis = (P[0]-Q[0])*(P[0]-Q[0])+(P[1]-Q[1])*(P[1]-Q[1]);\n                map[dis]++;\n            }\n            for(auto [a,b] : map){\n                result+=b*(b-1);\n            }\n        }\n        return result;\n    }\n};\n```\n\n时间复杂度：O(n<sup>2</sup>)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/25#issuecomment-3154861022","body":"``` c\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        unordered_map<char, int> dic;\n        int i = -1, res = 0, len = s.size();\n        for(int j = 0; j < len; j++) {\n            if (dic.find(s[j]) != dic.end())\n                i = max(i, dic.find(s[j])->second);\n            dic[s[j]] = j;\n            res = max(res, j - i);\n        }\n        return res;\n    }\n};\n```\n\n时间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/26#issuecomment-3158408178","body":"\n\n``` c\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        unordered_map<string, int> hash;\n        vector<int> res;\n        int n = s.length(), m = words.size();\n        if (n == 0 || m == 0)\n            return res;\n        int len = words[0].length(), end = n - m * len;\n        if (n < m * len)\n            return res;\n        for (auto word : words)\n            hash[word]++;\n        int size = hash.size();\n        for (int k = 0; k < len; k++) {\n            unordered_map<string, int> cur_hash;\n            int satisfy = 0;\n            for (int i = k, j = k; j <= n - len;) {\n                string cur = s.substr(j, len);\n                if (hash.find(cur) == hash.end()) {\n                    j = j + len;\n                    i = j;\n                    cur_hash.clear();\n                    satisfy = 0;\n                } else {\n                    cur_hash[cur]++;\n                    if (cur_hash[cur] == hash[cur])\n                        satisfy++;\n                    else if (cur_hash[cur] > hash[cur]) {\n                        while (i < j && cur_hash[cur] > hash[cur]) {\n                            string temp = s.substr(i, len);\n                            i += len;\n                            cur_hash[temp]--;\n                            if (cur_hash[temp] == hash[temp] - 1)\n                                satisfy--;\n                        }\n                    }\n                    if (satisfy == size) {\n                        string temp = s.substr(i, len);\n                        cur_hash[temp]--;\n                        satisfy--;\n                        res.push_back(i);\n                        i = i + len;\n                    }\n                    j = j + len;\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n\n时间复杂度O(n^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/27#issuecomment-3163210992","body":"\n\n``` c\nclass Solution {\npublic:\n    int minSubarray(vector<int> &nums, int p) {\n        int n = nums.size(), s[n + 1];\n        s[0] = 0;\n        for (int i = 0; i < n; i++)  s[i + 1] = (s[i] + nums[i]) % p;\n        int x = s[n];\n\n        int ans = n;\n        unordered_map<int, int> last;\n        for (int i = 0; i <= n; ++i) {\n            last[s[i]] = i;\n            auto it = last.find((s[i] - x + p) % p);\n            if (it != last.end()) {\n                ans = min(ans, i - it->second);\n            }\n        }\n        return ans < n ? ans : -1;\n    }\n};\n```\n\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/28#issuecomment-3167368429","body":"\n\n``` c\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        int len = 0;\n        ListNode* p = head;\n        while (p != nullptr) {\n            len++;\n            p = p->next;\n        }\n        int k = 0;\n        p = head;\n        while (k < len / 2) {\n            k++;\n            p = p->next;\n        }\n        return p;\n    }\n};\n```\n\n时间复杂度O(n)\n空间复杂度O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/29#issuecomment-3169793378","body":"```c\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        if (nums.empty()) {\n            return 0;\n        }\n        int slow = 0;\n        for (int fast = 1; fast < nums.size(); fast++) {\n            if (nums[fast] != nums[slow]) {\n                slow++;\n                nums[slow] = nums[fast];\n            }\n        }\n        return slow + 1;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/30#issuecomment-3172513759","body":"```c\n\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int n = nums.size();\n        int left = 0, right = n - 1, ans = n;\n        while (left <= right) {\n            int mid = ((right - left) / 2) + left;\n            if (target <= nums[mid]) {\n                ans = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/31#issuecomment-3173606055","body":"```c\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        if(nums.size() == 0 || k == 0) return {};\n        deque<int> deque;\n        vector<int> res(nums.size() - k + 1);\n        for(int j = 0, i = 1 - k; j < nums.size(); i++, j++) {\n            if(i > 0 && deque.front() == nums[i - 1])\n                deque.pop_front();\n            while(!deque.empty() && deque.back() < nums[j])\n                deque.pop_back();\n            deque.push_back(nums[j]);\n            if(i >= 0)\n                res[i] = deque.front();\n        }\n        return res;\n    }\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/32#issuecomment-3178242802","body":"```c\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        vector<int> inDegrees(n + 1);\n        vector<int> outDegrees(n + 1);\n        for (auto& edge : trust) {\n            int x = edge[0], y = edge[1];\n            ++inDegrees[y];\n            ++outDegrees[x];\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (inDegrees[i] == n - 1 && outDegrees[i] == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-16-daily-check/issues/36#issuecomment-3193632408","body":"```c\n\nclass Solution {\npublic:\n    vector<int> getOrder(vector<vector<int>>& tasks) {\n        long now = 0; \n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> >entry, ready;\n        int size = tasks.size();\n\n        for (int i = 0; i < size; ++i){\n            entry.push(make_pair(tasks[i][0], i));\n        }\n\n        vector<int> res;\n        while(!entry.empty() or !ready.empty()){\n            if (ready.empty()){\n                now = entry.top().first;\n                while (!entry.empty() && now == entry.top().first){ \n                    ready.push(make_pair(tasks[entry.top().second][1], entry.top().second));\n                    entry.pop();\n                }\n            }\n            res.emplace_back(ready.top().second);\n            now += ready.top().first;\n            ready.pop();\n\n            while(!entry.empty() && entry.top().first <= now){ \n                ready.push(make_pair(tasks[entry.top().second][1], entry.top().second));\n                entry.pop();\n            }\n        }\n\n        return res;\n    }\n};\n\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}