{"1":[],"2":[],"3":[],"4":[],"5":[],"6":[],"7":[],"8":[],"9":[],"10":[],"11":[],"12":[],"13":[],"14":[],"15":[],"16":[],"17":[],"18":[],"19":[],"20":[],"21":[],"22":[],"23":[],"24":[],"25":[],"26":[],"27":[],"28":[],"29":[],"30":[],"31":[],"32":[],"33":[],"34":[],"35":[],"36":[],"37":[],"38":[],"39":[],"40":[],"41":[],"42":[],"43":[],"44":[],"45":[],"46":[],"47":[],"48":[],"49":[],"50":[],"51":[],"52":[],"53":[],"54":[],"55":[],"56":[],"57":[],"58":[],"59":[],"60":[],"61":[],"62":[],"63":[],"64":[],"65":[],"66":[],"67":[],"68":[],"69":[],"70":[],"71":[],"72":[],"73":[],"74":[],"75":[],"76":[],"77":[],"78":[],"79":[],"80":[],"81":[],"82":[],"83":[],"84":[],"85":[],"86":[],"87":[],"88":[],"89":[],"90":[],"91":[],"839781960":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"954545647":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"1541732340":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"michaelxi3":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"darknightwriter":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"findlayzhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laofuwf":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lbc546":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zch-bit":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"frankelzeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhaodev":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joeymoso":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hackbl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"q815101630":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiyishuoshuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aouos":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"thinkfurther":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wengzhouyunfan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whisht":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bzlff":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzzkains":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenmengyu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uancen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nuomituxedo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhongranherz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gr52":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hydelovegood":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nikojxie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fangxianshen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jokertzw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cyang258":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kernelsue":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erikahuang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kuang-mou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iloveqier":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duke-github":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"caterpillar-0":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ashleyyma6":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuki-yzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zpc7":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yujian920":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kiirii4":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ucashurui":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xixiao51":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"feikerwu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"heng518":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yaya-bb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tlntin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richypang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fenchuiyun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jerry-lllman":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nickyk319":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"herbertpan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wsmmxmm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fan-svg":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuzejia":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunnyyujf":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"phoenixflyingsky":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nehchsuy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lzyxts":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elainekuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ll491119940":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"2learnsomething":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ataraxyadong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wzasd":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miluowzt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maylinglin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weijie-he":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brodxie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"y525":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leungogogo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suukii":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mirrors-cl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqy97":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jakkiabc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyoneday":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chouqin99":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhaogeg111":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnhu23":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ye2222":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uyplayer":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guixian001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"serena9":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"junzmer":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hx-code":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"admu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxiaomm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pgquestions":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eldinzhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiangwenzhe":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnwu6688":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tomtao626":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aiweng1981":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richard-lime":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"acoada":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duanyaqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ccslience":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaiykk":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cachezhou0617":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangtuo1999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cytrue":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyryan-web":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"naomiwufzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuajingliu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miss1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"johnxizhao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"incipe-win":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"revisegoal":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckysq999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dereklisdr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"perfqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mryao1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"likeyousmile":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhg1992":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liquanluo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aq666888":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"samlu-ecnu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhongxiangxiang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hatorimain":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"neado":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaojunjun1110":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wxleah":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunl1ght":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kerrhl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"orangejuz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flyzenr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"c1f2h3":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dlm001128":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuxy94":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aconcert":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linjunhe":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyqqq22":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yibenxiao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elon-lau":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nowkizzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gsgtgyb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"irenia111":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suiyi8760":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"saltychess":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rabbit2010520":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ellie-wu05":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yopming":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckytwj":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzz607":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zoulufeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxoojs":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"okkband":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wyz999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hacker90":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ricjli":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luhaoling":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flaming-cl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gelxgx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gaominghao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jessie725":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lsunxh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lanceli424":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qycoder":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qilin88":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hengheng-yun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"smz1995":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"size-of":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moyuanhua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"9vivian88":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guxuehua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kirosola":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biscuit279":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maoting":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"youzhaing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jawn-ha":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hanwangxxx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dujt-x":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"degndaixingqiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gzgzgzgzgzgz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gentleman-goodman":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xinyi-arch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zenwangzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"andyyxw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fourierhai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yangz001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mannnn6":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"haoyangxie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chjillout":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wenjialu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mhcn":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"coconutice":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jackgaoyuan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhan0312":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yufeng727":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fontendart":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yingchehu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cobayaz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tomato-tomato":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xfliudx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"djd28176":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xilutian":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xy147":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/6#issuecomment-2053574990","body":"### js代码\n```JavaScript\nvar maxChunksToSorted = function (arr) {\n  const stack = [];\n  for (let i = 0; i < arr.length; i++) {\n    a = arr[i];\n    if (stack.length > 0 && stack[stack.length - 1] > a) {\n      const cur = stack[stack.length - 1];\n      while (stack && stack[stack.length - 1] > a) stack.pop();\n      stack.push(cur);\n    } else {\n      stack.push(a);\n    }\n  }\n  return stack.length;\n};\n\n```\n\n### 复杂度分析\n- 时间复杂度: O(N)\n- 空间复杂度: O(N)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/10#issuecomment-2060871609","body":"### js代码\n```JavaScript\nlet getIntersectionNode = (headA,headB)=>{\n    let pA = headA,pB = headB\n    if(pA === null || pB === null){\n        return null\n    }\n    while(pA != pB){\n        pA = pA?pA.next:headB\n        pB = pB?pB.next:headA\n    }\n    return pA\n}\n\n```\n\n### 复杂度分析\n- 时间复杂度: O(N)\n- 空间复杂度: O(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/15#issuecomment-2068436709","body":"### js代码\n```JavaScript\nvar sumNumbers = function (nums) {\n    let dfs = (node,pre)=>{\n        if(!node) return 0\n        const sum = pre * 10 + node.val\n        if(node.left === null && node.right === null){\n            return sum\n        }\n        return dfs(node.left,sum) + dfs(node.right,sum)\n    }\n    return dfs(root,0)\n}\n\n```\n\n### 复杂度分析\n- 时间复杂度: O(N)\n- 空间复杂度: O(H)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/22#issuecomment-2081290690","body":"### js代码\n```JavaScript\nvar numberOfBoomerangs = function(points) {\n    let ans = 0;\n    for (const p of points) {\n        const cnt = new Map();\n        for (const q of points) {\n            const dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n            cnt.set(dis, (cnt.get(dis) || 0) + 1);\n        }\n        for (const [_, m] of cnt.entries()) {\n            ans += m * (m - 1);\n        }\n    }\n    return ans;\n};\n\n```\n\n### 复杂度分析\n时间复杂度：O(n2)\n\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/31#issuecomment-2097862515","body":"### js代码\n```JavaScript\nconst possibleBipartition = (N, dislikes) => {\n  let graph = [...Array(N + 1)].map(() => Array()),\n    colors = Array(N + 1).fill(-1);\n\n  for (const d of dislikes) {\n    graph[d[0]].push(d[1]);\n    graph[d[1]].push(d[0]);\n  }\n\n  const dfs = (cur, color = 0) => {\n    colors[cur] = color;\n    for (const nxt of graph[cur]) {\n      if (colors[nxt] !== -1 && colors[nxt] === color) return false;\n      if (colors[nxt] === -1 && !dfs(nxt, color ^ 1)) return false;\n    }\n    return true;\n  };\n\n  for (let i = 0; i < N; ++i) if (colors[i] === -1 && !dfs(i, 0)) return false;\n\n  return true;\n};\n\n```\n\n### 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n2)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/35#issuecomment-2105628486","body":"### js代码\n```JavaScript\n var numberOfRounds = function(startTime, finishTime) {\n    let m1 = toMinutes(startTime),m2 = toMinutes(finishTime);\n\n    if (m1 > m2) {\n        m2 += 24 * 60;\n    }\n\n    let ans = Math.floor(m2 / 15) - Math.ceil(m1 / 15);\n    return ans < 0 ? 0 : ans;\n};\n\nfunction toMinutes(time) {\n    let [h, m] = time.split(':');\n    return Number(h) * 60 + Number(m);\n}\n\n```\n\n### 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/39#issuecomment-2112027136","body":"\n### js代码\n```JavaScript\nvar solution = function (isBadVersion) {\n  return function (n) {\n    let left = 1;\n    let right = n;\n\n    while (left <= right) {\n      let mid = Math.floor((right + left) / 2);\n\n      if (isBadVersion(mid)) {\n        right = mid - 1;\n      } else {\n        left = mid + 1;\n      }\n    }\n\n    return left;\n  };\n};\n\n```\n\n### 复杂度分析\n时间复杂度：O(logN)\n\n空间复杂度：O(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/44#issuecomment-2119589311","body":"### js代码\n```JavaScript\nvar maxVowels = function (s, k) {\n    const dict = new Set([\"a\", \"e\", \"i\", \"o\", \"u\"]);\n    let ret = 0;\n    for (let i = 0; i < k; i++) {\n      if (dict.has(s[i])) ret++;\n    }\n  \n    let temp = ret;\n    for (let i = k, j = 0; i < s.length; i++, j++) {\n      if (dict.has(s[i])) temp++;\n      if (dict.has(s[j])) temp--;\n  \n      ret = Math.max(temp, ret);\n    }\n  \n    return ret;\n  };\n```\n\n### 复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/50#issuecomment-2132226454","body":"### js代码\n```JavaScript\nvar totalNQueens = function (n) {\n  let res = 0;\n  const dfs = (n, row, col, pie, na) => {\n    if (row >= n) {\n      res++;\n      return;\n    }\n    let bits = ~(col | pie | na) & ((1 << n) - 1);\n    while (bits) {\n      let p = bits & -bits;\n      bits = bits & (bits - 1);\n      dfs(n, row + 1, col | p, (pie | p) << 1, (na | p) >> 1);\n    }\n  };\n  dfs(n, 0, 0, 0, 0);\n  return res;\n};\n```\n\n### 复杂度分析\n时间复杂度：O(n!)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/51#issuecomment-2132519553","body":"### js代码\n```JavaScript\nvar maxAreaOfIsland = function (grid) {\n  let x = grid[0].length,\n    y = grid.length;\n  let res = 0;\n  function dfs(i, j) {\n    if (i >= y || j >= x || j < 0 || i < 0 || grid[i][j] != 1) return 0;\n    grid[i][j] = -1;\n    return 1 + dfs(i + 1, j) + dfs(i - 1, j) + dfs(i, j - 1) + dfs(i, j + 1);\n  }\n  for (let i = 0; i < y; i++) {\n    for (let j = 0; j < x; j++) {\n      if (grid[i][j]) {\n        res = Math.max(res, dfs(i, j));\n      }\n    }\n  }\n  return res;\n};\n```\n\n### 复杂度分析\n时间复杂度：O(m*n)\n空间复杂度：O(m*n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/57#issuecomment-2143806706","body":"### js代码\n```JavaScript\nvar findNumberOfLIS = function(nums) {\n    let n = nums.length, maxLen = 0, ans = 0;\n    const dp = new Array(n).fill(0);\n    const cnt = new Array(n).fill(0);\n    for (let i = 0; i < n; ++i) {\n        dp[i] = 1;\n        cnt[i] = 1;\n        for (let j = 0; j < i; ++j) {\n            if (nums[i] > nums[j]) {\n                if (dp[j] + 1 > dp[i]) {\n                    dp[i] = dp[j] + 1;\n                    cnt[i] = cnt[j]; // 重置计数\n                } else if (dp[j] + 1 === dp[i]) {\n                    cnt[i] += cnt[j];\n                }\n            }\n        }\n        if (dp[i] > maxLen) {\n            maxLen = dp[i];\n            ans = cnt[i]; // 重置计数\n        } else if (dp[i] === maxLen) {\n            ans += cnt[i];\n        }\n    }\n    return ans;\n};\n```\n\n### 复杂度分析\n时间复杂度：O(n2)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/58#issuecomment-2144219503","body":"### js代码\n```JavaScript\nvar longestCommonSubsequence = function(text1, text2) {\n    const m = text1.length, n = text2.length;\n    const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));\n    for (let i = 1; i <= m; i++) {\n        const c1 = text1[i - 1];\n        for (let j = 1; j <= n; j++) {\n            const c2 = text2[j - 1];\n            if (c1 === c2) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[m][n];\n};\n```\n\n### 复杂度分析\n时间复杂度：O(m*n)\n空间复杂度：O(m*n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/59#issuecomment-2147022019","body":"\n### js代码\n```JavaScript\nvar uniquePaths = function(m, n) {\n    const f = new Array(m).fill(0).map(() => new Array(n).fill(0));\n    for (let i = 0; i < m; i++) {\n        f[i][0] = 1;\n    }\n    for (let j = 0; j < n; j++) {\n        f[0][j] = 1;\n    }\n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            f[i][j] = f[i - 1][j] + f[i][j - 1];\n        }\n    }\n    return f[m - 1][n - 1];\n};\n```\n\n### 复杂度分析\n时间复杂度：O(m*n)\n空间复杂度：O(m*n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/65#issuecomment-2157999000","body":"### js代码\n```JavaScript\nvar change = function (amount, coins) {\n  const dp = Array.from({ length: amount + 1 }).fill(0);\n  dp[0] = 1;\n  for (let coin of coins) {\n    for (let i = coin; i <= amount; i++) {\n      dp[i] += dp[i - coin];\n    }\n  }\n  return dp[amount];\n};\n```\n\n### 复杂度分析\n时间复杂度：O(m*n)\n空间复杂度：O(m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/66#issuecomment-2159722418","body":"### js代码\n```JavaScript\nconst findContentChildren = function (g, s) {\n  g = g.sort((a, b) => a - b);\n  s = s.sort((a, b) => a - b);\n  let gi = 0;\n  let sj = 0;\n  let res = 0;\n  while (gi < g.length && sj < s.length) {\n    if (s[sj] >= g[gi]) {\n      gi++;\n      sj++;\n      res++;\n    } else {\n      sj++;\n    }\n  }\n  return res;\n};\n```\n\n### 复杂度分析\n时间复杂度：O(nlogn)\n空间复杂度：O(logn)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/71#issuecomment-2171678108","body":"### js代码\n```JavaScript\nconst beautifulArray = function (n) {\n  let arr = [];\n  arr.push(1);\n  while (arr.length < n) {\n    let tmp = [];\n    for (const i of arr) if (i * 2 - 1 <= n) tmp.push(i * 2 - 1);\n    for (const i of arr) if (i * 2 <= n) tmp.push(i * 2);\n    arr = tmp;\n  }\n\n  return arr;\n};\n```\n\n### 复杂度分析\n时间复杂度：O(nlogn)\n空间复杂度：O(n+logn)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/74#issuecomment-2177784243","body":"### js代码\n```JavaScript\nvar Trie = function() {\n    this.children = {};\n};\n\nTrie.prototype.insert = function(word) {\n    let node = this.children;\n    for (const ch of word) {\n        if (!node[ch]) {\n            node[ch] = {};\n        }\n        node = node[ch];\n    }\n    node.isEnd = true;\n};\n\nTrie.prototype.searchPrefix = function(prefix) {\n    let node = this.children;\n    for (const ch of prefix) {\n        if (!node[ch]) {\n            return false;\n        }\n        node = node[ch];\n    }\n    return node;\n}\n\nTrie.prototype.search = function(word) {\n    const node = this.searchPrefix(word);\n    return node !== undefined && node.isEnd !== undefined;\n};\n\nTrie.prototype.startsWith = function(prefix) {\n    return this.searchPrefix(prefix);\n};\n\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/80#issuecomment-2188763612","body":"### js代码\n```JavaScript\nvar pruneTree = function (root) {\n  function dfs(root) {\n    if (!root) return 0;\n    const l = dfs(root.left);\n    const r = dfs(root.right);\n    if (l == 0) root.left = null;\n    if (r == 0) root.right = null;\n    return root.val + l + r;\n  }\n  ans = new TreeNode(-1);\n  ans.left = root;\n  dfs(ans);\n  return ans.left;\n};\n```\n\n### 复杂度分析\n时间复杂度：O(h)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null],"itsjacob":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shunanch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yppah-eb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"raychenlei":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"woshichuanqilz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"willuuu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"christina-soda":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jia98shanliang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"user-vannnn":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tobepellucid":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"johnvsd":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yueza":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawyuan97":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"victorhuang99":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cusanity":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jay-xzj":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiradaone":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xinyue-ma":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taojin1992":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joyce94":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"steven72574":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tian-pengfei":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asuka1h":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaowangcoding":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"james0608":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaneyang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"azl397985856":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whgsh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chengfengfengwang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bulingbulingbuling":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"c2tr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eden-ye":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"codingtrains":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"starorbiting":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mo-xiaoxiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"passengersa":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shellylcooper":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"testplm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tom-zhouch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"skylarxu214":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taihui":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huaxueguakele":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yang-chenyu104":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mlking15":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"-3":[],"cyonline":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rzhao010":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zywang0":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jetery":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"klspta":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bookyue":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jancerwu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"buer1121":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ceramickitten":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gg925407590":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alyenor":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenming-cao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ggohem":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dark-volute":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ronething":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jmastella":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"paopaohua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dd2001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mayloveless":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuexi001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nineis7":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"abby-xu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gsw9818":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaomingshixiaotang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"snmyj":[{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/1#issuecomment-2043024166","body":"```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res,ans;\n        int jw = 0;\n        int pos = num.size() - 1;\n        for ( int i = pos; i>=0; i-- ) {\n             int s = num[i] + k % 10 + jw;\n             jw = s/10;\n             k/=10;\n             res.push_back(s % 10);\n             \n        }\n        while (jw > 0 || k > 0) {\n            int s =( jw + k%10 );\n            jw = s/10;\n            k /= 10;\n            res.push_back(s%10);\n        }\n        for ( int i = res.size() - 1 ;i>=0;i--) {\n           ans.push_back(res[i]);\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/2#issuecomment-2045548930","body":"```\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.length();\n        vector<int> ans(n);\n        int index;\n\n        index = -2*n; \n        for (int i = 0; i < n; i++) {\n            if (s[i] == c) {\n                index = i;\n            }\n            ans[i] = i - index;\n        }\n\n        index = 2*n;\n        for (int i = n - 1; i >= 0; i--) {\n            if (s[i] == c) {\n                index = i;\n            }\n            ans[i] = min(ans[i], index - i);\n        }\n        return ans;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flipn9":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wabw1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqmmy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a-pricity":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sclihuiming":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"amazeding":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"astrking":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tzuikuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ringo1597":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brucezhang-utf-8":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luanxing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moin-jer":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lihua1997":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cuizezhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xuanaxuan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tiandao043":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"restlessbreeze":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ruikiwi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huiminren":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"saitochen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wtdcai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"albert556":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wuxiaoshawn":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zrtch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhuzhu096":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whoam-challenge":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weisday":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"syh-coder":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaaller":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kyrie96521":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cavecrypto":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cxgbro":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erjian96":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a-polarbear":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alexno1no2":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yetfan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhiyuanpeng":[{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/1#issuecomment-2041877241","body":"```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        ans = []\r\n        overflow = 0\r\n        k = [int(i) for i in str(k)]\r\n        num = num[::-1]\r\n        k = k[::-1]\r\n        for i in range(max(len(num), len(k))):\r\n            if i <= len(num) - 1 and i <= len(k) - 1:\r\n                overflow, cur = divmod((num[i] + k[i] + overflow), 10)\r\n                ans.append(cur)\r\n            elif i <= len(num) - 1:\r\n                overflow, cur = divmod((num[i] + overflow), 10)\r\n                ans.append(cur)\r\n            elif i <= len(k) - 1:\r\n                overflow, cur = divmod((k[i] + overflow), 10)\r\n                ans.append(cur)\r\n        if overflow != 0:\r\n            ans.append(overflow)\r\n        return ans[::-1] \r\n```\r\ntime: O(len(num)+len(k)) space max(len(num), len(k))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/2#issuecomment-2043461515","body":"```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        # compute the dis from its left \r\n        ans = []\r\n        pre = float(\"-inf\")\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                pre = i\r\n            ans.append(i-pre)\r\n        pre = float(\"inf\")\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                pre = i\r\n            ans[i] = min(ans[i], pre-i)\r\n        return ans\r\n```\r\n\r\ntwo passes: 1. compute the dis from its left 2. compute the dis from its right, the val is min(ans[i], pre-i)\r\n\r\ntime: n, space 1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/3#issuecomment-2046555340","body":"```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.size = 0\r\n        self.maxSize = maxSize\r\n        self.add = []\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size < self.maxSize:\r\n            self.stack.append(x)\r\n            self.size += 1\r\n            self.add.append(0)\r\n        \r\n\r\n    def pop(self) -> int:\r\n        if self.size > 0:\r\n            self.size -= 1\r\n            inc = self.add.pop()\r\n            if self.size > 0:\r\n                self.add[-1] += inc\r\n            val = self.stack.pop()\r\n            return val+inc\r\n        return -1\r\n        \r\n        \r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        n = min(k, self.size)\r\n        if n >= 1:\r\n            self.add[n-1] += val\r\n```\r\n\r\ntime: push O(1), pop O(1), increment O(1), space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/4#issuecomment-2049179153","body":"```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for c in s:\r\n            if c == \"]\":\r\n                rep = []\r\n                while True:\r\n                    top = stack.pop()\r\n                    if top == \"[\":\r\n                        k = []\r\n                        while stack and stack[-1] in \"0123456789\":\r\n                            k.append(stack.pop())\r\n                        k = int(\"\".join(k[::-1]))\r\n                        for i in range(k):\r\n                            stack += rep[::-1]\r\n                        break\r\n                    else:\r\n                        rep.append(top)\r\n            else:\r\n                stack.append(c)\r\n        return \"\".join(stack)\r\n```\r\ntime N space N where N is the len(decoded s)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/5#issuecomment-2050503396","body":"```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.forward = []\r\n        self.backward = []\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        self.forward.append(x)\r\n        \r\n\r\n    def pop(self) -> int:\r\n        if self.backward:\r\n            return self.backward.pop()\r\n        else:\r\n            while self.forward:\r\n                self.backward.append(self.forward.pop())\r\n            return self.backward.pop()\r\n        \r\n\r\n    def peek(self) -> int:\r\n        if self.backward:\r\n            return self.backward[-1]\r\n        return self.forward[0]\r\n        \r\n\r\n    def empty(self) -> bool:\r\n        if len(self.forward) or len(self.backward):\r\n            return False\r\n        else:\r\n            return True\r\n  ```\r\n  space O(N) time O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/6#issuecomment-2052393185","body":"```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        if len(arr) == 1:\r\n            return 1\r\n        stack = []\r\n        stack.append(arr[0])\r\n        for i in range(1, len(arr)):\r\n            if arr[i] < stack[-1]:\r\n                cur = stack.pop()\r\n                while stack and arr[i] < stack[-1]:\r\n                    stack.pop()\r\n                stack.append(cur)\r\n            else:\r\n                stack.append(arr[i])\r\n        return len(stack)\r\n```\r\nEach element in the stack represents a block in which the element is the biggest number. Iterate the arr and if find a value smaller than the top of the stack, this value needs to be merged into the blocks in the stack. To determine which block this value should be merged in, we need to compare it with the element in the blocks. At least, it should be merged with the block stored on the top of the stack, but it is also necessary to merage some blocks in the stack together as if the value is very small, for instance, stack=[3,4] and value=1, block 3, 4 and value 1 should be merged into one block. So, we first pop the last block or element in the stack (if the value is smaller than the top of stack, at least it should be merged into the top block), then we compare the value with left blocks and if find value < left_block, we need to pop left_block. We discard or merge the left_block by popping it. Finally we append the previous popped top block in the stack. \r\n\r\nTime O(N), space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/7#issuecomment-2053729208","body":"```\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return head\r\n        if not k:\r\n            return head\r\n        # get the length of head\r\n        p = head\r\n        length = 0\r\n        while p:\r\n            length += 1\r\n            p = p.next\r\n        _, k = divmod(k, length)\r\n        if not k:\r\n            return head\r\n        # start rotateRight, find the length-k node\r\n        loc = 0\r\n        p = head\r\n        while p:\r\n            loc += 1\r\n            if loc == length - k:\r\n                break\r\n            else:\r\n                p = p.next\r\n        new_head = p.next\r\n        p.next = None\r\n        pointer = new_head\r\n        while pointer.next:\r\n            pointer = pointer.next\r\n        pointer.next = head\r\n        return new_head\r\n```\r\ntime O(N) space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/8#issuecomment-2054630072","body":"```\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n        num = 0\r\n        p = head\r\n        while p:\r\n            num += 1\r\n            p = p.next\r\n        swap_num = int(num/2)\r\n        cur_p = head\r\n        pre = ListNode(next=head)\r\n        for i in range(swap_num):\r\n            next_p = cur_p.next\r\n            cur_p.next = next_p.next\r\n            next_p.next = cur_p\r\n            pre.next = next_p\r\n            pre = cur_p\r\n            if i == 0:\r\n                new_head = next_p\r\n            cur_p = cur_p.next\r\n        return new_hea\r\n```\r\ntime O(N) space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/9#issuecomment-2057589502","body":"```\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head:\r\n            return None\r\n        nodes = []\r\n        p = head\r\n        while p:\r\n            nodes.append(p.val)\r\n            p = p.next\r\n        root = self.sortedListToBSTHelper(nodes)\r\n        return root\r\n    \r\n    def sortedListToBSTHelper(self, nodes):\r\n        if nodes:\r\n            mid = len(nodes) // 2\r\n            root = TreeNode(val=nodes[mid])\r\n            root.left = self.sortedListToBSTHelper(nodes[:mid])\r\n            root.right = self.sortedListToBSTHelper(nodes[mid+1:])\r\n            return root\r\n        else:\r\n            return None\r\n   ```\r\ntime O(N), space O(N)\r\n   \r\n   ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/10#issuecomment-2059631676","body":"```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\r\n        set_a = set()\r\n        p_a = headA\r\n        while p_a:\r\n            set_a.add(p_a)\r\n            p_a = p_a.next\r\n        p_b = headB\r\n        while p_b:\r\n            if p_b in set_a:\r\n                return p_b\r\n            p_b = p_b.next\r\n        return None\r\n ```\r\n \r\n Time O(N) Space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/11#issuecomment-2061908903","body":"```\r\nclass Solution:\r\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        nodes = set()\r\n        p = head\r\n        while p:\r\n            if p in nodes:\r\n                return p\r\n            nodes.add(p)\r\n            p = p.next\r\n        return None\r\n```\r\nTime O(N) Space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/12#issuecomment-2065796146","body":"```\r\nclass Dlist:\r\n    def __init__(self, val=None, key=None):\r\n        self.val = val\r\n        self.key = key\r\n        self.pre = None\r\n        self.next = None\r\n\r\nclass LRUCache:\r\n        \r\n    def __init__(self, capacity: int):\r\n        self.map = {}\r\n        self.capacity = capacity\r\n        self.head = Dlist()\r\n        self.tail = Dlist()\r\n        self.head.next = self.tail\r\n        self.tail.pre = self.head\r\n\r\n    def move2tail(self, n):\r\n        # if already at the end, take no action\r\n        if n == self.tail.pre:\r\n            return\r\n        # find the node\r\n        pre_n = n.pre\r\n        next_n = n.next\r\n        pre_tail = self.tail.pre\r\n        # take out the node\r\n        pre_n.next = next_n\r\n        next_n.pre = pre_n\r\n        # move to the end\r\n        pre_tail.next = n\r\n        n.pre = pre_tail\r\n        n.next = self.tail\r\n        self.tail.pre = n\r\n\r\n    def add2tail(self, n):\r\n        pre_tail = self.tail.pre\r\n        pre_tail.next = n\r\n        n.pre = pre_tail\r\n        self.tail.pre = n\r\n        n.next = self.tail\r\n\r\n    def delete_head(self):\r\n        self.top = self.head.next\r\n        self.top_next = self.top.next\r\n        # delete the top node\r\n        self.head.next = self.top_next\r\n        self.top_next.pre = self.head\r\n        # set pointer to None\r\n        self.top.pre = None\r\n        self.top.next = None\r\n        del self.map[self.top.key]\r\n        \r\n    def get(self, key: int) -> int:\r\n        n = self.map.get(key, -1)\r\n        if n == -1:\r\n            return -1\r\n        self.move2tail(n)\r\n        return n.val\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.map:\r\n            self.map[key].val = value\r\n            self.move2tail(self.map[key])\r\n        else:\r\n            if len(self.map) == self.capacity:\r\n                self.delete_head()\r\n            self.map[key] = Dlist(val=value, key=key)\r\n            self.add2tail(self.map[key])\r\n```\r\ndict to store (key, double_linked_list_node)\r\n\r\ntime O(1) space O(capacity)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/13#issuecomment-2067196395","body":"```\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root:\r\n            return 0\r\n        max_depth = [-1]\r\n        self.dfs(root, 0, max_depth)\r\n        return max_depth[0]\r\n    \r\n    def dfs(self, root, current_depth, max_depth):\r\n        if not root:\r\n            return\r\n        current_depth += 1\r\n        max_depth[0] = max(max_depth[0], current_depth)\r\n        self.dfs(root.left, current_depth, max_depth)\r\n        self.dfs(root.right, current_depth, max_depth)   \r\n```\r\ntime O(N) space O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/14#issuecomment-2067910204","body":"```\r\nclass Solution:\r\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n        if p and q:\r\n            if p.val == q.val:\r\n                return True and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n            else:\r\n                return False\r\n        elif not p and not q:\r\n            return True\r\n        else:\r\n            return False   \r\n```\r\n    \r\n    Time O(N) Space O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/15#issuecomment-2068231540","body":"```\r\nclass Solution:\r\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\r\n        ans = [0]\r\n        self.dfs(root, 0, ans)\r\n        return ans[0]\r\n    \r\n    def dfs(self, root, score, ans):\r\n        score = score*10 + root.val\r\n        if not root.left and not root.right:\r\n            ans[0] += score\r\n        else:\r\n            if root.left:\r\n                self.dfs(root.left, score, ans)\r\n            if root.right:\r\n                self.dfs(root.right, score, and)\r\n```\r\ntime O(N) space O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/16#issuecomment-2070428695","body":"```\r\nfrom collections import deque\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        q = deque([root])\r\n        ans = root.val\r\n        while q:\r\n            next_layer = []\r\n            while q:\r\n                n = q.popleft()\r\n                if n.left:\r\n                    next_layer.append(n.left)\r\n                if n.right:\r\n                    next_layer.append(n.right)\r\n            q = deque(next_layer)\r\n            if next_layer:\r\n                ans = next_layer[0].val\r\n        return ans\r\n```\r\ntime O(N) space(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/17#issuecomment-2075728792","body":"```\r\nfrom collections import deque\r\nclass Codec:\r\n\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        nodes = []\r\n        self. encode_dfs(root, nodes)\r\n        return \",\".join(nodes)\r\n        \r\n    def encode_dfs(self, root, nodes):\r\n        if not root:\r\n            nodes.append(\"null\")\r\n            return\r\n        nodes.append(str(root.val))\r\n        self.encode_dfs(root.left, nodes)\r\n        self.encode_dfs(root.right, nodes)\r\n    \r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        if not data:\r\n            return None\r\n        data = deque(data.split(\",\"))\r\n        return self.decode_dfs(data)\r\n    \r\n    def decode_dfs(self, data):\r\n        if not data:\r\n            return None\r\n        val = data.popleft()\r\n        if val == \"null\":\r\n            return None\r\n        node = TreeNode(val)\r\n        node.left = self.decode_dfs(data)\r\n        node.right = self.decode_dfs(data)\r\n        return node\r\n```\r\ntime O(N) space O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/18#issuecomment-2075643183","body":"```\r\nfrom collections import defaultdict\r\nclass Solution:\r\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\r\n        nodes = []\r\n        self.dfs(root, 0, 0, nodes)\r\n        nodes = sorted(nodes)\r\n        ans = defaultdict(list)\r\n        for n in nodes:\r\n            ans[n[0]].append(n[-1])\r\n        return list(ans.values())\r\n    \r\n    def dfs(self, root, col, row, nodes):\r\n        if not root:\r\n            return\r\n        nodes.append((col, row, root.val))\r\n        self.dfs(root.left, col-1, row+1, nodes)\r\n        self.dfs(root.right, col+1, row+1, nodes\r\n```\r\nTime O(nlogn) Space O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/20#issuecomment-2078231603","body":"```\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        can = {}\r\n        for i, val in enumerate(nums):\r\n            if val in can:\r\n                return [can[val], i]\r\n            else:\r\n                can[target-val] = i\r\n```\r\nTime O(N) space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/21#issuecomment-2080378154","body":"```\r\nfrom collections import Counter, defaultdict\r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        freq = Counter(nums)\r\n        return heapq.nlargest(k, freq.keys(), key=lambda x: freq[x]\r\n```\r\nTime O(Nlogk) space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/22#issuecomment-2081174729","body":"```\r\nclass Solution:\r\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\r\n        ans = 0\r\n        for i, a in enumerate(points):\r\n            distance = collections.defaultdict(int)\r\n            for j, b in enumerate(points):\r\n                if i == j:\r\n                    continue\r\n                dist = (a[0] - b[0])**2 + (a[1] - b[1])**2\r\n                distance[dist] += 1\r\n            #\r\n            for k, v in distance.items():\r\n                if v >=2:\r\n                    ans += v*(v-1)\r\n        return and\r\n```\r\nTime O(N**2) Space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/23#issuecomment-2081694891","body":"```\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        l, ans = 0, 0\r\n        sub = set()\r\n        for r in range(len(s)):\r\n            if s[r] not in sub:\r\n                sub.add(s[r])\r\n                ans = max(ans, len(sub))\r\n            else:\r\n                while s[r] in sub:\r\n                    sub.remove(s[l])\r\n                    l += 1\r\n                sub.add(s[r])\r\n                ans = max(ans, len(sub))\r\n        return ans\r\n```\r\nTime O(N) Space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/24#issuecomment-2087978650","body":"```\r\nclass Solution:\r\n    def helper(self, s, start, words, w_len, s_len, golden):\r\n        ans = []\r\n        if len(s) < s_len:\r\n            return ans\r\n        l, r = 0, 0\r\n        target = collections.defaultdict(int)\r\n        for r in range(0, s_len, w_len):\r\n            target[s[r: w_len+r]] += 1\r\n        if target == golden:\r\n            ans.append(l+start)\r\n            \r\n        if s_len > len(s) - w_len:\r\n            return ans\r\n        \r\n        for r in range(s_len, len(s), w_len):\r\n            target[s[r: r+w_len]] += 1\r\n            target[s[l: l+w_len]] -= 1\r\n            if target[s[l: l+w_len]] == 0:\r\n                del target[s[l: l+w_len]]\r\n            l += w_len\r\n            if target == golden:\r\n                ans.append(l+start)\r\n        return ans\r\n            \r\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\r\n        w_len = len(words[0])\r\n        s_len = len(words)*w_len\r\n        ans = []\r\n        target = collections.Counter(words)\r\n        if len(s) < s_len:\r\n            return ans\r\n        else:\r\n            for i in range(w_len):\r\n                ans += self.helper(s[i:], i, words, w_len, s_len, target)\r\n            return ans\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/25#issuecomment-2087979501","body":"```\r\nclass Solution:\r\n    def minSubarray(self, nums: List[int], p: int) -> int:\r\n        s = sum(nums) % p\r\n        if s == 0:\r\n            return 0\r\n\r\n        cum_sum = 0\r\n        d = {0: -1}\r\n        result = len(nums)\r\n        for j, elem in enumerate(nums):\r\n            cum_sum = (cum_sum + elem) % p\r\n            i = d.get((cum_sum - s) % p)\r\n            if i is not None:\r\n                result = min(result, j - i)\r\n            d[cum_sum] = j\r\n        \r\n        if result == len(nums):\r\n            return -1\r\n        return result\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/26#issuecomment-2089765510","body":"```\r\nclass Solution:\r\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        fast, slow = head, head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        return slow\r\n```\r\nTime O(N) Space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/27#issuecomment-2092621781","body":"```\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        diffs = set()\r\n        l, r, ans = 0, 0, 1\r\n        diffs.add(nums[0])\r\n        for r in range(1, len(nums)):\r\n            if nums[r] in diffs:\r\n                continue\r\n            else:\r\n                l += 1\r\n                nums[l] = nums[r]\r\n                ans += 1\r\n                diffs.add(nums[r])\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/28#issuecomment-2093883446","body":"```\r\nclass Solution:\r\n    def searchInsert(self, nums: List[int], target: int) -> int:\r\n        l, r = 0, len(nums)-1\r\n        while l <= r:\r\n            mid = (l + r)//2\r\n            if nums[mid] == target:\r\n                return mid\r\n            elif nums[mid] > target:\r\n                r = mid - 1\r\n            else:\r\n                l = mid + 1\r\n        return \r\n```\r\nTime O(logN) space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/29#issuecomment-2094526993","body":"```\r\nclass Solution:\r\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\r\n        q = collections.deque()\r\n        ans = []\r\n        for i in range(len(nums)):\r\n            while q and q[0] == i-k:\r\n                q.popleft()\r\n            while q and nums[q[-1]] < nums[i]:\r\n                q.pop()\r\n            q.append(i)\r\n            if i >= k-1:\r\n                ans.append(nums[q[0]])\r\n        return ans\r\n```\r\nTime O(N), Space O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/30#issuecomment-2094876712","body":"```\r\nclass Solution:\r\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\r\n        d = collections.defaultdict(int)\r\n        for k, v in trust:\r\n            d[k] -= 1\r\n            d[v] += 1\r\n        for i in range(1, n+1):\r\n            if d[i] == n-1:\r\n                return i\r\n        return -1\r\n```\r\nTime O(N) Space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/31#issuecomment-2097415850","body":"```\r\nclass Solution:\r\n    def dfs(self, g, i, c, colors):\r\n        colors[i] = c\r\n        # for it's connector v, try to color -1*c\r\n        for j in g[i]:\r\n            if colors[j] == c:\r\n                return False\r\n            elif colors[j] == 0 and not self.dfs(g, j, -1*c, colors):\r\n                return False\r\n        return True\r\n    \r\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\r\n        g = collections.defaultdict(list)\r\n        for x, y in dislikes:\r\n            g[x-1].append(y-1)\r\n            g[y-1].append(x-1)\r\n        colors = [0] * n\r\n        for i in range(n):\r\n            if colors[i] == 0 and not self.dfs(g, i, 1, colors):\r\n                return False\r\n        return True\r\n```\r\n            \r\n        ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/32#issuecomment-2099798252","body":"class Solution:\n    def sortItems(self, n, m, group, beforeItems):\n        # If an item belongs to zero group, assign it a unique group id.\n        group_id = m\n        for i in range(n):\n            if group[i] == -1:\n                group[i] = group_id\n                group_id += 1\n        \n        # Sort all item regardless of group dependencies.\n        item_graph = [[] for _ in range(n)]\n        item_indegree = [0] * n\n        \n        # Sort all groups regardless of item dependencies.\n        group_graph = [[] for _ in range(group_id)]\n        group_indegree = [0] * group_id      \n        \n        for curr in range(n):\n            for prev in beforeItems[curr]:\n                # Each (prev -> curr) represents an edge in the item graph.\n                item_graph[prev].append(curr)\n                item_indegree[curr] += 1\n                \n                # If they belong to different groups, add an edge in the group graph.\n                if group[curr] != group[prev]:\n                    group_graph[group[prev]].append(group[curr])\n                    group_indegree[group[curr]] += 1      \n        \n        # Tologlogical sort nodes in graph, return [] if a cycle exists.\n        def topologicalSort(graph, indegree):\n            visited = []\n            stack = [node for node in range(len(graph)) if indegree[node] == 0]\n            while stack:\n                cur = stack.pop()\n                visited.append(cur)\n                for neib in graph[cur]:\n                    indegree[neib] -= 1\n                    if indegree[neib] == 0:\n                        stack.append(neib)\n            return visited if len(visited) == len(graph) else []\n\n        item_order = topologicalSort(item_graph, item_indegree)\n        group_order = topologicalSort(group_graph, group_indegree)\n        \n        if not item_order or not group_order: \n            return []\n        \n        # Items are sorted regardless of groups, we need to \n        # differentiate them by the groups they belong to.\n        ordered_groups = collections.defaultdict(list)\n        for item in item_order:\n            ordered_groups[group[item]].append(item)\n        \n        # Concatenate sorted items in all sorted groups.\n        # [group 1, group 2, ... ] -> [(item 1, item 2, ...), (item 1, item 2, ...), ...]\n        answer = []\n        for group_index in group_order:\n            answer += ordered_groups[group_index]\n        return answer","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/33#issuecomment-2101100534","body":"```\r\nclass Solution:\r\n    def judgeCircle(self, moves: str) -> bool:\r\n        if len(moves) % 2 != 0:\r\n            return False\r\n        count = collections.Counter(moves)\r\n        if count[\"U\"] == count[\"D\"] and count[\"L\"]==count[\"R\"]:\r\n            return True\r\n        else:\r\n            return False\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/34#issuecomment-2104827511","body":"```\r\nclass Solution:\r\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\r\n        tasks = [(task[0], i, task[1]) for i, task in enumerate(tasks)]\r\n        tasks.sort()\r\n        ans = []\r\n        will_pro = []\r\n        time, pro = 0, 0 \r\n        for _ in tasks:\r\n            if not will_pro:\r\n                time = max(time, tasks[pro][0])\r\n            while pro < len(tasks) and tasks[pro][0] <= time:\r\n                heapq.heappush(will_pro, (tasks[pro][2], tasks[pro][1]))\r\n                pro += 1\r\n            en, i = heapq.heappop(will_pro)\r\n            ans.append(i)\r\n            time += en\r\n        return ans\r\n ```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/35#issuecomment-2105409165","body":"```\r\nclass Solution:\r\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\r\n        if 0 <= self.time2minute(logoutTime) - self.time2minute(loginTime) < 15:\r\n            return 0\r\n        login_m = self.roundUpper(loginTime)\r\n        logout_m = self.roundLower(logoutTime)\r\n        if self.time2minute(loginTime) > self.time2minute(logoutTime):\r\n            logout_m += 24*60\r\n        ans = (logout_m - login_m)//15\r\n        return ans\r\n        \r\n    def time2minute(self, time):\r\n        return int(time[:2])*60 + int(time[3:])\r\n                \r\n    def roundUpper(self, time):\r\n        interval = [0, 15, 30, 45, 60]\r\n        minute = int(time[3:])\r\n        min_v, min_i = minute, 0\r\n        for i in range(1, len(interval)):\r\n            if abs(minute - interval[i]) < abs(min_v):\r\n                min_v = minute - interval[i]\r\n                min_i = i\r\n        if min_v > 0:\r\n            minute = interval[min_i] + 15\r\n        else:\r\n            minute = interval[min_i]\r\n        \r\n        h, m = divmod(minute, 60)\r\n\r\n        return (int(time[:2])+h)*60+m\r\n        \r\n    def roundLower(self, time):\r\n        interval = [0, 15, 30, 45, 60]\r\n        minute = int(time[3:])\r\n        min_v, min_i = minute, 0\r\n        for i in range(1, len(interval)):\r\n            if abs(minute - interval[i]) < abs(min_v):\r\n                min_v = minute - interval[i]\r\n                min_i = i\r\n        if min_v >= 0:\r\n            minute = interval[min_i]\r\n        else:\r\n            minute = interval[min_i] - 15\r\n\r\n        return int(time[:2])*60+minute\r\n```\r\n\r\ntime O(1) spaceO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/36#issuecomment-2106151211","body":"```\r\nclass Solution:\r\n    def minCharacters(self, a: str, b: str) -> int:\r\n        a = [ord(c)-ord(\"a\") for c in a]\r\n        b = [ord(c)-ord(\"a\") for c in b]\r\n        a_c = collections.Counter(a)\r\n        a_l = len(a)\r\n        b_c = collections.Counter(b)\r\n        b_l = len(b)\r\n        # case 3\r\n        ans_3 = float(\"inf\")\r\n        for i in range(26):\r\n            ans_3 = min(ans_3, a_l+b_l-a_c[i]-b_c[i])    \r\n        # case 1 a < b\r\n        ans_1 = self.a_smaller_b(a_c, b_c)\r\n        # case 2 b < a\r\n        ans_2 = self.a_smaller_b(b_c, a_c)\r\n        ans = min(ans_1, ans_2, ans_3)\r\n        return ans\r\n\r\n    def a_smaller_b(self, x, y):\r\n        # to make a smaller than b, iterate all the possible max char in a:\r\n        # 1. all the char in a bigger than max shoud be changed to smaller than max\r\n        # 2. all the char in b smaller than max in a should be changed to be bigger than max in a\r\n        ans = float(\"inf\")\r\n        for i in range(1,26):\r\n            t = 0\r\n            for j in range(i, 26):\r\n                t += x[j]\r\n            for j in range(i):\r\n                t += y[j]\r\n            ans = min(ans, t)\r\n        return and\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/37#issuecomment-2106321861","body":"```\r\nclass Solution:\r\n    def sortArray(self, nums: List[int]) -> List[int]:\r\n        if len(nums) > 1:\r\n            mid = len(nums)//2\r\n            left = nums[:mid]\r\n            right = nums[mid:]\r\n            left = self.sortArray(left)\r\n            right = self.sortArray(right)\r\n            ans = self.merge(left, right)\r\n            return ans\r\n        else:\r\n            return nums\r\n        \r\n    def merge(self, left, right):\r\n        ans = []\r\n        l,r = 0,0\r\n        while l < len(left) and r < len(right):\r\n            if left[l] <= right[r]:\r\n                ans.append(left[l])\r\n                l += 1\r\n            else:\r\n                ans.append(right[r])\r\n                r += 1\r\n        while l < len(left):\r\n            ans.append(left[l])\r\n            l += 1\r\n        while r < len(right):\r\n            ans.append(right[r])\r\n            r += 1\r\n        return ans \r\n ```       ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/38#issuecomment-2110573636","body":"class Solution:\n    def mySqrt(self, x: int) -> int:\n        ans, l, r = 0, 0, x\n        while l <= r:\n            mid = (l + r) // 2\n            if mid ** 2 > x:\n                r = mid - 1\n            if mid ** 2 <= x:\n                ans = mid\n                l = mid + 1\n        return int(ans)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/39#issuecomment-2114464483","body":"```\r\n# The isBadVersion API is already defined for you.\r\n# @param version, an integer\r\n# @return an integer\r\n# def isBadVersion(version):\r\n\r\nclass Solution:\r\n    # def firstBadVersion(self, n):\r\n    #     \"\"\"\r\n    #     :type n: int\r\n    #     :rtype: int\r\n    #     \"\"\"\r\n    #     l, r = 1, n\r\n    #     while l < r:\r\n    #         mid = (l+r)//2\r\n    #         # if find B, G is right\r\n    #         if isBadVersion(mid):\r\n    #             r = mid - 1\r\n    #         # if find G, we want to find the right most G, current may be the right most, so l = mid\r\n    #         if not isBadVersion(mid):\r\n    #             l = mid\r\n    #     return l+1\r\n    \r\n        def firstBadVersion(self, n):\r\n            \"\"\"\r\n            :type n: int\r\n            :rtype: int\r\n            \"\"\"\r\n            l, r = 1, n\r\n            while l < r:\r\n                mid = (l+r)//2\r\n                # if find B, G is right\r\n                if isBadVersion(mid):\r\n                    r = mid\r\n                # if find G, we want to find the right most G, current may be the right most, so l = mid\r\n                if not isBadVersion(mid):\r\n                    l = mid + 1\r\n            return l\r\n```\r\n        ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/40#issuecomment-2114459106","body":"from sortedcontainers import SortedList\nclass Solution:\n    def reversePairs(self, A):\n        d = SortedList()\n        ans = 0\n\n        for a in A:\n            i = d.bisect_right(a * 2)\n            ans += len(d) - i\n            d.add(a)\n        return ans","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/42#issuecomment-2118733308","body":"class Solution:\n    def solve(self, A, k):\n        A.sort()\n        def count_not_greater(diff):\n            i = ans = 0\n            for j in range(1, len(A)):\n                while A[j] - A[i] > diff:\n                    i += 1\n                ans += j - i\n            return ans\n        l, r = 0, A[-1] - A[0]\n        k += 1 # zero based -> one based\n        while l <= r:\n            mid = (l + r) // 2\n            if count_not_greater(mid) >= k:\n                r = mid - 1\n            else:\n                l = mid + 1\n        return l","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/45#issuecomment-2122461508","body":"```\r\nclass Solution:\r\n    def new21Game(self, N: int, K: int, W: int) -> float:\r\n        dp = [0] * (K + W)\r\n        win_sum = 0\r\n        for i in range(K, K + W):\r\n            if i <= N:\r\n                dp[i] = 1\r\n            win_sum += dp[i]\r\n\r\n        for i in range(K - 1, -1, -1):\r\n            dp[i] = win_sum / W\r\n            win_sum += dp[i] - dp[i + W]\r\n        return dp[0]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/46#issuecomment-2123944030","body":"```\r\nfrom collections import defaultdict, Counter\r\nclass Solution:\r\n    def findAnagrams(self, s: str, p: str) -> List[int]:\r\n        w = len(p)\r\n        n = len(s)\r\n        if n < w:\r\n            return None\r\n        pd = Counter(p)\r\n        wd = defaultdict(int)\r\n        for c in s[:w]:\r\n            wd[c] += 1\r\n        ans = []\r\n        for i in range(0, n-w+1):\r\n            if wd == pd:\r\n                ans.append(i)\r\n            wd[s[i]] -= 1\r\n            if wd[s[i]] == 0:\r\n                del wd[s[i]]\r\n            if i != n-w:\r\n                wd[s[i+w]] += 1\r\n        return and\r\n```\r\n                \r\n            \r\n        ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/47#issuecomment-2127447743","body":"```\r\nfrom collections import Counter\r\nclass Solution:\r\n    def minWindow(self, s: str, t: str) -> str:\r\n        td = Counter(t)\r\n        wd = Counter()\r\n        tl = len(td)\r\n        ans = \"\"\r\n        ans_len = float(\"inf\")\r\n        j = 0\r\n        k = 0\r\n        for i in range(len(s)):\r\n            wd[s[i]] += 1\r\n            if wd[s[i]] == td[s[i]]:\r\n                k += 1\r\n            while k == tl:\r\n                if i-j+1 < ans_len:\r\n                    ans_len = i-j+1\r\n                    ans = s[j: i+1]\r\n                wd[s[j]] -= 1\r\n                if wd[s[j]] == td[s[j]] - 1:\r\n                    k -= 1\r\n                j += 1\r\n        return ans\r\n```\r\n                \r\n        ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/49#issuecomment-2131157719","body":"class Solution:\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\n        ans = []\n        for a in range(12):\n            for b in range(60):\n                if (bin(a) + bin(b)).count('1') == turnedOn:\n                    ans.append(str(a) +\":\" + str(b).rjust(2, '0'))\n        return ans\n        ","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/52#issuecomment-2134457476","body":"```\r\nclass Solution:\r\n    def maxDistance(self, grid: List[List[int]]) -> int:\r\n        n = len(grid)\r\n        q = collections.deque([(i, j) for i in range(len(grid)) for j in range(len(grid[0])) if grid[i][j] == 1])\r\n        step = -1\r\n        if len(q) == 0 or len(q) == len(grid)*len(grid):\r\n            return step\r\n        while len(q):\r\n            for i in range(len(q)):\r\n                x, y = q.popleft()\r\n                bfs = [(x+1, y), (x-1, y), (x, y-1), (x, y+1)]\r\n                for xx, yy in bfs:\r\n                    if 0 <= xx < n and 0 <= yy < n and grid[xx][yy] == 0:\r\n                        q.append((xx, yy))\r\n                        grid[xx][yy] = -1\r\n            step += 1\r\n        return step\r\n```\r\n        \r\n        ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/53#issuecomment-2137736973","body":"def maxCandies(self, status, candies, keys, containedBoxes, initialBoxes):\n        boxes = set(initialBoxes)\n        q = [i for i in boxes if status[i]]\n        for i in q:\n            for j in containedBoxes[i]:\n                boxes.add(j)\n                if status[j]:\n                    q.append(j)\n            for j in keys[i]:\n                if status[j] == 0 and j in boxes:\n                    q.append(j)\n                status[j] = 1\n        return sum(candies[i] for i in q)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/55#issuecomment-2142532042","body":"class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        dp = [0] * (len(cost)+1)\n        dp[0], dp[1] = cost[0], cost[1]\n        for i in range(2, len(cost)+1):\n            dp[i] = min(dp[i-1], dp[i-2]) + (cost[i] if i != len(cost) else 0)\n        return dp[-1]","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/62#issuecomment-2155013242","body":"class Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        target = sum(nums) // 2\n        if target + target != sum(nums):\n            return False\n        dp = [False] * (target + 1)\n        dp[0] = True\n\n        for i in range(1, len(nums) + 1):\n            for j in range(target, 0, -1):\n                if dp[j] or (j - nums[i - 1] > -1 and dp[j - nums[i - 1]]):\n                    dp[j] = True\n        return dp[-1]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/63#issuecomment-2156079360","body":"class Solution:\n    def findTargetSumWays(self, nums, target) -> bool:\n        t = sum(nums) + target\n        if t % 2:\n            return 0\n        t = t // 2\n\n        dp = [0] * (t + 1)\n        dp[0] = 1\n\n        for i in range(len(nums)):\n            for j in range(t, nums[i] - 1, -1):\n                dp[j] += dp[j - nums[i]]\n        return dp[-1]","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/70#issuecomment-2168392839","body":"class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        if not lists or not any([l for l in lists]):\n            return None\n        q = [(s.val, index, s) for index, s in enumerate(lists) if s is not None]\n        cnt = len(q)\n        head = p = ListNode()\n        heapq.heapify(q)\n        while q:\n            _, _, n = heapq.heappop(q)\n            p.next = ListNode(n.val)\n            n = n.next\n            if n:\n                cnt += 1\n                heapq.heappush(q, (n.val, cnt, n))\n            p = p.next\n        return head.next","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/71#issuecomment-2171749259","body":"```\r\nclass Solution:\r\n    def beautifulArray(self, n: int) -> List[int]:\r\n        res=[1]\r\n        while len(res)<n :\r\n            odd=[2*i-1 for i in res]\r\n            even=[2*i for i in res]\r\n            res=odd+even\r\n        return [i for i in res if i<=n]\r\n``` ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/72#issuecomment-2173468201","body":"```\r\nclass Solution:\r\n    def singleNumber(self, nums: List[int]) -> List[int]:\r\n        xor = 0\r\n        for val in nums:\r\n            xor ^= val\r\n        mask = 1\r\n        while mask & xor == 0:\r\n            mask <<= 1\r\n        a, b =0, 0\r\n        for val in nums:\r\n            if val & mask:\r\n                a ^= val\r\n            else:\r\n                b ^= val\r\n        return [a, b]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/73#issuecomment-2176450551","body":"```\r\nclass Solution:\r\n    def subsets(self, nums: List[int]) -> List[List[int]]:\r\n        ans = []\r\n        for i in range(2**len(nums)):\r\n            cur = []\r\n            for j in range(len(nums)):\r\n                if ((1 << j) & i) != 0:\r\n                    cur.append(nums[j])\r\n            ans.append(cur)\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/74#issuecomment-2178922668","body":"```\r\nclass TrieNode:\r\n    def __init__(self):\r\n        # pre to store the # of str prefixed by the nodes from root to current node\r\n        self.pre = 0\r\n        # count to store the # of str formed by the nodes from root to current node\r\n        self.count = 0\r\n        self.children = collections.defaultdict(TrieNode)\r\nclass Trie:\r\n\r\n    def __init__(self):\r\n        self.root = TrieNode()\r\n        \r\n\r\n    def insert(self, word: str) -> None:\r\n        node = self.root\r\n        for ch in word:\r\n            node = node.children[ch]\r\n            node.pre += 1\r\n        node.count += 1\r\n        \r\n\r\n    def search(self, word: str) -> bool:\r\n        node = self.root\r\n        for ch in word:\r\n            if ch not in node.children:\r\n                return False\r\n            node = node.children[ch]\r\n        return node.count > 0\r\n        \r\n\r\n    def startsWith(self, prefix: str) -> bool:\r\n        node = self.root\r\n        for ch in prefix:\r\n            if ch not in node.children:\r\n                return False\r\n            node = node.children[ch]\r\n        return node.pre > 0\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/75#issuecomment-2181013195","body":"```\r\nclass TrieNode:\r\n    def __init__(self):\r\n        self.children = {}\r\n        self.value = 0\r\n\r\nclass MapSum:\r\n    def __init__(self):\r\n        self.root = TrieNode()\r\n        self.map = {}\r\n\r\n    def insert(self, key: str, val: int) -> None:\r\n        # Calculate the difference between the new value and the old value\r\n        # for the given key, if it exists.\r\n        diff = val - self.map.get(key, 0)\r\n        self.map[key] = val\r\n        \r\n        # Traverse the Trie from the root to the node that represents\r\n        # the prefix of the key, and update the node value with the new value.\r\n        node = self.root\r\n        node.value += diff\r\n        for char in key:\r\n            if char not in node.children:\r\n                node.children[char] = TrieNode()\r\n            node = node.children[char]\r\n            node.value += diff\r\n\r\n    def sum(self, prefix: str) -> int:\r\n        # Traverse the Trie from the root to the node that represents\r\n        # the prefix, and return the value of that node.\r\n        node = self.root\r\n        for char in prefix:\r\n            if char not in node.children:\r\n                return 0\r\n            node = node.children[char]\r\n        return node.value\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/76#issuecomment-2183010980","body":"```\r\nclass Trie:\r\n    def __init__(self, words):\r\n        self.d = {}\r\n        for word in words:\r\n            t = self.d\r\n            for w in word:\r\n                if w not in t:\r\n                    t[w] = {}\r\n                t = t[w]\r\n            t['end'] = word\r\n    \r\n    def search(self, s):\r\n        t = self.d\r\n        res = []\r\n        for w in s:\r\n            if w not in t:\r\n                break\r\n            t = t[w]\r\n            if 'end' in t:\r\n                res.append(t['end'])\r\n        return res\r\n\r\nclass Solution:\r\n    def multiSearch(self, big: str, smalls: List[str]) -> List[List[int]]:\r\n        trie = Trie(smalls)\r\n        hit = collections.defaultdict(list)\r\n\r\n        for i in range(len(big)):\r\n            matchs = trie.search(big[i:])\r\n            for word in matchs:\r\n                hit[word].append(i)\r\n        \r\n        res = []\r\n        for word in smalls:\r\n            res.append(hit[word])\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/77#issuecomment-2183313328","body":"```\r\nclass UFind:\r\n    def __init__(self, n):\r\n        self.parent = {i: i for i in range(n)}\r\n        self.size = n\r\n\r\n    def find(self, x):\r\n        if x != self.parent[x]:\r\n            self.parent[x] = self.find(self.parent[x])\r\n            return self.parent[x]\r\n        return x\r\n\r\n    def union(self, x, y):\r\n        parent_x = self.find(x)\r\n        parent_y = self.find(y)\r\n\r\n        if parent_x != parent_y:\r\n            self.size -= 1\r\n            self.parent[parent_x] = parent_y\r\n\r\nclass Solution:\r\n    def findCircleNum(self, isConnected: List[List[int]]) -> int:\r\n        n = len(isConnected)\r\n        if n == 1:\r\n            return 1\r\n        union_find = UFind(n)\r\n        for i in range(n - 1):\r\n            for j in range(i + 1, n):\r\n                if isConnected[i][j]:\r\n                    union_find.union(i, j)\r\n        return union_find.size\r\n```\r\nspace O(N), time (N^2)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/81#issuecomment-2192042483","body":"```\r\nclass Solution:\r\n    def combinationSum(\r\n        self, candidates: List[int], target: int\r\n    ) -> List[List[int]]:\r\n\r\n        results = []\r\n\r\n        def backtrack(remain, comb, start):\r\n            if remain == 0:\r\n                # make a deep copy of the current combination\r\n                results.append(list(comb))\r\n                return\r\n            elif remain < 0:\r\n                # exceed the scope, stop exploration.\r\n                return\r\n\r\n            for i in range(start, len(candidates)):\r\n                # add the number into the combination\r\n                comb.append(candidates[i])\r\n                # give the current number another chance, rather than moving on\r\n                backtrack(remain - candidates[i], comb, i)\r\n                # backtrack, remove the number from the combination\r\n                comb.pop()\r\n\r\n        backtrack(target, [], 0)\r\n\r\n        return results\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null],"bwspsu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"arinzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mdge":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"allenfeng666":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yin02":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elsa-zhang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asur4s":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"littlesugarman":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhihaowan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"apockira":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guowei0223":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shuqianyang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sj941127":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zjsuper":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yongxi-zhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"darwintk":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"h-steven":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mischaqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wurongronga":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miduoliu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyshenzhengkang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"y4h2":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yoco323":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"forschers":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shanshuiqiankun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"annabellhyx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hwfrankfung":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"frederickfan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huibinny":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ggmybro":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"myleetcodejourney":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"want2333":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"staringwhere":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"allenfeng8":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ryanbaiyansong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dou-yu-xuan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyxupup":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cs12300":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chiehw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aesir-idun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaldsk12":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hxj2001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"for123s":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzhilin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yfu6":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mengsixing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"import-ant":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joriscai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangqianqian202301":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"airwalkers":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhumengcheng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kofzhang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leonalhq":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hjy-u":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"csthaha":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zepherust":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"feefeefee":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hughlin07":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huizsh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chanceyliu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hshen11":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"horace7":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangzh0114":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dragonfcl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huifeng248":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sarah11qing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"el1as7":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zcytm3000":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pangjiadai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xb798298436":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ywang525":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"limbo42":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dorapocket":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zoeyzyzyzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jasonqiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lp1506947671":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"texamc2":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joemonkeylee":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"northseacoder":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dominique9898":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wl678":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"meisgithub":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sye9286":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fuku-l":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kangliqi1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richardtaok":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chocolate-emperor":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lydia61":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangjiahuan17":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"seanutf":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangyong-hub":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erquaner":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiujingxukong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"x1aox1a":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"drinkmorekaik":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dinjufen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuzmt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"munmust":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yan-jie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hktangshuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zpbc007":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linlizzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"krabbejing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"firehaosky":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chao-cc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jinjin680":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cruiseyugh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"quieter2018":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jadeliu13":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaoq777":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiangyanlineu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuxiner":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yufanzh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"franciszq":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kangqinsen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"manwzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jerry9926":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"soso1105":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pkuphy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhenya-zhu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wty9sky":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"skyoct":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bingzxy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaodingc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jyjsunny":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aoxiangw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"enrilwang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aswrise":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aneureka":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ljqchlsw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jingyuzhou123":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dianlandu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jameswangxin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhenxied":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nuozhouzhang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shin-guid":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bochengwan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kyo-tom":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uratora":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guitarys":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sosdogecoin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zol013":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lrwhc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wwewwt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cyk1337":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangyu1131":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"diana21170648":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"61hhh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"quaaaaaack":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"acy925":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bi9potato":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guangsizhongbin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhaoygcq":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"catkathy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yqycs":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhuxinyu-znb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"freesan44":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mo660":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sencc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"randong22":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"beginner-jamji":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yzhyzhyzh123":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunstrongchina":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dongzegithub":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"metsystem":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miller-em":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dorian-byte":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yizhewill":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qiaojunch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhouliuhuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"beanza":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kingxiaozhe":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ygnauh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wzbwzt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iambigchen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weiboshi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"master-guang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jennyjgao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangjay408":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chang-you":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rocjemaintiendrai":[null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/2#issuecomment-2044133557","body":"### 思路\n对数组进行两次遍历。\n第一次从左向右使用一个指针来记录最靠近当前字母左边的c的位置，并记录下距离。\n第二次从右向左同样使用指针来计算当前字母与最靠近的右边的c的距离并与第一次遍历的结果进行对比取最小值。\n\n### 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        final int n = s.length();\n        int pos = -n;\n        int[] res = new int[n];\n\n        for(int i = 0; i < n; i++) {\n            if(s.charAt(i) == c) {\n                pos = i;\n            }\n            res[i] = i - pos;\n        }\n\n        for(int i = pos; i >= 0; i--) {\n            if(s.charAt(i) == c) {\n                pos = i;\n            }\n            res[i] = Math.min(res[i], pos - i);\n        }\n\n        return res;\n    }\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(2N)，两次遍历\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/3#issuecomment-2046502850","body":"### 思路\n额外创建一个数组int[] inc来记录对应的index上增加的值，index = Math.min(k, stack.size()) - 1。 当pop操作时，将pop出的值与inc[i]的值相加返回，inc[i-1]的值要加上inc[i]的值，之后inc[i]变为0.\n\n### 代码\nclass CustomStack {\n    int n;\n    int[] inc;\n    Stack<Integer> stack;\n\n    public CustomStack(int maxSize) {\n        n = maxSize;\n        inc = new int[n];\n        stack = new Stack<>();\n    }\n    \n    public void push(int x) {\n        if(stack.size() < n) {\n            stack.push(x);\n        }\n    }\n    \n    public int pop() {\n        int i = stack.size() - 1;\n        if(i < 0) {\n            return -1;\n        }\n        if(i > 0) {\n            inc[i - 1] += inc[i];\n        }\n        int res = stack.pop() + inc[i];\n        inc[i] = 0;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        int i = Math.min(k, stack.size()) - 1;\n        if(i >= 0) {\n            inc[i] += val;\n        }\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：所有操作均为O(1)\n- 空间复杂度：开了新的数组所以为O(N)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/9#issuecomment-2058193567","body":"### 思路\n快慢指针 + 递归\n\n### 代码\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null) return null;\n        return toBST(head, null);\n    }\n\n    private TreeNode toBST(ListNode head, ListNode tail) {\n        if(head == tail) return null;\n\n        ListNode slow = head;\n        ListNode fast = head;\n        while(fast != tail && fast.next != tail) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        TreeNode newHead = new TreeNode(slow.val);\n        newHead.left = toBST(head, slow);\n        newHead.right = toBST(slow.next, tail);\n        return newHead;\n    }\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(tree height)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ainfinitedz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"christ36":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hengistchan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huiyingc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"andyli4":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"momogir":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jamjid":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"freeroo2":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ycan253":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laurallalala":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"danielyan86":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rennzhang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"larscheng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qingkediguo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"adfvcdxv":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"javajianghu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chloe-c11":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"verkru":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eggeggliu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dr-kkk":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jinhma":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"emergence23":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"0christ1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"junru281":[null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/3#issuecomment-2046543534","body":"Cool. 时隔半年再做, 终于可以很快做出来了. \n\n```python\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.array = []\n\n    def push(self, x: int) -> None:\n        if len(self.array) < self.maxSize:\n            self.array.append(x)\n\n    def pop(self) -> int:\n        if len(self.array) == 0:\n            return -1\n        else:\n            return self.array.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len(self.array))):\n            self.array[i] += val\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/10#issuecomment-2061538300","body":"```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        data = set()\n        while headA:\n            data.add(headA)\n            headA = headA.next\n\n        while headB:\n            if headB in data:\n                return headB\n            else: headB = headB.next\n\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/13#issuecomment-2067696137","body":"```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        # 不用check的原因是,我们已经在leaf node的时候return 0了\n        left_depth = self.maxDepth(root.left)\n        right_depth = self.maxDepth(root.right)\n        return max(left_depth, right_depth) + 1\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joe-the-plumber":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jsaki":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"witerth":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ludwig-ll":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luster-lyl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"smallppgirl":[{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/1#issuecomment-2043123861","body":"思路： 遍历 数组和整数k的每一个数字，然后逐位相加，如果遇到进位，加在下一轮\n算法\n\n```python\nclass Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        i = len(A) - 1\n        while K:\n            A[i] += K\n            K, A[i] = A[i] // 10, A[i] % 10\n            i -= 1\n\n            if i < 0 and K:\n                A.insert(0,0)\n                i = 0\n        return A\n```\n\n时间复杂：O(len(num)+len(K))\n空间复杂： O(max(len(num)+len(K)))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/2#issuecomment-2045543788","body":"思路：遍历找到所有的c存入listc，然后遍历整个list依次计算所有绝对值差，找出最小的追加进入一个新的list\r\n\r\n代码\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        cpos = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                cpos.append(i)\r\n        for i in range(len(s)):\r\n            nearest = len(s)\r\n            for p in cpos:\r\n                dis = abs(i-p)\r\n                if dis < nearest:\r\n                    nearest = dis\r\n            res.append(nearest)\r\n        return res\r\n                \r\n```\r\n\r\n时间复杂度： O(nm)  #m 是c 的个数\r\n空间： O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/4#issuecomment-2050014346","body":"思路： stack \n代码：\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        res = \"\"\n        mul = 0\n        for ch in s:\n            if ch == \"[\":\n                stack.append((mul, res))\n                res, mul = \"\", 0\n            elif ch == \"]\":\n                cur_mul, last_res = stack.pop()\n                res = last_res + cur_mul * res\n            elif \"0\" <= ch <= \"9\":\n                mul = mul * 10 + int(ch)\n            else:\n                res += ch\n        return res\n```\n\n时间 ：O(n)\n空间： O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/6#issuecomment-2053676862","body":"思路：未排序 数组 和排序数组 遍历，当满足前N个元素出现频次完全一致， 则前N 个元素可以成为一组，以此遍历整个数组找出一共多少组\n\n代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        cnt = Counter()\n        res = 0\n        for a, b in zip(arr, sorted(arr)):\n            cnt[a] += 1\n            if cnt[a] == 0:\n                del cnt[a]\n            cnt[b] -= 1\n            if cnt[b] == 0:\n                del cnt[b]\n            if len(cnt) == 0:\n                res += 1\n        return res\n```\n时间复杂 O(nlogn), 排序复杂度为 O(nlogn)\n空间复杂度 O(n), ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/8#issuecomment-2057199061","body":"class Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        newHead = head.next\n        head.next = self.swapPairs(newHead.next)\n        newHead.next = head\n        return newHead\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/11#issuecomment-2064328518","body":"思路 快慢指针\r\n\r\n代码\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        f, s = head, head\r\n        while True:\r\n            if not (f and f.next): \r\n                return\r\n            f, s = f.next.next, s.next\r\n            if f == s:\r\n                break\r\n        f = head\r\n        while f != s:\r\n            f, s = f.next, s.next\r\n        return f\r\n```\r\n时间 O(n)\r\n空间 O(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/16#issuecomment-2072783328","body":"思路： 广度优先搜索(BFS), 利用deque \n代码\n```python\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        q = deque([root])\n        while q:\n            node = q.popleft()\n            if node.right: q.append(node.right)\n            if node.left:  q.append(node.left)\n        return node.val\n```\n时间复杂 ： O(n)\n空间复杂： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/17#issuecomment-2075311965","body":"```python\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        res = \"\"\n        if not root:\n            return res\n        q = collections.deque()\n        q.append(root)\n        while q:\n            node = q.popleft()\n            if node:\n                res = res + str(node.val) + \",\"\n                q.append(node.left)\n                q.append(node.right)\n            else:\n                res = res + \"null,\"\n        return res.rstrip(\",\")\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        if not data:\n            return\n        data_l = data.split(\",\")\n        q = collections.deque()\n        i = 1\n        root = TreeNode(int(data_l[0]))\n        q.append(root)\n        while q:\n            node = q.popleft()\n            if data_l[i] != \"null\":\n                node.left = TreeNode(int(data_l[i]))\n                q.append(node.left)\n            i += 1\n            if data_l[i] != \"null\":\n                node.right = TreeNode(int(data_l[i]))\n                q.append(node.right)\n            i += 1\n        return root\n```","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/20#issuecomment-2077722215","body":"思路： 哈希表 ， 依次把元素 加入哈希表， 直到找到正确结果\n\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        n_dict = {}\n        for i in range(len(nums)):\n            if target - nums[i] in n_dict:\n                return [n_dict[target - nums[i]], i]\n            n_dict[nums[i]] = i\n        return []\n                \n```\n时间复杂 O(n)   遍历所有元素\n空间复杂 O(n)  哈希表最大 n 个值","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/23#issuecomment-2083092787","body":"滑动窗口\r\n```py\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        if not s:return 0\r\n        left = 0\r\n        lookup = set()\r\n        n = len(s)\r\n        max_len = 0\r\n        cur_len = 0\r\n        for i in range(n):\r\n            cur_len += 1\r\n            while s[i] in lookup:\r\n                lookup.remove(s[left])\r\n                left += 1\r\n                cur_len -= 1\r\n            if cur_len > max_len:max_len = cur_len\r\n            lookup.add(s[i])\r\n        return max_len\r\n```\r\n时间O(n) 空间O(k)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/26#issuecomment-2090847865","body":"思路： 快慢指针\n代码：\n```py\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head.next is None:\n            return head\n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n```\n时间复杂 O(n) \n空间复杂 O(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/31#issuecomment-2098779025","body":"广度优先染色\r\n```py\r\nclass Solution:\r\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\r\n        g = [[] for _ in range(n)]\r\n        for x, y in dislikes:\r\n            g[x - 1].append(y - 1)\r\n            g[y - 1].append(x - 1)\r\n        color = [0] * n  # color[x] = 0 表示未访问节点 x\r\n        for i, c in enumerate(color):\r\n            if c == 0:\r\n                q = deque([i])\r\n                color[i] = 1\r\n                while q:\r\n                    x = q.popleft()\r\n                    for y in g[x]:\r\n                        if color[y] == color[x]:\r\n                            return False\r\n                        if color[y] == 0:\r\n                            color[y] = -color[x]\r\n                            q.append(y)\r\n        return True\r\n```\r\n时间复杂 O(n+m)\r\n空间复杂 O)m+n)\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/33#issuecomment-2100992480","body":"思路 模拟\n代码\n```py\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        x = y = 0\n        for move in moves:\n            if move == 'U': y += 1\n            elif move == 'D': y -= 1\n            elif move == 'L': x -= 1\n            elif move == 'R': x += 1\n\n        return x == y == 0\n```\n时间复杂 O(n)\n空间复杂 O(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/38#issuecomment-2110519591","body":"思路 二分查找\n\n代码 \n```py\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        if x < 2:\n            return x\n        left, right = 1, x\n        while left + 1 < right:\n            mid = (left + right) // 2\n\n            if mid * mid > x:\n                right = mid\n            elif mid * mid == x:\n                return mid\n            else:\n                left = mid\n        return left\n```\n时间 O(logN)\n空间: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/39#issuecomment-2112803796","body":"思路： 二分法\n\n代码\n```py\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        left, right = 1, n\n        while left + 1 < right:\n            mid = (left + right) // 2\n            if isBadVersion(mid):\n                right = mid\n            else:\n                left = mid\n        \n        if isBadVersion(left):\n            return left\n        else:\n            return right\n```\n\n时间复杂: O(log(n))\n空间复杂: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/68#issuecomment-2163524931","body":"思路： 贪心法\n代码\n```py\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        n, rightmost = len(nums), 0\n        for i in range(n):\n            if i <= rightmost:\n                rightmost = max(rightmost, i + nums[i])\n                if rightmost >= n - 1:\n                    return True\n        return False\n```\n时间复杂 O(n)\n空间复杂 O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/71#issuecomment-2171752733","body":"```python\r\nclass Solution:\r\n    def beautifulArray(self, n: int) -> List[int]:\r\n        memo = {1: [1]}\r\n        def f(N):\r\n            if N not in memo:\r\n                odds = f((N+1)//2)\r\n                evens = f(N//2)\r\n                memo[N] = [2*x-1 for x in odds] + [2*x for x in evens]\r\n            return memo[N]\r\n        return f(n)\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/72#issuecomment-2173780268","body":"class Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        xorsum = 0\n        for num in nums:\n            xorsum ^= num\n        \n        lsb = xorsum & (-xorsum)\n        type1 = type2 = 0\n        for num in nums:\n            if num & lsb:\n                type1 ^= num\n            else:\n                type2 ^= num\n        \n        return [type1, type2]\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/76#issuecomment-2182913880","body":"```py\r\nclass Trie:\r\n    def __init__(self, words):\r\n        self.d = {}\r\n        for word in words:\r\n            t = self.d\r\n            for w in word:\r\n                if w not in t:\r\n                    t[w] = {}\r\n                t = t[w]\r\n            t['end'] = word\r\n    \r\n    def search(self, s):\r\n        t = self.d\r\n        res = []\r\n        for w in s:\r\n            if w not in t:\r\n                break\r\n            t = t[w]\r\n            if 'end' in t:\r\n                res.append(t['end'])\r\n        return res\r\n\r\nclass Solution:\r\n    def multiSearch(self, big: str, smalls: List[str]) -> List[List[int]]:\r\n        trie = Trie(smalls)\r\n        hit = collections.defaultdict(list)\r\n\r\n        for i in range(len(big)):\r\n            matchs = trie.search(big[i:])\r\n            for word in matchs:\r\n                hit[word].append(i)\r\n        \r\n        res = []\r\n        for word in smalls:\r\n            res.append(hit[word])\r\n        return res\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/82#issuecomment-2194833080","body":"```py\nclass Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        def backtrack(\n            state: list[int], target: int, choices: list[int], start: int, res: list[list[int]]\n        ):\n            \"\"\"回溯算法：子集和 II\"\"\"\n            # 子集和等于 target 时，记录解\n            if target == 0:\n                res.append(list(state))\n                return\n            # 遍历所有选择\n            # 剪枝二：从 start 开始遍历，避免生成重复子集\n            # 剪枝三：从 start 开始遍历，避免重复选择同一元素\n            for i in range(start, len(choices)):\n                # 剪枝一：若子集和超过 target ，则直接结束循环\n                # 这是因为数组已排序，后边元素更大，子集和一定超过 target\n                if target - choices[i] < 0:\n                    break\n                # 剪枝四：如果该元素与左边元素相等，说明该搜索分支重复，直接跳过\n                if i > start and choices[i] == choices[i - 1]:\n                    continue\n                # 尝试：做出选择，更新 target, start\n                state.append(choices[i])\n                # 进行下一轮选择\n                backtrack(state, target - choices[i], choices, i + 1, res)\n                # 回退：撤销选择，恢复到之前的状态\n                state.pop()\n\n        state = []  # 状态（子集）\n        candidates.sort()  # 对 candidates 进行排序\n        start = 0  # 遍历起始点\n        res = []  # 结果列表（子集列表）\n        backtrack(state, target, candidates, start, res)\n        return res\n```","onTime":true},null,null,null,null,null,null,null,null,null,null],"realduxy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"awilekong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wwz223":[{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/1#issuecomment-2041912942","body":"```javascript\r\nvar addToArrayForm = function (num, k) {\r\n  const knum = k.toString().split('').reverse();\r\n  num = num.reverse();\r\n  const max = Math.max(num.length, knum.length);\r\n  let isUp = 0;\r\n  let ni = 0,\r\n    ki = 0,\r\n    sub = 0;\r\n  for (let i = 0; i < max; i++) {\r\n    ni = Number(num[i]) || 0;\r\n    ki = Number(knum[i]) || 0;\r\n    sub = ni + ki + isUp;\r\n    num[i] = sub % 10;\r\n    isUp = Number(sub >= 10);\r\n  }\r\n  if (isUp) num.push(1);\r\n  return num.reverse();\r\n};\r\n```\r\n\r\ntime：O(n)\r\nspace：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/2#issuecomment-2044684145","body":"### 思路\n采用双指针的方式进行求解，分别从两个方向进行遍历，头部 -> 尾部，尾部 -> 头部，通过取最小值的方式将之前保存的距离进行覆盖\n\n### 代码\n```var shortestToChar = function (s, c) {\n  let i = 0;\n  let k = s.length - 1;\n  let iKey = -1;\n  let kKey = -1;\n  let arr = [];\n  while (i < s.length) {\n    if (s[i] !== c) {\n      arr[i] = Math.min(iKey >= 0 ? i - iKey : 10000, arr[i] || 10000);\n    } else {\n      iKey = i;\n      arr[i] = 0;\n    }\n    if (s[k] !== c) {\n      arr[k] = Math.min(kKey >= 0 ? kKey - k : 10000, arr[k] || 10000);\n    } else {\n      kKey = k;\n      arr[k] = 0;\n    }\n    i++;\n    k--;\n  }\n  return arr;\n};\n```\n### 复杂度分析\n\n时间复杂度：使用了一层循环 O(N)\n空间复杂度：创建了一个数组和多个变量，数组长度为s的长度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/3#issuecomment-2047192573","body":"```javascript\nclass CustomStack {\n  constructor(maxSize) {\n    this.maxSize = maxSize;\n  }\n  /**\n   * 最大值\n   * @param {number} maxSize\n   */\n  maxSize = 0;\n  /**\n   * 栈空间\n   */\n  stack = [];\n  /**\n   * 初始化\n   * @param {number} maxSize\n   */\n  /**\n   * 入栈\n   * @param {number} maxSize\n   * @return {void}\n   */\n  push(x) {\n    if (this.stack.length < this.maxSize) this.stack.push(x);\n    return null;\n  }\n  /**\n   * 出栈\n   * @param {number} x\n   * @return {number}\n   */\n  pop(x) {\n    if (this.stack.length > 0) return this.stack.pop();\n    return -1;\n  }\n  /**\n   * 增加值操作\n   * @param {number} k\n   * @param {number} val\n   */\n  increment(k, val) {\n    for (let i = 0; i < k && i < this.stack.length; i++) {\n      this.stack[i] += val;\n    }\n    return null;\n  }\n}\n\n// 输入：\nconst action = ['CustomStack', 'push', 'push', 'pop', 'push', 'push', 'push', 'increment', 'increment', 'pop', 'pop', 'pop', 'pop'];\nconst param = [[3], [1], [2], [], [2], [3], [4], [5, 100], [2, 100], [], [], [], []];\n\nconst run = (action, param) => {\n  let stack = null;\n  let result = [];\n  let res = null;\n  action.map((a, i) => {\n    if (a === 'CustomStack') {\n      stack = new CustomStack(...param[i]);\n      res = null;\n    } else {\n      res = stack[a](...param[i]);\n    }\n\n    result.push(res);\n  });\n  return result;\n};\n\nconsole.log(run(action, param));\n```\n\n### 复杂度分析\n时间复杂度： push、pop: O(1)   increment：O(k)\n空间复杂度：O(maxsize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/4#issuecomment-2049536790","body":"### 思路\n定义了三个栈空间，分别存放返回数据、循环次数数组、left坐标数组，通过同步进栈出栈保持同步\n\n\n### 答案\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function (s) {\n  let stack = [];\n  let numsStack = [];\n  let leftStack = [];\n  let num = 0;\n  let left = 0;\n  for (let i = 0; i < s.length; i++) {\n    k = s[i];\n    if (k === '[') {\n      numsStack.push(num);\n      leftStack.push(i);\n      num = 0;\n    } else if (k === ']') {\n      num = numsStack.pop();\n      left = leftStack.pop();\n\n      num--;\n      if (num > 0) {\n        i = left - 1;\n      }\n    } else if (!isNaN(Number(k))) {\n      num = num > 0 ? num * 10 + Number(k) : Number(k);\n    } else {\n      num = 0;\n      stack.push(k);\n    }\n  }\n  return stack.join('');\n};\n```\n \n### 复杂度分析  O(n2)\n### 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/5#issuecomment-2051571539","body":" ## 代码\n```javascript\nclass Stack {\n  constructor() {\n    this.stack = [];\n  }\n  push(x) {\n    this.stack.push(x);\n  }\n  pop() {\n    return this.stack.pop();\n  }\n  size() {\n    return this.stack.length;\n  }\n\n  empty() {\n    return this.stack.length === 0;\n  }\n}\n\nclass MyQueue {\n  constructor() {\n    this.stack = new Stack();\n    this.queue = new Stack();\n  }\n\n  push(x) {\n    this.queue.push(x);\n  }\n\n  pop() {\n    if (this.queue.size() === 0) return null;\n    while (this.queue.size() > 1) {\n      this.stack.push(this.queue.pop());\n    }\n    const head = this.queue.pop();\n    while (this.stack.size() > 0) {\n      this.queue.push(this.stack.pop());\n    }\n    return head;\n  }\n  peek() {\n    if (this.queue.size() === 0) return null;\n    while (this.queue.size() > 1) {\n      this.stack.push(this.queue.pop());\n    }\n    const head = this.queue.pop();\n    this.queue.push(head)\n    while (this.stack.size() > 0) {\n      this.queue.push(this.stack.pop());\n    }\n    return head;\n  }\n  empty() {\n    return this.queue.size() === 0;\n  }\n}```\n\n时间复杂度\npush：O(1)\npop：O(2N) 两次循环\npeek: O(2N) 两次循环\n\n空间复杂度  O（1）\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/8#issuecomment-2056636366","body":"### 代码\n\n```js\nvar swapPairs = function (head) {\n    if (head === null || head.next === null) return head;\n\n    let tmp = head.next;\n    head.next = swapPairs(tmp.next);\n    tmp.next = head;\n    return tmp;\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度 O（N）\n- 空间复杂度 每两个节点的交换需要借助一个节点， O（1/2N）\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/10#issuecomment-2060990707","body":"### 思路\n先循环headA，把链表1的所有节点保存起来，然后遍历链表2，找到相同的节点，返回该节点的next\n\n### 代码\n\n```js\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function (headA, headB) {\n    const visited = new Set();\n    let temp = headA;\n    while (temp !== null) {\n        visited.add(temp);\n        temp = temp.next;\n    }\n    temp = headB;\n\n    while (temp !== null) {\n        if (visited.has(temp)) {\n            return temp;\n        }\n        temp = temp.next;\n    }\n\n    return null\n};\n```\n\n### 复杂度分析\n\n- 时间复杂度: O(m + n)\n- 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/11#issuecomment-2063536306","body":"### 代码\n```javascript\nvar detectCycle = function (head) {\n  let temp = head;\n  const set = new Set();\n  while (temp) {\n    if (set.has(temp)) return temp;\n    set.add(temp);\n    temp = temp.next;\n  }\n  return null\n};\n```\n\n### 复杂度分析\n时间复杂度 O（N）\n空间复杂度O（N）\n\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/13#issuecomment-2069053458","body":"```javascript\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function(root) {\r\n    let i = 0\r\n    const getDepth = (node,index)=>{\r\n        if(!root || root.val === null) return index\r\n        index ++ \r\n        let left  = index\r\n        let right = index\r\n        if(node.left) {\r\n            left = getDepth(node.left,index)\r\n        }\r\n        if (node.right){\r\n           right = getDepth(node.right,index)\r\n        }\r\n        return Math.max(left,right) \r\n    }\r\n  \r\n    return getDepth(root, 0)\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/16#issuecomment-2071807515","body":"### 思路\n采用深度遍历的方式，从右子节点开始深度遍历，记录left值和maxDeep的值，采用从右往左的方式的目的是为了遍历同一层级的时候左节点值可以对右节点值进行覆盖，这里的核心逻辑就是判断当前deep是否大于等于maxDeep，如果大于则代表是更深的一层，所以对left进行一个重新赋值\n\n### 代码\n\n```js\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar findBottomLeftValue = function(root) {\n    let left = root.val; \n    let maxDeep = 0;\n    const order = (node, deep) => {\n        if(!node || node.val === null) return \n        if(deep >= maxDeep){\n            maxDeep = deep\n            left = node.val\n        }\n        order(node.right, deep + 1);\n        order(node.left, deep + 1);\n    }\n    order(root,1)\n    return left\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度 O(N) N为二叉树的节点个数\n- 空间复杂度 O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/18#issuecomment-2077012632","body":"```javascript\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar verticalTraversal = function (root) {\n    let arr1 = []\n    let arr2 = []\n    let order = (node, deep) => {\n        if (!node || node.val === null) return\n        let newArr = []\n        let arr1c = arr1[deep]\n        let arr2c = arr2[Math.abs(deep) - 1]\n        if (deep >= 0) {\n            if (!arr1[deep]) {\n                arr1[deep] = [node.val]\n                arr1c = arr1[deep]\n            } else {\n                if (arr1c[arr1c.length - 1] <= node.val) {\n                    newArr = arr1[deep]\n                    newArr.push(node.val)\n                } else {\n                    arr1c.map((i) => {\n                        if (node.val < i) {\n                            newArr.push(node.val)\n                        }\n                        newArr.push(i)\n                    })\n                }\n                arr1c = newArr\n            }\n            arr1[deep] = arr1c\n        } else {\n            if (!arr2[Math.abs(deep) - 1]) {\n                arr2[Math.abs(deep) - 1] = [node.val]\n                arr2c = arr2[Math.abs(deep) - 1]\n            } else {\n\n                if (arr2c[arr2c.length - 1] <= node.val) {\n                    newArr = arr2[deep]\n                    newArr.push(node.val)\n                } else {\n                    arr2c.map((i) => {\n                        if (node.val < i) {\n                            newArr.push(node.val)\n                        }\n                        newArr.push(i)\n                    })\n                }\n                arr2c = newArr\n            }\n            arr2[Math.abs(deep) - 1] = arr2c\n        }\n        node.left && order(node.left, deep - 1)\n        node.right && order(node.right, deep + 1)\n    }\n    order(root, 0)\n    return [...arr2.reverse(), ...arr1]\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/20#issuecomment-2079218817","body":"### 思路\n遍历数组，将数组值作为下标，数组下标作为值保存在hash数组中，值的数据结构是数组，遍历的过程中获取当前值与target的差，在已存在的hash数组中进行获取，如果没有该值，则循环继续，如果该值存在，则放回对应的两个下标，值的数据结构为数组，目的是解决数组中有两个相同值的问题\n\n### 代码\n```javascript\nvar twoSum = function (nums, target) {\n    let hash = []\n    let res = []\n    for (let i = 0; i < nums.length; i++) {\n        const val = nums[i]\n        if (hash[val] !== undefined) {\n            hash[val].push(i)\n        } else {\n            hash[val] = [i]\n        }\n        const num = target - val\n        if (hash[num] === undefined || (hash[num].length === 1 && hash[num][0] === i)) {\n            continue\n        }\n        if (num === val) {\n            res = hash[num]\n            break\n        } else {\n            res = [hash[num], i]\n            break\n        }\n    }\n    return res\n};  \n```\n\n### 复杂度\n时间复杂度：O(N) 只需要一次循环\n空间复杂度：O(N) 取决于nums数组长度\n\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/25#issuecomment-2088010880","body":"```js\n/**\n * @param {number[]} nums\n * @param {number} p\n * @return {number}\n */\nvar minSubarray = function (nums, p) {\n    let x = 0\n    for (const num of nums) {\n        x = (x + num) % p\n    }\n    if (x === 0) {\n        return 0\n    }\n    const index = new Map()\n    let y = 0; res = nums.length\n    for (let i = 0; i < nums.length; i++) {\n        index.set(y, i)\n        y = (y + nums[i]) % p\n        if (index.has((y - x + p) % p)) {\n            res = Math.min(res, i - index.get((y - x + p) % p) + 1)\n        }\n    }\n    return res === nums.length ? -1 : res\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/31#issuecomment-2098154889","body":"```js\n/**\n * @param {number} n\n * @param {number[][]} dislikes\n * @return {boolean}\n */\n\nvar possibleBipartition = function(n, dislikes) {\n    if(n==1){\n        return true\n    }\n    dislikes= dislikes.sort((a,b)=>Math.min(a[0],a[1])-Math.min(b[0],b[1]))\n    let list1=[],list2=[]\n    for(let i = 0;i<dislikes.length;i++){\n        let max =Math.max(dislikes[i][0],dislikes[i][1]),min =Math.min(dislikes[i][0],dislikes[i][1])\n        let u1 = list1.indexOf(min)!=-1,u2 = list2.indexOf(min)!=-1\n        if(u1||u2){\n            if(u1){\n                if(list1.indexOf(max)!=-1){\n                    return false\n                }\n                list2.push(max)  \n                \n            }else\n            if(u2){\n                if(list2.indexOf(max)!=-1){\n                    return false\n                }\n                list1.push(max) \n            }  \n        }else list1=[min],list2=[max]\n        \n    }\n    return true\n};\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/38#issuecomment-2110461710","body":"```js\n/**\n * @param {number} x\n * @return {number}\n */\nvar mySqrt = function (x) {\n  let left = 0, right = x;\n  // 左闭右闭区间\n  while (left <= right) {\n    let mid = left + ((right - left) >> 1)\n    if (mid * mid < x) {\n      left = mid + 1\n    } else right = mid - 1\n  }\n  return left * left > x ? left - 1 : left\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/44#issuecomment-2120163431","body":"```js\nvar maxVowels = function(s, k) {\n    // arr1 = s.split(\"\")\n    let arr2 = 'aeiou'.split(\"\")\n    let count = 0 \n    let resArr = []\n\n    // 先计数前k位的元音字母的个数\n    for(let i = 0; i < k; i++) {\n        if(arr2.includes(s[i])){\n            count++\n        }\n    }\n\n    // 再计数前k位后面的元音字母的个数\n    let maxCount = count\n    for(let i = k; i < s.length; i++) {\n        if(arr2.includes(s[i])){\n            count++\n        }\n        // 判断滑过的那位是不是元音\n        if(arr2.includes(s[i-k])){\n            count--\n        }\n        maxCount = Math.max(maxCount, count)\n    }\n    return maxCount\n};\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/51#issuecomment-2132685810","body":"```js\nfunction maxAreaOfIsland(grid: number[][]): number {\n    const row:number = grid.length,\n        col:number = grid[0].length;\n    \n    let maxIsland:number = 0;\n    \n    interface IDfs {\n        (i:number, j:number):number\n    }\n\n    const dfs:IDfs = (i, j) => {\n\n        // 边界判断\n        let iJudge:boolean = i < 0 || i >= row,\n            jJudge:boolean = j < 0 || j >= col;\n \n        if (iJudge || jJudge || grid[i][j] === 0) {\n            // 不符合条件则 直接返回0\n            return 0;\n        }\n\n        // 遍历过的节点置 0 防止多次计数\n        grid[i][j] = 0;\n        let cntIsland:number = 1;\n\n        cntIsland += dfs(i - 1, j) + dfs(i + 1, j) + dfs(i, j - 1) + dfs(i, j + 1);\n\n        return cntIsland;\n    }\n\n    // 遍历地图(因遍历过后的节点都为0，不会重复遍历)，并取最大值\n    for(let i:number = 0; i < row; i++) {\n        for (let j:number = 0; j < col; j++) {\n            maxIsland = Math.max(maxIsland, dfs(i,j));\n        }\n    }\n\n    return maxIsland;\n\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangjinzhepro":[{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/1#issuecomment-2042264449","body":"## 题解\r\n\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n  const arr = [];\r\n  let carry = 0;\r\n  for (let i = num.length - 1; i >= 0; i--) {\r\n    let sum = num[i] + k % 10 + carry;\r\n    carry = Math.floor(sum / 10);\r\n    sum = sum % 10;\r\n    arr.unshift(sum);\r\n    k = Math.floor(k / 10); \r\n  }\r\n\r\n  for (; k > 0 || carry > 0 ;) {\r\n    let sum = k % 10 + carry;\r\n    carry = Math.floor(sum / 10);\r\n    arr.unshift(sum % 10);\r\n    k = Math.floor(k / 10);\r\n  }\r\n\r\n  return arr;\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n时间复杂度： 取决于num的长度和k的大小(取最大)：O(n)\r\n空间复杂度：常量忽略，只定义了一个arr：O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/2#issuecomment-2044578441","body":"## 题解\n```js\nfunction shortestToChar(s, c) {\n  var arr = new Array(s.length);\n  var left = -Infinity\n  var right = s.indexOf(c)\n  for (var i = 0; i < s.length; i++) {\n    if(i === right){\n      left = right\n      right = s.indexOf(c, right+1)\n    }\n    arr[i] = Math.min(right < 0 ? Infinity : right - i, i - left)\n  }\n  console.log(arr)\n  return arr\n}\n```\n\n## 复杂度分析\n双指针，只有一次循环，时间复杂度O(n)\n空间复杂度取决去数据规模 O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/3#issuecomment-2046658210","body":"## 题解\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.stack = []\n  this.length  = maxSize\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if(this.stack.length !== this.length){\n    this.stack.push(x);\n  }\n\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  if(this.stack.length === 0) return -1\n  return this.stack.pop();\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  const l =  k  > this.stack.length ? this.stack.length : k\n  for(let i = 0; i < l; i++) {\n    this.stack[i] += val\n  }\n};\n\n```\n\n## 复杂度\n时间复杂度：push、pop O(1) increment O(n)\n空间复杂度：push、pop O(1) increment O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/4#issuecomment-2049545313","body":"## 思路\n使用栈结构，存放string和num，然后匹配`]`依次推出\n```js\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n  var stack = []\n  var string = ''\n  var num = 0\n  for (var i = 0; i < s.length; i++) {\n    if(!isNaN(s[i])) {\n      num = num * 10 + Number(s[i])\n    }else if(s[i] === '[') {\n      stack.push([string, num])\n      string = ''\n      num = 0\n    }else if(s[i] === ']'){\n      const val = stack.pop()\n      string = val[0] + string.repeat(val[1])\n    }else{\n      string += s[i]\n    }\n  }\n  console.log(string)\n  return string\n};\n```\n\n## 复杂度\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/5#issuecomment-2052022040","body":"```js\n\nvar MyQueue = function() {\n    this.stack1 = []; \n    this.stack2 = []; \n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.stack1.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if (this.stack2.length === 0) {\n        while (this.stack1.length > 0) {\n            this.stack2.push(this.stack1.pop());\n        }\n    }\n    return this.stack2.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if (this.stack2.length === 0) {\n        while (this.stack1.length > 0) {\n            this.stack2.push(this.stack1.pop());\n        }\n    }\n    return this.stack2[this.stack2.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.stack1.length === 0 && this.stack2.length === 0;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n\n时间复杂度 push, pop, peek, O(N); empty O(1)\n空间复杂度 O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/7#issuecomment-2056944475","body":"```js\r\nvar rotateRight = function(head, k) {\r\n    if (!head || !head.next || k === 0) {\r\n        return head;\r\n    }\r\n\r\n    let length = 1;\r\n    let tail = head;\r\n    while (tail.next) {\r\n        tail = tail.next;\r\n        length++;\r\n    }\r\n\r\n    k = k % length;\r\n\r\n    if (k === 0) {\r\n        return head;\r\n    }\r\n\r\n    tail.next = head;\r\n\r\n    let newTail = head;\r\n    for (let i = 0; i < length - k - 1; i++) {\r\n        newTail = newTail.next;\r\n    }\r\n\r\n    let newHead = newTail.next;\r\n\r\n    newTail.next = null;\r\n\r\n    return newHead;\r\n};\r\n\r\n```\r\n\r\n时间复杂度O(n) 空间复杂度O(1)","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"atom-set":[{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/1#issuecomment-2042268392","body":"### 思路\r\n\r\n这个题目可以理解为大数相加的变形。\r\n\r\n- step1: 去 num 和 k 的最大长度\r\n- step2: 对 num 和 k(k 需要转换为数组) 进行前置补 0\r\n- step3: 逆序遍历按位相加，同时需要考虑是否有进位(大于 9，即有进位)\r\n\r\n### 代码\r\n\r\n```js\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n  if (num === 0) return k;\r\n\r\n  // k 计算 k 的长度\r\n  var kLen = 0;\r\n  var secondNum = [];\r\n  var firstNum = [];\r\n  var kLen = String(k).length;\r\n  // 最大长度\r\n  var maxLen = num.length > kLen ? num.length : kLen;\r\n\r\n  // 补0\r\n  for (var j = maxLen - 1; j >= 0; j--) {\r\n    if (j > num.length - 1) {\r\n      firstNum.push(0);\r\n    } else {\r\n      firstNum.push(num.shift());\r\n    }\r\n  }\r\n\r\n  for (var i = maxLen - 1; i >= 0; i--) {\r\n    if (i > kLen.length - 1) {\r\n      secondNum.push(0);\r\n    } else {\r\n      secondNum.unshift(k % 10);\r\n      k = (k - (k % 10)) / 10;\r\n    }\r\n  }\r\n\r\n  // 遍历相加\r\n  var bit = 0;\r\n  for (var k = maxLen - 1; k >= 0; k--) {\r\n    var sum = firstNum[k] + secondNum[k] + bit;\r\n    if (sum >= 10) {\r\n      secondNum[k] = sum % 10;\r\n      bit = (sum - (sum % 10)) / 10;\r\n    } else {\r\n      bit = 0;\r\n      secondNum[k] = sum;\r\n    }\r\n  }\r\n\r\n  if (bit > 0) {\r\n    return [bit, ...secondNum];\r\n  }\r\n\r\n  return secondNum;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n对数据进补 0 和按位相加，进行了遍历，时间复杂度为 O(N)；\r\n\r\n声明了 firstNum 和 secondNum 临时变量存放数据，空间负责度为 O(N)\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/2#issuecomment-2044488976","body":"### 思路\r\n\r\n- 基本思想：从题目里可以得知，会用到回溯思想：字符 C 出现不止一次，当第 N + 1 次 (N >=1) 出现时，需要进行判断第 N + 1 次出现的位置和 第 N 次出现的位置之间的元素距离进行比对，取最小的那个距离。\r\n- 数据结构\r\n  - 栈: 结果存到到堆栈里，因为回溯会用到数据结果栈\r\n  - 队列: 从栈顶弹窗的元素，再次进栈需要用队列，先出栈的元素先进栈\r\n\r\n### 代码\r\n\r\n```js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n  // 存放结果\r\n  var res = [];\r\n  var targetPos = -1;\r\n\r\n  // step1: 先将 s 转换成数组\r\n  var sArr = s.split(\"\");\r\n\r\n  // step2: 遍历 sArr\r\n  for (var i = 0; i < sArr.length; i++) {\r\n    if (sArr[i] !== c) {\r\n      // 长度默认设置为 1\r\n      res.push(\r\n        targetPos === -1\r\n          ? 10000\r\n          : Math.abs(i - (targetPos === -1 ? 0 : targetPos))\r\n      );\r\n      continue;\r\n    }\r\n    console.log(\"step1: res:\", res, targetPos, i);\r\n\r\n    if (sArr[i] === c) {\r\n      var tempArr = [];\r\n      // 先出栈到距离为0的元素\r\n      while (res.length > 0 && res[res.length - 1] !== 0) {\r\n        tempArr.unshift(res.pop());\r\n      }\r\n      console.log(\"step2: tempArr:\", tempArr);\r\n\r\n      // 再次进栈校验距离\r\n      while (tempArr.length > 0) {\r\n        var len = tempArr.length;\r\n        const head = tempArr.shift();\r\n        console.log(\"head:\", head);\r\n        if (head > len) {\r\n          res.push(len);\r\n        } else {\r\n          res.push(head);\r\n        }\r\n      }\r\n      res.push(0);\r\n      console.log(\"step3: res:\", res, targetPos, i);\r\n      targetPos = i;\r\n      continue;\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n空间复杂度取决于临时队列的长度，即 O(N)\r\n\r\n时间复杂度取决于回溯元素的长度，即 O(N)，遍历的时间复杂度也是 O(N)，这 2 个是叠加关系，及时间复杂度是 O(N)\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/3#issuecomment-2046743925","body":"\r\n### 思路\r\n\r\n- 栈的结构特性: 先进先出，只能从一端进栈和出栈\r\n- 自定义栈类的要求:\r\n  - 限制了栈的长度，栈满了就不允许进栈\r\n  - 新增了 inc 操作\r\n\r\n可以借助数组数据结构模拟栈，进栈调用 `push` API，出栈调用 `pop` API。进栈的时候判断数组长度是不是大于 maxSize， 出栈的时候判断数组长度是否为 0\r\n\r\n### 代码\r\n\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n  this.maxSize = maxSize;\r\n  this.stack = [];\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.stack.length < this.maxSize) {\r\n    this.stack.push(x);\r\n  }\r\n  return null;\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n  if (this.stack.length > 0) {\r\n    return this.stack.pop();\r\n  }\r\n  return -1;\r\n};\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n  var temp = [];\r\n  for (let i = 0; i < k; i++) {\r\n    if (this.stack.length > 0) {\r\n      temp.push(this.stack.shift());\r\n    }\r\n  }\r\n\r\n  while (temp.length > 0) {\r\n    const v = temp.pop();\r\n    this.stack.unshift(v + val);\r\n  }\r\n  return null;\r\n};\r\n...\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度\r\n  - 初始化（构造函数）: O(1)\r\n  - push: O(1)\r\n  - pop: O(1)\r\n  - inc: O(k)\r\n- 空间复杂度：O(maxSize) [这里用到了一个长度为 maxSize 的数组作为辅助空间]\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/4#issuecomment-2048884473","body":"\r\n### 思路\r\n\r\n- 可以理解为括号匹配的升级版\r\n- 遍历字符串，借助数组存放过程态\r\n- 逆向遍历字符串，寻找 `[ ]` 之间包裹的字符串\r\n- 继续往前寻找数字，遇到字符结束\r\n\r\n### 代码\r\n\r\n```js\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function (s) {\r\n  var num = [];\r\n  var stack = [];\r\n  var len = String(s).length;\r\n  // 标识是否遇到\r\n  var flag = 0;\r\n\r\n  for (var p = len - 1; p >= 0; p--) {\r\n    var ch = s.charAt(p);\r\n    // 非数字进入\r\n    if (isNaN(Number(ch))) {\r\n      if (flag === 0) {\r\n        stack.push(ch);\r\n        continue;\r\n      }\r\n\r\n      // 数字\r\n      var k = Number(num.join(\"\"));\r\n      var stop = false;\r\n      var sub = [];\r\n      // console.log(\"k:\", stack, k);\r\n\r\n      while (!stop) {\r\n        var t = stack.pop();\r\n        if (t === \"[\") {\r\n          continue;\r\n        }\r\n        if (t === \"]\") {\r\n          // 重复 k 次\r\n          for (var n = 0; n < k; n++) {\r\n            stack.push(sub.join(\"\"));\r\n          }\r\n          stop = true;\r\n          continue;\r\n        } else {\r\n          sub.push(t);\r\n        }\r\n      }\r\n      stack.push(ch);\r\n      // console.log(\"step:\", stack, p);\r\n      flag = 0;\r\n      num = [];\r\n      sub = [];\r\n      continue;\r\n    } else {\r\n      num.unshift(ch);\r\n      flag = 1;\r\n    }\r\n  }\r\n\r\n  // console.log(\"step:\", stack, num);\r\n  if (num.length > 0) {\r\n    var k = Number(num.join(\"\"));\r\n    var stop = false;\r\n    var sub = [];\r\n    while (!stop) {\r\n      var t = stack.pop();\r\n      if (t === \"[\") {\r\n        continue;\r\n      }\r\n      if (t === \"]\") {\r\n        // 重复 k 次\r\n        // console.log(\"sub:\", sub, k);\r\n        for (var n = 0; n < k; n++) {\r\n          stack.push(sub.join(\"\"));\r\n        }\r\n        stop = true;\r\n        break;\r\n      }\r\n      sub.push(t);\r\n    }\r\n  }\r\n\r\n  return stack.reverse().join(\"\");\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度: O(N)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/5#issuecomment-2051103778","body":"### 思路\r\n\r\n- 先用数组实现 Stack，支持的 API 有 push、pop、empty、size，其中 push、pop 时间复杂度是 O(1)，empty、size 时间复杂度是 O(N)\r\n- 队列的 push 操作调用栈的 push 操作即可\r\n- 队列的 peek 和 pop 操作是栈底元素，可以利用中间栈，将元素出栈放到中间栈，操作完后再把中间栈元素移到栈即可\r\n- 队列的 empty 操作调用栈的 empty 操作即可\r\n- 队列的 size 操作调用栈的 size 操作即可\r\n\r\n### 代码\r\n\r\n```js\r\nvar Stack = function () {\r\n  this.stack = [];\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nStack.prototype.push = function (x) {\r\n  this.stack.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nStack.prototype.pop = function () {\r\n  if (this.stack.length > 0) {\r\n    return this.stack.pop();\r\n  }\r\n  return -1;\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nStack.prototype.empty = function () {\r\n  return this.stack.length === 0;\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nStack.prototype.size = function () {\r\n  return this.stack.length;\r\n};\r\n\r\nvar MyQueue = function () {\r\n  this.stack = new Stack();\r\n  this.queue = new Stack();\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function (x) {\r\n  this.queue.push(x);\r\n  return null;\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function () {\r\n  if (this.queue.size() === 0) {\r\n    return null;\r\n  }\r\n\r\n  while (this.queue.size() > 1) {\r\n    this.stack.push(this.queue.pop());\r\n  }\r\n\r\n  var head = this.queue.pop();\r\n\r\n  while (this.stack.size() > 0) {\r\n    this.queue.push(this.stack.pop());\r\n  }\r\n  return head;\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function () {\r\n  if (this.queue.size() === 0) {\r\n    return null;\r\n  }\r\n\r\n  while (this.queue.size() > 1) {\r\n    this.stack.push(this.queue.pop());\r\n  }\r\n\r\n  var head = this.queue.pop();\r\n\r\n  this.queue.push(head);\r\n\r\n  while (this.stack.size() > 0) {\r\n    this.queue.push(this.stack.pop());\r\n  }\r\n\r\n  return head;\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function () {\r\n  return this.queue.empty();\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度\r\n  - push: O(1)\r\n  - pop: O(N)，要把栈里元素都先遍历存起来\r\n  - peek: O(N)，要把栈里元素都先遍历存起来\r\n  - empty: O(N)，依赖于栈的 empty 时间复杂度\r\n  - size: O(N)，依赖于栈的 size 时间复杂度\r\n- 空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/7#issuecomment-2056413454","body":"\r\n### 思路\r\n\r\n- step1: 先对链表进行翻转，同时记录链表长度(len)，同时记录最后一个节点的前驱节点(tailPrev) 和头节点 newHead\r\n- step2: 对 k 进行裁剪，只需要移动 k % len 次\r\n- step3: 每次移动时候，进行操作\r\n\r\n```\r\n// 暂存头结点\r\nvar headNextNode = newHead.next;\r\n// 最后一个节点的前驱节点后移\r\ntailPrev = tailPrev.next;\r\n// 更新最后一个节点为暂存的头结点\r\ntailPrev.next = newHead;\r\n// 切断链接\r\ntailPrev.next.next = null;\r\n// 更新头结点\r\nnewHead = headNextNode;\r\n```\r\n\r\n- step4: 再次进行翻转，输出\r\n\r\n### 代码\r\n\r\n```js\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function (head, k) {\r\n  if (!head || (head && !head.next) || k === 0) {\r\n    return head;\r\n  }\r\n\r\n  var newHead = null;\r\n  var tailPrev = null;\r\n  var len = 0;\r\n\r\n  // 头节点\r\n  while (head) {\r\n    //  1->2->3->4->5->NULL\r\n    const nextNode = head.next;\r\n\r\n    // 头插法。从头往后插入\r\n    head.next = newHead;\r\n    newHead = head;\r\n\r\n    head = nextNode;\r\n\r\n    if (newHead && newHead.next && !newHead.next.next) {\r\n      tailPrev = newHead;\r\n    }\r\n    len++;\r\n  }\r\n\r\n  for (var i = 0; i < k % len; i++) {\r\n    var headNextNode = newHead.next;\r\n    tailPrev = tailPrev.next;\r\n    tailPrev.next = newHead;\r\n    tailPrev.next.next = null;\r\n    newHead = headNextNode;\r\n  }\r\n\r\n  while (newHead) {\r\n    const nextNode = newHead.next;\r\n    // 头插法。从头往后插入\r\n    newHead.next = head;\r\n    head = newHead;\r\n\r\n    newHead = nextNode;\r\n  }\r\n\r\n  return head;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n对链表进行遍历，时间复杂度是 O(N)\r\n\r\n- 时间复杂度: O(N)\r\n- 空间复杂度: O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/8#issuecomment-2058544224","body":"### 思路\r\n\r\n#### 分支 1: 边界条件判断，直接返回 head\r\n\r\n- 链表为空\r\n- 链表长度为 1\r\n\r\n#### 分支 2: 两两交互\r\n\r\n- step1: 定义两个指针，`p1` 和 `p2`, `p2` 是 `p1` 的后继\r\n- step2: 迭代逻辑，`p1` 和 `p2` 都不为看空，先进行交互，然后分别前进 `2` 位\r\n- step3: 退出条件：`p1` 和 `p2` 至少有 `1` 个为空\r\n\r\n### 代码\r\n\r\n```js\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\nvar swapPairs = function (head) {\r\n  // 边界条件判断\r\n  if (!head || (head && !head.next)) {\r\n    return head;\r\n  }\r\n\r\n  var p1 = new ListNode(0);\r\n  var p2 = new ListNode(0);\r\n  var p3 = new ListNode(0);\r\n  var p4 = new ListNode(0);\r\n  p1 = head;\r\n  p2 = p1.next;\r\n  p3.next = head;\r\n\r\n  // p3 -> 1 -> 2\r\n  // step1: p3 -> 1 <- 2\r\n  // step2: 1 <- 2 <- p3\r\n\r\n  while (p2) {\r\n    var nextP1 = p2.next;\r\n    var nextP2 = p2.next ? p2.next.next : null;\r\n    p2.next = p1;\r\n    p3.next = p2;\r\n    p1.next = null;\r\n    if (!p4.next) {\r\n      p4.next = p3.next;\r\n    }\r\n\r\n    p3 = p3.next.next;\r\n\r\n    p1 = nextP1;\r\n    p2 = nextP2;\r\n  }\r\n\r\n  if (p1) {\r\n    p3.next = p1;\r\n  }\r\n  return p4.next;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n对链表进行一次遍历即可\r\n\r\n- 时间复杂度: O(N)\r\n- 空间复杂度: O(1)\r\n","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/10#issuecomment-2060275722","body":"### 思路\r\n题目要求不允许对链表进行修改，可以借助哈希表数据结果\r\n- step1: 先将链表 A 的数据都存到哈希表中\r\n- step2: 遍历链表 B，判断是否出现过，出现过返回\r\n- \r\n### 代码\r\n\r\n```js\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function (headA, headB) {\r\n  const visited = new Set();\r\n  let temp = headA;\r\n  while (temp !== null) {\r\n    visited.add(temp);\r\n    temp = temp.next;\r\n  }\r\n\r\n  temp = headB;\r\n  while (temp !== null) {\r\n    if (visited.has(temp)) {\r\n      return temp;\r\n    }\r\n    temp = temp.next;\r\n  }\r\n  return null;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度: O(N)\r\n- 空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/11#issuecomment-2062932994","body":"\r\n- 快慢指针，快指针每次走 2 步，慢指针每次走 1 步\r\n- 当快慢指针第一次相遇时，块指针和头结点分别走 1 步，再次相遇的节点就是环的入口节点\r\n\r\n```js\r\nvar detectCycle = function (head) {\r\n  var p1 = new ListNode(0);\r\n  var p2 = new ListNode(0);\r\n  var ptr = new ListNode(0);\r\n  p1.next = head;\r\n  p2.next = head;\r\n  ptr.next = head;\r\n\r\n  while (p1.next && p2.next) {\r\n    p1 = p1.next;\r\n    p2 = p2.next ? p2.next.next : null;\r\n    if (!p2) {\r\n      return null;\r\n    }\r\n\r\n    if (p1 === p2) {\r\n      while (ptr !== p2) {\r\n        ptr = ptr.next;\r\n        p2 = p2.next;\r\n      }\r\n      return ptr;\r\n    }\r\n  }\r\n  return null;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度: O(N)\r\n- 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/12#issuecomment-2065894177","body":"### 思路\r\n\r\n- LRU 要实现 get 和 set 操作复杂度为 O(1)，可以借助哈希表和双链表数据结构\r\n- LRU: 最近最少使用\r\n  - 即每次访问元素后，需要将其放到最前面\r\n  - 容量满了，添加的元素替换掉最后一个元素\r\n- 哈希表存放的是节点，通过节点可以获取前驱和后继指针\r\n- 通过哈希表实现 get 操作时间复杂度为 O(1) 的\r\n- 通过双链表实现 push 操作为 O(1) 时间复杂度\r\n\r\n### 代码\r\n\r\n```js\r\nclass DoubleListNode {\r\n  constructor(key, val, next, prev) {\r\n    this.key = key;\r\n    this.val = val;\r\n    this.next = next === undefined ? null : next;\r\n    this.prev = prev === undefined ? null : prev;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function (capacity) {\r\n  this.capacity = capacity;\r\n  this.hashMap = new Map();\r\n  this.head = new DoubleListNode();\r\n  this.tail = new DoubleListNode();\r\n};\r\n\r\n/**\r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function (key) {\r\n  if (this.capacity === 1) {\r\n    return this.hashMap.has(key) ? this.hashMap.get(key).val : -1;\r\n  }\r\n  if (this.hashMap.has(key)) {\r\n    var currentNode = this.hashMap.get(key);\r\n    var nextNode = currentNode.next;\r\n    var prevNode = currentNode.prev;\r\n\r\n    if (nextNode) {\r\n      prevNode.next = nextNode;\r\n      nextNode.prev = prevNode;\r\n    } else {\r\n      prevNode.next = null;\r\n    }\r\n\r\n    var headNextNode = this.head.next;\r\n    currentNode.next = headNextNode;\r\n    currentNode.prev = this.head;\r\n\r\n    if (headNextNode) {\r\n      headNextNode.prev = currentNode;\r\n    }\r\n    this.head.next = currentNode;\r\n\r\n    var p2 = this.head.next;\r\n    while (p2) {\r\n      if (!p2.next) {\r\n        this.tail.next = p2;\r\n      }\r\n      p2 = p2.next;\r\n    }\r\n\r\n    return this.hashMap.get(key).val;\r\n  }\r\n  return -1;\r\n};\r\n\r\n/**\r\n * @param {number} key\r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function (key, value) {\r\n  // 容量为1\r\n  if (this.capacity === 1) {\r\n    this.hashMap.clear();\r\n    this.hashMap.set(key, new DoubleListNode(key, value));\r\n    return null;\r\n  }\r\n  // currentNode\r\n  var currentNode = new DoubleListNode(key, value);\r\n\r\n  if (this.capacity > this.hashMap.size) {\r\n    if (this.hashMap.has(key)) {\r\n      var temp = this.hashMap.get(key);\r\n      temp.val = value;\r\n      console.log(\"value:\", key, value, temp.val, temp.key);\r\n      this.hashMap.set(key, temp);\r\n      this.get(key);\r\n      return null;\r\n    }\r\n    // 容量不满\r\n    // head <-> a <-> b\r\n    var headNext = this.head.next;\r\n\r\n    currentNode.next = headNext;\r\n    if (headNext) {\r\n      headNext.prev = currentNode;\r\n    }\r\n\r\n    this.head.next = currentNode;\r\n    currentNode.prev = this.head;\r\n\r\n    if (!this.tail.next) {\r\n      this.tail.next = currentNode;\r\n    }\r\n    this.hashMap.set(key, currentNode);\r\n  } else {\r\n    if (this.hashMap.has(key)) {\r\n      var temp = this.hashMap.get(key);\r\n      temp.val = value;\r\n      console.log(\"value:\", key, value, temp.val, temp.key);\r\n      this.hashMap.set(key, temp);\r\n      this.get(key);\r\n      return null;\r\n    }\r\n\r\n    // 容量满了，删除最后一个节点\r\n    var lastNode = this.tail.next;\r\n\r\n    const prevNode = lastNode.prev;\r\n    prevNode.next = null;\r\n\r\n    this.hashMap.delete(lastNode.key);\r\n\r\n    this.tail.next = prevNode;\r\n\r\n    // 头部插入\r\n    var nextHeadNode = this.head.next;\r\n    currentNode.next = nextHeadNode;\r\n\r\n    if (nextHeadNode) {\r\n      nextHeadNode.prev = currentNode;\r\n    }\r\n    currentNode.prev = this.head;\r\n    this.head.next = currentNode;\r\n    this.hashMap.set(key, currentNode);\r\n  }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度: O(1)\r\n- 空间复杂度: O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/13#issuecomment-2069000425","body":"\r\n### 代码\r\n\r\n```js\r\nvar maxDepth = function (root) {\r\n  if (root === null) {\r\n    return 0;\r\n  }\r\n\r\n  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度: O(N)\r\n- 空间复杂度: O(H), H 是树的高度\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/14#issuecomment-2071504396","body":"## 答案\r\n\r\n### 思路\r\n\r\n- 递归思想: 都只考虑当前节点，不需要考虑子问题节点\r\n- 递归公式：当前问题可以分为 2 个子问题\r\n  - isSameTree(p, q) = isSameTree(p.left, q.left) + isSameTree(p.right, q.right) + p.val === q.val\r\n- 递归结束条件: p 或者 q 有一个为 null，递归结束\r\n\r\n### 代码\r\n\r\n```js\r\nvar isSameTree = function (p, q) {\r\n  if (!p || !q) {\r\n    return !p && !q;\r\n  }\r\n\r\n  return (\r\n    p.val === q.val &&\r\n    isSameTree(p.left, q.left) &&\r\n    isSameTree(p.right, q.right)\r\n  );\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n递归需要遍历每个节点，故时间复杂度为 O(N)\r\n递归调用的深度和树的高度有关，故空间复杂度为 O(H)\r\n\r\n- 时间复杂度: O(N)\r\n- 空间复杂度: O(H)\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/15#issuecomment-2071566413","body":"## 思路\r\n\r\n- 使用 dfs，每次 dfs 调用时候计算当前 curSum 的值\r\n- 递归公式: dfs(root, 0) = dfs(root.left, curSum) + dfs(root.right, curSum)\r\n  - curSum = curSum `*` 10 + root.val\r\n- 退出条件：p 或者 q 有一个为 null 时，返回 sum 的和\r\n\r\n### 代码\r\n\r\n```js\r\nvar sumNumbers = function (root) {\r\n  var sum = 0;\r\n\r\n  function dfs(root, cur) {\r\n    if (!root) {\r\n      return 0;\r\n    }\r\n\r\n    var curSum = cur * 10 + root.val;\r\n\r\n    if (!root.left && !root.right) {\r\n      sum += curSum;\r\n      return;\r\n    }\r\n\r\n    dfs(root.left, curSum);\r\n    dfs(root.right, curSum);\r\n  }\r\n\r\n  dfs(root, 0);\r\n  return sum;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n递归需要遍历每个节点，故时间复杂度为 O(N)\r\n递归调用的深度和树的高度有关，故空间复杂度为 O(H)\r\n\r\n- 时间复杂度: O(N)\r\n- 空间复杂度: O(H)\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/16#issuecomment-2074188747","body":"\r\n### 思路\r\n\r\n- 求解在树的最后一行找到最左边的值，要借助 BFS 思想\r\n- 这里有个小技巧，在 BFS 遍历过程中，先访问右节点，再访问左节点，可以确定最后访问的叶子节点就是想要的结果\r\n\r\n### 代码\r\n\r\n```js\r\nvar findBottomLeftValue = function (root) {\r\n  if (!root) {\r\n    return -1;\r\n  }\r\n\r\n  var dist = root;\r\n  var queue = [];\r\n  queue.push(root);\r\n  var flag = 0;\r\n  while (queue.length > 0) {\r\n    var point = queue.shift();\r\n    if (point.right) {\r\n      dist = point.right;\r\n      queue.push(point.right);\r\n    }\r\n    if (point.left) {\r\n      dist = point.left;\r\n      queue.push(point.left);\r\n    }\r\n  }\r\n  return dist.val;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n递归需要遍历每个节点，故时间复杂度为 O(N)\r\n递归调用的深度和树的高度有关，故空间复杂度为 O(H)\r\n\r\n- 时间复杂度: O(N)\r\n- 空间复杂度: O(H)\r\n","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/20#issuecomment-2078535247","body":"### 思路\r\n\r\n- 先对数组进行排序\r\n- 收尾进行往中间走，进行判断两数之和\r\n- 拿到数字后再去原数组取下标\r\n\r\n### 代码\r\n\r\n```js\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number[]}\r\n */\r\nvar twoSum = function (nums, target) {\r\n  var sortNums = [...nums].sort((a, b) => (a - b > 0 ? 1 : -1));\r\n\r\n  var mid = Math.floor(nums.length / 2);\r\n  var left = 0;\r\n  var right = nums.length - 1;\r\n\r\n  while (sortNums[left] + sortNums[right] !== target) {\r\n    if (sortNums[left] + sortNums[right] > target) {\r\n      right--;\r\n    } else if (sortNums[left] + sortNums[right] < target) {\r\n      left++;\r\n    }\r\n    if (right < left) {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  var leftPos = -1;\r\n  var rightPos = -1;\r\n\r\n  for (var i = 0; i < nums.length; i++) {\r\n    if (nums[i] === sortNums[left] && leftPos === -1) {\r\n      leftPos = i;\r\n      continue;\r\n    }\r\n    if (nums[i] === sortNums[right] && rightPos === -1) {\r\n      rightPos = i;\r\n    }\r\n  }\r\n  return [leftPos, rightPos];\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度取决于数字排序，空间复杂度使用了临时数组存在\r\n\r\n- 时间复杂度：O(N^2)\r\n- 空间复杂度：O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/21#issuecomment-2081841292","body":"\r\n### 思路\r\n\r\n- 遍历数组，记录数组中元素出现的次数存放到哈希表\r\n- 对哈希表中的 `val` 进行排序\r\n- 取出排序后的前 `k` 个元素，然后去哈希表查询的 `key`\r\n\r\n### 代码\r\n\r\n```js\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar topKFrequent = function (nums, k) {\r\n  var hash1 = new Map();\r\n  var resArr = [];\r\n  var dist = [];\r\n  for (var i = 0; i < nums.length; i++) {\r\n    if (hash1.has(nums[i])) {\r\n      hash1.set(nums[i], hash1.get(nums[i]) + 1);\r\n    } else {\r\n      hash1.set(nums[i], 1);\r\n    }\r\n  }\r\n\r\n  for (var [k1, v1] of hash1.entries()) {\r\n    resArr.push(v1);\r\n  }\r\n\r\n  // 排序\r\n  resArr = resArr.sort((a, b) => {\r\n    return a - b > 0 ? -1 : 1;\r\n  });\r\n  for (var j = 0; j < k; j++) {\r\n    for (var [k2, v2] of hash1.entries()) {\r\n      if (v2 === resArr[j]) {\r\n        dist.push(k2);\r\n        hash1.set(k2, 0);\r\n      }\r\n    }\r\n  }\r\n  return dist;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度: O(N^2)\r\n- 空间复杂度: O(N)\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/22#issuecomment-2095174042","body":"### 代码\r\n\r\n```js\r\nvar numberOfBoomerangs = function (points) {\r\n  let ans = 0;\r\n  for (const p of points) {\r\n    const cnt = new Map();\r\n    for (const q of points) {\r\n      const dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\r\n      cnt.set(dis, (cnt.get(dis) || 0) + 1);\r\n    }\r\n    for (const [_, m] of cnt.entries()) {\r\n      ans += m * (m - 1);\r\n    }\r\n  }\r\n  return ans;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度: O(N^2)\r\n- 空间复杂度: O(N)\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/23#issuecomment-2081823050","body":"### 思路\r\n\r\n- 使用双指针\r\n- 将双指针之间的字符串存放到哈希表里，判断右指针是否出现过\r\n  - 出现，返回，重置左右指针和哈希表\r\n  - 不出现，移动右指针，将元素放到哈希表里\r\n\r\n### 代码\r\n\r\n```js\r\nvar lengthOfLongestSubstring = function (s) {\r\n  if (!s) {\r\n    return 0;\r\n  }\r\n  var leftPoint = 0;\r\n  var rightPoint = 0;\r\n  var len = s.length;\r\n  var map = new Map();\r\n  var max = 0;\r\n\r\n  while (rightPoint < len) {\r\n    var ch = s.charAt(rightPoint);\r\n    if (!map.has(ch)) {\r\n      map.set(ch, 1);\r\n      rightPoint++;\r\n      if (rightPoint === len) {\r\n        max = max < map.size ? map.size : max;\r\n        break;\r\n      }\r\n    } else {\r\n      max = max < map.size ? map.size : max;\r\n      leftPoint = leftPoint + 1;\r\n      rightPoint = leftPoint;\r\n      map.clear();\r\n    }\r\n  }\r\n\r\n  return max;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\nN 数据规模，M: 最长子串长度\r\n\r\n- 时间复杂度: O(N)\r\n- 空间复杂度: O(M)\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/26#issuecomment-2105455010","body":"\r\n### 思路\r\n\r\n- 快慢指针法，快指针走 2 步，慢指针走 1 步\r\n- 快指针最后一步走完 2 步，是偶数个节点，更新慢指针\r\n- 快指针最后一步走不完 2 步，是奇数个节点，不更新\r\n- 返回慢指针即可\r\n\r\n### 代码\r\n\r\n```js\r\nvar middleNode = function (head) {\r\n  if (!head || !head.next) {\r\n    return head;\r\n  }\r\n\r\n  slow = head;\r\n  fast = head;\r\n\r\n  while (fast) {\r\n    if (fast.next) {\r\n      fast = fast.next.next;\r\n    } else {\r\n      fast = fast.next;\r\n      break;\r\n    }\r\n    slow = slow.next;\r\n  }\r\n\r\n  return slow;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度花费在遍历链表上，故 O(N)\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/27#issuecomment-2103801282","body":"\r\n### 思路\r\n\r\n- 定义个指针，指向数组第 0 个位置元素\r\n- 从第 1 个元素进行遍历，和指针指向的元素进行比较，如果不相同，更新指针，同时把元素放到该指针指向的位置\r\n\r\n### 代码\r\n\r\n```js\r\nvar removeDuplicates = function (nums) {\r\n  var len = nums.length;\r\n\r\n  if (len <= 1) {\r\n    return len;\r\n  }\r\n\r\n  var point = 0;\r\n  var map = new Map();\r\n\r\n  map.set(nums[0], 1);\r\n\r\n  for (var i = 1; i <= len - 1; i++) {\r\n    if (!map.has(nums[i])) {\r\n      map.set(nums[i], 1);\r\n      point = point + 1;\r\n      nums[point] = nums[i];\r\n    }\r\n  }\r\n  return point + 1;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\nN 数据规模，\r\n\r\n- 时间复杂度: O(N)\r\n- 空间复杂度: O(1)\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/28#issuecomment-2099615694","body":"### 思路\r\n\r\n使用二分思想\r\n\r\n- left = 0 right = nums.length - 1;\r\n- mid = Math.floor((left + right) / 2);\r\n- nums[mid] = target ==> return mid;\r\n- 左侧: nums[mid] < target ==> left = mid + 1;\r\n- 右侧: nums[mid] > target ==> right = mid - 1;\r\n- 返回 left\r\n\r\n### 代码\r\n\r\n```js\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number}\r\n */\r\nvar searchInsert = function (nums, target) {\r\n  var left = 0;\r\n  var right = nums.length - 1;\r\n\r\n  while (left <= right) {\r\n    var mid = Math.floor((left + right) / 2);\r\n    if (nums[mid] === target) {\r\n      return mid;\r\n    }\r\n\r\n    if (nums[mid] < target) {\r\n      left = mid + 1;\r\n    }\r\n\r\n    if (nums[mid] > target) {\r\n      right = mid - 1;\r\n    }\r\n  }\r\n\r\n  return left;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\nN 为数组规模\r\n\r\n- 时间复杂度：O(logN)\r\n- 空间复杂度：O(1)\r\n","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/30#issuecomment-2095578349","body":"### 代码\r\n```js\r\nvar findJudge = function(n, trust) {\r\n    const inDegrees = new Array(n + 1).fill(0);\r\n    const outDegrees = new Array(n + 1).fill(0);\r\n    for (const edge of trust) {\r\n        const x = edge[0], y = edge[1];\r\n        ++inDegrees[y];\r\n        ++outDegrees[x];\r\n    }\r\n    for (let i = 1; i <= n; ++i) {\r\n        if (inDegrees[i] === n - 1 && outDegrees[i] === 0) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n+m)\r\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"coderxiaowq":[{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/1#issuecomment-2042506523","body":"Java 时间复杂度 O(n)\r\n` public List addToArrayForm(int[] a, int k) {\r\nList list = new ArrayList<>();\r\nList K = new ArrayList<>();\r\n//将数据k保存到集合K\r\nwhile(k > 0){\r\nK.add(k % 10);\r\nk /= 10;\r\n}\r\n//开始计算\r\nint p = a.length - 1;//从右往左遍历a\r\nint i = 0;//从左往右遍历K\r\nint left = 0;//进位值\r\nwhile(p>=0 || i<K.size()){\r\nint sum = 0;//保存相加的和\r\nif(p>=0 && i<K.size()){\r\nsum = a[p]+K.get(i)+left;\r\n}else if(p<0){\r\nsum = K.get(i)+left;\r\n}else{\r\nsum = a[p]+left;\r\n}\r\nif(sum>9){\r\nlist.add(sum % 10);\r\nleft = sum / 10;\r\n}else{\r\nlist.add(sum);\r\nleft = 0;\r\n}\r\np--;\r\ni++;\r\n}\r\nif(left != 0){\r\nlist.add(left);\r\n}\r\n\r\n    List<Integer> rs = new ArrayList<>();\r\n    //反转list\r\n    for(int j = list.size() - 1; j>=0; j--){\r\n        rs.add(list.get(j));\r\n    }\r\n    \r\n    return rs;\r\n}`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/2#issuecomment-2043950862","body":"Java 时间复杂度O(n)\n```\npublic int[] shortestToChar(String s, char c) {\n        int[] rs = new int[s.length()];\n        char[] a = s.toCharArray();\n        //记录字符c出现在i\"左边\"\"的最近索引left<=i,第1次可能例外\n        int left = s.indexOf(c+\"\"); \n        for(int i = 0; i < a.length; i++){\n            char ch = a[i];//记录当前索引i位置的字符\n            if(ch == c){\n                rs[i] = 0;\n                left = i;\n                continue;\n            }else if(left > i){//left大于i,因为left是i\"左边\"的,所以不存在更近的右边索引了\n                rs[i]= left-i;\n                continue;\n            }\n            //运行到这里,说明left<i,需要查询i右边\n            int right = i + 1;\n            while(right < a.length && a[right] != c){\n                right++;\n            }\n            //找到i右边的第一个目标right, a[right]==c\n            if(right == a.length){//right越界\n                rs[i] = i - left;\n            }else{\n                rs[i]= Math.min(i-left,right-i);\n            }\n\n        }\n        return rs;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/3#issuecomment-2046300464","body":"Java\r\n思路: 底层创建一个数组用于存储数据,并定义一个变量保存数组中的有效元素个数\r\n```\r\nclass CustomStack {\r\n    private int[] a;// 底层数组 保存数据\r\n    private int N;// 数组逻辑长度\r\n\r\n    public CustomStack(int maxSize) {// maxSize>=1\r\n        a = new int[maxSize];\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (N == a.length)\r\n            return;\r\n        a[N++] = x;\r\n    }\r\n\r\n    public int pop() {\r\n        if (N == 0)\r\n            return -1;\r\n        return a[--N];\r\n    }\r\n\r\n    public void increment(int k, int val) {// k>=1\r\n        if (k >= N) {\r\n            for (int i = 0; i < N; i++) {\r\n                a[i] += val;\r\n            }\r\n        } else {\r\n            for (int i = 0; i < k; i++) {\r\n                a[i] += val;\r\n            }\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/4#issuecomment-2050710577","body":"Java\r\n昨天写的时候思路有,但是代码实现总是差一点,最后虽然实现了,觉有运气的成分,心烦\r\n时间复杂度O(n)\r\n```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        StringBuilder rs = new StringBuilder();\r\n        Stack<Integer> nums = new Stack<>();\r\n        Stack<String> chs = new Stack<>();\r\n        int num = 0;\r\n        char[] a = s.toCharArray();\r\n        for (char c : a) {\r\n            if (c >= '0' && c <= '9') {\r\n                num = num * 10 + c - '0';\r\n            } else if (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z') {\r\n                rs.append(c);\r\n            } else if (c == '[') {\r\n                nums.push(num);\r\n                chs.push(rs.toString());\r\n                rs = new StringBuilder();//重置rs\r\n                num = 0;\r\n            } else {\r\n                int N = nums.pop();//重复次数N\r\n                String tmp = chs.pop();\r\n                for (int j = 0; j < N; j++) {\r\n                    tmp += rs.toString();\r\n                }\r\n                rs = new StringBuilder(tmp);\r\n            }\r\n\r\n        }\r\n        return rs.toString();\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/5#issuecomment-2050703883","body":"Java 时间复杂度O(1)\r\n因为是返回队列头部元素,因此需要将整个队列反转后放在另一个队列中\r\n定义两个队列保存数据\r\n```\r\nclass MyQueue {\r\n    private Deque<Integer> in;\r\n    private Deque<Integer> out;\r\n\r\n    public MyQueue() {\r\n        in = new LinkedList();\r\n        out = new LinkedList();\r\n    }\r\n\r\n    public void push(int x) {\r\n        in.push(x);\r\n    }\r\n\r\n    public int pop() {\r\n        if (out.isEmpty()) {//将in中的数据给到out\r\n            while (!in.isEmpty()) {\r\n                out.push(in.pop());\r\n            }\r\n        }\r\n        return out.pop();\r\n    }\r\n\r\n    public int peek() {\r\n        if(out.isEmpty()){\r\n            while (!in.isEmpty()) {\r\n                out.push(in.pop());\r\n            }\r\n        }\r\n        return out.peek();\r\n    }\r\n\r\n    public boolean empty() {\r\n        return out.isEmpty() && in.isEmpty();\r\n    }\r\n\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/6#issuecomment-2053604956","body":"Java 时间复杂度O(n)\n```\nclass Solution {\n    public int maxChunksToSorted(int[] a) {\n        if (a.length == 1) return 1;\n        List<Integer> list = new LinkedList<>();\n        list.add(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            if(a[i]<list.getLast()){//当前遍历到的值a[i]小于队列末尾的值\n                int j = list.removeLast();//移除该值并保存,应该该值是list中最大的\n                while(list.size()!=0 && a[i]<list.getLast()){//持续移除list中的值,直到a[i]到达所在块的起始索引\n                    list.removeLast();\n                }\n                list.add(j);//将最大值添加回list\n            }else\n                list.add(a[i]);\n        }\n        return list.size();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/7#issuecomment-2053836912","body":"Java 时间复杂度 O(n)\n面向debug编程......\n```\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null || k == 0) return head;\n        //先获取链表长度 计算head偏移距离\n        ListNode cur = head;\n        int N = 1;\n        while(cur.next!=null){\n            cur = cur.next;\n            N++;\n        }\n        if(N == 1) return head;\n        k %= N;//计算实际偏移量 \n        if(k==0) return head;\n        cur.next = head;//将链表闭合 \n        //利用cur找位置\n        cur = head;\n        while(k<N-1){\n            cur = cur.next;\n            k++;\n        }\n        //cur指向要切开元素对左边那个 切断 0-1-2/-3-4\n        ListNode temp = cur.next;\n        cur.next = null;\n        return temp;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/8#issuecomment-2055238112","body":"Java 时间复杂度O(n)\r\n使用虚拟头结点\r\n```\r\npublic ListNode swapPairs(ListNode head) {\r\n        if (head == null || head.next == null)\r\n            return head;\r\n        ListNode dummy = new ListNode(666, head);\r\n        ListNode cur = dummy;\r\n        // 交换1号和2号 cur.next和cur.next.next\r\n        while (cur.next != null && cur.next.next != null) {\r\n            ListNode first = cur.next;// 记录1号\r\n            ListNode seconde = cur.next.next;// 记录2号 用以访问下一个1号\r\n            first.next = seconde.next;// 1号指向下一个1号\r\n            seconde.next = first;// 2号指向1号\r\n            cur.next = seconde;// cur指向2号并且dummy第一次指向2号\r\n            // cur.next再次指向下一组1号\r\n            cur = first;\r\n        }\r\n        return dummy.next;\r\n    }\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/10#issuecomment-2061157329","body":"Java\n时间复杂度O(n)\n```\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode A, ListNode B) {\n        ListNode p1 = new ListNode(1);\n        ListNode p2 = new ListNode(1);\n        p1.next = A;\n        p2.next = B;\n        Map<ListNode,Integer> map = new HashMap<>();\n        while(p1.next != null){\n            map.put(p1.next,0);\n            p1=p1.next;\n        }\n        while(p2.next!=null){\n            if(map.containsKey(p2.next))\n                return p2.next;\n            p2=p2.next;\n        }\n        return null;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hillsonziqiu":[{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/1#issuecomment-2042528858","body":"## 思路\r\n首先想到的方法是两个数求解嘛，直接数组转数字相加后再放到数组中。提交的时候发现了问题，js大数操作的时候精度会G掉，故这个方案不可行；\r\n那么就只能按位相加了，加法是从个位开始进行计算，那么反向获取一下数组, 按位相加.\r\n另一种情况：如果k的位数大于sum，那么需要将k多出来的位数追加到前面。\r\n最后数组取反即可；\r\n\r\n## 代码\r\n```javascript\r\n  const res = [];\r\n  const n = num.length;\r\n  for (let i = n - 1; i >= 0; --i) {\r\n    let sum = num[i] + (k % 10);\r\n    k = ~~(k / 10);\r\n    if (sum >= 10) {\r\n      k++;\r\n      sum -= 10;\r\n    }\r\n    res.push(sum);\r\n  }\r\n  while (k > 0) {\r\n    res.push(k % 10);\r\n    k = ~~(k / 10);\r\n  }\r\n  res.reverse();\r\n  return res;\r\n```\r\n\r\n## 复杂度\r\nn为sum的length，m为k的个数\r\n时间复杂度：O(n + |n-m|)\r\n空间复杂度：O(1) 没有用到新的存储空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/2#issuecomment-2047036979","body":"## 思路\r\n正反来回两次遍历，正向遍历是获取距离左侧c的距离，反向遍历是获取距离右侧c的距离。第二次遍历的时候对比正向过来的值获取最小值。\r\n## 解法\r\n``` javascript\r\nvar shortestToChar = function (s, c) {\r\n  let res = [];\r\n  const n = s.length;\r\n  let mark = -n;\r\n  for (let i = 0; i < n; i++) {\r\n    if (s[i] === c) {\r\n      mark = i;\r\n    }\r\n    res[i] = i - mark;\r\n  }\r\n  mark = 2 * n;\r\n  for (let i = n - 1; i >= 0; --i) {\r\n    if (s[i] === c) {\r\n      mark = i;\r\n    }\r\n    res[i] = Math.min(res[i], mark - i);\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n## 复杂度分析\r\n时间复杂度 O(n)  两次遍历   n+n   复杂度忽略常量\r\n空间复杂度 O(1)  就用到一个常量","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/3#issuecomment-2047142482","body":"## 思路\r\n通过数组来模拟栈。通过push和pop来操作栈。CustomStack有两个属性一个是list，一个是maxSize；\r\nincrement的实现：\r\n遍历长度判断 const len = this.list.length > k ? k : this.list.length;\r\n如果栈长度大于k，那么就遍历到k，如果长度小于k，那么遍历整个list即可；\r\n\r\n## 题解\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=1381 lang=javascript\r\n *\r\n * [1381] 设计一个支持增量操作的栈\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n  const list = [];\r\n  //   list.length = maxSize;\r\n  this.maxSize = maxSize;\r\n  this.list = list;\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.list.length >= this.maxSize) {\r\n    return;\r\n  }\r\n  this.list.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n  if (this.list.length <= 0) {\r\n    return -1;\r\n  }\r\n  return this.list.pop();\r\n};\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n  const len = this.list.length > k ? k : this.list.length;\r\n  for (let i = 0; i < len; i++) {\r\n    this.list[i] += val;\r\n  }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n// @lc code=end\r\n\r\n\r\n```\r\n## 复杂度分析\r\n时间复杂度:\r\n* CustomStack O(1)\r\n* push O(1)\r\n* pop O(1)\r\n* increment O(n)\r\n空间复杂度: O（N）   N就是maxSize;\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/4#issuecomment-2049276667","body":"## 思路\r\n这类字符串匹配括号或者特殊符号的场景，我一般首先想到的要不就是用字符串替换法（正则），要不就用栈来操作。本题题解就用栈的形式进行操作：\r\n针对字符串做一次遍历，遍历过程中要处理几个条件：\r\n统一点，除了']'和数字类型需要单独处理外，将其余的char统统推入栈中；\r\n1. '!isNaN(char)'\r\n用于计算重复次数，之前以为数字只会是1位，导致用例 100[leetcode] 没过。\r\n在一次遍历中只能获取一位数字，那么在遇到'['之前数字是要累加的，算法为：```times = times * 10 + parseInt(item);```\r\n2. '[' \r\n将之前算好的次数推入栈中。并将全局变量times重置为0；\r\n3. ']'\r\n* 这里是重点 *，首先这里是要计算需要重复字符串的，循环从已有的stack中pop元素，当遇到'['需要停止，并再次pop出来之前计算的重复次数times，然后将``` += ```后的repeatStr推入栈中\r\n4. 其他\r\n当前char 统统推入栈中\r\n\r\n通过这次遍历，那么整个栈都只剩下``` string[] ``` 了。然后将字符串数组拼接起来，就是最终的答案了。\r\n\r\n## 解法\r\n```javascript\r\nvar decodeString = function (s) {\r\n  const stack = [];\r\n  let times = 0;\r\n  // 考虑栈的操作\r\n  for (const item of s) {\r\n    if (item === \"[\") {\r\n      stack.push(times);\r\n      stack.push(item);\r\n      times = 0;\r\n    } else if (item === \"]\") {\r\n      let repeatStr = \"\";\r\n      while (1) {\r\n        const stackPopItem = stack.pop();\r\n        if (stackPopItem === \"[\") {\r\n          const repeatTimes = stack.pop();\r\n          repeatStr = repeatStr.repeat(repeatTimes);\r\n          break;\r\n        } else {\r\n          repeatStr = stackPopItem + repeatStr;\r\n        }\r\n      }\r\n      stack.push(repeatStr);\r\n    } else if (!isNaN(item)) {\r\n      times = times * 10 + parseInt(item);\r\n    } else {\r\n      stack.push(item);\r\n    }\r\n  }\r\n\r\n  console.log(\"res\", stack);\r\n  return stack.join(\"\");\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度：for 循环里包含了一个while循环 我感觉复杂度是 O(n^2)  然后还有个join 那么总时间复杂度应该是  O(n^2 + n); 按算法来看时间复杂度应该是O(n^2);\r\n空间复杂度：此处用了一个位数为n的栈，故空间复杂度为O(n)   。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/5#issuecomment-2051026867","body":"## 思路\r\n因为只能使用栈的操作，那么如果想用栈实现队列的话就需要两个栈相互倒蹬。\r\n\r\n## 题解\r\n```javascript\r\nvar MyQueue = function () {\r\n    this.inStack = [];\r\n    this.outStack = [];\r\n\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function (x) {\r\n    this.inStack.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function () {\r\n    if (!this.outStack.length) {\r\n        while (this.inStack.length) {\r\n            this.outStack.push(this.inStack.pop());\r\n        }\r\n    }\r\n\r\n    return this.outStack.pop();\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function () {\r\n    if (!this.outStack.length) {\r\n        while (this.inStack.length) {\r\n            this.outStack.push(this.inStack.pop());\r\n        }\r\n    }\r\n\r\n    return this.outStack[this.outStack.length - 1];\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function () {\r\n    return !this.inStack.length && !this.outStack.length;\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度：O(1)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/6#issuecomment-2053606354","body":"## 思路\r\n单调栈的可以进行排序，正序经过栈可以变成倒序，倒序经过栈可以变成正序，利用这种特性，for循环遍历如果栈顶值小于遍历的item，那么推入stack栈中；否则，推出栈顶，对栈里面的栈底值进行比较，如果当前值小于最后一个，那么停止当前栈的推出。循环结束后插入循环前栈推出的值。最终栈中剩下的长度就是分割的块数。\r\n\r\n## 代码\r\n```javascript\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function (arr) {\r\n  const stack = [];\r\n  for (item of arr) {\r\n    if (stack.length === 0 || item >= stack[stack.length - 1]) {\r\n      stack.push(item);\r\n    } else {\r\n      const maxItem = stack.pop();\r\n      while (stack.length > 0 && item < stack[stack.length - 1]) {\r\n        stack.pop();\r\n      }\r\n      stack.push(maxItem);\r\n    }\r\n  }\r\n\r\n  return stack.length;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度：O(n)  栈总共就是arr的长度，遍历中最糟糕的场景时间复杂度也就是 O(n + n) => O(n);\r\n空间复杂度：O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/7#issuecomment-2054110908","body":"## 思路\r\n链表如果拼成一个“轮子”的话，那么就容易解决了。\r\n\r\n## 实现\r\n```javascript\r\nvar rotateRight = function (head, k) {\r\n  if (!head || !head.next || k === 0) return head;\r\n\r\n  let [n, cur] = [1, head];\r\n  while (cur.next) {\r\n    cur = cur.next;\r\n    n++;\r\n  }\r\n\r\n  let gap = n - (k % n);\r\n  if (gap === n) return head;\r\n\r\n  cur.next = head;\r\n  while (gap > 0) {\r\n    cur = cur.next;\r\n    gap--;\r\n  }\r\n\r\n  const res = cur.next;\r\n  cur.next = null;\r\n\r\n  return res;\r\n};\r\n```\r\n\r\n##  复杂度分析\r\n时间复杂度：O(n)    最多循环2次  故时间复杂度为O(n)\r\n空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/8#issuecomment-2056725430","body":"## 思路\r\n递归交换链表相邻两个值即可\r\n\r\n## 代码\r\n```javascript\r\nvar swapPairs = function(head) {\r\n    if (!head?.next) return head;\r\n\r\n    const nh = head.next;\r\n    head.next = swapPairs(nh.next);\r\n    nh.next = head;\r\n    return nh;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(n)\r\n* 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/15#issuecomment-2069866714","body":"## 思路\r\n树的深度优先遍历后相加即可\r\n\r\n## 代码\r\n```javascript\r\n// 深度优先\r\nconst dfs = (root, pre) => {\r\n  if (!root) return 0;\r\n\r\n  let sum = pre * 10 + root.val;\r\n  if (!root.left && !root.right) return sum;\r\n\r\n  return dfs(root.left, sum) + dfs(root.right, sum);\r\n};\r\n\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar sumNumbers = function (root) {\r\n  return dfs(root, 0);\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(n) 树的节点个数\r\n* 空间复杂度：O(h) 树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/16#issuecomment-2074629176","body":"## 思路\r\n深度优先，优先遍历左边节点。\r\n\r\n## 代码\r\n```javascript\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\nconst dfs = (root, h, callback) => {\r\n    if (!root) return;\r\n\r\n    h++;\r\n    dfs(root.left, h, callback);\r\n    dfs(root.right, h, callback);\r\n\r\n    callback && callback(h, root.val);\r\n}\r\n\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar findBottomLeftValue = function (root) {\r\n    let [height, val] = [0, undefined];\r\n\r\n    dfs(root, 0, (h, curVal) => {\r\n        if (h > height) {\r\n            height = h;\r\n            val = curVal;\r\n        }\r\n    })\r\n\r\n    return val;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(n)\r\n* 空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/17#issuecomment-2074908810","body":"## 思路\r\n深度优先遍历。\r\n序列化：如果tree为空，则直接拼接字符串 'None,'. 否则字符串拼接当前节点的value，并分别执行左侧节点和右侧节点的方法。最终返回拼接到的字符串。\r\n反序列化：判断第一个拿出的值是否是none，如果是，则为空。否则就从头部获取值，并创建node节点。再通过递归获取左侧的节点和右侧的节点。\r\n\r\n## 代码\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=297 lang=javascript\r\n *\r\n * [297] 二叉树的序列化与反序列化\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n\r\nconst reSerialize = (root, str) => {\r\n    if (root === null) {\r\n      str += 'None,'\r\n    } else {\r\n      str += root.val + ',';\r\n      str = reSerialize(root.left, str);\r\n      str = reSerialize(root.right, str);\r\n    }\r\n    \r\n    return str;\r\n}\r\n\r\n/**\r\n * Encodes a tree to a single string.\r\n *\r\n * @param {TreeNode} root\r\n * @return {string}\r\n */\r\nvar serialize = function(root) {\r\n    return reSerialize(root, '');\r\n};\r\n\r\nconst reDeserialize = (data) => {\r\n  if (data[0] === 'None') {\r\n    data.shift();\r\n    return null;\r\n  }\r\n\r\n  let root = new TreeNode(data[0]);\r\n  data.shift();\r\n  root.left = reDeserialize(data);\r\n  root.right = reDeserialize(data);\r\n\r\n  return root;\r\n}\r\n\r\n/**\r\n * Decodes your encoded data to tree.\r\n *\r\n * @param {string} data\r\n * @return {TreeNode}\r\n */\r\nvar deserialize = function(data) {\r\n    return reDeserialize(data.split(','));\r\n};\r\n\r\n/**\r\n * Your functions will be called as such:\r\n * deserialize(serialize(root));\r\n */\r\n// @lc code=end\r\n\r\n\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/20#issuecomment-2079473956","body":"## 思路\r\n使用map的能力，将nums数组转换成为key是nums值value是index的map，然后遍历target减去nums中的每一位，如果在map中，那么再判断是不是value和当前下标相同，如果不同则退出循环，返回当前下标和map中对应的下标。\r\n\r\n## 代码\r\n```javascript\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number[]}\r\n */\r\nvar twoSum = function (nums, target) {\r\n    const numsMap = new Map();\r\n    for (let i = 0; i < nums.length; i++) {\r\n        const item = nums[i];\r\n        numsMap.set(item, i);\r\n    }\r\n    let result;\r\n    for (let i = 0; i < nums.length; i++) {\r\n        const item = nums[i];\r\n        const computedNum = target - item;\r\n        if (numsMap.get(computedNum) !== undefined) {\r\n            if (numsMap.get(computedNum) === i) {\r\n                continue;\r\n            }\r\n            result = [i, numsMap.get(computedNum)]\r\n            break;\r\n        }\r\n    }\r\n    return result;\r\n};\r\n```\r\n\r\n\r\n## 复杂度分析\r\n时间复杂度：O(n)   最多2次循环  2n；\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/21#issuecomment-2081382080","body":"## 思路\r\n使用hash表，遍历数组，每遇到一次一样的就+1，这样就有了key为元素，value为重复次数的map。\r\n将这个map转换成为数组，然后进行sort排序，通过slice切割（或者设置length），获得排名前k的数组。最后再通过map方法转换成为输出的数组形式即可。\r\n\r\n\r\n## 代码\r\n```javascript\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar topKFrequent = function (nums, k) {\r\n  const timesMap = new Map();\r\n  for (const num of nums) {\r\n    if (timesMap.has(num)) {\r\n      timesMap.set(num, timesMap.get(num) + 1);\r\n    } else {\r\n      timesMap.set(num, 1);\r\n    }\r\n  }\r\n\r\n  // 迭代数组\r\n  const generatorArr = [...timesMap];\r\n  const result = generatorArr\r\n    .sort((a, b) => {\r\n      return b[1] - a[1];\r\n    })\r\n    .slice(0, k)\r\n    .map((item) => item[0]);\r\n\r\n  return result;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度：O(nlogn)\r\n空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/22#issuecomment-2081401531","body":"## 思路\r\n乍一看题目其实没有看明白，就挺离谱的。看了一下解法才知道是咋肥四。\r\n这个就是要找到在直角坐标系中给出的三个点里，是不是有个点在其他两点的垂直平分线上。\r\n这里因为要求距离相等的次数，那么用map存储的话效率最高；\r\n* 外层遍历给出的点。\r\n* 然后内层再遍历所有点。\r\n* 求内层和外层距离差的平方和。\r\n* 排列组合是 C m 2     也就可以写成   m*(m-1)条路径；\r\n* 将所有遍历出的结果求和就得到了最终的返回值。\r\n\r\n## 代码\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=447 lang=javascript\r\n *\r\n * [447] 回旋镖的数量\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {number[][]} points\r\n * @return {number}\r\n */\r\nvar numberOfBoomerangs = function (points) {\r\n  let result = 0;\r\n\r\n  for (const itemPi of points) {\r\n    const countMap = new Map();\r\n    for (const itemPj of points) {\r\n      const key =\r\n        Math.pow(itemPi[0] - itemPj[0], 2) + Math.pow(itemPi[1] - itemPj[1], 2);\r\n      countMap.set(key, (countMap.get(key) || 0) + 1);\r\n    }\r\n\r\n    for (const [_, m] of [...countMap]) {\r\n      result += m * (m - 1);\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n// @lc code=end\r\n\r\n```\r\n## 复杂度分析\r\n时间复杂度：O(n^2)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/23#issuecomment-2083141371","body":"## 思路\r\n双指针，从开始向后遍历内部指针向后遍历，然后内容用Set存储，这样可以以O（1）的复杂度快速获取值进行比较。\r\n\r\n## 代码\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=3 lang=javascript\r\n *\r\n * [3] 无重复字符的最长子串\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nvar lengthOfLongestSubstring = function (s) {\r\n  const ss = new Set();\r\n  let result = 0;\r\n  let p = -1;\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (i !== 0) {\r\n      ss.delete(s.charAt([i - 1]));\r\n    }\r\n\r\n    while (p + 1 < s.length && !ss.has(s.charAt(p + 1))) {\r\n      ss.add(s.charAt(p + 1));\r\n      p++;\r\n    }\r\n\r\n    result = Math.max(result, p - i + 1);\r\n  }\r\n\r\n  return result;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度：O(n);\r\n空间复杂度：O(m);  m是所有不同字符集的长度","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/26#issuecomment-2088763650","body":"## 思路\r\n链表求中间值，那么就两个指针，一个指针跨2步，一个指针跨1步，当跨2步的指针到头之后，那么跨一步的指针正好指向中间。\r\n\r\n## 代码\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar middleNode = function (head) {\r\n    let [p1, p2] = [head, head];\r\n    while (p2 && p2.next) {\r\n        p1 = p1.next;\r\n        p2 = p2.next.next;\r\n    }\r\n\r\n    return p1;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(n); 应该是链表长度的一半 n/2 \r\n* 空间复杂度：O(1); 只用到了两个变量   ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/27#issuecomment-2107256468","body":"\r\n## 代码\r\n```javascript\r\n/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar removeDuplicates = function (nums) {\r\n    var p = 0;\r\n    var n = nums.length;\r\n    for (let i = 1; i < n; i++) {\r\n        if (nums[i] != nums[i - 1]) {\r\n            p++;\r\n            nums[p] = nums[i];\r\n        }\r\n    }\r\n    return p + 1;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":false},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/33#issuecomment-2107174875","body":"## 代码\r\n```javascript\r\n/**\r\n * @param {string} moves\r\n * @return {boolean}\r\n */\r\nvar judgeCircle = function(moves) {\r\n    const position = { x: 0, y: 0 };\r\n\r\n  for (let i = 0; i < moves.length; i++) {\r\n    const item = moves[i];\r\n    if (item === \"U\") {\r\n      position.y++;\r\n    }\r\n    if (item === \"L\") {\r\n      position.x--;\r\n    }\r\n    if (item === \"R\") {\r\n      position.x++;\r\n    }\r\n    if (item === \"D\") {\r\n      position.y--;\r\n    }\r\n  }\r\n\r\n  return position.x === 0 && position.y === 0;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":false},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/37#issuecomment-2107126828","body":"## 思路\r\n快排\r\n\r\n## 代码\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=912 lang=javascript\r\n *\r\n * [912] 排序数组\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {number[]} nums\r\n * @return {number[]}\r\n */\r\nvar sortArray = function (nums) {\r\n  if (nums.length <= 1) {\r\n    return nums;\r\n  }\r\n\r\n  // 获取中点下标\r\n  const midIdx = Math.floor(nums.length / 2);\r\n\r\n  // 获取中点元素\r\n  const mid = nums[midIdx];\r\n  const left = [];\r\n  const right = [];\r\n\r\n  // 遍历数组，将小于中点的元素放入left数组，大于中点的元素放入right数组\r\n  for (let i = 0; i < nums.length; i++) {\r\n    if (i === midIdx) continue;\r\n    if (nums[i] < mid) {\r\n      left.push(nums[i]);\r\n    } else {\r\n      right.push(nums[i]);\r\n    }\r\n  }\r\n\r\n  return [...sortArray(left), mid, ...sortArray(right)];\r\n};\r\n// @lc code=end\r\n\r\n```\r\n## 复杂度分析\r\n时间复杂度：O(nlogn) ~ O(n^2)\r\n空间复杂度：O(log n) ~ O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/38#issuecomment-2112939373","body":"## 方法\r\n远古记忆被唤醒, 这个好像没有在官方题解中。已知平方根永远小于等于 1/2 原值。然后遍历1~ x/2 求平方，如果大于 x 则退出循环。对应的下标对应-1就是其平方根的下取整。\r\n\r\n## 代码\r\n```javascript\r\n/**\r\n * @param {number} x\r\n * @return {number}\r\n */\r\nvar mySqrt = function(x) {\r\n    if (x === 1) {\r\n        return 1;\r\n    }\r\n    let res = 1;\r\n    while(res <= x / 2) {\r\n        res ++;\r\n        if (res * res > x) {\r\n\r\n            break;\r\n        }\r\n    }\r\n    return res - 1;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度：O(log n)\r\n空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/39#issuecomment-2112918537","body":"## 思路\r\n二分法\r\n\r\n## 代码\r\n```javascript\r\n/**\r\n * @param {function} isBadVersion()\r\n * @return {function}\r\n */\r\nvar solution = function(isBadVersion) {\r\n    /**\r\n     * @param {integer} n Total versions\r\n     * @return {integer} The first bad version\r\n     */\r\n    return function(n) {\r\n        let l = 1, r = n;\r\n        while(l < r) {\r\n            const m = Math.floor(l + (r - l) / 2)\r\n            if (isBadVersion(m)) {\r\n                r = m;\r\n            } else {\r\n                l = m + 1;\r\n            }\r\n        }\r\n\r\n        return l;\r\n    };\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度：O(log n)\r\n空间复杂度：O(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/44#issuecomment-2120723083","body":"## 思路\r\n滑动窗口\r\n\r\n## 代码\r\n```javascript\r\nconst isVowel = (ch) => {\r\n    return ['a', 'e', 'i', 'o', 'u'].includes(ch) ? 1 : 0;\r\n}\r\n/**\r\n * @param {string} s\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar maxVowels = function(s, k) {\r\n    const len = s.length;\r\n    let count = 0;\r\n    for (let i = 0; i < k; i++) {\r\n        count += isVowel(s[i]);\r\n    }\r\n\r\n    let ans = count;\r\n    for (let i = k; i < len; i++) {\r\n        count += isVowel(s[i]) - isVowel(s[i - k]);\r\n        ans = Math.max(ans, count);\r\n    }\r\n\r\n    return ans;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度: O(n)l;\r\n空间复杂度: O(1);","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/49#issuecomment-2139029412","body":"## 解法\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=401 lang=javascript\r\n *\r\n * [401] 二进制手表\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {number} turnedOn\r\n * @return {string[]}\r\n */\r\nvar readBinaryWatch = function (turnedOn) {\r\n  const result = [];\r\n\r\n  for (let h = 0; h < 12; h++) {\r\n    for (let m = 0; m < 60; m++) {\r\n      if (\r\n        h.toString(2).split(0).join(\"\").length +\r\n          m.toString(2).split(0).join(\"\").length ===\r\n        turnedOn\r\n      ) {\r\n        const minuteNum = m < 10 ? `0${m}` : m;\r\n        result.push(`${h}:${minuteNum}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n// @lc code=end\r\n\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(1); 可枚举场景\r\n* 空间复杂度：O(1);","onTime":false},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/53#issuecomment-2137731706","body":"## 原理\r\n\r\n## 代码\r\n```javascript\r\n/**\r\n * @param {number[]} status\r\n * @param {number[]} candies\r\n * @param {number[][]} keys\r\n * @param {number[][]} containedBoxes\r\n * @param {number[]} initialBoxes\r\n * @return {number}\r\n */\r\nvar maxCandies = function(status, candies, keys, containedBoxes, initialBoxes) {\r\n    const needKeys = new Set();\r\n    let sum = 0;\r\n    let queue = initialBoxes;\r\n    while (queue.length) {\r\n        const i = queue.shift();\r\n        if (status[i]) {\r\n            sum += candies[i];\r\n            queue.push(...containedBoxes[i]);\r\n            for (const key of keys[i]) {\r\n                status[key] = 1;\r\n                if (needKeys.has(key)) {\r\n                    queue.push(key);\r\n                    needKeys.delete(key);\r\n                }\r\n            }\r\n        } else {\r\n            needKeys.add(i)\r\n        }\r\n    }\r\n\r\n    return sum;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(n);\r\n* 空间复杂度：O(n);","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/55#issuecomment-2141333600","body":"## 解法描述\r\n一通遍历，让每次比较走一步或者走两步相加结果的最小值求出来，然后累加即可\r\n\r\n## 代码\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=746 lang=javascript\r\n *\r\n * [746] 使用最小花费爬楼梯\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {number[]} cost\r\n * @return {number}\r\n */\r\nvar minCostClimbingStairs = function (cost) {\r\n  let [prev, curr] = [0, 0];\r\n  for (let i = 2; i <= cost.length; i++) {\r\n    const next = Math.min(curr + cost[i - 1], prev + cost[i - 2]);\r\n    prev = curr;\r\n    curr = next;\r\n  }\r\n\r\n  return curr;\r\n};\r\n// @lc code=end\r\n\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(n);\r\n* 空间复杂度：O(1);","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/58#issuecomment-2145341920","body":"## 解题思路\r\n动态规划\r\n\r\n## 代码\r\n```javascript\r\nconst [t1Len, t2Len] = [text1.length, text2.length];\r\n  const dp = new Array(t1Len + 1)\r\n    .fill(0)\r\n    .map(() => new Array(t2Len + 1).fill(0));\r\n  for (let i = 0; i < t1Len; i++) {\r\n    const item = text1[i];\r\n\r\n    for (let j = 0; j < t2Len; j++) {\r\n      const cur = text2[j];\r\n      if (item === cur) {\r\n        dp[i + 1][j + 1] = dp[i][j] + 1;\r\n      } else {\r\n        dp[i + 1][j + 1] = Math.max(dp[i][j + 1], dp[i + 1][j]);\r\n      }\r\n    }\r\n  }\r\n  return dp[t1Len][t2Len];\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(mn);\r\n* 空间复杂度：O(mn);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/59#issuecomment-2147785117","body":"## \r\n动态规划，每个位置决定了向下或向右两个方向。故f[i][j] = f[i -1] + f[j - 1];来决定。\r\n\r\n## 代码\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=62 lang=javascript\r\n *\r\n * [62] 不同路径\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {number} m\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nvar uniquePaths = function (m, n) {\r\n  let dp = new Array(m).fill(1);\r\n\r\n  for (let i = 1; i < n; i++) {\r\n    for (let j = 1; j < m; j++) {\r\n      dp[j] += dp[j - 1];\r\n    }\r\n  }\r\n\r\n  return dp[m - 1];\r\n};\r\n// @lc code=end\r\n\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(m*n);\r\n* 空间复杂度：O(m*n);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/60#issuecomment-2149390370","body":"## 思路\r\n跟昨天的思路一样，动态窗口；\r\n\r\n## 代码\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=688 lang=javascript\r\n *\r\n * [688] 骑士在棋盘上的概率\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {number} n\r\n * @param {number} k\r\n * @param {number} row\r\n * @param {number} column\r\n * @return {number}\r\n */\r\nconst pos = [\r\n  [-2, -1],\r\n  [-2, 1],\r\n  [2, -1],\r\n  [2, 1],\r\n  [-1, -2],\r\n  [-1, 2],\r\n  [1, -2],\r\n  [1, 2],\r\n];\r\nvar knightProbability = function (n, k, row, column) {\r\n  const dp = new Array(k + 1)\r\n    .fill(0)\r\n    .map(() => new Array(n).fill(0).map(() => new Array(n).fill(0)));\r\n\r\n  for (let step = 0; step <= k; step++) {\r\n    for (let i = 0; i < n; i++) {\r\n      for (let j = 0; j < n; j++) {\r\n        if (step === 0) {\r\n          dp[step][i][j] = 1;\r\n        } else {\r\n          for (let [dx, dy] of pos) {\r\n            const x = i + dx;\r\n            const y = j + dy;\r\n            if (x >= 0 && x < n && y >= 0 && y < n) {\r\n              dp[step][i][j] += dp[step - 1][x][y] / 8;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return dp[k][row][column];\r\n};\r\n// @lc code=end\r\n\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(k*n^2);\r\n* 空间复杂度：O(k*n^2);","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/65#issuecomment-2158464378","body":"## 思路\r\n\r\n## 代码\r\n```javascript\r\n/**\r\n * @param {number} amount\r\n * @param {number[]} coins\r\n * @return {number}\r\n */\r\nvar change = function (amount, coins) {\r\n    const dp = new Array(amount + 1).fill(0);\r\n    dp[0] = 1;\r\n    for (const item of coins) {\r\n        for (let i = item; i <= amount; i++) {\r\n            dp[i] += dp[i - item];\r\n        }\r\n    }\r\n    return dp[amount]\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(amount * n);\r\n* 空间复杂度：O(amount);","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/67#issuecomment-2161128141","body":"\r\n## 代码\r\n```javascript\r\n/**\r\n * @param {number[][]} intervals\r\n * @return {number}\r\n */\r\nvar eraseOverlapIntervals = function (intervals) {\r\n    if (intervals.length === 0) return 0;\r\n    intervals.sort((a, b) => a[1] - b[1]);\r\n\r\n    const len = intervals.length;\r\n    let right = intervals[0][1];\r\n    let count = 1;\r\n    for (let i = 1; i < len; i++) {\r\n        if (intervals[i][0] >= right) {\r\n            count++;\r\n            right = intervals[i][1];\r\n        }\r\n    }\r\n\r\n    return len - count;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(n)；\r\n* 空间复杂度：O(n)；","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/69#issuecomment-2167818803","body":"## 代码\r\n```javascript\r\n/**\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nvar numTrees = function(n) {\r\n    let G = []\r\n    G.length = n + 1;\r\n    G.fill(0);\r\n    G[0] = G[1] = 1;\r\n\r\n    for (let i = 2; i <= n; i++) {\r\n        for (let j = 1; j <= i; j++) {\r\n            G[i] += G[j - 1] * G[i - j];\r\n        }\r\n    }\r\n    return G[n]\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(n^2)；\r\n* 空间复杂度：O(n)；","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/72#issuecomment-2174999788","body":"## 思路\r\n用hash表存储计数\r\n\r\n## 解法\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=260 lang=javascript\r\n *\r\n * [260] 只出现一次的数字 III\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {number[]} nums\r\n * @return {number[]}\r\n */\r\nvar singleNumber = function (nums) {\r\n  const countMap = new Map();\r\n  for (const num of nums) {\r\n    countMap.set(num, (countMap.get(num) || 0) + 1);\r\n  }\r\n  const ans = [];\r\n  for (const [num, count] of countMap) {\r\n    if (count === 1) {\r\n      ans.push(num);\r\n    }\r\n  }\r\n  return ans;\r\n};\r\n// @lc code=end\r\n\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(n);\r\n* 空间复杂度：O(n);","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/73#issuecomment-2174996070","body":"## 思路\r\n我通过递归实现的\r\n\r\n## 代码\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=78 lang=javascript\r\n *\r\n * [78] 子集\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {number[]} nums\r\n * @return {number[][]}\r\n */\r\nvar subsets = function (nums) {\r\n  const select = [];\r\n  const ans = [];\r\n  const dfs = (index) => {\r\n    if (index === nums.length) {\r\n      ans.push([...select]);\r\n      return;\r\n    }\r\n    select.push(nums[index]);\r\n    dfs(index + 1);\r\n    select.pop();\r\n    dfs(index + 1);\r\n  };\r\n  dfs(0);\r\n  return ans;\r\n};\r\n// @lc code=end\r\n\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(n * 2 ^ n);\r\n* 空间复杂度：O(n);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/74#issuecomment-2177460409","body":"##\r\n\r\n## 代码\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=208 lang=javascript\r\n *\r\n * [208] 实现 Trie (前缀树)\r\n */\r\n\r\n// @lc code=start\r\n\r\nvar Trie = function () {\r\n  this.children = {};\r\n};\r\n\r\n/**\r\n * @param {string} word\r\n * @return {void}\r\n */\r\nTrie.prototype.insert = function (word) {\r\n  let node = this.children;\r\n  for (const str of word) {\r\n    if (!node[str]) {\r\n      node[str] = {};\r\n    }\r\n    node = node[str];\r\n  }\r\n  node.isEnd = true;\r\n};\r\n\r\n/**\r\n * @param {string} prefix\r\n * @return {boolean}\r\n */\r\nTrie.prototype.startsWith = function (prefix) {\r\n  let node = this.children;\r\n  for (const str of prefix) {\r\n    if (!node[str]) {\r\n      return false;\r\n    }\r\n    node = node[str];\r\n  }\r\n  return node;\r\n};\r\n\r\n/**\r\n * @param {string} word\r\n * @return {boolean}\r\n */\r\nTrie.prototype.search = function (word) {\r\n  const node = this.startsWith(word);\r\n  return node !== null && node.isEnd === true;\r\n};\r\n\r\n/**\r\n * Your Trie object will be instantiated and called as such:\r\n * var obj = new Trie()\r\n * obj.insert(word)\r\n * var param_2 = obj.search(word)\r\n * var param_3 = obj.startsWith(prefix)\r\n */\r\n// @lc code=end\r\n\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：初始化是O(1)，其余 O(n); n是word.length;\r\n* 空间复杂度：O(n); n是word.length;","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/75#issuecomment-2180962548","body":"\r\n## 代码\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=677 lang=javascript\r\n *\r\n * [677] 键值映射\r\n */\r\n\r\n// @lc code=start\r\n\r\nvar MapSum = function () {\r\n  this.map = new Map();\r\n};\r\n\r\n/**\r\n * @param {string} key\r\n * @param {number} val\r\n * @return {void}\r\n */\r\nMapSum.prototype.insert = function (key, val) {\r\n  this.map.set(key, val);\r\n};\r\n\r\n/**\r\n * @param {string} prefix\r\n * @return {number}\r\n */\r\nMapSum.prototype.sum = function (prefix) {\r\n  let sum = 0;\r\n  for (const key of this.map.keys()) {\r\n    if (key.startsWith(prefix)) {\r\n      sum += this.map.get(key);\r\n    }\r\n  }\r\n\r\n  return sum;\r\n};\r\n\r\n/**\r\n * Your MapSum object will be instantiated and called as such:\r\n * var obj = new MapSum()\r\n * obj.insert(key,val)\r\n * var param_2 = obj.sum(prefix)\r\n */\r\n// @lc code=end\r\n\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(m * n); m是插入map属性的个数，n是前缀的长度；\r\n* 空间复杂度：O(m * n); m是插入map属性的个数，n是key的长度；","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/80#issuecomment-2187857391","body":"## 思路\r\n递归\r\n\r\n## 代码\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=814 lang=javascript\r\n *\r\n * [814] 二叉树剪枝\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n\r\n/**\r\n * @param {TreeNode} root\r\n * @return {TreeNode}\r\n */\r\nvar pruneTree = function (root) {\r\n  if (!root) return null;\r\n  root.left = pruneTree(root.left);\r\n  root.right = pruneTree(root.right);\r\n  if (root.val === 0 && !root.left && !root.right) return null;\r\n\r\n  return root;\r\n};\r\n// @lc code=end\r\n\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(n);\r\n* 空间复杂度：O(n);","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null],"alexzhang-mini":[{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/1#issuecomment-2042571062","body":"## 代码\n\n```python\nclass Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        K = list(map(int,str(K)))\n        \n        diff = len(K) - len(A)\n        if diff: A = [0] * diff + A \n        if diff < 0: K = [0] * (-diff) + K\n        \n        flag = 0\n        for i in range(len(A)-1,-1,-1):\n            bit = A[i] + K[i] + flag\n            flag = 0\n            if bit >= 10:\n                flag = 1\n                bit %= 10\n            A[i] = bit \n        if flag: A = [1] + A \n        return A\n```\n\n时间复杂度：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/2#issuecomment-2046525998","body":"\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        result = [0] * len(s)\n        c_indices = [i for i in range(len(s)) if s[i] == c]\n        for i in range(len(s)):\n            min_distance = float('inf')\n            for index in c_indices:\n                distance = abs(index - i)\n                min_distance = min(min_distance, distance)\n            result[i] = min_distance\n        return result\n```\n\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/3#issuecomment-2046532493","body":"```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n         if self.stack:\n            return self.stack.pop()\n         else:\n            return -1  \n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len(self.stack))):\n            self.stack[i] += val\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/4#issuecomment-2058285278","body":"class Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        current_str = \"\"\n        repeat_num = 0\n\n        for char in s:\n            if char.isdigit():\n                repeat_num = repeat_num * 10 + int(char)\n            elif char.isalpha():\n                current_str += char\n            elif char == \"[\":\n                stack.append((current_str, repeat_num))\n                current_str = \"\"\n                repeat_num = 0\n            elif char == \"]\":\n                last_str, last_repeat = stack.pop()\n                current_str = last_str + current_str * last_repeat\n\n        return current_str\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/5#issuecomment-2058289316","body":"class MyQueue:\n   def __init__(self):\n       self.input_stack = []  # 用于入队操作\n       self.output_stack = []  # 用于出队操作\n\n   def push(self, x: int) -> None:\n       self.input_stack.append(x)\n\n   def pop(self) -> int:\n       self._transfer_if_needed()\n       return self.output_stack.pop()\n\n   def peek(self) -> int:\n       self._transfer_if_needed()\n       return self.output_stack[-1]\n\n   def empty(self) -> bool:\n       return not self.input_stack and not self.output_stack\n\n   def _transfer_if_needed(self):\n       if not self.output_stack:\n           while self.input_stack:\n               self.output_stack.append(self.input_stack.pop())\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/6#issuecomment-2058300417","body":"```python\nclass Solution:\n    def maxChunksToSorted(self, arr: list[int]) -> int:\n        length = 0\n        cnt = 0\n        while length < len(arr):\n            j = 0\n            lefttemp = arr[length:length + j + 1]\n            righttmep = arr[length + j + 1:]\n            while len(righttmep) and max(lefttemp) > min(righttmep):\n                j += 1\n                lefttemp = arr[length:length + j + 1]\n                righttmep = arr[length + j + 1:]\n                if not len(righttmep) or max(lefttemp) <= min(righttmep):\n                    break\n            length += len(lefttemp)\n            cnt += 1\n        return cnt\n\n```\n\n\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/7#issuecomment-2058303980","body":"```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next or k == 0:\n            return head\n        \n        length = 1\n        tail = head\n        while tail.next:\n            tail = tail.next\n            length += 1\n        \n        k = k % length\n        if k == 0:\n            return head\n\n        tail.next = head\n        \n        new_head_prev = head\n        for i in range(length - k - 1):\n            new_head_prev = new_head_prev.next\n        \n        new_head = new_head_prev.next\n        new_head_prev.next = None\n        \n        return new_head\n\n```\n\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/8#issuecomment-2058306020","body":"```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode(0)\n        dummy.next = head\n        current = dummy\n        \n        while current.next and current.next.next:\n            first = current.next\n            second = current.next.next\n            first.next = second.next\n            current.next = second\n            current.next.next = first\n            current = current.next.next\n        \n        return dummy.next\n\n```\n\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/9#issuecomment-2058308520","body":"```python\nclass Solution:\n    def findMiddle(self, head):\n        if not head or not head.next:\n            return head\n        \n        prev_ptr = None\n        slow_ptr = head\n        fast_ptr = head\n        \n        while fast_ptr and fast_ptr.next:\n            prev_ptr = slow_ptr\n            slow_ptr = slow_ptr.next\n            fast_ptr = fast_ptr.next.next\n        \n        if prev_ptr:\n            prev_ptr.next = None\n        \n        return slow_ptr\n    \n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return None\n        \n        mid = self.findMiddle(head)\n        root = TreeNode(mid.val)\n        \n        if head == mid:  \n            return root\n        \n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(mid.next)\n        \n        return root\n\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xil324":[{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/1#issuecomment-2042728270","body":"```\nvar addToArrayForm = function (num, k) {\n    const res = []; \n    let index = num.length - 1; \n    let currSum = k; \n    while(index >= 0 || currSum > 0) {\n        if(index >= 0) {\n            currSum += num[index]; \n            index--; \n        }\n        res.push(currSum % 10);\n        currSum = Math.floor(currSum / 10); \n    }\n    return res.reverse()\n};\n```\n\n思路：\n\n一个数组num和数字k相加，第一个想法是把数字转换层数组，然后从两个数组的末尾依次相加， 如何和超过10则进一位。 这样和用k与每一个num的数字相加，然后保留和的尾数，k除以10 是一样的。\n例如： \nnum = [1,2,3]\nk = 79\n- 79 + 3 = 82   [2]\n- 82/ 10 -> 8  \n- 8 + 2 = 10 [2, 0]\n- 10/10 -> 1\n- 1 + 1 = 2 [2, 0, 2]\n\n数组反转： [2,0,2]\n\n时间复杂度：\nnum长度为n, k包含的数组为m \n- n >= m O(n)\n- n < m. O(log(k))\n综合 O(max(n, log(k)) \n\n空间复杂度：\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/2#issuecomment-2044072899","body":"\nfrom left to right: \nstartIndex = 11 \n[l,o,v,e,l,e,e,t,c,o,d,e] \n[11,10,9,0,1,0,0,1,2,3,4,0]\n\nfrom right to left:\nstartIndex = 0\n[3,2,1,0,1,0,0,4,3,2,1,0]\n\ncompare two arrays to get the min \n\n```\nvar shortestToChar = function(s, c) {\n    const res = []; \n    let index = s.length - 1; \n    for(let i = 0; i < s.length; i++) {\n        if(s[i] === c) index = i;\n        res[i] = Math.abs(index - i);  \n    }\n\n    index = 0;\n    for(let i = s.length-1; i >=0; i--) {\n        if(s[i] === c) index = i;\n        res[i] = Math.min(res[i], Math.abs(index - i)); \n    }\n\n    return res; \n    \n};\n```\ntime complexity: O(n)\nspace complexity: O(n)\n\n\n\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/3#issuecomment-2046475194","body":"```\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize; \n    this.stack = []; \n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stack.length === this.maxSize) return; \n    this.stack.push(x); \n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.stack.length === 0) return -1;\n    return this.stack.pop(); \n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    console.log(k, this.stack)\n    for (let i=0; i < k; i++) {\n        if(i < this.stack.length) {\n            this.stack[i] += val\n        }\n    }\n};\n\n```\ntime complexity: \npush: O(1) pop: O(1) increment O(k)\nspace complexity: O(n) n = maxSize","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/4#issuecomment-2049650306","body":"```\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    const stack = []; \n    for(const char of s) {\n        if(char !== ']') {\n            stack.push(char); \n            continue; \n        } \n        let arr = []; \n        while(stack.length && stack[stack.length-1] !== '['){\n            arr.unshift(stack.pop())\n        }\n        stack.pop(); \n        const str = arr.join(\"\"); \n\n        let repeatNumberArr = []\n        while(!Number.isNaN(Number(stack[stack.length-1]))) {\n            repeatNumberArr.unshift(stack.pop())\n        }\n        stack.push(str.repeat(Number(repeatNumberArr.join(\"\"))))\n    }\n    return stack.join(\"\")\n};\n```\ntime complexity: O(n) where n is the length of the string\nspace complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/5#issuecomment-2050790223","body":"```\nvar MyQueue = function () {\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n    this.stack.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n    const removeElement = this.stack.shift();\n    return removeElement;\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n    return this.stack[0]\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n    return this.stack.length === 0\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/6#issuecomment-2053106127","body":"```\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    const stack = []; \n    for(const val of arr) {\n        if(!stack.length || stack[stack.length-1]<=val) {\n            stack.push(val); \n        } else {\n            const currentMaxVal = stack.pop(); \n            while(stack.length && stack[stack.length-1] > val) {\n                stack.pop(); \n            }\n            stack.push(currentMaxVal); \n        }\n    }\n    return stack.length; \n};\n```\ntime complexity: O(n) where n is the length of the array\nspace complexity: O(n) where n is the length of the array","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/7#issuecomment-2054080712","body":"```\nvar rotateRight = function(head, k) {\n    if(!head) return head;\n    let length = 0;\n    let node = head;\n    while(node) {\n        node = node.next;\n        length += 1;\n    }\n    k = k % length;\n    let slow = head, fast = head, result = head;\n    while(fast.next) {\n        fast = fast.next;\n        k -= 1;\n        if(k < 0) {\n            slow = slow.next; \n        }\n    }\n    fast.next = head;\n    result = slow.next;\n    slow.next = null\n    return result;\n};\n```\ntime complexity: O(n)\nspace complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/8#issuecomment-2056869909","body":"```\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    if(head === null || head.next === null) return head;\n    let first = head, second = head.next, rest = head.next.next;\n    second.next = first;\n    first.next = swapPairs(rest);\n    return second; \n};\n```\ntime complexity: O(n)\nspace complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/9#issuecomment-2058207851","body":"```\n**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    const arr = []; \n    while(head) {\n        arr.push(head.val);\n        head = head.next;\n    }\n    return createTree(arr, 0, arr.length-1);\n};\n\nfunction createTree(arr, left, right) {\n    if(left > right) return null; \n    const mid = Math.floor((left + right)/2); \n    const node = new TreeNode(arr[mid]);\n    if(left === right) return node;\n    node.left = createTree(arr, left, mid -1);\n    node.right = createTree(arr, mid + 1, right);\n    return node; \n}\n```\ntime complexity: O(n)\nspace complexity:  O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/10#issuecomment-2060317566","body":"```\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    let first = headA, second = headB;\n    while(first !== second) {\n       first !== null ? first = first.next : first = headB;\n       second !== null ? second = second.next: second = headA;\n    }\n    return first;\n}; \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/11#issuecomment-2062941774","body":"```\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    let slow = head, fast = head;\n    while(fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if(slow === fast) break;\n    }\n    if(!fast || !fast.next) return null;\n    fast = head;\n    while (slow !== fast) {\n        slow = slow.next;\n        fast = fast.next;\n    }\n    return fast; \n};\n```\ntime complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/12#issuecomment-2066583108","body":"/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map();\n    this.head = new ListNode(-1,-1);\n    this.tail = new ListNode(-1,-1); \n    this.head.next = this.tail;\n    this.tail.prev = this.head; \n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if(!this.cache.has(key)) return -1; \n    const node = this.cache.get(key);\n    this.remove(node);\n    this.add(node);\n    return node.val;\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    if(this.cache.has(key)) {\n        const node = this.cache.get(key);\n        this.remove(node); \n    }\n    const newNode = new ListNode(key, value); \n    this.cache.set(key, newNode);\n    this.add(newNode); \n    \n    if(this.cache.size > this.capacity) {\n        const nodeToDelete = this.head.next; \n        this.remove(nodeToDelete); \n        this.cache.delete(nodeToDelete.key)\n    }\n };\n\n\n /** \n * @param {ListNode} node \n * @return {void}\n */\n\nLRUCache.prototype.add = function (node) {\n    const nodeBeforeTail = this.tail.prev;\n    nodeBeforeTail.next = node;\n    node.prev = nodeBeforeTail;\n    node.next = this.tail;\n    this.tail.prev = node;\n}\n\n /** \n * @param {ListNode} node \n * @return {void}\n */\nLRUCache.prototype.remove = function(node) {\n    node.prev.next = node.next;\n    node.next.prev = node.prev; \n}\n\n class ListNode {\n    constructor (key,val) {\n        this.key = key;\n        this.val = val;\n        this.next = null; \n        this.prev = null; \n    }\n }","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/14#issuecomment-2067877229","body":"/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n   if(!p && !q) return true; \n   if(!p || !q)  return false; \n   if(p.val !== q.val) return false;\n   return isSameTree(p.left, q.left) && isSameTree(p.right ,  q.right)\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/15#issuecomment-2068286367","body":"/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root) {\n    let totalSum = 0; \n    traveseToGetSum(root, []); \n    return totalSum;\n\n    function traveseToGetSum(node, path) {\n        if(!node) return \n        path.push(node.val)\n        if(!node.left && !node.right) {\n            totalSum += parseInt(path.join(\"\"))\n        }\n        traveseToGetSum(node.left, path);\n        traveseToGetSum(node.right, path);\n        path.pop()\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/16#issuecomment-2072315754","body":"/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar findBottomLeftValue = function(root) {\n     const queue = [], levels = [];\n     queue.push(root);\n     while(queue.length) {\n        const level = []\n        const queueSize = queue.length;\n        for(let i = 0; i<queueSize; i++) {\n            const node = queue.shift();\n            level.push(node.val); \n            if(node.left) queue.push(node.left);\n            if(node.right) queue.push(node.right); \n        }\n        levels.push(level)\n     }\n     return levels[levels.length-1][0]\n     \n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/17#issuecomment-2073803649","body":"/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n    const serializationRes = []; \n    traverseToSerializeTree(root, serializationRes);\n    return serializationRes.join(';'); \n\n\n    function traverseToSerializeTree(node, result) {\n        if(!node) {\n            result.push('NULL');\n            return;\n        }\n        result.push(node.val);\n        traverseToSerializeTree(node.left, result);\n        traverseToSerializeTree(node.right, result);\n    }\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n    if(!data) return []; \n    const nodeList = data.split(';'); \n    return traverseToGenerateTree(nodeList); \n\n    function traverseToGenerateTree(nodes) {\n        const value = nodes.shift(); \n        if(value === 'NULL'  || !nodes.length) return null;\n        const node = new TreeNode(value)\n        node.left =  traverseToGenerateTree(nodes);\n        node.right = traverseToGenerateTree(nodes);\n        return node; \n    }\n    \n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/18#issuecomment-2077222360","body":"/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar verticalOrder = function(root) {\n    if(!root) return []; \n    const nodeList = {}; \n    let min = Infinity\n    let max = Infinity * (-1) \n    const queue = [];\n    queue.push([root, 0]); \n    while(queue.length) {\n        const [current, index] = queue.shift();\n        min = Math.min(index, min);\n        max = Math.max(index,max);\n      \n        if(!nodeList[index]) {\n            nodeList[index] = []; \n        }\n        nodeList[index].push(current.val)\n        if (current.left) {\n            queue.push([current.left, index-1]);\n        }\n        if(current.right) {\n           queue.push([current.right, index+1]);\n        }\n    }\n \n    const result = []; \n    for (let i = min; i < max+ 1; i++) {\n        result.push(nodeList[i])\n    }\n    return result\n\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/20#issuecomment-2079394895","body":"var twoSum = function(nums, target) {\n    const numberMap = {};\n    for(let i = 0; i < nums.length; i++) {\n        const need = target - nums[i];\n        if(need in numberMap) {\n            return [i, numberMap[need]]\n        } else{\n            numberMap[nums[i]] =i; \n        }\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/21#issuecomment-2080331739","body":"/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar topKFrequent = function(nums, k) {\n    const frequencyMap = {}; \n    for(const num of nums) {\n        if(!(num in frequencyMap)) {\n            frequencyMap[num] = 1; \n        } else {\n            frequencyMap[num] += 1; \n        }\n    }\n\n    const sortedFrequencyMap =  Object.entries(frequencyMap).sort((a,b) => b[1] - a[1]); \n    const res  = []; \n    for(let i = 0; i < k; i++) {\n        res.push(sortedFrequencyMap[i][0])\n    }\n    return res;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/22#issuecomment-2081269870","body":" ```\nvar numberOfBoomerangs = function(points) {\n    let ans = 0; \n    for(let i= 0; i < points.length; i++) {\n        const [x,y] = points[i];\n        const countMap = {}; \n        for(const point of points) {\n            const squaredDist = (point[0]-x) **2 + (point[1]-y) **2;\n            if(squaredDist in countMap) {\n                countMap[squaredDist] += 1; \n            }else {\n                countMap[squaredDist] = 1; \n            }\n        } \n        Object.values(countMap).forEach((val) => {\n            ans += val * (val - 1); \n        })\n    }\n    return ans; \n};\n```\n// time complexity: O(n^2);\n// space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/23#issuecomment-2081669083","body":"\n```\nvar lengthOfLongestSubstring = function(s) {\n    let maxLen = 0; \n    let left = 0, right = 0;\n    const freqMap = {};\n    while (right < s.length) {\n        const char = s[right];\n        if(char in freqMap) {\n            freqMap[char] += 1;\n        } else {\n            freqMap[char] = 1;\n        }\n        while(freqMap[char] > 1) {\n            freqMap[s[left]]--;\n            left++; \n        }\n        maxLen = Math.max(maxLen, right-left+1); \n        right++\n    }\n    return maxLen;\n};\n\n```\n\n// time complexity: O(n)\n// space complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/24#issuecomment-2084283920","body":" ```\nvar findSubstring = function (s, words) {\n    const wordFreqCounts = {};\n    for (const word of words) {\n        if (!(word in wordFreqCounts)) {\n            wordFreqCounts[word] = 1\n        }else {\n            wordFreqCounts[word] += 1; \n        }\n    }\n    const res = []; \n    const wordLen = words[0].length; \n\n    for(let i = 0; i < wordLen; i++) {\n        let currMap = {}; \n        let left = i, right= i, validWords = 0; \n        while(right + wordLen <= s.length) {\n            const curr = s.slice(right, right + wordLen);\n            right += wordLen; \n            if(!(curr in wordFreqCounts)) {\n                currMap = {};\n                left = right;\n                validWords = 0; \n                continue;\n            }\n            if(currMap[curr]) {\n                currMap[curr] += 1;\n            }else {\n                currMap[curr] = 1; \n            }\n            validWords+=1;\n            while(currMap[curr] > wordFreqCounts[curr]) {\n                const wordToDelete = s.slice(left, left + wordLen); \n                currMap[wordToDelete] -= 1;\n                left += wordLen;\n                validWords -=1;\n            }\n        \n            if(validWords === words.length) {\n                res.push(left)\n            }\n        }\n    }\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/25#issuecomment-2088437944","body":"    ```\n    def minSubarray(self, nums, p):\n        \"\"\"\n        :type nums: List[int]\n        :type p: int\n        :rtype: int\n        \"\"\"\n        remainder = sum(nums) % p\n        if remainder == 0:\n            return 0\n        index_map = {0: -1}\n        min_len = len(nums)\n        pre_sum = 0\n        for i in range(len(nums)):\n            pre_sum += nums[i]\n            curr_mod = pre_sum % p\n            need = (curr_mod - remainder) % p\n            if need in index_map:\n                min_len = min(min_len, i - index_map[need])\n            index_map[curr_mod] = i\n\n        return -1 if min_len == len(nums) else min_len\n     ```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/26#issuecomment-2089370757","body":"    def middleNode(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/27#issuecomment-2092956599","body":"    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return 1\n        left = 0\n        for right in range(1,len(nums)):\n            if nums[left] != nums[right]:\n                left+=1\n                nums[left] = nums[right]\n        return left + 1\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/28#issuecomment-2093953435","body":"```\r\n    def searchInsert(self, nums, target):\r\n        \"\"\"\r\n        :type nums: List[int]\r\n        :type target: int\r\n        :rtype: int\r\n        \"\"\"\r\n        left = 0\r\n        right = len(nums)-1\r\n        if target > nums[right]:\r\n            return len(nums)\r\n        if target < nums[left]:\r\n            return 0\r\n        while left <= right:\r\n            mid = (left + right) // 2\r\n            if nums[mid] > target:\r\n                right = mid - 1\r\n            if nums[mid] < target:\r\n                left = mid + 1\r\n            if nums[mid] == target:\r\n                return mid\r\n            \r\n        return left\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/29#issuecomment-2094557584","body":"````\nclass Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        queue = MonotonicQueue()\n        res = []\n        for i in range(len(nums)):\n            if i < k - 1:\n                queue.push(nums[i])\n            else:\n                queue.push(nums[i])\n                res.append(queue.max())\n                queue.pop(nums[i-k+1])\n        return res\n\n\nclass MonotonicQueue:\n    def __init__(self):\n        self.queue = []; \n    \n    def push(self, n):\n        while self.queue and self.queue[-1] < n:\n            self.queue.pop()\n        self.queue.append(n)\n    \n    def max(self):\n        return self.queue[0]\n    \n    def pop(self,n):\n        if n == self.queue[0]:\n            self.queue.pop(0)\n\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/30#issuecomment-2094916976","body":"class Solution(object):\n    def findJudge(self, n, trust):\n        \"\"\"\n        :type n: int\n        :type trust: List[List[int]]\n        :rtype: int\n        \"\"\"\n        in_degree = [0] * (n+1)\n        out_degree = [0] * (n+1)\n        for item in trust:\n            in_degree[item[1]] += 1\n            out_degree[item[0]] += 1\n        for i in range(1, n+1):\n            if in_degree[i] == n - 1 and out_degree[i] ==0:\n                return i\n        return -1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/31#issuecomment-2096500323","body":"```\r\nclass Solution(object):\r\n    def possibleBipartition(self, n, dislikes):\r\n        \"\"\"\r\n        :type n: int\r\n        :type dislikes: List[List[int]]\r\n        :rtype: bool\r\n        \"\"\"\r\n        graph = {i: [] for i in range(n+1)}\r\n        for a, b in dislikes:\r\n            graph[a].append(b)\r\n            graph[b].append(a)\r\n        \r\n        groups = [1] * (n+1)\r\n        visited = set()\r\n        self.res = True\r\n\r\n        for i in range(1, n+1):\r\n            if i not in visited:\r\n                self.traverse(graph, i, visited, groups)\r\n        return self.res\r\n    \r\n\r\n    def traverse(self, graph, position, visited, groups):\r\n        if not self.res:\r\n            return;\r\n        visited.add(position)\r\n        for neighbor in graph[position]:\r\n            if neighbor not in visited:\r\n                groups[neighbor] = -1 * groups[position]\r\n                self.traverse(graph, neighbor,visited, groups)\r\n            else:\r\n                if groups[neighbor] == groups[position]:\r\n                    self.res = False\r\n   ```\r\n\r\nTime complexity: O(V + E)\r\n\r\nSpace complexity: O(v^2)   ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/32#issuecomment-2100595345","body":"```\r\nclass Solution(object):\r\n    def sortItems(self, n, m, group, beforeItems):\r\n        \"\"\"\r\n        :type n: int\r\n        :type m: int\r\n        :type group: List[int]\r\n        :type beforeItems: List[List[int]]\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        index = m\r\n        group_items_map = [[] for _ in range(n + m)]\r\n        for item, groupItem in enumerate(group):\r\n            if groupItem == -1:\r\n                group[item] = index\r\n                index+=1\r\n            group_items_map[group[item]].append(item)\r\n        \r\n        items_degree= [0] * n\r\n        groups_degree = [0] * (n+m)\r\n        items_graph = [[] for _ in range(n)]\r\n        groups_graph = [[] for _ in range(n+m)]\r\n\r\n        for i, groupNumber in enumerate(group):\r\n            for j in beforeItems[i]:\r\n                if group[j] == groupNumber:\r\n                    items_degree[i] += 1\r\n                    items_graph[j].append(i)\r\n                else:\r\n                    groups_degree[groupNumber] += 1\r\n                    groups_graph[group[j]].append(groupNumber)\r\n        \r\n        group_order = self.sort(groups_degree, groups_graph, list(range(n+m)))\r\n        if not group_order:\r\n            return []\r\n        \r\n        res = []\r\n        for group_index in group_order:\r\n            item_order = self.sort(items_degree,items_graph,group_items_map[group_index] )\r\n            if len(item_order) != len(group_items_map[group_index]):\r\n                return []\r\n            res.extend(item_order)\r\n        return res\r\n\r\n    def sort(self, degrees, graph, items):\r\n            queue = deque([item for item in items if degrees[item] == 0])\r\n            result = []\r\n            while queue:\r\n                current = queue.popleft()\r\n                result.append(current)\r\n                for neighbor in graph[current]:\r\n                    degrees[neighbor] -= 1\r\n                    if degrees[neighbor] == 0:\r\n                        queue.append(neighbor)\r\n            return result if len(result) == len(items) else []\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/33#issuecomment-2102566696","body":"```\r\nclass Solution(object):\r\n    def judgeCircle(self, moves):\r\n        \"\"\"\r\n        :type moves: str\r\n        :rtype: bool\r\n        \"\"\"\r\n        direction_map = {'L':[0,-1], 'U':[1,0], 'R':[0,1],'D':[-1,0]};\r\n        start = [0, 0]\r\n        for move in moves:\r\n            start[0] += direction_map[move][0]\r\n            start[1] += direction_map[move][1] \r\n        return start == [0,0]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/34#issuecomment-2104572549","body":"```\r\nimport heapq\r\nclass Solution(object):\r\n    def getOrder(self, tasks):\r\n        \"\"\"\r\n        :type tasks: List[List[int]]\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        minHeap = []; \r\n        task_list  = [(task[0],i, task[1]) for i, task in enumerate (tasks)]\r\n        sorted_task_list = sorted(task_list, key = lambda x:x[0])\r\n        result = []\r\n        index = 0\r\n        time = 0\r\n        for _ in tasks:\r\n            if len(minHeap) == 0:\r\n                time = max(time, sorted_task_list[index][0])\r\n            while index < len(tasks) and sorted_task_list[index][0] <= time:\r\n                heapq.heappush(minHeap,(sorted_task_list[index][2], sorted_task_list[index][1]))\r\n                index+=1\r\n            processing_time, task_index = heapq.heappop(minHeap)\r\n            result.append(task_index)\r\n            time += processing_time\r\n        return result\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/35#issuecomment-2105510298","body":"```\r\nclass Solution(object):\r\n    def numberOfRounds(self, loginTime, logoutTime):\r\n        \"\"\"\r\n        :type loginTime: str\r\n        :type logoutTime: str\r\n        :rtype: int\r\n        \"\"\"\r\n        login_minutes = self.convert_to_minutes(loginTime)\r\n        logout_minutes = self.convert_to_minutes(logoutTime)\r\n        if login_minutes > logout_minutes:\r\n            logout_minutes += 60 * 24\r\n        if login_minutes / 15 > login_minutes // 15:\r\n            login_minutes += 14\r\n        rounds = logout_minutes // 15 - (login_minutes+14)//15\r\n        return max(0,rounds)\r\n\r\n    def convert_to_minutes(self, time):\r\n        return 60 * int(time[:2]) + int(time[3:])\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/36#issuecomment-2106054419","body":"```\r\nclass Solution(object):\r\n    def minCharacters(self, a, b):\r\n        \"\"\"\r\n        :type a: str\r\n        :type b: str\r\n        :rtype: int\r\n        \"\"\"\r\n        self.min_changes = len(a) + len(b)\r\n        count_a = [0] * 26\r\n        count_b = [0] * 26\r\n        for char in a:\r\n            count_a[ord(char) - ord('a')] += 1\r\n        for char in b:\r\n            count_b[ord(char) - ord('a')] += 1\r\n        presum_a, presum_b = [0 for i in range(27)], [0 for i in range(27)]\r\n        for count_a_char, count_b_char in zip(count_a, count_b):\r\n            self.min_changes = min(self.min_changes, len(a) + len(b) - count_a_char - count_b_char)\r\n        self.calculate_min_changes(count_a, count_b)\r\n        self.calculate_min_changes(count_b, count_a)\r\n        return self.min_changes\r\n         \r\n\r\n    def calculate_min_changes(self, count_a, count_b): \r\n        print(count_a, count_b)\r\n        for i in range(1, 26):\r\n            changes = sum(count_a[i:]) + sum(count_b[:i])\r\n            self.min_changes = min(changes, self.min_changes)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/37#issuecomment-2107467505","body":"```\r\nclass Solution(object):\r\n    def sortArray(self, nums):\r\n        \"\"\"\r\n        :type nums: List[int]\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        if len(nums) <= 1:\r\n            return nums\r\n        \r\n        mid = len(nums) // 2\r\n        left = nums[:mid]\r\n        right = nums[mid:]\r\n        self.sortArray(left)\r\n        self.sortArray(right)\r\n        first = 0\r\n        second = 0\r\n        curr = 0\r\n        while first < len(left) and second < len(right):\r\n            if left[first] <= right[second]:\r\n                nums[curr] = left[first]\r\n                first += 1\r\n            else:\r\n                nums[curr] = right[second]\r\n                second += 1\r\n            curr += 1\r\n        while first < len(left):\r\n            nums[curr] = left[first]\r\n            curr+=1\r\n            first += 1\r\n        while second < len(right):\r\n            nums[curr] = right[second]\r\n            second += 1\r\n            curr += 1\r\n        return nums\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/38#issuecomment-2110062188","body":"···\r\nclass Solution(object):\r\n    def mySqrt(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: int\r\n        \"\"\"\r\n        if x < 2:\r\n            return x\r\n        left, right = 2, x//2\r\n        \r\n        while left <= right:\r\n            mid = (left + right) //2\r\n            if mid * mid > x:\r\n                right = mid -1\r\n            elif mid * mid < x:\r\n                left = mid + 1\r\n            else:\r\n                return mid\r\n        return right\r\n···","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/39#issuecomment-2112443731","body":"```\r\n# The isBadVersion API is already defined for you.\r\n# @param version, an integer\r\n# @return a bool\r\n# def isBadVersion(version):\r\n\r\nclass Solution(object):\r\n    def firstBadVersion(self, n):\r\n        \"\"\"\r\n        :type n: int\r\n        :rtype: int\r\n        \"\"\"\r\n        left = 0\r\n        right = n \r\n        while left < right:\r\n            mid = (left + right) // 2\r\n            if isBadVersion(mid):\r\n                right = mid\r\n            else:\r\n                left = mid + 1\r\n        return left\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/40#issuecomment-2115194387","body":"```\r\nclass Solution(object):\r\n    def reversePairs(self, nums):\r\n        \"\"\"\r\n        :type nums: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n        count = 0\r\n        if len(nums) > 1:\r\n            mid = (len(nums)) // 2\r\n            left = nums[:mid]\r\n            right = nums[mid:]\r\n            count += self.reversePairs(left)\r\n            count += self.reversePairs(right)\r\n            i = 0\r\n            j = 0\r\n            for i in range(len(left)):\r\n                while j < len(right) and left[i] > right[j] * 2:\r\n                    j += 1\r\n                count += j\r\n            i = j = k = 0\r\n            while i < len(left) and j < len(right):\r\n                if left[i] < right[j]:\r\n                    nums[k] = left[i]\r\n                    k+=1\r\n                    i +=1\r\n                else:\r\n                    nums[k] = right[j]\r\n                    j += 1\r\n                    k += 1\r\n            while i < len(left):\r\n                nums[k] = left[i]\r\n                k += 1\r\n                i += 1\r\n            while j < len(right):\r\n                nums[k] = right[j]\r\n                j += 1\r\n                k += 1\r\n        return count\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/41#issuecomment-2117519076","body":"```\r\nclass Solution(object):\r\n    def findRadius(self, houses, heaters):\r\n        \"\"\"\r\n        :type houses: List[int]\r\n        :type heaters: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n        heaters.sort()\r\n        houses.sort()\r\n        left = 0\r\n        right = int(1e9)\r\n        while left < right:\r\n            mid = (left + right) // 2\r\n            if self.isFeasible(heaters,houses,mid):\r\n                right = mid\r\n            else:\r\n                left = mid + 1\r\n        return left\r\n\r\n\r\n       \r\n\r\n    def isFeasible(self, heaters, houses,radius):\r\n        house_index = 0\r\n        heater_index = 0\r\n        while house_index < len(houses):\r\n            if heater_index >= len(heaters):\r\n                return False\r\n            left_cover_range = heaters[heater_index] - radius\r\n            right_cover_range = heaters[heater_index] + radius\r\n            if houses[house_index] < left_cover_range:\r\n                return False\r\n            if houses[house_index] > right_cover_range:\r\n                heater_index += 1\r\n            else:\r\n                house_index += 1\r\n        return True\r\n\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/43#issuecomment-2119252226","body":"```\r\nimport heapq\r\nclass Solution(object):\r\n    def swimInWater(self, grid):\r\n        \"\"\"\r\n        :type grid: List[List[int]]\r\n        :rtype: int\r\n        \"\"\"\r\n        n = len(grid); \r\n        heap = [(grid[0][0], 0,0)]; \r\n        count = 0\r\n        visited = set(); \r\n        while heap:\r\n            time, row, col = heapq.heappop(heap); \r\n            count = max(time, count); \r\n            if row == n-1 and col == n-1:\r\n                return count; \r\n            for direction in [(0,-1), (0,1), (1,0), (-1,0)]:\r\n                x = direction[0] + row\r\n                y = direction[1] + col\r\n                if 0 <=x < len(grid) and 0<=y< len(grid[0]) and (x,y) not in visited: \r\n                    heapq.heappush(heap, (grid[x][y], x,y)); \r\n                    visited.add((x,y))\r\n        return count; \r\n        \r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bordergong":[{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/1#issuecomment-2042730017","body":"var addToArrayForm = function(num, k) {\n    var numK = (k + '').split('');\n    var diff = num.length - numK.length > 0 ? num.length : numK.length;\n    var result = [];\n    var isStep = false;\n    for (var i = 0; i < diff; i++) {\n        var a = num[num.length - (1 + i)] || 0;\n        var b = numK[numK.length - (1 + i)] || 0;\n        var r = a + Number(b) + Number(isStep);\n        isStep = r >= 10;\n        result.unshift(r%10);\n    }\n    if (isStep) {\n        result.unshift(1);\n    }\n    return result;\n};\n\n时间复杂度： O(n)\n\n思路： 总体思路是模拟数学的加法\n1·数据格式对齐\n2.从各位开始遍历（数组尾部），依次累加，超过十进位取余\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/2#issuecomment-2044696860","body":"## 代码\n```javascript\nvar shortestToChar = function(s, c) {\n    const flag = 100000;\n    const n = s.length;\n    const answer = new Array(n).fill(flag);\n\n    let prev = -flag;\n    for (let i = 0; i < n; i++) {\n        if (s[i] === c) {\n            prev = i;\n        }\n        answer[i] = Math.min(answer[i], Math.abs(i - prev));\n    }\n\n    prev = flag;\n    for (let i = n - 1; i >= 0; i--) {\n        if (s[i] === c) {\n            prev = i;\n        }\n        answer[i] = Math.min(answer[i], Math.abs(i - prev));\n    }\n\n    return answer;\n};\n```\n## 思路\n通过两次遍历字符串 s，分别从左到右和从右到左，更新每个位置到字符 c 最近位置的距离，最终得到最短距离数组并返回。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/3#issuecomment-2056528000","body":"## 代码\r\n```typescript\r\nclass CustomStack {\r\n    private maxSize: number;\r\n    private stack: number[];\r\n    private incMap: any;\r\n    constructor(maxSize) {\r\n        this.maxSize = maxSize;\r\n        this.stack = [];\r\n        this.incMap = {}; // 用于记录增量操作\r\n    }\r\n\r\n    push(x) {\r\n        if (this.stack.length < this.maxSize) {\r\n            this.stack.push(x);\r\n        }\r\n    }\r\n\r\n    pop() {\r\n        if (this.stack.length === 0) {\r\n            return -1;\r\n        }\r\n        // 处理增量操作\r\n        let inc = this.incMap[this.stack.length] || 0;\r\n        if (this.stack.length > 1) {\r\n            this.incMap[this.stack.length - 1] = (this.incMap[this.stack.length - 1] || 0) + inc;\r\n        }\r\n        return this.stack.pop() + inc;\r\n    }\r\n\r\n    increment(k, val) {\r\n        const top = Math.min(k, this.stack.length);\r\n        this.incMap[top] = (this.incMap[top] || 0) + val;\r\n    }\r\n}\r\n```\r\n## 时间复杂度\r\n- push O(1)\r\n- pop O(1)\r\n- increment O(n)\r\n\r\n## 思路\r\n用数组模拟栈\r\n","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hawkins-hjq":[{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/1#issuecomment-2043020205","body":"### 思路\r\n遍历数组，将数组和K的每一位数字 ，从右到左 ，逐一相加，如果两个数相加大于等于10，则进位+1；\r\n\r\n### 代码\r\n\r\n```\r\nclass Solution {\r\npublic List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> result = new ArrayList<>();\r\n        for (int i = num.length - 1; i >= 0; i--) {\r\n            // 逐位相加\r\n            int sum = num[i] + k % 10;\r\n            k /= 10;\r\n            // 进位\r\n            if (sum >= 10) {\r\n                k++;\r\n                sum -= 10;\r\n            }\r\n            result.add(0, sum); \r\n        }\r\n\r\n        for (; k > 0; k/= 10) {\r\n            result.add(0, k % 10);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n时间复杂度：O(max(n,logk));\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/2#issuecomment-2045398105","body":"### 思路\n暴力求解法：两次遍历，求最短距离；\n### 代码\n```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] result = new int[s.length()];\n        List<Integer> posList =new ArrayList<>();\n        for(int i =0;i<s.length();i++){\n            if(s.charAt(i)==c){\n                posList.add(i);\n            }\n        }\n\n        for(int j =0;j<s.length();j++){\n           int distance = 10000;\n           for(int k =0;k<posList.size();k++){\n                if(Math.abs(j-posList.get(k))<distance){\n                    distance = Math.abs(j-posList.get(k));\n                }\n           }\n           result[j] = distance;\n        }\n\n        return result;\n    }\n}\n```\n\n### 复杂度\n时间复杂度：O(N^2);\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/3#issuecomment-2047939857","body":"### 思路\n数组实现栈\n\n### 代码\n```\nclass CustomStack {\n    // 声明一个数组，作为自定义栈的底层实现\n    int[] stackArray;\n    // 栈顶位置监控\n    int pos = 0;\n\n    public CustomStack(int maxSize) {\n        stackArray = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        // 栈空间满了，不能入栈\n        if(pos==stackArray.length){\n            return;\n        }\n        // 入栈\n        stackArray[pos++]=x;\n    }\n    \n    public int pop() {\n        if(pos==0){\n            return -1;\n        }\n        return stackArray[--pos];\n\n    }\n    \n    public void increment(int k, int val) {\n        // 栈中元素个数小于k\n        if(k>stackArray.length){\n            for(int i = 0;i<stackArray.length;i++){\n                stackArray[i] += val;\n            }\n        } else{\n              // 栈中元素个数小于k\n            for(int j =0;j<k;j++){\n                    stackArray[j] += val;\n                }\n        }\n    }\n}\n\n```\n### 复杂度\n时间复杂度： push、pop:  O(1),increment:O(K)\n空间复杂度：O(maxSize)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/4#issuecomment-2050041025","body":"### 思路\n双栈\n### 代码\n```\nclass Solution {\n    public String decodeString(String s) {\n        Deque<StringBuilder> stack = new LinkedList<>();\n        Deque<Integer> numStack = new LinkedList<>();\n        StringBuilder sb = new StringBuilder();\n        int num = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (Character.isDigit(s.charAt(i))) {\n                num = num * 10 + s.charAt(i) - '0';\n            } else if (s.charAt(i) == '[') {\n                numStack.push(num);\n                num = 0;\n                stack.push(sb);\n                sb = new StringBuilder();\n            } else if (Character.isLetter(s.charAt(i))) {\n                sb.append(s.charAt(i));\n            } else {\n                StringBuilder temp = stack.pop();\n                int count = numStack.pop();\n                for (int j = 0; j < count; j++) {\n                    temp.append(sb);\n                }\n                sb = temp;\n            }\n        }\n        return sb.toString();\n\n    }\n}\n```\n### 复杂度\n时间复杂度：O（N）\n空间复杂度：O（N）","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cathyshang":[{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/1#issuecomment-2043063331","body":"思路:\n1. 数组转换整数\n2. 相加\n3. 判断和的长度\n4. 整数转换数组\n\n代码:\n```cpp\nvector<int> addToArrayForm(vector<int>& num, int k) {\n    long long int h=0;\n    int n = num.size();\n    int cur_m = n-1;\n    for(int i=0; i<n; i++){\n        h = h + num[i]*pow(10,cur_m);\n        cur_m = cur_m -1; \n    }\n    //2\n    long long r; int l; //求和，输出长度\n    r = h+k;\n    //3\n    if(r>=pow(10,n)){\n        l = n+1;\n    } else{ l = n;}\n    // 判断一下k的长度，kl\n    int kl = 0;\n    if(k>=pow(10,4)){kl = 5;}\n    else if (k>=pow(10,3)){kl = 4;}\n    else if (k>=pow(10,2)){kl = 3;}\n    else if (k>=10){kl = 2;}\n    else{ kl = 1;}\n    if(kl > l){ l = kl;}\n    if(r>=pow(10, l)){\n        l = l+1;\n    }\n    //4\n    vector<int> res(l,0);\n    cur_m = l-1;\n\n    for(int j=0; j < l; j++){\n        if(j==l-1){ res[j]= r;}\n        else{\n            int temp = floor(r/pow(10,cur_m));\n            res[j] = temp;\n            r = r - res[j]*pow(10,cur_m);\n            cur_m = cur_m-1;\n            // cout << r;\n        }\n    }\n    return res;\n    }\n```\n复杂度:\n时间复杂度 $O(N)$  N = num.length()\n\n错误:\n由于是以num为主导，没有注意它范围很大，超出了程序变量的长度。\n后发现，将k转换为数组，再模拟数字加法，适合本题。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/2#issuecomment-2044718204","body":"思路：\n两次遍历，a.一次求字符串元素s[i]到其右侧目标字符的距离最小值；b. 另一次求字符串元素s[i]到其左侧目标字符距离；\n距离通过索引相减获得。\n代码：\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int i=0;\n        int b=0; // 上一个同字符索引\n        int n = s.length();\n        std::vector<int> temp(n);\n        int cur;\n        // 到右侧 同字符距离 n\n        while( s[i]!='\\0'){\n            if(s[i]==c){\n                temp[i]=0;\n                for(int j = b; j<i; j++){\n                    cur = i-j;\n                    if(temp[j] > cur){temp[j] = cur;}          \n                }\n                b = i;}\n            else{temp[i]=n;}\n            i++;\n        }\n        // 到左侧 同字符距离\n        for(int i = 0, b= -n; i<n; ++i){\n            if(s[i]==c){\n                b = i;\n            }\n            temp[i] = min(temp[i], i-b);\n            // std::cout << temp[i]<<'\\n';\n        }\n        return temp;\n    }\n};\n```\n复杂度：\n时间复杂度$O(N^2)$\n空间复杂度$O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/3#issuecomment-2046219106","body":"思路：\n- 看到前k个增添一个增量，用数组实现。\n- 优化前，增添函数中for循环求和更新栈中元素，时间复杂度为$O(N)$ N=k\n- 前缀和优化，\n     - 增添函数更新增量数组，举例中，\"increment\",\"increment\", 对应 \"add[2]=100\",\"add[1]=100\"，其记录前k（k<top）个增量值val，\n     - 在pop()，通过stk[top]+add[top]获取增量后元素，并通过add[top-1] += add[top];更新增量数组。\n\n代码：\n```cpp\nclass CustomStack {\npublic:\n    vector<int> stk, add;\n    int top;\n\n    CustomStack(int maxSize) {\n        stk.resize(maxSize);\n        add.resize(maxSize);\n        top = -1; //没满栈,监测栈顶位置\n    }\n    \n    void push(int x) {\n        if(top != stk.size()-1){ //错误 if(top < stk.size()-1)\n            ++top;\n            stk[top] = x;\n            // std::cout << 'test';\n        }\n        // std::cout << top <<'\\n';\n    }\n    \n    int pop() {\n        int cur;\n        if(top==-1) return -1; //空了\n        cur = stk[top] + add[top];\n        if(top != 0) add[top-1] += add[top]; // 错误 add[top-1] = add[top]\n        add[top] = 0; //跟着元素出栈清零\n        --top;\n        return cur; \n    }\n    \n    void increment(int k, int val) {\n        int rag;\n        rag = min(k, top+1);\n        // 优化器前\n        // for(int i = 0; i<rag; ++i){\n        //     stk[i] += val;\n        // }\n        if( rag >= 1) add[rag-1] += val;\n    }\n};\n```\n复杂度：\n- 时间复杂度： push，pop，increment $O(1)$\n- 空间复杂度：$O(N)$ 使用两个长度为N=maxSize的数组\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/4#issuecomment-2050020501","body":"思路\n- 用栈维护，记录字符型数字 与 字符串\n- 当遇到“[” 入栈;\n当遇到“]” 出栈。\n\n代码\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n        // 解码   没跑通\n        stack<string> stkStr;\n        // stack<int> stkNum;\n        int n = s.size(), num;\n        string temp1,temp2,sNum;\n        string res;\n        int flag = -1, k=1;\n        string q; \n        // \n        for(int i=0; i<n; i++){\n            if(s[i]>='a' && s[i]<='z'){\n                temp1 += s[i];\n            }\n            else{sNum += s[i];}\n            if(s[i]=='['){\n                flag = 1;\n                if(sNum==''){sNum = \"1\";} // 错误\n                // else{num = stoi(sNum)}                \n                if(temp1!=''){stkStr.push(temp1);}\n                stkStr.push(num);\n                stkStr.push(s[i]);\n                // 入栈后清零\n                temp1 = '';\n                sNum = '';\n            }\n            if(s[i]==']'){\n                //出栈\n                q = stkStr.pop();\n                if(q=='['){\n                    k = stkStr.pop()\n                    k = stoi(k);\n                    for(int j =0; j<k; i++){\n                        temp2 += temp1;\n                    }\n                }\n                else{\n                    temp2 = stkStr.pop() + temp2;\n                    stkStr.pop()\n                }\n            }\n        }\n        k = stkStr.pop()\n        k = stoi(k);\n        for(int j =0; j<k; i++){\n            res += temp2;\n            }        \n        if(!flag){return temp1;}\n        else{\n            if(temp1!=''){\n                res += temp1;\n            }\n            return res;}\n    }\n};\n```\n\n复杂度\n- 时间复杂度$O(N)$\n- 空间复杂度$O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/5#issuecomment-2051993043","body":"思路：\n- 栈与队列的区别：栈Last in, First out, LIFO; 队列 First in, First out, FIFO；\n- 发展仅元素输出顺序不同，一头一尾，那么用2个栈进行维护，在输出时，让先入栈的为栈的top()，就像把瓶子倒过来一样。\n- 当然，在输入的时候，需要查看stk2是否还有元素，若有得让它回到stk1，保持输入的顺序不发生改变。\n\n代码\n```cpp\nclass MyQueue {\npublic:\n    // 通过\n    stack<int> stk1;\n    stack<int> stk2;\n\n    MyQueue() {}\n    \n    void push(int x) {\n        if(!stk2.empty()){\n            // stk2中元素移到stk1\n            while(!stk2.empty()){\n                stk1.push(stk2.top());\n                stk2.pop();            \n            }\n        }\n        stk1.push(x);\n    }\n    \n    int pop() {\n        if(!stk1.empty()){\n            while(!stk1.empty()){\n                stk2.push(stk1.top());\n                stk1.pop();\n            }\n        }\n        int res = stk2.top();\n        stk2.pop();\n        return res;\n    }\n    \n    int peek() {\n        if(!stk1.empty()){\n            while(!stk1.empty()){\n                stk2.push(stk1.top());\n                stk1.pop();\n            }\n        }\n        int res = stk2.top();\n        return res;\n    }\n    \n    bool empty() {\n        if(stk1.empty()&&stk2.empty()){\n            return true;\n        }\n        else{return false;}\n    }\n};\n```\n\n复杂度\n- 时间复杂度 push(), pop(), peek() $O(N)$; empty() $O(1)$;\n- 空间复杂度 $O(N)$ 调用2个栈，栈内存放长度为N的元素。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/6#issuecomment-2053684901","body":"思路：\n单调栈，\n- 非递增是1\n- 非递减是n；错得和题解是一模一样，卡在[4,2,2,1,1]，后使用融合栈中保存区块中最大元素，但是无法在连续重复元素情况下判断序列增减情况\n- 序列的增减情况，是通过arr[i]，进行更新，面对[1,1,..]时，当arr[2]==2，则栈中存放[1,1,2]; 当arr[2]==0时，栈中存放[1]。这是if语句无法判断的，所以有了code不通过2。\n\n代码\n```cpp\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        int n=arr.size();\n        stack<int> stk;\n        // 单调栈\n\n        for(int i=0;i<n ;i++){\n           if(!stk.empty()&&stk.top()>arr[i]){\n            int cur=stk.top();\n            while(!stk.empty()&&stk.top()>arr[i]){\n                //一开始有多个重复的满足\n                stk.pop();\n            }\n            stk.push(cur);\n           }\n\n           else{\n            stk.push(arr[i]);\n           }\n\n        }\n        return stk.size();\n    }\n};\n// 不通过2\n// class Solution {\n// public:\n//     int maxChunksToSorted(vector<int>& arr) {\n//         int n=arr.size();\n//         stack<int> stk;\n//         // 单调栈\n//         stk.push(arr[0]);\n//         std::cout<<arr[0]<<endl;\n//         int flag = 0;\n//         for(int i=1;i<n ;i++){\n//             if(arr[i]<stk.top()) {\n//                 flag=-1;\n//                 continue;}\n//             // 序列最大与下一元素相等\n//             else if(arr[i]==stk.top()){\n//                 if(flag){ //修改判别条件\n//                     stk.push(arr[i]);\n//                 }\n//             }\n//             //\n//             else if(arr[i]>stk.top()){\n//                 flag=1;\n//                 stk.push(arr[i]);\n//                 std::cout<<i<<\":\"<<arr[i]<<endl;\n//             } \n\n//         }\n//         return stk.size();\n//     }\n// };\n```\n复杂度：\n- 时间复杂度$O(N)$\n- 空间复杂度$O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/7#issuecomment-2054088630","body":"思路：\n参考题解\n- 当链表长度小于1，k==0时，原链表输出；\n- 计链表长度n；\n- 当k%n==0时，原链表输出；\n- 链表成环\n- 在p = n-k%n处断开，输出\n代码：\n```cpp\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        //当链表为空，或者长度为1，k=0\n        //head->next==nullptr||head==nullptr||k==0 报错[]\n        if(k==0||head==nullptr||head->next==nullptr){\n            return head;\n        }\n        int n=1;\n        //计数\n        ListNode* cur = head;\n        while(cur->next!=nullptr){\n            cur = cur->next;\n            n++;\n        }\n        //此时，cur指向尾节点\n        \n        //计算在哪里断开\n        int part = n-k%n;\n        if(part==n){\n            return head;\n        }\n        //成环\n        cur->next = head; //cur指向头部        \n        while(part>0){\n            cur = cur->next;\n            part--;\n        }\n        // 旋转后，cur指向链表尾节点\n        ListNode* res=cur->next; // 现在还是环，指向答案头部\n        // 断开\n        cur->next = nullptr;\n        return res;\n    }\n};\n```\n复杂度：\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(1)$ 这里均使用指针","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/8#issuecomment-2057191992","body":"思路：\n- 迭代\n- 间1隔选取相邻2个节点进行交换\n（循环程序写的不对，死循环）\n代码：\n```cpp\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        // 不通过，循环超时\n        // 小于1\n        if(head==nullptr||head->next==nullptr)return head;\n        ListNode* cur = head;\n        ListNode* temp = head->next;\n        ListNode* temp2;\n        ListNode* preHead=new ListNode(-1);\n        ListNode* res=preHead;\n        while(cur!=nullptr && temp!=nullptr){\n            std::cout << cur->val << endl;\n            // if(temp->next!=nullptr) temp2=temp->next;\n            // else{ temp2=nullptr; }\n            // cur->next = nullptr;\n            // temp->next = cur;\n            // cur->next = temp2;\n            res->next = temp;\n            cur->next = temp->next;\n            temp->next = cur;\n            // temp->next = cur;\n            //\n            cur=cur->next->next;\n            if(temp->next==nullptr) break;\n            else{temp->next->next;}\n        }\n        return preHead->next;\n\n    }\n};\n```\n\n复杂度：\n- 时间 $O(N)$\n- 空间 $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/9#issuecomment-2059421437","body":"思路：\n- 找到链表中点\n- 构造二叉数，左树先，递归\n\n代码：\n```cpp\nclass Solution {\npublic:\n    ListNode* median(ListNode* left, ListNode* right){\n        ListNode* fast = left;\n        ListNode* slow = left;\n        while(fast!=right && fast->next!=right){\n            fast = fast->next;\n            fast = fast->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n    TreeNode* buildTree(ListNode* left, ListNode* right){\n        if(left==right){\n            return nullptr;\n        }\n        ListNode* mid = median(left, right);\n        TreeNode* root = new TreeNode(mid->val);\n        root->left = buildTree(left, mid);\n        root->right = buildTree(mid->next,right);\n        return root;\n    }\n    TreeNode* sortedListToBST(ListNode* head) {\n        // TreeNode* res = new TreeNode();\n        \n        // ListNode* preHead = new ListNode(-1);\n        // preHead->next = head;\n        // ListNode* cur = preHead->next;\n        // ListNode* fast = cur;\n        // if(head==nullptr) return res->left;\n        // //遍历链表\n        // while(cur!=nullptr){\n        //     if(fast==nullptr){ \n        //         TreeNode* test = new TreeNode(cur->val);\n        //         res->left = test;\n        //         break;\n        //     }           \n        //     cur = cur->next;\n        // }\n        \n        // return res;\n        return buildTree(head, nullptr);\n        \n    }\n};\n```\n\n复杂度：\n- 时间复杂度$O(NlogN)$\n- 空间复杂度$O(logN)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/10#issuecomment-2061403311","body":"思路\n讲义原题 双指针 cur1，cur2\n- cur1，cur2分布从headA，headB开始遍历，当其中一个为nullptr时，指向另一个链表头再遍历；\n- 若有交点，则cur1与cur2会在交点相遇\n假设，headA非交点长度为L1，headB非交点长度为L2，交点之后链表长度L3，指针相遇时，cur1，cur2走过的链表长度分别为L1+L3+L2,L2+L3+L1, 验证了它们会相遇。\n\n代码\n```cpp\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* cur1 = headA;\n        ListNode* cur2 = headB;\n        int flag1 = 0,flag2 = 0;\n        while(cur1!=nullptr || cur2!=nullptr){\n            if(cur1==nullptr){\n                cur1 = headB;\n                flag1 += 1;\n            }\n            if(cur2==nullptr){\n                cur2 = headA;\n                flag2 += 1;\n            }\n            if(cur1 == cur2){break;} // 表示指向同一节点，指针相等（不是值相等）\n            if(flag1==2||flag2==2){break;} //当没有交点时避免死循环\n            std::cout << cur1->val << endl;\n            cur1 = cur1->next;\n            cur2 = cur2->next;\n        }\n        return cur1;\n    }\n};\n```\n复杂度\n- 时间 $O(M+N)$ 最坏情况没有交点，两个链表长度分布M,N\n- 空间 $O(1)$ 双指针","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/11#issuecomment-2062933128","body":"思路\n- 双指针，设快慢指针 fast,slow，fast每次走2步（c++没有nullptr->next 会报错，故进行判段），slow每次走1步\n- 当它们第一次相遇之后，fast回到链表头部，并每次走1步\n- 当它们再次相遇时，为环形链表入口\n\n证明：假设链表环形入口前长度L ，入口到第一次相遇点长度C，D+C=环形长度；\n- 2*slow走过长度 =  fast走过长度； 2(L+C)=L+D+2C； D+C 是一圈，slow被套圈了 ！\n- 有上式得 L=D，所以fast和slow第二次相遇在环形入口处。\n\n代码\n```cpp\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if(head==nullptr || head->next==nullptr || head->next->next==nullptr ) return nullptr;\n        ListNode* fast = head;\n        ListNode* slow = head;\n        do{ \n            if(fast==nullptr) break;\n            fast = fast->next;\n            if(fast==nullptr) break;           \n            fast = fast->next;\n            slow = slow->next;\n        }while(fast!=slow);  // 单独 while将多走一步\n        if(fast==nullptr||slow==nullptr) return nullptr;\n        fast = head;\n        while(fast!=slow){\n            fast = fast->next;\n            slow = slow->next;\n        }\n        return fast;\n    }\n};\n```\n\n复杂度\n- 时间$O(N)$ N 为链表长度\n- 空间$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/12#issuecomment-2066800283","body":"```cpp\nclass Node{\npublic:\n    int key, value;\n    Node *pre, *next;\n    Node(int k=0, int v=0):key(k), value(v){}\n};\n\nclass LRUCache {\nprivate:\n    int capacity;\n    Node *dummy;\n    unordered_map<int, Node*> key_to_node;\n    // 删除一个节点（抽出一本书）\n    void remove(Node *x) {\n        x->pre->next = x->next;\n        x->next->pre = x->pre;\n    }\n\n    // 在链表头添加一个节点（把一本书放在最上面）\n    void push_front(Node *x) {\n        x->pre = dummy;\n        x->next = dummy->next;\n        x->pre->next = x;\n        x->next->pre = x;\n    }\n\n    Node *get_node(int key) {\n        auto it = key_to_node.find(key);\n        if (it == key_to_node.end()) // 没有这本书\n            return nullptr;\n        auto node = it->second; // 有这本书\n        remove(node); // 把这本书抽出来\n        push_front(node); // 放在最上面\n        return node;\n    }\n   \npublic:\n    \n\n    LRUCache(int capacity): capacity(capacity), dummy(new Node()) {\n        dummy->pre = dummy;\n        dummy->next = dummy;\n    }\n\n    int get(int key) {\n        auto node = get_node(key);\n        return node ? node->value : -1;\n    }\n\n    void put(int key, int value) {\n        auto node = get_node(key);\n        if (node) { // 有这本书\n            node->value = value; // 更新 value\n            return;\n        }\n        key_to_node[key] = node = new Node(key, value); // 新书\n        push_front(node); // 放在最上面\n        if (key_to_node.size() > capacity) { // 书太多了\n            auto back_node = dummy->prev;\n            key_to_node.erase(back_node->key);\n            remove(back_node); // 去掉最后一本书\n            delete back_node; // 释放内存\n        }\n    }\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/13#issuecomment-2067682157","body":"思路：\n- 后续遍历二叉树\n- 分别遍历左子树，右子树，有叶节点就加1，进行递归。\n- 递归结束 当遍历到根节点 return 1；\n- 递归中，return max(a.计算左子树深度 maxD(root->left) b.计算左子树深度 maxD(root->right) )+1。\n\n代码：\n```cpp\nclass Solution {\npublic:\n    int maxD(TreeNode* root){\n        if(!root){return 0;}\n        // std::cout << root->val<< endl;\n        // maxD(root->left);\n        // maxD(root->right); // 超时\n        return max(maxD(root->left),maxD(root->right))+1;\n\n    }\n    int maxDepth(TreeNode* root) {\n        int res = -1;\n        res = maxD(root);\n        return res;\n    }\n};\n```\n\n复杂度：\n- 时间 $O(N)$ 遍历所有节点\n- 空间 $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/14#issuecomment-2067869796","body":"思路：\n想用BFS，遍历1个和遍历2个同步成为我的难点，代码参考题解。\n- 空判断，都空是true，单空是false，都不空接着看；\n- 2个队列，放入树根p,q\n- 2个队列不空，开始遍历\n    - 当前节点是否相等，\n    - 子节点空了，空的不一样则false\n    - 子节点不空，放入队列\n- 遍历完，队列都空是true，其余是false\n\n其中，空的判断很多，还用到了异或，之前没怎么用到\n\n代码\n```cpp\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(p==nullptr&&q==nullptr) return true;\n        else if(p==nullptr|| q==nullptr) return false;\n        queue<TreeNode*> que,que2;\n        bool res;\n        que.push(p);\n        que2.push(q);\n        int a = 0;\n        while(!que.empty()&&!que2.empty()){\n            auto node = que.front(); //队列现进先出\n            que.pop();\n            auto node2 = que2.front();\n            que2.pop();\n            if(node->val!=node2->val) return false;\n            // 异或^ 俩值相同为0\n            if((node->left==nullptr)^(node2->left==nullptr)) return false;\n            if((node->right==nullptr)^(node2->right==nullptr)) return false;\n\n\n            if(node->left!=nullptr) que.push(node->left);\n            if(node->right!=nullptr) que.push(node->right);\n\n            if(node2->left!=nullptr) que2.push(node2->left);\n            if(node2->right!=nullptr) que2.push(node2->right);         \n            // a++;           \n        }\n        // std::cout<< a << endl;\n        return que.empty()&&que2.empty();\n    }\n};\n```\n\n复杂度\n- 时间 $O(min(M,N))$ 同时访问，仅当不空时，才进行造作，所以为树M与树N其中最小值\n- 空间 $O(min(M,N))$ 同理","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/15#issuecomment-2068935752","body":"思路：\n- 前序遍历\npresum10+root->val;\n\n代码：\n```cpp\nclass Solution {\npublic:\n    int preOrder(TreeNode* root, int presum){\n        if(root==nullptr) return 0;\n        int sum = presum*10 + root->val;\n        if(root->left==nullptr&&root->right==nullptr){\n            return sum;\n        }\n        else {return preOrder(root->left, sum)+ preOrder(root->right, sum);\n}\n    }\n    int sumNumbers(TreeNode* root) {\n        return preOrder(root, 0);\n\n    }\n};\n```\n\n复杂度：\n- 时间 $O(N)$ 遍历节点\n- 空间 $O(H)$ 树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/16#issuecomment-2072044078","body":"思路：\nBFS，遍历到最后一层，返回首元素。\n\n代码：\n```cpp\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        if(root->left == nullptr && root->right==nullptr) return root->val;\n        queue<TreeNode*> q;\n        q.push(root);\n        int res;\n        while(!q.empty()){\n            TreeNode* node;// 拿出首个元素\n            queue<TreeNode*> tmp;\n            int n = q.size();\n            for(int i=0;i<n; i++){\n            node = q.front();\n            q.pop();\n            if(node->left!=nullptr) tmp.push(node->left);\n            if(node->right!=nullptr) tmp.push(node->right);\n            }\n            q=tmp;\n            if(q.empty()) break; // for出来最后一次为空\n            res = tmp.front()->val;\n        }\n        return res;\n     \n    }\n};\n```\n\n复杂度：\n- 时间 $O(N)$ 树节点数\n- 复杂 $O(Q)$ 树的宽度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/17#issuecomment-2074708846","body":"思路：\n- 先序遍历，没有叶子节点为“None”\n- 反序列化，字符串根据逗号列表<字符串>\n    - 从左到右，先序遍历\n    - 同时，擦去遍历过的元素，List.erase(List.begin()); 其中，List.begin()为列表第一个元素的迭代器\n\n难点数据结构转换，序列化与反序列化需要数据结构转换\n\n代码：\n```cpp\nclass Codec {\npublic:\n    void preOrder(TreeNode* root, string& str){\n        if(root==nullptr){\n            str += \"None,\";\n        }\n        else{\n        str += to_string(root->val) + \",\";\n        preOrder(root->left, str);\n        preOrder(root->right,str);\n        }\n    }\n\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        string str;\n        preOrder(root, str);\n        cout << str << endl;\n        return str;\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* rdserialize(list<string>& dataArray){\n        if(dataArray.front()==\"None\"){\n            dataArray.erase(dataArray.begin());\n            return nullptr;\n        }\n        TreeNode* root = new TreeNode(stoi(dataArray.front()));\n        dataArray.erase(dataArray.begin());\n        root->left = rdserialize(dataArray);\n        root->right = rdserialize(dataArray);\n        return root;\n    }\n\n    TreeNode* deserialize(string data) {\n        list<string> dataArray;\n        string str;\n        for(auto& ch: data){\n            if(ch==','){\n                dataArray.push_back(str);\n                // cout << str << \", \";\n                str.clear();\n            }else{\n                str.push_back(ch); // 字符变字符串\n            }\n        }\n        // the lastest one\n        if(!str.empty()){\n            dataArray.push_back(str);\n            // cout << str << \", \";\n            str.clear();\n        }\n        // cout << endl;\n        // 字符串 变 字符串列表\n        return rdserialize(dataArray);\n\n    }\n};\n```\n\n复杂度：\n- 时间 $O(N)$ 需要遍历每一个节点\n- 空间 $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/18#issuecomment-2077087400","body":"- DFS遍历树，对每个节点整理（row，col）序号，以col为key将（row，root->val）存入unordered_map哈希表，并记录min_col;\n- 根据min_col向上累加遍历哈希表，对有多个value的进行排序，将值存入temp容器\n- 对每一个col 汇总 res，输出答案\n\n```cpp\nclass Solution {\npublic:\n    unordered_map<int, vector<pair<int, int>>> groups;\n    int min_col=0;\n\n    void dfs_987(TreeNode* root, int r, int c){\n        if(root == nullptr) \n        return;\n        min_col = min(min_col, c);\n        groups[c].emplace_back(r,root->val);\n        dfs_987(root->left, r+1, c-1);\n        dfs_987(root->right, r+1, c+1);\n    }\n    vector<vector<int>> verticalTraversal(TreeNode* root){\n        dfs_987(root,0,0);\n        vector<vector<int>> res;\n        cout << min_col << endl;\n        int n = groups.size();\n        for(int i = min_col; i < min_col + n ;i++){\n            auto &g = groups[i];\n            sort(g.begin(), g.end()); // 排序\n            vector<int> temp;\n\n            for(int j=0; j < g.size(); j++){\n                // cout << g[j].second << endl;\n                temp.push_back(g[j].second);\n            }\n            res.push_back(temp);\n        }\n        return res;\n    }\n    \n};\n```\n\nTime: $O(nlogn)$\nSpace: $O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/20#issuecomment-2078524025","body":"- 哈希表 unordered_map<int, int>\n- 遍历数组，将target-nums[i]作为key，i作为value存入哈希表\n- 判断当前nums[i] 是否为key值，若是则它的搭档索引已经存入哈希表，返回{i, hashmap[nums[i]]}\n\n```cpp\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> hashmap;\n        int n = nums.size();\n\n        for(int i=0;i<n;i++){\n            auto it = hashmap.find(nums[i]);\n            if(it != hashmap.end()){\n                return {hashmap[nums[i]],i};\n            }\n            hashmap[target-nums[i]] = i;\n        }\n        return {};\n        \n    }\n};\n```\n- Time $O(N)$\n- Space $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/21#issuecomment-2080373055","body":"思路：\n- 哈希表统计频次\n- 堆排序\n\n代码\n```cpp\nclass Solution {\npublic:\n    static bool cmp(pair<int, int>& m, pair<int, int>& n){\n        return m.second > n.second;\n    }\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int, int> hash;\n        int n = nums.size();\n        for(int i = 0; i < n; i++){\n            auto it = hash.find(nums[i]);\n            if(it != hash.end()){\n                hash[nums[i]] += 1;\n            }else{\n                hash[nums[i]] = 1;\n            }\n        }\n        // 排序 堆（不会）\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(&cmp)> q(cmp);\n        for(auto& [num, count]: hash){\n            std::cout << num <<\", \"<<count <<endl;\n            if(q.size()==k){\n                if(q.top().second < count){\n                    q.pop();\n                    q.emplace(num,count);\n                }                \n            }else{\n                    q.emplace(num, count);\n                }\n        }\n        // 输出堆中答案\n        vector<int> res;\n        while(!q.empty()){\n            res.emplace_back(q.top().first);\n            q.pop();\n        }\n        return res;\n    }\n};\n```\n\n- 时间 O(NlogN)\n- 空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/22#issuecomment-2081508741","body":"思路： 统计相等的距离的频次，枚举。\n\n```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ans = 0\n        for p in points:\n            hashmap = defaultdict(int)\n            for q in points:\n                dis = (p[0]-q[0])*(p[0]-q[0]) + (p[1]-q[1])*(p[1]-q[1])\n                hashmap[dis] += 1\n            for m in hashmap.values():\n                ans += m*(m-1)\n        return ans\n```\n- Time $O(N^{2})$\n- Space $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/23#issuecomment-2082987883","body":"### 思路 C++\nupdate 2024-04-29\n- 遍历 while(){... fast++;} 注意：边界位fast<n+1;\n- 构建 hashmap，记录char最近一次索引;\n- 快慢指针 slow, fast\n    - 当fast指向重复char, 并且slow小于该char最近一次hashmap[char], 更新slow = hashmap[s[fast]]+1;\n    - temp = fast-slow 目前不重复字符串长度，比较更新最长max_l;\n### 代码\n```C++ []\n// update 2024-04-29\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int slow = 0, fast = 0; // 快慢指针\n        unordered_map<char, int> hash; // 哈希表\n        int max_l=0; // 输出\n        // string max_s = \"\";\n        int n = s.size();\n        if(n==1) return n;\n        // note1: 字符串默认有一个\"\\0\"长度位n，不到n，则\"abc\"仅输出\"ab\"\n        while(fast<n+1){\n            // cout << slow  <<\":\"<< fast<<  \":\" << max_s;\n            auto it = hash.find(s[fast]);\n            int temp= fast-slow;\n            if(it!=hash.end()){\n                // note2: slow最远优先，而不是仅仅让slow=上一次重复的位置 不然 \"abba\"输出 \"bba\"\n                if(slow < hash[s[fast]]+1){\n                    slow = hash[s[fast]]+1;\n                }\n            }\n            hash[s[fast]]=fast;\n            if(temp>max_l){\n            max_l = temp;\n            // max_s = s.substr(slow, temp); // 字符串截取 (start_idx, length)\n            }\n            fast++;\n            // cout << endl;\n        }\n        return max_l;\n    }\n};\n```\n### 复杂度\n- 时间 $O(N)$ 遍历字符串\n- 空间 $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/24#issuecomment-2084338085","body":"### 思路\n\n如何判断s与words所有字符串组合相等？\n- words中出现的每个字符频率 与 s对应长度切片每个字符频率是否相等；\n- s对应长度切片等分后每个string是否与words中的string相等。\n\n- 构造hashmap 共4个:\n    - `hash_word` words中出现的每个字符频率\n    - `hash_q` words中的string出现频率\n    - `hash_s` s对应长度切片每个字符频率\n    - `hash_z` s对应长度切片等分后每个string出现频率\n- 固定大小的滑动窗口遍历字符串s\n    - 判断`hash_word`==`hash_s`，若是则进行下一步\n    - 判断`hash_q`==`hash_z`，返回答案索引\n\n### Code\n```C++ []\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        int pern = words[0].size();\n        int n = words.size();\n        int lengths = n*pern;\n        cout << pern << \":\" << n << \":\" << lengths << endl;\n        unordered_map<char, int> hash_word;\n        unordered_map<string, int> hash_q;\n        // 统计出现频次 char hash_word/ string hash_q\n        for(int i=0; i<n; i++){\n            hash_q[words[i]]++;\n            for(int j=0; j<pern; j++){\n            hash_word[words[i][j]]++;\n            }\n        }\n        // cout << hash_word['o'] << endl;\n        int sn = s.size();\n        if(lengths > sn) return {};\n        // 统计出现频次 char \n        int r = lengths;\n        int l = 0;\n        vector<int> res;\n        while(r < sn+1){\n            // cout<<s.substr(l,lengths)<<endl;\n            string temp = s.substr(l,lengths);\n            unordered_map<char, int> hash_s;\n            for(int i = 0; i<lengths; i++){\n            hash_s[temp[i]]++;\n            }\n            if(hash_s == hash_word){\n            // cout << \"yes\" << endl;\n            // 选出的字符串 每一个字符串判断\n            unordered_map<string, int> hash_z;\\\n            int k = 0;\n            while(k<lengths-pern+1){\n                // cout << k << endl;\n                string aa = temp.substr(k, pern);\n                // cout<<aa<<endl;\n                hash_z[aa]++;\n                k += pern;\n            }\n\n            if(hash_z == hash_q){\n            res.push_back(l);\n            // cout << \"res:\" << l << endl;\n            }\n            }else{\n            // cout << \"no\" << endl;\n            }\n            r++;\n            l++;\n        }        \n        return res;\n    }\n};\n```\n\n### 复杂度\n\n时间复杂度: $O(n*{m}*{k})$ n为words元素个数，k为words元素长度, m为s长度\n\n空间复杂度: $O(m)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/25#issuecomment-2088000293","body":"- 哈希表\n- 同余定理\n- 前缀和\n```cpp\nclass Solution {\npublic:\n    int minSubarray(vector<int>& nums, int p) {\n        // 计算nums整体的p的模\n        int total_m = 0;\n        for(auto num:nums){\n            total_m = (total_m+num)%p;\n        }\n        if(total_m==0){\n            return 0;\n        }\n        // 子数组\n        unordered_map<int, int> hash_idx;\n        int num_m = 0;\n        int res = nums.size();\n        for(int i=0; i<nums.size();i++){\n            hash_idx[num_m] = i;\n            num_m = (num_m + nums[i]) %p;\n            if(hash_idx.count((num_m-total_m+p)%p)>0){\n                res = min(res, i - hash_idx[(num_m-total_m+p)%p]+1);\n            }\n        }\n        return res==nums.size()?-1:res;\n\n    }\n};\n```\n- 时间 $O(N)$\n- 空间 $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/26#issuecomment-2089739729","body":"思路：\n- 快慢指针，slow每次走1步，fast每次走2步，fast到链表尾部，正好slow到达中点；\n- 设置虚拟头节点，当fast恰好到尾部时，那么slow->next为本题要求。\n\n```cpp\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* preH = new ListNode(0);\n        ListNode* slow = preH;\n        ListNode* fast = preH;\n        preH->next = head;\n        while(fast->next!=nullptr&&fast->next->next!=nullptr){\n            slow=slow->next;\n            fast=fast->next;\n            fast=fast->next;\n        }\n        return slow->next;\n    }\n};\n```\n- Time $O(N)$\n- Space $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/27#issuecomment-2094210722","body":"- slow 指针 nums[slow]更新不重复元素\n\n```cpp\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int n = nums.size();\n        int slow=1, fast=1;\n        while(fast<n){\n            if(nums[fast] != nums[fast-1]){\n                nums[slow] = nums[fast];\n                slow++;\n            }\n            fast++;\n        }\n        return slow;        \n    }\n};\n```\n- Time O(n)\n- Space O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/28#issuecomment-2094201611","body":"二分法闭区间\n\n```cpp\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l = 0, r = nums.size()-1;\n        int temp = 0;\n        while(l<=r){\n            temp = l+(r-l)/2;\n            cout << temp << endl;\n            if(nums[temp]>=target){\n                r = temp-1;\n            }\n            if(nums[temp]<target){\n                l = temp+1;\n            }\n        }\n        return l;\n    }\n};\n```\n- Time O(logn)\n- Space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/29#issuecomment-2100666806","body":"思路\n- 滑动窗口\n- 单调队列\n\n```cpp\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        deque<int> q;\n        int n = nums.size();\n        vector<int> ans(n-k+1);\n        int cur_m;\n        for(int j=0, i=1-k; j<nums.size(); i++,j++){\n            if(i>0 && q.front()==nums[i-1])\n                q.pop_front();\n            // 保持递减\n            while(!q.empty() && q.back()<nums[j])\n                q.pop_back();\n            q.push_back(nums[j]);\n            if(i>=0){\n                ans[i] = q.front();\n            }\n        }\n        // for(int i=0; i<=n-k; i++){\n            // cur_m = maxCur(nums, i, i+k);\n        //     ans.push_back(cur_m);\n        // }\n        return ans;\n    }\n    // int maxCur(vector<int>& nums, int start, int end){\n    //     int cur=-10001;\n    //     for(int i=start; i<end; i++){\n    //         cur = max(cur, nums[i]);\n    //     }\n    //     cout<< cur<< endl;\n    //     return cur;\n    // }\n};\n```\n- Time O(n)\n- Space O(k)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/30#issuecomment-2098561429","body":"图 统计入度；\n```cpp\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        if(trust.empty()&&n==1) return 1;\n        unordered_map<int, int> cont;\n        for(auto& relation : trust){\n            cont[relation[0]] += -1; // 出\n            cont[relation[1]] += 1;  // 入\n        }\n        int no_law = -1;\n        for(auto& k:cont){\n            if( k.second== n-1){\n                no_law = k.first;\n            }\n        }\n        return no_law;\n    }\n};\n```\n- Time O(N)\n- Space O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/31#issuecomment-2100463884","body":"思想\n- 构建图\n- 二分图 染色法\n- dfs\n\n```cpp\nclass Solution {\n    unordered_map<int, vector<int>> G;\n    vector<int> _colors;\npublic:\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        for(auto& tmp:dislikes){\n            int a = tmp[0]-1, b = tmp[1]-1;\n            G[a].push_back(b);\n            G[b].push_back(a);\n        }\n        _colors = vector<int> (n,0);\n        for(int i = 0; i<n; ++i){\n            if(_colors[i] == 0 && !dfs(i,1))\n                return false;\n        }\n        return true;\n    }\n    bool dfs(int cur, int color){\n        _colors[cur]=color;\n        for(int next: G[cur]){\n            if(_colors[next] == color) // 讨厌的已分组，结果是一组\n                return false;\n            if(_colors[next] == 0 && !dfs(next, -color)) // cur是color组，讨厌的未分组不是-color组（讨厌的不能是一组）\n                return false;\n        }\n        return true;\n    }\n};\n```\n\n- Time $O(n+m)$  人数n，关系数m\n- Space $O(n+m)$","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/32#issuecomment-2100841090","body":"```python\nclass Solution:\n    def tp_sorted(self, items, indegree, neighbors):\n        q = collections.deque([])\n        ans = []\n        for item in items:\n            if not indegree[item]:\n                q.append(item)\n        while q:\n            cur = q.popleft()\n            ans.append(cur)\n\n            for neighbor in neighbors[cur]:\n                indegree[neighbor] -= 1\n                if not indegree[neighbor]:\n                    q.append(neighbor)\n        return ans\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\n        max_group_id = m \n        for i in range(n):\n            if group[i] == -1:\n                group[i] = max_group_id\n                max_group_id += 1\n        \n        project_indegree = collections.defaultdict(int)\n        group_indegree = collections.defaultdict(int)\n        project_neighbors = collections.defaultdict(list)\n        group_neighbors = collections.defaultdict(list)\n        group_projects = collections.defaultdict(list)\n\n        for project in range(n):\n            group_projects[group[project]].append(project)\n            for pre in beforeItems[project]:\n                if group[pre] != group[project]:\n                    group_indegree[group[project]] += 1\n                    group_neighbors[group[pre]].append(group[project])\n                else:\n                    project_indegree[project] += 1\n                    project_neighbors[pre].append(project)\n        ans = []\n        group_queue = self.tp_sorted([i for i in range(max_group_id)], group_indegree, group_neighbors)\n\n        if(len(group_queue)!=max_group_id):\n            return []\n        for group_id in group_queue:\n            project_queue = self.tp_sorted(group_projects[group_id], project_indegree, project_neighbors)\n\n            if len(project_queue) != len(group_projects[group_id]):\n                return []\n            ans += project_queue\n\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/33#issuecomment-2101736838","body":"思路：回到原点说明向左与向右的位移量相等，向上与向下位移量相等。\n\n```cpp\nclass Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int ud = 0, lr = 0;\n        bool ans;\n        for(auto& cur : moves){\n            if(cur=='L')\n                lr += -1;\n            else if(cur=='R')\n                lr += 1;\n            else if(cur=='D')\n                ud += -1;\n            else if(cur=='U')\n                ud += 1;\n        }\n        ans = (ud==0 && lr==0)? true:false;\n        return ans;\n    }\n};\n```\n- Time O(n)  字符串长度\n- Space  O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/34#issuecomment-2104528695","body":"- 优先队列（小顶堆）：当前时刻下，需要处理的任务放入队列\n- 排序：更新时间戳\n```cpp\nclass Solution {\npublic:\n    vector<int> getOrder(vector<vector<int>>& tasks) {\n        int n = tasks.size();\n        vector<int> idx(n);\n        iota(idx.begin(), idx.end(), 0);\n        sort(idx.begin(), idx.end(), [&](int i, int j){\n            return tasks[i][0] < tasks[j][0];\n        });\n        vector<int> ans;\n        long long timesample=1;\n        int ptr = 0;\n        // 小堆 优先队列\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int,int>>> q;\n        for(int i=0; i<n; ++i){\n            if(q.empty()){\n                timesample = max(timesample, (long long)tasks[idx[ptr]][0]);\n            }\n            // 将小于等于时间戳的任务放入\n            while(ptr<n && tasks[idx[ptr]][0]<=timesample){\n                q.emplace(tasks[idx[ptr]][1], idx[ptr]);// 任务耗时， 索引\n                ++ptr;\n            }\n            auto& process = q.top().first;\n            auto& a = q.top().second;\n            timesample += process;\n            ans.push_back(a);\n            q.pop();\n\n        }\n        return ans;\n    }\n};\n```\n- Time O(nlogn)\n- Space O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/35#issuecomment-2105940087","body":"```python\nclass Solution:\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\n        sh, sm = map(int, loginTime.split(\":\"))\n        eh, em = map(int, logoutTime.split(\":\"))\n        day = 0\n        if sh * 60 + sm > eh * 60 + em: day += 1\n        # 开始-> 15,30,45,0\n        if 0 < sm <= 15:\n            sm = 15\n        elif 15 < sm <= 30:\n            sm = 30\n        elif 30 < sm <= 45:\n            sm = 45\n        elif 45 < sm <= 60:\n            sm = 0\n            sh += 1\n        # 结束-> 0,15,30,45\n        if 0 <= em < 15:\n            em = 0\n        elif 15 <= em < 30:\n            em = 15\n        elif 30 <= em < 45:\n            em = 30\n        elif 45 <= em < 60:\n            em = 45\n        # 转换为分钟，被15整除    \n        st = sh * 60 + sm\n        et = eh * 60 + em\n        if day == 1: et += 1440 #add 24h\n        return max(0, (et - st)) // 15\n```\n参考思路","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/36#issuecomment-2106289195","body":"```python\nclass Solution:\n    def minCharacters(self, a: str, b: str) -> int:\n        coutA = [0]*26\n        coutB = [0]*26 # count 26 nums\n        for cur1 in a:\n            coutA[ord(cur1)-ord('a')] +=1\n        for cur2 in b:\n            coutB[ord(cur2)-ord('a')] +=1\n        ans = len(a)+len(b)\n\n        # 条件3\n        for i in range(26):\n            ans = min(ans, len(a)+len(b)-coutA[i]-coutB[i])\n        print(ans,\"\\n\")\n        # 条件1\n        for i in range(1,26):\n            t = 0\n            for j in range(i,26):\n                t += coutA[j]\n            for k in range(i):\n                t += coutB[k]\n            ans = min(ans, t)\n        print(ans,\"\\n\")\n        # 条件2\n        for i in range(1,26):\n            t = 0\n            for j in range(i,26):\n                t += coutB[j]\n            for k in range(i):\n                t += coutA[k]\n            ans = min(ans, t)\n        return ans\n```\n- Time O(m+n)\n- Space O(26)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/37#issuecomment-2108083878","body":"冒泡，计数\n```python\nclass Solution:\n    # def swp(self, nums:List[int], a:int, b:int):\n    #     temp = nums[a]\n    #     nums[a] = nums[b]\n    #     nums[b] = temp\n\n    def sortArray(self, nums: List[int]) -> List[int]:\n        # # 冒泡\n        # n = len(nums)\n        # flag = 1\n        # for i in range(n-1):\n        #     for j in range(0,n-i-1):\n        #         if(nums[j]>nums[j+1]):\n        #             self.swp(nums, j, j+1)\n        #             flag = 0\n        #     if(flag):break\n                \n        # return nums\n        n = len(nums)\n        min_m = min(nums)\n        max_m = max(nums)\n        cout = [0]*(max_m-min_m+1)\n        for i in range(n):\n            cout[nums[i]-min_m] +=1\n        cur = 0\n        for j in range(max_m-min_m+1):\n            while(cout[j]):\n                nums[cur] = j + min_m\n                cout[j] += -1\n                cur += 1\n        return nums\n```\n计数复杂度满足\n- Time O(Max-Min)\n- Space O(Max-Min)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/38#issuecomment-2110568276","body":"```python\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        l, r, ans = 0, x, -1\n        while l<=r:\n            mid = l+(r-l)//2\n            if mid**2<=x:\n                ans = mid\n                l = mid + 1\n            else:\n                r = mid - 1 \n        return ans\n\n```\n- Time O(logx)\n- Space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/39#issuecomment-2112912920","body":"二分\n```python\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        l, r = 1, n\n        while(l<=r):\n            mid = (l+r)//2\n            if(isBadVersion(mid)):\n                r = mid - 1\n            else:\n                l = mid + 1\n        return l\n```\n- Time O(logn)\n- Space O(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/44#issuecomment-2120501503","body":"固定滑动窗口：\n- 添加1元素若是元音，则+1\n- 删除1元素若是元音，则-1\n```cpp\nclass Solution {\npublic:\n    bool isYuan(char cur){\n        if(cur == 'a' ||cur == 'e' ||cur == 'i' ||cur == 'o' ||cur == 'u')\n            return true;\n        return false;\n    }\n    int maxVowels(string s, int k) {\n        int ans = 0;\n        int temp = 0;\n        \n        for(int l = 0; l < s.size()-k+1; l++){            \n            if(l==0){\n                for(auto& a:s.substr(l,k)){\n                    if(isYuan(a)){\n                        temp++;\n                    }\n                }\n            }\n            else{\n                if(isYuan(s[l-1])){temp--;}\n                if(isYuan(s[l+k-1])){temp++;}\n            }\n            ans = max(ans, temp);\n            if(temp==k) break;\n        }\n        return ans;\n    }\n};\n```\n- Time O(N)\n- Space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/45#issuecomment-2122541968","body":"```python\nclass Solution:\n    def new21Game(self, n: int, k: int, maxPts: int) -> float:\n        dp = [0]*(k+maxPts)\n        my_sum = 0\n        for i in range(k,k+maxPts):\n            if i<=n:\n                dp[i]=1\n            my_sum += dp[i]\n        for i in range(k-1, -1, -1):\n            dp[i] = my_sum/maxPts\n            my_sum += dp[i]\n            my_sum += -dp[i+maxPts]\n        return dp[0]\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/49#issuecomment-2131134555","body":"```python\nclass Solution:\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\n        minute = [1, 2, 4, 8, 16, 32]\n        hour = [1, 2, 4, 8]\n        h_len, m_len = len(hour), len(minute)\n        ans = []    \n        def time(combi, led,  start):\n            if led == 0:\n                if combi[1] < 10:\n                    ans.append(str(combi[0]) + ':0' + str(combi[1]))\n                else:\n                    ans.append(str(combi[0]) + ':' + str(combi[1]))\n            else:\n                for i in range(start, h_len + m_len):\n                    if i < h_len:\n                        combi[0] += hour[i]\n                        if combi[0] <= 11:\n                            time(combi, led - 1, i + 1)\n                        combi[0] -= hour[i]\n                    else:\n                        combi[1] += minute[i - h_len]\n                        if combi[1] <= 59:\n                            time(combi, led - 1, i + 1)\n                        combi[1] -= minute[i - h_len]       \n        cur = 2 * [0]\n        time(cur, turnedOn, 0)\n        return ans\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/53#issuecomment-2137318396","body":"题目虽然是最大，但事实是将能够开的盒子都开了求从中获取糖果数。\n那么需要一层一层开，开盒子的条件：\n1. 获得了，本身盒子是开的\n2. 获得了，本身是关着的，又获得了钥匙\n\n```C++ []\nclass Solution {\npublic:\n    int maxCandies(vector<int>& status, vector<int>& candies, vector<vector<int>>& keys, vector<vector<int>>& containedBoxes, vector<int>& initialBoxes) {\n      int ans=0;\n      unordered_map<int, pair<int,int>> hash; // 盒子索引（是否获取，是否有钥匙）\n      queue<int> q; // 可获取盒子索引\n      // 查看初始化 initialBoxes\n      if(initialBoxes.empty()) return ans;\n      else{\n        for(auto init:initialBoxes){\n          q.push(init);\n        }\n      }\n      // 维护队列\n      while(!q.empty()){\n        int cur = q.front();\n        // 判断是否能开启\n        if(status[cur]==1){\n          ans += candies[cur];\n          // 看看有没有钥匙\n          if(!keys[cur].empty()){\n            for(auto key:keys[cur]){\n              status[key] = 1; // 有钥匙设置状态为1\n              auto it = hash.find(key);\n              if( it!=hash.end() ){\n                q.push(key);\n                hash.erase(key); // 删除               \n              }\n            }\n          }\n          // 放入获得的盒子\n          for(auto box:containedBoxes[cur]){\n            q.push(box);\n          }\n        }\n        else{\n          hash[cur] = {1,0}; // 存一些没有钥匙的盒子\n        }\n        \n        q.pop();//删除\n        \n      }\n      return ans;\n    }\n};\n```\n\n时间复杂度: $O(n)$\n\n空间复杂度: $O(n)$","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/58#issuecomment-2145537704","body":"二维动态规划\n\n```python\nclass Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        m = len(text1)\n        n = len(text2)\n        dp = [[0]*(n+1) for _ in range(m+1)] #n text2 ; m text1\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if text1[i-1] == text2[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1])\n        \n        return dp[m][n]\n```\n- Time O(n*m)\n- Space O(n*m)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/63#issuecomment-2156042704","body":"0-1背包问题\n```python\nclass Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        bag = target+sum(nums)\n        if bag < 0 or bag%2:\n            return 0\n\n        @cache\n        def dfs(i, c): # c背包容量\n            if i < 0:\n                return 1 if c==0 else 0\n            if c < nums[i]:\n                return dfs(i-1, c)\n            return dfs(i-1, c)+dfs(i-1, c-nums[i])\n        return dfs(len(nums)-1, bag//2)\n```\nn= len(nums)\ns= sum(nums)\n- Time O(n*(Target+s))\n- Space O(n*(Target+s))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/64#issuecomment-2156663260","body":"完全背包\n```python\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount<0: return -1\n        @cache\n        def dfs(i, c):\n            if i<0:\n                return 0 if c== 0 else inf\n            if c < coins[i]:\n                return dfs(i-1, c)\n            return min(dfs(i-1,c),dfs(i, c-coins[i])+1)\n        ans = dfs(len(coins)-1, amount)\n        return ans if ans < inf else -1\n\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/69#issuecomment-2168263807","body":"```python\nclass Solution:\n    def numTrees(self, n: int) -> int:\n        f = [0] * (n+10)\n        f[0] = 1\n        for i in range(1, n + 1):\n            for j in range(1, i+1):\n                f[i] += f[j-1] * f[i-j]\n                \n        return f[n]\n```\n- Time $O(n^{2})$\n- Space $O(n)$","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/74#issuecomment-2178724459","body":"前缀树，一种树的结构\n- 构建树 节点 1. 字符的字典 2. 完整word计数 3. 前缀pre计数\n- 插入 从根节点出发，逐个字符插入，没有就创建树\n- 搜索 从根节点开始找，逐个字符寻找\n- 搜索pre 从根节点逐个字符寻找\n```python\nclass TrieNode:\n    def __init__(self):\n        self.count = 0 # 单词个数\n        self.preCount = 0 # 前缀个数\n        self.children = {}\nclass Trie:\n\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for tmp in word:\n            if tmp not in node.children:\n                node.children[tmp] = TrieNode()\n            node = node.children[tmp]\n            node.preCount += 1\n        node.count += 1\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for tmp in word:\n            if tmp not in node.children:\n                return False\n            node = node.children[tmp]\n        return node.count > 0\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for tmp in prefix:\n            if tmp not in node.children:\n                return False\n            node = node.children[tmp]\n        return node.preCount > 0\n\n```\n\n时间复杂度: $O(n)$ 待插入(查找) word or pre\n\n空间复杂度: $O(m*n)$ m操作中字符个数，n字符平均长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/75#issuecomment-2179690547","body":"- insert 使用字典嵌套实现\n- sum 先进行前缀判断，若不符合直接return 0，若符合，后续使用DFS遍历尾部求加和\n\n```Python3 []\nclass MapSum:\n\n    def __init__(self):\n        self.dic = {}\n\n    def insert(self, key: str, val: int) -> None:\n        node = self.dic\n        for ch in key:\n            if ch not in node:\n                node[ch] = {}\n            node = node[ch]\n        node['#'] = val\n\n    def sum(self, prefix: str) -> int:\n        node = self.dic\n        for ch in prefix:\n            if ch not in node:\n                return 0\n            node = node[ch]\n        return self.dfs(node)\n    \n    def dfs(self, node):\n        ans = 0\n        for tmp in node.keys():\n            if tmp == '#':\n                ans += node['#']\n            else:\n                ans += self.dfs(node[tmp])\n        return ans\n\n```\n\n时间复杂度: $O(n)$\n\n空间复杂度: $O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/76#issuecomment-2182346270","body":"smalls构建前缀树，big子集遍历\n```Python3 []\nimport collections\nclass Trie:\n    def __init__(self, words):\n        self.d = {}\n        # t = self.d 不能写在循环外面，一次到底了\n        for word in words:\n            t = self.d # 回到头部，回到字典嵌套第一层而不是尾层\n            for w in word:\n                if w not in t:\n                    t[w] = {}\n                t = t[w]\n            t['end'] = word \n        # 不止一个根的前缀树\n    \n    def search(self, s):\n        t = self.d\n        res = []\n        for w in s:\n            if w not in t:\n                break\n            t = t[w]\n            if 'end' in t:\n                res.append(t['end'])\n        return res\n\nclass Solution:\n    def multiSearch(self, big: str, smalls: List[str]) -> List[List[int]]:\n        node = Trie(smalls)\n        dic = collections.defaultdict(list)\n\n        for i in range(len(big)):\n            match_words = node.search(big[i:])\n            for word in match_words:\n                dic[word].append(i)\n            \n        ans = []\n        for word in smalls:\n            ans.append(dic[word])\n        return ans\n```\n时间复杂度: $O(n*m)$ n表示big的长度\n\n空间复杂度: $O(m*k)$ m表示smalls的长度，k表示smalls中最长字符串的长度，最坏的情况时都匹配上\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/77#issuecomment-2183822877","body":"```Python3 []\nclass uk:\n    def __init__(self, M):\n        self.parent = {}\n        self.cnt = 0\n        for i in range(M):\n            # for j in range(i, n):\n            #     if i not in self.parent:\n            #         self.parent[i] = []\n            self.parent[i]=i #自己是自己的parent\n            self.cnt += 1\n    def find(self, x):\n        while x != self.parent[x]:\n            x = self.parent[x]\n        return self.parent[x]\n    \n    # def connected(self, p, q):\n    #     return self.find(p)==self.find(q)\n    \n    def union(self, p, q):\n        parent_p = self.find(p)\n        parent_q = self.find(q)\n        if parent_p != parent_q:\n            self.cnt -= 1\n            self.parent[parent_p] = parent_q\n        # if self.connected(p,q):return\n        # leader_p = self.find(p)\n        # leader_q = self.find(q)\n        # self.parent[leader_p] = leader_q\n        # self.cnt -= 1\n\n\nclass Solution:\n    def findCircleNum(self, isConnected: List[List[int]]) -> int:\n        n = len(isConnected)\n        unfind = uk(n) # 初始化并查集\n        for i in range(n):\n            for j in range(i+1,n):\n                if isConnected[i][j]: # 仅联通，代表是谁？\n                    # tmp = unfind.find(i)\n                    # if unfind.find(j)==tmp:\n                    #     break\n                    unfind.union(i,j)\n        return unfind.cnt\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/82#issuecomment-2195053128","body":"```python\nclass Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        ans = []\n        temp = []\n        def backtracking(candidates,target,Sum,startIndex):\n            if Sum==target:\n                ans.append(temp[:])\n                return\n            if Sum>target:\n                return\n            for i in range(startIndex,len(candidates)):\n                if i > startIndex and candidates[i] == candidates[i-1]: continue\n                temp.append(candidates[i])\n                Sum += candidates[i]\n                backtracking(candidates,target,Sum,i+1)\n                temp.pop()\n                Sum -= candidates[i]\n        candidates=sorted(candidates)\n        backtracking(candidates,target,0,0)\n        return ans\n```","onTime":true},null,null,null,null,null,null,null,null,null,null],"greyqt":[{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/1#issuecomment-2043188462","body":"题解思路：\r\n（1）整型按位翻转存放在容器中\r\n（2）翻转num容器，然后按位相加，并考虑进位情况\r\n（3）翻转最后的结果即为答案\r\n代码：\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int digit = 0;\r\n        vector<int> k_num;\r\n        vector<int> result;\r\n        for (int i = 0; ; i++)\r\n        {\r\n            digit = (k / (int)pow(10, i)) % 10;\r\n            if (digit == 0 && (int)pow(10, i) > k )\r\n            {\r\n                break;\r\n            }\r\n            k_num.push_back(digit); //翻转存放\r\n        }\r\n        int carry = 0; // 进位\r\n        int size = max(num.size(), k_num.size()); // 选择两个容器中较大的大小作为循环次数\r\n        reverse(num.begin(), num.end());    //num容器翻转\r\n        for (int i = 0; i < size; ++i) \r\n        {\r\n            int digit1 = (i < num.size()) ? num[i] : 0; // 如果 i 超出 num 的索引范围，取 0\r\n            int digit2 = (i < k_num.size()) ? k_num[i] : 0; // 如果 i 超出 k_num 的索引范围，取 0\r\n            int sum = digit1 + digit2 + carry; // 计算当前位的和\r\n            carry = sum / 10; // 更新进位\r\n            result.push_back(sum % 10); // 将当前位的结果添加到结果容器中\r\n        }\r\n        // 如果最高位有进位，需要额外添加一位\r\n        if (carry > 0) \r\n        {\r\n            result.push_back(carry);\r\n        }\r\n        reverse(result.begin(), result.end());  //翻转获得结果\r\n        return result;\r\n    }\r\n};\r\n```\r\n复杂度分析：\r\n时间复杂度：取决于整数 k 的位数和 num 容器的大小，因此为O(n)\r\n空间复杂度：取决于空间复杂度主要取决于 k_num 和 result 容器的大小，因此为O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/2#issuecomment-2045318663","body":"题解思路：\n（1）获取字符串的下标存在在结果数组中，及字符C的下标存在在数组中\n（2）使字符串的下标数组减去字符C的下标数组并取最小值\n代码：\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> ac,res;\n        int length = s.size();\n        for(int i=0; i < length; ++i)//获取字符串的下标，及字符C的下标\n        {\n            res.push_back(i);\n            if(c == s[i])\n                ac.push_back(i);\n        }\n        for(auto it = res.begin(); it != res.end(); ++it)//使字符串的下标减去字符C的下标并取最小值\n        {\n            int min = length;\n            for(auto at = ac.begin(); at != ac.end(); ++at)\n            {\n                int temp = abs((*it)-(*at));\n                if(min >= temp)\n                    min = temp;\n            }\n            *it = min;\n        }\n        return res;\n    }\n};\n```\n复杂度分析：\n时间复杂度：取决于字符串的长度n和目标字符 c 的数量m，因此为O(n*m)\n空间复杂度：取决于字符串的长度n对应的结果vector，因此为O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/3#issuecomment-2047883121","body":"### 题解思路：\n（1）使用vector容器作为数据的载体\n（2）vector的末尾作为栈顶\n### 代码：\n```cpp\nclass CustomStack {\nprivate:\n    int _size;\n    int _maxsize;\n    vector<int> stack;\n    \npublic:\n    CustomStack(int maxSize) {\n        _maxsize=maxSize;\n        _size=0;\n    }\n    \n    void push(int x) {\n        if(_size < _maxsize)\n        {\n            stack.push_back(x);\n            _size++;\n        }            \n    }\n    \n    int pop() {\n        if(0 == stack.size())\n            return -1;\n        \n        int re = stack.back();\n        \n        stack.pop_back();\n        _size--;                   \n        \n        return re;\n    }\n    \n    void increment(int k, int val) {\n        if(k > stack.size())\n            k=stack.size();\n            \n        int count=0;\n        for(auto it = stack.begin(); it != stack.end(); ++it)\n        {\n            if(count == k)\n                break;\n                \n            *it += val;\n            count++;\n        }\n    }\n};\n```\n**复杂度分析**：\n**CustomStack(int maxSize)**：\n- 时间复杂度：不依赖于输入，所以为O(1)\n- 空间复杂度：不依赖于输入，所以为O(1)\n\n**void push(int x)**：\n- 时间复杂度：push_back() 操作的平均时间复杂度是 O(1)，因此平均时间复杂度为O(1)，偶尔需要重新分配内存，导致复杂度为 O(n)\n- 空间复杂度：push_back() 操作的空间时间复杂度是 O(1)，因此平均空间复杂度为O(1)，偶尔需要重新分配内存，导致复杂度为 O(n)\n\n**int pop()**：\n- 时间复杂度：不涉及对内存的操作，只需要减少vector向量的计数，所以为O(1)\n- 空间复杂度：不需要额外的内存分配或释放，所以为O(1)\n\n**void increment(int k, int val)**：\n- 时间复杂度：时间复杂度取决于输入的int k，因此为O(k)\n- 空间复杂度：没有使用额外的空间，所以为O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/4#issuecomment-2050025367","body":"### 题解思路：\n代码：\n```cpp\nclass Solution {\npublic:\nstring decodeString(string s) {\n    stack<char> strstack;\n    string res;\n    int count = 0;\n    for (int i = 0; i < s.size(); ++i)\n    {\n        if (s[i] != ']')\n        {\n            strstack.push(s[i]);//字符逐个压栈\n        }\n        else\n        {\n            string temp;\n            while (strstack.top() != '[')\n            {\n                temp = strstack.top() + temp;\n                strstack.pop();\n            }\n            strstack.pop();//[出栈\n            count = strstack.top() - '0';\n            strstack.pop();\n            string countstr;\n            while (count--)\n            {\n                countstr += temp;\n            }\n            for (int j = 0; j < countstr.size(); ++j)\n            {\n                strstack.push(countstr[j]);\n            }\n            temp.clear();\n            countstr.clear();\n        }\n    }\n\n    while (!strstack.empty()) {\n        res += strstack.top();\n        strstack.pop();\n    }\n\n    reverse(res.begin(), res.end());\n    return res;\n    }\n};\n```\n**复杂度分析**：\n- 时间复杂度：\n- 空间复杂度：\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/5#issuecomment-2051946064","body":"### 题解思路：\n（1）创建一个存储数据的栈，和一个过渡处理的栈\n代码：\n```cpp\nclass MyQueue {\nprivate:\n    stack<int> store,deal;\npublic:\n    MyQueue() {\n        while (!store.empty())\n        {\n            store.pop();\n        }\n        while (!deal.empty()) \n        {\n            deal.pop();\n        }\n    }\n    \n    void push(int x) {\n        store.push(x);\n    }\n    \n    int pop() {\n        int res = 0;\n        while(!store.empty())\n        {\n            deal.push(store.top());\n            store.pop();\n        }\n        res = deal.top();\n        deal.pop();\n        while(!deal.empty())\n        {\n            store.push(deal.top());\n            deal.pop();\n        }\n        return res;\n    }\n    \n    int peek() {\n        int res = 0;\n        while(!store.empty())\n        {\n            deal.push(store.top());\n            store.pop();\n        }\n        res = deal.top();\n        while(!deal.empty())\n        {\n            store.push(deal.top());\n            deal.pop();\n        }\n        return res;\n    }\n    \n    bool empty() {\n        if(store.empty())\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }\n};\n```\n**复杂度分析**：\n- 时间复杂度：取决队列中的元素个数，因此时间复杂度为O(n)\n- 空间复杂度：使用了两个栈来实现，复杂度取决队列中的元素个数，因此空间复杂度为O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/6#issuecomment-2053528383","body":"### 题解思路：\r\n（1）创建一个已经排序好的数组sorted\r\n（2）创建两个哈希表，从左到右遍历数组，分别存储数组arr和数组sorted中元素出现的频次，数组中元素的值作为键，其出现的频次作为键值；\r\n（3）当两个哈希表中所有键的值都相等时，既表示可以切分原数组；\r\n代码：\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        vector<int> sorted(arr.begin(), arr.end());\r\n        unordered_map<int, int> arrmap, sortedmap;\r\n        sort(sorted.begin(), sorted.end());\r\n        \r\n        int count = 0;\r\n        for (int i = 0; i < arr.size(); ++i)\r\n        {\r\n            int flag = 0;\r\n            arrmap[arr[i]] += 1; //记录arr[i]出现的频次\r\n            sortedmap[sorted[i]] += 1;//记录sorted[i]出现的频次\r\n            for (const auto& pair : arrmap)\r\n            {\r\n                int temp = (pair.second + sortedmap[pair.first]) % 2;//如果pair.first出现的频次，在两个数组中出现一致；表示可以切分\r\n                if ((temp != 0 ) || (pair.second != sortedmap[pair.first]))//确保元素在两个数组中出现的频次一致\r\n                {\r\n                    flag = 1;\r\n                }\r\n            }\r\n            if (flag == 0)\r\n            {\r\n                count++;\r\n                arrmap.clear();\r\n                sortedmap.clear();\r\n            }\r\n        }\r\n        return count;\r\n    }\r\n};\r\n```\r\n**复杂度分析**：\r\n- 时间复杂度：sorted数组排序的时间复杂度为 O(nlogn)，在两个for循环的遍历中，时间复杂度是n^2，因此时间复杂度比较高是O(n^2);\r\n- 空间复杂度：创建 sorted 数组和 arrmap、sortedmap 哈希表，长度取决于输入的数组的长度n，因此空间复杂度分别为 O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/7#issuecomment-2053981094","body":"### 题解思路：\n（1）计算链表长度并找到尾节点\n（2）形成环形链表减少尾处理\n（3）将 k 取模，减少多余操作\n（4）从头节点到新头节点的步数，找到新的尾节点，断开链表\n\n代码：\n```cpp\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) \n    {\n        if (head == nullptr || k == 0)\n        {\n            return head;\n        }\n        ListNode* tail = head;\n        int len = 1;\n        while (tail->next)  //计算链表长度并找到尾节点\n        {\n            len++;\n            tail = tail->next;\n        }\n        tail->next = head; //形成环形链表减少尾处理；\n        k = k % len; //将 k 取模，减少多余操作\n        int step = len - k;//计算从头节点到新头节点的步数\n        ListNode* newtail = head;\n        for (int i = 1; i < step; ++i)\n        {\n            newtail = newtail->next;//找到新的尾节点\n        }\n        ListNode* newhead = newtail->next;// 新的头节点\n        newtail->next = nullptr;//断开链表\n        return newhead;\n    }\n};\n```\n**复杂度分析**：\n- 时间复杂度：取决于链表的长度n，因此时间的复杂度为O(n)\n- 空间复杂度：函数额外创建变量存储指针和普通变量，因此空间复杂度为 O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/8#issuecomment-2057042732","body":"### 题解思路：\n（1）分解子问题：每一次都是两个节点交换的问题\n（2）子问题推导递推公式：\nnewHead = head->next;\nhead->next = newHead->next;\nnewHead->next = head;\n（2）判断递归终止条件：链表剩余为空或者仅一个节点\n代码：\n```cpp\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == nullptr || head->next == nullptr)\n        {\n            return head;\n        }\n        ListNode* newHead = head->next;\n        head->next = swapPairs(newHead->next);\n        newHead->next = head;\n        return newHead;\n    }\n};\n```\n**复杂度分析**：\n- 时间复杂度：取决于链表的长度n，因此时间的复杂度为O(n)\n- 空间复杂度：取决于链表的长度n，每一层递归调用都会使用一定的堆栈空间，因此空间复杂度为 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/9#issuecomment-2059413611","body":"### 题解思路：\n1，分解子问题：每一次都是创建一个最小平衡二叉树\n2，子问题推导递推公式：\n（0）首次左端为链表的头，右端为链表尾null\n对于左子树，每一次递归，左端为链表的头，右端为中位数;\n对于右子树，每一次递归，左端为中位数->next，右端为链表尾null；\n（1）获取中位数，作为根节点；\n（2）中位树数的左侧为，左子节点（左子树）；中位数的右侧为右子节点（右子树）；\n（3）每一个左子树和右子树，重复步骤（1）（2）；\n3，判断递归终止条件：当左端等于右端时结束；\n代码：\n```cpp\nclass Solution {\npublic:\n    //快慢指针寻找中位数\n    ListNode* find_mid(ListNode* left, ListNode* right)\n    {\n        ListNode* slow = left;\n        ListNode* fast = left;\n        while (fast != right && fast->next != right)\n        {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return slow;\n    }\n\n    TreeNode* creatree(ListNode* left, ListNode* right)\n    {\n        if(left == right)\n        {\n            return nullptr;\n        }\n        ListNode* mid = find_mid(left, right);\n        TreeNode* root = new TreeNode(mid->val);\n        root->left = creatree(left, mid);\n        root->right = creatree(mid->next, right);\n        return root;\n    }\n    TreeNode* sortedListToBST(ListNode* head) \n    {\n        return creatree(head,nullptr);\n    }\n};\n```\n**复杂度分析**：\n- 时间复杂度：取决于链表的长度n，以及二分创建树的递归，因此时间的复杂度为O(nlog n)\n- 空间复杂度：取决于链表的长度n，每一层递归创建一个新的树节点，因此空间复杂度为 O(log n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/10#issuecomment-2061492075","body":"### 题解思路：\n1，遍历链表headA将每个节点的地址存入数组中\n2，遍历链表headB，当headB中节点与A中的相等时返回，或者为找到既不相交返回空\n代码：\n```cpp\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        vector<ListNode *> headAvec;\n        while(headA != nullptr)\n        {\n            headAvec.push_back(headA);\n            headA = headA->next;\n        }\n        while(headB != nullptr)\n        {\n            for(auto it = headAvec.begin(); it != headAvec.end(); ++it)\n            {\n                if(*it == headB)\n                {\n                    return headB;\n                }\n            }\n            headB = headB->next;\n        }\n        return headB;\n    }\n};\n```\n**复杂度分析**：\n- 时间复杂度：取决于链表的长度n，时间的复杂度为O(n^2)\n- 空间复杂度：取决于链表的长度n，空间复杂度为 O( n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/11#issuecomment-2064126848","body":"### 题解思路：\n1.，使用两个指针，一个慢指针（每次移动一步）和一个快指针（每次移动两步），同时从链表的起始位置出发。\n2.，如果链表中存在环，快指针和慢指针在环内相遇。既确定链表中存在环\n3，然后重新将快指针指向链表的起始位置，并且保持慢指针在相遇点。\n4，最后以相同的速度（每次一步）移动慢指针和快指针。当它们再次相遇时，相遇点即为环的起始节点。\n代码：\n```cpp\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n         ListNode *slow = head, *fast = head;\n        do{\n            if(!fast || !fast->next)   //不存在闭环，返回空指针\n                return nullptr;\n            slow = slow->next;\n            fast = fast->next->next;\n        }while(fast != slow);   //不相等未闭环，继续\n        //存在，fast指针返回起点\n        fast = head;\n        //查找闭环起点，再次相交即为闭环起点\n        while(fast != slow)\n        {\n            slow = slow->next;\n            fast = fast->next;\n        }\n        return fast;\n    }\n};\n```\n**复杂度分析**：\n- 时间复杂度：取决于链表的长度n，时间的复杂度为O(n)\n- 空间复杂度：仅创建指针，因此空间复杂度为 O( 1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/12#issuecomment-2066822985","body":"还存在些问题\nclass LRUCache {\nprivate:\n    struct ListNode {\n        int key;\n        int val;\n        ListNode* next;\n        ListNode* last;\n        ListNode() : key(0), val(0), next(nullptr), last(nullptr) {}\n        ListNode(int _key, int _value)\n            : key(_key), val(_value), next(nullptr), last(nullptr) {}\n    };\n\n    ListNode* dummy_head;\n    ListNode* dummy_tail;\n\n    unordered_map<int, ListNode*> datamap;\n    int max_size;\n    int cur_size;\n\npublic:\n    LRUCache(int capacity) {\n        max_size = capacity;\n\n        dummy_head = new ListNode();\n        dummy_tail = new ListNode();\n\n        dummy_head->next = dummy_tail;\n        dummy_tail->last = dummy_head;\n    }\n\n    int get(int key) {\n        auto it = datamap.find(key);\n        if (it != datamap.end()) {\n            // 如果关键字 key 存在于缓存中\n            // 移动至头部\n            ListNode* cur_node = datamap[key];\n            moveToHead(cur_node);\n            // 则返回关键字的值\n            return cur_node->val;\n        } else {\n            return -1;\n        }\n    }\n\n    void put(int key, int value) {\n        auto it = datamap.find(key);\n        if (it != datamap.end()) {\n            // 如果关键字 key 已经存在，则变更其数据值 value\n            datamap[key]->val = value;\n            // 移动至头部\n            moveToHead(datamap[key]);\n        } else // 如果不存在，则向缓存中插入该组 key-value\n        {\n            // 创建新节点\n            ListNode* node = new ListNode(key, value);\n\n            // 头部插入\n            insertToHead(node);\n            // 保存哈希\n            datamap[key] = node;\n\n            cur_size++;\n            if (cur_size > max_size) {\n                // 如果插入操作导致关键字数量超过 capacity ，则应该 逐出\n                // 最久未使用的关键字。 删除末尾节点\n                ListNode* tail_node = removeTail();\n                // 删除哈希\n                datamap.erase(tail_node->key);\n                cur_size--;\n            }\n        }\n    }\n\n    void moveToHead(ListNode* node) {\n        node->last->next = node->next;\n        node->next->last = node->last;\n        node->next = dummy_head->next;\n        node->next->last = node;\n        dummy_head->next = node;\n        node->last = dummy_head;\n    }\n\n    void insertToHead(ListNode* node) {\n        ListNode* temp = dummy_head->next;\n        node->next = temp;\n        temp->last = node;\n        dummy_head->next = node;\n        node->last = dummy_head;\n    }\n\n    ListNode* removeTail() {\n        ListNode* tail_node = dummy_tail->last;\n        tail_node->last->next = dummy_tail;\n        dummy_tail->last = tail_node->last;\n        return tail_node;\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/13#issuecomment-2067704256","body":"### 题解思路：\n（1）分解子问题：每一次都是计算当前子树的最大深度\n（2）子问题推导递推公式：\nleftDepth = maxDepth(root->left);\nrightDepth = maxDepth(root->right);\n(leftDepth, rightDepth) + 1；\n（2）判断递归终止条件，当节点为空时；\n代码：\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),\n * right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        // 递归的终止条件：当节点为空时，返回深度为 0\n        if (root == NULL) {\n            return 0;\n        } else {\n            // 递归地计算左右子树的最大深度\n            int leftDepth = maxDepth(root->left);\n            int rightDepth = maxDepth(root->right);\n            // 返回左右子树最大深度中的较大值加上 1（当前节点的深度）\n            return max(leftDepth, rightDepth) + 1;\n        }\n    }\n};\n```\n**复杂度分析**：\n- 时间复杂度：取决于二叉树节点的个数n，因此时间的复杂度为O(n)\n- 空间复杂度：取决于二叉树的最大深度maxDepth，每一层递归调用都会使用一定的堆栈空间，因此空间复杂度为 O(maxDepth)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/14#issuecomment-2068029677","body":"### 题解思路：\n（1）分解子问题：每一次都是计算当前子树的两个子树是否相等\n（2）子问题推导递推公式：\n先判断左子树：isLeftTree = isSameTree(p->left, q->left)\n再判断右子树：isRightTree = isSameTree(p->right, q->right)\n（2）判断递归终止条件，当出现空节点时退出递归\n代码：\n```cpp\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (p == nullptr && q == nullptr) \n        {\n            return true;\n        } \n        else if (p != nullptr && q != nullptr) \n        {\n            if (p->val != q->val) \n            {\n                return false;\n            } \n            else \n            {\n                int isLeftTree = isSameTree(p->left, q->left);\n                int isRightTree = isSameTree(p->right, q->right);\n                if (isLeftTree != true || isRightTree != true) \n                {\n                    return false;\n                } \n                else \n                {\n                    return true;\n                }\n            }\n        } \n        else \n        {\n            return false;\n        }\n    }\n};\n```\n**复杂度分析**：\n- 时间复杂度：取决于两个二叉树节点的个数n，因此时间的复杂度为O(n)\n- 空间复杂度：也是取决于两个二叉树节点的个数n，因此空间复杂度为 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/15#issuecomment-2069997872","body":"代码：\n```cpp\nclass Solution {\npublic:\n    int sumNumbersDeal(TreeNode* root, int lastSum) {\n        if(root == nullptr)\n        {\n            return 0;\n        }\n        \n        int sum = lastSum * 10 + root->val;\n        if (root->left == nullptr && root->right == nullptr) \n        {\n            return sum;\n        } \n        else \n        {\n            int left = sumNumbersDeal(root->left, sum);\n            int right = sumNumbersDeal(root->right, sum);\n            return left + right;\n        }\n    }\n    int sumNumbers(TreeNode* root) \n    { \n        return sumNumbersDeal(root,0); \n    }\n};\n```\n**复杂度分析**：\n- 时间复杂度：时间的复杂度为O(n)\n- 空间复杂度：空间复杂度为 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/16#issuecomment-2072790728","body":"### 题解思路：\r\n（1）层序遍历树，且先把右节点入队，再把左节点入队，最有一个节点就是左下角节点；\r\n\r\n### 代码：\r\n```cpp\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),\r\n * right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int findBottomLeftValue(TreeNode* root) {\r\n        if (root == nullptr)\r\n            return 0; // 如果根节点为空，直接返回\r\n        queue<TreeNode*> q;\r\n        q.push(root); // 将根节点入队\r\n        while (!q.empty()) {\r\n            TreeNode* current = q.front(); // 获取队列头部节点\r\n            q.pop(); // 将头部节点出队\r\n            // 如果有右子节点，将右子节点入队\r\n            if (current->right != nullptr) {\r\n                q.push(current->right);\r\n            }\r\n            // 如果有左子节点，将左子节点入队\r\n            if (current->left != nullptr) {\r\n                q.push(current->left);\r\n            }\r\n        }\r\n        return q.back()->val;\r\n    }\r\n};\r\n```\r\n**复杂度分析**：\r\n- 时间复杂度：O(n)\r\n- 空间复杂度： O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/17#issuecomment-2075276838","body":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Codec {\npublic:\n\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        //#表示空节点\n        string res;\n        if (root == nullptr)\n        {\n            return res.append(\"#\"); // 如果根节点为空，直接返回，\n        }\n\n        queue<TreeNode*> q;\n        q.push(root); // 将根节点入队\n        while (!q.empty()) \n        {\n            TreeNode* current = q.front(); // 获取队列头部节点\n            res.append(to_string(current->val));\n\n            q.pop(); // 将头部节点出队\n\n            // 如果有左子节点，将左子节点入队\n            if (current->left != nullptr) \n            {\n                q.push(current->left);\n            }\n            else\n            {\n                res.append(\"#\"); \n            }\n            // 如果有右子节点，将右子节点入队\n            if (current->right != nullptr) \n            {\n                q.push(current->right);\n            }\n            else\n            {\n                res.append(\"#\"); \n            }\n        }\n\n        cout<<res<<endl;\n\n        return res;\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        if( data[0] == '#')\n        {\n            return nullptr;\n        }\n\n        TreeNode* root = new TreeNode(data[0] - '0');\n\n        size_t i = 1;\n\n        queue<TreeNode*> q;\n        q.push(root); // 将根节点入队\n\n        while (!q.empty() && i < data.size()) \n        {\n            TreeNode* current = q.front(); // 获取队列头部节点\n            q.pop(); // 将头部节点出队\n\n            //创建左节点\n            if (i < data.size() && data[i] != '#') \n            {\n                current->left = new TreeNode(data[i] - '0');\n                q.push(current->left);\n            }\n            else if (i < data.size() && data[i] == '#') \n            {\n                current->left = nullptr;\n            }\n            i++;\n\n            //创建右节点\n            if (i < data.size() && data[i] != '#') \n            {\n                current->left = new TreeNode(data[i] - '0');\n                q.push(current->right);\n            }\n            else if (i < data.size() && data[i] == '#') \n            {\n                current->right = nullptr;\n            }\n            i++;\n        }\n\n        return root;\n    }\n};\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser, deser;\n// TreeNode* ans = deser.deserialize(ser.serialize(root));\n半成品","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/18#issuecomment-2077635101","body":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),\n * right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    vector<tuple<int, int, int>> nodes;\n\npublic:\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        depth(root,0,0);\n        sort(nodes.begin(), nodes.end());\n\n        vector<vector<int>> res;\n        int lastcol = get<0>(nodes[0]);\n\n        for(auto it = nodes.begin(); it != nodes.end(); ++it)\n        {\n            if(get<0>(*it) == lastcol)\n            {\n                res.back().push_back(get<2>(*it));\n            }\n            else\n            {\n                lastcol = get<0>(*it);\n            }\n        }\n\n        return res;\n    }\n\n    void depth(TreeNode* root, int row, int col) {\n        // 递归的终止条件：当节点为空时\n        if (root == NULL) \n        {\n            return;\n        } \n        else \n        {\n            nodes.emplace_back(col, row, root->val);\n\n            depth(root->left, row + 1, col - 1);\n            depth(root->right, row + 1, col + 1);\n        }\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/20#issuecomment-2079566498","body":"### 题解思路：\n（1）双层遍历查找\n### 代码：\n```cpp\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        vector<int> res;\n        for(int i = 0; i < nums.size(); ++i)\n        {\n            for(int j = i+1; j < nums.size(); ++j)\n            {\n                if(nums[i] + nums[j] == target)\n                {\n                    res.push_back(i);\n                    res.push_back(j);\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n**复杂度分析**：\n- 时间复杂度：O(n^2)\n- 空间复杂度： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/21#issuecomment-2080573566","body":"### 题解思路：\n（1）使用哈希表存储数组nums中元素出现的频次；\n（2）因为unordered_map是无序的，因此将装换为可排序的vector<pair<int, int>>\n（3）降序排序，获取前k个；\n### 代码：\n```cpp\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int, int> cnt;\n        for (int i = 0; i < nums.size(); ++i) {\n            cnt[nums[i]]++;\n        }\n        // 转换成 vector<pair<int, int>>\n        vector<pair<int, int>> sorted_cnt(cnt.begin(), cnt.end());\n        // 按照第二个元素降序排序\n        sort(sorted_cnt.begin(), sorted_cnt.end(),\n             [](const pair<int, int>& a, const pair<int, int>& b) {\n                 return a.second > b.second;\n             });\n        vector<int> res;\n        for (int i = 0; i < k; ++i) {\n            res.push_back(sorted_cnt[i].first);\n        }\n        return res;\n    }\n};\n```\n**复杂度分析**：\n- 时间复杂度：O(nlogn)\n- 空间复杂度： O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/22#issuecomment-2081519911","body":"class Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        int n = points.size();\n        int ans = 0;\n\n        unordered_map<int, int> cnt;\n\n        for (int i = 0; i < n; i++) {\n            cnt.clear();\n            for (int j = 0; j < n; j++) {\n                if (i == j)\n                    continue;\n                int x = (points[i][0] - points[j][0]) *\n                        (points[i][0] - points[j][0]);\n                int y = (points[i][1] - points[j][1]) *\n                        (points[i][1] - points[j][1]);\n                cnt[x + y]++;\n            }\n            for (auto p : cnt) {\n                ans += p.second * (p.second - 1);\n            }\n        }\n\n        return ans;\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/23#issuecomment-2083077652","body":"### 题解思路：\n（1）创建哈希表储字符和其出现次数的映射，其中键为字符，值为该字符在当前滑动窗口中出现的次数。\n（2）使用两个值i和j来构建滑动窗口，其中i指向当前滑动窗口的起始位置，j用于遍历整个字符串。\n### 代码：\n```cpp\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        unordered_map<char, int> map;\n        int len = s.length();\n        int res = 0; // 最长字串长度\n        int i = 0;   // 滑动窗口起始位置\n        for (int j = 0; j < len; j++) \n        {\n            map[s[j]]++;\n            while (map[s[j]] > 1) \n            {\n                map[s[i++]]--;\n            }\n            res = res > j - i + 1 ? res : j - i + 1;\n        }\n        return res;\n    }\n};\n```\n**复杂度分析**：\n- 时间复杂度：O(n)\n- 空间复杂度： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/24#issuecomment-2085547119","body":"```cpp\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        vector<int> res;\n        int n1 = s.length(), n2 = words.size();\n        int len = words[0].length(); \n        if (n1 < n2 * len)\n            return res;\n        unordered_map<string, int> word1;\n        unordered_map<string, int> word2;\n        for (int i = 0; i < words.size(); i++) {\n            word1[words[i]]++;\n        }\n        int p = 0, q = p + n2 * len - 1, flag = 0;\n        while (q < n1) {\n            for (int i = p; i <= q; i += len) {\n                if (word1.find(s.substr(i, len)) != word1.end()) {\n                    word2[s.substr(i, len)]++;\n                    if (word2[s.substr(i, len)] > word1[s.substr(i, len)]) {\n                        flag = 1;\n                        break;\n                    }\n                } else {\n                    flag = 1;\n                    break;\n                }\n            }\n            if (!flag)\n                res.push_back(p);\n            p++;\n            q = p + n2 * len - 1;\n            word2.clear();\n            flag = 0;\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/25#issuecomment-2088650785","body":"class Solution {\npublic:\n    int minSubarray(vector<int>& nums, int p) {\n        unordered_map<int, int> map;\n        int deal = 0;\n        long sum = 0;\n        for (int i = 0; i < nums.size(); ++i) {\n            deal = (deal + nums[i]) % p;\n            sum += nums[i];\n            map[nums[i]]++;\n        }\n\n        if (sum < p) {\n            return -1;\n        }\n\n        if(deal == 0)\n        {\n            return 0;\n        }\n        int ret = minKeyCount(map, deal);\n\n        return ret;\n    }\n\n    int minKeyCount(unordered_map<int, int>& hashTable, int target) {\n        if(hashTable.size()==1)\n        {\n            if(hashTable.find(target)!= hashTable.end())\n            {\n                return 1;\n            }\n            else\n            {\n                return -1;\n            }\n        }\n\n        vector<int> dp(target + 1, INT_MAX);\n        dp[0] = 0;\n\n        for (const auto& kv : hashTable) {\n            int key = kv.first;\n            int value = kv.second;\n\n            for (int i = key; i <= target; ++i) {\n                if (dp[i - key] != INT_MAX) {\n                    dp[i] = min(dp[i], dp[i - key] + value);\n                }\n            }\n        }\n\n        return dp[target] == INT_MAX ? -1 : dp[target];\n    }\n};\n动态规划，但是还有问题。。","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/31#issuecomment-2098746249","body":"```cpp\nclass Solution {\npublic:\n    vector<vector<int>> g;\n    unordered_map<int, int> color;\n    bool dfs(int x, int c) {\n        if (color.count(x)) {\n            return color[x] == c;\n        }\n        color[x] = c;\n        for (auto& e : g[x]) {\n            if (false == dfs(e, -c)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        g.resize(n + 1);\n        for (auto& e : dislikes) {\n            int x = e[0];\n            int y = e[1];\n            g[x].push_back(y);\n            g[y].push_back(x);\n        }\n        for (int i = 1; i < n; ++i) {\n            if (!color.count(i)) {\n                if (false == dfs(i, 1))\n                    return false;\n            }\n        }\n        return true;\n    }\n};\n\n```\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/33#issuecomment-2102919628","body":"```cpp\nclass Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int nums_u = 0;\n        int nums_d = 0;\n        int nums_l = 0;\n        int nums_r = 0;\n        for (char c : moves) {\n            if (c == 'U') {\n                nums_u++;\n            } else if (c == 'D') {\n                nums_d++;\n            } else if (c == 'L') {\n                nums_l++;\n            } else if (c == 'R') {\n                nums_r++;\n            }\n        }\n        if (nums_u == nums_d && nums_l == nums_r) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n};\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/37#issuecomment-2107730822","body":"```cpp\nclass Solution {\npublic:\n    vector<int> sortArray(vector<int>& nums) {\n        int n = nums.size();\n        mergeSort(nums, 0, n - 1);\n        return nums;\n    }\n    // 归并排序\n    void mergeSort(vector<int>& nums, int left, int right) {\n        if (left < right) {\n            int mid = left + (right - left) / 2;\n            mergeSort(nums, left, mid);\n            mergeSort(nums, mid + 1, right);\n            merge(nums, left, mid, right);\n        }\n    }\n    // 合并两个有序数组\n    void merge(vector<int>& nums, int left, int mid, int right) {\n        int n1 = mid - left + 1;\n        int n2 = right - mid;\n        vector<int> L(n1), R(n2);\n        for (int i = 0; i < n1; ++i)\n            L[i] = nums[left + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = nums[mid + 1 + j];\n        int i = 0, j = 0, k = left;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                nums[k++] = L[i++];\n            } else {\n                nums[k++] = R[j++];\n            }\n        }\n        while (i < n1) {\n            nums[k++] = L[i++];\n        }\n        while (j < n2) {\n            nums[k++] = R[j++];\n        }\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/39#issuecomment-2112838984","body":"```cpp\n// The API isBadVersion is defined for you.\n// bool isBadVersion(int version);\nclass Solution {\npublic:\n    int firstBadVersion(int n) {\n        int left = 0, right = n,mid;\n        while ( left <right) \n        {\n            mid = left + (right -left)/2;\n            if(isBadVersion(mid)) \n                right = mid;\n            else\n                left = mid+1;\n        }\n        return left;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/46#issuecomment-2125130460","body":"```cpp\nclass Solution {\npublic:\n    vector<int> findAnagrams(string s, string p) {\n        int left = 0;\n        int right = 0;\n        vector<int> ans;\n        unordered_map<char, int> window;\n        unordered_map<char, int> need;\n        for (char c : p) need[c]++;\n        int cnt = 0;\n        while (right < s.size()) {\n            char r_char = s[right];\n            if (need.count(r_char)) {\n                window[r_char]++;\n                if (window[r_char] == need[r_char]) {\n                    cnt++;\n                }\n            }\n            if (right - left + 1 > p.size()) {\n                char l_char = s[left];\n                if (need.count(l_char)) {\n                    if (window[l_char] == need[l_char]) {\n                        cnt--;\n                    }\n                    window[l_char]--;\n                }\n                left++;\n            }\n            if (cnt == need.size()) {\n                ans.push_back(left);\n            }\n            right++;\n        }\n        return ans;\n    }\n};\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/51#issuecomment-2133584671","body":"```cpp\nclass Solution {\npublic:\n    typedef pair<int, int> PII;\n    int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};\n    int bfs(vector<vector<int>>& grid, vector<vector<bool>>& st, int x, int y) {\n        int area = 1;\n        queue<PII> q;\n        q.push({x, y});\n        while (!q.empty()) {\n            auto t = q.front();\n            q.pop();\n\n            for (int i = 0; i < 4; i++) {\n                int xi = t.first + dx[i];\n                int yi = t.second + dy[i];\n\n                if (xi < 0 || xi >= grid.size() || yi < 0 ||\n                    yi >= grid[0].size()) {\n                    continue;\n                }\n\n                if (!st[xi][yi] && grid[xi][yi] == 1) {\n                    area++;\n                    st[xi][yi] = true;\n                    q.push({xi, yi});\n                }\n            }\n        }\n        return area;\n    }\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n\n        vector<vector<bool>> st =\n            vector<vector<bool>>(n, vector<bool>(m, false));\n\n        int cnt = 0;\n        int max_area = 0;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (!st[i][j] && grid[i][j] == 1) {\n                    st[i][j] = true;\n                    cnt++;\n                    int area = bfs(grid, st, i, j);\n                    max_area = max(max_area, area);\n                }\n            }\n        }\n        if (cnt == 0)\n            return 0;\n        return max_area;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yanglimbo":[{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/1#issuecomment-2045612487","body":"补day1\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        // 注意！32位的int最大值2147483647，是十位数，题干说明数组长度最大为10^4\r\n        // 如果把数组转成整数计算，会出现溢出的问题\r\n        // 所以只能用数组计算\r\n        int len = num.size();\r\n        vector<int> rev = num;\r\n        reverse(rev.begin(),  rev.end());\r\n        int i = 0;\r\n        int a = k / 10;\r\n        int b = k % 10;\r\n        int sum = 0;\r\n        int extra = 0; // 进位\r\n        int x = 0;\r\n        vector<int> res;\r\n        do {\r\n            if(i <len){\r\n                x = rev[i];\r\n            }else{\r\n                x = 0;\r\n            }\r\n            sum = x + b + extra;\r\n            extra = sum / 10;\r\n            //printf(\"%d + %d = %d\\n\",rev[i],b, sum);\r\n            res.push_back(sum % 10);\r\n            i++;\r\n            k = a;\r\n            a = k / 10;\r\n            b = k % 10;\r\n           \r\n        } while (k != 0 || i < len || extra!= 0);\r\n\r\n\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n        \r\n    }\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/2#issuecomment-2045351587","body":"```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        // 只想出来两个循环嵌套的暴力\r\n        int len = s.size();\r\n        vector<int> ans(len, len-1);\r\n        auto absDiff = [](int a, int b) -> int{\r\n            if(a>b){\r\n                return a-b;\r\n            }\r\n            return b-a;\r\n        };\r\n        for(int i = 0; i < len; i++){\r\n            char elem = s[i];\r\n            if(elem == c){\r\n                ans[i] = 0;\r\n            }else{\r\n                for(int j = 0; j < len; j++){\r\n                    char temp = s[j];\r\n                    if(temp == c){\r\n                        ans[i] = min(ans[i], absDiff(i,j));\r\n                    }\r\n                }    \r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/3#issuecomment-2051799535","body":"```cpp\nclass CustomStack {\nprotected:\n    vector<int> m_customStack;\n    int m_pos = -1;\n    int m_maxSize = 1;\npublic:\n    CustomStack(int maxSize):m_customStack(maxSize),m_maxSize(maxSize) {\n    }\n\n    void push(int x) {\n        if(m_pos < m_maxSize - 1){\n            m_pos ++;\n            m_customStack[m_pos] = x;\n        }\n    }\n    \n    int pop() {\n        if(m_pos == -1){\n            return -1;\n        }\n        m_pos --;\n        return m_customStack[m_pos + 1];\n    }\n    \n    void increment(int k, int val) {\n        int increNum = 0;\n        if(m_pos + 1 < k ){\n            increNum = m_pos + 1;\n        }else{\n            increNum = k;\n        }\n        for(int i = 0;i < increNum;i++){\n            m_customStack[i] += val;\n        }\n    }\n};\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/4#issuecomment-2053689006","body":"写了一个没有用到栈的错误版本，不支持[]的嵌套，而且以字母结尾的情况也不支持。明天再看看提示重写吧。sad\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n        int len = s.size();\n        vector<int> repeats;\n        vector<string> patterns;\n        char c;\n        string repeat;\n        string pattern;\n        string ans;\n        for(int i = 0 ; i < len; i++){\n            c = s[i];\n            if(c >= '0' && c <= '9'){\n                // 也有可能是pattern记录结束\n                if(!pattern.empty()){\n                    repeats.push_back(1);\n                    patterns.push_back(pattern);\n                    pattern.clear();\n                }\n                repeat += c;\n            }else if(c == '['){\n                // 说明repeat记录完毕\n                repeats.push_back(stoi(repeat));\n                repeat.clear();\n            }else if(c == ']'){\n                // pattern记录完毕\n                patterns.push_back(pattern);\n                pattern.clear();\n            }else{\n                // 记录pattern\n                pattern += c;\n            }\n        }\n        for(int i = 0; i < repeats.size(); i++){\n            int num = repeats[i];\n            printf(\"%d\",num);\n            printf(\"%s\\n\",patterns[i].c_str());\n            for(int j = 0; j < num; j++){\n                ans += patterns[i];\n            }\n        }\n        return ans;\n    }\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/5#issuecomment-2066042728","body":"思路：用两个相反的栈，时间复杂度O(n)\n```cpp\nclass MyQueue {\n    \nprotected:\n    std::stack<int> stack;\n    std::stack<int> revStack;\n\npublic:\n    MyQueue() {\n    }\n    \n    void push(int x) {\n        stack.push(x); // stack的栈顶即队列末尾\n    }\n    \n    int pop() {\n        while(!stack.empty()){\n            revStack.push(stack.top());\n            stack.pop();\n        }// 弹出stack中的元素，进入revstack\n    \n        int ans = revStack.top(); // revstack的栈顶即队列开头\n        revStack.pop(); \n\n        while(!revStack.empty()){\n            stack.push(revStack.top());\n            revStack.pop();\n        }// 重新进入stack\n        return ans;\n    }\n    \n    int peek() {\n        while(!stack.empty()){\n            revStack.push(stack.top());\n            stack.pop();\n        }// 弹出stack中的元素，进入revstack\n\n        int ans = revStack.top(); // revstack的栈顶即队列开头\n        \n        while(!revStack.empty()){\n            stack.push(revStack.top());\n            revStack.pop();\n        }// 重新进入stack\n        return ans;\n    }\n    \n    bool empty() {\n        return stack.empty();\n    }\n};\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/6#issuecomment-2068058056","body":"哇塞，我自己想出来的……难我天\r\n然后发现自己的解法时间复杂度O(n^2)，最优解O(n)\r\n```cpp\r\nclass Solution {\r\n\r\npublic:\r\n    int maxChunkBeforeCursor(vector<int>& arr,int cursor){\r\n        if(cursor == -1){\r\n            return 0;\r\n        }\r\n        int cutter = cursor - 1;\r\n        int maxBefore = arr[0], minAfter = arr[cursor];\r\n        while(cutter >= 0){\r\n            for(int i = 0; i <= cutter; i++){\r\n                maxBefore = max(maxBefore,arr[i]);\r\n            }\r\n            for(int j = cursor; j> cutter; j--){\r\n                minAfter = min(minAfter, arr[j]);\r\n            }\r\n            //cout << \"cutter为 \" << cutter << \"此时maxbefore=\"<< maxBefore << \"此时minAfter=\" <<minAfter << endl;\r\n            if(maxBefore <= minAfter){\r\n                break;\r\n            }\r\n            maxBefore = arr[0];\r\n            minAfter = arr[cursor];// 重置maxbefore和minafter\r\n            cutter--;\r\n        }\r\n        //cout << \"在位置 \" << cutter << \" 处切割\";\r\n        return 1 + maxChunkBeforeCursor(arr,cutter);\r\n    }\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        // 理解一下题意，最少的块数肯定是1块，即直接进行升序排序。\r\n        // 分块需要满足的条件： 第i块的最大值 <= 第i+1块的最小值\r\n        // 思路：从最后一格切一刀，看看能不能>=前面那块的最大值，不能的话就把划分的刀往左推进一格\r\n        // 以此类推，分割成功后，再递归查看左边的数组能分成几块\r\n\r\n        return maxChunkBeforeCursor(arr, arr.size()-1);\r\n    }\r\n};\r\n```\r\n\r\n抄一下最优解，太牛了吧\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stk = []\r\n        for v in arr:\r\n            if not stk or v >= stk[-1]:\r\n                stk.append(v)\r\n            else:\r\n                mx = stk.pop()\r\n                while stk and stk[-1] > v:\r\n                    stk.pop()\r\n                stk.append(mx)\r\n        return len(stk)\r\n\r\n作者：ylb\r\n链接：https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/solutions/1888343/by-lcbin-dh6b/\r\n\r\n```\r\n代码解析\r\n初始化栈 stk： 栈用来存储每一块的最大值。这是因为我们在判断是否可以形成一个新的块时，需要确保当前块的最大值不大于后面块的最小值。\r\n\r\n遍历数组中的每个元素 v： 对于数组中的每个元素，我们需要决定是将其加入当前块，还是合并到前一个块中。\r\n\r\n判断条件：\r\n\r\n如果栈为空或者当前元素 v 大于等于栈顶元素： 这意味着当前元素可以开始一个新的块或者加入到当前的块中，因为它没有破坏块的有序性。因此，直接将其推入栈中。\r\n否则： 如果当前元素小于栈顶元素，说明当前元素不能单独形成一个块，并且它也不能简单地加入到当前块中，因为它会破坏已有块的有序性。此时，我们需要将当前块与前面的块进行合并，直到找到一个块的最大值不大于当前元素。这个过程中，我们不断弹出栈顶元素，并保留遇到的最大值，直到栈顶元素小于等于当前元素。然后将这个保留的最大值重新推回栈中。\r\n返回结果： 最后，栈的大小就是可以形成的块的最大数量。每个栈元素代表一个块的最大值。","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/7#issuecomment-2104765157","body":"```cpp\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        //我的思路，先走到头看看有多长（应该没有环吧？）记为n\n        // 然后获取k % n，其中一个走n-k%n步，让它屁股后面断开，末尾连这里。最后返回那一步后面的指针\n        if(head == nullptr){\n            return nullptr;\n        }\n        \n        ListNode* lastNode = head;\n        int n = 1;\n        while(lastNode->next!= nullptr){\n            lastNode = lastNode->next;\n            n++;\n        }\n        ListNode* node = head;\n        for(int i = 1; i < n-k%n; i++){\n            node = node->next;\n        }\n        if(node->next == nullptr){\n            //刚好转了整圈数\n            return head;\n        }else{\n            ListNode* newHead = node->next;\n            node->next = nullptr;\n            lastNode->next = head;\n            return newHead;\n        }\n        \n    }\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/8#issuecomment-2057189370","body":"## 递归，每次处理完一对节点，把后面的作为整体进行处理\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        // 递归\n        if(head == nullptr){\n            return nullptr;\n        }\n        if(head->next == nullptr){\n        //单数,最后一个元素\n            return head;\n        }\n        ListNode* first = head;\n        ListNode* second = head->next;\n\n        first->next = swapPairs(second->next);\n        second->next = first;\n        return second;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/9#issuecomment-2059279831","body":"已经忘了平衡二叉树的旋转知识点了，这里用标准思路，即利用链表不断从中间分开构成树\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        // 改天再学avl tree，现在先用推荐的思路，即寻找中点，递归构造树节点\r\n        // 注意为了防止无限递归，断开链表\r\n        if(head == nullptr){\r\n            return nullptr;\r\n        }else if(head->next == nullptr){\r\n            TreeNode* node = new TreeNode(head->val);\r\n            // 这个有没有内存问题？\r\n            return node;\r\n        }\r\n\r\n        // 快慢指针法（龟兔赛跑）寻找链表中点，作为树节点的根部\r\n        ListNode* fast = head;\r\n        ListNode *slow = head;// 注意，ListNode* fast, *slow = head;只会给后者赋值，是错误的\r\n        ListNode* prev = nullptr;\r\n        \r\n        while(fast!=nullptr && fast->next!=nullptr){\r\n            /*确保两件事：\r\n            fast 指针不是 nullptr，即它确实指向了一个有效的链表节点。\r\n            fast->next 也不是 nullptr，这意味着 fast 指针所指向的节点后面至少还有一个节点。\r\n            */\r\n            prev = slow;\r\n            fast = fast->next->next;\r\n            slow = slow->next;\r\n        }\r\n        \r\n        //断开链表\r\n        if(prev!=nullptr){\r\n            prev->next = nullptr;\r\n        } // 这一步if是必要的，否则会出现尝试访问 prev->next 失败，程序崩溃\r\n        \r\n        TreeNode* root = new TreeNode(slow->val);\r\n        root->left = sortedListToBST(head);\r\n        root->right = sortedListToBST(slow->next);\r\n        return root;\r\n    }\r\n};\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/10#issuecomment-2061128740","body":"```cpp\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        // 方法1：暴力，对于每一个list A的节点，遍历list B 并比较 过程略\n\n        // 自己想的：计算链表，长度相减，长的那个先走差值步数，然后一起走，比对。灵感来源昨天遇到的快慢指针\n\n        ListNode* ptrA = headA;\n        ListNode* ptrB = headB;\n\n        // 已知链表A B均不为空 m为链表A长度，n为链表B长度\n        int m = 1, n = 1; \n        \n        while(ptrA->next!=nullptr){\n            ptrA = ptrA->next;\n            m++;\n        }\n        while(ptrB->next!=nullptr){\n            ptrB = ptrB->next;\n            n++;\n        }\n        \n        // 使用快慢指针，链表长的那一方先走abs(m-n)步\n        int distance = abs(m-n);\n        ptrA =headA;\n        ptrB = headB;\n        if(m>n){\n            while(distance>0){\n                ptrA = ptrA->next;\n                distance--;\n            }\n        }else{\n            while(distance>0){\n                ptrB = ptrB->next;\n                distance--;\n            }\n        }\n\n        \n        if(ptrA == ptrB){\n            return ptrA;// 相同的链表\n        }\n        ListNode* ans = nullptr;\n        while(ptrA->next!=nullptr){\n            if(ptrA->next == ptrB->next){\n                ans = ptrA->next;\n                break;\n            }\n            ptrA = ptrA->next;\n            ptrB = ptrB->next;\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/11#issuecomment-2064631779","body":"一开始用了笨办法，先快慢指针确定有环，再写了两层嵌套的循环，结果结果出错不知道为什么，找漏洞失败。\n最后重新回归快慢指针，再次使用快慢指针找到交叉点。\n```cpp\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        // 不知道节点可不可以指向自己，我这里按照不能做的\n        // 先判断链表是否有环；如果有环，交叉点必然在head和slow中间\n        if(head == nullptr || head->next == nullptr){\n            return nullptr;\n        }\n        ListNode* fast = head;\n        ListNode* slow = head;\n        int flag = 0;\n        while(fast!=nullptr && fast->next != nullptr){\n            fast = fast->next->next;\n            slow = slow->next;\n            if(fast == slow){\n                flag = 1;\n                break;\n            }\n        }\n        if(flag == 0){\n            return nullptr;\n        }\n        // 当flag=1，有环，此时快指针走了2s距离，慢指针走了s距离，相遇点出发走到相遇点为s\n        // 画一个示意图，设head到交叉处距离为x，则交叉处到相遇点为s-x,相遇点再走到交叉处为s-(s-x)=x\n        // 所以，从head到交叉点的距离=x=相遇点到交叉点的距离\n        ListNode* ptr = head;\n        while(1){\n            if(ptr == slow){\n                break;\n            }\n            ptr = ptr->next;\n            slow = slow->next;\n        }\n        return ptr;\n    }\n};\n```","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/13#issuecomment-2067715439","body":"```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root == nullptr){\n            return 0;\n        }\n        int leftDepth = root->left == nullptr ? 0 : maxDepth(root->left);\n        int rightDepth = root->right == nullptr ? 0 : maxDepth(root->right);\n        return max(leftDepth,rightDepth) +1;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/14#issuecomment-2067718339","body":"感觉我的思路可能不是最简洁的？\n```cpp\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(p == nullptr || q == nullptr){\n            return p == q;\n        }\n        bool valueSame = p->val == q->val;\n        return valueSame && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n    }\n};\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/15#issuecomment-2069868575","body":"用了遍历的方法 在叶节点结算\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprotected:\n    int _sum = 0;\npublic:\n    void findLeafAndSumUp(TreeNode* root, int prev){\n        if(root->left == nullptr && root->right == nullptr){\n            // is leaf\n            _sum += prev*10 + root->val;\n            return;\n        }\n\n        if(root->left != nullptr){\n            findLeafAndSumUp(root->left, prev*10 + root->val);\n        }\n        if(root->right != nullptr){\n            findLeafAndSumUp(root->right, prev*10 + root->val);\n        }\n       \n        \n        return;\n    }\n    int sumNumbers(TreeNode* root) {\n        findLeafAndSumUp(root,0);\n        return _sum;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/16#issuecomment-2076851288","body":"```cpp 前序遍历 \nclass Solution {\n    protected:\n    int _value;\n    int _depth = -1;\npublic:\n    void preorderTraverse(TreeNode*root, int depth){\n        \n        if(depth > _depth){\n            _value = root->val;\n            _depth = depth;\n        }\n        if(root->left != nullptr){\n            preorderTraverse(root->left, depth +1);\n        }\n        if(root->right != nullptr){\n            preorderTraverse(root->right, depth +1);\n        }\n\n    }\n\n    int findBottomLeftValue(TreeNode* root) {\n        // 前序遍历，先遍历左子树再找右子树，，这样一来顺序就一定是从左到右\n        // 最终的结果不一定是左子叶节点也可能是右\n        // 从左到右的过程中比较叶节点的深度，如果深度>之前的进行替换，否则不替换\n        preorderTraverse(root, 0);\n        return _value;\n    }\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/17#issuecomment-2077033949","body":"```cpp\n//#include <queue>\nclass Codec {\npublic:\n\n    // use BFS level-order traverse 使用队列的层序遍历（属于bfs）\n    \n    // 写了一堆发现没有办法处理\"null\"转化为int的情况，这里试试看能不能用C++17的std::nullopt来表示，勉强解决一下。。\n    string intVectorToString(vector<std::optional<int>>& v){\n        string s;\n        for(int i = 0; i<v.size();i++){\n            if(v.at(i).has_value()){\n                s+= to_string(v.at(i).value());\n            }else{\n                s+= \"null\";\n            }\n            if(i!=v.size()-1){\n                s+=\",\";\n            } \n        }\n        //cout << \"string is \" << s << endl;\n        return s;\n    }\n\n    vector<std::optional<int>> stringToIntVector(string s){\n        size_t start = 0, pos = 0;\n        vector<std::optional<int>> v;\n        do{\n            pos = s.find(\",\",start);\n            if(pos == string::npos){\n                // 找不到splitter了\n                pos = s.length();\n            }\n            string token = s.substr(start, pos-start);\n            if(token == \"null\"){\n                v.push_back(std::nullopt);\n            }else{\n                v.push_back(stoi(token));\n            }\n            start = pos+1;\n        }while(pos < s.length());\n        /*\n            C++查找子字符串:\n            size_t find(const std::string& str, size_t pos = 0) const;\n            在调用者字符串中从索引 pos 开始搜索子字符串 str。\n        */\n        return v;\n    }\n\n// Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        if(root == nullptr){\n            return \"null\";\n        }\n        vector<std::optional<int>> v;\n        queue<TreeNode*> q;\n        q.push(root);\n        TreeNode* node; // current node\n        while(!q.empty()){\n            node = q.front();\n            q.pop();\n            if(node == nullptr){\n                v.push_back(std::nullopt);\n            }else{\n                v.push_back(node->val);\n                q.push(node->left);\n                q.push(node->right);\n            }\n        }\n        //Remove trailing None values to minimize data size\n        // 因为有存在结尾好几个null的情况，可以考虑去除掉结尾倒数的连续的null，这样就符合leetcode的模式了~\n\n        return intVectorToString(v);\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        if(data == \"null\"){\n            return nullptr;\n        }\n        vector<std::optional<int>> v = stringToIntVector(data);\n        \n        queue<TreeNode*> q;\n        TreeNode* root = new TreeNode(v.at(0).value());\n        q.push(root);\n        TreeNode* node; // current node\n        int i = 1;\n        while(!q.empty() && i < v.size()){\n            node = q.front();\n            q.pop();\n            if(v.at(i).has_value()){\n                node->left = new TreeNode(v.at(i).value());\n                q.push(node->left);\n            }\n            i++;\n            if(v.at(i).has_value() && i < v.size()){ // 注意这里要小心过界\n                node->right = new TreeNode(v.at(i).value());\n                q.push(node->right);\n            }\n            i++;\n        }\n        return root;\n    }\n};\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser, deser;\n// TreeNode* ans = deser.deserialize(ser.serialize(root));\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/18#issuecomment-2080464294","body":"我写得好麻烦。。\n```cpp\nclass Solution {\npublic:\n    vector<pair<pair<int,int>,int >> nodes;\npublic:\n    void traverse(TreeNode* root, int x, int y){\n        nodes.push_back({{x,y},root->val});\n        if(root->left != nullptr){\n            traverse(root->left, x-1,y+1);\n        }\n        if(root->right != nullptr){\n            traverse(root->right, x+1,y+1);\n        }\n        return;\n    }\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        // 思路：先traverse并记录坐标，再根据坐标排序。不过我的横纵坐标不是题目描述里的，\n        // 我是先x再y，x为横坐标y为纵坐标，从左到右从上到下从小到大\n        traverse(root, 0,0);\n        \n        map<int, vector<pair<int,int>>> columns; // (x, (y,val))\n        for(auto& node: nodes){\n            auto& col = node.first.first; // x值\n            if(columns.find(col)!=columns.end()){\n                columns.at(col).push_back({node.first.second, node.second});\n            }else{\n                columns[col] = {{node.first.second, node.second}};\n            }\n        }\n        for(auto& column: columns){\n            auto& v = column.second;\n            sort(v.begin(),v.end(),[](const pair<int,int>& a, const pair<int,int>& b){\n                return a.first < b.first? true : (a.first == b.first ?(a.second < b.second) :false);\n            });\n        }\n        vector<vector<int>> result;\n        for(auto& column: columns){\n            auto pairs = column.second;\n            vector<int> temp(pairs.size());\n            transform(pairs.begin(),pairs.end(),temp.begin(),[](const pair<int,int>& a)\n            {\n                return a.second;\n            });\n            result.push_back(temp);\n        }\n\n        return result;\n    }\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/20#issuecomment-2105852346","body":"思路 就正常的两个for循环。\n```cpp\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        int n = nums.size();\n        for(int i = 0; i<n;i++){\n            for(int j = i+1; j < n; j ++){\n                if(nums[i] + nums[j] == target){\n                    return vector<int>({i,j});\n                }\n            }\n        }\n        return vector<int>();\n    }\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/21#issuecomment-2080451124","body":"懒惰的map写法，键值对储存完再根据value排序。\n\n```cpp\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        std::map<int,int> freqMap;\n        for(auto& num : nums){\n            if(freqMap.find(num)!=freqMap.end()){\n                freqMap[num] = freqMap[num]+1; // 这里能不能用++\n            }else{\n                freqMap[num] = 1;\n            }\n        }\n        vector<pair<int,int>> compVec(freqMap.begin(),freqMap.end());\n        sort(compVec.begin(),compVec.end(),[](const pair<int,int>& a, const pair<int,int>& b){\n            return a.second > b.second;\n        });\n        \n        vector<int> ans(k);\n        std::transform(compVec.begin(),compVec.begin()+k, ans.begin(), \n        [](const pair<int,int> p){\n            return p.first; // 返回key\n            /*\n            std::transform 是 C++ 标准库中的一个非常有用的算法，它属于 <algorithm> 头文件。\n            这个函数通常用于将一个函数或操作应用于一个输入范围的元素，并将结果存储到另一个输出\n            范围。它非常适合进行元素级的转换和操作。\n            这里右边不会取到compVec.begin()+k\n\n            在 C++ 中，std::transform 不会自动调整输出容器的大小。它假设输出容器已经有足够的\n            空间来存放所有的结果。如果输出容器的大小不足以存放所有结果，那么 std::transform\n            会覆盖容器末尾之外的内存，这可能导致运行时错误，如内存访问违规（segmentation \n            fault）或其他形式的崩溃。所以这里ans必须初始化\n            */\n        });\n\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/22#issuecomment-2105931061","body":"旧思路：三层嵌套，超时了。实际上得到了具体的哪些点的信息，但这些信息是冗余的，并不需要知道具体是哪些点可以组成元组\n新思路：对于每个点（作为回旋镖boomerang的中间点，三元组之首项），维护一个哈希表（unorderedmap即可），计算每一种距离出现的次数k，即距离相同的点的数目，则回旋镖的另外两个点组成的对子有k*(k-1)个，每个不同的距离所对应的对子数加起来即是这个点产生的回旋镖数目。\n所有点的回旋镖数目加起来就是结果\n这样，我们并没有存储具体哪些点产生的元组，我们只关心了不同距离的重复次数，获取到的信息少了，时间也节约了，没有浪费在遍历每一种元组之上。\n```cpp\nclass Solution {\npublic:\n    int distanceSquare(vector<int>& a, vector<int>& b){\n        //return pow( a[0]-b[0],2) +  pow( a[1] -b[1],2);\n        return ( a[0]-b[0])* (a[0]-b[0]) + (a[1] -b[1])*(a[1] -b[1]);// 比Pow函数更快\n    }\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        int n = points.size(); // n 个点\n        int count = 0;\n        // vector<vector<int>> matrix(n,vector<int>(n,0));\n        // for(int i = 0; i < n; i++){\n        //     for(int j = i+1; j < n;j++){\n        //         matrix[i][j] = distanceSquare(points[i], points[j]);\n        //     }\n        // }\n        // auto getDistance = [&matrix](int a, int b){\n        //     if(a<b){\n        //         return matrix[a][b];\n        //     }else{\n        //         return matrix[b][a];\n        //     }\n        // };\n        // for(int i = 0; i < n; i ++){\n        //     for(int j = 0; j <n;j++){\n        //         if(i == j){\n        //             continue;\n        //         }\n        //         for(int k = 0;k<n;k++){\n        //             if( i == k || j == k){\n        //                 continue;\n        //             }\n        //             if(getDistance(i, j) == getDistance(i, k)){\n        //                 count++;\n        //             }\n        //         }\n        //     }\n        // }\n        // return count;\n        // 问题：在于三层循环，时间太长，超出限制\n        /*\n        gpt给出优化方法:使用哈希表维护距离，记录每个距离出现的次数\n        某个距离出现了k次则可以产生k*(k-1)个回旋镖\n        */\n        // 对于每一个点i，也就是三元组的头一个领袖，都维护一个新的哈希表，计算i与其他点的距离以及出现的次数\n        for(int i = 0; i < n ;i++){\n            unordered_map<int, int> distanceCount;\n            int k = 0;\n            for(int j = 0;j<n;j++){\n                if(i==j){\n                    continue;\n                }\n                distanceCount[distanceSquare(points[i],points[j])]++;\n                /*\n                在 C++ 中，当你使用 std::unordered_map 并尝试通过键访问值时，如果该键不存在，unordered_map 会自动创建该\n                键，并将其值初始化为该值类型的默认值。对于基本数据类型如 int，默认值是 0。\n                所以这里不用担心\n                */\n            }\n            // 对每个距离，计算可以形成的回旋镖数量\n            for(auto distancePair: distanceCount){\n                int k = distancePair.second;\n                if(k>1)\n                count += k*(k-1);\n            }\n            /*\n            gpt说这里最好判断一下k>1，我认为不判断也可以运行，而且判断也需要消耗资源，gpt这么回答\n            计算与判断的成本比较\n计算成本：在不进行 k > 1 的判断的情况下，你会执行所有的乘法和加法操作，即使它们的结果是 0。这不仅涉及数学运算，\n还可能涉及对内存中 count 变量的不必要更新。当数据集很大时，这些无用的计算会累积成显著的性能损失。\n\n判断成本：if 语句的成本相对较低，尤其是在现代处理器上，分支预测和流水线技术可以极大地减少条件分支的开销。\n此外，if 语句的成本通常远低于涉及算术运算和可能的内存访问的成本。\n\n\n我来记录一下：\n不写if(k>1)时，执行用时358ms，371ms,364ms,试验了几次都不一样，内存124.63，124.64,124.70MB\n写if(k>1)时，执行用时343ms,350ms,359ms内存124.56MB,124.63MB,124.67MB\ngpt是对的，真的更节省，有微妙的区别。但区别也不大\n\n\n            */\n        }\n        return count;\n    }\n};\n```","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rao-qianlin":[{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/1#issuecomment-2045464036","body":"* 思路：按位进行运算，相加大于10，则进位。\n\n```java\nimport java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] arr = new int[n];\n        for(int i = 0; i < n; i++){\n            arr[i] = scanner.nextInt();\n        }\n\n        int k = scanner.nextInt();\n        int mid;\n\n        for(int i = n-1; i >=0 ; i--){\n            if((int)arr[i] + k >= 10){\n                mid = (arr[i] + k)/10;\n                arr[i] = arr[i] + k - 10 * mid;\n                k = mid;\n            }\n            else{\n                arr[i] = arr[i] + k;\n                k = 0;\n            }\n        }\n        if(k!=0){\n            System.out.println(k+\" \");\n        }\n\n        for(int i = 0; i < arr.length; i++){\n            System.out.println(arr[i]+\" \");\n        }\n    }\n}\n```\n\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/2#issuecomment-2045501831","body":"* 思路：正向反向遍历两次，取距离的最小值\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        char[] sc = s.toCharArray();\n        int count = -1;\n        int[] de = new int[sc.length];\n        // 正向遍历计算一次值\n        for(int i=0; i<sc.length; i++){\n            if(sc[i] ==c){\n                count = i;\n            }\n            if(count == -1){\n                // 表示还没有遇到第一个c\n                de[i] = sc.length;\n            }\n            else{\n                de[i] = i-count;\n            }\n        }\n        count = -1;\n        // 反向遍历计算一次值\n        for(int i=sc.length-1; i>=0; i--){\n            if(sc[i] == c){\n                count = i;\n            }\n            if(count != -1){\n                de[i] = Math.min(count-i,de[i]);\n            }\n        }\n        return de;\n    }\n}\n```\n\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/5#issuecomment-2052019645","body":"```java\nclass MyQueue {\n    private Stack<Integer> s1, s2;\n\n    public MyQueue() {\n        s1 = new Stack<>();\n        s2 = new Stack<>();\n    }\n    \n    public void push(int x) {\n        s1.push(x);\n\n    }\n    \n    public int pop() {\n        if(s2.isEmpty()){\n            while(!s1.isEmpty()){\n                s2.push(s1.pop());\n            }\n        }\n        return s2.pop();\n    }\n    \n    public int peek() {\n        if(s2.isEmpty()){\n            while(!s1.isEmpty()){\n                s2.push(s1.pop());\n            }\n        }\n        return s2.peek();\n    }\n    \n    public boolean empty() {\n        return s1.isEmpty() && s2.isEmpty();\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/7#issuecomment-2054081351","body":"``` java \nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null) {\n            return head;\n        }\n\n        ListNode end = head;\n        int len = 1;\n\n        while (end.next != null) {\n            end = end.next;\n            len += 1;\n        }\n        // return new ListNode(len);\n        // end 位于链表尾部 len为链表长度\n        // 连接形成环形链表\n\n        end.next = head;\n        // 处理k，如果k大于len，则减去len\n        while (k >= len) {\n            k -= len;\n        }\n        if (k == 0) {\n            // 不进行旋转\n            end.next = null;\n        } else {\n            // 找到链表第 len-k 个节点，就是新的尾结点\n            ListNode pre = head;\n            for (int i = 0; i < len - k - 1; i++) {\n                pre = pre.next;\n            }\n            // pre.next 就是新的头结点；\n            head = pre.next;\n            // 断开环\n            pre.next = null;\n\n        }\n\n        return head;\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/8#issuecomment-2059453315","body":"```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        // 空链表、只有一个元素的链表不用交换\n        if(head == null || head.next == null){\n            return head;\n        }\n\n        ListNode temph = new ListNode(0);\n        temph.next = head;\n        ListNode slow = temph;\n        ListNode fast = temph.next.next;\n\n        while(fast.next != null && fast.next.next != null){\n            ListNode temp = fast.next;\n            fast.next = slow.next;\n            slow.next = fast;\n            fast = fast.next;\n            fast.next = temp;\n\n            slow = slow.next.next;\n            fast = fast.next.next;\n        }\n        if(fast.next == null){\n            fast.next = slow.next;\n            slow.next = fast;\n            fast = fast.next;\n            fast.next = null;\n        }\n        else if(fast.next.next == null){\n            ListNode temp = fast.next;\n            fast.next = slow.next;\n            slow.next = fast;\n            fast = fast.next;\n            fast.next = temp;\n        }\n        return temph.next;\n    }\n}\n```\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/9#issuecomment-2059372486","body":"思路：\n递归构造子树，每次找到链表中点作为根节点\n使用快慢指针找到链表中点\n```Java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null){\n            return null;\n        }\n        return toTree(head, null);\n    }\n    private  TreeNode toTree(ListNode start, ListNode end){\n        if(start == end){\n            return null;\n        }\n        ListNode slow = start;\n        ListNode fast = start;\n        while(fast != end && fast.next != end){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        root.left = toTree( start, slow);\n        root.right = toTree( slow.next, end);\n        return root;\n    }\n}\n```\n时间复杂度 O(N*logN)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/10#issuecomment-2059471150","body":"思路：使用双指针\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if( headA == null || headB == null){\n            return null;\n        }\n        ListNode pa = headA;\n        ListNode pb = headB;\n        while(pa!=pb){\n            if(pa == null){\n                pa = headB;\n            }\n            else{\n                pa = pa.next;\n            }\n            if(pb == null){\n                pb = headA;\n            }\n            else{\n                pb = pb.next;\n            }\n        }\n        return pa;\n        \n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/11#issuecomment-2064370862","body":"思路：使用快慢双指针。\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head == null){\n            return null;\n        }\n\n        ListNode slow = head;\n        ListNode fast = head;\n\n        while(fast.next != null && fast.next.next != null){\n            slow = slow.next;\n            fast = fast.next.next;\n            if(slow == fast){\n                ListNode temp = head;\n                // int i = 0;\n                while(temp != slow){\n                    temp = temp.next;\n                    slow = slow.next;\n                    // i = i+1;\n                }\n                return temp;\n            }\n        }\n\n        return null;\n    }\n}\n```\n时间复杂度 O(N)","onTime":false},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/20#issuecomment-2078550547","body":"## 思路\n两次遍历，遇到满足条件的两个元素，直接返回下标结果。\n## 代码\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int[] re = new int[2];\n        for(int i=0; i< nums.length; i++){\n            for(int j=i+1; j<nums.length; j++){\n                if(nums[i]+nums[j]==target){\n                    re[0]=i;\n                    re[1]=j;\n                    return re;\n                }\n            }\n        }\n        return re;\n    }\n}\n```\n## 复杂度\n时间$ O(N^2)$ 空间 $ O(1)$ ","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/23#issuecomment-2081772450","body":"## 思路\n使用滑动窗口\n\n## 代码\n``` java\n\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int minLength = Integer.MIN_VALUE;\n        char[] sc = s.toCharArray();\n\n        int left = 0;\n        int right = 0;\n\n        HashMap<Character,Integer> window = new HashMap<>();\n\n        while(right < sc.length){\n            char c = sc[right];\n            right ++;\n            window.put(c, window.getOrDefault(c, 0) + 1);\n            while(window.get(c)>1){\n                char l = sc[left];\n                left ++;\n                window.put(l, window.get(l) - 1);\n            }\n            minLength = Math.max(minLength, right - left);\n            \n        }\n        if(minLength == Integer.MIN_VALUE){\n            return 0;\n        }\n        else{\n            return minLength;\n        }\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/26#issuecomment-2090345573","body":"## 思路：使用快慢指针\n## 代码：\n```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast!=null && fast.next!=null){\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n\n    }\n}\n```\n## 复杂度\n时间复杂度 O(N) 空间复杂度 不使用额外空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/27#issuecomment-2092376359","body":"## 思路：使用双指针\n## 代码：\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int i = 0;\n        int j = 0;\n\n        while(j < nums.length){\n            if(nums[i] == nums[j]){\n                j ++;\n            }\n            else{\n                i ++;\n                nums[i] = nums[j];\n                j ++;\n            }\n        }\n        return i+1;\n\n    }\n}\n```\n\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/34#issuecomment-2104814339","body":"class Solution {\n    public int[] getOrder(int[][] tasks) {\n        int[][] tt = new int[tasks.length][3];\n        for (int i = 0; i < tasks.length; ++i) {\n            tt[i][0] = tasks[i][0];\n            tt[i][1] = tasks[i][1];\n            tt[i][2] = i;\n        }\n        Arrays.sort(tt, (a, b) -> a[0] - b[0]);\n        PriorityQueue<int[]> q = new PriorityQueue<>((a, b) -> a[1] == b[1] ? a[2] - b[2] : a[1] - b[1]);\n\n        int curTime = Integer.MIN_VALUE;\n        int p = 0;\n        int[] res = new int[tt.length];\n\n        for (int i = 0; i < tt.length; ++i) {\n            while (p < tt.length && (tt[p][0] <= curTime || q.isEmpty())) {\n                curTime = Math.max(tt[p][0], curTime);\n                q.offer(tt[p]);\n                p++;\n            }\n            int[] t = q.poll();\n            curTime = curTime + t[1];\n            res[i] = t[2];\n           \n        }\n        return res;\n    }\n}","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/38#issuecomment-2109753550","body":"## 思路 \n二分查找 \n需要注意溢出问题\n\n## 代码\n```java\nclass Solution {\n    public int mySqrt(int x) {\n        if(x==0 || x==1){\n            return x;\n        }\n\n        int left = 1;\n        int right = x/2;\n\n        while(left < right){\n            int mid = left + (right - left + 1) / 2;\n            if( mid > x/mid){\n                right = mid -1;\n            }else{\n                left = mid;\n            }\n        }\n\n        return left;\n\n    }\n}\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/44#issuecomment-2119529259","body":"## 思路\n使用滑动窗口的方法\n## 代码\nclass Solution {\n    public int maxVowels(String s, int k) {\n        int sum = 0;\n        int start = 1;\n        int end = k;\n        \n        char[] sc = s.toCharArray () ;\n        int len = sc.length;\n        for (int i = 0 ; i< k  ; i++){\n            if (sc[i]=='a' || sc[i]=='e' ||sc[i]=='i' ||sc[i]=='o' ||sc[i]=='u'){\n                sum += 1;\n            }\n        }\n        int max = sum;\n        while(end <= sc.length-1){\n            if (sc[start-1]=='a' || sc[start-1]=='e' ||sc[start-1]=='i' ||sc[start-1]=='o' ||sc[start-1]=='u'){\n                sum -= 1;\n            }\n            if (sc[end]=='a' || sc[end]=='e' ||sc[end]=='i' ||sc[end]=='o' ||sc[end]=='u'){\n                sum += 1;\n            }\n            if(sum > max){\n                max = sum;\n            }\n            start += 1;\n            end += 1;\n        }\n\n        return max ;\n\n    }\n}","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/51#issuecomment-2132558827","body":"```java\nclass Solution {\n    int maxAreaOfIsland(int[][] grid) {\n        int res = 0;\n        int m = grid.length, n = grid[0].length;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    res = Math.max(res, dfs(grid, i, j));\n                }\n            }\n        }\n        return res;\n    }\n\n    int dfs(int[][] grid, int i, int j) {\n        int m = grid.length, n = grid[0].length;\n        if (i < 0 || j < 0 || i >= m || j >= n) {\n            return 0;\n        }\n        if (grid[i][j] == 0) {\n            return 0;\n        }\n        grid[i][j] = 0;\n\n        return dfs(grid, i + 1, j)\n            + dfs(grid, i, j + 1)\n            + dfs(grid, i - 1, j)\n            + dfs(grid, i, j - 1) + 1;\n    }\n}\n\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/58#issuecomment-2144209797","body":"## 思路：\n动态规划 使用备忘录提升时间效率\n## 代码：\n```java\nclass Solution {\n    int[][] memo;\n\n    public int longestCommonSubsequence(String s1, String s2) {\n        int m = s1.length(), n = s2.length();\n        memo = new int[m][n];\n        for (int[] row : memo) \n            Arrays.fill(row, -1);\n        return dp(s1, 0, s2, 0);\n    }\n\n\n    int dp(String s1, int i, String s2, int j) {\n        // base case\n        if (i == s1.length() || j == s2.length()) {\n            return 0;\n        }\n        if (memo[i][j] != -1) {\n            return memo[i][j];\n        }\n        if (s1.charAt(i) == s2.charAt(j)) {\n            memo[i][j] = 1 + dp(s1, i + 1, s2, j + 1);\n        } else {\n            memo[i][j] = Math.max(\n                dp(s1, i + 1, s2, j),\n                dp(s1, i, s2, j + 1)\n            );\n        }\n        return memo[i][j];\n    }\n}\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/64#issuecomment-2156661727","body":"## 思路\n使用动态规划\n## 代码\n```java\nclass Solution {\n    public int coinChange(int[] coins, int amount) {\n        if(amount < 0){\n            return -1;\n        }\n        int[] dp = new int[amount+1];\n        dp[0]=0;\n        for(int i=1; i<= amount; i++){\n            dp[i] = -1;\n        }\n        \n        int res = 1000;\n        for(int i=0; i<amount+1; i++){\n            for(int j=0; j<coins.length; j++){\n                if(i-coins[j]>=0){\n                    if(dp[i-coins[j]] != -1){\n                        res = dp[i-coins[j]] + 1;\n                        if(dp[i]==-1 || res<dp[i]){\n                            dp[i] = res;\n                        }\n                    }\n                }\n            }\n        }\n        return dp[amount];\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dtjk":[null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/3#issuecomment-2045781953","body":"```c++\nclass CustomStack {\npublic:\n    int ssize;\n    stack<int> ss;\n    CustomStack(int maxSize) {\n        ssize = maxSize;\n    }\n    \n    void push(int x) {\n        if (ss.size() < ssize) ss.push(x);\n    }\n    \n    int pop() {\n         if(!ss.empty()) {\n            int res = ss.top();\n            ss.pop();\n            return res;\n         }\n         else return -1;\n    }\n    \n    void increment(int k, int val) {\n         stack<int> ss2;\n         while (!ss.empty()){\n            ss2.push(ss.top());\n            ss.pop();\n         }\n         int sum = 0;\n         while(!ss2.empty()){\n            sum++;\n            if (sum <= k) ss.push(ss2.top() + val);\n            else ss.push(ss2.top());\n            ss2.pop();\n         }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/4#issuecomment-2049933805","body":"```\nclass Solution {\npublic:\n    string decodeString(string s) {\n    stack<int> numStack;\n    stack<string> resStack;\n    int num = 0;\n    string res;\n    for (int i = 0; i < s.size(); i++) {\n        if (isalpha(s[i])) {\n            res.push_back(s[i]);\n        } else if (isdigit(s[i])) {\n            num = num * 10 + s[i] - '0';\n        } else if (s[i] == '[') {\n            resStack.push(res);\n            res = \"\";\n            numStack.push(num);\n            num = 0;\n        } else {\n            for (int j = 0; j < numStack.top(); j++) {\n                resStack.top() += res;\n            }\n            numStack.pop();\n            res = resStack.top();\n            resStack.pop();\n        }\n    }\n    return res;\n}\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/5#issuecomment-2052019308","body":"```\nclass MyQueue {\nprivate:\n    std::stack<int> q1,q2;\npublic:\n    MyQueue() {}\n    \n    void push(int x) {\n        q1.push(x);\n    }\n    \n    int pop() {\n       if(!q2.empty()){\n           int t = q2.top();\n           q2.pop();\n           return t;\n       } \n       else {\n           while(!q1.empty()){\n               int x = q1.top();\n               q1.pop();\n               q2.push(x);\n           }\n           int t = q2.top();\n           q2.pop();\n           return t;\n       }\n    }\n    \n    int peek() {\n        if(!q2.empty()) return q2.top();\n        else {\n           while(!q1.empty()){\n               int x = q1.top();\n               q1.pop();\n               q2.push(x);\n           }\n           return q2.top();\n       }\n    }\n    \n    bool empty() {\n        if(q1.size() || q2.size()) return false;\n        return true;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/6#issuecomment-2053261966","body":"```\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        vector<int> sorted;\n        int ans = 0;\n        for (int i = 0 ;i< arr.size();i++) sorted.push_back(arr[i]);\n        sort(sorted.begin(),sorted.end());\n        unordered_map<int,int> a,as;\n        for(int i = 0; i < arr.size(); i++) {\n            a[arr[i]]++;as[sorted[i]]++;\n            int flag = 1;\n            for ( int j = 0; j<=i; j++) {\n                if (a[arr[j]] != as[arr[j]]) {\n                    flag = 0;\n                    break;\n                }\n            }\n            if (flag == 1) ans++;\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/7#issuecomment-2054053880","body":"```\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        ListNode* newhead=head,*forward=head,*temp=head;\n        int count=1;\n        if(!head) return nullptr;\n        while(temp->next){\n            temp=temp->next;\n            count++;\n        }\n        k=k%count;\n        for(int i=0;i<k;i++){\n            forward=forward->next;\n        }\n        while(forward->next){\n            newhead=newhead->next;\n            forward=forward->next;\n        }\n        forward->next=head;\n        head=newhead->next;\n        newhead->next=nullptr;\n        \n        return head;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/9#issuecomment-2059421495","body":"```\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        TreeNode *root;\n        if (head == nullptr) return nullptr;\n        else if (head->next == nullptr) {\n            root = new TreeNode(head->val);\n            return root;\n        }\n\n        ListNode *fast = head, *slow = head, *pre = head;\n        while (fast != nullptr && fast->next != nullptr) {\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n\n        while (pre->next != slow) pre = pre->next;\n        root = new TreeNode(slow->val);\n        pre->next = nullptr; \n        root->left = sortedListToBST(head);\n        root->right = sortedListToBST(slow->next);\n\n        return root;\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/10#issuecomment-2061603977","body":"```\nclass Solution {\npublic:\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\nListNode *ptr1 = headA;\nListNode *ptr2 = headB;\n\n    while(ptr1 != ptr2){\n        ptr1 = ptr1->next;\n        ptr2 = ptr2->next;\n        \n        if(ptr1 == ptr2) break;\n        \n        if(ptr1 == NULL) ptr1 = headB;\n        if(ptr2 == NULL) ptr2 = headA;\n\n    }\n    return ptr1;\n}\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/11#issuecomment-2064305954","body":"class Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        fast, slow = head, head\n        while True:\n            if not (fast and fast.next): return\n            fast, slow = fast.next.next, slow.next\n            if fast == slow: break\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/12#issuecomment-2066825903","body":"```\nfrom collections import OrderedDict\nclass LRUCache(OrderedDict):\n\n    def __init__(self, capacity: int):\n        self.s = capacity\n        \n\n    def get(self, key: int) -> int:\n        if key in self:\n            self.move_to_end(key)\n            return self[key]\n        else:\n            return -1\n        \n\n    def put(self, key: int, value: int) -> None:\n        if key in self:\n            self.move_to_end(key)\n        self[key] = value\n        if len(self) > self.s:\n            self.popitem(last=False)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/13#issuecomment-2067603351","body":"class Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root==nullptr){\n            return 0 ;\n        }\n        return max(maxDepth(root->left)+1,maxDepth(root->right)+1);\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/14#issuecomment-2067835692","body":"class Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(p == nullptr || q == nullptr){\n            return p == q;\n        }\n        return (p->val == q->val) && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/15#issuecomment-2070003611","body":"```\nclass Solution {\npublic:\n    int sum = 0;\n    int sumNumbers(TreeNode* root) {\n        dfs(root, 0);\n        return sum;\n    }\n\n    void dfs(TreeNode* root, int num) {\n        if (!root) return;\n        if (!root->left && !root->right) {\n            sum += num * 10 + root->val;\n            return;\n        }\n        dfs(root->left, num * 10 + root->val);\n        dfs(root->right, num * 10 + root->val);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/16#issuecomment-2072804047","body":"```\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        queue<TreeNode*> curq,lastq;\n        if(!root) return 0;\n        curq.push(root);\n        while(!curq.empty()){\n            TreeNode* left=curq.front();\n            while(!curq.empty()){\n                TreeNode* temp=curq.front();\n                if(temp->left) lastq.push(temp->left);\n                if(temp->right) lastq.push(temp->right);\n                curq.pop();\n            }\n            if(lastq.empty()) return left->val;\n            while(!lastq.empty()){\n                TreeNode* temp2=lastq.front();\n                curq.push(temp2);\n                lastq.pop();\n            }\n        }\n        return 0;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/17#issuecomment-2075292430","body":"```java\npublic class Codec {\n    public String serialize(TreeNode root) {\n        return rserialize(root, \"\");\n    }\n  \n    public TreeNode deserialize(String data) {\n        String[] dataArray = data.split(\",\");\n        List<String> dataList = new LinkedList<String>(Arrays.asList(dataArray));\n        return rdeserialize(dataList);\n    }\n\n    public String rserialize(TreeNode root, String str) {\n        if (root == null) {\n            str += \"None,\";\n        } else {\n            str += str.valueOf(root.val) + \",\";\n            str = rserialize(root.left, str);\n            str = rserialize(root.right, str);\n        }\n        return str;\n    }\n  \n    public TreeNode rdeserialize(List<String> dataList) {\n        if (dataList.get(0).equals(\"None\")) {\n            dataList.remove(0);\n            return null;\n        }\n  \n        TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0)));\n        dataList.remove(0);\n        root.left = rdeserialize(dataList);\n        root.right = rdeserialize(dataList);\n    \n        return root;\n    }\n}\n\n   \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/18#issuecomment-2077337817","body":"```\nclass Solution {\npublic:\n    \n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        vector<tuple<int, int, int>> nodes;\n        dfs(root, nodes, 0, 0);\n        sort(nodes.begin(), nodes.end());\n        vector<vector<int>> res;\n        int last_col = 2000;\n        for(const auto& [col, row, val]: nodes){\n            if(last_col != col){\n                last_col = col;\n                res.emplace_back();\n            }\n            res.back().emplace_back(val);\n        }\n        return res;\n    }\n\n    void dfs(TreeNode* root, vector<tuple<int, int, int>>& nodes, int row, int col){\n        if(!root) return;\n        nodes.push_back(make_tuple(col, row, root->val));\n        dfs(root->left, nodes, row+1, col-1);\n        dfs(root->right, nodes, row+1, col+1);\n    }\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/20#issuecomment-2079486230","body":"```\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        vector<int>res;\n        for(int i = 0; i < (nums.size() - 1); i++){\n            for(int j = i + 1; j < nums.size(); j++){\n                if(target == (nums[i] + nums[j])){\n                    res.push_back(i);\n                    res.push_back(j);\n                    break;\n                }\n            }\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/21#issuecomment-2080310268","body":"```\nclass Solution {\npublic:\n    static bool cmp(const pair<int, int>& n, const pair<int, int>& m){\n        return n.second > m.second;\n    }\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int, int> occurrences;\n        for(const auto& num: nums){\n            occurrences[num]++;\n        }\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(&cmp)> q(cmp);\n        for(const auto &[num, count]: occurrences){\n            if(q.size() < k){\n                q.emplace(num, count);\n            }else{\n                if(q.top().second < count){\n                    q.pop();\n                    q.emplace(num, count);\n                }\n            }\n        }\n\n        vector<int> ans;\n        while(!q.empty()){\n            ans.emplace_back(q.top().first);\n            q.pop();\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/22#issuecomment-2081334834","body":"```\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        int ans = 0;\n        for (int i = 0; i < points.size(); i++) {\n            unordered_map<int, int> mp;\n            for (int j = 0; j < points.size(); j++) {\n                if (j == i) continue;\n                int x = points[i][0] - points[j][0];\n                int y = points[i][1] - points[j][1];\n                int dist = x * x + y * y;\n                mp[dist]++;\n            }\n            for (auto [dist, cnt] : mp) {\n                ans += cnt * (cnt - 1);\n            }\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/23#issuecomment-2082979369","body":"```\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        unordered_set<char> occ;\n        int n = s.size();\n        int rk = -1, ans = 0;\n        for (int i = 0; i < n; ++i) {\n            if (i != 0) {\n                occ.erase(s[i - 1]);\n            }\n            while (rk + 1 < n && !occ.count(s[rk + 1])) {\n                occ.insert(s[rk + 1]);\n                ++rk;\n            }\n            ans = max(ans, rk - i + 1);\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/24#issuecomment-2085765128","body":"class Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        vector<int> res;\n        unordered_map<string, int> search;\n        for (auto &word : words) ++search[word];\n        int n = s.size(), m = words.size(), len = words[0].size();\n        for (int i = 0, j = 0; i < n - m * len + 1; ++i) {\n            unordered_map<string, int> sub; \n            for (j = 0; j < m; ++j) {\n                auto word = s.substr(i + j * len, len);\n                if (!search.count(word)) break; \n                if (++sub[word] > search[word]) break;\n            }\n            if (j == m) res.push_back(i);\n        }\n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/25#issuecomment-2088621241","body":"class Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        int ans = 0, n = nums.size() + 1;\n        vector<int> sum(n, 0);\n        unordered_map<int, int> mp;\n        for (int i = 1; i < n; i++) {\n            sum[i] = sum[i - 1] + nums[i - 1];\n            int mod = (sum[i] % k + k) % k;\n            mp[mod]++;\n        }\n\n        for (auto &[k, v] : mp) {\n            if (!k) ans += v;\n            ans += v * (v - 1) / 2;\n        }\n\n        return ans;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/26#issuecomment-2090881231","body":"class Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode *slow=head, *fast=head;\n        while(fast != nullptr && fast->next != nullptr){\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/27#issuecomment-2091928317","body":"class Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int n = nums.size();\n        if(n == 0){\n            return 0;\n        }\n        int fast = 1, slow = 1;\n        while(fast <= n-1){\n            if(nums[fast] != nums[fast-1]){\n                nums[slow++] = nums[fast]; \n            }\n            fast++;\n        }\n        return slow;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/28#issuecomment-2094030086","body":"class Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int n = nums.size();\n        int left = 0, right = n - 1, ans = n;\n        while (left <= right) {\n            int mid = ((right - left) >> 1) + left;\n            if (target <= nums[mid]) {\n                ans = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return ans;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/29#issuecomment-2094683252","body":"class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int n = nums.length;\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {\n            public int compare(int[] pair1, int[] pair2) {\n                return pair1[0] != pair2[0] ? pair2[0] - pair1[0] : pair2[1] - pair1[1];\n            }\n        });\n        for (int i = 0; i < k; ++i) {\n            pq.offer(new int[]{nums[i], i});\n        }\n        int[] ans = new int[n - k + 1];\n        ans[0] = pq.peek()[0];\n        for (int i = k; i < n; ++i) {\n            pq.offer(new int[]{nums[i], i});\n            while (pq.peek()[1] <= i - k) {\n                pq.poll();\n            }\n            ans[i - k + 1] = pq.peek()[0];\n        }\n        return ans;\n    }\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/31#issuecomment-2098778967","body":"class Solution {\npublic:\n    int p[4010];\n    int find(int x) {\n        if (p[x] != x) p[x] = find(p[x]);\n        return p[x];\n    }\n\n    void union_(int i, int j) {\n        p[find(i)] = p[find(j)];\n    }\n\n    bool connected(int i, int j) {\n        return find(i) == find(j);\n    }\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        for (int i = 1; i <= 2 * n; i++) p[i] = i;\n        for (vector<int> dis : dislikes) {\n            int a = dis[0], b = dis[1];\n            if (connected(a, b)) return false;\n            union_(a, b + n);\n            union_(b, a + n);\n        }\n        return true;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/32#issuecomment-2100865028","body":"```\nclass Solution {\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\n      \n        for (int i = 0; i < group.length; i++) {\n            if (group[i] == -1) {\n                group[i] = m;\n                m++;\n            }\n        }\n\n       \n        List<Integer>[] groupGraph = new ArrayList[m];\n        List<Integer>[] itemGraph = new ArrayList[n];\n        for (int i = 0; i < m; i++) groupGraph[i] = new ArrayList<>();\n        for (int i = 0; i < n; i++) itemGraph[i] = new ArrayList<>();\n\n       \n        int[] groupIndegree = new int[m];\n        int[] itemIndegree = new int[n];\n\n        int len = group.length; // m changed\n        for (int i = 0; i < len; i++) {\n            int curGroup = group[i];\n            for (int beforeItem: beforeItems.get(i)) {\n                int beforeGroup = group[beforeItem];\n                if (beforeGroup != curGroup) {\n                    groupGraph[beforeGroup].add(curGroup);\n                    groupIndegree[curGroup]++;\n                }\n            }\n        } \n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/33#issuecomment-2102837557","body":"```\nclass Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int x = 0, y = 0;\n        for (char c : moves) {\n            if (c == 'U') y += 1;\n            else if (c == 'D') y -= 1;\n            else if (c == 'L') x -= 1;\n            else if (c == 'R') x += 1;\n        }\n        return x == 0 && y == 0;\n    }\n};·\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/34#issuecomment-2104854227","body":"class Solution(object):\n    def getOrder(self, tasks):\n        \"\"\"\n        :type tasks: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        from heapq import *\n        if not tasks:\n            return []\n \n        tasks = [(pair[1], index, pair[0]) for index, pair in enumerate(tasks)] \n        tasks.sort(key = lambda x: x[2]) \n \n        next_task_id = 0 \n        cur_time = tasks[0][2]\n        min_heap = []\n        res = []\n        while next_task_id < len(tasks) or min_heap:\n            while next_task_id < len(tasks) and tasks[next_task_id][2] <= cur_time:\n               \n                heappush(min_heap, tasks[next_task_id])\n                next_task_id += 1\n \n            if not min_heap:\n                \n                cur_time = tasks[next_task_id][2]\n            else\n                working_task = heappop(min_heap)\n                cur_time += working_task[0]\n                res.append(working_task[1])\n \n        return res","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/35#issuecomment-2105897612","body":"```\nclass Solution:\n    def numberOfRounds(self, s, f):\n        sh, sm = s.split(\":\")\n        eh, em = f.split(\":\")\n        sh, sm, eh, em = int(sh), int(sm), int(eh), int(em)\n        if sh == eh:\n            if sm <= em:\n                d = em//15-(sm//15)-(1 if sm % 15 > 0 else 0)\n                return d if d > 0 else 0\n            else:\n                sm = 60-sm\n                val = 0\n                val += sm//15\n                val += em//15\n                return 23*4+val\n        else:\n            if eh < sh:\n                eh += 24\n            val = 0\n            sm = 60-sm\n            val += sm//15\n            val += em//15\n            sh += 1\n            return (eh-sh)*4+val\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/37#issuecomment-2107541105","body":"class Solution {\npublic:\n    vector<int> sortArray(vector<int>& nums) {\n        heapSort(nums);\n        return nums;\n    }\n    void maxHeapify(vector<int>& nums, int i, int length) {\n        while (2 * i + 1 < length){\n            int min_index = i;\n            if (2 * i + 1 < length && nums[2 * i + 1] > nums[min_index]) min_index = 2 * i + 1;\n            if (2 * i + 2 < length && nums[2 * i + 2] > nums[min_index]) min_index = 2 * i + 2;\n            if (min_index == i) break;\n            swap(nums[min_index], nums[i]);\n            i = min_index;\n        }\n    }\n    void heapSort(vector<int>& nums) {\n        for (int i = (nums.size() >> 1) - 1; i >= 0; i--) \n            maxHeapify(nums, i, nums.size());\n        int end = nums.size();\n        while(--end > 0) {\n            swap(nums[0], nums[end]);\n            maxHeapify(nums, 0, end);\n        }\n    }\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/39#issuecomment-2112925391","body":"```\npublic class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        int left=0,right=n;\n        while(left<right){\n            int mid=(right-left)/2+left;\n            if(isBadVersion(mid)){\n                right=mid;\n            }else\n                left=mid+1;\n        }\n        return left;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/40#issuecomment-2115600581","body":"class Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        tb, res = [], 0\n        for n in nums[::-1] :\n            res += bisect.bisect_left(tb, n)\n            n2 = 2*n\n            idx = bisect.bisect_left(tb, n2)\n            tb.insert(idx, n2)\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/41#issuecomment-2117897212","body":"class Solution {\npublic:\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\n        sort(houses.begin(),houses.end());\n        sort(heaters.begin(),heaters.end());\n        int ans = 0;\n        int h = 0;\n        for(int i=0;i<houses.size();i++){\n            while(h+1<heaters.size() && abs(houses[i]-heaters[h])>=abs(houses[i]-heaters[h+1])) \n                h++;\n            ans = max(ans,abs(houses[i]-heaters[h]));\n        }\n        return ans;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/42#issuecomment-2118865687","body":"class Solution {\npublic:\n    int smallestDistancePair(vector<int>& nums, int k) {\n        sort(nums.begin(), nums.end());\n        int n=nums.size(), l=0, r=nums[n-1]-nums[0];\n        while(l <= r){\n            int m=(l+r)/2, cnt=0;\n            for(int i=0,j=0;j<n;j++){\n                while(nums[j]-nums[i] > m)\n                    i++;\n                cnt += j-i;\n            }\n            if(cnt >= k)\n                r = m-1;\n            else\n                l = m+1;\n        }\n        return l;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/43#issuecomment-2119265173","body":"```\nclass Solution {\npublic:\n    int swimInWater(vector<vector<int>>& grid) {\n        int m=grid.size();\n        int n=grid[0].size();\n        UnionFind uf(m*n);\n        vector<tuple<int,int,int>>edge;\n        for(int i=0;i<m;i++)\n        for(int j=0;j<n;j++){\n            int id=i*n+j;\n            if(i>0)edge.emplace_back(max(grid[i][j],grid[i-1][j]),id,id-m);\n            if(j>0)edge.emplace_back(max(grid[i][j],grid[i][j-1]),id,id-1);\n        }\n        sort(edge.begin(),edge.end());\n        int res=0;\n        for(auto&[v,x,y]:edge){\n            uf.merge(x,y);\n            if(uf.connected(0,n*n-1)){\n                res=v;\n                break;\n            }\n        }\n        return res;\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/44#issuecomment-2120741908","body":"```\nclass Solution {\n    public int maxVowels(String s, int k) {\n        int cnt = 0;\n        int left = 0;\n        int right = 0;\n        while(right < s.length() && right < k){\n            cnt += isNeed(s.charAt(right)) ? 1 : 0;\n            right++;\n        }\n        int max = cnt;\n        while(right < s.length()){\n            cnt -= isNeed(s.charAt(left)) ? 1 : 0;\n            cnt += isNeed(s.charAt(right)) ? 1 : 0;\n            right++;\n            left++;\n            max = Math.max(max, cnt);\n        }\n        return max;\n    }\n\n    private boolean isNeed(char c){\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/45#issuecomment-2122832008","body":"class Solution {\npublic:\n    double new21Game(int n, int k, int maxPts) {\n        if (k == 0) {\n            return 1.0;\n        }\n        vector<double> dp(k + maxPts);\n        for (int i = k; i <= n && i < k + maxPts; i++) {\n            dp[i] = 1.0;\n        }\n        for (int i = k - 1; i >= 0; i--) {\n            for (int j = 1; j <= maxPts; j++) {\n                dp[i] += dp[i + j] / maxPts;\n            }\n        }\n        return dp[0];\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/46#issuecomment-2124561978","body":"```\nclass Solution {\npublic:\n    vector<int> findAnagrams(string s, string p) {\n        int sLen = s.size(), pLen = p.size();\n\n        if (sLen < pLen) {\n            return vector<int>();\n        }\n\n        vector<int> ans;\n        vector<int> sCount(26);\n        vector<int> pCount(26);\n        for (int i = 0; i < pLen; ++i) {\n            ++sCount[s[i] - 'a'];\n            ++pCount[p[i] - 'a'];\n        }\n\n        if (sCount == pCount) {\n            ans.emplace_back(0);\n        }\n\n        for (int i = 0; i < sLen - pLen; ++i) {\n            --sCount[s[i] - 'a'];\n            ++sCount[s[i + pLen] - 'a'];\n\n            if (sCount == pCount) {\n                ans.emplace_back(i + 1);\n            }\n        }\n\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/47#issuecomment-2127453083","body":"class Solution:\n    def minWindow(self, s: 'str', t: 'str') -> 'str':\n        from collections import Counter\n        t = Counter(t)\n        lookup = Counter()\n        start = 0\n        end = 0\n        min_len = float(\"inf\")\n        res = \"\"\n        while end < len(s):\n            lookup[s[end]] += 1\n            end += 1\n            #print(start, end)\n            while all(map(lambda x: lookup[x] >= t[x], t.keys())):\n                if end - start < min_len:\n                    res = s[start:end]\n                    min_len = end - start\n                lookup[s[start]] -= 1\n                start += 1\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/48#issuecomment-2128589973","body":"class Solution {\n    public int maxScore(int[] cardPoints, int k) {\n        int len = cardPoints.length;\n        int[] preSum = new int[len + 1];\n        for (int i = 1; i <= len; i++) {\n            preSum[i] = preSum[i - 1] + cardPoints[i - 1];\n        }\n\n        int max = 0;\n        for (int i = 0; i <= k; i++) {\n            int score = preSum[i] + preSum[len] - preSum[len - k + i];\n            max = Math.max(score, max);\n        }\n        return max;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/49#issuecomment-2130746896","body":"class Solution {\npublic:\n    vector<string> readBinaryWatch(int turnedOn) {\n        vector<string> ans;\n        if(turnedOn>=9)return {};\n        for(int i=0;i<1024;i++){\n            int h=i>>6,m=i&63;\n            if(h<12&&m<60&&__builtin_popcount(i)==turnedOn){\n                ans.push_back(to_string(h)+\":\"+(m<10?\"0\"+to_string(m):to_string(m)));\n            }\n        }\n        return ans;\n    }\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/51#issuecomment-2133755750","body":"class Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n\n        m,n = len(grid), len(grid[0])\n        ans = 0\n        def dfs(i,j):\n            if i < 0 or i >= m or j < 0 or j >= n: return 0\n            if grid[i][j] == 0: return 0\n            grid[i][j] = 0\n            top = dfs(i+1,j)\n            bottom = dfs(i-1,j)\n            left = dfs(i,j-1)\n            right = dfs(i,j+1)\n            return 1 + sum([top, bottom,left, right])\n\n        for i in range(m):\n            for j in range(n):\n                ans = max(ans, dfs(i,j))\n\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/52#issuecomment-2134404190","body":"class Solution {\npublic:\n    static constexpr int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\n    static constexpr int MAX_N = 100 + 5;\n\n    struct Coordinate {\n        int x, y, step;\n    };\n\n    int n, m;\n    vector<vector<int>> a;\n\n    bool vis[MAX_N][MAX_N];\n\n    int findNearestLand(int x, int y) {\n        memset(vis, 0, sizeof vis);\n        queue <Coordinate> q;\n        q.push({x, y, 0});\n        vis[x][y] = 1;\n        while (!q.empty()) {\n            auto f = q.front(); q.pop();\n            for (int i = 0; i < 4; ++i) {\n                int nx = f.x + dx[i], ny = f.y + dy[i];\n                if (!(nx >= 0 && nx <= n - 1 && ny >= 0 && ny <= m - 1)) {\n                    continue;\n                }\n                if (!vis[nx][ny]) {\n                    q.push({nx, ny, f.step + 1});\n                    vis[nx][ny] = 1;\n                    if (a[nx][ny]) {\n                        return f.step + 1;\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n    \n    int maxDistance(vector<vector<int>>& grid) {\n        this->n = grid.size();\n        this->m = grid.at(0).size();\n        a = grid;\n        int ans = -1;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (!a[i][j]) {\n                    ans = max(ans, findNearestLand(i, j));\n                }\n            }\n        }\n        return ans;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/53#issuecomment-2137653498","body":"```\npublic int findShortestCircleContainingTarget(List<List<Integer>> graph, int target) {\n        Queue<Integer> queue = new ArrayDeque<>();\n        Set<Integer> seen = new HashSet<>();\n        queue.offer(target);\n\n        int len = 0;\n        while (!queue.isEmpty()) {\n            len++;\n            for (int size = queue.size(); size > 0; size--) {\n                var cur = queue.poll();\n                seen.add(cur);\n\n                for (var next : graph.get(cur)) {\n                    if (!seen.contains(next))\n                        queue.offer(next);\n                    else if (next == target)\n                        return len;\n                }\n            }\n        }\n\n        return -1;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/54#issuecomment-2140034998","body":"class Solution {\npublic:\n\n    typedef map<int, multiset<pair<int, int>>> MAP;\n\n    void dfs(int x, int y, TreeNode* root, MAP &mp) {\n        if (!root) return ;\n        mp[y].insert({x, root->val});\n        dfs(x + 1, y - 1, root->left, mp);\n        dfs(x + 1, y + 1, root->right, mp);\n    }\n\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        MAP mp;\n        dfs(0, 0, root, mp);\n        vector<vector<int>> ans;\n        for (auto &[a, b] : mp) {\n            vector<int> temp;\n            for (auto &e : b) {\n                temp.push_back(e.second);\n            }\n            ans.push_back(temp);\n        }\n        return ans;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/55#issuecomment-2142551308","body":"class Solution:\n    def minCostClimbingStairs(self, cost: list[int]):\n        cost = cost + [0]\n        dp = [0]*len(cost)\n        dp[0], dp[1] = cost[0], cost[1]\n        for i in range(2, len(cost)):\n            dp[i] = min(dp[i-1], dp[i-2]) + (cost[i])\n        return dp[-1]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/56#issuecomment-2143308983","body":"if len(nums) == 1:\n            return nums[0]\n\n        dp = [0] * len(nums)\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n        \n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i-1], dp[i-2]+nums[i])\n        \n        return dp[-1]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/57#issuecomment-2143890264","body":"class Solution:\n    def findNumberOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        f = [1] * n \n        cnt = [1] * n \n        longest = 1\n        for i in range(1, n):\n            for j in range(i):\n                if nums[j] < nums[i]:\n                    cur = f[j] + 1\n                    if cur > f[i]:\n                        f[i] = cur\n                        cnt[i] = cnt[j]\n                    elif cur == f[i]:\n                        cnt[i] += cnt[j]\n            longest = max(longest, f[i])\n        \n    #    #  print(longest)\n    #     print(cnt)\n    #     print(f)\n        ans = 0\n        for i in range(n):\n            if f[i] == longest:\n                ans += cnt[i]\n        \n        return ans","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/60#issuecomment-2150421776","body":"class Solution {\n    static int[][] dirs = {{-2, -1}, {-2, 1}, {2, -1}, {2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}};\n    \n    public double knightProbability(int N, int K, int row, int column) {\n        double[][][] f = new double[N][N][K + 1];\n        for (double[][] x : f)\n            for (double[] y : x)\n                y[0] = 1;\n        for (int step = 1; step <= K; step++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    for (int[] dir : dirs) {\n                        int x = i + dir[0], y = j + dir[1];\n                        if (x < 0 || x >= N || y < 0 || y >= N) continue;\n                        f[i][j][step] += f[x][y][step - 1] / 8;\n                    }\n                }\n            }\n        }\n        return f[row][column][K];\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/61#issuecomment-2152882380","body":"class Solution {\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n        if (desiredTotal <= maxChoosableInteger || desiredTotal == 0)\n\t\t\treturn true;\n        if (desiredTotal > ((maxChoosableInteger * (maxChoosableInteger + 1)) / 2))\n\t\t\treturn false;\n\n\t\tif (1 + maxChoosableInteger < desiredTotal && desiredTotal < 2 * maxChoosableInteger)\n\t\t\treturn true;\n\t\tif (1 + maxChoosableInteger == desiredTotal && desiredTotal < 2 * maxChoosableInteger)\n\t\t\treturn false; \n\n\t\tif (desiredTotal % 2 == 0 && maxChoosableInteger % 2 == 0) {\n\t\t\treturn desiredTotal / maxChoosableInteger < 4 || desiredTotal == 100 && maxChoosableInteger == 16;\n\t\t} else {\n\t\t\treturn desiredTotal % 2 == 0 || maxChoosableInteger % 2 != 0 || desiredTotal / maxChoosableInteger < 5;\n\t\t}\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/62#issuecomment-2155104580","body":"class Solution {\n    public boolean canPartition(int[] nums) {\n        int n = nums.length;\n        if (n < 2) {\n            return false;\n        }\n        int sum = 0, maxNum = 0;\n        for (int num : nums) {\n            sum += num;\n            maxNum = Math.max(maxNum, num);\n        }\n        if (sum % 2 != 0) {\n            return false;\n        }\n        int target = sum / 2;\n        if (maxNum > target) {\n            return false;\n        }\n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true;\n        for (int i = 0; i < n; i++) {\n            int num = nums[i];\n            for (int j = target; j >= num; --j) {\n                dp[j] |= dp[j - num];\n            }\n        }\n        return dp[target];\n    }\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/65#issuecomment-2158664431","body":"class Solution {\n    public int change(int amount, int[] coins) {\n        int[] dp = new int[amount + 1];\n        dp[0] = 1;\n        for (int coin : coins) {\n            for (int i = coin; i <= amount; i++) {\n                dp[i] += dp[i - coin];\n            }\n        }\n        return dp[amount];\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/66#issuecomment-2161115354","body":"class Solution {\npublic:\n    int findContentChildren(vector<int>& g, vector<int>& s) {\n        sort(g.begin(), g.end());\n        sort(s.begin(), s.end());\n        int ans = 0;\n        for (int i = 0; i < s.size(); i++) {\n            if (ans < g.size() && g[ans] <= s[i]) ans++;\n        }\n        return ans;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/67#issuecomment-2163388464","body":"class Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        if (intervals.size() == 0) return 0;\n        sort(intervals.begin(), intervals.end(), cmp);\n        int count = 1;\n        int end = intervals[0][1];\n        for (int i = 1; i < intervals.size(); i++) {\n            if (end <= intervals[i][0]) {\n                end = intervals[i][1];\n                count++;\n            }\n        }\n        return intervals.size() - count;\n    }\n\n    static bool cmp (const vector<int>& a, const vector<int>& b) {\n        return a[1] < b[1];\n    }\n\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/69#issuecomment-2167186521","body":"class Solution {\npublic:\n    int numTrees(int n) {\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1;\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= i; j++)\n                dp[i] += dp[j - 1] = dp[i - j];\n\n        return dp[n];\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/70#issuecomment-2169478871","body":"public ListNode mergeKLists(ListNode a, ListNode b) {\n    if (a == null || b == null) {\n        return a != null ? a : b;\n    }\n    ListNode head = new ListNode(0);\n    ListNode tail = head, aPtr = a, bPtr = b;\n    while (aPtr != null && bPtr != null) {\n        if (aPtr.val < bPtr.val) {\n            tail.next = aPtr;\n            aPtr = aPtr.next;\n        } else {\n            tail.next = bPtr;\n            bPtr = bPtr.next;\n        }\n        tail = tail.next;\n    }\n    tail.next = (aPtr != null ? aPtr : bPtr);\n    return head.next;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/71#issuecomment-2171750637","body":"class Solution {\npublic:\n    vector<int> beautifulArray(int n) {\n        if(n==1)return {1};\n        vector<int> res;\n        auto left=beautifulArray(n-n/2);\n        auto right=beautifulArray(n/2);\n        for(auto& x:left){\n            res.push_back(2*x-1);\n        }\n        for(auto& x:right){\n            res.push_back(2*x);\n        }\n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/72#issuecomment-2173555092","body":"var singleNumber = function(nums) {\n    const freq = new Map();\n    for (const num of nums) {\n        freq.set(num, (freq.get(num) || 0) + 1);\n    }\n    const ans = [];\n    for (const [num, occ] of freq.entries()) {\n        if (occ === 1) {\n            ans.push(num);\n        }\n    }\n    return ans;\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/74#issuecomment-2179019494","body":"class Trie {\nprivate:\n    vector<Trie*> children;\n    bool isEnd;\n\n    Trie* searchPrefix(string prefix) {\n        Trie* node = this;\n        for (char ch : prefix) {\n            ch -= 'a';\n            if (node->children[ch] == nullptr) {\n                return nullptr;\n            }\n            node = node->children[ch];\n        }\n        return node;\n    }\n\npublic:\n    Trie() : children(26), isEnd(false) {}\n\n    void insert(string word) {\n        Trie* node = this;\n        for (char ch : word) {\n            ch -= 'a';\n            if (node->children[ch] == nullptr) {\n                node->children[ch] = new Trie();\n            }\n            node = node->children[ch];\n        }\n        node->isEnd = true;\n    }\n\n    bool search(string word) {\n        Trie* node = this->searchPrefix(word);\n        return node != nullptr && node->isEnd;\n    }\n\n    bool startsWith(string prefix) {\n        return this->searchPrefix(prefix) != nullptr;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/75#issuecomment-2181042811","body":"class MapSum {\n    Map<String, Integer> map;\n\n    public MapSum() {\n        map = new HashMap<>();\n    }\n    \n    public void insert(String key, int val) {\n        map.put(key,val);\n    }\n    \n    public int sum(String prefix) {\n        int res = 0;\n        for (String s : map.keySet()) {\n            if (s.startsWith(prefix)) {\n                res += map.get(s);\n            }\n        }\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/76#issuecomment-2183020077","body":"class Solution {\npublic:\n    struct Trie{\n         int smallIndex;\n         Trie* next[26];\n         Trie(){ \n             smallIndex=-1;\n             memset(next,0,sizeof(next));\n         }\n    };\n    vector<vector<int>> res;\n    Trie* root=new Trie();\n    void insert(string s,int s_index){\n        Trie*  node=root;\n        for(auto ch:s){\n            if(node->next[ch-'a']==NULL){\n                node->next[ch-'a']=new Trie();\n            }\n            node=node->next[ch-'a'];\n        }\n        node->smallIndex=s_index; \n    }\n\n    void search(string subBig,int index){ \n        Trie* node=root;\n        for(auto ch:subBig){\n            if(node->next[ch-'a']==NULL) return;\n            node=node->next[ch-'a'];\n            if(node->smallIndex!=-1){ \n                res[node->smallIndex].push_back(index);\n            }           \n        }\n    }\n\n\n    vector<vector<int>> multiSearch(string big, vector<string>& smalls) {\n        res.resize(smalls.size());\n        for(int i=0;i<smalls.size();i++){ \n            insert(smalls[i],i);\n        }\n        for(int i=0;i<big.size();i++){ \n            string subBig=big.substr(i);\n            search(subBig,i);\n        }\n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/77#issuecomment-2184002853","body":"class Solution {\npublic:\n    int ans, a[210];\n\n    void init(int n) {\n        for (int i = 0; i < n; i++) a[i] = i;\n    }\n\n    int find(int x) {\n        if (x != a[x]) a[x] = a[find(a[x])];\n        return a[x];\n    }\n\n    void connect(int i, int j) {\n        int x = find(i), y = find(j);\n        if (x == y) return;\n        a[x] = y;\n        ans--;\n    }\n\n    int findCircleNum(vector<vector<int>>& isConnected) {\n        int row = isConnected.size();\n        int col = isConnected[0].size();\n        init(row);\n        ans = row;\n        for (int i = 0; i < row; i++) {\n            for (int j = 0; j < col; j++) {\n                if (isConnected[i][j]) connect(i, j);\n            }\n        }\n        return ans;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/78#issuecomment-2184498248","body":"class Solution {\n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        Arrays.sort(initial);\n        int N = graph.length;\n        int ans = initial[0];\n        int max = 0;\n        boolean[] init = new boolean[N];\n        for (int p : initial) {\n            init[p] = true;\n        }\n        for (int p : initial) {\n            init[p] = false;\n            int count = process(graph, p, new boolean[N], init);\n            if (count > max) {\n                max = count;\n                ans = p;\n            }\n            init[p] = true;\n        }\n        return ans;\n    }\n\n    private int process(int[][] graph, int p, boolean[] visited, boolean[] initial) {\n        if (initial[p]) {\n            return 0;\n        }\n        visited[p] = true;\n        int count = 1;\n        for (int q = 0; q < graph[p].length; q++) {\n            if (!visited[q] && graph[p][q] == 1) {\n                int c = process(graph, q, visited, initial);\n                if (c == 0) {\n                    return 0;\n                }\n                count += c;\n            }\n        }\n        return count;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/79#issuecomment-2186906941","body":"class Solution {\npublic:\n    int makeConnected(int n, vector<vector<int>>& connections) {\n        if (connections.size() < n - 1) {\n            return -1;\n        }\n\n        vector<int> fa(n);\n        iota(fa.begin(), fa.end(), 0);    \n        \n        function<int(int)> findset = [&](int x) {return x == fa[x] ? x : fa[x] = findset(fa[x]);};\n        int part = n;\n        for (auto&& c: connections) {\n            int p = findset(c[0]), q = findset(c[1]);\n            if (p != q) {\n                --part;\n                fa[p] = q;\n            }\n        }\n\n        return part - 1;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/80#issuecomment-2189335901","body":"class Solution {\n    public TreeNode pruneTree(TreeNode root) {\n        if (root == null)\n            return null;\n        root.left = pruneTree(root.left);\n        root.right = pruneTree(root.right);\n        if (root.left == null && root.right == null && root.val == 0)\n            return null;\n        return root;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/81#issuecomment-2192061380","body":"class Solution {\n    Set<List<Integer>> ans = new HashSet<>();\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        int n = candidates.length;\n        dfs(candidates,target,0,new ArrayList<>());\n        List<List<Integer>> res = new ArrayList<>();\n        res.addAll(ans);\n        return res;\n    }\n    void dfs(int[] nums,int target,int num,List<Integer> l){\n        if (num > target){\n            return;\n        }\n        if (num == target){\n            List<Integer> tmp = new ArrayList<>(l);\n            Collections.sort(tmp);\n            ans.add(tmp);\n        }\n        int n = nums.length;\n        for (int i = 0;i < n;i++){\n            l.add(nums[i]);\n            dfs(nums,target,num + nums[i],l);\n            l.remove(l.size() - 1);\n        }\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/82#issuecomment-2195091673","body":"class Solution {\npublic:\n    vector<vector<int>> ans;\n    vector<int> index;\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target, int ii=-1) {\n        sort(candidates.begin(),candidates.end());\n        \n        if(target==0){\n            ans.push_back(index);            \n            return {};\n        }\n       \n        for(int i=ii+1;i<candidates.size();i++){\n            if(target<candidates[i]){break;}\n            if(i>ii+1&&candidates[i]==candidates[i-1]){\n                continue;\n            }\n            index.push_back(candidates[i]);\n            combinationSum2(candidates,target-candidates[i],i);\n            index.pop_back();\n        }\n        return ans;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null],"martina001":[{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/1#issuecomment-2049926597","body":"补打卡day 1\r\n思路： 直接记录进位 不断向前++ 即可，注意最后还需处理剩余的进位值和k剩余部分\r\n```\r\npublic List<Integer> addToArrayForm(int[] num, int k) {\r\n            int n = num.length;\r\n            int carry = 0;\r\n            LinkedList<Integer> linkedList = new LinkedList<>();\r\n            for (int i = n - 1; i >= 0; i--) {\r\n                int val = num[i];\r\n                int newVal = val + k % 10 + carry;\r\n                linkedList.addFirst(newVal % 10);\r\n                // num[i] = newVal % 10;\r\n                k /= 10;\r\n                carry = newVal / 10;\r\n            }\r\n            if(carry !=0 || k !=0){\r\n                int val = carry+k;\r\n                while(val !=0){\r\n                    linkedList.addFirst(val%10);\r\n                    val = val/10;\r\n                }\r\n            }\r\n            /*List<Integer> list = new ArrayList<>();\r\n            if(carry != 0){\r\n                list.add(carry);\r\n            }\r\n            for(int val:num){\r\n                list.add(val);\r\n            }*/\r\n            return linkedList;\r\n        }\r\n```\r\n    时间复杂度On 空间复杂度O1","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/2#issuecomment-2049956673","body":"两遍遍历可解，第一遍从左到右，第二遍从右到左，更新到e的较小值\r\n根据题意 这道题很像是找e为终点的最短路径，直接套用BFS来求解\r\n```\r\n private int[] bfs(String s,char c){\r\n        int n = s.length();\r\n        int res[] = new int[n];\r\n        Arrays.fill(res,-1);\r\n        LinkedList<Integer> queue = new LinkedList<>();\r\n        for(int i = 0;i<n;i++){\r\n            if(s.charAt(i) == c){\r\n                queue.offer(i);\r\n                res[i] =0;\r\n            }\r\n        }\r\n        int []dir = new int[]{-1,1};\r\n        while(!queue.isEmpty()){\r\n            int index = queue.poll();\r\n            for(int d:dir){\r\n                int next = index+d;\r\n                if(next >=0 && next<n && res[next] ==-1){\r\n                    res[next] = res[index] +1;\r\n                    queue.offer(next);\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n```\r\n每个数组只用入栈出栈一次，所以时间复杂度为On 用到了栈，所以空间复杂度为On","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/3#issuecomment-2050948479","body":"补打卡\nclass CustomStack {\n    // 1。 直接使用双栈比较直接，就是保存一个元素总和，当递增的时候用备用栈倒出来，从倒到n-k的时候开始增加，然后再倒回去原来的栈\n\n    // 2。 其实这道题考察的是模拟的思想，用数组表示栈，会更直接一点，每次incre就遍历0-k对数组执行++就行，这样incre的复杂度是Ok\n\n    // 3。 有一个比较巧妙的方法就是使用前缀和数组的思想，用数组实现栈，保存一个addArr[i]表示在i位置需增加的值，这样每次increment只用增加addArr[k]位置的值\n    // push保存一个栈顶索引，topIndex，pop的时候需要拿到stack[topIndex]+addArr[topIndex]的值\n    // 又因为每次incre的时候只是增加了addArr[k],为了保证每次取到的值都是已经被加过的，所以每次pop以后，addArr[topIndex-1]位置也要增加addArr[topIndex]\n    // 这样看似有点难理解，但是想清楚了就很妙了，可以保证incre的时候复杂度都是O1\n\n    int [] stack;\n    int addArr[];\n\n    int topIndex;\n\n    // 直接写一下前缀和方式\n    public CustomStack(int maxSize) {\n        addArr = new int[maxSize];\n        stack = new int[maxSize];\n        topIndex = -1;\n    }\n    \n    public void push(int x) {\n        if(topIndex == stack.length-1){\n            return ;\n        }\n        stack[++topIndex] = x;\n    }\n    \n    public int pop() {\n        if(topIndex==-1){\n            return -1;\n        }\n\n        int addVal = addArr[topIndex];\n        int res = stack[topIndex]+addVal;\n\n        // 更新最新top索引处的add值\n        if(topIndex>=1){\n            addArr[topIndex-1] += addVal;\n        }\n        // 记得还原addArr[topIndex] =0\n        addArr[topIndex] =0;\n        topIndex--;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        // 这里要用topIndex和K比较\n        int actualK = Math.min(k,topIndex+1);\n        if(actualK >=1){\n            addArr[actualK-1] +=val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n//leetcode submit region end(Prohibit modification and deletion)\n\n}","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/4#issuecomment-2048784123","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n = num.length;\n        int carry = 0;\n        LinkedList<Integer> linkedList = new LinkedList<>();\n        for (int i = n - 1; i >= 0; i--) {\n            int val = num[i];\n            int newVal = val + k % 10 + carry;\n            linkedList.addFirst(newVal % 10);\n            // num[i] = newVal % 10;\n            k /= 10;\n            carry = newVal / 10;\n        }\n        if(carry !=0 || k !=0){\n            int val = carry+k;\n            while(val !=0){\n                linkedList.addFirst(val%10);\n                val = val/10;\n            }\n        }\n        return linkedList;\n    }\n}\n直接进位计算，空间复杂度On 时间复杂度On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/5#issuecomment-2050823345","body":" // 思路：栈 先进后出，队列 先进先出 用两个队列可以实现栈 一个队列在offer的时候poll队列中其他元素再offer，即可实现栈\r\n        // 同理两个栈倒来倒去也可以实现队列 但是这样相当于在pop和peek的时候都要倒一遍\r\n        //  感觉可以想办法在push中实现\r\n\r\n```\r\nclass MyQueue {\r\n\r\n        LinkedList<Integer> stack;\r\n\r\n        LinkedList<Integer> helpStack;\r\n        public MyQueue() {\r\n            stack = new LinkedList<>();\r\n            helpStack = new LinkedList<>();\r\n        }\r\n        public void push(int x) {\r\n            stack.push(x);\r\n        }\r\n\r\n        public int pop() {\r\n            if(helpStack.isEmpty()){\r\n                while(!stack.isEmpty()){\r\n                    helpStack.push(stack.pop());\r\n                }\r\n            }\r\n           return helpStack.pop();\r\n        }\r\n\r\n        public int peek() {\r\n            if(helpStack.isEmpty()){\r\n                while(!stack.isEmpty()){\r\n                    helpStack.push(stack.pop());\r\n                }\r\n            }\r\n            return helpStack.peek();\r\n        }\r\n\r\n        public boolean empty() {\r\n            return helpStack.isEmpty() && stack.isEmpty();\r\n        }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/6#issuecomment-2053187566","body":"public int maxChunksToSorted(int[] arr) {\n        // 思路1 按照题意，相当于每个块内元素的和 与 排序后的arr对应范围内的元素和是相等的\n        // 将arr先排序得到sortArr，然后两个数组一起滑动 当和相等 就说明成了一个独立块，计算共几次相等和即可\n        // 这样的话 意味着时间复杂度为排序的时间复杂度O( nLogn) 空间复杂度为O(n)\n        int n = arr.length;\n//        int sortArr[] = Arrays.copyOf(arr,n);\n//        Arrays.sort(sortArr);\n//        int aSum =0,bSum = 0;\n//        int index =0;\n//        int res = 0;\n//        while (index<n){\n//            aSum+=arr[index];\n//            bSum +=sortArr[index];\n//            index++;\n//            if(aSum == bSum){\n//                res++;\n//                aSum = 0;\n//                bSum =0;\n//            }\n//        }\n//        return res;\n        // 另一种常见思路：单调栈 这个思路比较巧妙，假设现在已经分好了前面的块，又新增一个元素num，可以分情况讨论\n        // 1. num比最近的块中的max还大，那就num自成一块\n        // 2。 num比最近块中的max小，这时候就需要去和前一块的max2比较，如果比max2大，那么num加入最近块；如果比max2还小，那么num就得再往前一块进行比较，\n        // 直到找到一个块B的最大值小于num，这时num就必须和B块以及其后所有的块成为一块，整个块的最大值为最近块的最大值max。\n        // 所以单调栈中只用存储每个块的最大值即可 我们来写一下代码\n        LinkedList<Integer> stack = new LinkedList<>();\n\n        for(int i =0;i<n;i++){\n            int num =arr[i];\n            if(stack.isEmpty() || num>=stack.peekLast()){\n                stack.addLast(num);\n            }else{\n                int max = stack.removeLast();\n                // 只要发现有最大值小于num的，这些块都要被合并\n                while(!stack.isEmpty() && num<stack.peekLast()){\n                    stack.removeLast();\n                }\n                stack.addLast(max);\n            }\n        }\n        return stack.size();\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/7#issuecomment-2054602857","body":"// 这个题的自己做的时候错误在于，使用了固化的数组的思维去做一个链表题，后移几个节点，直接断掉再连即可，不用单纯的一个个后移\n\n        // 这个题应该是直接闭环，然后在k%n处断掉即可\n        if(head == null || k==0 || head.next == null){\n            return head;\n        }\n        ListNode temp = head;\n        int n = 1;\n        while(temp.next != null){\n            n++;\n            temp=temp.next;\n        }\n        int i = k%n;\n        if(i==0){\n            return head;\n        }\n        temp.next = head;\n        int needMove = n-i;\n        while(needMove-- > 0){\n            temp = temp.next;\n        }\n        ListNode  res =temp.next;\n        temp.next =null;\n        return res;\n    }","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/8#issuecomment-2054612734","body":"思路：这是一个递归解法的优秀范例：\n private ListNode swapPair2(ListNode head){\n            if(head == null || head.next == null){\n                return head;\n            }\n            ListNode temp = head;\n            head = head.next;\n            head.next = temp;\n            head.next.next = swapPair2(head.next.next);\n            return head;\n        }\n\n时间复杂度On 空间复杂度为On（递归用到了栈）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/9#issuecomment-2058968098","body":"思路：考察的是递归和分治，dfs更容易理解，类似于归并排序，每个节点都走进一次递归，一次递归每个节点又会被遍历logn次，时间复杂度为O(nlogn)\r\ndfsMid考察的是中序遍历，每个节点只会被遍历一次，时间复杂度为O(n)\r\n\r\n```\r\npublic TreeNode sortedListToBST(ListNode head) {\r\n        // 由于要找平衡二叉搜索树 所以直接找到中点后进行归并即可，但是链表不是数组（108 将有序数组转换为二叉搜索树），不能直接快速找到中点，\r\n        // 所以只有递归采用中序遍历的方式，分治才可以保证On的复杂度，既然是中序并且分治 必然要先找到left 和right，right就是链表长度\r\n        int n = 0;\r\n        ListNode temp = head;\r\n        while(temp!=null){\r\n            n++;\r\n            temp = temp.next;\r\n        }\r\n//        return dfs(head,0,n-1);\r\n        headNode = head;\r\n        return dfsMid(0,n-1);\r\n    }\r\n\r\n    private TreeNode dfsMid(int l,int r){\r\n        // 学习一下题解中的中序遍历\r\n        if(l>r){\r\n            return null;\r\n        }\r\n        int mid =  (r-l)/2+l;\r\n        TreeNode leftNode = dfsMid(l,mid-1);\r\n        // 此时headNode就是当前的中点节点middleNode\r\n        TreeNode midNode = new TreeNode(headNode.val);\r\n        headNode = headNode.next;\r\n        midNode.left = leftNode;\r\n        midNode.right = dfsMid(mid+1,r);\r\n        return midNode;\r\n    }\r\n\r\n\r\n    private TreeNode dfs(ListNode head,int left ,int right){\r\n        // 递归结束条件 记得只要是递归分治，一定要考虑这个递归结束条件\r\n        if(left>right){\r\n            return null;\r\n        }\r\n        int mid = (right-left)/2+left;\r\n        // 此时head需要来到链表中点的位置\r\n        int moveNum = mid-left;\r\n        ListNode cur = head;\r\n        while(moveNum-- >0){\r\n            cur = cur.next;\r\n        }\r\n        TreeNode root = new TreeNode(cur.val);\r\n        root.left  = dfs(head,left,mid-1);\r\n        root.right =  dfs(cur.next,mid+1,right);\r\n        return root;\r\n    }\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/10#issuecomment-2064005892","body":"```\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        // 把A和B接到一起 让两个指针分别走A-B 和B-A，如果有相遇 就是有交点 如果没有交点，此时两个指针都走到末尾为null\r\n        ListNode aNode = headA;\r\n        ListNode bNode = headB;\r\n        while(aNode != bNode){\r\n            if(aNode == null){\r\n                aNode = headB;\r\n            }else{\r\n                aNode = aNode.next;\r\n            }\r\n\r\n            if(bNode == null){\r\n                bNode = headA;\r\n            }else{\r\n                bNode = bNode.next;\r\n            }\r\n        }\r\n        return aNode;\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/11#issuecomment-2063976520","body":"思路：这是个数学题\r\n时间复杂度：On 空间复杂度O1\r\n\r\n```\r\npublic ListNode detectCycle(ListNode head) {\r\n        // 环形链表找环入口，经典公式：先fast和slow移动找到相遇点后，fast移动到链表头部，每次一步和slow同时走，再次相遇即为环入口\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        while(true){\r\n              if(fast == null || fast.next == null) return null;\r\n              fast = fast.next.next;\r\n              slow = slow.next;\r\n              if(fast == slow) break;\r\n        }\r\n\r\n        fast = head;\r\n        while(fast != slow){\r\n            fast=fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n\r\n```\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/14#issuecomment-2081726293","body":"思路：深度优先遍历代码比较简单一点；广度优先遍历，用队列也可以\r\n时间复杂度和空间复杂度都为：O(min(m,n))\r\n```\r\npublic boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if(p == null && q == null){\r\n            return true;\r\n        }\r\n        if(p == null || q == null){\r\n            return false;\r\n        }\r\n        if(p.val == q.val){\r\n            return  isSameTree(p.left,q.left) &&  isSameTree(p.right,q.right);\r\n        }\r\n        return false;\r\n    }\r\n```\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/15#issuecomment-2081757184","body":"时间复杂度: O(N)\r\n空间复杂度: O(N)，最大的高度为节点个数，所以空间复杂度也是On\r\n```\r\npublic int sumNumbers(TreeNode root) {\r\n            // 这道题感觉像直接深度遍历拿到所有的值之后再相加比较简单 不过应该可以直接后续遍历边加和的吧 测试验证之后发现后序不对，改用前序\r\n            // 这道题的重点在应该直接前序遍历保存当前已知的和preSum，然后preSum*10+子节点的数\r\n            return dfs1(root,0);\r\n        }\r\n        private int dfs1(TreeNode root,int preSum){\r\n            if(root == null){\r\n                return 0;\r\n            }\r\n            int sum = preSum*10+root.val;\r\n            // 如果叶子节点为空 就直接返回\r\n            if(root.left == null && root.right == null){\r\n                return sum;\r\n            }else{\r\n                //  获取叶子节点的和，左右叶子节点相加\r\n                return dfs1(root.left,sum) + dfs1(root.right,sum);\r\n            }\r\n        }\r\n```","onTime":false},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/22#issuecomment-2081415377","body":"时间复杂度O(n方)，空间复杂度O(n)\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int n = points.length;\n        // 这题自己的思路就是n^2的解法，以为答案会有点技术含量，结果答案也是如此，直接遍历一遍 双循环，把其他点到当前点的距离保存下来\n        // 需要关注的点是 利用hashMap降低时间复杂度，类似题目：560 和为K的子数组 1248 统计“优美子数组”\n        int res =0;\n        // 公式：因为题目求的是排列，A(a,b)=a!/(a-b)!,所以从m中选两个出来，排列数量为m！/(m-2)！= m*(m-1)\n        for(int i = 0; i < n; i++){\n            HashMap<Double,Integer> map = new HashMap<>(n);\n            int [] curPoint = points[i];\n            for(int j = 0; j < n; j++){\n                if(i != j){\n                    double dis = calDistance(points[j],curPoint);\n                    map.put(dis,map.getOrDefault(dis,0)+1);\n                }\n            }\n            for(double dis:map.keySet()){\n                int countDis = map.get(dis);\n                res += countDis*(countDis-1);\n            }\n        }\n        return res;\n    }\n\n    private double calDistance(int[] x,int []y) {\n        return Math.pow(x[0]-y[0],2)+Math.pow(x[1]-y[1],2);\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/23#issuecomment-2081716805","body":"思路：滑动窗口简单题\n时间复杂度：O(n)\n空间复杂度：O(n)\n``` \npublic int lengthOfLongestSubstring(String s) {\n        // 滑动窗口\n        HashMap<Character,Integer> window = new HashMap<>();\n        int len = 0,l = 0,r = 0;\n        while(r<s.length()){\n            char c = s.charAt(r);\n            r++;\n            window.put(c,window.getOrDefault(c,0)+1);\n            while(window.get(c)>1){\n                char left = s.charAt(l);\n                l++;\n                window.put(left,window.getOrDefault(left,0)-1);\n            }\n            // 这一段要放在外面 以保证最后的无重复子串也能参与\n            if(r-l >len){\n                len = r-l;\n            }\n        }\n        return len;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/24#issuecomment-2085399031","body":"class Solution {\n        public List<Integer> findSubstring(String s, String[] words) {\n            List<Integer> res = new ArrayList<>();\n            HashMap<String, Integer> need = new HashMap<>(words.length);\n            int wordSize = words[0].length();\n            int len = words.length * wordSize;\n            for (String w : words) {\n                need.put(w, need.getOrDefault(w, 0) + 1);\n            }\n\n            int n = s.length();\n            if (n < len) return res;\n\n            // 这道题有三个点没有考虑到，1 就是在需要循环wordSize次进行单词分割\n//            2 就是need不能--，只能window++  这样重新开始的时候need不用动，window直接clear就行（直接不用window而是用need--也可，但是理解上有点难度）\n//            3 就是一定right要先加加，出窗口用window和need对比判断，用while而不用if，这样valid==0的时候窗口不用再缩小了\n\n//           为啥循环wordSize次呢，因为循环到第wordSize+1次的时候，等价于i=0的时候情况\n            for (int i = 0; i < wordSize; i++) {\n                int right = i, left = i, valid = words.length;\n                HashMap<String, Integer> window = new HashMap<>(words.length);\n                // 如果right + wordSize已经大于n了 就说明right后的数量不足以构成word，直接结束\n                while (right + wordSize <= n) {\n                    String w = s.substring(right, right + wordSize);\n                    right += wordSize;\n\n                    if (need.containsKey(w)) {\n                        // 入窗口\n                        window.put(w, window.getOrDefault(w,0) + 1);\n                        valid--;\n                        // 用while循环出窗口，所以下面valid==0的时候就不用再滑出了\n                        // 这个while循环不写在下面valid==0的判断里是因为需要用到w\n                        while (window.getOrDefault(w, 0) > need.getOrDefault(w, 0)) {\n                            String leftString = s.substring(left, left + wordSize);\n                            window.put(leftString, window.get(leftString) - 1);\n                            valid++;\n                            left += wordSize;\n                        }\n                    } else {\n                        // 如果当前单词不在words中，直接从下一个单词的起始点开始，window和valid记得初始化\n                        left = right;\n                        window.clear();\n                        valid = words.length;\n                        continue;\n                    }\n\n                    if (valid == 0) {\n                        // 这里不用再滑出窗口，上面已经在while判读的时候滑出过了\n                        res.add(left);\n                        \n                    }\n                }\n            }\n            return res;\n        }\n    }\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/25#issuecomment-2087787200","body":"```\r\n public int minSubarray(int[] nums, int p) {\r\n            // 这道题一看就是要用前缀和S[]\r\n            // 下一步的重点在于推导取余公式：\r\n            // (A-B)%p=0当A和B都是非负数的时候相当于A%p = B%p； 当A<0 B>=0时 相当于A%p +p = B%p;两种情况合起来：(A%p +p)%p =B%p\r\n            // 设x为所有元素和\r\n            // 题目要求是找 （x%p -( s[i]%p -s[j]%p)）%p=0，其中i>=j\r\n            // 取模公式为 （X - SI+SJ)%p ==0 即 (SJ -(SI-X))%p = 0 套入取余公式，即 SJ%p = ((SI-X)%p+p)%p\r\n            // 也就是说 如果遍历到ii的时候，如果之前存在索引jj 其前缀和为(S[ii]-X)%p+p的，那么[jj,ii)就是题目所说去除的子数组\r\n            int n = nums.length, ans = n;\r\n            int s[] = new int[n + 1];\r\n            for (int i = 0; i < n; ++i){\r\n                // 前缀和直接取余\r\n                s[i + 1] = (s[i] + nums[i]) % p;\r\n            }\r\n            int x = s[n];\r\n            if (x == 0) return 0;\r\n\r\n            // map中key存储前缀和 value为索引\r\n            HashMap<Integer,Integer> last = new HashMap<Integer, Integer>();\r\n            for (int i = 0; i <= n; ++i) {\r\n                last.put(s[i], i);\r\n                // 如果不存在，-n 可以保证 i-j >= n\r\n                int j = last.getOrDefault((s[i] - x + p) % p, -n);\r\n                ans = Math.min(ans, i - j);\r\n            }\r\n            return ans < n ? ans : -1;\r\n        }\r\n```\r\n使用了hashMap 所以只需遍历一次，时间复杂度On 空间复杂度为On\r\n也可以直接一次遍历 计算前缀和的同时计算ans","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/29#issuecomment-2094835250","body":"时间复杂度：O(n)\n空间复杂度 ：单调栈只需要存k个值：O(k)\n```\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        // 这是一个滑动窗口+单调队列的题 处理单调队列 push的时候把之前所有比自己小的都移除\n        int[] res = new int[nums.length - k + 1];\n        MyQueue windowQueue = new MyQueue();\n        int j =0;\n        for (int i = 0; i < nums.length; i++) {\n            if(i<k-1){\n                windowQueue.push(nums[i]);\n            }else{\n                windowQueue.push(nums[i]);\n                res[j++]=windowQueue.getMax();\n                windowQueue.pop(nums[i-k+1]);\n            }\n        }\n       return res;\n    }\n    private class MyQueue{\n        LinkedList<Integer> queue = new LinkedList<>();\n\n        private void push(int val){\n            // 只有当前值大于之前的最大值的时候 才去除已有的最大值\n            // 相等的时候 不用换\n            while(!queue.isEmpty() && val >queue.peekLast()){\n                queue.pollLast();\n            }\n            queue.addLast(val);\n        }\n\n        private void pop(int val){\n            // 找队列的first 为当前最大值 如果val不是first，那就是已经pop了\n            // 注意一定记得加empty的判断\n            if(!queue.isEmpty() && val == queue.peekFirst()){\n                queue.pollFirst();\n            }\n        }\n\n        private int getMax(){\n            return queue.getFirst();\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/30#issuecomment-2096249339","body":"class Solution {\n    public int findJudge(int n, int[][] trust) {\n        // 这题理解起来很简单，重点在于如何遍历一次就把信息存储下来\n        // 官方解答就比较直白，遍历一遍，把每个人的入度和出度都保存下来 再遍历这两个入/出度数组 找入度为n-1 出度为0的人即可\n        int inDegree[] = new int[n];\n        int outDegree[] = new int[n];\n        for(int i = 0; i < trust.length; i++) {\n            int a = trust[i][0];\n            int b = trust[i][1];\n            inDegree[b-1]++;\n            outDegree[a-1]++;\n        }\n        for(int i = 0; i < n; i++) {\n            if(inDegree[i] == n-1 && outDegree[i] == 0){\n                return i+1;\n            }\n        }\n        return -1;\n//        return findJudge2(n, trust);\n    }\n\n    /**\n     * 写一下只用一个数组的实现\n     * @param n\n     * @param trust\n     * @return\n     */\n    public int findJudge2(int n, int[][] trust) {\n        // 因为总共就n个人，所以直接用一个长度为n的数组就行\n        int mixDegree[] = new int[n];\n        for(int i = 0; i < trust.length; i++) {\n            int a = trust[i][0];\n            int b = trust[i][1];\n            mixDegree[a-1]--;\n            mixDegree[b-1]++;\n        }\n        for(int i = 0; i < n; i++) {\n            // 全++ 无--  就是法官\n            if(mixDegree[i] == n-1){\n                return i+1;\n            }\n        }\n        return -1;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/31#issuecomment-2097882058","body":"'''\n'''\nclass Solution {\n        public boolean possibleBipartition(int n, int[][] dislikes) {\n            // 巧了 早上刚学了并查集 先写一下看看UF\n            // 这道题很明显是一个并查集的应用题 先处理一下dislikes数组，把dislikes[i][0]和dislikes[i][1]先union起来，再把同一个人的不喜欢的人数组遍历一遍，判断是否有connected\n            UF myUf = new UF(n);\n\n            // nums的value是List，存储索引对应的不喜欢的人,所以索引从1开始\n            List<Integer>[] nums = new List[n + 1];\n            // 别忘了初始化\n            for (int i = 0; i <= n; ++i) {\n                nums[i] = new ArrayList<Integer>();\n            }\n            for (int item[] : dislikes) {\n                int a = item[0];\n                int b = item[1];\n\n                // 在a和b对应的list中添加对方\n                nums[a].add(b);\n                nums[b].add(a);\n            }\n\n            for (int i = 1; i <= n; i++) {\n                List<Integer> list = nums[i];\n                for (int j = 0; j < list.size(); j++) {\n                    // 连接在同一个数组中的人，注意连接是一体的，无需两两单独互相连接\n                    myUf.union(list.get(0), list.get(j));\n                    // 如果当前数组中的人和自己不喜欢的人（索引值）相连，就返回false\n                    if (myUf.connected(list.get(j), i)) {\n                        return false;\n                    }\n\n                }\n            }\n            return true;\n        }\n\n        class UF {\n            private int count;\n            private int parent[];\n\n            public UF(int n) {\n                parent = new int[n+1];\n                for (int i = 0; i <= n; i++) {\n                    parent[i] = i;\n                }\n                count = n;\n            }\n\n            public int getUFCount() {\n                return count;\n            }\n\n            public int findRoot(int x) {\n                // 注意回溯的话要用if。循环的话要用while\n               /* if (parent[x] != x) {\n                    parent[x] = findRoot(parent[x]);\n                }\n                return parent[x];*/\n                while (parent[x] != x) {\n                    // 进行路径压缩\n                    parent[x] = parent[parent[x]];\n                    x = parent[x];\n                }\n                return x;\n            }\n\n            public void union(int a, int b) {\n                int rootA = findRoot(a);\n                int rootB = findRoot(b);\n                if (rootA == rootB) {\n                    return;\n                }\n                parent[rootA] = rootB;\n\n                // 别忘了count--\n                count--;\n            }\n\n            public boolean connected(int a, int b) {\n                return findRoot(a) == findRoot(b);\n            }\n        }\n    }","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/33#issuecomment-2103658669","body":"简单模拟题，时间复杂度：On 空间复杂度 O1\r\n```\r\n public boolean judgeCircle(String moves) {\r\n        int x =0, y = 0;\r\n        for (int i = 0; i < moves.length(); i++) {\r\n            if(moves.charAt(i) == 'U') {\r\n                y++;\r\n            }else if(moves.charAt(i) == 'D') {\r\n                y--;\r\n            }else if(moves.charAt(i) == 'L') {\r\n                x--;\r\n            }else if(moves.charAt(i) == 'R') {\r\n                x++;\r\n            }\r\n        }\r\n        return x == 0 && y == 0;\r\n    }\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/34#issuecomment-2103687204","body":"优先级队列的排序时间复杂度nlogn；for循环为n，队列操作为logn，故时间复杂度为nlogn\r\n空间复杂度为n\r\n```\r\n public int[] getOrder(int[][] tasks) {\r\n        // 这一个模拟题，重点在于如何排序，必须要先按照开始时间进行排序 按此顺序将任务入队列执行，在此基础上，优先级队列要按照持续时间+任务索引排序\r\n        int n = tasks.length;\r\n        // 用mix三维数组保存任务编号\r\n        int mix[][] = new int[n][3];\r\n        for(int i =0;i<n;i++){\r\n            int[] task = tasks[i];\r\n            mix[i] = new int[]{task[0],task[1],i};\r\n        }\r\n        // 先按照任务开始时间升序 后面按照开始时间顺序入队列\r\n        Arrays.sort(mix,(a,b)->a[0]-b[0]);\r\n        // 优先级队列排序：持续时间+任务编号\r\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->{\r\n            if(a[1]!=b[1]){\r\n                return a[1]-b[1];\r\n            }\r\n            return a[2]-b[2];\r\n        });\r\n\r\n        // i为mix索引，time表示当前执行到了啥时候，index表示结果集res的索引\r\n        int i =0,time =1;\r\n        int res[] = new int[n];\r\n        for(int index =0;index<n;){\r\n            // 满足开始时间小于等于当前时间的，都可以入队列\r\n            while(i<n && mix[i][0]<= time){\r\n                pq.add(mix[i++]);\r\n            }\r\n            // 如果队列为空，那么没有任何任务可以在当前时间之前执行\r\n            if(pq.isEmpty()){\r\n                time = mix[i][0];\r\n            }else{\r\n                int[] cur = pq.poll();\r\n                res[index++] = cur[2];\r\n                // 时间增加当前任务的持续时间\r\n                time+= cur[1];\r\n            }\r\n\r\n        }\r\n        return res;\r\n    }\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/36#issuecomment-2106205546","body":"//时间复杂度：统计词频的复杂度为 O(n+m)，统计答案的复杂度为 O(C^2)，其中 C=26 为字符集大小\r\n    //空间复杂度：O(C)\r\n```\r\n public int minCharacters(String a, String b) {\r\n        // 枚举三种情况 找出最少操作次数\r\n        // 1. 假设有个字符为x，则a中字符都得小于x，b中字符都要大于等于x\r\n        // 2. a>=x,b<x\r\n        // 3。 a==x，b也等于x\r\n        // 为了快速枚举出所有的情况，可先把a和b中的字符出现次数存储下来\r\n        int m  = a.length();\r\n        int n = b.length();\r\n        int []aArr = new int[26];\r\n        int bArr[] = new int[26];\r\n\r\n        for (int i = 0; i < m; i++) {\r\n            aArr[a.charAt(i) - 'a'] ++;\r\n        }\r\n        for (int i = 0; i < n; i++) {\r\n            bArr[b.charAt(i) - 'a'] ++;\r\n        }\r\n\r\n\r\n        int res = Integer.MAX_VALUE;\r\n        // 枚举所有的x，统计操作数\r\n        for(int x = 0;x<26;x++){\r\n\r\n            // 特殊的，不存在任何字符严格小于'a' 所以要跳过\r\n            if(x !=0){\r\n                // 情况1的操作数为：\r\n                int count1=0;\r\n                for(int i=x;i<26;i++){\r\n                    // 把a中比x大或者等的字符都操作一下\r\n                    count1+=aArr[i];\r\n                }\r\n                for(int i=0;i<x;i++){\r\n                    count1+=bArr[i];\r\n                }\r\n\r\n                // 情况2的操作数\r\n                int count2=0;\r\n                for(int i=0;i<x;i++){\r\n                    // 把a中比x小的字符都操作一下\r\n                    count2+=aArr[i];\r\n                }\r\n                for(int i=x;i<26;i++){\r\n                    // 把b中比x大的字符都操作一下\r\n                    count2+=bArr[i];\r\n                }\r\n\r\n                res = Math.min(Math.min(count1,count2),res);\r\n            }\r\n\r\n            // 情况3，将a和b中的字符全都变成x\r\n            int count3 = (m-aArr[x])+(n-bArr[x]);\r\n\r\n            res = Math.min(res,count3);\r\n        }\r\n        return res;\r\n    }\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/39#issuecomment-2112743598","body":"简单二分查找 时间复杂度 logn 空间复杂度 o(1)\nclass Solution {\npublic:\n    int firstBadVersion(int n) {\n        int left = 1;\n        int right = n;\n        \n        int ans = -1;\n        while (left <= right) {\n            int mid = (right-left)/2 + left;\n            if (isBadVersion(mid)) {\n                ans = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        \n        return ans;\n    }\n};","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/44#issuecomment-2119575165","body":"时间复杂度On\n空间复杂度 O1\nclass Solution {\n    public int maxVowels(String s, int k) {\n        // 很明显这是一个滑动窗口的题目，练手写一下试试\n        // 简单一点，直接判断去掉的那个字符是不是元音即可\n        int maxVowels =0;\n        for(int i =0;i<k;i++){\n            maxVowels += isVowel(s.charAt(i))?1:0;\n        }\n        int res = maxVowels;\n        for(int i=k;i<s.length();i++){\n            int isLeftVowel = isVowel(s.charAt(i-k))?1:0;\n            int isRightVowel = isVowel(s.charAt(i))?1:0;\n            maxVowels +=  isRightVowel - isLeftVowel;\n            res = Math.max(res,maxVowels);\n        }\n        return res;\n\n//        HashMap<Character, Integer> window = new HashMap<>();\n        /*int maxVowels = 0;\n        int right = 0,left = 0;\n        int valid = 0;\n        while (right < s.length()) {\n            char ch = s.charAt(right);\n            right++;\n//            window.put(ch, window.getOrDefault(ch, 0) + 1);\n            if(isVowel(ch)){\n                valid++;\n            }\n            if(right-left>=k){\n                if(valid>maxVowels){\n                    maxVowels = valid;\n                }\n                if(valid==k){\n                    return k;\n                }\n                char leftChar = s.charAt(left);\n                left++;\n//                window.put(ch, window.getOrDefault(leftChar, 0) - 1);\n                if(isVowel(leftChar)){\n                    valid--;\n                }\n            }\n        }\n        return maxVowels;*/\n    }\n    private boolean isVowel(char ch){\n        return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u';\n    }\n}","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/48#issuecomment-2128345709","body":" 时间复杂度：令 n 和 m 分别为 houses 和 heaters 长度，L=1e9 为最大长度，对其进行排序复杂度为 O(nlogn+mlogm)，在 [0,L] 范围进行二分，单次 check 会使用「双指针」判断是否每个 houses[i] 是否被覆盖，复杂度为 O(max(n,m)∗logL)。整体复杂度为O(max(n,m)∗logL)\r\n空间复杂度：排序所需要消耗的空间。复杂度为O(logn+logm)\r\n```\r\n public int findRadius(int[] houses, int[] heaters) {\r\n        // 乍一看的思路就是排序后挨个判断 找第一个最小加热半径 然后看后面的还有没有更大的，时间复杂度应该是大于ON\r\n        // 答案解法是二分法 其实正常应该立马想到的，一个数值问题 又是最值，直接考虑二分\r\n        Arrays.sort(houses);\r\n        Arrays.sort(heaters);\r\n        int m=houses.length;\r\n        // 边界取错了，最大会比hourse的最大值还大 以后直接取题目范围准没错\r\n//        int max = houses[m-1];\r\n        int max =(int)1e9;\r\n        int left =0,right = max;\r\n        while(left < right){\r\n            int mid = left + (right - left)/2;\r\n            if(checkOk(houses,heaters,mid)){\r\n                // 如果check成功 半径缩小\r\n                right = mid;\r\n            }else {\r\n                left = mid+1;\r\n            }\r\n        }\r\n        // 返回此时满足checkOk最小加热半径,此时left=right 返回哪个都可\r\n        return left;\r\n//        return left==max?-1:left;\r\n    }\r\n    // 这里直接判断以x为半径是不是能全部覆盖更容易理解\r\n    private boolean checkOk(int[] houses, int[] heaters,int radius) {\r\n        int m=houses.length;\r\n        int n = heaters.length;\r\n        int j =0;\r\n        for(int i = 0;i<m;i++){\r\n            while(j<n && houses[i]>heaters[j]+radius){\r\n                j++;\r\n            }\r\n            if(j<n && houses[i]<=heaters[j]+radius\r\n                    && houses[i]>=heaters[j]-radius){\r\n                continue;\r\n            }else{\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/52#issuecomment-2134214345","body":"时间复杂度 O(n^4) 空间复杂度：队列大小：O(n^2)\r\n```\r\n public int maxDistance(int[][] grid) {\r\n        // 这个上来一看 哎暴力解法好像可以 每个0最近的1遍历一遍 求最小值，不过可能时间复杂度高了点\r\n        // 妙：类似于310最小高度数 是一个BFS的应用题 先把1放进去，然后遍历所有的他的邻接点0 更新后再加入queue 就是一圈一圈的遍历所有1周围的0 这样每个最远的0一定是被离他最近的1遍历到的\r\n        // 还有一种利用dijkstra求“多源最短路径”的 回头记得看一下\r\n\r\n        // 队列中放当前坐标值\r\n        Queue<int[]> queue = new LinkedList<>();\r\n        for(int i = 0; i < grid.length; i++){\r\n            for(int j = 0; j < grid[0].length; j++){\r\n                if(grid[i][j] == 1){\r\n                    queue.offer(new int[]{i, j});\r\n                }\r\n            }\r\n        }\r\n        if(queue.isEmpty()){\r\n            return -1;\r\n        }\r\n\r\n        boolean hasOcean = false;\r\n        int[] finalPoint = new int[2];\r\n        while(!queue.isEmpty()){\r\n            int[] poll = queue.poll();\r\n            int x = poll[0], y = poll[1];\r\n            finalPoint[0] = x;\r\n            finalPoint[1] =y;\r\n            int dir[][] = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\r\n            for(int dirr[]:dir){\r\n                int nx = x + dirr[0], ny = y + dirr[1];\r\n                if(isLegal(grid,nx,ny) && grid[nx][ny] == 0){\r\n                    hasOcean = true;\r\n                    // 直接更新原数组 所以可以不用判断是否访问 while循环会自动结束\r\n                   grid[nx][ny] = 1+grid[x][y];\r\n                   // 把更新后的节点加入队列，等待下一圈的更新\r\n                   queue.offer(new int[]{nx, ny});\r\n                }\r\n            }\r\n        }\r\n        if(!hasOcean){\r\n            return -1;\r\n        }\r\n        // 队列中最后一个元素 就是距离1最近的最远0\r\n        return grid[finalPoint[0]][finalPoint[1]] -1;\r\n    }\r\n    private boolean isLegal(int[][] grid, int x, int y){\r\n        return x >= 0 && x < grid.length && y >= 0 && y < grid[0].length;\r\n    }\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/55#issuecomment-2142530006","body":"class Solution {\n    public int minCostClimbingStairs(int[] cost) {\n       /* int n = cost.length;\n        int memo[] = new int[n];\n        Arrays.fill(memo,-1);\n        memo[0] = cost[0];\n        memo[1] = cost[1];\n        dfs(cost,n-1,memo);\n        return Math.min(memo[n-1],memo[n-2]);*/\n        return dp1(cost);\n    }\n\n    private int dfs(int[] cost,int i,int []memo){\n        if(memo[i] != -1) return memo[i];\n        if(i == 0){\n            return memo[i];\n        }\n        if(i == 1){\n            return memo[i];\n        }\n        memo[i] = Math.min(dfs(cost,i-1,memo),dfs(cost,i-2,memo))+cost[i];\n        return memo[i];\n    }\n\n    /**\n     * 再来根据dfs写一下动规\n     * @param cost\n     * @return\n     */\n    private int dp1(int []cost){\n        int n = cost.length;\n        int dp[] = new int[n];\n        dp[0] = cost[0];\n        dp[1] = cost[1];\n        for(int i = 2;i<n;i++){\n            dp[i] = Math.min(dp[i-1],dp[i-2])+cost[i];\n        }\n        return Math.min(dp[n-1],dp[n-2]);\n    }\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/58#issuecomment-2144106674","body":"class Solution {\n        public int longestCommonSubsequence(String text1, String text2) {\n            // 最长公共子序列很明显也是个动规的经典题型 有重复 有最优解 有递归\n            int x = text1.length();\n            int y = text2.length();\n            // dp[i][j]表示text1[0到i]和text2[0到j]之间的最长公共子序列的长度\n            // 那么dp[0][0]、dp[i][0]、dp[0][j]就是0。题目所求即为dp[x][y]，初始化就需要长度+1\n            int dp[][] = new int[x + 1][y + 1];\n\n            // i 和j要从1开始，取其减1之后dp值\n            for (int i = 1; i <= x; i++) {\n                char c = text1.charAt(i-1);\n                for (int j = 1; j <= y; j++) {\n                    char c1 = text2.charAt(j-1);\n                    if (c == c1) {\n                        dp[i][j] = dp[i - 1][j - 1] + 1;\n                    } else {\n                        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                    }\n                }\n            }\n            return dp[x][y];\n        }\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/59#issuecomment-2146331684","body":"时间复杂度和空间复杂度均为Omn\n经典动归题，优化空间后:\n\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        int[] f = new int[n];\n        for (int i = 0; i < n; ++i) {\n            f[i] = 1;\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                f[j] += f[j - 1];\n            }\n        }\n        return f[n - 1];\n    }\n}\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/65#issuecomment-2156980593","body":"经典完全背包问题\nclass Solution {\n    public int change(int amount, int[] coins) {\n        int[] f = new int[amount + 1];\n        f[0] = 1;\n        for (int x : coins) {\n            for (int c = x; c <= amount; c++) {\n                f[c] += f[c - x];\n            }\n        }\n        return f[amount];\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/66#issuecomment-2161801142","body":"```\r\n class Solution {\r\n        public int findContentChildren(int[] g, int[] s) {\r\n            // 思路：先两个都排序 然后只要s>g就可以分配\r\n            // 时间复杂度：排序的时间复杂度 NLogN（N为g和s长度的较大值）\r\n            // 空间复杂度：O1\r\n            Arrays.sort(g);\r\n            Arrays.sort(s);\r\n            int j = 0;\r\n            int i = 0;\r\n            for (; i < g.length && j < s.length; ) {\r\n                if (g[i] <= s[j]) {\r\n                    i++;\r\n                }\r\n                j++;\r\n            }\r\n            return i;\r\n        }\r\n    }\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/67#issuecomment-2161843612","body":"```\r\npublic int eraseOverlapIntervals(int[][] intervals) {\r\n        // 思路：直接按照第一位从小到大排序 然后逐个对比，如果第一位相同 移除距离最长的区间；两两比较，移除有重叠的第二位较大的那个区间\r\n        // 时间复杂度：nLongn 空间复杂度：排序所需的空间复杂度（On或者nOlogn）\r\n        /*Arrays.sort(intervals,(a,b)->a[0]-b[0]);\r\n        int count=0;\r\n        for(int i=1;i<intervals.length;i++){\r\n            if(intervals[i][0]<intervals[i-1][1]){\r\n                count++;\r\n                // 如果当前第二位大于前一个数的第二位,就删除当前值，拿前一个数和下一个数继续比较\r\n                if(intervals[i][1]>intervals[i-1][1]){\r\n                    intervals[i][1]=intervals[i-1][1];\r\n                }\r\n            }\r\n        }\r\n        return count;*/\r\n// 方法2\r\n        return erase1(intervals);\r\n    }\r\n // 按照右端点排序，找构成不重叠区间的个数，n-此个数就是所求解\r\n    private int erase1(int[][] intervals){\r\n        if (intervals.length == 0) {\r\n            return 0;\r\n        }\r\n\r\n        Arrays.sort(intervals, new Comparator<int[]>() {\r\n            public int compare(int[] interval1, int[] interval2) {\r\n                return interval1[1] - interval2[1];\r\n            }\r\n        });\r\n\r\n        int n = intervals.length;\r\n        int right = intervals[0][1];\r\n        int ans = 1;\r\n        for (int i = 1; i < n; ++i) {\r\n            if (intervals[i][0] >= right) {\r\n                ++ans;\r\n                right = intervals[i][1];\r\n            }\r\n        }\r\n        return n - ans;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/68#issuecomment-2164004445","body":"思路：只要每次跳到的最大值>=当前索引,就可以继续往后，同时判断是否到达终点；否则就说明无法继续跳，返回false\r\n时间/空间复杂度：O1\r\n```\r\nprivate boolean canJump2(int[] nums) {\r\n        int n = nums.length;\r\n        int maxRight = 0;\r\n        for(int i =0;i<n;i++) {\r\n            // 先判断maxRight小于i了没，如果没有才可以继续更新maxRight的值，不可反过来先更新maxRight再判断\r\n            if(i >maxRight){\r\n                return false;\r\n            }\r\n            maxRight = Math.max(maxRight,i+nums[i]);\r\n            if(maxRight >= n - 1) {\r\n                return true;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/69#issuecomment-2166996649","body":"时间复杂度 O(n^2) 空间复杂度On\r\n```\r\npublic int numTrees(int n) {\r\n            // 没想到吧 这是一个递归题，当n=5 root为3时，左子树为1和2构成，右子树由45构成，可能的结果就是count(1,2)*count(3,4)\r\n            // 递归记得加备忘录\r\n            memo = new int[n+1][n+1];\r\n            return traverse(1, n);\r\n        }\r\n\r\n        int memo[][];\r\n\r\n\r\n        private int traverse(int start, int end) {\r\n            if (start > end) {\r\n                return 1;\r\n            }\r\n            if(memo[start][end] != 0){\r\n                return memo[start][end];\r\n            }\r\n            int res = 0;\r\n            for (int i = start; i <= end; i++) {\r\n                // 以当前i节点为root的时候的情况：\r\n                int leftCount = traverse(start, i - 1);\r\n                int rightCount = traverse(i + 1, end);\r\n\r\n                res += leftCount * rightCount;\r\n            }\r\n            memo[start][end] = res;\r\n            return res;\r\n        }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/70#issuecomment-2168955214","body":"类似归并排序，时间复杂度为O（n*klogk） 空间复杂度为递归栈的复杂度：O(logk)\r\n```\r\npublic ListNode mergeKLists(ListNode[] lists) {\r\n        if(null == lists || lists.length == 0){\r\n            return null;\r\n        }\r\n        return mergeK(lists,0,lists.length-1);\r\n    }\r\n    private ListNode mergeK(ListNode[] lists,int l,int r){\r\n        if(l == r){\r\n            return lists[l];\r\n        }\r\n        int mid =(l+r)>>1;\r\n        ListNode lNode = mergeK(lists,l,mid);\r\n        ListNode rNode = mergeK(lists,mid+1,r);\r\n        return mergeTwo(lNode,rNode);\r\n    }\r\n    private ListNode mergeTwo(ListNode a,ListNode b){\r\n        if(null == a){\r\n            return b;\r\n        }\r\n        if(null == b){\r\n            return a;\r\n        }\r\n        ListNode dummy = new ListNode(-1);\r\n        ListNode cur = dummy;\r\n        while(a != null && b!= null){\r\n            if(a.val < b.val){\r\n                cur.next = a;\r\n                a = a.next;\r\n            }else{\r\n                cur.next = b;\r\n                b = b.next;\r\n            }\r\n            cur = cur.next;\r\n        }\r\n        if(a != null){\r\n            cur.next = a;\r\n        }\r\n        if(b != null){\r\n            cur.next = b;\r\n        }\r\n        return dummy.next;\r\n    }\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/73#issuecomment-2174725319","body":"时间复杂度：O(n*2^n) 空间On\r\n```\r\n public List<List<Integer>> subsets(int[] nums) {\r\n         getZiji(nums,0,new ArrayList<>());\r\n         return res;\r\n    }\r\n    List<List<Integer>> res = new ArrayList<>();\r\n    \r\n    private void getZiji(int[] nums,int start,List<Integer> track){\r\n        res.add(new ArrayList<>(track));\r\n        for(int i = start;i<nums.length;i++){\r\n            track.add(nums[i]);\r\n            getZiji(nums,i+1,track);\r\n            track.remove(track.size()-1);\r\n        }\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/74#issuecomment-2177290511","body":"```\r\nclass Trie {\r\n    Trie[] children;\r\n    int val;\r\n    public Trie() {\r\n        children = new Trie[26];\r\n        val = -1;\r\n    }\r\n    \r\n    public void insert(String word) {\r\n        Trie cur = this;\r\n        for(char c:word.toCharArray()){\r\n            if(cur.children[c-'a'] == null){\r\n                cur.children[c-'a'] = new Trie();\r\n            }\r\n            cur = cur.children[c-'a'];\r\n        }\r\n        // 只有结尾处有val值\r\n        cur.val = 1;\r\n    }\r\n    \r\n    public boolean search(String word) {\r\n        return startWithPrefix(word) != null && startWithPrefix(word).val != -1;\r\n    }\r\n    \r\n    public boolean startsWith(String prefix) {\r\n        return startWithPrefix(prefix) != null;\r\n    }\r\n\r\n    private Trie startWithPrefix(String pre){\r\n        Trie cur = this;\r\n        for(char c:pre.toCharArray()){\r\n            if(cur.children[c-'a'] == null){\r\n                return null;\r\n            }\r\n            cur=cur.children[c-'a'];\r\n        }\r\n        return cur;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/75#issuecomment-2179631452","body":"思路：前缀树+DFS实现\r\n```\r\nclass MapSum {\r\n        Trie cur;\r\n\r\n        public MapSum() {\r\n            cur = new Trie();\r\n        }\r\n\r\n        public void insert(String key, int val) {\r\n            cur.insert(key, val);\r\n        }\r\n\r\n        public int sum(String prefix) {\r\n            return cur.sum(prefix);\r\n        }\r\n\r\n        class Trie {\r\n            Trie[] children;\r\n            int val;\r\n\r\n            public Trie() {\r\n                children = new Trie[26];\r\n                val = -1;\r\n            }\r\n\r\n            public void insert(String key, int val) {\r\n                Trie cur = this;\r\n                for (int i = 0; i < key.length(); i++) {\r\n                    char c = key.charAt(i);\r\n                    if (cur.children[c - 'a'] == null) {\r\n                        cur.children[c - 'a'] = new Trie();\r\n                    }\r\n                    cur = cur.children[c - 'a'];\r\n                }\r\n                cur.val = val;\r\n            }\r\n\r\n            public Trie startsWith(String prefix) {\r\n                Trie cur = this;\r\n                for (int i = 0; i < prefix.length(); i++) {\r\n                    char c = prefix.charAt(i);\r\n                    if (cur.children[c - 'a'] == null) {\r\n                        return null;\r\n                    }\r\n                    cur = cur.children[c - 'a'];\r\n                }\r\n                return cur;\r\n            }\r\n\r\n            public int sum(String prefix) {\r\n                Trie trie = startsWith(prefix);\r\n                if (trie == null) {\r\n                    return 0;\r\n                }\r\n                return getSum(trie);\r\n            }\r\n\r\n            // 递归获取当前节点后续所有key的sum\r\n            private int getSum(Trie trie) {\r\n                if (trie == null) {\r\n                    return 0;\r\n                }\r\n                int res = trie.val == -1 ? 0 : trie.val;\r\n                for (Trie child : trie.children) {\r\n                    if (child != null) {\r\n                        res += child.getSum(child);\r\n                    }\r\n                }\r\n                return res;\r\n            }\r\n        }\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/76#issuecomment-2181796343","body":"```\r\nclass Solution {\r\n    public int[][] multiSearch(String big, String[] smalls) {\r\n        // 思路：将smalls中的字符串构建出一个前缀树 写一个search(word)方法 查询树中是否有word的前缀 并将其返回\r\n        // 这个和之前的实现前缀树的不同点在于\r\n        // 之前是startWithPrefix判断树中是否有字符串的前缀为prefix；这次是要返回树中word的所有前缀，并且树节点的val存储树中字符串值\r\n        Trie root = new Trie();\r\n        for (String word : smalls) {\r\n            root.insert(word);\r\n        }\r\n        // resMap存储每个smalls中word在target中的开始索引值们\r\n        Map<String, List<Integer>> resMap = new HashMap();\r\n        int n = big.length();\r\n        for (int i = 0; i < n; i++) {\r\n            String target = big.substring(i);\r\n            List<String> prefixs = root.searchPrefixListOfTarget(target);\r\n            for (String word : prefixs) {\r\n                // 为啥getOrDefault没用\r\n                // resMap.getOrDefault(word, new ArrayList()).add(i);\r\n                if(!resMap.containsKey(word)){\r\n                    resMap.put(word, new ArrayList<>());\r\n                }\r\n                resMap.get(word).add(i);\r\n            }\r\n        }\r\n\r\n        // 把resMap转成对应的数组\r\n        // 不能直接初始化res长度为new int[smalls.length][n] 不然就会被赋初始值0\r\n        int[][] res = new int[smalls.length][];\r\n        for (int i = 0; i < smalls.length; i++) {\r\n            String word = smalls[i];\r\n            List<Integer> indexs = resMap.get(word);\r\n            if (indexs == null || indexs.size() == 0) {\r\n                res[i] = new int[0];\r\n                continue;\r\n            }\r\n            int j = 0;\r\n            res[i] = new int[indexs.size()];\r\n            for (int index : indexs) {\r\n                res[i][j++] = index;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n    class Trie {\r\n        String val;\r\n        Trie[] child;\r\n\r\n        public Trie() {\r\n            child = new Trie[26];\r\n        }\r\n\r\n\r\n        void insert(String word) {\r\n            Trie cur = this;\r\n            for (char c : word.toCharArray()) {\r\n                if (cur.child[c - 'a'] == null) {\r\n                    cur.child[c - 'a'] = new Trie();\r\n                }\r\n                cur = cur.child[c - 'a'];\r\n            }\r\n            // 节点中存储word字符串\r\n            cur.val = word;\r\n        }\r\n\r\n        // 获取 在target中是前缀的当前树中的字符串\r\n        List<String> searchPrefixListOfTarget(String target) {\r\n            Trie cur = this;\r\n            List<String> res = new ArrayList();\r\n            for (char c : target.toCharArray()) {\r\n                // 如果发现前缀不匹配了 直接break\r\n                if (cur.child[c - 'a'] == null) {\r\n                    break;\r\n                }\r\n                cur = cur.child[c - 'a'];\r\n                if (cur.val != null && cur.val != \"\") {\r\n                    res.add(cur.val);\r\n                }\r\n            }\r\n            return res;\r\n        }\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/82#issuecomment-2193886211","body":"class Solution {\r\n        List<List<Integer>> res = new ArrayList<>();\r\n\r\n        public List<List<Integer>> combinationSum2(int[] candidates, int target) {\r\n            if (null == candidates || candidates.length == 0) return res;\r\n            // 排序和下面的判断nums[i-1] == nums[i] 是为了去除由于nums中的重复数据导致的结果重复\r\n            Arrays.sort(candidates);\r\n            getCombine2(candidates, 0, target);\r\n            return res;\r\n        }\r\n\r\n        List<Integer> track = new ArrayList<>();\r\n\r\n        private void getCombine2(int[] nums, int start, int target) {\r\n            if (target == 0) {\r\n                res.add(new ArrayList<>(track));\r\n                return;\r\n            }\r\n            if (target < 0) {\r\n                return;\r\n            }\r\n            for (int i = start; i < nums.length; i++) {\r\n                if (i > start && nums[i] == nums[i - 1]) {\r\n                    continue;\r\n                }\r\n                track.add(nums[i]);\r\n                getCombine2(nums, i + 1, target - nums[i]);\r\n                track.remove(track.size() - 1);\r\n            }\r\n        }\r\n    }","onTime":true},null,null,null,null,null,null,null,null,null,null],"lxy1108":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/5#issuecomment-2051393283","body":"### 实现思路\n通过两个栈来实现，一个栈用来读取，另一个栈用来做缓存。在push的时候将现有的内容先转移到缓存栈里，将新元素放到读取栈最底端后，再把缓存栈里的数据放回来。\n\n### python 3代码\nclass MyQueue:\n\n    def __init__(self):\n        self.queue = collections.deque([])\n        self.cache = collections.deque([])\n\n    def push(self, x: int) -> None:\n        while self.queue:\n            n = self.queue.pop()\n            self.cache.append(n)\n        self.queue.append(x)\n        while self.cache:\n            n = self.cache.pop()\n            self.queue.append(n)\n\n\n    def pop(self) -> int:\n        return self.queue.pop()\n\n    def peek(self) -> int:\n        return self.queue[-1]\n\n    def empty(self) -> bool:\n        return len(self.queue)==0\n\n\n### 复杂度分析\n空间复杂度为O(N)，时间复杂度push为O(N)，其他操作为O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/7#issuecomment-2058954421","body":"#### 思路\n首先遍历一遍链表，得到链表的长度和链表的尾节点；\n再次从头遍历链表，指针停在旋转后链表的尾节点，然后进行链表后续节点的重新分配\n\n#### python3代码\n```\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        p = head\n        count = 0\n        while p:\n            tail = p\n            p = p.next\n            count+=1\n        k = k % count\n        if k==0:\n            return head\n        p = head\n        ind = 0\n        while p and ind<count-k-1:\n            p = p.next\n            ind += 1\n        newhead = p.next\n        p.next = None\n        tail.next = head\n        return newhead\n```\n\n#### 复杂度分析\n时间复杂度O(n)，因为需要从头遍历链表\n空间复杂度O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/8#issuecomment-2056379378","body":"**思路**\n采用迭代的方式，每次迭代交换当前指针后面的两个节点，直到当前指针后面的节点不足两个循环停止\n\n**Python3 代码**\n\n```\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prehead = ListNode(0)\n        prehead.next = head\n        cur = prehead\n        while cur.next and cur.next.next:\n            node1 = cur.next\n            node2 = node1.next\n            node3 = node2.next\n            node2.next = node1\n            cur.next = node2\n            node1.next = node3\n            cur = node1\n        return prehead.next\n```\n\n**复杂度分析**\n时间复杂度O(n)，即为循环执行次数，n为节点个数\n空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/9#issuecomment-2058581121","body":"### 思路\n首先将链表转换为数组，方便后续直接访问元素。采用递归的方式构建树，由于需要构建平衡二叉树，因此树的根节点为有序数组的中间元素。\n\n### 代码\n```\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        nums = []\n        p = head\n        while p:\n            nums.append(p.val)\n            p = p.next\n        def genTree(nums):\n            if not nums:\n                return None\n            root_idx = len(nums)//2\n            root = TreeNode(nums[root_idx])\n            root.left = genTree(nums[:root_idx])\n            root.right = genTree(nums[root_idx+1:])\n            return root\n        return genTree(nums)\n```\n\n### 复杂度分析\n\n空间复杂度O(n),因为创建了一个新的数组\n\n时间复杂度O(ln)，因为遍历了一遍链表","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/10#issuecomment-2060254797","body":"#### 思路\n先遍历list A并利用hashmap存储节点，再遍历list B并在遍历过程中检查当前节点是否在hashmap里，如果有则为交点，否则没有交点\n\n#### python3代码\n\n```\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        nodesa = set()\n        pointera = headA\n        while pointera:\n            nodesa.add(pointera)\n            pointera = pointera.next\n        pointerb = headB\n        while pointerb:\n            if pointerb in nodesa:\n                return pointerb\n            pointerb = pointerb.next\n        return None\n```\n\n#### 复杂度分析\n\n空间复杂度 O(N)，因为额外开辟了空间用来存储其中一个链表的节点\n时间复杂度 O(N)，因为需要遍历链表","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/11#issuecomment-2063456967","body":"#### 思路\n采用快慢指针，通过是否存在交点判断是否有环；若有环再引入一个指针从头开始和慢指针一起遍历，二者交点即为环的开始点\n#### python3代码\n```\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None:\n            return None\n        fast, slow = head, head\n        point = None\n        while fast.next and fast.next.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                point = fast\n                break\n        if point is None:\n            return None\n        slow = head\n        fast = point\n        while slow!=fast:\n            slow = slow.next\n            fast = fast.next\n        return slow\n```\n\n#### 复杂度分析\n\n空间复杂度O(1) 没有开辟额外空间\n时间复杂度O(N) 因为需要遍历链表","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/13#issuecomment-2067628657","body":"#### 思路\n采用层次遍历，每次循环遍历该层节点并将该层节点的子节点加入队列中，循环过程中记录层数，即为最大深度\n\n#### python3代码\n```\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n        queue = collections.deque([root])\n        height = 0\n        while queue:\n            height+=1\n            q_tmp = []\n            for node in queue:\n                if node.left:\n                    q_tmp.append(node.left)\n                if node.right:\n                    q_tmp.append(node.right)\n            queue=q_tmp\n        return height\n```\n\n#### 复杂度分析\n时间复杂度O(N)，因为需要遍历树\n空间复杂度取决于树的结构，最坏情况为O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/14#issuecomment-2067966290","body":"#### 思路\n递归的方式检测两树是否相同，递归方法中首先检查两树是否同为空，然后检查两树根节点值是否相同，以及左子树和右子树是否都相同。\n\n#### python3代码\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val==q.val:\n            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\n        return False\n```\n\n#### 复杂度分析\n时间复杂度：O(min⁡(m,n))，其中 m 和 n 分别是两个二叉树的节点数\n空间复杂度：O(min⁡(m,n))，其中 m 和 n 分别是两个二叉树的节点数。空间复杂度取决于递归栈调用层数，即为较小二叉树的深度，最坏情况下为该树的节点数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/15#issuecomment-2068741753","body":"#### 思路\n深度遍历树的同时记录经过的节点值，在遇到叶子节点时计算由该条路径构成的数字的值，最后返回所有数字的和\n\n#### python3代码\n```\nclass Solution:\n    def dfs(self, node, path):\n        path.append(node.val)\n        if not node.left and not node.right:\n            cur = 0\n            for i in range(len(path)):\n                cur += path[i] * (10**(len(path)-i-1))\n            self.rs += cur\n        if node.left:\n            self.dfs(node.left, path)\n        if node.right:\n            self.dfs(node.right, path)\n        path.pop()            \n\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        self.rs = 0\n        self.dfs(root, [])\n        return self.rs\n```\n\n#### 复杂度分析\n时间复杂度O(n) 因为需要遍历树中的所有节点\n\n空间复杂度O(n) 因为栈的深度取决于树的深度，在最坏情况下树的深度与节点个数相同","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/16#issuecomment-2072155840","body":"#### 思路\nbfs层次遍历树，返回最后一层最左侧的节点\n\n#### python3代码\n```\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        queue = collections.deque([root])\n        while queue:\n            left = queue[0]\n            for _ in range(len(queue)):\n                node = queue.popleft()\n                if node.left is not None:\n                    queue.append(node.left)\n                if node.right is not None:\n                    queue.append(node.right)\n        return left.val\n```\n\n#### 复杂度分析\n\n时间复杂度o(n) 需要遍历所有节点\n\n空间复杂度o(n) 维护队列存储每层节点","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/18#issuecomment-2076801204","body":"#### 思路\n层次遍历树的同时记录每个节点的行和列，遍历的同时维护以列和行为键值的哈希表\n根据哈希表的内容输出垂序遍历结果\n\n#### python3代码\n```\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        queue = [(root,0,0)]\n        pos_map = {}\n        while queue:\n            queue_tmp = []\n            cur_map = {}\n            for node, row, col in queue:\n                if col not in cur_map.keys():\n                    cur_map[col] = []\n                cur_map[col].append(node.val)\n                if node.left:\n                    queue_tmp.append((node.left,row+1,col-1))\n                if node.right:\n                    queue_tmp.append((node.right,row+1,col+1))\n            for k,v in cur_map.items():\n                if k not in pos_map.keys():\n                    pos_map[k] = {}\n                pos_map[k][row] = sorted(v)\n            queue = queue_tmp\n        # print(pos_map)\n        pos_map_keys = sorted(pos_map)\n        rs = []\n        for k1 in pos_map_keys:\n            v1 = pos_map[k1]\n            v1_keys = sorted(v1)\n            cur_rs = []\n            for k2 in v1_keys:\n                cur_rs += v1[k2]\n            rs.append(cur_rs)\n        return rs\n```\n\n#### 复杂度分析\n时间复杂度为o(n) 因为需要对节点进行遍历\n\n空间复杂度为o(n) 因为遍历时维护了哈希表和队列来存储节点","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/20#issuecomment-2079241292","body":"#### 思路\n采用空间换时间的思路，维护哈希表记录数组中值对应的索引，这样一次遍历就可以检查是否可以构成target\n\n### python3代码\n```\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        num_dict = dict()\n        for i, num in enumerate(nums):\n            if target - num in num_dict:\n                return [num_dict[target - num], i]\n            num_dict[num] = i\n        return []\n```\n\n#### 复杂度分析\n时间复杂度o(n) 只需要遍历一次数组\n\n空间复杂度o(n) 哈希表的空间开销最差情况与数组大小一致","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/23#issuecomment-2082516527","body":"#### 思路\n滑动窗口思想，当目前的子序列中包括重复字符的时候收紧子序列直到没有重复字符，遍历过程中计算最长无重复子序列的长度。\n维护一个集合来记录当前子序列中的字符。\n\n#### python3 代码\n```\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        start = 0\n        rs = 0\n        seen = set()\n        for i in range(len(s)):\n            if s[i] not in seen:\n                seen.add(s[i])\n                rs = max(rs,i-start+1)\n            else:\n                while s[i] in seen:\n                    seen.remove(s[start])\n                    start+=1\n                seen.add(s[i])\n        return rs\n```\n\n#### 复杂度\n时间复杂度o(n) 需要遍历一次字符串\n\n空间复杂度o(k) k为字符集合占用的最大空间，即可能出现的字符个数\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/26#issuecomment-2090098268","body":"#### 思路\n快慢指针，快指针走两步，慢指针走一步，直到快指针不能再走两步。如果停止时快指针后面没有节点，说明链表中有奇数个节点，此时慢节点为中间节点；如果停止时快指针后面还有一个节点，说明链表中有偶数个节点，此时慢节点为第一个中间节点，因此返回慢节点的下一个节点。\n\n#### python3代码\n```\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast,slow = head,head\n        while fast.next and fast.next.next:\n            fast = fast.next.next\n            slow = slow.next\n        if not fast.next:\n            return slow\n        return slow.next\n```\n\n#### 复杂度分析\n时间复杂度o(n) 需要遍历链表，n为链表中节点个数\n\n空间复杂度o(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/28#issuecomment-2093990226","body":"#### 思路\n二分查找\n\n#### python3代码\n```\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left,right = 0,len(nums)-1\n        while left<=right:\n            mid = (left+right)//2\n            if nums[mid]==target:\n                return mid\n            if nums[mid]<target:\n                left = mid+1\n            else:\n                right = mid-1\n        return left\n```\n\n复杂度分析\n时间复杂度o(logn) 空间复杂度o(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/31#issuecomment-2097810320","body":"#### 思路\n维护两个集合，遍历dislikes数组，如果其中一个节点在其中一个集合里，那么另一个节点只能加入到另外一个集合里，若两个节点出现在相同集合里则发生冲突，\n\n#### python3 代码\n```\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        if not dislikes:\n            return True\n        edges = collections.defaultdict(list)\n        for dislike in dislikes:\n            edges[dislike[0]].append(dislike[1])\n            edges[dislike[1]].append(dislike[0])\n        queue = []\n        set1 = set([dislikes[0][0]])\n        set2 = set([dislikes[0][1]])\n        queue = dislikes[1:]\n        while queue:\n            tmp = []\n            s1,s2 = len(set1),len(set2)\n            for a,b in queue:\n                if a not in set1 and a not in set2 and b not in set1 and b not in set2:\n                    tmp.append([a,b])\n                else:\n                    if a in set1:\n                        if b in set1:\n                            return False\n                        set2.add(b)\n                    elif a in set2:\n                        if b in set2:\n                            return False\n                        set1.add(b)\n            queue = tmp\n            if len(set1)==s1 and len(set2)==s2 and queue:\n                set1.add(queue[0][0])\n                set2.add(queue[0][1])\n                queue = queue[1:]\n        return True\n```\n\n#### 复杂度分析\n空间和空间复杂度均为o(m+n) 其中m为dislikes数组的大小","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/33#issuecomment-2102675969","body":"#### 思路\n记录坐标x和y，每次移动改变坐标值，最终检查坐标是否位于原点\n\n#### python3代码\n···\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        x,y = 0,0\n        for move in moves:\n            if move=='U':\n                y+=1\n            elif move=='L':\n                x-=1\n            elif move=='D':\n                y-=1\n            elif move=='R':\n                x+=1\n        if x==0 and y==0:\n            return True\n        return False\n···\n\n#### 复杂度分析\n空间复杂度o(1) 时间复杂度o(n) n为moves中move的个数","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/38#issuecomment-2109149130","body":"#### 思路\n二分查找\n\n#### python3代码\n```\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        l,r=1,x\n        while l<=r:\n            mid = (l+r)//2\n            if mid**2 == x:\n                return mid\n            if mid**2 < x:\n                l = mid+1\n            else:\n                r = mid-1\n        return r\n```\n\n#### 复杂度分析\n时间复杂度 o(logx) 空间复杂度o(1)","onTime":true},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/46#issuecomment-2124251863","body":"#### 思路\n滑动窗口的同时计算当前窗口和p子串中字符个数是否相同\n#### python3代码\n```\nclass Solution:\n    def findAnagrams(self, s: str, p: str) -> List[int]:\n        if len(s)<len(p):\n            return []\n        p_arr = [0]*26\n        for ch in p:\n            # print(ch,ord(ch)-ord('a'),ord('y'),ord(ch))\n            p_arr[ord(ch)-ord('a')]+=1\n        s_arr = [0]*26\n        for ch in s[:len(p)]:\n            s_arr[ord(ch)-ord('a')]+=1\n        rs = []\n        if s_arr==p_arr:\n            rs.append(0)\n        if len(s)==len(p):\n            return rs\n        for pointer in range(1,len(s)-len(p)+1):\n            s_arr[ord(s[pointer-1])-ord('a')]-=1\n            s_arr[ord(s[pointer+len(p)-1])-ord('a')]+=1\n            if s_arr==p_arr:\n                rs.append(pointer)\n        return rs\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/47#issuecomment-2126221539","body":"#### 思路\n滑动窗口，每次发现有可以覆盖t的s子窗口时，对窗口进行收紧从而得到最短的子窗口\n\n#### python3代码\n```\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        t_arr = collections.defaultdict(int)\n        for ch in t:\n            t_arr[ch]+=1\n        def ifcover(cur_arr):\n            for k in t_arr:\n                if cur_arr[k]<t_arr[k]:\n                    return False\n            return True\n        cur_arr = collections.defaultdict(int)\n        rs = \"\"\n        start=0\n        end=start+1\n        while start<len(s):\n            while end<=len(s):\n                cur_arr[s[end-1]]+=1\n                if ifcover(cur_arr):\n                    break\n                end+=1\n            if not ifcover(cur_arr):\n                return rs\n            while start<end and cur_arr[s[start]]-1>=t_arr[s[start]]:\n                cur_arr[s[start]]-=1\n                start+=1\n            if rs==\"\" or end-start<len(rs):\n                rs = s[start:end]\n            cur_arr[s[start]]-=1\n            start+=1\n            end+=1\n        return rs\n\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/50#issuecomment-2132212777","body":"python3 代码\n```\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        def check(inaval,count,idxstart):\n            rs = 0\n            if count==n:\n                return 1\n            if len(inaval)==n**2:\n                return 0\n            istart = idxstart//n\n            jstart = idxstart%n\n            for idx in range(idxstart,n**2):\n                i,j = idx//n,idx%n\n                if (i,j) not in inaval:\n                    inaval_tmp = inaval.copy()\n                    inaval_tmp.add((i,j))\n                    for k in range(n):\n                        if (i,k) not in inaval_tmp:\n                            inaval_tmp.add((i,k))\n                        if (k,j) not in inaval_tmp:\n                            inaval_tmp.add((k,j))\n                        if i+j-k>=0 and i+j-k<n and (k,i+j-k) not in inaval_tmp:\n                            inaval_tmp.add((k,i+j-k))\n                        if k-i+j>=0 and k-i+j<n and (k,k-i+j) not in inaval_tmp:\n                            inaval_tmp.add((k,k-i+j))\n                    # print(i,j,inaval_tmp,count)\n                    rs += check(inaval_tmp,count+1,i*n+j+1)\n            return rs\n        return check(set(),0,0)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/51#issuecomment-2133514238","body":"python3代码\n```\nclass Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        m,n = len(grid),len(grid[0])\n        def dfs(x,y):\n            if x<0 or x>=m or y<0 or y>=n or grid[x][y]!=1:\n                return 0\n            grid[x][y]=-1\n            area=1\n            area+=dfs(x+1,y)\n            area+=dfs(x-1,y)\n            area+=dfs(x,y-1)\n            area+=dfs(x,y+1)\n            return area\n        rs=0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]==1:\n                    rs=max(rs,dfs(i,j))\n        return rs\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/52#issuecomment-2134276073","body":"python3代码\n```\nclass Solution:\n    def maxDistance(self, grid: List[List[int]]) -> int:\n        m,n=len(grid),len(grid[0])\n        queue = []\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]==1:\n                    queue.append((i,j))\n        if len(queue)==0 or len(queue)==n*m:\n            return -1\n        dist=-1\n        while queue:\n            print(queue)\n            q_tmp = []\n            dist+=1\n            for x,y in queue:\n                grid[x][y]=2\n                if (x)>0:\n                    if grid[x-1][y]==0:\n                        q_tmp.append((x-1,y))\n                        grid[x-1][y]=2\n                if (x+1)<m:\n                    if grid[x+1][y]==0:\n                        q_tmp.append((x+1,y))\n                        grid[x+1][y]=2\n                if (y)>0:\n                    if grid[x][y-1]==0:\n                        q_tmp.append((x,y-1))\n                        grid[x][y-1]=2\n                if (y+1)<n: \n                    if grid[x][y+1]==0:\n                        q_tmp.append((x,y+1))\n                        grid[x][y+1]=2\n            queue=q_tmp\n        return dist\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/55#issuecomment-2141500612","body":"#### 思路\n动态规划\n\n#### python3代码\n```\nclass Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        dp = [0]*(len(cost)+1)\n        for i in range(2,len(cost)+1):\n            dp[i]=min(dp[i-2]+cost[i-2],dp[i-1]+cost[i-1])\n        return dp[-1]\n```\n\n#### 复杂度分析\n空间复杂度 时间复杂度均为o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/56#issuecomment-2143331486","body":"动态规划\npython3代码\n```\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        dp = [0] * len(nums)\n        for i in range(len(nums)):\n            if i ==0:\n                dp[i]=nums[i]\n            elif i==1:\n                dp[i]=max(nums[:i+1])\n            else:\n                dp[i]=max(dp[i-1],dp[i-2]+nums[i])\n        return dp[-1]\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/58#issuecomment-2144189710","body":"动态规划\n\npython3代码\n```\nclass Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        dp = [0]*len(text1)\n        rs = 0\n        for j in range(len(text2)):\n            tmp = dp.copy()\n            for i in range(len(text1)):\n                if i>0:\n                    tmp[i] = max(tmp[i],tmp[i-1])\n                if text1[i]==text2[j]:\n                    tmp[i] = max(tmp[i],dp[i-1]+1 if i>0 else 1)\n            dp = tmp\n            rs = max(dp[-1],rs)\n        return rs\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/59#issuecomment-2146445483","body":"#### 思路\n动态规划 dp[i][j] = dp[i-1][j]+dp[i][j-1]\n\n需要考虑边界情况，且可使用滚动数组优化空间\n#### python3代码\n```\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = [1]*n\n        for i in range(m):\n            tmp = [1]*n\n            for j in range(n):\n                if not (i==0 and j==0):\n                    tmp[j]=(tmp[j-1] if j>0 else 0)+(dp[j] if i>0 else 0)\n            dp = tmp\n        return dp[-1]\n```\n#### 复杂度分析\n时间复杂度o(mn) 空间复杂度o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/60#issuecomment-2148749662","body":"python3代码\n```\nclass Solution:\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n        def check(x,y):\n            if x>=0 and x<n and y>=0 and y<n:\n                return True\n            else:\n                return False\n        @lru_cache\n        def step(x,y):\n            rs = []\n            if check(x-2,y-1):\n                rs.append((x-2,y-1))\n            if check(x-1,y-2):\n                rs.append((x-1,y-2))\n            if check(x+1,y-2):\n                rs.append((x+1,y-2))\n            if check(x+2,y-1):\n                rs.append((x+2,y-1))\n            if check(x+2,y+1):\n                rs.append((x+2,y+1))\n            if check(x+1,y+2):\n                rs.append((x+1,y+2))\n            if check(x-2,y+1):\n                rs.append((x-2,y+1))\n            if check(x-1,y+2):\n                rs.append((x-1,y+2))\n            return rs\n        queue = collections.defaultdict(int)\n        queue[(row, column)] = 1\n        for i in range(k):\n            # print(queue)\n            if not queue:\n                return 0\n            tmp = collections.defaultdict(int)\n            for (x,y),nums in queue.items():\n                next_list = step(x,y)\n                for nl in next_list:\n                    tmp[nl]+=nums\n            queue = tmp\n        return sum(list(queue.values()))/8**k\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/62#issuecomment-2154863177","body":"python 3代码\n```\nclass Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        sumval = sum(nums)\n        if sumval%2==1:\n            return False\n        target = sumval//2\n        cache = set()\n        for num in nums:\n            tmp = set()\n            for c in cache:\n                if c+num==target:\n                    return True\n                tmp.add(c+num)\n            cache = cache.union(tmp)\n            if num == target:\n                return True\n            cache.add(num)\n        return False\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/63#issuecomment-2156034211","body":"```\nclass Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        dp = collections.defaultdict(int)\n        dp[0]=1\n        for num in nums:\n            tmp = collections.defaultdict(int)\n            for k in dp:\n                tmp[k+num]+=dp[k]\n                tmp[k-num]+=dp[k]\n            dp = tmp\n        return dp[target]\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/66#issuecomment-2160788383","body":"```\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        g = sorted(g)\n        s = sorted(s)\n        sidx = 0\n        rs = 0\n        for gidx in range(len(g)):\n            if sidx>=len(s):\n                return rs\n            while sidx<len(s) and g[gidx]>s[sidx]:\n                sidx+=1\n            if sidx<len(s):\n                rs+=1\n                sidx+=1\n            else:\n                return rs\n        return rs\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/68#issuecomment-2165078406","body":"```\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        pos = 0\n        for i in range(len(nums)):\n            if i<=pos:\n                pos = max(pos,i+nums[i])\n                if pos>=len(nums)-1:\n                    return True\n        return False\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/69#issuecomment-2168078795","body":"#### 记忆化递归\n```\nclass Solution:\n    @lru_cache(None)\n    def numTrees(self, n: int) -> int:\n        if n<=1:\n            return 1\n        rs = 0\n        for i in range(1,n+1):\n            rs+=self.numTrees(i-1)*self.numTrees(n-i)\n        return rs\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/70#issuecomment-2169488693","body":"```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        prehead = ListNode()\n        pointer = prehead\n        while True:\n            minnode = None\n            minidx = -1\n            # print(lists)\n            for i,head in enumerate(lists):\n                if head is not None:\n                    if minnode is None or head.val<minnode.val:\n                        minnode = head\n                        minidx = i\n            if minnode is None:\n                break\n            pointer.next = minnode\n            lists[minidx] = minnode.next\n            pointer = pointer.next\n            \n\n        return prehead.next\n         \n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/72#issuecomment-2172733575","body":"```\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        vals = set()\n        for n in nums:\n            if n in vals:\n                vals.remove(n)\n            else:\n                vals.add(n)\n        return list(vals)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/73#issuecomment-2175444357","body":"```\nclass Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        rs = [[]]\n        for n in nums:\n            tmp = []\n            for r in rs:\n                tmp.append(r+[n])\n            rs+=tmp\n        return rs\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/79#issuecomment-2185454003","body":"```\nclass Solution:\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\n        graph = collections.defaultdict(list)\n        for edge in connections:\n            graph[edge[0]].append(edge[1])\n            graph[edge[1]].append(edge[0])\n        seen = set()\n        groups, extra = 0, 0\n        for i in range(n):\n            if i in seen:\n                continue\n            seen.add(i)\n            queue = [i]\n            curnode, curedge = 1,0\n            while queue:\n                node = queue.pop()\n                for child in graph[node]:\n                    curedge+=1\n                    if child not in seen:\n                        curnode+=1\n                        seen.add(child)\n                        queue.append(child)\n            groups += 1\n            extra += max(0, curedge//2-curnode+1)\n        if extra>=groups-1:\n            return groups-1\n        else:\n            return -1\n ```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/80#issuecomment-2187893925","body":"```\nclass Solution:\n    def pruneTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root:\n            return None\n        left_rs = self.pruneTree(root.left)\n        right_rs = self.pruneTree(root.right)\n        if not left_rs and not right_rs and root.val==0:\n            return None\n        root.left = left_rs\n        root.right = right_rs\n        return root\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/82#issuecomment-2194227916","body":"```\nclass Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        candidates = sorted(candidates)\n        rs_list = [set() for _ in range(target)]\n        for num in candidates:\n            for target_val in range(target-num-1,-1,-1):\n                for i in rs_list[target_val]:\n                    rs_list[target_val+num].add(i+(num,))\n            if num-1<target:\n                rs_list[num-1].add(tuple([num]))\n        return [list(l) for l in rs_list[-1]]\n```","onTime":true},null,null,null,null,null,null,null,null,null,null],"franklinsworld666":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/5#issuecomment-2051488571","body":"### 思路\n用双端队列来实现栈。\n用栈A 来保存队列push 进来的元素，用栈B来支持pop和peek操作。如果栈B为空，那么把栈A全部出栈并插入栈B，此时栈B中的元素出栈顺序刚好与队列一致，可以用来进行队列pop和peek操作；如果栈B不为空，则直接对栈B进行 pop和peek操作；\n\n### 代码\n```python3\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = MyStack()\n        self.stack2 = MyStack()\n\n    def push(self, x: int) -> None:\n        self.stack2.push(x)\n\n    def pop(self) -> int:\n        if not self.stack1.empty():\n            return self.stack1.pop()\n        else:\n            while not self.stack2.empty():\n                self.stack1.push(self.stack2.pop())\n            return self.stack1.pop()\n\n    def peek(self) -> int:\n        if not self.stack1.empty():\n            return self.stack1.peek()\n        else:\n            while not self.stack2.empty():\n                self.stack1.push(self.stack2.pop())\n            return self.stack1.peek()\n\n    def empty(self) -> bool:\n        return self.stack1.empty() and self.stack2.empty()\n\nclass MyStack:\n    def __init__(self):\n        self.stack = deque()\n\n    def push(self,x):\n        self.stack.append(x)\n    \n    def pop(self) -> int:\n        if not self.empty():\n            return self.stack.pop()\n        else:\n            return None\n    \n    def peek(self) -> bool:\n        if not self.empty():\n            return self.stack[-1]\n        else:\n            return None\n    \n    def empty(self) -> bool:\n        return len(self.stack) == 0\n\n```\n\n### 复杂度分析\n+ 时间复杂度\n   + push: O(1)， 同双端队列的push操作\n   + empty: O(1)\n   + pop/peek: 最好O(1), 最坏O(N), 平均来讲O(1);  假设在栈A中存在X个元素时，进行pop/peek操作，那么要进行X次出栈入栈操作，也意味着接下来的 X-1 次pop/peek 操作只要常数时间，所以平均来讲时间复杂度是O(1)\n\n+ 空间复杂度: O(N)\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/8#issuecomment-2057129878","body":"## 思路\n递归，先解决空链表、一个节点或两个节点的问题。然后递归结果剩下的。\n\n## 代码\n```python3\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        second = head. next\n        third = second.next\n        head.next = self.swapPairs(third)\n        second.next = head\n        head = second\n        return head\n```\n\n## 复杂度分析\n+ 时间复杂度：O(N)\n+ 空间复杂度:O(N)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/14#issuecomment-2068062301","body":"## 思路\n两棵树相同的条件：当前节点值相同，左子树相同，右子树相同\n\n## 代码\n```python3\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p and not q:\n            return False\n        if not p and q:\n            return False\n        if not p and not q:\n            return True\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n\n## 复杂度\n+ 时间复杂度：O(min(M,N))，比较的次数最大为规模较小的树的节点数\n+ 空间复杂度：O(log(min(M,N))), 递归深度为树的高度，最坏情况下为规模较小的树的节点数","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/22#issuecomment-2081495513","body":"## 思路\n首先，固定点X，计算其他所有的点到X的距离，假设距离 D 有 m 个(m>=2), 那么回旋镖有 m(m-1)\n从头到尾遍历每一个点，同上计算出总的回旋镖。\n\n## 代码\n```python3\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        res = 0\n        order_map = dict()\n        for i in range(len(points)):\n            order_map.clear()\n            for j in range(len(points)):\n                if j != i:\n                    dist = self.__dis(points[i],points[j])\n                    if dist not in order_map:\n                        order_map[dist] = 1\n                    else:\n                        order_map[dist] += 1\n            for key,value in order_map.items():\n                if value >= 2:\n                    res += value * (value-1)\n        return res\n    def __dis(self,pa,pb):\n        return (pa[0]-pb[0])*(pa[0]-pb[0])+(pa[1]-pb[1])*(pa[1]-pb[1])\n```\n\n## 复杂度\n+ 时间复杂度：O(n *n)\n+ 空间复杂度：字典最多需要存放 n 个距离，所以O(n)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/29#issuecomment-2094756404","body":"## 思路\n先考虑这样一个问题，如果已经知道了 0~k-1 这个窗口，以及最大值，如何利用以上信息加快获得 1~k+1 这个窗口的最大值？\n【-1， -3， 5】为例，当把5推入窗口时，-1，-3对于后续的最大值计算就已经没有用了，所以可以舍弃，即只要保留上一个窗口中的部分信息用于加速下一个窗口的计算。\n建立一个队列，队列从头到尾保持从大到小的顺序，即队头就是本次窗口中的最大值。\n当有一个新的元素推入窗口时，首先检查队头的元素是否在窗口内，不再窗口内就pop出队列；\n再次，检查队尾的元素，凡比新元素小的，全部出队列，因为对于后续计算最大值没有价值了。\n最后，把新元素入队列。\n于是，队头是本次窗口的最大值，整个队列仍然保持从大到小的顺序。\n\n\n## 代码\n```python3\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        ans = []\n        queue = deque()\n        size = len(nums)\n        i = 0\n        while i < size:\n            if queue and queue[0] <= i - k:\n                queue.popleft()\n            while queue and nums[queue[-1]] < nums[i]:\n                queue.pop()\n            queue.append(i)\n            i += 1\n            if i >= k:\n                ans.append(nums[queue[0]])\n        return ans\n```\n\n## 复杂度\n+ 时间复杂度： O(N), 每个元素进入队列一次，出队列一次\n+ 空间复杂度：O(k)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/36#issuecomment-2106156691","body":"## 代码\n```python3\nclass Solution:\n    def minCharacters(self,a: str,b: str) -> int:\n        str1 = [0]*26 \n        str2 = [0]*26\n        for c in a:\n            str1[ord(c)-97] += 1\n        for c in b:\n            str2[ord(c)-97] += 1\n\n        s1,s2=len(a),len(b)\n\n        pre1 = [str1[0]]+[0]*25\n        pre2 = [str2[0]]+[0]*25\n        suf1 = [0]*25 +[str1[-1]]\n        suf2 = [0]*25 +[str2[-1]]\n        \n        \n        for i in range(1,26):\n            pre1[i] = pre1[i - 1] + str1[i] \n            pre2[i] = pre2[i - 1] + str2[i] \n        \n        for i in range(24,-1,-1):\n            suf1[i] = suf1[i+1]+str1[i] \n            suf2[i] = suf2[i+1]+str2[i]\n\n        ans = s1 + s2\n\n        for i in range(1,26):\n            ans = min(ans, suf1[i]+ pre2[i-1])\n            ans = min(ans, suf2[i] + pre1[i-1])\n\n        for i in range(26):\n            ans = min(ans,s1 +s2 - str1[i] - str2[i])\n\n        return ans\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/43#issuecomment-2119262144","body":"```python3\nfrom typing import List, Tuple\nfrom collections import deque\n\nclass Solution:\n    def canReach(self, time: int, matrix: List[List[int]]) -> bool:\n        rows, cols = len(matrix), len(matrix[0])\n        queue: deque[Tuple[int, int]] = deque([(0, 0)])\n        visit = [[0] * cols for _ in range(rows)]\n        visit[0][0] = 1\n\n        while queue:\n            x, y = queue.popleft()\n            if x == rows - 1 and y == cols - 1:\n                return True\n\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < rows and 0 <= ny < cols and matrix[nx][ny] <= time and not visit[nx][ny]:\n                    visit[nx][ny] = 1\n                    queue.append((nx, ny))\n        \n        return False\n\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        rows, cols = len(grid), len(grid[0])\n        low, high = max(grid[0][0], grid[-1][-1]), max([max(row) for row in grid])\n        res = rows * cols\n\n        while low <= high:\n            mid = (low + high) // 2\n            if self.canReach(mid, grid):\n                res = min(res, mid)\n                high = mid - 1\n            else:\n                low = mid + 1\n\n        return res\n```\n\n## 复杂度\n时间复杂度：O(N^2logN)\n空间复杂度：O(N^2)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/50#issuecomment-2132246659","body":"### 代码\n```python3\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        def can_place(row):\n            # 检查当前行放置皇后是否安全\n            for i in range(row):\n                if col[i] == col[row] or \\\n                   abs(col[i] - col[row]) == row - i:\n                    return False\n            return True\n\n        def backtrack(row):\n            if row == n:\n                result.append(generate_board())\n                return\n            for i in range(n):\n                col[row] = i\n                if can_place(row):\n                    backtrack(row + 1)\n\n        def generate_board():\n            # 生成当前解决方案的棋盘表示\n            board = [[\".\" for _ in range(n)] for _ in range(n)]\n            for i in range(n):\n                board[i][col[i]] = \"Q\"\n            return board\n\n        col = [-1] * n  \n        result = []  \n        backtrack(0)  \n        return len(result)  \n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/51#issuecomment-2133351340","body":"## 代码\n```python3\nclass Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        if not grid:\n            return 0\n\n        def dfs(x, y):\n            if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0:\n                return 0\n            grid[x][y] = 0  # Mark as visited by setting to 0\n            return (1 +\n                    dfs(x+1, y) +\n                    dfs(x-1, y) +\n                    dfs(x, y+1) +\n                    dfs(x, y-1))\n\n        max_area = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    max_area = max(max_area, dfs(i, j))\n        return max_area\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/58#issuecomment-2145116939","body":"### 代码\n```python3\nclass Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        m, n = len(text1), len(text2)\n        \n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if text1[i - 1] == text2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        \n        return dp[m][n]\n```\n\n## 复杂度\n+ 时间复杂度: O(mn)\n+ 空间复杂度：O(mn)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/65#issuecomment-2157497624","body":"## 代码\n```python\nclass Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n        for coin in coins:\n            for i in range(1, amount + 1):\n                if coin <= i:\n                    dp[i] += dp[i - coin]\n        return dp[amount]\n```\n\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/72#issuecomment-2173357542","body":"## 代码\n```python3\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        diff = 0\n        for n in nums:\n            diff ^= n\n        diff &= -diff\n\n        res = [0, 0]\n        for n in nums:\n            if(n&diff==0):\n                res[0] ^= n\n            else:\n                res[1]^=n\n\n        return res\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/79#issuecomment-2186221905","body":"## 代码\n```python3\nclass Solution:\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\n        def find(x):\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        cnt, size = 0, n\n        p = list(range(n))\n        for a, b in connections:\n            if find(a) == find(b):\n                cnt += 1\n            else:\n                p[find(a)] = find(b)\n                size -= 1\n        return -1 if size - 1 > cnt else size - 1\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null],"brainlds":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/6#issuecomment-2053580210","body":"class Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();\n        int res = 0;\n        int[] sortedArr = new int[arr.length];\n        System.arraycopy(arr, 0, sortedArr, 0, arr.length);\n        Arrays.sort(sortedArr);\n        for (int i = 0; i < sortedArr.length; i++) {\n            int x = arr[i], y = sortedArr[i];\n            cnt.put(x, cnt.getOrDefault(x, 0) + 1);\n            if (cnt.get(x) == 0) {\n                cnt.remove(x);\n            }\n            cnt.put(y, cnt.getOrDefault(y, 0) - 1);\n            if (cnt.get(y) == 0) {\n                cnt.remove(y);\n            }\n            if (cnt.isEmpty()) {\n                res++;\n            }\n        }\n        return res;\n    }\n}\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huamulanyyds":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/6#issuecomment-2053654726","body":"class Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n    vector<int> vc = arr;\n    sort(vc.begin(),vc.end());\n    int res = 0;\n    long long sumArr = 0;\n    long long sumVc = 0;\n    for(int i=0;i<arr.size();i++){\n      sumArr += arr[i];\n      sumVc += vc[i];\n      if(sumArr == sumVc)\n         res++;\n    }\n    return res;\n    }\n};\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eclairs46":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/7#issuecomment-2054108279","body":"var rotateRight = function(head, k) {\r\n    if (!head || !head.next || k === 0) return head;\r\n\r\n    let length = 1;\r\n    let tail = head;\r\n    while (tail.next) {\r\n        tail = tail.next;\r\n        length++;\r\n    }\r\n    tail.next = head;\r\n\r\n    let newTail = head;\r\n    for (let i = 0; i < length - k % length - 1; i++) {\r\n        newTail = newTail.next;\r\n    }\r\n    \r\n    let newHead = newTail.next;\r\n    newTail.next = null;\r\n    return newHead;\r\n};","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/8#issuecomment-2056858398","body":"### 思路\r\n\r\n定义临时变量 next 保存下一个节点的下一个节点，交换 head 和 head.next 两个节点的位置\r\n\r\n### 代码\r\n\r\n```javascript\r\nvar swapPairs = function(head) {\r\n    if(!head || !head.next) {return head}\r\n    let next = head.next.next;\r\n    let newHead = head.next;\r\n    head.next.next = head;\r\n    head.next = swapPairs(next);\r\n    return newHead;\r\n};\r\n``` \r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/15#issuecomment-2069300768","body":"### 思路\r\n\r\n深度遍历\r\n\r\n### 代码\r\n\r\n```javascript\r\nvar sumNumbers = function(root) {\r\n    const recerve = (curRoot, sum) => {\r\n        if(curRoot === null) {return 0}\r\n        const curSum = sum * 10 + curRoot.val;\r\n        if(curRoot.left === null && curRoot.right === null) { return curSum; }\r\n        return recerve(curRoot.left, curSum) + recerve(curRoot.right, curSum)\r\n    }\r\n    return recerve(root, 0);\r\n};\r\n``` \r\n### 复杂度：\r\n\r\n- 时间复杂度： O(n)\r\n- 空间复杂度： O(h)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maike-hps":[null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/10#issuecomment-2061516451","body":"思路：\r\n\r\n计算两个链表的长度：首先遍历两个链表，计算它们的长度 m 和 n。\r\n对齐两个链表的起始位置：根据长度之差，移动较长链表的指针 diff = |m - n| 步，这样可以使得两个链表的尾部对齐。\r\n遍历链表寻找相交节点：然后从两个链表的当前位置开始，每次同时移动两个指针一步，如果两个指针指向了同一个节点，那么这个节点就是相交的起始节点。\r\n返回结果：如果遍历过程中没有找到相交的节点，那么返回 null。\r\n代码：\r\n`\r\nfunction getIntersectionNode(headA, headB):\r\n    if headA == null or headB == null:\r\n        return null\r\n\r\n    # Step 1: Calculate the lengths of the two lists\r\n    lenA, lenB = 0, 0\r\n    currentA, currentB = headA, headB\r\n    while currentA != null:\r\n        lenA += 1\r\n        currentA = currentA.next\r\n    while currentB != null:\r\n        lenB += 1\r\n        currentB = currentB.next\r\n\r\n    # Step 2: Align the starting positions of the two lists\r\n    currentA, currentB = headA, headB\r\n    if lenA > lenB:\r\n        for i in range(lenA - lenB):\r\n            currentA = currentA.next\r\n    else:\r\n        for i in range(lenB - lenA):\r\n            currentB = currentB.next\r\n\r\n    # Step 3: Traverse the lists to find the intersection node\r\n    while currentA != null and currentB != null:\r\n        if currentA == currentB:\r\n            return currentA\r\n        currentA = currentA.next\r\n        currentB = currentB.next\r\n\r\n    # Step 4: If no intersection is found, return null\r\n    return null\r\n`\r\n复杂度：时间复杂度是 O(m + n)，因为我们需要遍历两个链表来找到相交节点。由于 m 和 n 分别是链表 A 和 B 的长度，所以这个算法的时间复杂度可以简化为 O(m + n)。由于我们只使用了一个额外的指针来遍历链表，所以空间复杂度是 O(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/15#issuecomment-2068389529","body":"`class TreeNode:\r\n    def __init__(self, val=0, left=None, right=None):\r\n        self.val = val\r\n        self.left = left\r\n        self.right = right\r\n\r\ndef sum_numbers(root):\r\n    def dfs(node, current_number):\r\n        if not node:\r\n            return 0\r\n        current_number = current_number * 10 + node.val\r\n        if not node.left and not node.right:\r\n            return current_number\r\n        return dfs(node.left, current_number) + dfs(node.right, current_number)\r\n    \r\n    return dfs(root, 0)\r\n\r\n\r\nroot1 = TreeNode(1)\r\nroot1.left = TreeNode(2)\r\nroot1.right = TreeNode(3)\r\n\r\nroot2 = TreeNode(4)\r\nroot2.left = TreeNode(9)\r\nroot2.left.left = TreeNode(5)\r\nroot2.left.right = TreeNode(1)\r\nroot2.right = TreeNode(0)\r\n\r\nprint(sum_numbers(root1)) \r\nprint(sum_numbers(root2)) `","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/22#issuecomment-2081314948","body":"遍历所有可能的三个点的组合，检查它们是否形成一个回旋镖。\n对于每一对点，找到中点，然后检查中点是否与第三个点形成一个回旋镖。\ndef numberOfBoomerangs(points):\n    # 初始化回旋镖的数量\n    count = 0\n    \n    # 遍历所有点的组合\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            # 计算点 i 和点 j 之间的距离的平方\n            distance_i_j = (points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2\n            \n            # 使用一个字典来统计每个距离的点的数量\n            distance_count = {}\n            distance_count[distance_i_j] = distance_count.get(distance_i_j, 0) + 1\n            \n            # 更新回旋镖的数量\n            # 如果有至少两个点与点 i 的距离相同，那么就会形成一个回旋镖\n            count += distance_count[distance_i_j]\n    \n    return count","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/24#issuecomment-2084314359","body":"def findSubstring(s, words):\n    def helper(word_dict, start):\n        for i in range(len(words)):\n            word = words[i]\n            index = (i + start) % len(words)\n            if word_dict[word] > 0:\n                word_dict[word] -= 1\n            else:\n                return False\n        return True\n\n    word_count = {word: 0 for word in words}\n    for word in words:\n        word_count[word] += 1\n    n, k = len(s), len(words)\n    result = []\n\n    for i in range(n - k * len(words[0]) + 1):\n        if helper(word_count.copy(), i // len(words[0])):\n            result.append(i)\n\n    return result","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/30#issuecomment-2095263936","body":"class Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        lst1, lst2 = [], []\n        for x, y in trust:\n            lst1.append(x)\n            lst2.append(y)\n        l = list(set(range(1, n + 1)) - set(lst1))\n        return l[0] if len(l) == 1 and lst2.count(l[0]) == n - 1 else -1","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/35#issuecomment-2105627145","body":"function countMatches(startTime, finishTime):\n    startMinutes = convertToMinutes(startTime)\n    finishMinutes = convertToMinutes(finishTime)\n    \n    if finishMinutes < startMinutes:\n        finishMinutes += 24 * 60  # 玩家玩了通宵，将结束时间增加一天的分钟数\n    \n    totalMinutes = finishMinutes - startMinutes\n    matchesInHour = 4\n    totalMatches = totalMinutes // 15\n    \n    # 如果开始时间不是15的倍数，减去一个对局\n    if startMinutes % 15 != 0:\n        totalMatches -= 1\n    \n    # 如果结束时间不是15的倍数，加上一个对局\n    if finishMinutes % 15 != 0:\n        totalMatches += 1\n    \n    return max(0, totalMatches)\n\nfunction convertToMinutes(time):\n    hours, minutes = split time by \":\"\n    return hours * 60 + minutes","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/41#issuecomment-2116880996","body":"def minRadius(nums):\n    nums.sort()\n    n = len(nums)\n    left, right = 0, nums[-1] - nums[0]\n\n    while left <= right:\n        mid = (left + right) / 2\n        if canLightAllHouses(nums, n, mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\ndef canLightAllHouses(nums, n, r):\n    count = 1  # 初始时，第一个灯已经放置\n    i = 0  # 当前房子的索引\n    for j in range(1, n):\n        # 如果当前房子不能被照亮，则需要放置新的灯\n        if nums[j] - nums[i] > 2 * r:\n            # 尝试找到下一个灯的位置\n            while nums[j] - nums[i] > 2 * r:\n                i += 1\n            count += 1  # 放置了新的灯\n            # 如果已经放置了3个灯，则所有房子都能被照亮\n            if count == 3:\n                return True\n    return count == 3","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/48#issuecomment-2128838094","body":"def min_operations(nums, target):\n    # 初始化操作次数和指针\n    operations = 0\n    left, right = 0, len(nums) - 1\n    current_sum = sum(nums[left:right+1])\n\n    # 当左指针小于等于右指针时继续循环\n    while left <= right:\n        # 如果当前和等于目标，返回操作次数\n        if current_sum == target:\n            return operations\n        # 如果当前和小于目标，无法通过移动指针来减少目标值\n        elif current_sum < target:\n            return -1\n        # 如果当前和大于目标，尝试从两端减少元素\n        else:\n            # 尝试从右端减少元素\n            if nums[right] >= target:\n                return operations + 1\n            else:\n                current_sum -= nums[right]\n                right -= 1\n                operations += 1\n            # 尝试从左端减少元素\n            if nums[left] >= target - current_sum:\n                return operations + 1\n            else:\n                current_sum -= nums[left]\n                left += 1\n                operations += 1\n\n    # 如果循环结束，说明无法通过移动指针来减少目标值\n    return -1","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sanjiu81":[null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/10#issuecomment-2061561282","body":"思路 \n双指针\n代码\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* cur1 = headA;\n        ListNode* cur2 = headB;\n        int flag1 = 0,flag2 = 0;\n        while(cur1!=nullptr || cur2!=nullptr){\n            if(cur1==nullptr){\n                cur1 = headB;\n                flag1 += 1;\n            }\n            if(cur2==nullptr){\n                cur2 = headA;\n                flag2 += 1;\n            }\n            if(cur1 == cur2){break;} \n            if(flag1==2||flag2==2){break;} \n            std::cout << cur1->val << endl;\n            cur1 = cur1->next;\n            cur2 = cur2->next;\n        }\n        return cur1;\n    }\n};\n复杂度\n时间O(M+N）\n空间O(N)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/17#issuecomment-2074184841","body":"思路：先序遍历\n代码：\nvar serialize = function(root) {\n    return rserialize(root, '');\n};\n\nvar deserialize = function(data) {\n    const dataArray = data.split(\",\");\n    return rdeserialize(dataArray);\n};\n\nconst rserialize = (root, str) => {\n    if (root === null) {\n        str += \"None,\";\n    } else {\n        str += root.val + '' + \",\";\n        str = rserialize(root.left, str);\n        str = rserialize(root.right, str);\n    }\n    return str;\n}\n\nconst rdeserialize = (dataList) => {\n    if (dataList[0] === \"None\") {\n        dataList.shift();\n        return null;\n    }\n\n    const root = new TreeNode(parseInt(dataList[0]));\n    dataList.shift();\n    root.left = rdeserialize(dataList);\n    root.right = rdeserialize(dataList);\n\n    return root;\n}\n时间空间复杂度均为O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qinmengx":[null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/11#issuecomment-2063925697","body":"// 方法2: 快慢指针法\ntype ListNode struct {\n\tVal  int\n\tNext *ListNode\n}\n\n/*1. 根据讲义内容, 假定快指针的速度是慢指针速度的2倍.\n2. 第一次相遇时, 快指针走的路程为L+C+环的周长(假定环的周长为C+D)\n                        慢指针走的路程为L+C ,即慢指针被套圈\n3. 得出L=D, 此时另快指针用1倍速从链表起始位置开始走, 刚好与慢指针\n   剩余的路程相等, 再次相遇时, 快慢再次相遇时, 即为环形链表入口.*/\n\nfunc detectCycle(head *ListNode) *ListNode {\n\tvar fast = head\n\tvar slow = head\n\tfor {\n\t\tif fast == nil || fast.Next == nil {\n\t\t\treturn nil\n\t\t}\n\t\tfast = fast.Next.Next\n\t\tslow = slow.Next\n\t\tif fast == slow {\n\t\t\tbreak\n\t\t}\n\t}\n\tfast = head\n\tfor fast != slow {\n\t\tfast = fast.Next\n\t\tslow = slow.Next\n\n\t}\n\treturn fast\n}\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/13#issuecomment-2073826432","body":"思路 : 递归的方法, 假设最底层有一排空节点, 倒推出开始有实体数字的节点为1 ,逐层倒推, 逐层加1 , 最终求得深度\n\ntype TreeNode struct {\n\t\n    Val   int\n\t\n    Left  *TreeNode\n\t\n    Right *TreeNode\n}\n\nfunc maxDepth(root *TreeNode) int {\n\n    if root == nil {\n        return 0\n\t}\n\n    return Max(maxDepth(root.Left), maxDepth(root.Right)) + 1\n}\n\nfunc Max(a, b int) int {\n    \n    if a > b {\n        return a\n    } else {\n        return b\n    }\n}","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yashuning":[null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/14#issuecomment-2068076041","body":"思路：\n\t判断两颗树是否相同，主要判断2点\n\t\t1.对应的结构是否相同\n\t\t2.相同结构的节点值是否相同\n\t整体思路：递归\n\t具体思路：\n\t\t1.判断两个根节点是否相同\n\t\t2.判断根节点的左节点和右节点是否相同\n\t\n```code:\n\tclass Solution:\n\t    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n\t        def dfs(n1,n2):\n\t            if n1 is None and n2 is None:\n\t                return True\n\t            elif n1 is None or n2 is None:\n\t                return False\n\t            else:\n\t                if n1.val != n2.val:return False\n\t                return dfs(n1.left,n2.left) and dfs(n1.right,n2.right)\n\t        return dfs(p,q)\n```\n复杂度：相当于遍历了两棵树，复杂度为O(n)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/22#issuecomment-2081448727","body":"题目：447回旋镖的数量\n思路： 整体思路：哈希表\n代码\n```\n    class Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        def calc(p1,p2):\n            return pow(p1[0]-p2[0],2)+pow(p1[1]-p2[1],2)\n        dis_map_list = []\n        res = 0\n        for i in range(points):\n            tmp = {}\n            for j in range(points):\n                if j == i :continue\n                dis = calc(points[i],points[j])\n                if dis not in tmp:\n                    tmp[dis]=0\n                tmp[dis] += 1\n            dis_map_list.append(tmp.copy())\n        for tmp in dis_map_list:\n            for k in tmp:\n                if tmp[k]>1:\n                    res += tmp[k]*(tmp[k]-1)\n        return res\n```\n时间复杂度：对点集中的点进行了n方的暴力枚举，复杂度为O(n^2)","onTime":true},null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/32#issuecomment-2100587094","body":"思路：主体：拓扑排序\n    \n代码：\n```\nclass Solution:\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\n        # 子方法，当某一个组对外无依赖之后，拓扑排序组内元素，并且按顺序输出\n        def tp_sort(gids,inner_p_map):\n            res = []\n            igs = {}\n            for g in gids:\n                igs[g]=0\n            for g in gids:\n                if g in inner_p_map:\n                    cs = inner_p_map[g]\n                    for ccs in cs:\n                        igs[ccs] += 1\n            while len(res) != len(gids):\n                cur = []\n                for g in  gids:\n                    if g in igs and  igs[g]==0:\n                        cur.append(g)\n                        del(igs[g])\n                        if g in inner_p_map:\n                            cs = inner_p_map[g]\n                            for ccs in cs:\n                                igs[ccs]-=1\n                if len(res) != len(gids) and not cur:return []\n                res.extend(cur)\n                \n            return res\n\n        res = []\n        groups = set()\n        inf = -100000\n        group_input_degree = {} # key 为组号，val为入度，-1组的组号为-1*项目号，当0号项目的组为-1时，取-100000表示，取巧操作\n        group_mem_id = {} # key为组号，val为组员项目id的list\n        p_map = {} # 每个项目对应的组的下游，组间依赖\n        inner_p_map = {} # 每个项目对应的组内下游，组内依赖\n        for i,x in enumerate(group):\n            if x == -1:\n                bis = beforeItems[i]\n                gid = -1 * i if i !=0 else inf\n                group_input_degree[gid] = len(bis)\n                for bi in bis:\n                    if bi not in p_map:\n                        p_map[bi] = set()\n                    p_map[bi].add(gid)\n            else:\n                gid = x \n                if gid not in group_mem_id:\n                    group_mem_id[gid] = set()\n                group_mem_id[gid].add(i)\n            groups.add(gid)\n        for gid in group_mem_id:\n            if gid < 0 :continue\n            gms = group_mem_id[gid]\n            for g in gms:\n                par = beforeItems[g]\n                if par:\n                    for p in par:\n                        if p in gms:\n                            if p not in inner_p_map:\n                                inner_p_map[p]=set()\n                            inner_p_map[p].add(g)\n                        else:\n                            if p not in p_map:\n                                p_map[p]=set()\n                            p_map[p].add(gid)\n        # 初始化每个组的入度\n        for g in groups:\n            group_input_degree[g]=0\n        for p,gg in p_map.items():\n            for g in gg:\n                group_input_degree[g] += 1\n        while group_input_degree:\n            cur = []\n            used = set()\n            for g in group_input_degree:\n                if group_input_degree[g]==0:\n                    if g < 0:\n                        it = -1 * g if g != inf else 0\n                        res.append(it)\n                        if it in p_map:\n                            cur.extend(list(p_map[it]))\n                    else:\n                        gids = group_mem_id[g]\n                        tmp = tp_sort(gids,inner_p_map)\n                        if not tmp:return []\n                        res.extend(tmp)\n                        for it in group_mem_id[g]:\n                            if it in p_map:\n                                cur.extend(list(p_map[it]))\n                    used.add(g)\n            for u in used:\n                del(group_input_degree[u])\n            if group_input_degree and not cur:return []\n            for cc in cur:\n                group_input_degree[cc]-=1\n        return res\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/38#issuecomment-2109958303","body":"思路：二分查找\n代码：\n```\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        if x <= 1:return x \n        start,end = 1,x \n        while start<end:\n            mid = (start + end + 1) // 2\n            if mid ** 2 <= x:\n                start = mid\n            else:\n                end = mid - 1\n        return start\n```\n时间复杂度：Ologn","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luzhaofeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/16#issuecomment-2071952211","body":"```python\nclass Solution:\n    def findValue(self, root):\n        q = deque([root])\n        while q:\n            node = q.popleft()\n            if node.right: q.append(node.right)\n            if node.left:  q.append(node.left)\n        return node.val\n```\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/18#issuecomment-2077013131","body":"```python\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        # dfs遍历, 得到col,row,value三元组\n        arr = []\n        def dfs(root, row, col):\n            if not root:\n                return\n            arr.append([col, row, root.val])\n            dfs(root.left, row+1, col-1)\n            dfs(root.right, row+1, col+1)\n        dfs(root, 0, 0)\n\n        # col 为第一关键字升序,row为第二关键字升序,value 为第三关键字升序\n        arr = sorted(arr, key=lambda x: (x[0], x[1], x[2]), reverse=False)\n\n        hash_ = defaultdict(list)\n        for i in arr:\n            hash_[i[0]].append(i[2])\n\n        res = []\n        for i in hash_.values():\n            res.append(i)\n\n        return res   \n``` ","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/24#issuecomment-2085394420","body":"```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        from collections import Counter\n        if not s or not words:return []\n        one_word = len(words[0])\n        word_num = len(words)\n        n = len(s)\n        words = Counter(words)\n        res = []\n        for i in range(0, one_word):\n            cur_cnt = 0\n            left = i\n            right = i\n            cur_Counter = Counter()\n            while right + one_word <= n:\n                w = s[right:right + one_word]\n                right += one_word\n                cur_Counter[w] += 1\n                cur_cnt += 1\n                while cur_Counter[w] > words[w]:\n                    left_w = s[left:left+one_word]\n                    left += one_word\n                    cur_Counter[left_w] -= 1\n                    cur_cnt -= 1\n                if cur_cnt == word_num :\n                    res.append(left)\n        return res\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/30#issuecomment-2095070598","body":"```python\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        lst1, lst2 = [], []\n        for x, y in trust:\n            lst1.append(x)\n            lst2.append(y)\n        l = list(set(range(1, n + 1)) - set(lst1))\n        return l[0] if len(l) == 1 and lst2.count(l[0]) == n - 1 else -1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/31#issuecomment-2098254749","body":"```python\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        def dfs(i, c):\n            color[i] = c\n            for j in g[i]:\n                if color[j] == c:\n                    return False\n                if color[j] == 0 and not dfs(j, 3 - c):\n                    return False\n            return True\n\n        g = defaultdict(list)\n        color = [0] * n\n        for a, b in dislikes:\n            a, b = a - 1, b - 1\n            g[a].append(b)\n            g[b].append(a)\n        return all(c or dfs(i, 1) for i, c in enumerate(color))\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/37#issuecomment-2106487362","body":"```python\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        self.quickSort(nums, 0, len(nums)-1)\n        return nums\n\n        \n    def quickSort(self, nums, left: int, right: int):\n        flag = nums[randint(left, right)]\n        i,j = left,right\n\n        while i<=j:\n            while nums[i]<flag:\n                i+=1\n            while nums[j]>flag:\n                j-=1\n            if i<=j:\n                nums[i], nums[j]=nums[j], nums[i]\n                i+=1\n                j-=1\n\n        if i<right:\n            self.quickSort(nums, i, right)\n        if left<j:\n            self.quickSort(nums, left, j)\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/44#issuecomment-2119877599","body":"```python\nSolution:\n    def maxVowels(self, s: str, k: int) -> int:\n        n = len(s)\n        ans = 0\n        for i in range(k):\n            if s[i] in \"aeiou\":\n                ans += 1\n\n        cnt = ans\n        for i in range(k, n):\n            if s[i] in \"aeiou\":\n                cnt += 1\n            if s[i - k] in \"aeiou\":\n                cnt -= 1\n            ans = max(ans, cnt)\n        return ans\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/47#issuecomment-2126936327","body":"```python\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        \n        if len(t) > len(s):\n            return ''        \n        \n        cnt = collections.Counter(t)   \n        need = len(t)                   \n        \n        n = len(s)\n        start, end = 0, -1         \n        min_len = n + 1             \n        left = right = 0           \n        for right in range(n):\n            \n            # 窗口右边界右移一位\n            ch = s[right]             \n            if ch in cnt:               \n                if cnt[ch] > 0:         \n                    need -= 1          \n                cnt[ch] -= 1\n            \n            # 窗口左边界持续右移\n            while need == 0:            \n                if right - left + 1 < min_len:     \n                    min_len = right - left + 1\n                    start, end = left, right\n                \n                ch = s[left]            \n                if ch in cnt:           \n                    if cnt[ch] >= 0:    \n                        need += 1      \n                    cnt[ch] += 1\n                left += 1              \n        \n        return s[start: end+1]\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/61#issuecomment-2152188853","body":"```python\nclass Solution:\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n        import functools\n        if  desiredTotal <= maxChoosableInteger: return True\n        if sum(range(maxChoosableInteger + 1)) < desiredTotal: return False\n        \n        @functools.lru_cache(None)\n        def dfs(used, desiredTotal):\n            for i in range(maxChoosableInteger):\n                cur = 1 << i\n                if cur & used == 0:\n                    if desiredTotal <= i + 1 or not dfs(cur | used, desiredTotal - i - 1):\n                        return True\n            return False\n        \n        return dfs(0, desiredTotal)\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/66#issuecomment-2159604969","body":"```python\nclass Solution(object):\n    def findContentChildren(self, g, s):\n        g.sort(), s.sort()\n        gi, gn, si, sn, cnt = 0, len(g), 0, len(s), 0\n        while gi < gn and si < sn:\n            if g[gi] <= s[si]: \n                cnt += 1\n                gi += 1\n            si += 1\n        return cnt\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/69#issuecomment-2167132097","body":"```python\nclass Solution:\n    def numTrees(self, n: int) -> int:\n        dp = [0 for _ in range(n+1)]\n        dp[0] = 1\n\n        for i in range(1, n + 1):\n            dp[i] = sum(dp[j] * dp[i - j - 1] for j in range(i))\n        return dp[-1]\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/72#issuecomment-2173053671","body":"```python\nclass Solution(object):\n  def singleNumber(self, nums):\n      xor_sum = 0\n      for num in nums:\n          xor_sum ^= num\n      # lsb = xorsum & (-xorsum)\n      cls = xor_sum - (xor_sum & (xor_sum-1))\n      x1 = x2 = 0\n      for num in nums:\n          if num & cls:\n              x1 ^= num\n          else:\n              x2 ^= num\n\n      return [x1, x2]\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/75#issuecomment-2180472369","body":"```python\nclass MapSum:\n    def __init__(self):\n        self.d = {}\n        self.p = collections.defaultdict(set)\n\n    def insert(self, key: str, val: int) -> None:\n        self.d[key] = val\n        for i in range(len(key)):\n            self.p[key[: i + 1]].add(key)\n\n    def sum(self, prefix: str) -> int:\n        return sum(self.d[key] for key in self.p[prefix])\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/80#issuecomment-2188567390","body":"```python\nclass Solution:\n    def pruneTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if (not root): return\n        if (not root.left) and (not root.right):\n            return root if root.val==1 else None\n        # 处理左子树\n        root.left = self.pruneTree(root.left)\n        # 处理右子树\n        root.right = self.pruneTree(root.right)\n        if root.val==1 or (root.left or root.right):\n            return root\n        # 否则 说明左右节点都是空 并且root.val==0\n        return None\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null],"lizhao-liu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/18#issuecomment-2076790754","body":"```\r\nclass Solution {\r\n    func verticalTraversal(_ root: TreeNode?) -> [[Int]] {\r\n    var resultArr = [[Int]]()\r\n    var dict = [Int: Array<Dictionary<Int, Int>>]()\r\n    dfs(node:root, row:0, col:0, map:&dict)\r\n\r\n    for xkey in dict.keys.sorted() {\r\n        let arr = dict[xkey]!\r\n        var yArr = [Int]()\r\n        let sortedArr = arr.sorted { (dict1, dict2) -> Bool in\r\n            let key1 = dict1.keys.first!\r\n            let key2 = dict2.keys.first!\r\n            if key1 > key2 {\r\n                return true\r\n            }else if key1 == key2 {\r\n                return dict1[key1]! < dict2[key2]!\r\n            }\r\n            return false\r\n        }\r\n        for yDict in sortedArr {\r\n            for (_,value) in yDict {\r\n                yArr.append(value)\r\n            }\r\n        }\r\n        resultArr.append(yArr)\r\n    }\r\n    return resultArr\r\n    \r\n    }\r\n\r\n\r\n    func dfs(node:TreeNode?, row:Int, col:Int, map:inout [Int: Array<Dictionary<Int, Int>>]) {\r\n        guard let node = node else {\r\n            return;\r\n        }\r\n        map[col, default: []].append([row:node.val])\r\n        dfs(node:node.left, row: row-1, col: col-1, map: &map)\r\n        dfs(node:node.right, row: row-1, col: col+1, map: &map)\r\n    }\r\n}\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/23#issuecomment-2082385336","body":"```\r\n\r\nclass Solution {\r\n    func lengthOfLongestSubstring(_ s: String) -> Int {\r\n        if s.isEmpty {\r\n            return 0\r\n        }\r\n        var left = s.startIndex, right = s.startIndex\r\n        var maxLength = Int.min\r\n        var map = Set<Character>.init()\r\n        while right < s.endIndex {\r\n            if !map.contains(s[right]) {\r\n                map.insert(s[right])\r\n                right = s.index(after: right)\r\n                maxLength = max(maxLength, s.distance(from: left, to: right))\r\n            } else {\r\n                map.remove(s[left])\r\n                left = s.index(after: left)\r\n            }\r\n        }\r\n        return maxLength\r\n    }\r\n    \r\n}\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/30#issuecomment-2095674940","body":"```\r\nfunc findJudge(_ n: Int, _ trust: [[Int]]) -> Int {\r\n    var trustTo = Array(repeating: 0, count: n + 1)\r\n    var trusted = Array(repeating: 0, count: n + 1)\r\n\r\n    for i in trust {\r\n        trustTo[i[0]] += 1 // 统计每个人信任别人的次数\r\n        trusted[i[1]] += 1 // 统计每个人被信任的次数\r\n    }\r\n\r\n    for i in 1...n {\r\n        if trustTo[i] == 0 && trusted[i] == n - 1 {\r\n            return i\r\n        }\r\n    }\r\n\r\n    return -1\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/31#issuecomment-2097773222","body":"```\r\nclass Solution {\r\n    func possibleBipartition(_ n: Int, _ dislikes: [[Int]]) -> Bool {\r\n        var vertexMatrix = [[Int]](repeating: [Int](repeating: 0, count: n+1), count: n+1)\r\n        \r\n        for relation in dislikes {\r\n            vertexMatrix[relation[0]][relation[1]] = 1\r\n            vertexMatrix[relation[1]][relation[0]] = 1\r\n        }\r\n        \r\n        var colors = [Int](repeating: 0, count: n+1)\r\n        for i in 1...n {\r\n            if  colors[i] == 0 && !dfs(vertexMatrix, &colors, i, 1){\r\n                return false\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n    func dfs(_ vertexMatrix: [[Int]], _ colors: inout [Int], _ curr : Int, _ color : Int) ->  Bool {\r\n        colors[curr] = color\r\n        for vertex in 1..<vertexMatrix[curr].count {\r\n            if vertexMatrix[curr][vertex] == 1 {\r\n                if colors[vertex] == color {\r\n                    return false\r\n                }\r\n                if colors[vertex] == 0 && !dfs(vertexMatrix, &colors, vertex, -1 * color) {\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n        return true\r\n        \r\n    }\r\n}\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/35#issuecomment-2105592872","body":"```\r\n    func numberOfRounds(_ loginTime: String, _ logoutTime: String) -> Int {\r\n        let (startM, endM) = getMinutes(loginTime, logoutTime)\r\n        \r\n        let start = Int(ceil(Double(startM) / 15.0))\r\n        let end = Int(floor(Double(endM) / 15))\r\n        \r\n       return max(end - start, 0)\r\n\r\n    }\r\n    \r\n    func getMinutes(_ startTime: String, _ endTimes: String) -> (Int, Int) {\r\n        var components = startTime.components(separatedBy: \":\")\r\n        let startH = Int(components[0])!\r\n        var startM = Int(components[1])!\r\n        \r\n        \r\n        components = endTimes.components(separatedBy: \":\")\r\n        var endH = Int(components[0])!\r\n        var endM = Int(components[1])!\r\n        \r\n        if (startH > endH) || (startH == endH && startM > endM) {\r\n            endH += 24\r\n        }\r\n        \r\n        startM = startH * 60 + startM\r\n        endM = endH * 60 + endM\r\n        \r\n        return (startM, endM)\r\n    }\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/37#issuecomment-2107175672","body":"```\r\nclass Solution {\r\n    func sortArray(_ nums: [Int]) -> [Int] {\r\n      let min = nums.min()!\r\n      let max = nums.max()!\r\n    \r\n      var countArr = [Int](repeating: 0, count: max - min + 1)\r\n      for num in nums {\r\n        countArr[num-min] += 1\r\n      }\r\n    \r\n      var res = [Int]()\r\n      for i in 0..<countArr.count {\r\n        if countArr[i] == 0 {\r\n          continue\r\n        }\r\n        for _ in 0..<countArr[i] {\r\n          res.append(i+min)\r\n        }\r\n      }\r\n      return res\r\n    }\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/39#issuecomment-2112112204","body":"```\r\nfunc firstBadVersion(_ n: Int) -> Int {\r\n    var left = 1\r\n    var right = n\r\n    while left <= right {\r\n        var mid = left + (right - left) / 2\r\n        if isBadVersion(mid) {\r\n            right = mid - 1\r\n        } else {\r\n            left = mid + 1\r\n        }\r\n    }\r\n    return left\r\n}\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/46#issuecomment-2124176012","body":"```\r\nfunc findAnagrams(_ s: String, _ p: String) -> [Int] {\r\n    guard !s.isEmpty && !p.isEmpty && s.count >= p.count else { return [] }\r\n    \r\n    let length = p.count\r\n    var res = [Int]()\r\n    \r\n    var window = [Character : Int]()\r\n    var pDict = [Character : Int]()\r\n\r\n    var sArray = Array(s)\r\n    \r\n    for c in p {\r\n        pDict[c, default: 0] += 1\r\n    }\r\n    \r\n    for r in 0..<s.count {\r\n        if r >= length {\r\n            var i = r - length\r\n            window[sArray[i]] = window[sArray[i]]! - 1\r\n            if window[sArray[i]] == 0 {\r\n                window.removeValue(forKey: sArray[i])\r\n            }\r\n        }\r\n        \r\n        let character = sArray[r]\r\n        window[character, default: 0] += 1 \r\n        if window == pDict {\r\n            res.append(r - length + 1)\r\n        }\r\n    }\r\n    \r\n    return res\r\n}\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/53#issuecomment-2137202447","body":"```\r\nclass Solution {\r\n    private var status = [Int]()\r\n    func maxCandies(_ status: [Int], _ candies: [Int], _ keys: [[Int]], _ containedBoxes: [[Int]], _ initialBoxes: [Int]) -> Int {\r\n        self.status = status\r\n        var totalCandies = 0\r\n        var myKeys: Set<Int> = []\r\n        var unOpenedBoxes: Set<Int> = []\r\n        var boxQueue = initialBoxes\r\n        \r\n        while !boxQueue.isEmpty {\r\n            let box = boxQueue.removeFirst()\r\n            \r\n            if self.status[box] == 1 { // box is open\r\n                totalCandies += candies[box]\r\n                \r\n                for key in keys[box] {\r\n                    if unOpenedBoxes.contains(key) {\r\n                        unOpenedBoxes.remove(key)\r\n                        self.status[key] = 1\r\n                        boxQueue.append(key)\r\n                    } else {\r\n                        myKeys.insert(key)\r\n                    }\r\n                }\r\n                \r\n                for containedBox in containedBoxes[box] {\r\n                    boxQueue.append(containedBox)\r\n                }\r\n                \r\n            } else {\r\n                if myKeys.contains(box) {\r\n                    self.status[box] = 1\r\n                    boxQueue.append(box)\r\n                } else {\r\n                    unOpenedBoxes.insert(box)\r\n                }\r\n            }\r\n        }\r\n        \r\n        return totalCandies\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/60#issuecomment-2150251659","body":"```\r\nfunc knightProbability(_ n: Int, _ k: Int, _ row: Int, _ column: Int) -> Double {\r\n    let directions = [(-2, -1), (-1, -2), (1, -2), (2, -1),\r\n                      (2, 1), (1, 2), (-1, 2), (-2, 1)]\r\n    \r\n    var dpPrev = Array(repeating: Array(repeating: 0.0, count: n), count: n)\r\n    var dpCurr = Array(repeating: Array(repeating: 0.0, count: n), count: n)\r\n    \r\n    dpPrev[row][column] = 1.0\r\n    \r\n    if k < 1 {\r\n        return 1\r\n    }\r\n    \r\n    for _ in 1...k {\r\n        for i in 0..<n {\r\n            for j in 0..<n {\r\n                if dpPrev[i][j] > 0 {\r\n                    for direction in directions {\r\n                        let ni = i + direction.0\r\n                        let nj = j + direction.1\r\n                        if ni >= 0 && ni < n && nj >= 0 && nj < n {\r\n                            dpCurr[ni][nj] += dpPrev[i][j] / 8.0\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        dpPrev = dpCurr\r\n        dpCurr = Array(repeating: Array(repeating: 0.0, count: n), count: n)\r\n    }\r\n    \r\n    let totalProbability = dpPrev.flatMap { $0 }.reduce(0.0, +)\r\n    return totalProbability\r\n}\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/67#issuecomment-2163327350","body":"```\r\nfunc eraseOverlapIntervals(_ intervals: [[Int]]) -> Int {\r\n    guard intervals.count > 1 else {\r\n        return 0\r\n    }\r\n\r\n    let sortedIntervals = intervals.sorted { $0[1] < $1[1] }\r\n\r\n    var nonOverlapCount = 1\r\n    var end = sortedIntervals[0][1]\r\n\r\n    for i in 1..<sortedIntervals.count {\r\n        if sortedIntervals[i][0] >= end {\r\n            nonOverlapCount += 1\r\n            end = sortedIntervals[i][1]\r\n        }\r\n    }\r\n\r\n    return intervals.count - nonOverlapCount\r\n}\r\n\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/74#issuecomment-2179005600","body":"```\r\nclass TrieNode {\r\n    var children: [Character: TrieNode] = [:]\r\n    var isEndOfWord: Bool = false\r\n}\r\n\r\n\r\nclass Trie {\r\n    private let root: TrieNode\r\n    init() {\r\n        root = TrieNode()\r\n    }\r\n    \r\n    func insert(_ word: String) {\r\n        var currentNode = root\r\n        for char in word {\r\n            if currentNode.children[char] == nil {\r\n                currentNode.children[char] = TrieNode()\r\n            }\r\n            currentNode = currentNode.children[char]!\r\n        }\r\n        currentNode.isEndOfWord = true\r\n    }\r\n    \r\n    func search(_ word: String) -> Bool {\r\n        var currentNode = root\r\n        for char in word {\r\n            if currentNode.children[char] == nil {\r\n                return false\r\n            }\r\n            currentNode = currentNode.children[char]!\r\n        }\r\n        return currentNode.isEndOfWord\r\n    }\r\n\r\n    func startsWith(_ prefix: String) -> Bool {\r\n        var currentNode = root\r\n        for char in prefix {\r\n            if currentNode.children[char] == nil {\r\n                return false\r\n            }\r\n            currentNode = currentNode.children[char]!\r\n        }\r\n        return true\r\n    }\r\n}\r\n\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/81#issuecomment-2191869315","body":"```\r\nfunc combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {\r\n    var result = [[Int]]()\r\n    var combination = [Int]()\r\n    \r\n    func backtrack(_ start: Int, _ target: Int) {\r\n        if target == 0 {\r\n            result.append(combination)\r\n            return\r\n        }\r\n        if target < 0 {\r\n            return\r\n        }\r\n        for i in start..<candidates.count {\r\n            combination.append(candidates[i])\r\n            backtrack(i, target - candidates[i])\r\n            combination.removeLast()\r\n        }\r\n    }\r\n    \r\n    backtrack(0, target)\r\n    return result\r\n}\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null],"yukibei":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/18#issuecomment-2077074239","body":"class Solution {\r\npublic:\r\n    vector<vector<int>> verticalTraversal(TreeNode *root) {\r\n        vector<tuple<int, int, int>> data;\r\n        function<void(TreeNode*, int, int)> dfs = [&](TreeNode *node, int row, int col) {\r\n            if (node == nullptr) {\r\n                return;\r\n            }\r\n            data.emplace_back(col, row, node->val);\r\n            dfs(node->left, row + 1, col - 1);\r\n            dfs(node->right, row + 1, col + 1);\r\n        };\r\n        dfs(root, 0, 0);\r\n\r\n        vector<vector<int>> ans;\r\n        ranges::sort(data);\r\n        int last_col = INT_MIN;\r\n        for (auto &[col, _, val]: data) {\r\n            if (col != last_col) {\r\n                last_col = col;\r\n                ans.push_back({});\r\n            }\r\n            ans.back().push_back(val);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n\r\n。\r\n时间复杂度：O(nlogn)，其中 nnn 为二叉树的节点个数。瓶颈在排序上。\r\n空间复杂度：O(n)。","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/23#issuecomment-2082358587","body":"用双指针（滑动窗口）\r\n\r\n\r\nclass Solution {\r\npublic:\r\n   int lengthOfLongestSubstring(string s) {\r\n       int len = s.size();\r\n       int res = 0;\r\n       int r = 0;\r\n       unordered_set<char> st;\r\n       for (int i = 0; i < len; i ++) {\r\n           while (r < len && !st.count(s[r])) {\r\n               st.insert(s[r]);\r\n               r ++;\r\n           }\r\n           res = max(res, r - i);\r\n           st.erase(s[i]);\r\n       }\r\n       return res;\r\n   }\r\n};\r\n时间空间为（n）","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/30#issuecomment-2095109254","body":"class Solution {\r\npublic:\r\n    int findJudge(int n, vector<vector<int>>& trust) {\r\n        vector<int> inDegrees(n + 1);\r\n        vector<int> outDegrees(n + 1);\r\n        for (auto& edge : trust) {\r\n            int x = edge[0], y = edge[1];\r\n            ++inDegrees[y];\r\n            ++outDegrees[x];\r\n        }\r\n        for (int i = 1; i <= n; ++i) {\r\n            if (inDegrees[i] == n - 1 && outDegrees[i] == 0) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n};\r\n复杂度分析\r\n时间复杂度n+m\r\n空间复杂度n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/37#issuecomment-2106961218","body":"class Solution {\r\npublic:\r\n    vector<int> sortArray(vector<int>& nums) {\r\n        sort(nums.begin(),nums.end());\r\n        return nums;\r\n    }\r\n｝；\r\n时间复杂度n\r\n空间复杂度n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/42#issuecomment-2118773213","body":"class Solution {\r\npublic:\r\n    int findRadius(vector<int> &houses, vector<int> &heaters) {\r\n        int ans = 0;\r\n        sort(heaters.begin(), heaters.end());\r\n        for (int house: houses) {\r\n            int j = upper_bound(heaters.begin(), heaters.end(), house) - heaters.begin();\r\n            int i = j - 1;\r\n            int rightDistance = j >= heaters.size() ? INT_MAX : heaters[j] - house;\r\n            int leftDistance = i < 0 ? INT_MAX : house - heaters[i];\r\n            int curDistance = min(leftDistance, rightDistance);\r\n            ans = max(ans, curDistance);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/46#issuecomment-2123969348","body":"\r\nclass Solution {\r\npublic:\r\n    vector<int> findAnagrams(string s, string p) {\r\n        int sLen = s.size(), pLen = p.size();\r\n\r\n        if (sLen < pLen) {\r\n            return vector<int>();\r\n        }\r\n\r\n        vector<int> ans;\r\n        vector<int> sCount(26);\r\n        vector<int> pCount(26);\r\n        for (int i = 0; i < pLen; ++i) {\r\n            ++sCount[s[i] - 'a'];\r\n            ++pCount[p[i] - 'a'];\r\n        }\r\n\r\n        if (sCount == pCount) {\r\n            ans.emplace_back(0);\r\n        }\r\n\r\n        for (int i = 0; i < sLen - pLen; ++i) {\r\n            --sCount[s[i] - 'a'];\r\n            ++sCount[s[i + pLen] - 'a'];\r\n\r\n            if (sCount == pCount) {\r\n                ans.emplace_back(i + 1);\r\n            }\r\n        }\r\n\r\n        return ans;\r\n    }\r\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hermione666":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/29#issuecomment-2094672792","body":"from collections import deque\n\nclass Solution:\n    def maxSlidingWindow(self, nums, k):\n        q = deque()\n        res = []\n        \n        for i in range(len(nums)):\n            if q and q[0] < i - k + 1:\n                q.popleft()\n                \n            while q and nums[q[-1]] < nums[i]:\n                q.pop()\n                \n            q.append(i)\n            \n            if i >= k - 1:\n                res.append(nums[q[0]])\n        \n        return res\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/30#issuecomment-2096382557","body":"class Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n         # Create a list to track the trust score for each person\n        trusted = [0] * n\n        \n        # Update trust scores based on the trust relationships\n        for a, b in trust:\n            trusted[a - 1] -= 1  # Person a trusts someone, decrement\n            trusted[b - 1] += 1  # Person b is trusted by someone, increment\n        \n        # Identify the judge by checking if their trust score is n -1\n        for i in range(n):\n            if trusted[i] == n- 1:\n                return i + 1  # Return the one-based index of the judge\n        \n        # If no judge is found, return -1\n        return -1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/31#issuecomment-2098782729","body":"class Solution:\n    def __init__(self):\n        self.N = 2005\n        self.p = [i for i in range(2 * self.N)]\n    \n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        for i in range(1, 2 * self.N):\n            self.p[i] = i\n        for d in dislikes:\n            a, b = d[0], d[1]\n            if self.find(a) == self.find(b):\n                return False\n            else:\n                self.p[self.find(a)] = self.find(b + n)\n                self.p[self.find(b)] = self.find(a + n)\n        return True\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/32#issuecomment-2100854857","body":"class Solution:\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\n        # Dependency counters for items and groups\n        item_deps_count = [0] * n\n        group_deps_count = [0] * m\n        \n        # Queue for items without groups and queues for each group\n        no_group_items = []\n        group_items = [[] for _ in range(m)]\n        ready_groups = []\n        \n        # Adjacency list for tracking which items depend on a given item\n        dependents = [[] for _ in range(n)]\n        \n        # Build dependency graph and initialize queues\n        for item, dependencies in enumerate(beforeItems):\n            item_deps_count[item] = len(dependencies)\n            item_group = group[item]\n            for dep_item in dependencies:\n                dependents[dep_item].append(item)\n                if item_group != -1 and group[dep_item] != item_group:\n                    group_deps_count[item_group] += 1\n            if not dependencies:\n                (group_items[item_group] if item_group != -1 else no_group_items).append(item)\n        \n        # Initialize the queue of ready groups\n        for i, deps in enumerate(group_deps_count):\n            if deps == 0:\n                ready_groups.append(group_items[i])\n        \n        result = []\n        while ready_groups or no_group_items:\n            current_queue = ready_groups.pop() if ready_groups else no_group_items\n            \n            while current_queue:\n                item = current_queue.pop()\n                result.append(item)\n                item_group = group[item]\n                \n                # Process all items depending on the current item\n                for dependent in dependents[item]:\n                    dependent_group = group[dependent]\n                    item_deps_count[dependent] -= 1\n                    if not item_deps_count[dependent]:\n                        (group_items[dependent_group] if dependent_group != -1 else no_group_items).append(dependent)\n                    \n                    # If dependent is in a different group, manage group dependencies\n                    if dependent_group != -1 and dependent_group != item_group:\n                        group_deps_count[dependent_group] -= 1\n                        if group_deps_count[dependent_group] == 0:\n                            ready_groups.append(group_items[dependent_group])\n        \n        return result if len(result) == n else []\n\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/35#issuecomment-2105933918","body":"from datetime import datetime, timedelta\nimport math\nclass Solution:\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\n\n\n        time1 = datetime.strptime(loginTime, \"%H:%M\")\n        time2 = datetime.strptime(logoutTime, \"%H:%M\")\n\n        if time2<time1:\n            time2=time2.replace(day=time2.day+1)\n\n        rounded_up_minutes = math.ceil(time1.minute /15) * 15\n        if rounded_up_minutes==60:\n            try:\n                time1 = time1.replace(hour=time1.hour+1)\n                time1 = time1.replace(minute=0)\n            except:\n                time1 = time1.replace(day=time1.day+1)\n                time1 = time1.replace(hour=0)\n                time1 = time1.replace(minute=0)\n\n        else:\n            time1 = time1.replace(minute=rounded_up_minutes)\n\n        rounded_down_minutes = (time2.minute // 15) * 15\n        # print(rounded_down_minutes)\n\n        time2 = time2.replace(minute=rounded_down_minutes)\n        # print(time1)\n        # print(time2)\n\n        time_difference=time2-time1\n\n    \n        interval = timedelta(minutes=15)\n        num_intervals=time_difference / interval #this gives a floating point number\n        if num_intervals<=0:\n            return 0\n        # print(time_difference)\n\n        return int(num_intervals)\n        ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/36#issuecomment-2106297527","body":"class Solution:\n    def minCharacters(self, a: str, b: str) -> int:\n        acnt = [0] * 26\n        bcnt = [0] * 26\n        an, bn = len(a), len(b)\n        \n        for c in a:\n            acnt[ord(c) - ord('a')] += 1\n        for c in b:\n            bcnt[ord(c) - ord('a')] += 1\n        \n        ans = float('inf')\n        asum, bsum = 0, 0\n        \n        for i in range(25):  \n            asum += acnt[i]\n            bsum += bcnt[i]\n            ans = min(ans, min(an - acnt[i] + bn - bcnt[i], min(an - asum + bsum, bn - bsum + asum)))\n        \n        # Handle the last character\n        ans = min(ans, an - acnt[25] + bn - bcnt[25])\n        \n        return ans\n\n        ","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/40#issuecomment-2113993537","body":"from typing import List\nimport bisect\n\nclass Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        sorted_list = []\n        reverse_pairs_count = 0\n\n        for num in reversed(nums):\n      \n            reverse_pairs_count += bisect.bisect_left(sorted_list, num)\n            \n  \n            bisect.insort(sorted_list, 2 * num)\n        \n        return reverse_pairs_count\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/41#issuecomment-2117866317","body":"class Solution:\n    def solve(self, nums):\n        nums.sort()\n        N = len(nums)\n        if N <= 3:\n            return 0\n        LIGHTS = 3\n\n        def possible(diameter):\n            start = nums[0]\n            end = start + diameter\n            for i in range(LIGHTS):\n                idx = bisect_right(nums, end)\n                if idx >= N:\n                    return True\n                start = nums[idx]\n                end = start + diameter\n            return False\n\n        l, r = 0, nums[-1] - nums[0]\n        while l <= r:\n            mid = (l + r) // 2\n            if possible(mid):\n                r = mid - 1\n            else:\n                l = mid + 1\n        return l / 2","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/45#issuecomment-2121367787","body":"class Solution:\n    def new21Game(self, n: int, k: int, w: int) -> float:\n        if k == 0 or n >= k + w - 1:\n            return 1.0\n        \n        dp = [0.0] * (k + w)\n        current_sum = 0.0\n        \n        for i in range(k, k + w):\n            dp[i] = 1.0 if i <= n else 0.0\n            current_sum += dp[i]\n        \n        for i in range(k - 1, -1, -1):\n            dp[i] = current_sum / w\n            current_sum = current_sum - dp[i + w] + dp[i]\n        \n        return dp[0]\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/46#issuecomment-2125138336","body":"class Solution:\n    def findAnagrams(self, s: str, t: str) -> List[int]:\n        need = {}\n        for char in t:\n            if char in need:\n                need[char] += 1\n            else:\n                need[char] = 1\n        \n        window = {}\n        left, right = 0, 0\n        valid = 0\n        res = []\n\n        while right < len(s):\n            c = s[right]\n            right += 1\n            if c in need:\n                if c in window:\n                    window[c] += 1\n                else:\n                    window[c] = 1\n                if window[c] == need[c]:\n                    valid += 1\n            \n            while right - left >= len(t):\n                if valid == len(need):\n                    res.append(left)\n                d = s[left]\n                left += 1\n                if d in need:\n                    if window[d] == need[d]:\n                        valid -= 1\n                    window[d] -= 1\n\n        return res\n\n            ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/47#issuecomment-2127446959","body":"class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        # Initialize variables\n        m, n = len(s), len(t)\n        \n        # If s is shorter than t, return empty string\n        if m < n:\n            return \"\"\n        \n        # Create dictionaries to count characters in t and the current window in s\n        dictt = {}\n        for char in t:\n            if char in dictt:\n                dictt[char] += 1\n            else:\n                dictt[char] = 1\n\n        dicts = {}\n        \n        # Initialize the window pointers and variables to track the minimum window\n        left, right = 0, 0\n        required = len(dictt)\n        formed = 0\n        min_len = float('inf')\n        ans = \"\"\n\n        while right < m:\n            # Add characters from the right end to the current window\n            char = s[right]\n            if char in dicts:\n                dicts[char] += 1\n            else:\n                dicts[char] = 1\n\n            # Check if the current character makes the window valid\n            if char in dictt and dicts[char] == dictt[char]:\n                formed += 1\n\n            # Try to contract the window from the left until it's no longer valid\n            while left <= right and formed == required:\n                char = s[left]\n                \n                # Update the minimum window\n                if right - left + 1 < min_len:\n                    min_len = right - left + 1\n                    ans = s[left:right + 1]\n\n                # Remove the leftmost character from the window\n                dicts[char] -= 1\n                if char in dictt and dicts[char] < dictt[char]:\n                    formed -= 1\n                \n                left += 1\n            \n            # Move the right end of the window to the right\n            right += 1\n        \n        return ans\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/49#issuecomment-2130742632","body":"class Solution:\n    def readBinaryWatch(self,num: int) -> list:\n        def count1(n):\n            return bin(n).count('1')\n        \n        res = []\n        # Directly iterate from 0:00 to 11:59, count the number of 1s in the binary representation\n        for i in range(12):\n            for j in range(60):\n                if count1(i) + count1(j) == num:\n                    # Format the time correctly with leading zeros for minutes less than 10\n                    res.append(f\"{i}:{j:02d}\")\n        return res\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/50#issuecomment-2132066226","body":"class Solution:\n    def totalNQueens(self, n: int) -> int:\n        ans = 0\n        # Initialize the markers for columns and diagonals\n        on_path = [False] * n\n        diag1 = [False] * (2 * n - 1)\n        diag2 = [False] * (2 * n - 1)\n        \n        def dfs(r):\n            nonlocal ans\n            if r == n:\n                ans += 1\n                return\n            \n            for c in range(n):\n                # Calculate the indices for the diagonals\n                d1 = r + c\n                d2 = r - c + n - 1\n                \n                # Check if the column and diagonals are not attacked\n                if not on_path[c] and not diag1[d1] and not diag2[d2]:\n                    # Place the queen\n                    on_path[c] = diag1[d1] = diag2[d2] = True\n                    # Move to the next row\n                    dfs(r + 1)\n                    # Remove the queen and restore the state\n                    on_path[c] = diag1[d1] = diag2[d2] = False\n        \n        dfs(0)\n        return ans\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/56#issuecomment-2143454608","body":"class Solution:\n    def rob(self, nums: List[int]) -> int:\n        prev = 0\n        curr = 0\n        \n        for i in nums:}\n            temp = max(curr, prev + i)\n            prev = curr\n            curr = temp\n            # 循环结束时，curr 表示 dp[k]，prev 表示 dp[k-1]\n\n        return curr","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/59#issuecomment-2147813622","body":"class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = [[1]*n] + [[1]+[0] * (n-1) for _ in range(m-1)]\n        #print(dp)\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        return dp[-1][-1]\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/65#issuecomment-2158730010","body":"class Solution:\n    def change(self, amount: int, coins: list[int]) -> int:\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n        for coin in coins:\n            for i in range(coin, amount + 1):\n                dp[i] += dp[i - coin]\n        return dp[amount]","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/72#issuecomment-2173627445","body":"class Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        xorsum = 0\n        for num in nums:\n            xorsum ^= num\n        \n        lsb = xorsum & (-xorsum)\n        type1 = type2 = 0\n        for num in nums:\n            if num & lsb:\n                type1 ^= num\n            else:\n                type2 ^= num\n        \n        return [type1, type2]","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yyyyytc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/34#issuecomment-2104720983","body":"确保有任务时才从堆中取任务执行，堆为空时时间跳转到下一个任务的时间，不应该在当前时间上增加。\nclass Solution {\n    func getOrder(_ tasks: [[Int]]) -> [Int] {\n    let indexedTasks = tasks.enumerated().map { ($0.element[0], $0.element[1], $0.offset) }\n    let sortedTasks = indexedTasks.sorted { $0.0 < $1.0 }\n\n    var result: [Int] = []\n    var heap: [(Int, Int)] = []  // (processingTime, index)\n    var index = 0\n    var time = 0\n    let n = tasks.count\n\n    while index < n || !heap.isEmpty {\n        if heap.isEmpty {\n            time = max(time, sortedTasks[index].0)\n        }\n\n        while index < n && sortedTasks[index].0 <= time {\n            heap.append((sortedTasks[index].1, sortedTasks[index].2))\n            heap.sort { $0.0 < $1.0 }  // 保证每次都是最小堆\n            index += 1\n        }\n\n        let task = heap.removeFirst()  // 弹出堆顶元素\n        time += task.0\n        result.append(task.1)\n    }\n\n    return result\n}\n}\n时间复杂度为O(n log n)\n空间复杂度为O(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/38#issuecomment-2109235773","body":"二分查找法\nclass Solution {\n    func mySqrt(_ x: Int) -> Int {\n    if x < 2 {\n        return x\n    }\n    \n    var left = 1\n    var right = x / 2\n    \n    while left <= right {\n        let mid = left + (right - left) / 2\n        let square = mid * mid\n        if square == x {\n            return mid\n        } else if square < x {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    \n    return right\n}\n}\no(logx)  o(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zin-next":[{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/1#issuecomment-2042264449","body":"## 题解\r\n\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n  const arr = [];\r\n  let carry = 0;\r\n  for (let i = num.length - 1; i >= 0; i--) {\r\n    let sum = num[i] + k % 10 + carry;\r\n    carry = Math.floor(sum / 10);\r\n    sum = sum % 10;\r\n    arr.unshift(sum);\r\n    k = Math.floor(k / 10); \r\n  }\r\n\r\n  for (; k > 0 || carry > 0 ;) {\r\n    let sum = k % 10 + carry;\r\n    carry = Math.floor(sum / 10);\r\n    arr.unshift(sum % 10);\r\n    k = Math.floor(k / 10);\r\n  }\r\n\r\n  return arr;\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n时间复杂度： 取决于num的长度和k的大小(取最大)：O(n)\r\n空间复杂度：常量忽略，只定义了一个arr：O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/2#issuecomment-2044578441","body":"## 题解\n```js\nfunction shortestToChar(s, c) {\n  var arr = new Array(s.length);\n  var left = -Infinity\n  var right = s.indexOf(c)\n  for (var i = 0; i < s.length; i++) {\n    if(i === right){\n      left = right\n      right = s.indexOf(c, right+1)\n    }\n    arr[i] = Math.min(right < 0 ? Infinity : right - i, i - left)\n  }\n  console.log(arr)\n  return arr\n}\n```\n\n## 复杂度分析\n双指针，只有一次循环，时间复杂度O(n)\n空间复杂度取决去数据规模 O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/3#issuecomment-2046658210","body":"## 题解\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.stack = []\n  this.length  = maxSize\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if(this.stack.length !== this.length){\n    this.stack.push(x);\n  }\n\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  if(this.stack.length === 0) return -1\n  return this.stack.pop();\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  const l =  k  > this.stack.length ? this.stack.length : k\n  for(let i = 0; i < l; i++) {\n    this.stack[i] += val\n  }\n};\n\n```\n\n## 复杂度\n时间复杂度：push、pop O(1) increment O(n)\n空间复杂度：push、pop O(1) increment O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/4#issuecomment-2049545313","body":"## 思路\n使用栈结构，存放string和num，然后匹配`]`依次推出\n```js\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n  var stack = []\n  var string = ''\n  var num = 0\n  for (var i = 0; i < s.length; i++) {\n    if(!isNaN(s[i])) {\n      num = num * 10 + Number(s[i])\n    }else if(s[i] === '[') {\n      stack.push([string, num])\n      string = ''\n      num = 0\n    }else if(s[i] === ']'){\n      const val = stack.pop()\n      string = val[0] + string.repeat(val[1])\n    }else{\n      string += s[i]\n    }\n  }\n  console.log(string)\n  return string\n};\n```\n\n## 复杂度\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/5#issuecomment-2052022040","body":"```js\n\nvar MyQueue = function() {\n    this.stack1 = []; \n    this.stack2 = []; \n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.stack1.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if (this.stack2.length === 0) {\n        while (this.stack1.length > 0) {\n            this.stack2.push(this.stack1.pop());\n        }\n    }\n    return this.stack2.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if (this.stack2.length === 0) {\n        while (this.stack1.length > 0) {\n            this.stack2.push(this.stack1.pop());\n        }\n    }\n    return this.stack2[this.stack2.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.stack1.length === 0 && this.stack2.length === 0;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n\n时间复杂度 push, pop, peek, O(N); empty O(1)\n空间复杂度 O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/7#issuecomment-2056944475","body":"```js\r\nvar rotateRight = function(head, k) {\r\n    if (!head || !head.next || k === 0) {\r\n        return head;\r\n    }\r\n\r\n    let length = 1;\r\n    let tail = head;\r\n    while (tail.next) {\r\n        tail = tail.next;\r\n        length++;\r\n    }\r\n\r\n    k = k % length;\r\n\r\n    if (k === 0) {\r\n        return head;\r\n    }\r\n\r\n    tail.next = head;\r\n\r\n    let newTail = head;\r\n    for (let i = 0; i < length - k - 1; i++) {\r\n        newTail = newTail.next;\r\n    }\r\n\r\n    let newHead = newTail.next;\r\n\r\n    newTail.next = null;\r\n\r\n    return newHead;\r\n};\r\n\r\n```\r\n\r\n时间复杂度O(n) 空间复杂度O(1)","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pandapls":[{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/1#issuecomment-2117944601","body":"补day1\n```\n// 利用k的取余操作 对num中倒叙进行相加\nvar addToArrayForm = function(num, k) {\n    const ret = [];\n    const n = num.length;\n\n    for(let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k /10)\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        ret.push(sum)\n    }\n\n    for(; k > 0; k = Math.floor(k / 10)) {\n        ret.push(k % 10)\n    }\n    return ret.reverse();\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/2#issuecomment-2120585704","body":"var shortestToChar = function(s, c) {\n    const result = [];\n    let prev = -Infinity;\n\n    for(let i = 0; i < s.length; i++) {\n        if (s[i] == c) {\n            prev  = i\n        }\n        result[i] = i - prev\n    }\n\n    prev = Infinity;\n    for(let i = s.length - 1; i >= 0; i--) {\n        if (s[i] == c) {\n            prev = i\n        }\n\n        result[i] = Math.min(result[i], prev - i)\n    }\n\n    return result;\n};\n\n时间复杂度：O(n)\n空间复杂度：O(1)'","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/3#issuecomment-2127074780","body":"var CustomStack = function(maxSize) {\n    this.stack = [];\n    this.maxSize = maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.stack.length >= this.maxSize) {\n        return;\n    }\n    this.stack.push(Number(x));\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (this.stack.length === 0) {\n        return -1\n    }\n\n    return this.stack.pop()\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(let i = 0; i < k && i < this.stack.length; i++) {\n        this.stack[i] = this.stack[i] + val\n    }\n    return this.stack\n};\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/4#issuecomment-2132237894","body":"\n```\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n\n \n\n示例 1：\n\n输入：s = \"3[a]2[bc]\"\n输出：\"aaabcbc\"\n示例 2：\n\n输入：s = \"3[a2[c]]\"\n输出：\"accaccacc\"\n示例 3：\n\n输入：s = \"2[abc]3[cd]ef\"\n输出：\"abcabccdcdcdef\"\n示例 4：\n\n输入：s = \"abc3[cd]xyz\"\n输出：\"abccdcdcdxyz\"\n\n\n### 思路\n\n 使用栈\n\n### 代码\n\n\n```javascript\nvar decodeString = function(s) {\n  let stack = []\n  for (const char of s) {\n    if (char !== ']') { // ] 前的字符都入栈\n      stack.push(char)\n      continue\n    }\n    let cur = stack.pop() // 弹出一个来检测\n    let str = '' // 组装字符串\n    // 接下来肯定是遇到字母，直到遇到 [\n    while (cur !== '[') {\n      str = cur + str // cur字符加在左边\n      cur = stack.pop() // 再拉出一个\n    }\n    // 此时cur为 [，接下来要遇到数字\n    let num = ''\n    cur = stack.pop() // 用下一个将 [ 覆盖\n    while (!isNaN(cur)) {\n      num = cur + num // 数字字符加在左边\n      cur = stack.pop() // 再拉出一个\n    }\n    // 现在要么是字母，要么是 [\n    stack.push(cur)\n    stack.push(str.repeat(num))\n  }\n  return stack.join('')\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/5#issuecomment-2133478206","body":"```\n使用栈实现队列的下列操作：\n\npush(x) -- 将一个元素放入队列的尾部。\npop() -- 从队列首部移除元素。\npeek() -- 返回队列首部的元素。\nempty() -- 返回队列是否为空。\n示例:\n\nMyQueue queue = new MyQueue();\n\nqueue.push(1);\nqueue.push(2);\nqueue.peek(); // 返回 1\nqueue.pop(); // 返回 1\nqueue.empty(); // 返回 false\n说明:\n\n你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n假设所有操作都是有效的、 （例如，一个空的队列不会调用 pop 或者 peek 操作）。\n```\n\n\n### 思路\n\n 使用辅助栈\n\n### 代码\n\n\n```javascript\nvar MyQueue = function() {\n    this.mainStack = []\n    this.viceStack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.mainStack.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if (this.viceStack.length === 0) {\n        while(this.mainStack.length) {\n            this.viceStack.push(this.mainStack.pop())\n        }\n    }\n\n    return this.viceStack.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if (this.viceStack.length === 0) {\n        while(this.mainStack.length) {\n            this.viceStack.push(this.mainStack.pop())\n        }\n    }\n\n    return this.viceStack[this.viceStack.length -1]\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.viceStack.length && !this.mainStack.length\n};\n\n```\n\n**复杂度分析**\n- peek 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/6#issuecomment-2135334082","body":"```javascript\nvar maxChunksToSorted = function(arr) {\n    const stack = [];\n\n    for(let num of arr) {\n        if (stack.length === 0 || num >= stack[stack.length - 1]) {\n            stack.push(num)\n        } else {\n            const mx = stack.pop();\n            while(stack.length && stack[stack.length -1] > num)\n            {\n                stack.pop()\n            }\n            stack.push(mx)\n        }\n    }\n    return stack.length\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/7#issuecomment-2137478804","body":"```javascript\nvar rotateRight = function(head, k) {\n    if (!head || !head.next || k === 0) {\n        return head\n    }\n    let len = 1;\n    let cur = head;\n    while(cur.next) {\n        cur = cur.next;\n        len++\n    }\n    let n = len - ( k % len );\n    cur.next = head;\n    if (n === len) {\n        cur.next = null;\n        return head\n    };\n\n    cur.next = head;\n    while (n > 0) {\n        cur = cur.next;\n        n--;\n    }\n\n    const res = cur.next;\n    cur.next = null;\n\n  return res;\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/8#issuecomment-2139765806","body":"\n```javascript\nvar swapPairs = function(head) {\n    let dummyNode = new ListNode(-1);\n    dummyNode.next = head;\n\n    let node = dummyNode;\n\n    while(node && node.next && node.next.next) {\n        let prev = node;\n        let curNode = prev.next;\n        let tmp = curNode.next;\n        curNode.next = tmp.next;\n        tmp.next = prev.next;\n        prev.next = tmp;\n\n        node = curNode\n    }\n\n    return dummyNode.next\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/9#issuecomment-2141249541","body":"```javascript\nvar sortedListToBST = function(head) {\n    if (!head) {\n        return null;\n    }\n\n    let slow = head;\n    let fast = head;\n    let preSlow; //缓存slow前一个节点\n\n    while(fast && fast.next) {\n        preSlow = slow;\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    const root = new TreeNode(slow.val);\n    if (preSlow) {\n        preSlow.next = null;\n        root.left = sortedListToBST(head)\n    }\n\n    root.right = sortedListToBST(slow.next)\n\n    return root\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：，O(nlogn)\n- 空间复杂度：O(logn)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/10#issuecomment-2143452778","body":"```\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\n\n图示两个链表在节点 c1 开始相交：\n\n```\n\n![](https://p.ipic.vip/bkdl1z.jpg)\n\n```\n题目数据 保证 整个链式结构中不存在环。\n\n注意，函数返回结果后，链表必须 保持其原始结构 。\n\n \n\n示例 1：\n```\n\n![](https://p.ipic.vip/bzw15z.jpg)\n\n```\n\n\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n示例 2：\n```\n\n![](https://p.ipic.vip/26cojo.jpg)\n\n```\n\n输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Intersected at '2'\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n示例 3：\n\n```\n\n![](https://p.ipic.vip/2tpyar.jpg)\n\n```\n\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n \n\n提示：\n\nlistA 中节点数目为 m\nlistB 中节点数目为 n\n0 <= m, n <= 3 * 104\n1 <= Node.val <= 105\n0 <= skipA <= m\n0 <= skipB <= n\n如果 listA 和 listB 没有交点，intersectVal 为 0\n如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1]\n \n\n进阶：你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？\n\n```\n\n\n\n### 思路\n\n 使用Set存储节点 判断是否存在该链表节点\n\n### 代码\n\n```javascript\n\nvar getIntersectionNode = function(headA, headB) {\n    let set = new Set()\n    let tmp = headA;\n    while(tmp) {\n        set.add(tmp)\n        tmp = tmp.next\n    }\n    tmp = headB;\n    while(tmp) {\n        if (set.has(tmp)) {\n            return tmp\n        }\n\n        tmp = tmp.next\n    }\n\n    return null\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/57#issuecomment-2143894772","body":"\n```javascript\nvar findNumberOfLIS = function(nums) {\n    if (!nums || nums.length === 0) {\n        return 0\n    }\n\n    let dp = Array.from({length: nums.length}).fill(1)\n    let counts = Array.from({length: nums.length}).fill(1);\n    \n\n    for (let i = 1; i < nums.length; i++) {\n        for (let j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n                if (dp[j] + 1 > dp[i]) {\n                    dp[i] = dp[j] + 1;\n                    counts[i] = counts[j];\n                } else if (dp[j] + 1 === dp[i]) {\n                    counts[i] += counts[j];\n                }\n            }\n        }\n    }\n    let maxLen = Math.max(...dp);\n    let count = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if (dp[i] === maxLen) {\n            count += counts[i];\n        }\n    }\n\n    return count;\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n的平凡)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/62#issuecomment-2153737024","body":"数组总和必须是偶数，因为只有偶数才能平分成两个和相等的子集\n如果数组中的最大值大于目标和（总和的一半），则无法分成两个和相等的子集\n动态规划方法通过构建一个布尔数组，记录是否存在某个和的子集，来判断是否可以分成两个和相等的子集\n```\nvar canPartition = function(nums) {\n    const n = nums.length;\n    if (n < 2) {\n        return false;\n    }\n    let sum = 0, maxNum = 0;\n    for (const num of nums) {\n        sum += num;\n        maxNum = maxNum > num ? maxNum : num;\n    }\n    if (sum & 1) {\n        return false;\n    }\n    const target = Math.floor(sum / 2);\n    if (maxNum > target) {\n        return false;\n    }\n    const dp = new Array(target + 1).fill(false);\n    dp[0] = true;\n    for (const num of nums) {\n        for (let j = target; j >= num; --j) {\n            dp[j] = dp[j - num] || dp[j] ;\n        }\n    }\n    return dp[target];\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/63#issuecomment-2156059000","body":"问题转换为 设有P，N分别为分组内 分组外的数总和， sum = P + N; P - N = target  => P = sum + target / 2\n```\nvar findTargetSumWays = function(nums, target) {\n    // 计算数组的总和\n    let sum = 0;\n    for (const num of nums) {\n        sum += num;\n    }\n\n    // 计算 P\n    const diff = sum - target;\n    if (diff < 0 || diff % 2 !== 0) {\n        // 如果 diff 是负数或不是偶数，返回 0\n        return 0;\n    }\n\n    const neg = Math.floor(diff / 2);\n\n    // 初始化 dp 数组\n    const dp = new Array(neg + 1).fill(0);\n    dp[0] = 1;  // 和为0的子集只有一种，即空子集\n\n    // 更新 dp 数组\n    for (const num of nums) {\n        for (let j = neg; j >= num; j--) {\n            dp[j] += dp[j - num];\n        }\n    }\n\n    // 返回和为 neg 的子集个数\n    return dp[neg];\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/69#issuecomment-2167446542","body":"状态转移方程\n想要计算有 i 个节点的不同 BST 的数量。假设我们选择 j 作为根节点（1 <= j <= i）\n那么：\n左子树 的节点个数是 j - 1，因为左子树的节点都比根节点 j 小\n右子树 的节点个数是 i - j，因为右子树的节点都比根节点 j 大\n\n所以 ：\ndp[j - 1] 表示左子树的不同 BST 数量\ndp[i - j] 表示右子树的不同 BST 数量\n\n···\nvar numTrees = function(n) {\n    const dp = new Array(n + 1).fill(0);\n\n    dp[0] = 1;\n    dp[1] = 1;\n\n    for(let i = 2; i <= n; i++) {\n        for(let j = 1; j <= i; j++) {\n            dp[i] += dp[j -1] * dp[i - j]\n        }\n    }\n\n    return dp[n]\n};\n···\n时间 O(n2)\n空间 O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-13-daily-check/issues/75#issuecomment-2179623379","body":"思路：使用Map存储 暴力遍历累加结果\n···\nvar MapSum = function() {\n    this.map = new Map()\n};\n\n/** \n * @param {string} key \n * @param {number} val\n * @return {void}\n */\nMapSum.prototype.insert = function(key, val) {\n    this.map.set(key, val)\n};\n\n/** \n * @param {string} prefix\n * @return {number}\n */\nMapSum.prototype.sum = function(prefix) {\n    let res = 0;\n    for(const s of this.map.keys()) {\n        if (s.startsWith(prefix)) {\n            res += this.map.get(s)\n        }\n    }\n    return res\n};\n···\nsum: O(n)\ninsert: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}