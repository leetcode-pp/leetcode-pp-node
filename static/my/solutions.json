{"1":[],"2":[],"3":[],"4":[],"5":[],"6":[],"7":[],"8":[],"9":[],"10":[],"11":[],"12":[],"13":[],"14":[],"15":[],"16":[],"17":[],"18":[],"19":[],"20":[],"21":[],"22":[],"23":[],"24":[],"25":[],"26":[],"27":[],"28":[],"29":[],"30":[],"31":[],"32":[],"33":[],"34":[],"35":[],"36":[],"37":[],"38":[],"39":[],"40":[],"41":[],"42":[],"43":[],"44":[],"45":[],"46":[],"47":[],"48":[],"49":[],"50":[],"51":[],"52":[],"53":[],"54":[],"55":[],"56":[],"57":[],"58":[],"59":[],"60":[],"61":[],"62":[],"63":[],"64":[],"65":[],"66":[],"67":[],"68":[],"69":[],"70":[],"71":[],"72":[],"73":[],"74":[],"75":[],"76":[],"77":[],"78":[],"79":[],"80":[],"81":[],"82":[],"83":[],"84":[],"85":[],"86":[],"87":[],"88":[],"89":[],"90":[],"91":[],"839781960":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"954545647":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"1541732340":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"michaelxi3":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"darknightwriter":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"findlayzhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laofuwf":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lbc546":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zch-bit":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"frankelzeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhaodev":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joeymoso":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hackbl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"q815101630":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiyishuoshuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aouos":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"thinkfurther":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wengzhouyunfan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whisht":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bzlff":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzzkains":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenmengyu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uancen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nuomituxedo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhongranherz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gr52":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hydelovegood":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nikojxie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fangxianshen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jokertzw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cyang258":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kernelsue":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erikahuang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kuang-mou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iloveqier":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duke-github":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"caterpillar-0":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ashleyyma6":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuki-yzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zpc7":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yujian920":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kiirii4":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ucashurui":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xixiao51":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"feikerwu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"heng518":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yaya-bb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tlntin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richypang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fenchuiyun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jerry-lllman":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nickyk319":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"herbertpan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wsmmxmm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fan-svg":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuzejia":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunnyyujf":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"phoenixflyingsky":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nehchsuy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lzyxts":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elainekuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ll491119940":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"2learnsomething":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ataraxyadong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wzasd":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miluowzt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maylinglin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weijie-he":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brodxie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"y525":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leungogogo":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/7#issuecomment-2522670730","body":"### Main Idea\nFor chunks `[c1, c2, c3, ..., cn]`, we have to maintain the property: `max(ci) <= min(cj)` if `i < j`. So we can create a monotonously increasing stack `stack` to keep track of the max value for each previous chunk. \n\nIf `arr[i] >= stack.peek()`, we can greedily create a new chunk and `stack.push(arr[i])`. Else, we need to find the previous chunk with max value smaller or equal to `arr[i]`, say `ck`, and we need to merge all the chunks `[c_k+1, ... c_cur]` with `arr[i]`.\n\nTo merge chunks, we can just pop all the max values representing those chunks off the stack, and push back the max among them (in our case, it will be stack top cuz this stack is increasing) as the max of the new chunk. \n\nFinally the size of the stack will be the number of chunks.\n### Code\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int n = arr.length;\n        Deque<Integer> stack = new ArrayDeque<>();\n        for (int num : arr) {\n            int max = num;\n            while (!stack.isEmpty() && stack.peek() > num) {\n                max = Math.max(max, stack.pop());\n            }\n            stack.push(max);\n        }\n        return stack.size();\n    }\n}\n```\n### Complexity Analysis\nTime: `O(n)`\nSpace: `O(n)`","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/9#issuecomment-2525554090","body":"### Main Idea\nUse iteration, process two nodes at a time. Say `tail` is the current tail of the new linked list, we use ListNode `cur` to keep tracks of the current node being processed, `next` is the second node being processed, here are three situations:\n\n1. `cur` is `null`, that means we are done and we can exit the loop.\n2. `cur` is not `null`, but `next` is `null`, which means only one node is left, and no need to swap, just append it to the current tail.\n3. Neither of them is `null`, so we record the next node to process in `nextCur`, then append `next` to the tail, and  append `cur` to `next`, also need to make `cur.next = null` and set it as the new tail.\n\nTo simplify coding and handle edge case, a dummy head is used.\n\n### Code\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummyHead = new ListNode(), tail = dummyHead, cur = head;\n        while (cur != null) {\n            ListNode next = cur.next;\n            if (next == null) {\n                tail.next = cur;\n                break;\n            } else {\n                ListNode nextCur = next.next;\n                tail.next = next;\n                next.next = cur;\n                cur.next = null;\n                tail = cur;\n                cur = nextCur;\n            }\n        }\n        return dummyHead.next;\n    }\n}\n```\n\n### Complexity Analysis\n* Time: `O(n)`\n* Space: `O(1)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/10#issuecomment-2527259733","body":"### Main Idea\nIf we pick a node as root of the tree, then we will need to determine the left and right subtrees with the list nodes on the left and right hand sides, which is the same problem but with a smaller size.\n\nAlso, we want the BST to be balanced, so when constructing the tree, we want to **choose the middle list node as the root**, so left and right will have same number of nodes, or one side will have an extra node.\n\n**Algorithm**\n1. Base case: If there is only one node left, return it as a new `TreeNode`.\n2. Get the middle node.\n3. Recusrivly call the function on the left and right lists and get the left and right subtree.\n\n### Code\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n        if (head.next == null) return new TreeNode(head.val);\n        \n        ListNode fast = head, slow = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        \n        ListNode prev = head;\n        while (prev.next != slow) {\n            prev = prev.next;\n        }\n        prev.next = null;\n        TreeNode left = sortedListToBST(head);\n        TreeNode right = sortedListToBST(slow.next);\n        TreeNode root = new TreeNode(slow.val);\n        root.left = left;\n        root.right = right;\n        return root;\n    }\n}\n```\n### Complexity Analysis\nTime: `O(nlogn)`, divide and conquer.\nSpace: `O(height) = O(logn)`  for recursive calls.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/11#issuecomment-2530917653","body":"```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        int lenA = listLen(headA), lenB = listLen(headB), diff = Math.abs(lenA - lenB);\n        ListNode cur1 = lenA < lenB ? headB : headA;\n        ListNode cur2 = lenA < lenB ? headA : headB;\n        for (int i = 0; i < diff; ++i) {\n            cur1 = cur1.next;\n        }\n        while (cur1 != null && cur2 != null) {\n            if (cur1 == cur2) {\n                return cur1;\n            } else {\n                cur1 = cur1.next;\n                cur2 = cur2.next;\n            }\n        }\n        return null;\n    }\n\n    private int listLen(ListNode head) {\n        if (head == null) {\n            return 0;\n        }\n        return 1 + listLen(head.next);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/12#issuecomment-2535640807","body":"### Main Idea\nDefine two pointers `fast` and `slow`, each iteration, `fast` moves 2 steps forward while `slow` moves 1 step. If there is a cycle, then `fast` will equals `slow` eventually, and if not, we will exit the loop.\n\nIf a cycle is detected, we need to find the starting point. \n\n```\nfast = 2 * slow\n\nfast = l + n1 * c + t\nslow = l + n2 * c + t\n\n\nl + n1 * c + t = 2 * l + 2 * n2 * c + 2 * t\nl = n1 * c - 2 * n2 * c = c * (n1 - 2 * n2) = n' * c - t\n```\n\n```\n     L\n--------   ----I-----\n           |         | D\n           ----------\n```\n### Code\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null) return null;\n        ListNode fast = head, slow = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) {\n                while (slow != head) {\n                    slow = slow.next;\n                    head = head.next;\n                }\n                return head;\n            }\n        }\n        return null;\n    }\n}\n```\n### Complexity Analysis\nTime: `O(n)`\nSpace: `O(1)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/13#issuecomment-2537932278","body":"### Main Idea\nWe can use a linked list to simulate the cache queue, but if we just use a linked list, then the time complexity of `get()` and `remove()` will be `O(n)`.\n\nTo make the `get()` and `remove()` operations more efficient, we can use a map to store `(key, ListNode)` pairs. Given a key, we can get its node immediately from the map instead of going through the linked list.\n### Code\n```java\nclass LRUCache {\n    private class DBListNode {\n        private DBListNode prev;\n        private DBListNode next;\n        private int key;\n        private int val;\n\n        private DBListNode(int key, int val) {\n            this.key = key;\n            this.val = val;\n        }\n    }\n    \n    private DBListNode head;\n    private DBListNode tail;\n    private int cap;\n    private int size;\n    private Map<Integer, DBListNode> map;\n\n    public LRUCache(int capacity) {\n        head = new DBListNode(-1, -1);\n        tail = new DBListNode(-1, -1);\n        map = new HashMap<>();\n        head.next = tail;\n        tail.prev = head;\n        cap = capacity;\n    }\n    \n    public int get(int key) {\n        if (!map.containsKey(key)) {\n            return -1;\n        }\n        DBListNode node = map.get(key);\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n        return node.val;\n    }\n    \n    public void put(int key, int value) {\n        DBListNode node;\n        if (map.containsKey(key)) {\n            node = map.get(key);\n            node.val = value;\n            node.prev.next = node.next;\n            node.next.prev = node.prev;\n        } else {\n            if (size < cap) {\n                ++size;\n            } else {\n                DBListNode remove = tail.prev;\n                remove.prev.next = tail;\n                tail.prev = remove.prev;\n                map.remove(remove.key);\n            }\n            node = new DBListNode(key, value);\n        }\n\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n        map.put(key, node);\n    }\n}\n```\n\n### Complexity Analysis\nTime: `O(1)` for all operations\nSpace: `O(cap)`","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/16#issuecomment-2543827340","body":"### Main Idea\nUse dfs to find all the root-to-leaf path numbers(use an integer `s` to record the number represented by previous nodes in the path, and `newNum = s * 10 + root.val`), and sum them up.\n\n### Code\n```java\nclass Solution {\n    private int sum;\n    public int sumNumbers(TreeNode root) {\n        if (root == null) return 0;\n        sum = 0;\n        dfs(root, 0);\n        return sum;\n    }\n    \n    private void dfs(TreeNode root, int s) {\n        if (root.left == null && root.right == null) {\n            sum += (s * 10 + root.val);\n            return;\n        }\n        \n        // dfs\n        if (root.left != null) dfs(root.left, s * 10 + root.val);\n        if (root.right != null) dfs(root.right, s * 10 + root.val);\n    }\n}\n```\n\n### Complexity Analysis\nTime: `O(n)`\nSpace: `O(h) = O(n)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/17#issuecomment-2544753765","body":"### Main Idea\nThis problem is asking for the leftmost node of the last layer, and when it comes to traversal by layer, BFS comes in handy.\n\nIn a standard BFS algorithm, we use a queue to keep track of the nodes on each layer, we just need to modify the algorithm to record the first node of the current layer, and if we exit the loop from the current layer, that means this is the last layer, and the node we recorded will be the one we want to find.\n\n### Code\n```java\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        Queue<TreeNode> q = new ArrayDeque<>();\n        q.offer(root);\n        int res = 0;\n        while (!q.isEmpty()) {\n            res = q.peek().val;\n            int size = q.size();\n            for (int i = 0; i < size; ++i) {\n                TreeNode n = q.poll();\n                if (n.left != null) q.offer(n.left);\n                if (n.right != null) q.offer(n.right);\n            }\n        }\n        return res;\n    }\n}\n```\n### Complexity Analysis\nTime: `O(n)`\nSpace: `O(n)`","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/21#issuecomment-2555859231","body":"### Main Idea\nCount the frequency and use a PriorityQueue to pop out the least frequent elements.\n### Code\n* java\n\n```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        int n = nums.length;\n        Map<Integer, Integer> freq = new HashMap<>();\n        for (int num : nums) {\n            freq.put(num, freq.getOrDefault(num, 0) + 1);\n        }\n        \n        // {num, freq}\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((p1, p2) -> p1[1] - p2[1]);\n        freq.forEach((key, val) -> {\n            minHeap.offer(new int[] {key, val});\n            if (minHeap.size() > k) {\n                minHeap.poll();\n            }\n        });\n        \n        return minHeap.stream().map(p -> p[0]).mapToInt(Integer::intValue).toArray();\n    }\n}\n```\n### Complexity Analysis\nTime: `O(nlogk)`\nSpace: `O(n)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/22#issuecomment-2558037674","body":"### Main Idea\nBrute force is to use 3 nested loops, but obviously it will cause TLE.\n\nFor each element in the input array, we can set it as the first point in tuple, and we calculate the distance from it to all other points, and use a map to record the count. So `map[k] = cnt`  means there are `cnt` points with distance `k` from the first point.\n\nOnce we have all the counts, iterate through the distances, if there are `cnt` points with distance `k` to the first point, it can form `cnt * (cnt - 1)` pairs.\n\n### Code\n```java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        if (points == null || points.length < 3) {\n            return 0;\n        }\n        \n        int n = points.length, res = 0;\n        for (int i = 0; i < n; ++i) {\n            Map<Integer, Integer> squareDistCount = new HashMap<>();\n            for (int j = 0; j < n; ++j) {\n                if (i == j) {\n                    continue;\n                }\n                \n                int squareDist = calculateDistanceSquare(points[i], points[j]);\n                int count = squareDistCount.getOrDefault(squareDist, 0) + 1;\n                squareDistCount.put(squareDist, count);\n            }\n            \n            for (int count : squareDistCount.values()) {\n                if (count >= 2) {\n                    res += count * (count - 1);\n                }\n            }\n        }\n        return res;\n    }\n    \n    \n    private int calculateDistanceSquare(int[] pointA, int[] pointB) {\n        int y = pointA[1] - pointB[1];\n        int x = pointA[0] - pointB[0];\n        return y * y + x * x;\n    }\n}\n```\n\n### Complexity Analysis\nTime: `O(n^2)`\nSpace: `O(n)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/23#issuecomment-2558240740","body":"## Method 1. Sliding Window + HashSet\n### Main Idea\nTwo pointers, if no repeat, increment `fast`, else, keep incrementing `slow` until we remove the duplicate, so in the worst case we need to traverse each element exactly twice.\n### Code\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        boolean[] set = new boolean[128];\n        int left = 0, right = 0, maxLen = 0, n = s.length();\n        while (right < n) {\n            while (right < n && !set[s.charAt(right)]) {\n                set[s.charAt(right)] = true;\n                right++;\n            }\n            \n            maxLen = Math.max(maxLen, right - left);\n            set[s.charAt(left)] = false;\n            left++;\n        }\n        \n        return maxLen;\n    }\n}\n```\n### Complexity Analysis\nTime: `O(2*n) = O(n)`\nSpace: `O(n)`\n\n## Method 2. One Scan with Map (Optimization)\n### Main Idea\nIn Method 1, we need to move the left boundary of the sliding window step by step, which causes extra runtime. Actually, we can use a map to record the index of last occurrences of each character, and when seeing repeated character, we can get its previous index, and `left = index + 1`.\n\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int slow = 0, fast = 0, n = s.length(), maxLen = 0;\n        while (fast < n) {\n            if (map.containsKey(s.charAt(fast)) && map.get(s.charAt(fast)) >= slow) {\n                slow = map.get(s.charAt(fast)) + 1;\n            }\n            \n            maxLen = Math.max(maxLen, fast - slow + 1);\n            map.put(s.charAt(fast), fast++);\n        }\n        \n        return maxLen;\n    }\n}\n```\n### Complexity Analysis\nTime: `O(n)`\nSpace: `O(n)`","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/26#issuecomment-2561455245","body":"### Main Idea\nTwo pointers, fast goes two times faster than slow pointer, when fast reaches the end of linked list, slow pointer will be the middle node.\n### Code\n```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        if (head == null) return null;\n        ListNode fast = head, slow = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```\n### Complexity Analysis\nTime: `O(n)`\nSpace: `O(1)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/27#issuecomment-2562054125","body":"## Method. Two pointers\n### Main Idea\nDefine two pointers `fast` and `slow`, and we will have 3 regoins:\n* `[0, slow - 1]`: the output array, no duplicates in this region.\n* `[slow: fast -1]`: Duplicate elements that we want to discard.\n* `[fast, n - 1]`: unexplored region.\n\nEach iteration, if `nums[fast] != nums[slow - 1]`, that means we `nums[fast]` is not a duplicate element, so we move it to `slow`, then increment slow so `arr[0:slow-1]` is still a region with no duplicates.\n\n### Code\n\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int fast = 0, slow = 0, n = nums.length;\n        while (fast < n) {\n            if (slow == 0 || nums[fast] != nums[slow - 1]) {\n                nums[slow++] = nums[fast++];\n            } else {\n                ++fast;\n            }\n        }\n        return slow;\n    }\n}\n```\n### Complexity Analysis\nTime: `O(n)` \n\nSpace: `O(1)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/28#issuecomment-2563089831","body":"### Main Idea\r\nFind the first element that is greater than `target`, and that's the insert position.\r\n\r\n### Code\r\n\r\n```java\r\nclass Solution {\r\n    public int searchInsert(int[] nums, int target) {\r\n        int n = nums.length, left = 0, right = n - 1;\r\n        \r\n        while (left < right) {\r\n            int mid = left + (right - left) / 2;\r\n            if (nums[mid]  ==  target) {\r\n                return mid;\r\n            } else if (nums[mid] > target) {\r\n                right = mid - 1;\r\n            } else {\r\n                left = mid + 1;\r\n            }\r\n        }\r\n        \r\n        return nums[left] >= target ? left : left + 1;\r\n        \r\n    }\r\n}\r\n```\r\n\r\n### Complexity Analysis\r\nTime: `O(logn)`\r\n\r\nSpace: `O(1)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/29#issuecomment-2564067343","body":"### Main Idea\nWe are looking for the rolling maximum values of intervals, so the intuition is to use a heap to keep track of the dynamic max/min values.\n\nWe can use a max heap `pq` to store the `(index,value)` pair and sort them by value with descending order.\n\nPush the first K elements to the priority queue `{val, index}`. Then at the beginning of each iteration, we can check if the heap top is within the valid range, if not, then we can remove it until we find a valid one, this will be the local max.\n### Code\n* Java\n\n```java\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int n = nums.length;\n        // {index, val}\n        PriorityQueue<int[]> pq = new PriorityQueue<>((p1, p2) -> p2[1] - p1[1]);\n        int[] res = new int[n - k + 1];\n        for (int i = 0; i < n; ++i) {\n            pq.offer(new int[] {i, nums[i]});\n            if (i >= k - 1) {\n                while (pq.peek()[0] < i - k + 1) {\n                    pq.poll();\n                }\n                \n                res[i - k + 1] = pq.peek()[1];\n            }\n        }\n        return res;\n    }\n}\n```\n### Complexity Analysis\nTime: `O(nlogn)`\n\nSpace: `O(n)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/30#issuecomment-2564555426","body":"### Main Idea\nThis problem can be moldeled with a directed graph, say each person is a vertex and `trust` are edges.\n\nIf `a` trust `b`, then a has an out-degree and `b` has an in-degree, a judge should have a net degree of `n - 1`. So we just need to go though all the edges, calculate the net degree of each vertex, and find the one with net degree of `n - 1`. If not exist, return `-1`.\n\n### Code\n* Java\n\n```java\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[] deg = new int[n];\n        for (int[] edge : trust) {\n            deg[edge[1] - 1]++; \n            deg[edge[0] - 1]--;\n        }\n        \n        for (int i = 0; i < n; ++i) {\n            if (deg[i] == n - 1) return i + 1;\n        }\n        \n        return -1;\n    }\n}\n```\n### Complexity Analysis\nTime: `O(E)`\n\nSpace: `O(V)`\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/31#issuecomment-2564833209","body":"### Main Idea\nBasically, this problem is asking if we can mark the graph with 2 colors, where adjacent vertices can't have the same color.\n\nSo we can apply BFS to traverse the graph, say we mark a vertex `v` with color 1, then we have to mark all its neighbors with color 2. If any of them was marked color 1, then we know it's impossible to mark the graph with 2 colors, so we can return `false`.\n\nIf no such contradictions found, that means the graph can be 2-colored, so return `true`.\n### Code\n* Java\n\n```java\nclass Solution {\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        List<List<Integer>> graph = new ArrayList<>(n + 1);\n\n        for (int i = 0; i <= n; ++i) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int[] dislike : dislikes) {\n            graph.get(dislike[0]).add(dislike[1]);\n            graph.get(dislike[1]).add(dislike[0]);\n        }\n\n\n        int[] groups = new int[n + 1];\n        Queue<int[]> queue = new ArrayDeque<>();\n\n        for (int i = 1; i <= n; ++i) {\n            if (groups[i] != 0) {\n                continue;\n            }\n            \n            queue.offer(new int[] {i, 1});\n\n            while (!queue.isEmpty()) {\n                int[] elem = queue.poll();\n                int node = elem[0], group = elem[1];\n                groups[node] = group;\n\n                int neiGroup = -1 * group;\n                for (int neigh : graph.get(node)) {\n                    if (groups[neigh] != 0 && groups[neigh] != neiGroup) {\n                        return false;\n                    } else if (groups[neigh] == 0) {\n                        queue.offer(new int[] {neigh, neiGroup});\n                    }\n                }\n            } \n        }\n\n        return true;\n    }\n}\n```\n### Complexity Analysis\nTime: `O(E + V)`\n\nSpace: `O(E + V)`","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/33#issuecomment-2566963167","body":"```java\nclass Solution {\n    public boolean judgeCircle(String moves) {\n        int[][] dirs = new int[][] {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\n        String dirStr = \"LRUD\";\n        int n = moves.length();\n        int[] pos = new int[] {0, 0};\n\n        for (int i = 0; i < n; ++i) {\n            int index = dirStr.indexOf(moves.charAt(i));\n            pos[0] += dirs[index][0];\n            pos[1] += dirs[index][1];\n        }\n\n        return pos[0] == 0 && pos[1] == 0;\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/34#issuecomment-2567170043","body":"```java\nclass Solution {\n    public int[] getOrder(int[][] tasks) {\n        // intuition - sort tasks as enqueue time\n        // then keep a waiting list as requirements -- here we use heap\n        int n = tasks.length;\n        int[][] memo = new int[n][3];\n        \n        // we could create an object for this purpose - track task index/id\n        for (int i = 0; i < n; i++) {\n            memo[i][0] = i;\n            memo[i][1] = tasks[i][0];\n            memo[i][2] = tasks[i][1];\n        }\n        \n        // sort tasks\n        Arrays.sort(memo, (m1, m2) -> m1[1] - m2[1]);\n        // create the heap as we need\n        PriorityQueue<int[]> pq = new PriorityQueue<>((m1, m2) -> \n            m1[2] != m2[2] ? m1[2] - m2[2] : m1[0] - m2[0]);\n        \n        int time = 0;\n        // cur - current running task, itr - traverse task one by one\n        int cur = 0, itr = 0;\n        int[] res = new int[n];\n        while (cur < n) {\n            // if enquetime <= current time, means we could add into waiting list\n            while (itr < n && memo[itr][1] <= time) {\n                pq.offer(memo[itr]);\n                itr++;\n            }\n            // if no waiting, we run it & update the time as its entry time\n            if (pq.isEmpty()) {\n                time = memo[itr][1];\n                continue;\n            }\n            // find the next avaliable one from heap\n            int[] next = pq.poll();\n            // note down order\n            res[cur] = next[0];\n            // control time window\n            time += next[2];\n            cur++;\n        }\n        \n        return res;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/36#issuecomment-2570646093","body":"```java\nclass Solution {\n    public int minCharacters(String a, String b) {\n        Map<Character, Integer> countA = new HashMap<>();\n        Map<Character, Integer> countB = new HashMap<>();\n\n        int m = a.length(), n = b.length();\n        for (int i = 0; i < m; ++i) {\n            countA.put(a.charAt(i), countA.getOrDefault(a.charAt(i), 0) + 1);\n        }\n\n        for (int j = 0; j < n; ++j) {\n            countB.put(b.charAt(j), countB.getOrDefault(b.charAt(j), 0) + 1);\n        }\n\n        int res1 = Integer.MAX_VALUE;\n        int res2 = Integer.MAX_VALUE;\n        int res3 = Integer.MAX_VALUE;\n        for (char c = 'a'; c <= 'z'; ++c) {\n            res1 = Math.min(res1, Math.min(minChangeForLt(c, countA, countB), minChangeForLt(c, countB, countA)));\n            res2 = Math.min(res2, countForEq(countA, c));\n            res3 = Math.min(res3, countForEq(countB, c));\n        }\n\n        return Math.min(res1, res2 + res3);\n    }\n\n    private int minChangeForLt(char c, Map<Character, Integer> smaller, Map<Character, Integer> greaterEq) {\n        int res = 0;\n\n        if (c == 'a') {\n            return Integer.MAX_VALUE;\n        }\n\n        for (var entry : smaller.entrySet()) {\n            if (entry.getKey() >= c) {\n                res += entry.getValue();\n            }\n        }\n\n        for (var entry : greaterEq.entrySet()) {\n            if (entry.getKey() < c) {\n                res += entry.getValue();\n            }\n        }\n\n        return res;\n    }\n\n    private int countForEq(Map<Character, Integer> count, char c) {\n        int res = 0;\n\n        for (var entry : count.entrySet()) {\n            if (entry.getKey() != c) {\n                res += entry.getValue();\n            }\n        }\n\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/37#issuecomment-2571460205","body":"Merge sort:\n\n```java\nclass Solution {\n    public int[] sortArray(int[] nums) {\n        return sortHelper(nums, 0, nums.length - 1);\n    }\n\n    private int[] sortHelper(int[] nums, int start, int end) {\n        if (start > end) {\n            return new int[0];\n        } else if (start == end) {\n            return new int[] {nums[start]};\n        }\n\n        int mid = start + (end - start) / 2;\n        int[] left = sortHelper(nums, start, mid);\n        int[] right = sortHelper(nums, mid + 1, end);\n\n        int m = left.length, n = right.length, i1 = 0, i2 = 0;\n        int[] res = new int[m + n];\n        for (int i = 0; i < res.length; ++i) {\n            if (i1 >= m || i2 < n && left[i1] > right[i2]) {\n                res[i] = right[i2];\n                ++i2;\n            } else {\n                res[i] = left[i1];\n                ++i1;\n            }\n        }\n        return res;\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/38#issuecomment-2571775313","body":"Binary search.\n\n```java\nclass Solution {\n    public int mySqrt(int x) {\n        int left = 0, right = x;\n\n        while (left < right - 1) {\n            int mid = left + (right - left) / 2;\n            long midSquare = 1l * mid * mid;\n            if (midSquare == x) {\n                return mid;\n            } else if (midSquare < x) {\n                left = mid;\n            } else {\n                right = mid - 1;\n            }\n        }\n        long rightSqaure = 1l * right * right;\n        return rightSqaure > x ? left : right;\n    }\n}\n```\n\nTime: O(logX)\n\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/39#issuecomment-2573695259","body":"Classic binary search.\n\n```java\n/* The isBadVersion API is defined in the parent class VersionControl.\n      boolean isBadVersion(int version); */\n\npublic class Solution extends VersionControl {\n    \n    public int firstBadVersion(int n) {\n        int left = 0, right = n;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (isBadVersion(mid)) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        return left;\n    }\n}\n```\n\nTime: O(logn)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/40#issuecomment-2577138109","body":"### Main Idea\r\nMerge sort variation..\r\n\r\n### Code\r\n```java\r\nclass Solution {\r\n    public int reversePairs(int[] nums) {\r\n        return helper(nums, 0, nums.length - 1);\r\n    }\r\n\r\n    private int helper(int[] nums, int start, int end) {\r\n        if (start >= end) {\r\n            return 0;\r\n        }\r\n\r\n        int mid = start + (end - start) / 2;\r\n        int res = helper(nums, start, mid) + helper(nums, mid + 1, end) + count(nums, start, mid, end);\r\n        int p1 = start, p2 = mid + 1, n = end - start + 1;\r\n        int[] arr = new int[n];\r\n\r\n        for (int i = 0; i < n; ++i) {\r\n            if (p1 > mid || p2 <= end && nums[p2] < nums[p1]) {\r\n                arr[i] = nums[p2];\r\n                ++p2;\r\n            } else {\r\n                arr[i] = nums[p1];\r\n                ++p1;\r\n            }\r\n        }\r\n\r\n        for (int i = start; i <= end; ++i) {\r\n            nums[i] = arr[i - start];\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    private int count(int[] nums, int start, int mid, int end) {\r\n        int p1 = start, p2 = mid + 1, cnt = 0;\r\n        while (p1 <= mid && p2 <= end) {\r\n            if (nums[p1] * 1l > 2l * nums[p2]) {\r\n                cnt += (mid - p1 + 1);\r\n                ++p2;\r\n            } else {\r\n                ++p1;\r\n            }\r\n        }\r\n        return cnt;\r\n    }\r\n}\r\n```\r\n\r\n### Complexity\r\nTime: `O(nlogn)`\r\n\r\nSpace: `O(n)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/41#issuecomment-2578880004","body":"Binary search the smallest possible solution.\n\n```java\nclass Solution {\n    public int findRadius(int[] houses, int[] heaters) {\n        Arrays.sort(houses);\n        Arrays.sort(heaters);\n\n        int left = 0, right = Integer.MAX_VALUE;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            boolean res = possible(houses, heaters, mid);\n            if (res) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        return left;\n    }\n\n    private boolean possible(int[] houses, int[] heaters, int r) {\n        int i = 0, j = 0, m = houses.length, n = heaters.length;\n        while (i < m && j < n) {\n            if (houses[i] >= heaters[j] - r && houses[i] <= heaters[j] + r) {\n                ++i;\n            } else if (houses[i] < heaters[j] - r) {\n                return false;\n            } else {\n                ++j;\n            }\n        }\n        return i >= m;\n    }\n}\n```\n\nTime: `O(mlogm + mlogn)`, where m is the length of the two input arrays, n is the solution space, sorting both arrays takes mlogm, binary search the answer takes mlogn.\n\nSpace: `O(m)` for sorting both arrays.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/42#issuecomment-2581812651","body":"\r\n```java\r\nclass Solution {\r\n    public int smallestDistancePair(int[] nums, int k) {\r\n        int n = nums.length;\r\n        Arrays.sort(nums);\r\n        int left = 0, right = nums[n - 1] - nums[0];\r\n        while (left < right) {\r\n            int mid = left + (right - left) / 2;\r\n            int cnt = countSmEq(nums, mid);\r\n\t\t\t\t\t\t// If there are more than k pairs, then mid can be a possible solution\r\n            if (cnt >= k) {\r\n                right = mid;\r\n            } else {\r\n                left = mid + 1;\r\n            }\r\n        }\r\n        return left;\r\n    }\r\n    \r\n    private int countSmEq(int[] nums, int diff) {\r\n        int n = nums.length, fast = 1, slow = 0, cnt = 0;\r\n        while (slow < n - 1) {\r\n            while (fast < n && nums[fast] - nums[slow] <= diff) {\r\n                ++fast;\r\n            }\r\n            cnt += fast - slow++ - 1;\r\n        }\r\n        return cnt;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/43#issuecomment-2583338015","body":"Binary search the answer.\n\n```java\nclass Solution {\n    private int[][] dirs = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n    public int swimInWater(int[][] grid) {\n        int n = grid.length, left = 0, right = 50 * 50;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (check(grid, mid)) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n    \n    private boolean check(int[][] grid, int t) {\n        int n = grid.length;\n        Queue<int[]> queue = new ArrayDeque<>();\n        boolean[][] visited = new boolean[n][n];\n        if (grid[0][0] <= t) {\n            queue.offer(new int[] {0, 0});\n            visited[0][0] = true;    \n        }\n        while (!queue.isEmpty()) {\n            int[] pos = queue.poll();\n            if (pos[0] == n - 1 && pos[1] == n - 1) {\n                return true;\n            }\n            for (int[] dir : dirs) {\n                int x = pos[0] + dir[0], y = pos[1] + dir[1];\n                if (x < 0 || x >= n || y < 0 || y >= n || visited[x][y] || grid[x][y] > t) {\n                    continue;\n                }\n                \n                queue.offer(new int[] {x, y});\n                visited[x][y] = true;\n            }\n        }\n        \n        return false;\n    }\n}\n```\nComplexity Analysis\nTime: `O(n^2 * logn)`\n\nSpace: `O(n)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/44#issuecomment-2585553965","body":"Sliding window\n\n```java\nclass Solution {\n    public int maxVowels(String s, int k) {\n        String vowels = \"aeiou\";\n        int n = s.length(), l = 0, r = 0, res = 0, cnt = 0;\n        while (r < n) {\n            while (r < n && r - l < k) {\n                if (vowels.indexOf(s.charAt(r)) != -1) {\n                    ++cnt;\n                }\n                ++r;\n            }\n\n            res = Math.max(res, cnt);\n            if (vowels.indexOf(s.charAt(l)) != -1) {\n                --cnt;\n            }\n            ++l;\n        }\n\n        return res;\n    }\n}\n```\nTime: O(n)\n\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/45#issuecomment-2585944937","body":"```java\nclass Solution {\n    public double new21Game(int n, int k, int maxPts) {\n        if (k - 1 + maxPts <= n) {\n            return 1.0;\n        }\n        double[] dp = new double[k + maxPts];\n        double sum = 0.0;\n        for (int i = k; i <= n; i++) {\n            dp[i] = 1.0;\n            sum += dp[i];\n        }\n        int left = k, right = k - 1 + maxPts;\n        for (int i = k - 1; i >= 0; i--) {\n            dp[i] = sum / maxPts;\n            sum -= dp[right--];\n            sum += dp[--left];\n        }\n        return dp[0];\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/46#issuecomment-2588529031","body":"HashMap + sliding window.\n```java\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        int m = s.length(), n = p.length();\n        Map<Character, Integer> count = new HashMap<>();\n        Map<Character, Integer> freq = new HashMap<>();\n\n        for (int i = 0; i < n; ++i) {\n            freq.put(p.charAt(i), freq.getOrDefault(p.charAt(i), 0) + 1);\n        }\n\n        int left = 0, right = 0;\n        List<Integer> res = new ArrayList<>();\n\n        while (right < m) {\n            while (right < m && right - left < n) {\n                count.put(s.charAt(right), count.getOrDefault(s.charAt(right), 0) + 1);\n                ++right;\n            }\n\n            if (Objects.equals(freq, count)) {\n                res.add(left);\n            }\n\n            count.computeIfPresent(s.charAt(left), (c, cnt) -> cnt == 1 ? null : cnt - 1);\n            ++left;\n        }\n\n        return res;\n    }\n}\n```\nTime: O(len(s))\n\nSpace: O(1), as we only have at most 26 characters.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/47#issuecomment-2591919208","body":"Sliding window + hash map\n\n```java\nclass Solution {\n    public String minWindow(String s, String t) {\n        int m = s.length();\n        Map<Character, Integer> freqOfT = getFreq(t);\n\n        // {startIndex, len}\n        int[] res = new int[2];\n        int left = 0, right  = 0;\n        Map<Character, Integer> freqOfS = new HashMap<>();\n        \n        while (right < m) {\n            while (right < m && !check(freqOfS, freqOfT)) {\n                freqOfS.put(s.charAt(right), freqOfS.getOrDefault(s.charAt(right), 0) + 1);\n                ++right;\n            }\n\n            while (left < right && check(freqOfS, freqOfT)) {\n                int len = right - left;\n                if (res[1] == 0 || len < res[1]) {\n                    res[0] = left;\n                    res[1] = len;\n                }\n\n                freqOfS.computeIfPresent(s.charAt(left), (c, cnt) -> cnt == 1 ? null : cnt - 1);\n                ++left;\n            }\n        }\n\n        return s.substring(res[0], res[0] + res[1]);\n\n    }\n    private boolean check(Map<Character, Integer> sMap, Map<Character, Integer> tMap) {\n        for (var entry : tMap.entrySet()) {\n            char c = entry.getKey();\n            int tCount = entry.getValue();\n            int sCount = sMap.getOrDefault(c, 0);\n\n            if (tCount > sCount) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n    private Map<Character, Integer> getFreq(String t) {\n        Map<Character, Integer> freq = new HashMap<>();\n\n        for (int i = 0; i < t.length(); ++i) {\n            freq.put(t.charAt(i), freq.getOrDefault(t.charAt(i), 0) + 1);\n        }\n\n        return freq;\n    }\n}\n```\nTime: O(len(S) + len(T)), because comparing two hash maps takes O(1), as there are only 26 alphabets.\n\nSpace: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/48#issuecomment-2594635613","body":"```java\nclass Solution {\n    public int maxScore(int[] cards, int k) {\n        int n = cards.length, len = n - k, left = 0, right = 0, minSum = Integer.MAX_VALUE, sum = 0;\n        while (right - left < len) {\n            sum += cards[right];\n            right++;\n        } \n        \n        while (right < n) {\n            minSum = Math.min(minSum, sum);\n            sum -= cards[left];\n            left++;\n            sum += cards[right];\n            right++;\n        }\n        \n        minSum = Math.min(minSum, sum);\n        int cardSum = 0;\n        for (int card : cards) {\n            cardSum += card;\n        }\n        return cardSum - minSum;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/49#issuecomment-2597449998","body":"```java\nclass Solution {\n    private int[] watch = {1, 2, 4, 8, 1, 2, 4, 8, 16, 32};\n    List<String> ret = new ArrayList<>();\n    public List<String> readBinaryWatch(int turnedOn) {\n        boolean[] chosen = new boolean[watch.length];\n        dfs(0, turnedOn, chosen);\n        return ret;\n    }\n    \n    private void dfs(int idx, int turnedOn, boolean[] chosen) {\n        if (idx == watch.length || turnedOn == 0) {\n            if (turnedOn != 0) {\n                return;\n            }\n            int hour = 0, min = 0;\n            for (int i = 0; i < watch.length; i++) {\n                if (chosen[i]) {\n                    if (i < 4) {\n                        hour += watch[i];\n                    } else {\n                        min += watch[i];\n                    }\n                }\n            }    \n            \n            if (min >= 60 || hour > 11) {\n                return;\n            }\n            \n            StringBuilder sb = new StringBuilder();\n            sb.append(hour);\n            sb.append(':');\n            if (min < 10) {\n                sb.append('0');\n            }\n            sb.append(min);\n            ret.add(sb.toString());\n            return;\n        }\n        \n        chosen[idx] = true;\n        dfs(idx + 1, turnedOn - 1, chosen);\n        chosen[idx] = false;\n        dfs(idx + 1, turnedOn, chosen);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/50#issuecomment-2599603218","body":"Backtracking.\n\n```java\nclass Solution {\n    private int res;\n\n    public int totalNQueens(int n) {\n        List<Integer> board = new ArrayList<>();\n        this.res = 0;\n        backtrack(board, n);\n        return this.res;\n    }\n\n\n    private void backtrack(List<Integer> board, int n) {\n        if (board.size() == n) {\n            ++res;\n            return;\n        }\n\n        for (int i = 1; i <= n; ++i) {\n            if (check(board, board.size() + 1, i)) {\n                board.add(i);\n                backtrack(board, n);\n                board.remove(board.size() - 1);\n            }\n        }\n    }\n\n    private boolean check(List<Integer> board, int x, int y) {\n        if (board.isEmpty()) {\n            return true;\n        }\n        \n        for (int i = 0; i < board.size(); ++i) {\n            if (board.get(i) == y || Math.abs(i + 1 - x) == Math.abs(board.get(i) - y)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n```\n\nTime: O(n!)\nSpace: O(n), for doing recursion & array to simulate board.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/51#issuecomment-2600744074","body":"BFS:\n\n```java\nclass Solution {\n    public int maxAreaOfIsland(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        \n        int ret = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) {\n                    continue;\n                }\n                \n                Queue<int[]> queue = new ArrayDeque<>();\n                queue.offer(new int[] {i, j});\n                grid[i][j] = 0;\n                int area = 1;\n                while (!queue.isEmpty()) {\n                    int[] loc = queue.poll();\n                    for (int[] dir : dirs) {\n                        int x = loc[0] + dir[0], y = loc[1] + dir[1];\n                        if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 0) {\n                            continue;\n                        }\n                        queue.offer(new int[] {x, y});\n                        grid[x][y] = 0;\n                        area++;\n                    }\n                }\n                \n                ret = Math.max(ret, area);\n            }\n        }\n        \n        return ret;\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/54#issuecomment-2606688055","body":"```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        if (root == null) return null;\n        // col -> {row, val}\n        Map<Integer, List<int[]>> map = new HashMap<>();\n        dfs(root, 0, 0, map);\n        List<List<Integer>> res = new ArrayList<>();\n        for (int i = -1000; i <= 1000; ++i) {\n            List<int[]> l = map.getOrDefault(i, null);\n            if (l == null) continue;\n            Collections.sort(l, (t1, t2) -> {\n                if (t1[0] == t2[0]) {\n                    return t1[1] - t2[1];\n                } else {\n                    return t1[0] - t2[0];\n                }\n            });\n            List<Integer> list = new ArrayList<>();\n            for (int[] tuple : l) {\n                list.add(tuple[1]);\n            }\n            res.add(list);\n        }\n        return res;\n    }\n    \n    private void dfs(TreeNode node, int x, int y, Map<Integer, List<int[]>> map) {\n        List<int[]> list = map.getOrDefault(x, new ArrayList<>());\n        list.add(new int[] {y, node.val});\n        map.put(x, list);\n        if (node.left != null)\n            dfs(node.left, x - 1, y + 1, map);\n        if (node.right != null)\n            dfs(node.right, x + 1, y + 1, map);\n    }    \n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/55#issuecomment-2609227870","body":"```java\nclass Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        int dp1 = 0, dp2 = 0, n = cost.length;\n        for (int i = 2; i <= n; ++i) {\n            int dp = Math.min(dp1 + cost[i - 2], dp2 + cost[i - 1]);\n            dp1 = dp2;\n            dp2 = dp;\n        }\n\n        return dp2;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/56#issuecomment-2611858429","body":"```java\nclass Solution {\n    public int rob(int[] nums) {\n        int dp1 = 0, dp2 = 0, n = nums.length;\n\n        for (int i = 0; i < n; ++i) {\n            if (i == 0) {\n                dp2 = nums[i];\n            } else {\n                int dp = Math.max(dp2, dp1 + nums[i]);\n                dp1 = dp2;\n                dp2 = dp;\n            }\n        }\n\n        return dp2;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/57#issuecomment-2613858457","body":"```java\nclass Solution {\n    public int findNumberOfLIS(int[] nums) {\n        int n = nums.length;\n        int[] counts = new int[n], lens = new int[n];\n        int ret = 0, maxLen = 0;\n        for (int i = 0; i < n; i++) {\n            if (i == 0) {\n                counts[i] = 1;\n                lens[i] = 1;\n            } else {\n                int curLen = 1, curCnt = 1;\n                for (int j = 0; j < i; j++) {\n                    if (nums[i] <= nums[j]) {\n                        continue;\n                    }\n                    if (lens[j] + 1 > curLen) {\n                        curLen = lens[j] + 1;\n                        curCnt = counts[j];\n                    } else if (lens[j] + 1 == curLen) {\n                        curCnt += counts[j];\n                    }\n                }\n\n                counts[i] = curCnt;\n                lens[i] = curLen;\n            }\n            \n            if (lens[i] > maxLen) {\n                maxLen = lens[i];\n                ret = counts[i];\n            } else if (lens[i] == maxLen) {\n                ret += counts[i];\n            }\n        }\n        return ret;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/58#issuecomment-2614229988","body":"```java\nclass Solution {\n    public int longestCommonSubsequence(String text1, String text2) {\n        int m = text1.length(), n = text2.length();\n        int[] dp1 = new int[n + 1], dp2 = new int[n + 1];\n\n        for (int i = 0; i <= m; ++i) {\n            for (int j = 0; j <= n; ++j) {\n                if (i == 0 || j == 0) {\n                    dp2[j] = 0;\n                } else {\n                    dp2[j] = Math.max(dp1[j], dp2[j - 1]);\n                    if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                        dp2[j] = Math.max(dp2[j], 1 + dp1[j - 1]);\n                    }\n                }\n            }\n            int[] temp = dp1;\n            dp1 = dp2;\n            dp2 = temp;\n        }\n        \n        return dp1[n];\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/59#issuecomment-2614863167","body":"```java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        int[] dp1 = new int[n], dp2 = new int[n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == 0 || j == 0) {\n                    dp2[j] = 1;\n                } else {\n                    dp2[j] = dp1[j] + dp2[j - 1];\n                }\n            }\n            \n            int[] tmp = dp1;\n            dp1 = dp2;\n            dp2 = tmp;\n        }\n        \n        return dp1[n - 1];\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suukii":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mirrors-cl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqy97":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jakkiabc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyoneday":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chouqin99":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhaogeg111":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnhu23":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ye2222":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uyplayer":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guixian001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"serena9":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"junzmer":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hx-code":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"admu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxiaomm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pgquestions":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eldinzhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiangwenzhe":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnwu6688":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tomtao626":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aiweng1981":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richard-lime":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"acoada":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duanyaqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ccslience":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaiykk":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cachezhou0617":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangtuo1999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cytrue":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyryan-web":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"naomiwufzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuajingliu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miss1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"johnxizhao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"incipe-win":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"revisegoal":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckysq999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dereklisdr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"perfqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mryao1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"likeyousmile":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhg1992":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liquanluo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aq666888":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"samlu-ecnu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhongxiangxiang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hatorimain":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"neado":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaojunjun1110":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wxleah":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunl1ght":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kerrhl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"orangejuz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flyzenr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"c1f2h3":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dlm001128":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuxy94":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aconcert":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linjunhe":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyqqq22":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yibenxiao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elon-lau":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nowkizzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gsgtgyb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"irenia111":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suiyi8760":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"saltychess":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rabbit2010520":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ellie-wu05":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yopming":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckytwj":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzz607":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zoulufeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxoojs":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"okkband":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wyz999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hacker90":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ricjli":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luhaoling":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flaming-cl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gelxgx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gaominghao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jessie725":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lsunxh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lanceli424":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qycoder":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qilin88":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hengheng-yun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"smz1995":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"size-of":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moyuanhua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"9vivian88":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guxuehua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kirosola":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biscuit279":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maoting":[{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/2#issuecomment-2592474528","body":"一、思路：\r\n从右到左，通过不断除以10来取对应位的数字\r\n如num = [1, 2] k=999。 \r\n第一次循环：k = 999 + 2 = 1001, res[0] = k % 10 = 1\r\n第二次循环：\r\n    k = Math.floor(k / 10) = 100 \r\n    k = k + 1 = 101\r\n    res[1] = k % 10 = 1\r\n\r\n二、代码\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0 || k > 0; --i, k = Math.floor(k / 10)) {\r\n        if (i >= 0) {\r\n            k += num[i];\r\n        }\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n```\r\n三、复杂度\r\n时间复杂度：O(max(n,logk))，其中 n 为数组的长度。\r\n空间复杂度：O(1)。除了返回值以外，使用的空间为常数。","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/3#issuecomment-2594538916","body":"一、思路 \r\n问题可以转换成，对 s 的每个下标 i，求\r\ns[i] 到其左侧最近的字符 c 的距离\r\ns[i] 到其右侧最近的字符 c 的距离\r\n这两者的最小值。\r\n\r\n注意：代码实现时，在开始遍历的时候 idx 可能不存在，为了简化逻辑，我们可以用 -n 或 2n 表示，这里 n 是 s 的长度。\r\n\r\n二、代码\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n    // 两次遍历\r\n    var len = s.length;\r\n    var ans = new Array(len).fill(0);\r\n    var idl = -len;\r\n    var idr = 2 * len;\r\n    for (let i = 0; i < len; i++) {\r\n        if (s[i] === c) {\r\n            idl = i;\r\n        }\r\n        ans[i] = i - idl;\r\n    }\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        if (s[i] === c) {\r\n            idr = i;\r\n        }\r\n        ans[i] = Math.min(ans[i], idr - i);\r\n    }\r\n    return ans;\r\n};\r\n```\r\n\r\n三、复杂度\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(1)\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/4#issuecomment-2594554385","body":"### 思路：\r\n    按照规则实现\r\n\r\n### 代码\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\n var CustomStack = function(maxSize) {\r\n    this.stack = new Array();\r\n    this.maxSize = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.stack.length < this.maxSize) {\r\n        this.stack.push(x);\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if (this.stack.length) {\r\n        return this.stack.pop();\r\n    }\r\n    return -1;\r\n};\r\n\r\n/** \r\n * 栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    const n = Math.min(this.stack.length, k);\r\n    for (let i = n - 1; i >= 0; i--) {\r\n        this.stack[i] += val; \r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度: push和pop为O（1），increment为O（min（k，top））\r\n* 空间复杂度O(1)","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/6#issuecomment-2594740837","body":"### 思路：\r\n两个栈\r\n\r\n```js\r\nvar MyQueue = function() {\r\n    this.stack = [];\r\n    this.size = 0;\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack.push(x);\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    if (this.empty()) {\r\n        return;\r\n    }\r\n    var tmpStack = [];\r\n    var stack = this.stack;\r\n    var stackLen = stack.length;\r\n    var res;\r\n    for(var i = stackLen - 1; i > 0 ; i--) {\r\n        tmpStack.push(stack.pop());\r\n    }\r\n    res = stack.pop();\r\n    for(var i = 0; i < stackLen - 1 ; i++) {\r\n        stack.push(tmpStack.pop())\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    if (this.empty()) {\r\n        return;\r\n    }\r\n    var tmpStack = [];\r\n    var stack = this.stack;\r\n    var stackLen = stack.length;\r\n    var res;\r\n    for(var i = stackLen - 1; i > 0 ; i--) {\r\n        tmpStack.push(stack.pop());\r\n    }\r\n    res = stack.pop();\r\n    stack.push(res);\r\n    for(var i = 0; i < stackLen - 1 ; i++) {\r\n        stack.push(tmpStack.pop())\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return !this.stack.length;\r\n};\r\n```\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/7#issuecomment-2595148949","body":"### 思路：\n单调栈（递增）\n- 当前值大于等于栈顶，可以成块\n- 当前值小于栈顶，去掉之前比他大的值，只保留栈顶用于成块\n\n### 代码\n```js\n// 获取栈顶元素\nvar stackTop = (stack) => {\n    return stack[stack.length - 1];\n}\n\nvar maxChunksToSorted = function(arr) {\n    if (!arr.length) return 0;\n    let ascStack = [arr[0]];\n    for (let i=1; i < arr.length; i++) {\n        let top = stackTop(ascStack);\n        if (arr[i] < top) {\n            // 小于的时候，只保留栈顶用于成块\n            while(ascStack.length && stackTop(ascStack) > arr[i]) {\n                ascStack.pop();\n            }\n            ascStack.push(top);\n        }\n        else {\n            // >= 可以独立成块\n            ascStack.push(arr[i]);\n        }\n    }\n    return ascStack.length;\n};\n```\n\n### 复杂度分析\n* 时间复杂度O(N)\n* 空间复杂度O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/8#issuecomment-2597754921","body":"```js\nvar rotateRight = function(head, k) {\n    if (k === 0 || !head || !head.next) {\n        return head;\n    }\n    let n = 1;\n    let cur = head;\n    while (cur.next) {\n        cur = cur.next;\n        n++;\n    }\n    cur.next = head;\n\n    let index = 0;\n    \n    // 计算从哪里转折\n    let add = n - k % n;\n\n    while(index < add) {\n        index++;\n        cur = cur.next;\n    }\n    const tmp = cur.next;\n    cur.next = null;\n    return tmp;\n};\n```\n\n复杂度：\n- 时间复杂度：O(n)，最坏情况下，我们需要遍历该链表两次。\n- 空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/9#issuecomment-2600880403","body":"```js\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    if (!head || !head.next) {\n        return head;\n    }\n    // 创建dumy节点\n    const dummyHead = new ListNode(0);\n    dummyHead.next = head;\n    let temp = dummyHead;\n    while (temp.next !== null && temp.next.next !== null) {\n        const node1 = temp.next;\n        const node2 = temp.next.next;\n        temp.next = node2;\n\n        node1.next = node2.next;\n        node2.next = node1;\n        \n        \n        temp = node1;\n    }\n    return dummyHead.next;\n};\n```","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/38#issuecomment-2580046968","body":"一、思路：二分法\r\n二、复杂度：\r\n- 时间复杂度：O(log n)\r\n- 空间复杂度：O(1)\r\n\r\n三、代码：\r\n```js\r\n/**\r\n * @param {number} x\r\n * @return {number}\r\n */\r\nvar mySqrt = function(x) {\r\n    var left = 0;\r\n    var right = x;\r\n    var ans = -1;\r\n\r\n    while(left <= right) {\r\n        var mid = Math.floor(left + (right - left) / 2);\r\n        var res = mid * mid;\r\n       \r\n        if(res === x) {\r\n            return mid;\r\n        }\r\n        else if (res < x) {\r\n            ans = mid;\r\n            left = mid + 1;\r\n        }\r\n        else if (res > x) {\r\n            right = mid - 1;\r\n        }\r\n    }\r\n\r\n    return ans;\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/39#issuecomment-2580466247","body":"```js\r\nvar solution = function(isBadVersion) {\r\n    /**\r\n     * @param {integer} n Total versions\r\n     * @return {integer} The first bad version\r\n     */\r\n    return function(n) {\r\n        var left = 0;\r\n        var right = n-1;\r\n\r\n        while(left <= right) {\r\n            var mid = Math.floor(left + (right - left) / 2);\r\n            var badVersion = isBadVersion(mid);\r\n            if (badVersion === false) {\r\n                left = mid + 1;\r\n            }\r\n            else {\r\n                right = mid -1;\r\n            }\r\n        }\r\n        return left;\r\n    };\r\n};\r\n```\r\n\r\n复杂度\r\n时间：O(logn)\r\n空间：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/40#issuecomment-2581905328","body":"一、思路：\r\n遍历并维护一个有序序列 d（二分法插入排序），其中 d 为已经遍历过的值的集合。对于每一个位置 0 <= i < n，我们统计 d 中大于 2 * A[i] 的个数，累计个数\r\n\r\n二、代码\r\n```js\r\n// 查找 nums[i] > target 的个数\r\nvar getNums = function(subNums, target) {\r\n    var left = 0;\r\n    var right = subNums.length - 1;\r\n    while(left <= right) {\r\n        var mid = Math.floor(left + (right - left) / 2);\r\n        if (subNums[mid] <= target ) {\r\n            left = mid + 1;\r\n        }\r\n        else if (subNums[mid] > target) {\r\n            right = mid - 1;\r\n        }\r\n    }\r\n    return subNums.length - left;\r\n};\r\n\r\n// 二分查找\r\nfunction binarySearch(sortedArray, target) {\r\n    let left = 0;\r\n    let right = sortedArray.length - 1;\r\n    while (left <= right) {\r\n        var mid = Math.floor(left + (right - left) / 2);\r\n        if (sortedArray[mid] === target) {\r\n            return mid;\r\n        } else if (sortedArray[mid] < target) {\r\n            left = mid + 1;\r\n        } else {\r\n            right = mid - 1;\r\n        }\r\n    }\r\n    return left;\r\n}\r\n\r\n// 二分法插入，保证已遍历数据\r\nfunction insertWithBinarySearch(sortedArray, newData) {\r\n    let insertIndex = binarySearch(sortedArray, newData);\r\n    sortedArray.splice(insertIndex, 0, newData);\r\n    return sortedArray;\r\n}\r\n/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\n// 一边遍历一边维护一个有序序列 d，其中 d 为已经遍历过的值的集合\r\nvar reversePairs = function(nums) {\r\n    var len = nums.length;\r\n    if (len <=1) return 0;\r\n    var sortedNums = [nums[0]];\r\n    var count = 0;\r\n    for(i = 1; i < len; i++) {\r\n        // 对于每一个位置 0 <= i < n，我们统计 d 中大于 2 * A[i] 的个数\r\n        count += getNums(sortedNums, nums[i] * 2);\r\n        // 二分法插入，保证已遍历数据\r\n        insertWithBinarySearch(sortedNums, nums[i]);\r\n    };\r\n    return count;\r\n};\r\n```\r\n\r\n三、复杂度\r\n- 时间复杂度O(logn)\r\n- 空间复杂度 O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/41#issuecomment-2582478699","body":"一、思路：\r\n排序 + 二分查找\r\n\r\n二、代码：\r\n```js\r\n/**\r\n * @param {number[]} houses\r\n * @param {number[]} heaters\r\n * @return {number}\r\n */\r\nconst binarySearchRight = (nums, target) => {\r\n    let left = 0;\r\n    let right = nums.length - 1;\r\n    let ans = -1;\r\n    while (left <= right) {\r\n        let mid = Math.floor(left + (right - left) / 2);\r\n        if (nums[mid] <= target) {\r\n            ans = mid;\r\n            // 搜索区间变为 [mid+1, right]\r\n            left = mid + 1;\r\n        }\r\n        if (nums[mid] > target) {\r\n            // 搜索区间变为 [left, mid-1]\r\n            right = mid - 1;\r\n        }\r\n    }\r\n    return ans;\r\n};\r\n\r\nconst findRadius = function(houses, heaters) {\r\n    let minRadius = 0;\r\n    let heatersLen = heaters.length;\r\n    heaters.sort((a, b) => a - b);\r\n    // 遍历每个房屋，去寻找2个离房屋最近的暖气。 \r\n    // ① 暖气1下标为i(heaters[i]≤house) ② 暖气2坐标为j(j=i+1)\r\n    for(let house of houses) {\r\n        let i = binarySearchRight(heaters, house);\r\n        let j = i + 1;\r\n        // i < 0 房子左边无暖气\r\n        const leftDistance = i < 0 ? Number.MAX_VALUE : house - heaters[i];\r\n        // j >= heatersLen 房子右边无暖气\r\n        const rightDistance = j >= heatersLen ? Number.MAX_VALUE : heaters[j] - house;\r\n\r\n        const curDistance = Math.min(leftDistance, rightDistance);\r\n        minRadius = Math.max(minRadius, curDistance);\r\n    }\r\n    return minRadius;\r\n};\r\n```\r\n\r\n三、复杂度\r\n- 时间复杂度：O((n+m)logn)，其中 m 是数组 houses 的长度，n 是数组 heaters 的长度。\r\n对数组 heaters 排序需要 O(nlogn) 的时间。\r\n使用二分查找对每个房屋寻找距离最近的供暖器，每次二分查找需要 O(logn) 的时间，有 m 个房屋，因此需要 O(mlogn) 的时间。\r\n总时间复杂度是 O((n+m)logn)。\r\n- 空间复杂度：O(logn)，其中 n 是数组 heaters 的长度。空间复杂度主要取决于排序所需要的空间。\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/42#issuecomment-2585141335","body":"一、思路\r\n排序 + 二分\r\n\r\n二、代码\r\n```js\r\nvar smallestDistancePair = function(nums, k) {\r\n    nums.sort((a, b) => a - b);\r\n    // 第 k 小的数对距离在区间 [0,max(nums)−min(nums)] 内，用二分查找寻找满足条件的值\r\n    let n = nums.length, left = 0, right = nums[n - 1] - nums[0];\r\n    while (left <= right) {\r\n        const mid = Math.floor((left + right) / 2);\r\n        let cnt = 0;\r\n        // 枚举右侧端点j，累加所有距离小于等于 mid 的数对数目 cnt。\r\n        // 即 二分查找大于等于 nums[j]−mid 的最小值的下标 i，那么右端点为 j 且距离小于等于 mid 的数对数目为 j−i，计算这些数目之和\r\n        for (let j = 0; j < n; j++) {\r\n            const i = binarySearch(nums, j, nums[j] - mid);\r\n            cnt += j - i;\r\n        }\r\n        if (cnt >= k) {\r\n            right = mid - 1;\r\n        } else {\r\n            left = mid + 1;\r\n        }\r\n    }\r\n    return left;\r\n};\r\n\r\n\r\nconst binarySearch = (nums, end, target) => {\r\n    let left = 0, right = end;\r\n    while(left <= right) {\r\n        let mid = Math.floor((left + right) / 2);\r\n        if(nums[mid] >= target) {\r\n            right = mid -1;\r\n        }\r\n        else if (nums[mid] < target) {\r\n            left = mid + 1;\r\n        }\r\n    }\r\n    return left;\r\n};\r\n```\r\n\r\n三、复杂度：\r\n- 时间复杂度：O(nlogn×logD)，其中 n 是数组 nums 的长度，D=max(nums)−min(nums)。外层二分查找需要 O(logD)，内层二分查找需要 O(nlogn)。\r\n- 空间复杂度：O(logn)。排序的平均空间复杂度为 O(logn)。","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/43#issuecomment-2585174548","body":"一、思路\r\n二分法+DFS\r\n二分法区间：[0, max(grid)]\r\nDFS注意点：\r\n1、越界 \r\n2、已访问过的格子要记录\r\n3、判断四个方向\r\n\r\n二、代码\r\n```js\r\n/**\r\n * @param {number[][]} grid\r\n * @return {number}\r\n */\r\nvar swimInWater = function(grid) {\r\n    let left = 0, right = 0;\r\n    const len = grid.length;\r\n    // 计算区间[left, right]\r\n    grid.forEach(g => {\r\n        g.forEach(x => {\r\n            right = Math.max(right, x)\r\n        })\r\n    });\r\n\r\n    let seen = {};\r\n    var isCanSwim = function (mid, x, y) {\r\n        // 边界不符合条件，false\r\n        if (x < 0 || y >= len || y < 0 || x >= len) {\r\n            return false;\r\n        }\r\n        // 当前格子水深大于区间上限，false\r\n        if (grid[x][y] > mid) {\r\n            return false;\r\n        }\r\n        // 到达终点，true\r\n        if (x == len - 1 && y == len - 1) {\r\n            return true;\r\n        }\r\n        // 当前格子已经访问过，false\r\n        if (seen[`${x}_${y}`]) {\r\n            return false;\r\n        }\r\n        // 标记当前格子已经访问过\r\n        seen[`${x}_${y}`] = true;\r\n        // 可以向右|左|下|上游泳\r\n        return isCanSwim(mid, x - 1, y)\r\n            || isCanSwim(mid, x + 1, y)\r\n            || isCanSwim(mid, x, y - 1)\r\n            || isCanSwim(mid, x, y + 1);\r\n    }\r\n    while(left <= right) {\r\n        let mid = Math.floor((left + right) / 2);\r\n        if(isCanSwim(mid, 0, 0)) {\r\n            right = mid - 1;\r\n        }\r\n        else {\r\n            left = mid + 1;\r\n        }\r\n        // 每一次重试，都需要重置seen\r\n        seen = {};\r\n    }\r\n    return left;\r\n};\r\n```\r\n\r\n三、复杂度：\r\n- 时间复杂度：O(n^2 * logn) ，其中DFS 为n^2，二分查找为 logn\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/44#issuecomment-2585585573","body":"### 思路：\r\n滑动窗口\r\n\r\n### 代码\r\n```js\r\n var maxVowels = function(s, k) {\r\n    let yuanYin = {\r\n        a: 1,\r\n        e: 1,\r\n        i: 1,\r\n        o: 1,\r\n        u: 1,\r\n    };\r\n    let max = 0;\r\n    let res = 0;\r\n    let l = 0;\r\n    let len = s.length;\r\n    for(let i=0; i<len;i++) {\r\n        if (i - l < k) {\r\n            res += yuanYin[s[i]] || 0;\r\n        }\r\n        else {\r\n            res = res - (yuanYin[s[l]] || 0) + (yuanYin[s[i]] || 0);\r\n            l++;\r\n        }\r\n        max = Math.max(max, res);\r\n    }\r\n    return max;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(n)\r\n* 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/45#issuecomment-2589625656","body":"### 思路：\r\n滑动窗口\r\n定义x为【少于 k 分时抽取数字后的和】\r\n- 已经确定的概率为：\r\n① x > min(n, k-1+maxPts+1)时，dp=0\r\n② k <= x <= min(n, k-1+maxPts+1)时，不超过n的概率为dp=1;\r\n- 未确定的概率为：\r\n0 < x < k时，未达到k时（k值的可能范围是[0, k-1]），随机抽取某个数后超过n的概率为dp[i] = xxx (参考题解)\r\n\r\n返回dp[0]\r\n\r\n### 代码\r\n```js\r\n var new21Game = function(n, k, maxPts) {\r\n    // 默认概率为0\r\n    // 重点是 x > min(n, k-1+maxPts+1)时，dp=0\r\n    const dp = new Array(k+maxPts).fill(0);\r\n    // 当分数达到或超过 k 时游戏结束，游戏结束时，如果分数不超过 n 则获胜。dp[i] = 1\r\n    // k和n之间的值，不超过n的概率都是1\r\n    // 可以达到的最大分数是k-1+maxPts\r\n    for (let i = k; i <=n && i <= k-1+maxPts; i++) {\r\n        dp[i] = 1;\r\n    }\r\n    // 未达到k值的可能范围是[0, k-1]\r\n    for (let i = k - 1; i >= 0; i--) { \r\n        // 随机抽取的范围[1, maxPts];\r\n        for (let j = 1; j <= maxPts; j++) {\r\n            dp[i] += dp[i + j] / maxPts;\r\n        }\r\n    }\r\n    return dp[0];\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(n+k*maxPts)\r\n* 空间复杂度O(k+maxPts)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/46#issuecomment-2589688656","body":"### 思路：\r\n滑动窗口\r\n用2个数组（new Array(26）)记录每个字符出现的次数\r\n\r\n### 代码\r\n```js\r\nvar findAnagrams = function(s, p) {\r\n    const sLen = s.length, pLen = p.length;\r\n\r\n    if (sLen < pLen) {\r\n        return [];\r\n    }\r\n\r\n    const ans = [];\r\n    const sCount = new Array(26).fill(0);\r\n    const pCount = new Array(26).fill(0);\r\n    for (let i = 0; i < pLen; ++i) {\r\n        ++sCount[s[i].charCodeAt() - 'a'.charCodeAt()];\r\n        ++pCount[p[i].charCodeAt() - 'a'.charCodeAt()];\r\n    }\r\n\r\n    if (sCount.toString() === pCount.toString()) {\r\n        ans.push(0);\r\n    }\r\n\r\n    for (let i = 0; i < sLen - pLen; ++i) {\r\n        --sCount[s[i].charCodeAt() - 'a'.charCodeAt()];\r\n        ++sCount[s[i + pLen].charCodeAt() - 'a'.charCodeAt()];\r\n\r\n        if (sCount.toString() === pCount.toString()) {\r\n            ans.push(i + 1);\r\n        }\r\n    }\r\n\r\n    return ans;\r\n}; \r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(Σ)（Σ = 52）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/47#issuecomment-2591791168","body":"一、思路\r\n收缩左边界： 窗口包含t的所有字符\r\n扩张右边界： 窗口不包含t的所有字符\r\n\r\n这里 t 中可能出现重复的字符，所以我们要记录字符的个数。\r\n\r\n二、代码\r\n```js\r\nconst isValid = (sObj, tObj) => {\r\n    for (let i in tObj) {\r\n        if ((sObj[i] || 0) < tObj[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * @param {string} s\r\n * @param {string} t\r\n * @return {string}\r\n */\r\nvar minWindow = function(s, t) {\r\n    const sLength = s.length;\r\n    const tLength = t.length;\r\n    if (tLength > sLength) {\r\n        return '';\r\n    }\r\n\r\n    const sObj = {};\r\n    const tObj = {};\r\n    for(let char1 of t) {\r\n        tObj[char1] = (tObj[char1] || 0) + 1;\r\n    }\r\n    let left = 0;\r\n    let right = 0;\r\n    let min = sLength;\r\n    let minLeftIndex = -1;\r\n    while(right < sLength) {\r\n    // for(;right <= sLength;right++) {\r\n        const inChar = s[right];\r\n        // 移入窗口\r\n        if (tObj[inChar]) {\r\n            sObj[inChar] = (sObj[inChar] || 0) + 1;   \r\n        }\r\n        else {\r\n            right++;\r\n            continue;\r\n        }\r\n        while(isValid(sObj, tObj) && left <= right) {\r\n            // 在范围内，满足条件移出\r\n            if ((right - left + 1) <= min) {\r\n                min = right - left + 1;\r\n                minLeftIndex = left;\r\n            }\r\n            let outChar = s[left];\r\n            sObj[outChar] && (sObj[outChar] = sObj[outChar] - 1);\r\n            left++;\r\n        }\r\n        right++;\r\n    }\r\n    return minLeftIndex > -1 ? s.substr(minLeftIndex, min) : '';\r\n};\r\n\r\ns = \"ADOBECODEBANC\", t = \"ABC\"\r\nminWindow(s, t);\r\n```\r\n\r\n三、复杂度\r\n- 时间复杂度：最坏情况下左右指针对 s 的每个元素各遍历一遍，哈希表中对 s 中的每个元素各插入、删除一次，对 t 中的元素各插入一次。每次检查是否可行会遍历整个 t 的哈希表，哈希表的大小与字符集的大小有关，设字符集大小为 C，则渐进时间复杂度为 O(C⋅∣s∣+∣t∣)。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/48#issuecomment-2601615661","body":"```js\n/**\n * @param {number[]} cardPoints\n * @param {number} k\n * @return {number}\n */\nvar maxScore = function(cardPoints, k) {\n    const n = cardPoints.length;\n    // 滑动窗口大小为 n-k\n    const windowSize = n - k;\n\n    // 选前 n-k 个作为初始值\n    let sum = 0;\n    for (let i = 0; i < windowSize; ++i) {\n        sum += cardPoints[i];\n    }\n\n    let totalSum = 0;\n    for (let i = 0; i < n; i++) {\n        totalSum += cardPoints[i];\n    }\n\n    let minSum = sum;\n    for (let i = windowSize; i < n; ++i) {\n        // 滑动窗口每向右移动一格，增加从右侧进入窗口的元素值，并减少从左侧离开窗口的元素值\n        sum += cardPoints[i] - cardPoints[i - windowSize];\n        minSum = Math.min(minSum, sum);\n    }\n\n    return totalSum - minSum;\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/49#issuecomment-2601822434","body":"一、思路：\n- num.toString([radix]) 用于指定在转换过程中使用的基数（进制数）\n- h.toString(2).split('0').join('') 不用计算灯灭的位数\n\n二、代码：\n```js\nvar readBinaryWatch = function(turnedOn) {\n    const ans = [];\n    for (let h = 0; h < 12; ++h) {\n        for (let m = 0; m < 60; ++m) {\n            if (h.toString(2).split('0').join('').length + m.toString(2).split('0').join('').length === turnedOn) {\n                ans.push(h + \":\" + (m < 10 ? \"0\" : \"\") + m);\n            }\n        }\n    }\n    return ans;\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/50#issuecomment-2603842964","body":"一、思路：\n回溯\n- （斜右方）行下标与列下标之差相等 row - col = 常数，并且常数值不同\n- （斜左方）行下标与列下标之和相等 row + col = 常数，并且常数值不同\n\n二、代码：\n```js\n/**\n * @param {number} n\n * @return {number}\n */\nvar totalNQueens = function(n) {\n    const cols = new Set();\n    const pie = new Set();\n    const na = new Set();\n    return backtrack(n, 0, cols, pie, na);\n};\n\nconst backtrack = (n, row, cols, pie, na) => {\n    if (row === n) {\n        return 1;\n    } else {\n        let count = 0;\n        for (let i = 0; i < n; i++) {\n            const naIndex = row - i;\n            const pieIndex = row + i;\n            if (cols.has(i) || pie.has(pieIndex) || na.has(naIndex)) {\n                continue;\n            }\n            cols.add(i);\n            pie.add(pieIndex);\n            na.add(naIndex);\n            count += backtrack(n, row + 1, cols, pie, na);\n            // 恢复现场，尝试同行的下一个数据\n            cols.delete(i);\n            pie.delete(pieIndex);\n            na.delete(naIndex);\n        }\n        return count;\n    }\n}\n```\n\n三、复杂度：\n\n- 时间复杂度O(n!)\n- 空间复杂度O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/51#issuecomment-2604394114","body":"一、思路\nDFS: 递归+visited（map）\n实际访问过的数据，遍历后设置为0，代表已经访问过，否则重复相加\n对于上下左右入栈的，需要记录是否访问过（可用map），直接清零，会阻断其他元素入栈。\n\n二、代码\n```js\nvar maxAreaOfIsland = (grid)  => {\n        let rows = grid.length;\n        let maxArea = 0;\n        // [] 特殊处理\n        if (!rows) {\n            return 0;\n        }\n        let cols = grid[0].length\n        // 关键:两个stack维护下标\n        let stacki = [];\n        let stackj = [];\n        let res = 0;\n        let visitedMap = {};\n        const isValid = (i, j) => {\n            return (\n                // 坐标合理\n                (i >= 0 && i < rows) && (j >= 0 && j < cols)\n                // 存在岛屿\n                && grid[i][j]!==0\n                // 未访问过\n                && !visitedMap[i + ',' + j]\n            );\n        }\n\n        const dfs = (i, j) => {\n            if (!isValid(i, j)) {\n                return 0;\n            }\n            // 当前值处理后清零，以免重复访问\n            grid[i][j] = 0;\n            let ans = 1;\n            // 顺序：上下左右(任一方向相邻)\n            // 顺序：上下左右(任一方向相邻)\n            let dx = [-1, 1, 0, 0];\n            let dy = [0, 0, -1, 1]; \n            for (let m = 0; m < dx.length; ++m) {\n                let next_i = i + dx[m];\n                let next_j = j + dy[m];\n                ans += dfs(next_i, next_j);\n            }\n            return ans;\n        }\n\n        for (let i = 0; i< rows; i++ ) {\n            for (let j = 0; j< cols; j++ ) {\n                res = Math.max(dfs(i, j), res);\n            }\n        }\n        \n        return res;\n    };\n```\n三、复杂度\n\n- 时间复杂度：O(m×n)。其中 m 是给定网格中的行数，n 是列数。我们访问每个网格最多一次。\n- 空间复杂度：O(m×n)，递归的深度最大可能是整个网格的大小，因此最大可能使用 O(m×n) 的栈空间。\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/52#issuecomment-2606625816","body":"一、思路：\nBFS\n先把所有的陆地都入队，然后从各个陆地（遍历陆地）同时开始一层一层的向海洋扩散，那么最后扩散到的海洋就是最远的海洋，并且这个海洋肯定是被离他最近的陆地给扩散到的！\n\n二、代码\n```js\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar maxDistance = function(grid) {\n    let rows = grid.length;\n    let cols = grid[0].length;\n    let landQueue = [];\n\n    const isValid = (i, j) => {\n        return (\n            // 坐标合理\n            (i >= 0 && i < rows) && (j >= 0 && j < cols)\n        );\n    }\n\n    // 先把所有的陆地都入队。\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            if (grid[i][j] == 1) {\n                landQueue.push([i, j]);\n            }\n        }\n    }\n    // 没有陆地或者没有海洋，返回-1。\n    if (landQueue.length === cols * rows || landQueue === 0) {\n        return -1\n    }\n\n    let distance = -1;\n    while(landQueue.length) {\n        distance++;\n        const size = landQueue.length;\n        for(let i = 0; i < size; i++) {\n            // 处理当前值\n            let [current_i, current_j] = landQueue.shift();\n            // 顺序：上下左右(任一方向相邻)引入四周值作为线索\n            let dx = [-1, 1, 0, 0];\n            let dy = [0, 0, -1, 1]; \n            for (let m = 0; m < dx.length; ++m) {\n                const next_i = current_i + dx[m];\n                const next_j = current_j + dy[m];\n                if (isValid(next_i, next_j) && grid[next_i][next_j] == 0) {\n                    grid[next_i][next_j] = 1;\n                    landQueue.push([next_i, next_j]);\n                }\n            }\n        }\n    }\n    return distance;\n};\n```\n三、复杂度\n时间复杂度O(n^2).\n空间复杂度O(1 ).","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/53#issuecomment-2610128024","body":"一、思路\nBFS + 队列\n注意：\n在枚举盒子时，如果该盒子可以被打开，就将其加入队尾；\n同理，在枚举钥匙时，如果其对应的盒子已经被拥有，就将该盒子加入队尾。\n\n二、代码\n```js\nvar maxCandies = function(status, candies, keys, containedBoxes, initialBoxes) {\n    // 获取的盒子\n    let hasBox = {};\n    // 可以打开的盒子\n    let canOpen = {};\n    let ans = 0;\n    let used = {};\n    for (let i = 0; i < status.length; ++i) {\n        canOpen[i] = status[i];\n    }\n\n    let queue = [];\n    // 遍历initialBoxes\n    for (let initBoxIndex of initialBoxes) {\n        // 获取的盒子\n        hasBox[initBoxIndex] = 1;\n        // 如果该盒子可以被打开，就将其加入队尾\n        if (canOpen[initBoxIndex]) {\n            queue.push(initBoxIndex);\n            used[initBoxIndex] = true;\n            ans += candies[initBoxIndex];\n        }\n    }\n\n    while(queue.length) {\n        // bigBox是数组\n        const bigBox = queue.shift();\n        for (let key of keys[bigBox]) {\n            canOpen[key] = 1;\n            // 在枚举钥匙时，如果其对应的盒子已经被拥有，就将该盒子加入队尾\n            if (!used[key] && hasBox[key]) {\n                queue.push(key);\n                used[key] = true;\n                ans += candies[key];\n            }\n        }\n        for (let boxIndex of containedBoxes[bigBox]) {\n            hasBox[boxIndex] = 1;\n            // 在枚举盒子时，如果该盒子可以被打开，就将其加入队尾\n            if (!used[boxIndex] && canOpen[boxIndex]) {\n                queue.push(boxIndex);\n                used[boxIndex] = true;\n                ans += candies[boxIndex];\n            }\n        }\n    }\n\n    return ans;\n};\n```\n复杂度分析\n- 时间复杂度：O(N)\n-空间复杂度：O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/54#issuecomment-2607491206","body":"### 思路：\n看了官方题解\nDFS遍历\n然后按照要求排序，按照列、行、值排序\n\n### 代码\n```js\n /**\n * @param {TreeNode} root\n * @return {number[][]}\n */\n\n var verticalTraversal = function(root) {\n    const nodes = [];\n    dfs(root, 0, 0, nodes);\n    // 排序后\n    // [ [ -1, 1, 9 ], [ 0, 0, 3 ], [ 0, 2, 15 ], [ 1, 1, 20 ], [ 2, 2, 7 ] ]\n    nodes.sort((tuple1, tuple2) => {\n        // 列排序\n        if (tuple1[0] !== tuple2[0]) {\n            return tuple1[0] - tuple2[0];\n        // 行排序\n        } else if (tuple1[1] !== tuple2[1]) {\n            return tuple1[1] - tuple2[1];\n        // 值排序\n        } else {\n            return tuple1[2] - tuple2[2];\n        }\n    });\n\n    const ans = [];\n    let lastcol = -Number.MAX_VALUE;\n    for (const tuple of nodes) {\n        let col = tuple[0], value = tuple[2];\n        if (col !== lastcol) {\n            lastcol = col;\n            ans.push([]);\n        }\n        ans[ans.length - 1].push(value);\n    }\n    return ans;\n}\n\nconst dfs = (node, row, col, nodes) => {\n    if (node === null) {\n        return;\n    }\n    nodes.push([col, row, node.val]);\n    dfs(node.left, row + 1, col - 1, nodes);\n    dfs(node.right, row + 1, col + 1, nodes);\n}  \n```\n\n### 复杂度分析\n* 时间复杂度O(nlogn)\nO(N)对数组进行遍历、O(nlogn)对数组进行排序\n* 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/55#issuecomment-2611458070","body":"一、思路\n动态规划\ndp方程：dp[i + 1] = Math.min(dp[i] + cost, dp[i-1] + cost[i-1]);\n\n二、代码\n```js\n/**\n * @param {number[]} cost\n * @return {number}\n */\nvar minCostClimbingStairs = function(cost) {\n    const len = cost.length;\n    let dp = new Array(len).fill(0);\n\n    for (let i = 1; i < len; i++) {\n        dp[i + 1] = Math.min(dp[i] + cost[i], dp[i-1] + cost[i - 1]);\n    }\n\n    return dp[len];\n};\n```\n\n三、复杂度\n时间复杂度 O(n)\n空间复杂度 O(n)\n\n上述代码的时间复杂度和空间复杂度都是 O(n)。注意到当 i≥2 时，dp[i] 只和 dp[i−1] 与 dp[i−2] 有关，因此可以使用滚动数组的思想，将空间复杂度优化到 O(1)。\n```js\nvar minCostClimbingStairs = function(cost) {\n    const len = cost.length;\n    let step1 = 0;\n    let step2 = 0;\n    let next = 0;\n\n    for (let i = 1; i < len; i++) {\n        next = Math.min(step1 + cost[i], step2 + cost[i - 1]);\n        step2 = step1;\n        step1 = next;\n    }\n\n    return next;\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/56#issuecomment-2611524617","body":"### 思路：\n动态规划\ndp方程：dp[n] = Math.max(dp[n-1], dp[n-2] + nums[n])\n\n### 代码\n```js\nvar rob = function(nums) {\n    let len = nums.length;\n    if (len == 0) return 0;\n    if (len === 1) return nums[0];\n    let dp = new Array(len).fill(0);\n    dp[0] = nums[0];\n    dp[1] = Math.max(nums[0], nums[1]);\n    for (let n = 2; n < len; n++) {\n        dp[n] = Math.max(dp[n-1], dp[n-2] + nums[n]);\n    }\n    return dp[len - 1];\n};   \n```\n\n### 复杂度分析\n* 时间复杂度O(N)\n* 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/57#issuecomment-2614448322","body":"### 思路：\n- 定义dp[n]记录以nums[n]结尾的最长上升字符串的最大长度\n- 定义cnt[n]记录以nums[n]结尾的'最大长度'的个数 \n**eg. 当nums=[1,2,2,3] 当n=2时，最长上升字符串为[1,2,3]与[1,2,3]，则cnt[n]=2、dp[n] = 3**\n- dp[n] = Math.max(dp[j] + 1) (0 <= j < n && nums[j] < nums[n]>), 考虑往dp[0…n−1] 中最长的上升子序列后面再加一个nums[j]\n- maxLen = Math.max(dp[n], maxLen)\n- ans 为从[0…len−1]过程中累计（最长上升字串）'最大长度'的个数(Sum 符合条件的cnt[n])\n\n### 代码\n```js\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumberOfLIS = function(nums) {\n    let len = nums.length;\n    let dp = new Array(len).fill(1);\n    let cnt = new Array(len).fill(1);\n    let maxLen = 0;\n    let ans = 0;\n    for(let n = 0; n < len; n++) {\n        for(let j = 0; j < n; j++) {\n            if (nums[n] > nums[j]) {\n                if (dp[j] + 1 > dp[n]) {\n                    dp[n] = dp[j] + 1;\n                    cnt[n] = cnt[j]; // 重置计数（只保留最大的长度）\n                }\n                else if (dp[j] + 1 === dp[n]) {\n                    cnt[n] += cnt[j]; // 同为最大值，累加\n                }\n            }\n        }\n        // 找最大值\n        if (dp[n] > maxLen) {\n            maxLen = dp[n];\n            ans = cnt[n];\n        }\n        else if (dp[n] === maxLen) {\n            ans += cnt[n];\n        }\n    }\n    return ans;\n}; \n```\n\n### 复杂度分析\n* 时间复杂度O(N * N)\n* 空间复杂度O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/58#issuecomment-2614248682","body":"### 思路：\n二维动态规划\n\n### 代码\n```js\nconst longestCommonSubsequence = (str1, str2) => {\n    let m = str1.length;\n    let n = str2.length;\n    let dp = Array.from(new Array(m+1), item => Array(n+1).fill(0));\n    for (let i = 1; i<=m; i++) {\n        for (let j = 1; j<=n; j++) {\n            if (str1[i-1] === str2[j-1]) {\n                // 两个都选\n                dp[i][j] = dp[i-1][j-1]+1;\n            }\n            else {\n                // Math(选择str1中字符最长公共子序列； 、选择str2中的字符最长公共子序列)\n                dp[i][j] = Math.max(dp[i][j-1] || 0, dp[i-1][j] || 0);\n            }\n        }\n    }\n    return dp[m][n]\n}   \n```\n\n### 复杂度分析\n* 时间复杂度O(M * N)\n* 空间复杂度O(M * N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"youzhaing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jawn-ha":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hanwangxxx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dujt-x":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"degndaixingqiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gzgzgzgzgzgz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gentleman-goodman":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xinyi-arch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zenwangzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"andyyxw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fourierhai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yangz001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mannnn6":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"haoyangxie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chjillout":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wenjialu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mhcn":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"coconutice":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jackgaoyuan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhan0312":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yufeng727":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fontendart":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yingchehu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cobayaz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tomato-tomato":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xfliudx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"djd28176":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xilutian":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xy147":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"itsjacob":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shunanch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yppah-eb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"raychenlei":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"woshichuanqilz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"willuuu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"christina-soda":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jia98shanliang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"user-vannnn":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tobepellucid":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"johnvsd":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yueza":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawyuan97":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"victorhuang99":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cusanity":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jay-xzj":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiradaone":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xinyue-ma":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taojin1992":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joyce94":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"steven72574":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tian-pengfei":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asuka1h":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaowangcoding":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"james0608":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaneyang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"azl397985856":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whgsh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chengfengfengwang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bulingbulingbuling":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"c2tr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eden-ye":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"codingtrains":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"starorbiting":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mo-xiaoxiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"passengersa":[{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/2#issuecomment-2509767434","body":"思路：\n1、将数组看成是一个加数，需要num和key逐位相加，需要考虑到进位，先定义一个是否进位的变量，0为不进位，1为进位，索引为num.length - 1 即数组中的最后一个，和key中的最小位相加，从而得知是否进位和计算得出当前的进位后的结果，然后新数组首部添加，在将key右移，用十位相加，依次类推，百位相加，索引自减1，直到 i>=0||k>0||carry>0都不满足时，则退出循环，返回相加后的结果\n时间复杂度分析：\n2、因为数组有多少个，就要有多少个进行相加，例如[1,2,3,4,5,6]和45，数组中的每项都需要加，索引其时间复杂度为O(N)\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n       let carry = 0 // 是否进位 0-不进位 1-进位\n  let i = num.length - 1\n  let result = []\n  // 逐位相加\n  while (i >= 0|| k > 0 || carry > 0) {\n    let digit = (i >= 0 ? num[i] : 0) + (k % 10) + carry\n    carry = Math.floor(digit / 10)\n    digit = digit % 10\n    result.unshift(digit)\n    k = Math.floor(k / 10)\n    i--\n  }\n  return result\n};","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/8#issuecomment-2525223698","body":"思路：\n1、定义链表节点类：首先，我们需要定义一个表示链表节点的类，通常包含一个值和一个指向下一个节点的指针。\n2、计算链表长度：遍历链表以确定其长度，并找到尾节点。\n3、处理旋转步数：根据链表长度调整旋转步数，因为旋转步数可能大于链表长度。\n4、找到新尾节点：根据调整后的旋转步数，找到新的尾节点。\n5、调整指针：将原尾节点连接到原头节点，然后断开新尾节点与新头节点之间的连接。\n时间复杂度：O(N)\n代码：\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n     if (!head || !head.next || k === 0) {\n    return head;\n  }\n\n  // Step 1: Calculate the length of the linked list\n  let length = 1;\n  let tail = head;\n  while (tail.next) {\n    tail = tail.next;\n    length++;\n  }\n  k = k % length;\n  if (k === 0) {\n    return head;\n  }\n  let newTail = head;\n  for (let i = 0; i < length - k - 1; i++) {\n    newTail = newTail.next;\n  }\n  let newHead = newTail.next;\n  newTail.next = null;\n  tail.next = head;\n  return newHead;\n};\n\nclass ListNode {\n  constructor(val) {\n    this.val = val;\n    this.next = null;\n  }\n}\nfunction printList(head) {\n  let current = head;\n  let result = '';\n  while (current) {\n    result += current.val + ' -> ';\n    current = current.next;\n  }\n  result += 'NULL';\n  console.log(result);\n}\nlet head = new ListNode(1);\nhead.next = new ListNode(2);\nhead.next.next = new ListNode(3);\nhead.next.next.next = new ListNode(4);\nhead.next.next.next.next = new ListNode(5);\nlet newHead = rotateRight(head, 2);\nprintList(newHead); ","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/15#issuecomment-2543073283","body":"思路：\n1、递归终止条件：\n如果 p 和 q 都为 null，说明它们都到达了叶子节点，返回 true。\n如果其中一个为 null 而另一个不是，说明结构不同，返回 false。\n如果两个节点的值不同，返回 false。\n2、递归检查：\n\n递归检查 p 和 q 的左子树和右子树是否相同。\n时间复杂度： O(n)\n\n代码：\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n     // 如果两个节点都为空，则它们相同\n    if (p === null && q === null) {\n        return true;\n    }\n    \n    // 如果其中一个节点为空，另一个不为空，则它们不相同\n    if (p === null || q === null) {\n        return false;\n    }\n    \n    // 如果节点的值不同，则它们不相同\n    if (p.val !== q.val) {\n        return false;\n    }\n    \n    // 递归检查左子树和右子树\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n};","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/20#issuecomment-2554270777","body":"思路：\n1、初始化哈希表：创建一个空对象 map，用于存储数组中的元素及其下标。\n2、遍历数组：使用 for 循环遍历数组 nums。\n3、计算差值：对于每个元素 nums[i]，计算 complement = target - nums[i]，即目标值与当前元素的差值。\n4、检查哈希表：使用 in 操作符检查 complement 是否存在于 map 中。\n     如果存在，说明之前已经有一个元素与当前元素的和等于目标值，返回这两个元素的下标 [map[complement], i]。\n    如果不存在，将当前元素及其下标存入 map 中，即 map[nums[i]] = i。\n5、返回结果：如果遍历完数组后没有找到符合条件的两个数，返回空数组 []。\n时间复杂度：O(n)\n代码：\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n        const map = {};\n\n    // 遍历数组\n    for (let i = 0; i < nums.length; i++) {\n        // 计算当前元素与目标值的差值\n        const complement = target - nums[i];\n\n        // 检查哈希表中是否存在差值\n        if (complement in map) {\n            // 如果存在，返回当前下标和差值的下标\n            return [map[complement], i];\n        }\n\n        // 将当前元素及其下标存入哈希表\n        map[nums[i]] = i;\n    }\n\n    // 如果没有找到符合条件的两个数，返回空数组\n    return [];\n};","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/26#issuecomment-2561867365","body":"思路：\n初始化两个指针 slow 和 fast，都指向链表的头结点 head。\nslow 指针每次移动一步，fast 指针每次移动两步。\n当 fast 指针到达链表的末尾时，slow 指针正好指向链表的中间结点。\n如果链表的长度是奇数，slow 指针正好指向中间结点；如果链表的长度是偶数，slow 指针会指向第二个中间结点。\n复杂度：\n时间复杂度是 O(n)，空间复杂度是 O(1)\n代码：\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function(head) {\n    let slow = head;\n    let fast = head;\n\n    // 当 fast 指针到达末尾时，slow 指针会指向中间结点\n    while (fast !== null && fast.next !== null) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    return slow;\n};","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/31#issuecomment-2565423669","body":"思路：\n1、建图：将不喜欢的关系构建为图的边。\n2、染色法判定二分图：使用 BFS 或 DFS 遍历图，尝试对节点进行染色，确保相邻节点颜色不同。\n如果在染色过程中发现相邻节点颜色相同，则图不是二分图。\n如果所有节点都能成功染色，则图是二分图。\n复杂度：\nO(n)\n代码：\nvar possibleBipartition = function(n, dislikes) {\n      // 建图\n    var graph = new Array(n + 1).fill(0).map(() => []);\n    for (const [a, b] of dislikes) {\n        graph[a].push(b);\n        graph[b].push(a);\n    }\n\n    // 染色数组，0表示未染色，1和-1表示两种不同的组\n    const color = new Array(n + 1).fill(0);\n\n    // BFS判断二分图\n    const bfs = (start) => {\n        const queue = [start];\n        color[start] = 1; // 初始颜色为1\n\n        while (queue.length) {\n            const node = queue.shift();\n            for (const neighbor of graph[node]) {\n                if (color[neighbor] === color[node]) {\n                    return false; // 相邻节点颜色相同，不是二分图\n                }\n                if (color[neighbor] === 0) {\n                    color[neighbor] = -color[node];\n                    queue.push(neighbor);\n                }\n            }\n        }\n        return true;\n    };\n\n    // 遍历所有节点，进行BFS\n    for (let i = 1; i <= n; i++) {\n        if (color[i] === 0 && !bfs(i)) {\n            return false;\n        }\n    }\n\n    return true;\n};","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/38#issuecomment-2572930522","body":"一、思路：\n边界条件：如果 x 是 0 或 1，直接返回 x，因为 0 和 1 的平方根就是它们自己。\n二分查找：使用二分查找来逼近平方根。平方根的范围是 [2, x/2]。\n计算中间值：在每次循环中，计算中间值 pivot，并检查 pivot * pivot 与 x 的关系。\n如果 pivot * pivot > x，说明平方根在 pivot 的左侧，因此将 right 更新为 pivot - 1。\n如果 pivot * pivot < x，说明平方根在 pivot 的右侧，因此将 left 更新为 pivot + 1。\n如果 pivot * pivot == x，直接返回 pivot。\n\n二、复杂度：\nO(log n)\n三、代码：\nvar mySqrt = function(x) {\n    if (x < 2) return x; // 如果 x 是 0 或 1，直接返回 x\n\n    let left = 2;\n    let right = Math.floor(x / 2); // 平方根不会超过 x/2\n    let pivot;\n\n    while (left <= right) {\n        pivot = Math.floor((left + right) / 2);\n        let num = pivot * pivot;\n\n        if (num > x) {\n            right = pivot - 1;\n        } else if (num < x) {\n            left = pivot + 1;\n        } else {\n            return pivot;\n        }\n    }\n\n    // 当 left > right 时，right 是小于等于 sqrt(x) 的最大整数\n    return right;\n};","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/43#issuecomment-2585280106","body":"一、思路\n1、MinHeap类：实现了一个最小堆，用于优先选择时间最小的节点进行扩展。\n2、swimInWater函数：\n      初始化一个时间矩阵times，记录从起点到每个点的最短时间。\n      使用最小堆来管理待访问的节点，初始时将起点加入堆中。\n      在每次循环中，弹出堆中时间最小的节点，更新其邻接点的时间，并将邻接点加入堆中。\n      当到达终点时，返回该点的时间值。\n二、复杂度\nO(n)\n三、代码\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar swimInWater = function(grid) {\n     const N = grid.length;\n  const directions = [[0,1], [1,0], [0,-1], [-1,0]];\n  const times = new Array(N).fill(0).map(() => new Array(N).fill(Infinity));\n  times[0][0] = grid[0][0];\n\n  const heap = new MinHeap();\n  heap.push({ x: 0, y: 0, time: grid[0][0] });\n\n  while (heap.heap.length > 0) {\n    const { x, y, time } = heap.pop();\n    if (x === N - 1 && y === N - 1) {\n      return time;\n    }\n    for (const [dx, dy] of directions) {\n      const nx = x + dx;\n      const ny = y + dy;\n      if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n        const maxTime = Math.max(time, grid[nx][ny]);\n        if (maxTime < times[nx][ny]) {\n          times[nx][ny] = maxTime;\n          heap.push({ x: nx, y: ny, time: maxTime });\n        }\n      }\n    }\n  }\n  return -1;\n};\n\nclass MinHeap {\n  constructor() {\n    this.heap = [];\n  }\n\n  getParentIndex(i) {\n    return Math.floor((i - 1) / 2);\n  }\n\n  getLeftChildIndex(i) {\n    return 2 * i + 1;\n  }\n\n  getRightChildIndex(i) {\n    return 2 * i + 2;\n  }\n\n  swap(i, j) {\n    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];\n  }\n\n  push(node) {\n    this.heap.push(node);\n    let index = this.heap.length - 1;\n    let parent = this.getParentIndex(index);\n    while (index > 0 && this.heap[parent].time > this.heap[index].time) {\n      this.swap(parent, index);\n      index = parent;\n      parent = this.getParentIndex(index);\n    }\n  }\n\n  pop() {\n    const min = this.heap[0];\n    this.heap[0] = this.heap.pop();\n    this.heapify(0);\n    return min;\n  }\n\n  heapify(i) {\n    const left = this.getLeftChildIndex(i);\n    const right = this.getRightChildIndex(i);\n    let smallest = i;\n    if (left < this.heap.length && this.heap[left].time < this.heap[smallest].time) {\n      smallest = left;\n    }\n    if (right < this.heap.length && this.heap[right].time < this.heap[smallest].time) {\n      smallest = right;\n    }\n    if (smallest !== i) {\n      this.swap(i, smallest);\n      this.heapify(smallest);\n    }\n  }\n}","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/50#issuecomment-2599566079","body":"思路：\nisSafe 函数：用于检查在当前行和列放置皇后是否会与已有的皇后冲突。\n\n检查同一列是否有皇后。\n检查左上对角线和右上对角线是否有皇后。\nbacktrack 函数：递归地尝试在每一行的每一列放置皇后，并在放置后递归到下一行。如果找到一个有效的解决方案（即放置了 N 个皇后），则增加解决方案计数。\n\n初始化棋盘：使用二维数组表示棋盘，初始时所有位置都为空（用 ‘.’ 表示）。\n\n主逻辑：从第 0 行开始回溯，尝试在每一列放置皇后。\n复杂度：为 O(N!)\n代码：\nvar totalNQueens = function(n) {\n     let count = 0;\n\n    // 检查当前位置是否可以放置皇后\n    function isSafe(board, row, col) {\n        // 检查列\n        for (let i = 0; i < row; i++) {\n            if (board[i][col] === 'Q') return false;\n        }\n\n        // 检查左上对角线\n        for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n            if (board[i][j] === 'Q') return false;\n        }\n\n        // 检查右上对角线\n        for (let i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\n            if (board[i][j] === 'Q') return false;\n        }\n\n        return true;\n    }\n\n    // 回溯函数\n    function backtrack(board, row) {\n        if (row === n) {\n            count++;\n            return;\n        }\n\n        for (let col = 0; col < n; col++) {\n            if (isSafe(board, row, col)) {\n                board[row][col] = 'Q';  // 放置皇后\n                backtrack(board, row + 1);  // 递归到下一行\n                board[row][col] = '.';  // 回溯，撤销放置\n            }\n        }\n    }\n\n    // 初始化棋盘\n    let board = Array.from({ length: n }, () => Array(n).fill('.'));\n\n    // 从第0行开始回溯\n    backtrack(board, 0);\n\n    return count;\n};","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/55#issuecomment-2609653939","body":"思路：\n初始化：我们可以选择从下标为 0 或 1 的元素作为初始阶梯，因此 dp[0] 和 dp[1] 的初始值分别为 cost[0] 和 cost[1]。\n状态转移方程：对于每个阶梯 i，我们可以从 i-1 或 i-2 到达 i，因此 dp[i] 可以通过以下公式计算：dp[i]=cost[i]+min(dp[i−1],dp[i−2])\n最终结果：最后我们需要比较 dp[n-1] 和 dp[n-2]，因为到达顶层可以从倒数第一个或倒数第二个阶梯直接跳上去。\n复杂度：\n时间复杂度：O(n)，其中 n 是数组 cost 的长度。我们只需要遍历一次数组。\n空间复杂度：O(n)，因为我们使用了额外的 dp 数组来存储中间结果。如果不希望使用额外的空间，可以通过两个变量来优化空间复杂度为 O(1)。\n代码：\n/**\n * @param {number[]} cost\n * @return {number}\n */\nvar minCostClimbingStairs = function(cost) {\n     const n = cost.length;\n\n  // 初始化 dp 数组\n  const dp = new Array(n + 1).fill(0);\n\n  // 动态规划计算\n  for (let i = 2; i <= n; i++) {\n    dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n  }\n\n  // 返回到达顶部的最低花费\n  return dp[n];\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shellylcooper":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"testplm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tom-zhouch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"skylarxu214":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taihui":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huaxueguakele":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yang-chenyu104":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mlking15":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"-3":[],"cyonline":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rzhao010":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zywang0":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jetery":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"klspta":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bookyue":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jancerwu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"buer1121":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ceramickitten":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gg925407590":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alyenor":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenming-cao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ggohem":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dark-volute":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ronething":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jmastella":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"paopaohua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dd2001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mayloveless":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuexi001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nineis7":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"abby-xu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gsw9818":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaomingshixiaotang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"snmyj":[{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/2#issuecomment-2509841099","body":"```c\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n    vector<int> kk;\n    vector<int> ans ;\n    while ( k > 0 ) {\n         kk.push_back( k % 10 ) ;\n         k /= 10 ;\n    }\n    int add;\n    reverse ( num.begin(), num.end() );\n    for ( int i = 0; i < min ( num.size(), kk.size()); i++) {\n        add = ( num[i] + kk[i] ) / 10;\n\n\n        ans.push_back (( num[i] + kk[i] ) % 10) ;\n    }\n    if ( num.size() >= min (num.size(), kk.size())) {\n        for ( int i = min(num.size() , kk.size()) ;i < num.size(); i++ ) {\n            add += num[i];\n            ans.push_back ( add % 10);\n            add /= 10 ;\n        }\n    }\n    else {\n         for ( int i = min(num.size() ,kk.size());i < kk.size(); i++ ) {\n            add += kk[i];\n            ans.push_back ( add % 10);\n            add /= 10 ;\n        }\n    }\n    reverse ( ans.begin(), ans.end() );\n    return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/3#issuecomment-2511778801","body":"```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> dis ;\n        int len = s.length();\n        for ( int i = 0; i < len ; i++ ) {\n            int p = i, q = i;\n            while ( p >= 0 || q < len ) {\n                if ( p >= 0 && s[p] == c) {dis.push_back(abs( p - i ));break;}\n                if ( q < len && s[q] == c) {dis.push_back(abs( q - i ));break;}\n                p--;\n                q++;\n\n            }\n        } \n        return dis ;  \n    }\n    \n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flipn9":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wabw1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqmmy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a-pricity":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sclihuiming":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"amazeding":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"astrking":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tzuikuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ringo1597":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brucezhang-utf-8":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luanxing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moin-jer":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lihua1997":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cuizezhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xuanaxuan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tiandao043":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"restlessbreeze":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ruikiwi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huiminren":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"saitochen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wtdcai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"albert556":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wuxiaoshawn":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zrtch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhuzhu096":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whoam-challenge":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weisday":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"syh-coder":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaaller":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kyrie96521":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cavecrypto":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cxgbro":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erjian96":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a-polarbear":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alexno1no2":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yetfan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhiyuanpeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bwspsu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"arinzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mdge":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"allenfeng666":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yin02":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elsa-zhang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asur4s":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"littlesugarman":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhihaowan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"apockira":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guowei0223":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shuqianyang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sj941127":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zjsuper":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yongxi-zhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"darwintk":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/5#issuecomment-2517764709","body":"方法：\n使用辅助栈，和两个临时变量：乘数multi，临时结果res，遍历字符串：\n- 当前字符为数字时，让其作为乘数multi的一部分\n- 当前字符为字母时，让其作为临时结果res的一部分\n- 在进入 \"[\" 时，将当前的乘数multi、临时结果res，存入辅助栈中，并将乘数和临时结果重新初始化；\n- 在离开 \"]\" 时，将辅助栈中的乘数pre_multi和前临时结果pre_res取出，让当前临时结果重复pre_multi，加在前临时结果的后方\n\n代码：\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        multi = 0\n        res=\"\"\n        for char in s:\n            if char.isdigit():\n                multi = multi * 10 + int(char)\n            elif char.isalpha():\n                res += char\n            elif char==\"[\":\n                stack.append([res,multi])\n                res = \"\"\n                multi = 0\n            elif char==\"]\":\n                pre_res, pre_multi = stack.pop()\n                res = pre_res+pre_multi*res\n        return res\n```\ns长度为N\n时间复杂度：O(N)\n空间复杂度：O(N) 或当s包含多个\"[\", \"]\" 时，需要线性空间","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/10#issuecomment-2528446696","body":"### 方法1\n对于链表，递归使用快慢指针，找到链表的中位数，生成树\n1. 使用快慢指针，快指针走两步，慢指针走一步；\n2. 当快指针为None，或者下一个为None时，慢指针的位置即为当前链表的中位数；\n3. 根据当前找到的中位，将链表分为左右两个链表，从当前中位开始构建树的根节点，同时分别对左右两个链表找中位，生成根节点的左右叶子节点；\n4. 递归运行步骤1~3，直到链表无法再区分左右，逐步返回；\n算法复杂度：\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(logn)\n\n```python\nclass Solution:\n    def findMid(self, left, right):\n        # 使用快慢指针找到链表中位数\n        fast = slow = left\n        while fast != right and fast.next != right:\n            fast = fast.next.next # 快指针走两步\n            slow = slow.next # 慢指针走一步\n        return slow\n\n    def buildTree(self, left, right):\n        if left==right:\n            return None\n        # 在链表中找中位数\n        mid = self.findMid(left,right)\n        root = TreeNode(mid.val)\n        root.left = self.buildTree(left,mid)\n        root.right = self.buildTree(mid.next,right)\n        return root\n\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        return self.buildTree(head,None)\n```\n\n### 方法2\n跟方法1一样递归生成树，但找中点的方法有所不同\n1. 方法2遍历一次链表，将链表存入一个列表arr中，再根据列表的长度，获取当前中点，作为根节点\n2. 将arr按中点分为左右两个列表，再分别找中点，以此类推进行递归\n算法复杂度：\n- 时间复杂度：O(n) \n- 空间复杂度：O(logn)\n\n```python\nclass Solution:\n    def buildTree(self, arr):\n        if len(arr)==0:\n            return None\n\n        mid = len(arr)//2\n        root = TreeNode(val=arr[mid])\n        root.left = self.buildTree(arr[:mid])\n        root.right = self.buildTree(arr[mid+1:])\n        return root\n\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if head is None:\n            return None\n        arr = []\n        while head is not None:\n            arr.append(head.val)\n            head = head.next\n        result = self.buildTree(arr)\n        return result\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/17#issuecomment-2545988012","body":"## 513 找树左下角的值\n### 方法：深度优先搜索\n搜索树的所有叶子节点，记录当前所在节点的深度，先查找左叶子节点，再寻找右叶子节点，\n当进入到一个更深的深度，更新当前最深的左下角值，直到没有叶子节点\n\n```python \n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def __init__(self):\n        self.cur_height = 0\n        self.result = 0\n\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        self.dfs(root, 0)\n        return self.result\n\n    def dfs(self, root: Optional[TreeNode], height: int):\n        if root is None:\n            return\n        height += 1\n        self.dfs(root.left,height)\n        self.dfs(root.right,height)\n        if height > self.cur_height:\n            self.cur_height = height\n            self.result = root.val\n```\n算法复杂度：\n时间复杂度：O(n)，其中 n 是二叉树的节点数目。需要遍历 n 个节点\n\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/24#issuecomment-2559921624","body":"### 方法\n由于单词的长度和所有单词拼接后的长度都是固定的，\n因此可以使用一个哈希表存储所有单词，并使用滑动窗口法来检查是否存在符合要求的部分；\n设单个单词的长度为x，有n个单词，则该组单词拼接后的长度为n*x\n从字符的头部开始使用滑动窗口，窗口长度为n*x，如果当前窗口的哈希表与初始哈希表一致，则记录当前窗口头部的位置；\n每检查完一次，窗口就向右滑动，再次检查，直至字符结束\n\n```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        from collections import Counter\n        if not s or not words:return []\n        word_len = len(words[0])\n        all_words_len = len(words) * word_len\n        n = len(s)\n        words_counter = Counter(words)\n        res = []\n        for i in range(0, n - all_words_len + 1):\n            tmp = s[i:i+all_words_len]\n            c_tmp = []\n            for j in range(0, all_words_len, word_len):\n                c_tmp.append(tmp[j:j+word_len])\n            if Counter(c_tmp) == words_counter:\n                res.append(i)\n        return res\n```\n假设字符长度为N，一组单词数量m\n- 时间复杂度： O(N)\n- 空间复杂度： O(m)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/31#issuecomment-2565647123","body":"使用并查集的方法\n```python\n\nclass Solution:\n    def possibleBipartition(self, n: int, ds: List[List[int]]) -> bool:\n        p = [i for i in range(0, 2 * n + 10)]\n        def find(x):\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n        def union(a, b):\n            p[find(a)] = p[find(b)]\n        def query(a, b):\n            return find(a) == find(b)\n        for info in ds:\n            a, b = info[0], info[1]\n            if query(a, b):\n                return False\n            else:\n                union(a, b + n)\n                union(b, a + n)\n        return True\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/38#issuecomment-2573400580","body":"### 方法\n使用二分法，从[0,x]中间开始找，如果当前中间数平方<=x，则更新搜索区间为[中间数,x],否则为[0,中间数]，以此类推，最终左侧边界为结果\n```python\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        if x in [0,1]:\n            return x\n        left = 0\n        right = x\n        while left+1<right:\n            m = (left+right)//2\n            if m*m<=x:\n                left=m\n            else:\n                right=m\n        return left\n```\n算法复杂度\n- 时间复杂度 O(logn)\n- 空间复杂度 O(1)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/45#issuecomment-2587461303","body":"方法：动态规划\n```python\nclass Solution:\n    def new21Game(self, n: int, k: int, maxPts: int) -> float:\n        if k == 0:\n            return 1.0\n        dp = [0.0] * (k + maxPts)\n        for i in range(k, min(n, k + maxPts - 1) + 1):\n            dp[i] = 1.0\n        dp[k - 1] = float(min(n - k + 1, maxPts)) / maxPts\n        for i in range(k - 2, -1, -1):\n            dp[i] = dp[i + 1] - (dp[i + maxPts + 1] - dp[i + 1]) / maxPts\n        return dp[0]\n```\n时间复杂度：O(min(n,k+maxPts))\n空间复杂度：O(k+maxPts)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/52#issuecomment-2602722954","body":"```python\nclass Solution:\n    def maxDistance(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        queue = collections.deque([(i, j) for i in range(n) for j in range(n) if grid[i][j]])\n        if len(queue) == 0 or len(queue) == n * n:\n            return -1\n\n        distance = -1\n        while queue:\n            distance += 1\n            for _ in range(len(queue)):\n                x, y = queue.popleft()\n                for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < n and 0 <= ny < n and not grid[nx][ny]:\n                        grid[nx][ny] = 1\n                        queue.append((nx, ny))\n        return distance\n```\n时间复杂度：O(n^2)\n空间复杂度：O(n^2)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"h-steven":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mischaqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wurongronga":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miduoliu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyshenzhengkang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"y4h2":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yoco323":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"forschers":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shanshuiqiankun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"annabellhyx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hwfrankfung":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"frederickfan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huibinny":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ggmybro":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"myleetcodejourney":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"want2333":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"staringwhere":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"allenfeng8":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ryanbaiyansong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dou-yu-xuan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyxupup":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cs12300":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chiehw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aesir-idun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaldsk12":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hxj2001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"for123s":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzhilin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yfu6":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mengsixing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"import-ant":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joriscai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangqianqian202301":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"airwalkers":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhumengcheng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kofzhang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leonalhq":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hjy-u":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"csthaha":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zepherust":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"feefeefee":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hughlin07":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huizsh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chanceyliu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hshen11":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"horace7":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangzh0114":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dragonfcl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huifeng248":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sarah11qing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"el1as7":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zcytm3000":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pangjiadai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xb798298436":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ywang525":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"limbo42":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dorapocket":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zoeyzyzyzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jasonqiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lp1506947671":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"texamc2":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joemonkeylee":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"northseacoder":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dominique9898":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wl678":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"meisgithub":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sye9286":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fuku-l":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kangliqi1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richardtaok":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chocolate-emperor":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lydia61":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangjiahuan17":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"seanutf":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangyong-hub":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erquaner":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiujingxukong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"x1aox1a":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"drinkmorekaik":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dinjufen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuzmt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"munmust":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yan-jie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hktangshuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zpbc007":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linlizzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"krabbejing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"firehaosky":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chao-cc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jinjin680":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cruiseyugh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"quieter2018":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jadeliu13":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaoq777":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiangyanlineu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuxiner":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yufanzh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"franciszq":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kangqinsen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"manwzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jerry9926":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"soso1105":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pkuphy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhenya-zhu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wty9sky":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"skyoct":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bingzxy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaodingc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jyjsunny":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aoxiangw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"enrilwang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aswrise":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aneureka":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ljqchlsw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jingyuzhou123":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dianlandu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jameswangxin":[{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/2#issuecomment-2509792692","body":"思路：\n   因为数组位数可能很长，所以模拟两数相加算法。最后需要处理好算法的运行边界\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ori = Arrays.stream(num).boxed().collect(Collectors.toList());\n        Collections.reverse(ori);\n        List<Integer> ans = new ArrayList<>();\n        int remain = k;\n        for (int i = 0; i < ori.size(); i++) {\n            remain = remain + ori.get(i);\n            ans.add(remain%10);\n            remain /= 10;\n        }\n        while (remain > 0) {\n            ans.add(remain%10);\n            remain /= 10;\n        }\n        Collections.reverse(ans);\n        return ans;\n    }\n}\n``` \n**时间复杂度**: O(N)\n**空间复杂度**: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/3#issuecomment-2511910390","body":"**思路**： 有点参考前缀思想，统计前缀和后缀中相等的字符出现的位置\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] pre = new int[len];\r\n        int[] suf = new int[len];\r\n        pre[0] = (s.charAt(0) == c ? 0 : Integer.MAX_VALUE);\r\n        for (int i = 1; i < len; i++) {\r\n            if (s.charAt(i) == c) {\r\n                pre[i] = i;\r\n            } else {\r\n                pre[i] = pre[i-1];\r\n            }\r\n        }\r\n\r\n        suf[len-1] = (s.charAt(len-1) == c ? len-1 : Integer.MAX_VALUE);\r\n        for (int i = len - 2; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                suf[i] = i;\r\n            } else {\r\n                suf[i] = suf[i+1];\r\n            }\r\n        }\r\n\r\n        int[] ans = new int[len];\r\n        for (int i = 0; i < len; i++) {\r\n            ans[i] = Math.min(Math.abs(i-pre[i]), Math.abs(i-suf[i]));\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n**时间复杂度**: O(N) \r\n**空间复杂度**: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/4#issuecomment-2514554434","body":"```java\nclass CustomStack {\n    private Deque<Integer> de = new LinkedList<>();\n    AtomicInteger el = new AtomicInteger(0);\n    private int sz = 0;\n    public CustomStack(int maxSize) {\n        sz = maxSize;\n    }\n    \n    public void push(int x) {\n        if (el.get() < sz) {\n            de.offerLast(x);\n            el.incrementAndGet();\n        }\n    }\n    \n    public int pop() {\n        if (el.get() > 0) {\n            el.decrementAndGet();\n            return de.pollLast();\n        } \n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        int pops = Math.min(k, el.get());\n        Deque<Integer> temp = new LinkedList<>();\n        for (int i = 0; i < pops; i++) {\n            int newValue = de.pollFirst() + val;\n            temp.offerLast(newValue);\n        }\n\n        while (temp.size() > 0) {\n            int tmpVal = temp.pollLast();\n            de.offerFirst(tmpVal);\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/5#issuecomment-2517851521","body":"```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n        int now = 0;\n        return dfs(s, now);\n    }\n    string dfs(string& s, int& now) {\n        string res = \"\";\n        while (now < s.size() && s[now] != ']') {\n            if ('A' <= s[now] && s[now] <= 'Z' || 'a' <= s[now] && s[now] <= 'z')  res += s[now++];\n            else if ('0' <= s[now] && s[now] <= '9') {\n                int i = now, num = 0;\n                while (i < s.size() && s[i] != '[') {\n                    num = num * 10 + s[i] - '0';\n                    i++;\n                }\n                now = i + 1;\n                string temp = dfs(s, now);\n                while (num--) res += temp;\n                now++;\n            }\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/6#issuecomment-2520454916","body":"```java\nclass MyQueue {\n    Deque<Integer> deque = null;\n    public MyQueue() {\n        deque = new ArrayDeque<>();\n    }\n    \n    public void push(int x) {\n        deque.offerLast(x);\n    }\n    \n    public int pop() {\n        return deque.pollFirst();\n    }\n    \n    public int peek() {\n        return deque.peekFirst();\n    }\n    \n    public boolean empty() {\n        return !(deque.size() > 0);\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/8#issuecomment-2525212078","body":"```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || k == 0) {\n            return head;\n        }\n        ListNode p = new ListNode();\n        p = head; \n        int tot = 1;\n        //找到链表中最后一个节点\n        while (p.next != null) {\n            p = p.next;\n            tot++;\n        }\n        // 有可能k的大小超过数组的长度\n        k %= tot;\n        ListNode w = new ListNode();\n        w = head; \n        // 计算要走到哪个节点位置上 \n        for (int i = 0; i < tot - k - 1; i++) {\n            w = w.next;\n        }\n        p.next = head;\n        head = w.next;\n        w.next = null;\n        return head;\n    }\n}\n```\n**时间复杂度: O(N)**\n**空间复杂度: O(1)**","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/9#issuecomment-2526193304","body":"```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null) return head;\n        ListNode dummy = new ListNode();\n        ListNode p = new ListNode();\n        ListNode q = new ListNode();\n        ListNode w = new ListNode();\n        p = head;\n        q = head.next;\n        dummy.next = head;\n        w = dummy;\n        while (p != null && q != null) {\n            w.next = q;\n            p.next = q.next;\n            q.next = p;\n            w = p;\n            p = p.next;\n            if (p != null) {\n                q = p.next;\n            }\n        } \n        return dummy.next;\n    }\n} \n**时间复杂度** : O(N) \n**空间复杂度**: O(1)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/10#issuecomment-2528407011","body":"```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        return dfs(head);\n    }\n    TreeNode* dfs(ListNode* head) {\n        if (!head) return NULL;\n        if (!head->next) {\n            return new TreeNode(head->val);\n        }\n        ListNode* pre = NULL, *p = head, *q = head;\n        while (q && q->next) {\n            q = q->next->next;\n            pre = p;\n            p = p->next;\n        }\n        pre->next = NULL;\n        TreeNode* root = new TreeNode(p->val);\n        root->left = dfs(head);\n        root->right = dfs(p->next);\n        return root;\n    }\n};\n```\n**时间复杂度:** O(NlgN)\n**空间复杂度**  O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/11#issuecomment-2532137906","body":"```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p = headB;\n        ListNode q = headA;\n        while (headA != headB) {\n            if (headA == null) {\n                headA = p;\n                continue;\n            }\n            if (headB == null) {\n                headB = q;\n                continue;\n            }\n        \n            headA = headA.next;\n            headB = headB.next;\n        }\n        return headA;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/12#issuecomment-2536372423","body":"```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if (!head || !head->next) return NULL;\n        auto p = head, q = head->next;\n        while (q) {\n            p = p->next;\n            q = q->next;\n            if (!q) return NULL;\n            q = q->next;\n            if (p == q) {\n                p = head, q = q->next;\n                while (p != q) {\n                    p = p->next;\n                    q = q->next;\n                }\n                // cout<< p->val << endl;\n                return p;\n            }\n        }\n        return NULL;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/14#issuecomment-2540328808","body":"```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode() {}\n * TreeNode(int val) { this.val = val; }\n * TreeNode(int val, TreeNode left, TreeNode right) {\n * this.val = val;\n * this.left = left;\n * this.right = right;\n * }\n * }\n */\nclass Solution {\n    private int ans = 0;\n    private int deepth = 1;\n\n    public int maxDepth(TreeNode root) {\n        deepth -= 1;\n        return dfs(root, deepth);\n    }\n\n    int dfs(TreeNode root, int deepth) {\n        if (root == null) {\n            return Math.max(ans, deepth);\n        }\n        return Math.max(dfs(root.left, deepth + 1), dfs(root.right, deepth + 1));\n    }\n}\n```\n**时间复杂度**： O(N) \n**空间复杂度**： O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/15#issuecomment-2543002937","body":"```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if ((p == null && q != null)\n            || (p != null && q == null)) {\n            return false;\n        }\n        if (p != null && q != null) {\n            if (p.val != q.val) {\n                return false;\n            } \n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n        }\n        return true;\n    }\n}\n```\n**时间复杂度**: O(N)\n**空间复杂度**: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/16#issuecomment-2543507693","body":"```java\nclass Solution {\n    private int sum = 0;\n    public int sumNumbers(TreeNode root) {\n        dfs(root, 0);\n        return sum;\n    }\n\n    public void dfs(TreeNode root, int pathSum) {\n        if (root == null) {\n            return;\n        }\n        pathSum = pathSum * 10 + root.val;\n        dfs(root.left, pathSum);\n        dfs(root.right, pathSum);\n        if (root.left == null && root.right == null) {\n            sum += pathSum;\n        }\n    }\n}\n``` \n**时间复杂度: O(N)**\n**空间复杂度: O(N)** ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/17#issuecomment-2544757735","body":"思路： 每次先搜左子树，再搜右子树，这样就可以保证搜到的节点一定是整颗树中最左边的节点。为什么正确 具体就可以尝试反证法进行证明 :)\n```java\nclass Solution {\n    private int maxDepth = 0;\n    private int ans = 0;\n    public int findBottomLeftValue(TreeNode root) {\n        dfs(root, 1);\n        return ans;\n    }\n\n    public void dfs(TreeNode root, int depth) {\n        if (root == null) {\n            return;\n        }\n        if (depth > maxDepth) {\n            maxDepth = depth;\n            ans = root.val;\n        }\n        dfs(root.left, depth + 1);\n        dfs(root.right, depth + 1);\n    }\n}\n```\n**时间复杂度:O(N)** ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/19#issuecomment-2551297607","body":"```cpp\nclass Solution {\npublic:\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        vector<tuple<int, int, int>> nodes;\n\n        function<void(TreeNode*, int, int)> dfs = [&](TreeNode* node, int row, int col) {\n            if (!node) {\n                return;\n            }\n            nodes.emplace_back(col, row, node->val);\n            dfs(node->left, row + 1, col - 1);\n            dfs(node->right, row + 1, col + 1);\n        };\n\n        dfs(root, 0, 0);\n        sort(nodes.begin(), nodes.end());\n        vector<vector<int>> ans;\n        int lastcol = INT_MIN;\n        for (const auto& [col, row, value]: nodes) {\n            if (col != lastcol) {\n                lastcol = col;\n                ans.emplace_back();\n            }\n            ans.back().push_back(value);\n        }\n        return ans;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/20#issuecomment-2554763350","body":"```java\n  class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>(1<<16);\n        int[] res = new int[2]; \n        for (int i = 0; i < nums.length; i++) {\n            if (map.containsKey(target-nums[i])) {\n                res[0] = map.get(target-nums[i]);\n                res[1] = i;\n                break;\n            }\n            map.put(nums[i], i);\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/21#issuecomment-2557238652","body":"```cpp\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int, int> cnt;\n        for (int val : nums) cnt[val]++;\n        int n = nums.size();\n        vector<int> ss(n+1);\n        for (auto it = cnt.begin(); it != cnt.end(); it++) {\n            ss[it->second]++;\n        }\n        int index = n;\n        while (k > 0) {\n            k -= ss[index--];\n        }\n        vector<int> ans;\n        for (auto it = cnt.begin(); it != cnt.end(); it++) {\n            if (it->second > index) {\n                ans.push_back(it->first);\n            }\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/22#issuecomment-2558144369","body":"```cpp\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& p) {\n        int ans = 0;\n        for (int i = 0; i < p.size(); i++) {\n            unordered_map<int, int> mp;\n            for (int j = 0; j < p.size(); j++) {\n                if (i != j) {\n                    int dis = (p[i][0] - p[j][0]) * (p[i][0] - p[j][0]) + (p[i][1] - p[j][1]) * (p[i][1] - p[j][1]);\n                    mp[dis]++;\n                }\n            }\n            for (auto it = mp.begin(); it != mp.end(); it++) {\n                ans = ans + it->second * (it->second-1);\n            }\n        }\n        return ans;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/24#issuecomment-2559839026","body":"```cpp\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        vector<int> ans;\n        if (words.empty()) return ans;\n        int n = s.size(), m = words.size(), sz = words[0].size();\n        unordered_map<string, int> w_map;\n        for (string element : words) w_map[element] ++; \n       \n        for (int i = 0; i < sz; i++) { \n            unordered_map<string, int> s_map;\n            int cnt = 0; //有效单词的数量\n            for (int j = i; j + sz <= n; j += sz) {\n               if (j >= i + m * sz) {\n                   auto str = s.substr(j - m * sz, sz);\n                   s_map[str] --;\n                   if (s_map[str] < w_map[str]) cnt--;\n               }\n                auto new_str = s.substr(j, sz);\n                s_map[new_str] ++;\n                if (s_map[new_str] <= w_map[new_str]) cnt++;\n                if (cnt == m) ans.push_back(j - sz * (m-1));\n            }\n        }\n        return ans;\n    }\n};\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/25#issuecomment-2561207230","body":"```cpp\nclass Solution {\npublic:\n    int minSubarray(vector<int>& nums, int p) {\n        int n = nums.size();\n        vector<int> s(n + 1);\n        for (int i = 1; i <= n; i++) s[i] = (s[i - 1] + nums[i - 1]) % p;  \n        int sum = s[n];\n        if (sum == 0) return 0;\n\n        unordered_map<int, int> last;\n        last[0] = 0;\n        int res = n;\n        for (int i = 1; i <= n; i++) {\n            int mod = (s[i] - sum + p) % p; \n            if (last.count(mod)) res = min(res, i - last[mod]);\n            last[s[i]] = i; \n        } \n        return res == n ? -1 : res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/26#issuecomment-2561907242","body":"```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        auto p = head, q = head;\n        while (q && q->next) {\n            q = q->next;\n            p = p->next;\n            if (q) q = q->next;\n        }\n        //cout << p->val << endl;\n        return p;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/27#issuecomment-2562338720","body":"```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int l, r;\n        for (l = 0, r = 1;  r < nums.length && l <= r; ) {\n            while (r < nums.length && nums[l] == nums[r]) r++;\n            if (r >= nums.length) {\n                break;\n            }\n            nums[++l] = nums[r];\n        }\n        return l+1;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/28#issuecomment-2563823963","body":"```cpp\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l = 0, r = nums.size(), ans = nums.size(); //[a, b]\n        while (l < r) {\n            int mid = (l + r) >> 1;\n            if (nums[mid] == target) {\n                ans = mid;\n                break;\n            }\n            else if (nums[mid] > target) r = mid;\n            else l = mid + 1;\n        }\n        return l == r ? l : ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/29#issuecomment-2564333752","body":"```cpp\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        deque<int> q;\n        vector<int> res;\n        for (int i = 0; i < nums.size(); i ++ ) {\n            if (q.size() && i - k + 1 > q.front()) q.pop_front();\n            while (q.size() && nums[i] >= nums[q.back()]) q.pop_back();\n            q.push_back(i);\n            if (i >= k - 1) res.push_back(nums[q.front()]);\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/30#issuecomment-2564729003","body":"```java\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[] in = new int[n+1];\n        int[] out = new int[n+1];\n        for (int i = 0; i < trust.length; i++) {\n            in[trust[i][1]]++;\n            out[trust[i][0]]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            if (out[i] == 0 && in[i] == n-1) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/33#issuecomment-2566817197","body":"```java\nclass Solution {\n    public boolean judgeCircle(String moves) {\n        int l = 0, r = 0, u = 0, d = 0;\n        for (int i = 0; i < moves.length(); i++) {\n            char ch = moves.charAt(i);\n            if (ch == 'L') l++;\n            else if (ch == 'R') r++;\n            else if (ch == 'U') u++;\n            else if (ch == 'D') d++;\n        }\n        return l == r && u == d ? true : false;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/35#issuecomment-2569430240","body":"```java\nclass Solution {\n    public int numberOfRounds(String loginTime, String logoutTime) {\n        int t0 = 60*Integer.valueOf(loginTime.substring(0,2)) + Integer.valueOf(loginTime.substring(3,5));\n        int t1 = 60*Integer.valueOf(logoutTime.substring(0,2))+ Integer.valueOf(logoutTime.substring(3,5));\n        if(t1 < t0){\n            t1 = t1 + 1440;\n        }\n        t0 = (t0+14)/15;\n        t1 = t1/15;\n        return Math.max(t1-t0,0); \n    }\n}\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/37#issuecomment-2571663252","body":"```java\nclass Solution {\n\n    public int[] sortArray(int[] nums) {        \n        int n = nums.length;\n        quickSort(nums, 0, n - 1);\n        return nums;\n    }\n\n     private void quickSort(int[] a, int l, int r){\n        if (l >= r) return;\n\n        int t = a[(l + r) >>> 1];\n        int i = l - 1;\n        int j = r + 1;\n        while (i < j){\n            while (a[++i] < t);\n            while (a[--j] > t);\n            if (i < j) {\n                int tmp = a[i];\n                a[i] = a[j];\n                a[j] = tmp;\n            }\n        }\n        quickSort(a, l, j);\n        quickSort(a, j + 1, r);\n     }\n\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/38#issuecomment-2573387935","body":"```cpp\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        long long l = 0, r = 1LL * x + 1;\n        while (l < r) {\n            long long mid = (l + r + 1) >> 1;\n            if (1LL * mid * mid <= 1LL * x) {\n                l = mid;\n            } else {\n                r = mid - 1;\n            }\n        }\n        return l;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/39#issuecomment-2575500184","body":"```cpp\n// The API isBadVersion is defined for you.\n// bool isBadVersion(int version);\n\nclass Solution {\npublic:\n    int firstBadVersion(int n) {\n        int l = 1, r = n;\n        while (l < r) {\n            int mid = (1LL*l+1LL*r) >> 1;\n            if (!isBadVersion(mid)) {\n                l = mid+1;\n            } else {\n                r = mid;\n            }\n        }\n        return r;\n    }\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/45#issuecomment-2587503585","body":"```cpp\ndouble dp[20010];\nclass Solution {\npublic:\n    double new21Game(int n, int k, int maxPts) {\n        if (!k) return 1;\n        memset(dp, 0, sizeof dp);\n        for (int i = k; i <= n && i < k + maxPts; i++) dp[i] = 1;\n        dp[k-1] = 0;\n        for (int i = 1; i<= maxPts; i++) dp[k-1] += dp[k-1+i] / (double)maxPts;\n        for (int i = k - 2; i >= 0; i--) {\n            dp[i] = dp[i+1] + (dp[i+1] - dp[i+maxPts+1]) / (double)maxPts;\n        }\n        return dp[0];\n    }\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/48#issuecomment-2595909720","body":"```java\nclass Solution {\n    public int maxScore(int[] cardPoints, int k) {\n       int n = cardPoints.length, totalSum = 0;\n       for (int i = 0; i < n-k; i++) {\n        totalSum += cardPoints[i];\n       }\n       int windowSum = 0, s = 0;\n       windowSum = s = totalSum;\n       for (int i = n - k;  i < n; i++) {\n          totalSum += cardPoints[i];\n          s += cardPoints[i] - cardPoints[i - (n-k)];\n          windowSum = Math.min(windowSum, s);\n       }\n       return totalSum - windowSum;\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/51#issuecomment-2600909384","body":"```java\nclass Solution {\n    private int maxConn = 0;\n    private int m = 0; \n    private int n = 0;\n    private int tot = 0;\n    private int[] dx = new int[]{0, 0, -1, 1};\n    private int[] dy = new int[]{1, -1, 0, 0};\n    public int maxAreaOfIsland(int[][] grid) {\n        m = grid.length;\n        n = grid[0].length;\n        int[][] vis = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1 && vis[i][j] == 0) {\n                    vis[i][j] = 1;\n                    tot = dfs(i,j,m,n,vis,grid);\n                    maxConn = Math.max(maxConn, tot);\n                }\n            }\n        }\n        return maxConn;\n    }\n    public int dfs(int row, int col, int m, int n, int[][] vis, int[][] grid) { \n        int tot = 1;\n        for (int i = 0; i < 4; i++) {\n            int nx = row + dx[i];\n            int ny = col + dy[i];\n        \n            if (check(nx, ny, m, n) && grid[nx][ny] == 1) {\n                if (vis[nx][ny] == 1) {\n                    continue;\n                }\n                vis[nx][ny] = 1; \n                tot += dfs(nx, ny, m, n, vis, grid);\n            }\n        }\n        return tot;\n    }\n    boolean check(int row, int col, int m, int n) {\n        if ((0 <= row && row < m) && (0 <= col && col < n)) {\n            return true;\n        } \n        return false;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/52#issuecomment-2602710636","body":"```java\nclass Solution {\n    private int[] dx = new int[]{0,0,-1,1};\n    private int[] dy = new int[]{-1,1,0,0};\n    public int maxDistance(int[][] grid) {\n        int n = grid.length;\n        int[][] dis = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dis[i][j] = -1;\n            }\n        }\n        Queue<Point> queue = new ArrayDeque<>();\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    dis[i][j] = 0;\n                    queue.offer(new Point(i, j));\n                }\n            }\n        }\n\n        boolean flag = false;\n        Point pp = null;\n        while (!queue.isEmpty()) {\n            pp = queue.poll();\n            int x = pp.x;\n            int y = pp.y;\n            for (int i = 0; i < 4; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if (nx < 0 || nx >= n || ny < 0 || ny >= n || dis[nx][ny] != -1) {\n                    continue;\n                }\n                dis[nx][ny] = dis[x][y] + 1;\n                flag = true;\n                queue.offer(new Point(nx, ny));\n            }\n        }\n        if (pp == null || !flag) {\n            return -1;\n        }\n        int maxDis = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                maxDis = Math.max(maxDis, dis[i][j]);\n            }\n        }\n        return maxDis;\n    }\n\n    static class Point {\n        int x;\n        int y;\n        Point() {};\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/54#issuecomment-2607279523","body":"```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        vector<tuple<int, int, int>> nodes;\n\n        function<void(TreeNode*, int, int)> dfs = [&](TreeNode* node, int row, int col) {\n            if (!node) {\n                return;\n            }\n            nodes.emplace_back(col, row, node->val);\n            dfs(node->left, row + 1, col - 1);\n            dfs(node->right, row + 1, col + 1);\n        };\n\n        dfs(root, 0, 0);\n        sort(nodes.begin(), nodes.end());\n        vector<vector<int>> ans;\n        int lastcol = INT_MIN;\n        for (const auto& [col, row, value]: nodes) {\n            if (col != lastcol) {\n                lastcol = col;\n                ans.emplace_back();\n            }\n            ans.back().push_back(value);\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/55#issuecomment-2610165813","body":"```java\nclass Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        int n = cost.length;\n        int[] dp = new int[n];\n        dp[0] = cost[0]; dp[1] = cost[1];\n        for (int i = 2; i < n; i++) {\n            dp[i] = Math.min(dp[i-2], dp[i-1]) + cost[i];\n        }\n        return Math.min(dp[n-1], dp[n-2]);\n    }\n}\n```\n\n**时间复杂度： O(N)**\n**空间复杂度:  O(N)**","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/56#issuecomment-2612625951","body":"```java\nclass Solution {\n    public int rob(int[] nums) {\n        int n = nums.length;\n        if (n < 2) {\n            return nums[0];\n        }\n        int[] dp = new int[n];\n        dp[0] = nums[0];\n        dp[1] = Math.max(dp[0], nums[1]);\n        for (int i = 2; i < n; i++) {\n            dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);\n        }\n        return dp[n-1];\n    }\n}\n```\n\n**时间复杂度: O(N)**\n**空间复杂度: O(N)**","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/57#issuecomment-2614004851","body":"```java\nclass Solution {\n    public int findNumberOfLIS(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n];  // 0...i, 代表以i结尾最长递增子序列的长度\n        int[] f = new int[n];   // 0...i, 代表以i结尾最长递增子序列的个数\n        for (int i = 0; i < n; i++) {\n            dp[i] = 1;\n            f[i] = 1;\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (nums[j] < nums[i]) {\n                    if (dp[j] + 1 == dp[i]) {\n                        f[i] += f[j];\n                    } else if (dp[j] + 1 > dp[i]) {\n                        f[i] = f[j];\n                    }\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                }\n            }\n        }\n        int maxLen = -1;\n        for (int i = 0; i < n; i++) {\n            maxLen = Math.max(maxLen, dp[i]);\n        }\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if (dp[i] == maxLen) {\n                res += f[i];\n            }\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/58#issuecomment-2614299520","body":"```java\nclass Solution {\n    public int longestCommonSubsequence(String a, String b) {\n        int n = a.length();\n        int m = b.length();\n        int[][] dp = new int[n+1][m+1];\n        for (int i = 0; i < n; i++) dp[i][0] = 0;\n        for (int i = 0; i < m; i++) dp[0][i] = 0;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (a.charAt(i-1) == b.charAt(j-1)) {\n                    dp[i][j] = dp[i-1][j-1] + 1;\n                } else {\n                    dp[i][j] = Math.max(dp[i-1][j-1],Math.max(dp[i][j-1], dp[i-1][j]));\n                }\n            }\n        }\n        return dp[n][m];\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/59#issuecomment-2614506896","body":"```java\nclass Solution {\n    private int[][] dp = null;\n    public int uniquePaths(int m, int n) {\n        dp = new int[m][n];\n        return dfs(0, 0, m-1, n-1);\n    }\n    int dfs(int x, int y, int m, int n) {\n        if (x < 0 || x > m || y < 0 || y > n) {\n            return 0;\n        }\n        if (x == m && y == n) {\n            return 1; \n        }\n        if (dp[x][y] != 0) {\n            return dp[x][y];\n        }\n        return dp[x][y] = dfs(x+1, y, m, n) + dfs(x, y+1, m, n);\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhenxied":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nuozhouzhang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shin-guid":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bochengwan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kyo-tom":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uratora":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guitarys":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sosdogecoin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zol013":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lrwhc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wwewwt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cyk1337":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangyu1131":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"diana21170648":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"61hhh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"quaaaaaack":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"acy925":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bi9potato":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guangsizhongbin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhaoygcq":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"catkathy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yqycs":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhuxinyu-znb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"freesan44":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mo660":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sencc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"randong22":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"beginner-jamji":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yzhyzhyzh123":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunstrongchina":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dongzegithub":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"metsystem":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miller-em":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dorian-byte":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yizhewill":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qiaojunch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhouliuhuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"beanza":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kingxiaozhe":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ygnauh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wzbwzt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iambigchen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weiboshi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"master-guang":[null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/4#issuecomment-2514333505","body":"```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n  this.maxSize = maxSize;\n  this.res = [];\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n  if (this.res.length < this.maxSize) {\n    this.res.push(x);\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n  if (this.res.length) {\n    return this.res.pop();\n  } else {\n    return -1;\n  }\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n  let len = this.res.length;\n  if (len < k) {\n    this.res = this.res.map((item) => (item += val));\n  } else {\n    let arr = this.res.splice(0, k);\n    this.newArr = arr.map((item) => (item += val));\n    this.res = [...this.newArr, ...this.res];\n  }\n\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/9#issuecomment-2525481316","body":"```js\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    let dummyHead = new ListNode(0, head)\n    let cur = dummyHead\n    while(cur.next && cur.next.next) {\n        let temp = cur.next\n        let temp1 = cur.next.next.next\n        cur.next = cur.next.next\n        cur.next.next = temp\n        temp.next = temp1\n        cur = cur.next.next\n    }\n    return dummyHead.next\n};","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/12#issuecomment-2533388614","body":"```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    let slow = head;\n    let fast = head;\n    while(fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if(slow === fast) {\n            let index1 = fast;\n            let index2 = head;\n            while(index1 !== index2) {\n                index1 = index1.next;\n                index2 = index2.next\n            }\n            return index2\n        }\n    }\n    return null\n};","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/16#issuecomment-2543854267","body":"```js\nvar sumNumbers = function(root) {\n    return dfs(root, 0);\n};\nconst dfs = (root, prevSum) => {\n    if (root === null) {\n        return 0;\n    }\n    const sum = prevSum * 10 + root.val;\n    if (root.left == null && root.right == null) {\n        return sum;\n    } else {\n        return dfs(root.left, sum) + dfs(root.right, sum);\n    }\n}","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/22#issuecomment-2558118349","body":"```js\nvar numberOfBoomerangs = function(points) {\n    let ans = 0;\n    for (const p of points) {\n        const cnt = new Map();\n        for (const q of points) {\n            const dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n            cnt.set(dis, (cnt.get(dis) || 0) + 1);\n        }\n        for (const [_, m] of cnt.entries()) {\n            ans += m * (m - 1);\n        }\n    }\n    return ans;\n};\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/27#issuecomment-2562634461","body":"```js\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    if(nums.length == 0) {\n        return 0;\n    }\n    let slow = 0;\n    let fast = 0;\n    while(fast < nums.length) {\n        if(nums[fast] != nums[slow]) {\n            slow++\n            nums[slow] = nums[fast]\n        }\n        fast++\n    }\n    return slow + 1\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jennyjgao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangjay408":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chang-you":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rocjemaintiendrai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ainfinitedz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"christ36":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hengistchan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huiyingc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"andyli4":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"momogir":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jamjid":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"freeroo2":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ycan253":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laurallalala":[{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/2#issuecomment-2509557352","body":"class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        power = 0\n        res = 0\n        for i in range(len(num)-1, -1, -1):\n            res += num[i]*10**power\n            power += 1\n        res += k\n        res_array = []\n        while res > 0:\n            digit = res % 10 \n            res = res // 10\n            res_array.insert(0, digit)\n        return res_array","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/3#issuecomment-2510681842","body":"```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        left2right = [float(\"inf\")]*n\n        last = -float(\"inf\")\n        for i in range(n):\n            if s[i] == c:\n                left2right[i] = 0\n                last = i\n            else:\n                left2right[i] = abs(i - last)\n        last = float(\"inf\")\n        for i in range(n-1, -1, -1):\n            if s[i] == c:\n                last = i\n            else:\n                left2right[i] = min(abs(last - i), left2right[i])\n        return left2right\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/4#issuecomment-2513486828","body":"```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n        \n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n        \n\n    def pop(self) -> int:\n        if len(self.stack) <= 0:\n            return -1\n        return self.stack.pop()\n        \n\n    def increment(self, k: int, val: int) -> None:\n        n = len(self.stack)\n        tmpStack = []\n        while len(self.stack) > k:\n            tmpStack.append(self.stack.pop())\n        while len(self.stack) > 0:\n            tmpStack.append(self.stack.pop()+val)\n        while tmpStack:\n            self.stack.append(tmpStack.pop())\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/6#issuecomment-2519221310","body":"```\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n        \n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        res = self.stack2.pop()\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n        return res\n\n    def peek(self) -> int:\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        res = self.stack2.pop()\n        self.stack2.append(res)\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/7#issuecomment-2522483064","body":"```\nclass Solution:\n    '''\n    5,4,1,2,10,3,4,8,7,9, 0\n\n    [5, 4, 1, 2] [10, 3, 4, 8, 7 ,9, 0]\n\n    '''\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        # [[5,4,1,2](1--min, 5--max)]\n        splited_arr = self.trySplit(arr)\n        print(splited_arr)\n        while len(splited_arr) > 1:\n            if self.validate(splited_arr):\n                print(splited_arr)\n                return len(splited_arr)\n            else:\n                splited_arr = self.tryMerge(splited_arr)\n        print(splited_arr)\n        return len(splited_arr)\n    \n    def trySplit(self, arr):\n        res, cur = [], []\n        min_num, max_num = arr[0], arr[0]\n        for i in range(len(arr)):\n            if not cur or arr[i]<max_num:\n                cur.append(arr[i])\n                min_num, max_num = min(min_num, arr[i]), max(max_num, arr[i])\n            else:\n                res.append([cur, min_num, max_num])\n                cur = [arr[i]]\n                min_num, max_num = arr[i], arr[i]\n        res.append([cur, min_num, max_num])\n        return res\n    \n    def validate(self, arr):\n        cur, min_num, max_num = arr[0]\n        for i in range(1, len(arr)):\n            nxt, nxt_min_num, nxt_max_num = arr[i]\n            if nxt_min_num >= max_num:\n                cur, min_num, max_num = nxt, nxt_min_num, nxt_max_num\n                continue\n            else:\n                return False\n        return True\n\n    def tryMerge(self, arr):\n        res = []\n        i = 0\n        for i in range(len(arr)):\n            cur, cur_min_num, cur_max_num = arr[i]\n            if not res:\n                res.append(arr[i])\n            else:\n                while res:\n                    prev, prev_min_num, prev_max_num = res.pop()\n                    if not (cur_min_num >= prev_max_num):\n                        cur, cur_min_num, cur_max_num = prev+cur, min(cur_min_num, prev_min_num), max(cur_max_num, prev_max_num)\n                    else:\n                        res.append([prev, prev_min_num, prev_max_num])\n                        break\n                res.append([cur, cur_min_num, cur_max_num])\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/8#issuecomment-2524844911","body":"```\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return head\n        n = 1\n        p = head\n        while p.next:\n            n += 1\n            p = p.next\n        p.next = head\n        \n        k = k%n\n        new_head = head\n        for i in range(n-k):\n            new_head = new_head.next\n        p = head\n        while p.next != new_head:\n            p = p.next\n        p.next = None\n        return new_head\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/9#issuecomment-2525457673","body":"```\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        first, second = head, head.next\n        prev = None\n        new_head = head\n        while first.next:\n            second = first.next\n            first.next = second.next\n            second.next = first\n            if prev:\n                prev.next = second\n            if new_head == head:\n                new_head = second\n            if first.next:\n                prev = first\n                first = first.next\n        return new_head\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/10#issuecomment-2526997375","body":"```\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head or not head.next:\n            return head\n        p = head\n        lst = []\n        while p:\n            lst.append(p.val)\n            p = p.next\n        \n        mid = len(lst) // 2\n        root = self.treeHelper(lst, mid, 0, len(lst)-1)\n        return root\n    \n    def treeHelper(self, lst, mid, left, right):\n        if left == right:\n            return TreeNode(lst[left], None, None)\n        elif left > right:\n            return None\n        root = TreeNode(lst[mid])\n        root.left = self.treeHelper(lst, (left+mid-1)//2, left, mid-1)\n        root.right = self.treeHelper(lst, (mid+1+right)//2, mid+1, right)\n        return root\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/11#issuecomment-2530469467","body":"```\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        if not headA or not headB:\n            return None\n        pA, pB = headA, headB\n        completeA, completeB = False, False\n        while True:\n            if pA == pB:\n                return pA\n            if not pA.next:\n                if not completeA:\n                    pA = headB\n                    completeA = True\n                else:\n                    return None\n            else:\n                pA = pA.next\n            if not pB.next:\n                if not completeB:\n                    pB = headA\n                    completeB = True\n                else:\n                    return None\n            else:\n                pB = pB.next\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/12#issuecomment-2533726049","body":"```\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return None\n        slow, fast = head.next, head.next.next\n        while slow != fast:\n            slow = slow.next\n            if fast and fast.next:\n                fast = fast.next.next\n            else:\n                return None\n        fast = head\n        while slow != fast:\n            slow = slow.next\n            fast = fast.next\n        return slow\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/13#issuecomment-2537817179","body":"```\nimport collections\n\nclass Node:\n    def __init__(self, key, val, prev=None, nxt=None):\n        self.key = key\n        self.val = val\n        self.prev = prev\n        self.nxt = nxt\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.map = collections.defaultdict(Node)\n        # dummy head\n        self.dhead = Node(-1, -1)\n        self.dtail = Node(-1, -1)\n        self.dhead.nxt = self.dtail\n        self.dtail.prev = self.dhead\n\n    def get(self, key: int) -> int:\n\n        if key in self.map:\n            node = self.map[key]\n            self.moveToFront(node)\n            return self.map[key].val\n        else:\n            return -1\n        \n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.map:\n            node = Node(key, value, self.dhead, self.dhead.nxt)\n            self.dhead.nxt.prev = node\n            self.dhead.nxt = node\n            self.map[key] = node\n            # evict\n            if len(self.map) > self.capacity:\n                lru = self.dtail.prev\n                lru.prev.nxt = self.dtail\n                lru.nxt.prev = lru.prev\n                del self.map[lru.key]\n        else:\n            node = self.map[key]\n            node.val = value\n            self.moveToFront(node)\n    \n    def moveToFront(self, node):\n        node.prev.nxt = node.nxt\n        node.nxt.prev = node.prev\n        node.nxt = self.dhead.nxt\n        node.prev = self.dhead\n        self.dhead.nxt.prev = node\n        self.dhead.nxt = node\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/14#issuecomment-2540500024","body":"```\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        leftMax = self.maxDepth(root.left)\n        rightMax = self.maxDepth(root.right)\n        return max(leftMax, rightMax) + 1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/15#issuecomment-2542627497","body":"```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/16#issuecomment-2543446385","body":"```\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        \n\n        def helper(node):\n            if not node:\n                return [], 0\n            if not node.left and not node.right:\n                # return depth, cur_sum\n                return [0], node.val\n            cur_sum = 0\n            cur_depths = []\n            depths, prev_sum = helper(node.left)\n            cur_depths += [d+1 for d in depths]\n            cur_sum = cur_sum + prev_sum + sum([node.val*10**(d+1) for d in depths])\n            depths, prev_sum = helper(node.right)\n            cur_sum = cur_sum + prev_sum + sum([node.val*10**(d+1) for d in depths])\n            cur_depths += [d+1 for d in depths]\n            return cur_depths, cur_sum\n        \n        _, res = helper(root)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/17#issuecomment-2544678803","body":"```\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        self.res = root.val\n        self.max_depth = 0\n\n        def helper(root, depth):\n            if not root:\n                return\n            elif not root.left and not root.right:\n                if depth > self.max_depth:\n                    self.res = root.val\n                    self.max_depth = depth\n                    return \n            helper(root.left, depth+1)\n            helper(root.right, depth+1)\n        \n        helper(root, 1)\n        return self.res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/18#issuecomment-2547546046","body":"```\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        1 l:n r:n \n        \"\"\"\n        def preorder(root):\n            if not root:\n                return \"null,\"\n            return str(root.val) + \",\" + preorder(root.left) + preorder(root.right)\n        return preorder(root)\n        \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        nodes = data.split(\",\")\n\n        def preorder(i):\n            if i >= len(nodes) or nodes[i] == \"null\":\n                return i, None\n            root = TreeNode(nodes[i])\n            j, root.left = preorder(i + 1)\n            k, root.right = preorder(j + 1)\n            return k, root\n\n        return preorder(0)[1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/19#issuecomment-2550419807","body":"```\nimport collections\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        # first, level order traversal to have x index sorted in a dict e.g. {-1:[9] 0:[3, 15], 1:[20]...}\n        d = collections.defaultdict(list)\n        q = collections.deque([(root, 0)])\n        while q:\n            l = len(q)\n            tmp = collections.defaultdict(list)\n            for i in range(l):\n                node, y = q.popleft()\n                tmp[y].append(node.val)\n                if node.left:\n                    q.append((node.left, y-1))\n                if node.right:\n                    q.append([node.right, y+1])\n            # sort the list in the same level to make sure the node with same index is ordered by values\n            for y in tmp:\n                d[y].extend(sorted(tmp[y]))\n        \n        return [d[key] for key in sorted(d)]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/20#issuecomment-2552902758","body":"```\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        d = {}\n        for i in range(len(nums)):\n            rest = target - nums[i]\n            if rest in d:\n                return [d[rest], i]\n            d[nums[i]] = i\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/21#issuecomment-2556367083","body":"```\nimport collections\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        ct = collections.defaultdict(int)\n        for num in nums:\n            ct[num] += 1\n        return [k for k, v in sorted(ct.items(), key=lambda item: item[1], reverse=True)][:k]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/22#issuecomment-2558021514","body":"```\nclass Solution:\n    \"\"\"\n    {(x,y): {dis:[(x2,y2), (x3,y3)...]}}\n\n    {(1,0): {1:[(0,0), (2,0)]}}\n    \n    \"\"\"\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        if len(points) < 3:\n            return 0\n        n = len(points)\n        res = 0\n        for i in range(n):\n            d = collections.defaultdict(int)\n            for j in range(n):\n                dis = (points[i][0]-points[j][0])**2 + (points[i][1]-points[j][1])**2\n                d[dis] += 1\n        \n            for key in d:\n                if d[key] >= 2:\n                    res += d[key]*(d[key]-1)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/23#issuecomment-2558353223","body":"```\nimport collections\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        if len(s) <= 1:\n            return len(s)\n        d = collections.defaultdict(int)\n        i, j = 0, 0\n        res = 0\n        n = len(s)\n        cur = 0\n        while j<n:\n            if d[s[j]] == 0:  \n                d[s[j]] = 1\n                cur += 1\n                res = max(res, cur)\n            else:\n                while i<j and s[i] != s[j]:\n                    d[s[i]] = 0\n                    i += 1\n                    cur -= 1\n                i += 1\n            j += 1\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/24#issuecomment-2559048361","body":"```\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n\n        def isPermutation(subs, ct, wl):\n\n            ctsub = collections.defaultdict(int)\n            for p in range(0, len(subs)-wl+1, wl):\n                ctsub[subs[p: p+wl]] += 1\n                        \n            if len(ctsub) != len(ct):\n                return False\n            \n            for key in ct:\n                if key not in ctsub or ctsub[key] != ct[key]:\n                    return False\n                \n            return True\n\n\n        wl = len(words[0])\n        l = len(words)\n        if wl*l > len(s):\n            return []\n\n        ct = collections.defaultdict(int)\n        for w in words:\n            ct[w] += 1\n                \n        res = []\n        for i in range(len(s)-wl*l+1):\n            if isPermutation(s[i:i+l*wl], ct, wl):\n                res.append(i)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/25#issuecomment-2560745124","body":"```\nclass Solution:\n\n    def minSubarray(self, nums: List[int], k: int) -> int:\n        total = sum(nums)\n        mod = total % k\n        if mod == 0: return 0\n\n        ans = len(nums)\n        total = 0\n        dic = {0: -1}\n        for j in range(len(nums)):\n            total += nums[j]\n            cur = total % k\n            # https://leetcode.cn/problems/make-sum-divisible-by-p/solutions/1/tao-lu-qian-zhui-he-ha-xi-biao-pythonjav-rzl0/ 负数 +k)%k\n            target = (cur - mod + k) % k\n            if target in dic:\n                ans = min(ans, j - dic[target])\n            dic[cur] = j\n\n        if ans == len(nums):\n            return -1\n        return ans\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/26#issuecomment-2561683824","body":"```\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/27#issuecomment-2562215319","body":"```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        prev = nums[0]\n        cur = 1\n        res = 1\n        for i in range(1, len(nums)):\n            if nums[i] != prev:\n                nums[cur] = nums[i]\n                cur += 1\n                res += 1\n                prev = nums[i]\n        if nums[-1] != prev:\n            nums[cur] = nums[i]\n            res += 1\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/28#issuecomment-2563387623","body":"```\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums)-1\n        while left <= right:\n            mid = (left+right) // 2\n            if target > nums[mid]:\n                left = mid+1\n            elif target < nums[mid]:\n                right = mid-1\n            else:\n                return mid\n        return left\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/29#issuecomment-2564254228","body":"```\nimport collections\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        dq = collections.deque([])\n        res = []\n        for i in range(len(nums)):\n            if not dq:\n                dq.append(i)\n            else:\n                if i-dq[0] >= k:\n                    dq.popleft()\n                while dq and nums[i] >= nums[dq[-1]]:\n                    dq.pop()\n                if not dq or nums[i] < nums[dq[-1]]:\n                    dq.append(i)\n            if i >= k-1:\n                res.append(nums[dq[0]])\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/30#issuecomment-2564632143","body":"```\nimport collections\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        d1 = collections.defaultdict(list)\n        d2 = collections.defaultdict(list)\n        for a, b in trust:\n            d1[b].append(a)\n            d2[a].append(b)\n        res = -1\n        for i in range(1, n+1):\n            if i not in d2 and len(d1[i]) == n-1:\n                res = i\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/31#issuecomment-2565098779","body":"```\nimport collections\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        if not dislikes:\n            return True\n        g = collections.defaultdict(list)\n        for a, b in dislikes:\n            g[a].append(b)\n            g[b].append(a)\n        visited = [-1]*n\n        \n        def dfs(color, node, visited):\n            if visited[node-1] != -1:\n                if color != visited[node-1]:\n                    return False\n                else:\n                    return True\n            visited[node-1] = color\n            for e in g[node]:\n                if not dfs(1-color, e, visited):\n                    return False\n            return True\n        \n        res = True\n        for a, b in dislikes:\n            if visited[a-1] == -1 and visited[b-1] == -1:\n                res = res and dfs(0, a, visited)\n                print(res)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/32#issuecomment-2566143100","body":"```\nclass Solution:\n    def has_cycle(self, graph, cur_node, visited, result):\n        if visited[cur_node] == 1:\n            return False\n        if visited[cur_node] == 2:\n            return True\n        visited[cur_node] = 2\n        for next_node in graph[cur_node]:\n            if self.has_cycle(graph, next_node, visited, result):\n                return True\n        visited[cur_node] = 1\n        result.append(cur_node)\n        return False\n\n    def sortItems(self, n: int, m: int, group: List[int],\n                  beforeItems: List[List[int]]) -> List[int]:\n        # Map between group_id and item_ids\n        group_items_map = defaultdict(list)\n        # Visited for items in each group. Will be used later\n        visited_item = defaultdict(dict)\n        for i in range(n):\n            # Assign no-group items to a new group\n            if group[i] == -1:\n                group[i] = m\n                m += 1\n            group_items_map[group[i]].append(i)\n            visited_item[group[i]][i] = 0\n\n        # key - group_id : value - next_groups\n        graph_group = defaultdict(set)\n        # key - group_id : value - {key - item_id : value: next_items}\n        graph_item = {i: defaultdict(list) for i in range(m)}\n\n        # Create graph for items and groups\n        for item_after, before_items in enumerate(beforeItems):\n            for item_before in before_items:\n                group_before = group[item_before]\n                group_after = group[item_after]\n\n                # If two items belong to different groups,\n                #   add a dependency between groups\n                # Otherwise, add a dependency between items in the same group\n                if group_before != group_after:\n                    graph_group[group_before].add(group_after)\n                else:\n                    graph_item[group_before][item_before].append(item_after)\n\n        # Use DFS to find group order\n        visited_group = [0] * m\n        group_order = []\n        for group_id in range(m):\n            if self.has_cycle(graph_group, group_id,\n                              visited_group, group_order):\n                return []\n\n        # Use DFS to find item order in each group\n        full_item_order = []\n        for group_id in group_order:\n            for item_id in group_items_map[group_id]:\n                if self.has_cycle(graph_item[group_id], item_id,\n                                  visited_item[group_id], full_item_order):\n                    return []\n        return full_item_order[::-1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/33#issuecomment-2566891073","body":"```\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        # d=[left, right, down, up]\n        d = {\"L\": [-1, 0], \"R\": [1, 0], \"D\": [0, -1], \"U\": [0, 1]}\n        x, y = 0, 0\n        for move in moves:\n            mx, my = d[move]\n            x, y = x+mx, y+my\n        return x==0 and y==0\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/34#issuecomment-2567421283","body":"```\nclass Solution {\n    public int[] getOrder(int[][] tasks) {\n        int n = tasks.length;\n        int[] ans = new int[n];\n        int[][] extTasks = new int[n][3];\n        for(int i = 0; i < n; i++) {\n            extTasks[i][0] = i;\n            extTasks[i][1] = tasks[i][0];\n            extTasks[i][2] = tasks[i][1];\n        }\n        Arrays.sort(extTasks, (a,b)->a[1] - b[1]);\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[2] == b[2] ? a[0] - b[0] : a[2] - b[2]);\n        int time = 0;\n        int ai = 0;\n        int ti = 0;\n        while(ai < n) {\n            while(ti < n && extTasks[ti][1] <= time) {\n                pq.offer(extTasks[ti++]);\n                \n            }\n            if(pq.isEmpty()) {\n                time = extTasks[ti][1];\n                continue;\n            }\n            int[] bestFit = pq.poll();\n            ans[ai++] = bestFit[0];\n            time += bestFit[2];\n        }\n        return ans;\n    }\n    \n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/35#issuecomment-2568812238","body":"```\nimport math\nclass Solution:\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\n        loginHour, loginMin = [int(part) for part in loginTime.split(':')]\n        logoutHour, logoutMin = [int(part) for part in logoutTime.split(':')]\n        if loginHour > logoutHour or (loginHour == logoutHour and loginMin > logoutMin):\n            return self.numberOfRounds(loginTime, \"24:00\") + self.numberOfRounds(\"00:00\", logoutTime)\n        loginHour, loginMin = self.findNextClosetCutoff(loginHour, loginMin)\n        logoutHour, logoutMin = self.findPrevClosetCutoff(logoutHour, logoutMin)\n        if loginHour > logoutHour:\n            return 0\n        elif loginHour == logoutHour:\n            if loginMin >= logoutMin:\n                return 0\n            return (logoutMin - loginMin) // 15\n        else:\n            return (logoutHour - loginHour) * 4 + logoutMin // 15 - loginMin // 15\n\n    def findNextClosetCutoff(self, loginHour, loginMin):\n        cutoff = [0, 15, 30, 45]\n        i = math.ceil(loginMin / 15) \n        if i >= len(cutoff):\n            return loginHour+1, cutoff[i%len(cutoff)]\n        else:\n            return loginHour, cutoff[i]\n    \n    def findPrevClosetCutoff(self, logoutHour, logoutMin):\n        cutoff = [0, 15, 30, 45]\n        i = math.floor(logoutMin / 15) \n        return logoutHour, cutoff[i]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/36#issuecomment-2570620226","body":"```\nclass Solution:\n    def minCharacters(self, a, b):\n        m, n = len(a), len(b)\n        c1 = Counter(ord(c) - 97 for c in a)\n        c2 = Counter(ord(c) - 97 for c in b)\n        res = m + n - max((c1 + c2).values()) # condition 3\n        for i in range(25):\n            c1[i + 1] += c1[i]\n            c2[i + 1] += c2[i]\n            res = min(res, m - c1[i] + c2[i]) # condition 1\n            res = min(res, n - c2[i] + c1[i]) # condition 2\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/37#issuecomment-2571541777","body":"```\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        return self.helper(nums, 0, len(nums)-1)\n    \n    def helper(self, nums, left, right):\n        if left == right:\n            return [nums[left]]\n        mid = (left + right) // 2\n        left_sort = self.helper(nums, left, mid)\n        right_sort = self.helper(nums, mid+1, right)\n        res = []\n        i, j = 0, 0\n        while i < len(left_sort) and j < len(right_sort):\n            if left_sort[i] < right_sort[j]:\n                res.append(left_sort[i])\n                i += 1\n            else:\n                res.append(right_sort[j])\n                j += 1\n        while i < len(left_sort):\n            res.append(left_sort[i])\n            i += 1\n        while j < len(right_sort):\n            res.append(right_sort[j])\n            j += 1\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/38#issuecomment-2572316458","body":"```\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        for i in range(x):\n            if i*i == x:\n                return i\n            elif i*i < x and (i+1)*(i+1) > x:\n                return i\n        return x\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/39#issuecomment-2574130381","body":"```\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        left, right = 1, n\n        res = 0\n        while left <= right:\n            mid = (left + right) // 2\n            if isBadVersion(mid):\n                res = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/40#issuecomment-2576463344","body":"```\nclass Solution:\n    '''\n    edge case: len(nums) == 1, return 0\n\n    nums [1,3,2,3,1]\n\n    2*nums [2,6,4,6,2]\n\n    O(n^2)\n\n    \n    '''\n    def reversePairs(self, nums: List[int]) -> int:\n        if len(nums) == 1:\n            return 0\n        \n        self.count = 0\n        \n        def mergeSort(nums, lo, hi):\n            if lo < hi:\n                mid = (lo + hi) // 2\n                mergeSort(nums, lo, mid)\n                mergeSort(nums, mid+1, hi)\n                merge(nums, lo, mid, hi)\n        \n\n        def merge(nums, lo, mid , hi):\n            # left: lo ... mid\n            # right: mid+1 ... hi\n            i, j = lo, mid+1\n            while i<=mid and j<=hi:\n                if nums[i] <= 2*nums[j]:\n                    i += 1\n                else:\n                    self.count += mid-i+1\n                    j += 1\n            \n            temp = []\n            i, j = lo, mid+1\n            while i<=mid and j<=hi:\n                if nums[i]<=nums[j]:\n                    temp.append(nums[i])\n                    i += 1\n                else:\n                    temp.append(nums[j])\n                    j += 1\n            \n            while i<=mid:\n                temp.append(nums[i])\n                i += 1\n            while j<=hi:\n                temp.append(nums[j])\n                j += 1\n            for i in range(len(temp)):\n                nums[lo+i] = temp[i]\n\n        \n        mergeSort(nums, 0, len(nums)-1)\n\n        return self.count\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/41#issuecomment-2579245438","body":"```\nclass Solution:\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\n        l = 0\n        r = 1e9\n        n = len(houses)\n        m = len(heaters)\n        houses.sort()\n        heaters.sort()\n        def checkHeat(mid: int):\n            fst = 0\n            snd = 0\n            while fst < n and snd < m:\n                while fst < n and \\\n                heaters[snd]+mid >= houses[fst] and heaters[snd]-mid <= houses[fst]:\n                    fst+=1\n                snd+=1\n            return (fst >= n)\n\n        while l <= r:\n            mid = int((l+r)//2)\n            if not checkHeat(mid):\n                l = mid + 1\n            else:\n                r = mid - 1\n        \n        return l\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/42#issuecomment-2581494561","body":"```\nclass Solution:\n    def smallestDistancePair(self, nums: List[int], k: int) -> int:\n        def get_count(dis):\n            cnt = l = 0\n            for r in range(len(nums)):\n                while nums[r] - nums[l] > dis:\n                    l += 1\n                cnt += r - l\n            return cnt\n        \n        nums.sort()\n        left, right = 0, nums[-1] - nums[0]\n        while left <= right:\n            mid = (left + right) // 2\n            if get_count(mid) < k:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/43#issuecomment-2584871439","body":"```\nimport heapq\n\nclass Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        rows, cols = len(grid), len(grid[0])\n        cache = [[float(\"inf\")]*cols for i in range(rows)]\n        minheap = [(grid[0][0], 0, 0)]\n        directions = [[-1,0],[1,0],[0,-1],[0,1]]\n        cache[0][0] = grid[0][0]\n\n        while minheap:\n            elevation, x, y = heapq.heappop(minheap)\n            if x == rows-1 and y == cols-1:\n                return elevation\n            for d in directions:\n                nx, ny = x+d[0], y+d[1]\n                if nx>=0 and nx<rows and ny>=0 and ny<cols:\n                    newElevation = max(elevation, grid[nx][ny])\n                    if newElevation < cache[nx][ny]:\n                        cache[nx][ny] = newElevation\n                        heappush(minheap, (newElevation, nx, ny))\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/44#issuecomment-2585617073","body":"```\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        vowels = \"aeiou\"\n        j = 0\n        cur = 0\n        while j < k:\n            if s[j] in vowels:\n                cur += 1\n            j += 1\n        res = cur\n        i = 0\n        while j < len(s):\n            if s[j] in vowels:\n                cur += 1\n            if s[i] in vowels:\n                 cur -= 1\n            i += 1\n            j += 1\n            res = max(res, cur)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/45#issuecomment-2586429916","body":"```\nclass Solution:\n    def new21Game(self, n: int, k: int, maxPts: int) -> float:\n        if k==0:\n            return 1.0\n        dp = [0.0]*(n+maxPts)\n\n        s = 0\n        for i in range(k, min(n, k+maxPts-1)+1):\n            dp[i] = 1.0\n            s += dp[i]\n        \n\n        for i in range(k-1, -1, -1):\n            dp[i] = s/float(maxPts)\n            s = s - dp[i+maxPts] + dp[i]\n        return dp[0]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/46#issuecomment-2588507165","body":"```\nclass Solution:\n    def findAnagrams(self, s: str, p: str) -> List[int]:\n        if len(s) < len(p):\n            return []\n        pct = [0]*26\n        for c in p:\n            pct[ord(c)-ord('a')] += 1\n        ct = [0]*26\n        for i in range(len(p)):\n            if s[i] in p:\n                ct[ord(s[i])-ord('a')] += 1\n        res = []\n        if self.isAnagram(pct, ct):\n            res.append(0)\n        start = 0\n        for end in range(len(p), len(s)):\n            if s[end] in p:\n                ct[ord(s[end])-ord('a')] += 1\n            if s[start] in p:\n                ct[ord(s[start])-ord('a')] -= 1\n            start += 1\n            if self.isAnagram(pct, ct):\n                res.append(start)\n        return res\n    \n    def isAnagram(self, pct, ct):\n        for i in range(26):\n            if pct[i] != ct[i]:\n                return False\n        return True\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/47#issuecomment-2591385220","body":"```\nimport collections\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if len(t) > len(s):\n            return \"\"\n        \n        ct = collections.Counter(t)\n        l = len(t)\n\n        left = 0\n        res = [left, len(s)]\n        for right in range(len(s)):\n            if s[right] in ct:\n                if ct[s[right]] > 0:\n                    l -= 1\n            ct[s[right]] -= 1\n            while l==0:\n                if (res[1]-res[0])>(right-left):\n                    res = [left, right]\n                if s[left] in ct:\n                    if ct[s[left]] >= 0:\n                        l += 1\n                    ct[s[left]] += 1        \n                left += 1\n        if res[1] == len(s):\n            return \"\"\n        return s[res[0]:res[1]+1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/48#issuecomment-2594177903","body":"```\nclass Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        min_len = len(cardPoints) - k\n        res = 0\n        for i in range(min_len):\n            res += cardPoints[i]\n        cur = res\n        for i in range(min_len, len(cardPoints)):\n            cur = cur + cardPoints[i] - cardPoints[i-min_len]\n            res = min(res, cur)\n        return sum(cardPoints) - res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/49#issuecomment-2597641824","body":"```\nclass Solution:\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\n        output = []\n        # Loop through all possible combinations of hours and minutes and count the number of set bits\n        for h in range(12):\n            for m in range(60):\n                if bin(h).count('1') + bin(m).count('1') == turnedOn:  # Check if the number of set bits in hours and minutes equals the target number\n                    output.append(f\"{h}:{m:02d}\")  # Add the valid combination of hours and minutes to the output list\n        return output\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/50#issuecomment-2599587298","body":"```\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        cols = set()\n        posDiag = set()\n        negDiag = set()\n\n        self.res = 0\n\n        def backtrack(r):\n            if r == n:\n                self.res += 1\n                return\n            for c in range(n):\n                if c in cols or (r+c) in posDiag or (r-c) in negDiag:\n                    continue\n                cols.add(c)\n                posDiag.add(r+c)\n                negDiag.add(r-c)\n                backtrack(r+1)\n                cols.remove(c)\n                posDiag.remove(r+c)\n                negDiag.remove(r-c)\n        \n        backtrack(0)\n        return self.res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/51#issuecomment-2600681931","body":"```\nclass Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        rows, cols = len(grid), len(grid[0])\n        res = 0\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == 1:\n                    res = max(res, self.dfs(grid, i, j))\n        return res\n    \n    def dfs(self, grid, i, j):\n        if i < 0 or j < 0 or i == len(grid) or j == len(grid[0]) or grid[i][j] == 0:\n            return 0\n        grid[i][j] = 0\n        return 1 + self.dfs(grid, i-1, j) + self.dfs(grid, i, j-1) + self.dfs(grid, i+1, j) + self.dfs(grid, i, j+1)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/52#issuecomment-2601445097","body":"```\nclass Solution:\n    def maxDistance(self, grid: List[List[int]]) -> int:\n        from collections import deque\n        N = len(grid)\n        steps = -1\n        q = deque([(i, j) for i in range(N) for j in range(N) if grid[i][j] == 1])\n        if len(q) == 0 or len(q) == N ** 2:\n            return steps\n        move = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        while len(q) > 0:\n            for _ in range(len(q)):\n                x, y = q.popleft()\n                for dx, dy in move:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < N and 0 <= ny < N and grid[nx][ny] == 0:\n                        q.append((nx, ny))\n                        grid[nx][ny] = -1\n            steps += 1\n\n        return steps\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/53#issuecomment-2603949972","body":"import collections\n\nclass Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        ans = cnt = 0\n        q = collections.deque(initialBoxes)\n        while q:\n            i = q[0]\n            q.popleft()\n            if status[i] != 1:\n                q.append(i)\n                cnt += 1\n                if cnt == len(q): break\n                continue\n            cnt = 0\n            ans += candies[i]\n            for box in containedBoxes[i]: q.append(box)\n            for key in keys[i]: status[key] = 1\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/54#issuecomment-2606023434","body":"```\n\nimport collections\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        # first, level order traversal to have x index sorted in a dict e.g. {-1:[9] 0:[3, 15], 1:[20]...}\n        d = collections.defaultdict(list)\n        q = collections.deque([(root, 0)])\n        while q:\n            l = len(q)\n            tmp = collections.defaultdict(list)\n            for i in range(l):\n                node, y = q.popleft()\n                tmp[y].append(node.val)\n                if node.left:\n                    q.append((node.left, y-1))\n                if node.right:\n                    q.append([node.right, y+1])\n            # sort the list in the same level to make sure the node with same index is ordered by values\n            for y in tmp:\n                d[y].extend(sorted(tmp[y]))\n        \n        return [d[key] for key in sorted(d)]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/55#issuecomment-2609018137","body":"```\nclass Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        n = len(cost) + 1\n        cost.append(0)\n        dp = [0] * n\n        dp[0], dp[1] = cost[0], cost[1]\n        for i in range(2, n):\n            dp[i] = min(dp[i-1], dp[i-2]) + cost[i]\n        return dp[n-1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/56#issuecomment-2611905673","body":"```\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        if len(nums) <= 1:\n            return sum(nums)\n        n = len(nums)\n        dp = [0] * n\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n        for i in range(2, n):\n                dp[i] = max(dp[i-2]+nums[i], dp[i-1])\n        return max(dp[n-2], dp[n-1])\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/57#issuecomment-2613600447","body":"```\nclass Solution:\n    def findNumberOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1: return 1\n\n        dp = [1] * n\n        count = [1] * n\n        max_length = 0\n        for i in range(1, n):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    if dp[j] + 1 > dp[i]:\n                        dp[i] = dp[j] + 1\n                        count[i] = count[j]\n                    elif dp[j] + 1 == dp[i]:\n                        count[i] += count[j]\n            max_length = max(max_length, dp[i])\n\n        res = 0\n        for i in range(n):\n            if dp[i] == max_length:\n                res += count[i]\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/58#issuecomment-2614245905","body":"```\nclass Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n\n        # Example \n        #    \"\" a c e\n        # \"\" 0  0 0 0 \n        # a  0  1 0 0 \n        # b  0  0 0 0 \n        # c  0  0 2 0 \n        # d  0  0 0 0 \n        # e  0  0 0 3 \n\n        n, m = len(text1), len(text2) \n        dp = [[0]*(m+1) for i in range(n+1)]\n        for i in range(1, n+1):\n            for j in range(1, m+1):\n                if text1[i-1] == text2[j-1]:\n                    dp[i][j] = max(dp[i][j], dp[i-1][j-1])+1\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        return dp[-1][-1]\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"danielyan86":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rennzhang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"larscheng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qingkediguo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"adfvcdxv":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"javajianghu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chloe-c11":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"verkru":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eggeggliu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dr-kkk":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jinhma":[{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/2#issuecomment-2509556168","body":"```class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> result = new ArrayList<>();\n        int len = num.length;\n        for (int i = 0; i < len; ++i) {\n            int a = num[len - i - 1];\n            k = k + a;\n            int b = k % 10;\n            result.add(b);\n            k = k / 10;\n        }\n        while (k != 0) {\n            int a = k % 10;\n            result.add(a);\n            k = k / 10;\n        }\n        Collections.reverse(result);\n        return result;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/3#issuecomment-2511831764","body":"```class Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] result = new int[s.length()];\n        int len = s.length();\n        int latestC = len;\n        for (int i = 0; i < len; i++) {\n            char tmp = s.charAt(i);\n            if (tmp == c) {\n                result[i] = 0;\n                latestC = i;\n                continue;\n            }\n            result[i] = Math.abs(latestC - i);\n        }\n        latestC = 0;\n        for (int i = len - 1; i >= 0; i--) {\n            char tmp = s.charAt(i);\n            if (tmp == c){\n                result[i] = 0;\n                latestC = i;\n                continue;\n            }\n            result[i] = Math.min(result[i], Math.abs(i - latestC));\n        }\n        return result;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/4#issuecomment-2514793006","body":"\n```class CustomStack {\n    List<Integer> stack;\n    int size;\n    public CustomStack(int maxSize) {\n        this.stack = new ArrayList<Integer>(maxSize);\n        this.size = maxSize;\n    }\n    \n    public void push(int x) {\n        if(stack.size()+1<=size){\n            stack.add(x);\n        }\n    }\n    \n    public int pop() {\n        if(stack.size() == 0){\n            return -1;\n        }\n        int result = stack.get(stack.size()-1);\n        stack.remove(stack.size()-1);\n        return result;\n    }\n    \n    public void increment(int k, int val) {\n        for(int i=0;i<stack.size();i++){\n            int var1 = stack.get(i);\n            if(i<k){\n                stack.set(i, var1+val);\n            }\n        }\n    }\n}\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/5#issuecomment-2517806222","body":"\n\n```class Solution {\n    public String decodeString(String s) {\n        Deque<Integer> numStack = new LinkedList<>();\n        Deque<StringBuilder> sbStack = new LinkedList<>();\n        int multi = 0;\n        StringBuilder sb = new StringBuilder();\n        for(char ch : s.toCharArray()){\n            if(Character.isDigit(ch)){\n               multi = multi * 10 + ch - '0';\n            }\n            else if(ch == '['){\n                numStack.push(multi);\n                sbStack.push(sb);\n                multi = 0;\n                sb = new StringBuilder();\n            }\n            else if(ch == ']'){\n                StringBuilder sbTemp = sbStack.pop();\n                int numTemp = numStack.pop();\n                for(int i = 0;i<numTemp;i++){\n                    sbTemp.append(sb.toString());\n                }\n                sb = sbTemp;\n            }\n            else{\n                sb.append(ch);\n            }\n        }\n        return sb.toString();\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/6#issuecomment-2520729938","body":"\n\n```class MyQueue {\n    private Stack<Integer> stackOne;\n    private Stack<Integer> stackTwo;\n    public MyQueue() {\n        this.stackOne = new Stack<Integer>();\n        this.stackTwo = new Stack<Integer>();\n    }\n\n    public void push(int x) {\n        stackOne.add(x);\n    }\n\n    public int pop() {\n        while (!stackOne.empty()){\n            stackTwo.add(stackOne.pop());\n        }\n        int result = stackTwo.pop();\n        while (!stackTwo.empty()){\n            stackOne.add(stackTwo.pop());\n        }\n        return result;\n    }\n\n    public int peek() {\n        while (!stackOne.empty()){\n            stackTwo.add(stackOne.pop());\n        }\n        int result = stackTwo.peek();\n        while (!stackTwo.empty()){\n            stackOne.add(stackTwo.pop());\n        }\n        return result;\n    }\n\n    public boolean empty() {\n        return stackOne.empty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/7#issuecomment-2523295893","body":"```class Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Deque<Integer> stack = new ArrayDeque<Integer>();\n        for (int num : arr) {\n            if (stack.isEmpty() || num >= stack.peek()) {\n                stack.push(num);\n            } else {\n                int mx = stack.pop();\n                while (!stack.isEmpty() && stack.peek() > num) {\n                    stack.pop();\n                }\n                stack.push(mx);\n            }\n        }\n        return stack.size();\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/8#issuecomment-2524871430","body":"```\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) return head;\n        ListNode cur = head;\n        int len = 0;\n        while (cur != null) {\n            len++;\n            cur = cur.next;\n        }\n        k %= len;\n        if (k == 0) return head;\n        ListNode fast = head;\n        while (k > 0) {\n            fast = fast.next;\n            k--;\n        }\n        ListNode slow = head;\n        while (fast.next != null) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        ListNode newHead = slow.next;\n        slow.next = null;\n        fast.next = head;\n        return newHead;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/9#issuecomment-2525415578","body":"```\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null){\n            return head;\n        }\n        ListNode next = head.next;\n        head.next = swapPairs(next.next);\n        next.next = head;\n        return next;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/10#issuecomment-2528017339","body":"\n\n```class Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        int n = 0;\n        ListNode cur = head;\n        while (cur != null && ++n >= 0) cur = cur.next;\n        return build(head, 0, n - 1);\n    }\n    TreeNode build(ListNode head, int l, int r) {\n        if (l > r) return null;\n        int mid = l + r >> 1, t = mid - l;\n        ListNode cur = head;\n        while (t-- > 0) cur = cur.next;\n        TreeNode ans = new TreeNode(cur.val);\n        ans.left = build(head, l, mid - 1);\n        ans.right = build(cur.next, mid + 1, r);\n        return ans;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/11#issuecomment-2532081122","body":"```\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Set<ListNode> visited = new HashSet<ListNode>();\n        ListNode temp = headA;\n        while (temp != null) {\n            visited.add(temp);\n            temp = temp.next;\n        }\n        temp = headB;\n        while (temp != null) {\n            if (visited.contains(temp)) {\n                return temp;\n            }\n            temp = temp.next;\n        }\n        return null;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/12#issuecomment-2536172152","body":"```\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode pos = head;\n        Set<ListNode> visited = new HashSet<ListNode>();\n        while (pos != null) {\n            if (visited.contains(pos)) {\n                return pos;\n            } else {\n                visited.add(pos);\n            }\n            pos = pos.next;\n        }\n        return null;\n    }\n}\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/39#issuecomment-2575587203","body":"public class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        int left = 1, right = n;\n        while (left < right) { \n            int mid = left + (right - left) / 2; \n            if (isBadVersion(mid)) {\n                right = mid; \n            } else {\n                left = mid + 1; \n            }\n        }\n       \n    }\n}\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/46#issuecomment-2590036050","body":"class Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        int sLen = s.length(), pLen = p.length();\n\n        if (sLen < pLen) {\n            return new ArrayList<Integer>();\n        }\n\n        List<Integer> ans = new ArrayList<Integer>();\n        int[] sCount = new int[26];\n        int[] pCount = new int[26];\n        for (int i = 0; i < pLen; ++i) {\n            ++sCount[s.charAt(i) - 'a'];\n            ++pCount[p.charAt(i) - 'a'];\n        }\n\n        if (Arrays.equals(sCount, pCount)) {\n            ans.add(0);\n        }\n\n        for (int i = 0; i < sLen - pLen; ++i) {\n            --sCount[s.charAt(i) - 'a'];\n            ++sCount[s.charAt(i + pLen) - 'a'];\n\n            if (Arrays.equals(sCount, pCount)) {\n                ans.add(i + 1);\n            }\n        }\n\n        return ans;\n    }\n}\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/52#issuecomment-2602544730","body":"```class Solution {\n    static int[] dx = {-1, 0, 1, 0};\n    static int[] dy = {0, 1, 0, -1};\n    int n;\n    int[][] grid;\n\n    public int maxDistance(int[][] grid) {\n        this.n = grid.length;\n        this.grid = grid;\n        int ans = -1;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 0) {\n                    ans = Math.max(ans, findNearestLand(i, j));\n                }\n            }\n        }\n        return ans;\n    }\n\n    public int findNearestLand(int x, int y) {\n        boolean[][] vis = new boolean[n][n];\n        Queue<int[]> queue = new LinkedList<int[]>();\n        queue.offer(new int[]{x, y, 0});\n        vis[x][y] = true;\n        while (!queue.isEmpty()) {\n            int[] f = queue.poll();\n            for (int i = 0; i < 4; ++i) {\n                int nx = f[0] + dx[i], ny = f[1] + dy[i];\n                if (!(nx >= 0 && nx < n && ny >= 0 && ny < n)) {\n                    continue;\n                }\n                if (!vis[nx][ny]) {\n                    queue.offer(new int[]{nx, ny, f[2] + 1});\n                    vis[nx][ny] = true;\n                    if (grid[nx][ny] == 1) {\n                        return f[2] + 1;\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n}\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/58#issuecomment-2614176301","body":"class Solution:\n    def longestCommonSubsequence(self, A: str, B: str) -> int:\n        m, n = len(A), len(B)\n        ans = 0\n        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if A[i - 1] == B[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                    ans = max(ans, dp[i][j])\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return ans","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"emergence23":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"0christ1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"junru281":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joe-the-plumber":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jsaki":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"witerth":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ludwig-ll":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luster-lyl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"smallppgirl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"realduxy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"awilekong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wwz223":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangjinzhepro":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"atom-set":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"coderxiaowq":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hillsonziqiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alexzhang-mini":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xil324":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bordergong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hawkins-hjq":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cathyshang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"greyqt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yanglimbo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rao-qianlin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dtjk":[null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/4#issuecomment-2514801113","body":"```c\nclass CustomStack {\npublic:\n    stack <int> stk;\n    int sz;\n    CustomStack(int maxSize) {\n       sz = maxSize; \n    }\n    \n    void push(int x) {\n        if ( stk.size() < sz ) stk.push(x);\n    }\n    \n    int pop() {\n        if ( !stk.empty() ) {\n            int val = stk.top() ;\n            stk.pop();\n            return val;\n        }\n        else return -1;\n    }\n    \n    void increment(int k, int val) {\n        stack <int> stk_;\n        while ( !stk.empty()  ) {stk_.push( stk.top() );stk.pop();}\n        while ( !stk_.empty() && k > 0 ) {\n            stk.push (stk_.top() + val);\n            stk_.pop();\n            k--;\n        }\n        while ( !stk_.empty() ) {\n            stk.push(stk_.top());\n            stk_.pop();\n        }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/5#issuecomment-2517837037","body":"```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack, res, multi = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append([multi, res])\n                res, multi = \"\", 0\n            elif c == ']':\n                cur_multi, last_res = stack.pop()\n                res = last_res + cur_multi * res\n            elif '0' <= c <= '9':\n                multi = multi * 10 + int(c)            \n            else:\n                res += c\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/6#issuecomment-2520505912","body":"```\nclass MyQueue {\npublic:\n    stack<int> skt1, skt2 ;\n    MyQueue() {\n        \n    }\n    \n    void push(int x) {\n       skt1.push (x) ; \n    }\n    \n    int pop() {\n        while (!skt1.empty()) {\n            skt2.push( skt1.top() );\n            skt1.pop();\n        }\n        int val = skt2.top();\n        skt2.pop();\n        while (!skt2.empty()) {\n            skt1.push(skt2.top());\n            skt2.pop();\n        }\n        return val;\n    }\n    \n    int peek() {\n        while (!skt1.empty()) {\n            skt2.push( skt1.top() );\n            skt1.pop();\n        }\n        int val = skt2.top();\n        \n        while (!skt2.empty()) {\n            skt1.push(skt2.top());\n            skt2.pop();\n        }\n        return val;\n    }\n    \n    bool empty() {\n        if (skt1.empty()) return 1 ;\n        else return 0 ;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/7#issuecomment-2523557669","body":"```\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = [arr[0]]\n        for i in range(1, len(arr)):\n            if stack and arr[i] < stack[-1]:\n                max_val = stack[-1]\n                while stack and arr[i] < stack[-1]:\n                    stack.pop()\n                stack.append(max_val)\n            else:\n                stack.append(arr[i])\n        return len(stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/8#issuecomment-2525212190","body":"```c++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        int cnt = 0 , value[510];\n        ListNode *p = head ;\n        while ( p != nullptr ) {\n            cnt++;\n            value[cnt] = p -> val;\n            p = p -> next;\n        }  \n        int value2[510] ;\n        for ( int i = 1; i <= cnt; i++ ) {\n            value2[ ( i + k ) % cnt ] = value[i] ;\n            if ( ( i+k) % cnt == 0 ) value2[cnt] = value[i]; \n        }\n        p = head ;\n        for ( int i = 1; i <= cnt; i++ ) {\n            p -> val = value2[i];\n            p = p -> next;\n        }\n        return head;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/9#issuecomment-2525439544","body":"```\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode *p = head ;\n        int cnt = 0, tmp ;\n        if ( p == nullptr ) return head;\n        while ( p != nullptr ) {\n            cnt++ ;\n            if ( cnt % 2 == 1 && p -> next!= nullptr) {\n                tmp = p -> val  ;\n                p -> val = p -> next -> val;\n                \n            }\n            else if ( cnt % 2 == 1 && p -> next == nullptr) break;\n            else p-> val = tmp;\n            p = p -> next ;\n        }\n         return head ;\n    }\n   \n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/10#issuecomment-2528479259","body":"```\nclass Solution:\ndef sortedListToBST(self, head: ListNode) -> TreeNode:\nif not head:\nreturn head\npre, slow, fast = None, head, head\n\n    while fast and fast.next:\n        fast = fast.next.next\n        pre = slow\n        slow = slow.next\n    if pre:\n        pre.next = None\n    node = TreeNode(slow.val)\n    if slow == fast:\n        return node\n    node.left = self.sortedListToBST(head)\n    node.right = self.sortedListToBST(slow.next)\n    return node\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/11#issuecomment-2532139380","body":"```\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n                A, B = headA, headB\n        while A != B:\n            A = A.next if A else headB\n            B = B.next if B else headA\n        return A\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/12#issuecomment-2533572982","body":"```c\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        unordered_map < ListNode *, int > mps;\n        ListNode *p = head;\n        if ( head == NULL ) return p;\n        mps[p] = 0;\n        for ( int  i = 0 ; ; i++ ) {\n            if ( i = 0 ) {\n                p = p -> next;\n                if ( p == NULL ) return p;\n                continue;\n            }\n            mps[p] = i ;\n            p = p -> next;\n            if ( mps.find (p) != mps.end()) return p;\n            if ( p == NULL ) return  p;\n        }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/13#issuecomment-2539177080","body":"```\nfrom collections import OrderedDict\nclass LRUCache(OrderedDict):\n\n    def __init__(self, capacity: int):\n        self.s = capacity\n        \n\n    def get(self, key: int) -> int:\n        if key in self:\n            self.move_to_end(key)\n            return self[key]\n        else:\n            return -1\n        \n\n    def put(self, key: int, value: int) -> None:\n        if key in self:\n            self.move_to_end(key)\n        self[key] = value\n        if len(self) > self.s:\n            self.popitem(last=False)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/14#issuecomment-2541753225","body":"```\nclass Solution(object):\n        def maxDepth(self, root):\n            \"\"\"\n            :type root: TreeNode\n            :rtype: int\n            \"\"\"\n            if not root:\n                return 0\n            left = self.maxDepth(root.left)\n            right = self.maxDepth(root.right)\n            return max(left, right) + 1\n```","onTime":true},null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/23#issuecomment-2558500821","body":"```\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        if (s.length()==0) return 0;\n        HashMap<Character, Integer> map = new HashMap<Character, Integer>();\n        int max = 0;\n        int left = 0;\n        for(int i = 0; i < s.length(); i ++){\n            if(map.containsKey(s.charAt(i))){\n                left = Math.max(left,map.get(s.charAt(i)) + 1);\n            }\n            map.put(s.charAt(i),i);\n            max = Math.max(max,i-left+1);\n        }\n        return max;\n        \n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/24#issuecomment-2559938226","body":"```\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> res = new ArrayList();\n        if (s == null || s.length() == 0 || words == null || words.length == 0){\n             return res;\n        }\n        int n = s.length();\n        int m = words.length;\n        int w = words[0].length();\n\n       Map<String, Integer> total = new HashMap();\n        for (String word : words) {\n            total.put(word, total.getOrDefault(word, 0) + 1);\n        }\n\n        for (int i = 0; i < w; ++i) {\n            HashMap<String, Integer> wd = new HashMap<>();\n            int cnt = 0; \n            for (int j = i; j + w <= n; j += w) {\n                 if (j >= i + w * m) {\n                    String word = s.substring(j - m * w, w + j - m * w); \n                    wd.put(word, wd.get(word) - 1); \n                    if (total.get(word) != null && wd.get(word) < total.get(word))\n                        cnt--;\n                }\n                String word = s.substring(j, j + w); \n                wd.put(word, wd.getOrDefault(word, 0) + 1); \n                if (total.get(word) != null && wd.get(word) <= total.get(word)){\n                    cnt++;\n                }\n                if (cnt == m){\n                    res.add(j - (m - 1) * w);\n                }\n            }\n        }\n        return res; \n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/25#issuecomment-2561250297","body":"```\nclass Solution {\n    public int minSubarray(int[] nums, int p) {\n        long sum = 0L;\n        for (var num : nums) sum += num;\n        int mod = (int) ((sum % p + p) % p);\n        \n        if (mod == 0) return 0;\n        \n        int n = nums.length;\n        int ans = n;\n        sum = 0L;\n        \n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0 , -1);\n\n        for (int i = 0; i < n; i++) {\n            sum += nums[i];\n            int curM = (int) ((sum % p + p) % p);\n            map.put(curM, i);\n            \n            int targetM = curM - mod + (curM >= mod ? 0 : p);\n            if (map.containsKey(targetM))\n                ans = Math.min(ans, i - map.get(targetM));\n        }\n        \n        return ans == n ? -1 : ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/26#issuecomment-2561935204","body":"```\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode *slow=head, *fast=head;\n        while(fast != nullptr && fast->next != nullptr){\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/27#issuecomment-2562877337","body":"```\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int n = nums.size();\n        if(n == 0){\n            return 0;\n        }\n        int fast = 1, slow = 1;\n        while(fast <= n-1){\n            if(nums[fast] != nums[fast-1]){\n                nums[slow++] = nums[fast]; \n            }\n            fast++;\n        }\n        return slow;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/28#issuecomment-2563269343","body":"```class Solution {\n    public int searchInsert(int[] nums, int target) {\n        int n = nums.length;\n        int left = 0, right = n - 1, ans = n;\n        while (left <= right) {\n            int mid = ((right - left) >> 1) + left;\n            if (target <= nums[mid]) {\n                ans = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return ans;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/29#issuecomment-2564305243","body":"```\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        int n = nums.size();\n        priority_queue<pair<int, int>> q;\n        for (int i = 0; i < k; ++i) {\n            q.emplace(nums[i], i);\n        }\n        vector<int> ans = {q.top().first};\n        for (int i = k; i < n; ++i) {\n            q.emplace(nums[i], i);\n            while (q.top().second <= i - k) {\n                q.pop();\n            }\n            ans.push_back(q.top().first);\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/30#issuecomment-2564746579","body":"```\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[] count = new int[n + 1];\n        for (int[] edge : trust) {\n            int x = edge[0];\n            int y = edge[1];\n            ++count[y];\n            --count[x];\n        }\n        for (int i = 1; i < n + 1; i++) {\n            if (count[i] == n - 1) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/31#issuecomment-2565623965","body":"```\nclass Solution {\npublic:\n    int p[4010];\n    int find(int x) {\n        if (p[x] != x) p[x] = find(p[x]);\n        return p[x];\n    }\n\n    void union_(int i, int j) {\n        p[find(i)] = p[find(j)];\n    }\n\n    bool connected(int i, int j) {\n        return find(i) == find(j);\n    }\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        for (int i = 1; i <= 2 * n; i++) p[i] = i;\n        for (vector<int> dis : dislikes) {\n            int a = dis[0], b = dis[1];\n            if (connected(a, b)) return false;\n            union_(a, b + n);\n            union_(b, a + n);\n        }\n        return true;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/32#issuecomment-2566000243","body":"```\nclass Solution {\npublic:\n    vector<int> topSort(vector<int>& deg, vector<vector<int>>& graph, vector<int>& items) {\n        queue<int> Q;\n        for (auto& item: items) {\n            if (deg[item] == 0) {\n                Q.push(item);\n            }\n        }\n        vector<int> res;\n        while (!Q.empty()) {\n            int u = Q.front(); \n            Q.pop();\n            res.emplace_back(u);\n            for (auto& v: graph[u]) {\n                if (--deg[v] == 0) {\n                    Q.push(v);\n                }\n            }\n        }\n        return res.size() == items.size() ? res : vector<int>{};\n    }\n\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {\n        vector<vector<int>> groupItem(n + m);\n\n        vector<vector<int>> groupGraph(n + m);\n        vector<vector<int>> itemGraph(n);\n\n        vector<int> groupDegree(n + m, 0);\n        vector<int> itemDegree(n, 0);\n        \n        vector<int> id;\n        for (int i = 0; i < n + m; ++i) {\n            id.emplace_back(i);\n        }\n\n        int leftId = m;\n        for (int i = 0; i < n; ++i) {\n            if (group[i] == -1) {\n                group[i] = leftId;\n                leftId += 1;\n            }\n            groupItem[group[i]].emplace_back(i);\n        }\n        for (int i = 0; i < n; ++i) {\n            int curGroupId = group[i];\n            for (auto& item: beforeItems[i]) {\n                int beforeGroupId = group[item];\n                if (beforeGroupId == curGroupId) {\n                    itemDegree[i] += 1;\n                    itemGraph[item].emplace_back(i);   \n                } else {\n                    groupDegree[curGroupId] += 1;\n                    groupGraph[beforeGroupId].emplace_back(curGroupId);\n                }\n            }\n        }\n\n        vector<int> groupTopSort = topSort(groupDegree, groupGraph, id); \n        if (groupTopSort.size() == 0) {\n            return vector<int>{};\n        } \n        vector<int> ans;\n        for (auto& curGroupId: groupTopSort) {\n            int size = groupItem[curGroupId].size();\n            if (size == 0) {\n                continue;\n            }\n            vector<int> res = topSort(itemDegree, itemGraph, groupItem[curGroupId]);\n            if (res.size() == 0) {\n                return vector<int>{};\n            }\n            for (auto& item: res) {\n                ans.emplace_back(item);\n            }\n        }\n        return ans;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/34#issuecomment-2567979294","body":"```\nclass Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        tasks = [(task[0], i, task[1]) for i, task in enumerate(tasks)]\n        tasks.sort()\n        backlog = []\n        time = 0\n        ans = []\n        pos = 0\n        for _ in tasks:\n            if not backlog:\n                time = max(time, tasks[pos][0])\n            while pos < len(tasks) and tasks[pos][0] <= time:\n                heapq.heappush(backlog, (tasks[pos][2], tasks[pos][1]))\n                pos += 1\n            d, j = heapq.heappop(backlog)\n            time += d\n            ans.append(j)\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/35#issuecomment-2569240339","body":"```\nclass Solution {\n    public int numberOfRounds(String loginTime, String logoutTime) {\n\n        String[] loginTimes = loginTime.split(\":\");\n        String[] logoutTimes = logoutTime.split(\":\");\n\n        int nums = 0;\n        int startTime = Integer.parseInt(loginTimes[0]) * 60 + Integer.parseInt(loginTimes[1]);\n        int endTime = Integer.parseInt(logoutTimes[0]) * 60 + Integer.parseInt(logoutTimes[1]);\n\n        if (endTime < startTime) {\n            endTime += (60 * 24);\n        }\n\n        endTime = endTime / 15 * 15;\n\n        return Math.max(0, (endTime - startTime)) / 15;\n\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/36#issuecomment-2571321793","body":"```\nclass Solution {\n    public int minCharacters(String a, String b) {\n        int n = a.length();\n        int m = b.length();\n        int ans = Integer.MAX_VALUE;\n        int[] c1 = new int[26];\n        int[] c2 = new int[26];\n        for (char c : a.toCharArray()){\n            c1[c - 'a']++;\n        }\n        for (char c : b.toCharArray()){\n            c2[c - 'a']++;\n        }\n        for (int i = 0; i < 26; i++) {\n            int ca = n - c1[i], cb = m - c2[i];\n            ans = Math.min(ans, ca + cb);\n            if (i == 0) {\n                continue;\n            }\n            int r1 = 0;\n            int r2 = 0;\n            for (int j = i; j < 26; j++) {\n                r1 += c1[j];\n            }\n            for (int j = 0; j < i; j++) {\n                r1 += c2[j];\n            }\n            for (int j = i; j < 26; j++) {\n                r2 += c2[j];\n            }\n            for (int j = 0; j < i; j++) {\n                r2 += c1[j];\n            }\n            ans = Math.min(ans, Math.min(r1, r2));\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/37#issuecomment-2571665654","body":"```\nclass Solution {\npublic:\n    vector<int> sortArray(vector<int>& nums) {\n        heapSort(nums);\n        return nums;\n    }\n    void maxHeapify(vector<int>& nums, int i, int length) {\n        while (2 * i + 1 < length){\n            int min_index = i;\n            if (2 * i + 1 < length && nums[2 * i + 1] > nums[min_index]) min_index = 2 * i + 1;\n            if (2 * i + 2 < length && nums[2 * i + 2] > nums[min_index]) min_index = 2 * i + 2;\n            if (min_index == i) break;\n            swap(nums[min_index], nums[i]);\n            i = min_index;\n        }\n    }\n    void heapSort(vector<int>& nums) {\n        for (int i = (nums.size() >> 1) - 1; i >= 0; i--) \n            maxHeapify(nums, i, nums.size());\n        int end = nums.size();\n        while(--end > 0) {\n            swap(nums[0], nums[end]);\n            maxHeapify(nums, 0, end);\n        }\n    }\n};\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/41#issuecomment-2580389590","body":"```\nclass Solution {\n    public int findRadius(int[] houses, int[] heaters) {\nArrays.sort(houses);\n        Arrays.sort(heaters);\n        int l = 0, r = (int) 1e9;\n        while (l < r) {\n            int mid = l + r >> 1;\n            if (check(houses, heaters, mid)) r = mid;\n            else l = mid + 1;\n        }\n        return r;\n    }\n    boolean check(int[] houses, int[] heaters, int x) {\n        int n = houses.length, m = heaters.length;\n        for (int i = 0, j = 0; i < n; i++) {\n            while (j < m && houses[i] > heaters[j] + x) j++;\n            if (j < m && heaters[j] - x <= houses[i] && houses[i] <= heaters[j] + x) continue;\n            return false;\n        }\n        return true;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/42#issuecomment-2582773532","body":"```\nclass Solution {\n    public int solve(int[] nums, int k) {\n        Arrays.sort(nums);\n        int absMin = 0;\n        int absMax = nums[nums.length-1] - nums[0];\n\n        while (absMin <= absMax) {\n            int absMid = (absMin + absMax) / 2;\n            if (count_not_greater(nums, absMid) <= k) {\n                absMin = absMid + 1;\n            } else {\n                absMax = absMid - 1;\n            }\n        }\n\n        return absMin;\n    }\n\n    private long count_not_greater(int[] nums, int targetDiff) {\n        long count = 0;\n\n        int l = 0;\n        for (int r=1; r<nums.length; r++) {\n            while (nums[r] - nums[l] > targetDiff) {\n                l++;\n            }\n\n            count += r - l;\n        }\n        return count;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/43#issuecomment-2585311159","body":"```\nclass Solution {\npublic:\n    typedef pair<int, int> PII;\n    int dirs[4][2] = {{1,0}, {-1,0}, {0,1}, {0,-1}};\n    int swimInWater(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int l = 0, r = n * n;\n        while (l < r) {\n            int mid = (l + r) >> 1;\n            if (dfs(grid, mid)) r = mid;\n            else l = mid + 1;\n        }\n        return l;\n    }\n\n    bool dfs(vector<vector<int>> &grid, int time) {\n        if (time < grid[0][0]) return false;\n        int n = grid.size();\n        vector<vector<bool>> vis(n, vector<bool>(n, false));\n        queue<PII> que;\n        que.push({0, 0});\n        vis[0][0] = true;\n        while (!que.empty()) {\n            auto [i, j] = que.front();\n            que.pop();\n            for (auto dir : dirs) {\n                int x = i + dir[0];\n                int y = j + dir[1];\n                if (x < 0 || y < 0 || x >= n || y >= n) continue;\n                if (grid[x][y] > time || vis[x][y] == true) continue;\n                vis[x][y] = true;\n                que.push({x, y});\n            }\n        }\n        return vis[n - 1][n - 1];\n    }\n};\n```\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/45#issuecomment-2587474119","body":"```\nclass Solution {\n     public double new21Game(int N, int K, int W) {\n        if (K == 0 || N >= K + W) return 1;\n        double dp[] = new double[N + 1],  Wsum = 1, res = 0;\n        dp[0] = 1;\n        for (int i = 1; i <= N; ++i) {\n            dp[i] = Wsum / W;\n            if (i < K) Wsum += dp[i]; else res += dp[i];\n            if (i - W >= 0) Wsum -= dp[i - W];\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/46#issuecomment-2590162134","body":"```\nclass Solution {\nprivate:\n    int sLen;\n    int pLen;\n    void initCount(string &s, string &p, vector<int> &sCount, vector<int> &pCount){\n        for(int i=0; i<pLen; i++){\n            sCount[s[i] - 'a']++;\n            pCount[p[i] - 'a']++;\n        }\n    }\npublic:\n    vector<int> findAnagrams(string s, string p) {\n        sLen = s.size();\n        pLen = p.size();\n        if(sLen < pLen){\n            return vector<int>();\n        }\n\n        vector<int> ans;\n        vector<int> sCount(26);\n        vector<int> pCount(26);\n        initCount(s, p, sCount, pCount);\n\n        if(sCount == pCount){\n            ans.emplace_back(0);\n        }\n        for(int i=0; i<sLen-pLen; i++){\n            sCount[s[i] - 'a']--;\n            sCount[s[i+pLen] - 'a']++;\n\n            if(sCount == pCount){\n                ans.emplace_back(i+1);\n            }\n        }\n        return ans;\n    }\n};\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/50#issuecomment-2599768489","body":"class Solution {\n    public int totalNQueens(int n) {\n        int[] rows = new int[n];\n        return process(0, rows, n);\n    }\n\n    private int process(int i, int[] rows, int n){\n        if(i == n){\n            return 1;\n        }\n        int res = 0;\n        for(int j = 0; j < n; j++){\n            if(isValid(rows, i, j)){\n                rows[i] = j;\n                res += process(i + 1, rows, n);\n            }\n        }\n        return res;\n    }\n\n    private boolean isValid(int[] rows, int i, int j){\n        for(int k = 0; k < i; k++){\n            if(rows[k] == j || Math.abs(i - k) == Math.abs(j - rows[k])){\n                return false;\n            }\n        }\n        return true;\n    }\n}","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/55#issuecomment-2609857845","body":"class Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        int n = cost.length;\n        int[] dp = new int[n+1];\n        dp[0] = dp[1] = 0;\n        for(int i = 2;i <= n;i++){\n            dp[i] = Math.min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);\n        }\n        return dp[n];\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/56#issuecomment-2612498741","body":"```class Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int size = nums.size();\n        if (size == 1) {\n            return nums[0];\n        }\n        \n        vector<int> count = vector<int>(size, 0);\n        count[0] = nums[0];\n        count[1] = max(nums[0], nums[1]);\n\n        for (int i = 2; i < size; i++) {\n            count[i] = max(count[i - 2] + nums[i], count[i - 1]);\n        }\n        return count[size - 1];\n    }\n};\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/58#issuecomment-2614457254","body":"```\nclass Solution {\n    public int longestCommonSubsequence(String text1, String text2) {\n        int n = text1.length();\n        int m = text2.length();\n        char[] charArray1 = text1.toCharArray();\n        char[] charArray2 = text2.toCharArray();\n        int[][] dp = new int[n + 1][m + 1];\n        int ans = 0;\n\n        for (int i = 1; i < n + 1; i++) {\n            for (int j = 1; j < m + 1; j++) {\n                if (charArray1[i-1] == charArray2[j-1]) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                    ans = Math.max(ans, dp[i][j]);\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return ans;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"martina001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lxy1108":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"franklinsworld666":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brainlds":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huamulanyyds":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eclairs46":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maike-hps":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sanjiu81":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qinmengx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yashuning":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luzhaofeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lizhao-liu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yukibei":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hermione666":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yyyyytc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zin-next":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pandapls":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jackinai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"godkun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dadahui":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"akxuan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fightforcoding":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jialigogogo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"celestexiong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zjy-debug":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"peggyhao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sleepydog25":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"edwineo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"panfx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liudi9047":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"allanli-lhh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xchen172":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qiaoeve":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tangyi23":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shangjiaw":[{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/2#issuecomment-2509519979","body":"### 思路\n先将数组转换成数字，然后运算后再将数字转换回数组\n\n### 代码\n```python\ndef addArrayInteger( A, K ):\n    res = ''.join([str(i) for i in A])\n    res = int(res) + K\n    return [int(i) for i in str(res)]\n\nprint(addArrayInteger([1,2,0,0], 34))\nprint(addArrayInteger([2,7,4], 181))\nprint(addArrayInteger([2,1,5], 806))\nprint(addArrayInteger([9,9,9,9,9,9,9,9,9,9], 1))\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)，其中 N 为数组长度。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/3#issuecomment-2510432857","body":"### 思路\n正向遍历一遍数组，记录每个字符和左边最近C字符的距离。\n反向遍历一遍数组，记录每个字符和右边最近C字符的距离。\n取两个数组每个位置上更小的那个值。\n\n### 代码\n```python\ndef shortestDistanceToC(S, C):\n    n = len(S)\n    res1 = [float('inf')] * n\n    res2 = [float('inf')] * n\n    \n    p = -1\n    for i in range(n):\n        if S[i] == C:\n            p = i\n        if p != -1:\n            res1[i] = i-p\n\n    p = -1\n    for i in range(n-1, -1, -1):\n        if S[i] == C:\n            p = i\n        if p != -1:\n            res2[i] = p-i\n            \n    return [min(res1[i],res2[i]) for i in range(n) ]\n    \nprint(shortestDistanceToC(\"loveleetcode\", 'e'))\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)，其中 N 为数组长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/4#issuecomment-2513243000","body":"class CustomStack:\n    def __init__(self, maxSize):\n        self.stack = []\n        self.size = 0\n        self.maxSize = maxSize\n        \n    def push(self, x):\n        if self.size < self.maxSize:\n            self.stack.append(x)\n            self.size += 1\n        else:\n            print(\"reach max size. cannot push.\")\n    \n    def pop(self):\n        if self.stack:\n            self.size -= 1\n            return self.stack.pop(-1)\n        else:\n            return -1\n    \n    def increment(self, k, val):\n        if self.size < k:\n            for i in range(self.size):\n                self.stack[i] += val\n        else:\n            for i in range(k):\n                self.stack[i] += val\n                \ncustomStack = CustomStack(3)\ncustomStack.push(1) #栈变为 [1]\ncustomStack.push(2) #栈变为 [1, 2]\nprint(customStack.pop()) #返回栈顶值 2，栈变为 [1]\ncustomStack.push(2) #栈变为 [1, 2]\ncustomStack.push(3) #栈变为 [1, 2, 3]\ncustomStack.push(4) #栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\ncustomStack.increment(5, 100) #栈变为 [101, 102, 103]\ncustomStack.increment(2, 100) #栈变为 [201, 202, 103]\nprint(customStack.pop()) #返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\nprint(customStack.pop()) #返回 202 --> 返回栈顶值 202，栈变为 [201]\nprint(customStack.pop()) #返回 201 --> 返回栈顶值 201，栈变为 []\nprint(customStack.pop()) #返回 -1 --> 栈为空，返回 -1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/5#issuecomment-2516048437","body":"### 代码\n\n\n```python\ndef decodeString(s):\n    res = []\n    \n    for i in s:\n        if i != ']':\n            res.append(i)\n        else:\n            subString = ''\n            while res[-1] != '[':\n                subString = res.pop() + subString\n            res.pop()\n                \n            k = ''\n            while res and res[-1].isdigit():\n                k = res.pop() + k\n                \n            res.append( subString * int(k) )    \n            \n    return ''.join(res)\n                \nprint(decodeString(\"3[a]2[bc]\"))\n#\"aaabcbc\"\n\nprint(decodeString(\"3[a2[c]]\"))\n#\"accaccacc\"\n\nprint(decodeString(\"2[abc]3[cd]ef\"))\n#\"abcabccdcdcdef\"\n\nprint(decodeString(\"abc3[cd]xyz\"))\n#\"abccdcdcdxyz\"\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/6#issuecomment-2518967943","body":"### 思路\nUse two stacks, stack 1 saves elements in the order received and stack 2 is used for peek and pop (reverse order of the elements).\nFor push, add elements to stack 1\nFor pop, check if stack 2 is empty. If yes, move all elements from stack 1 to stack 2 (reversed order). Pop the last element of stack 2.\nFor peek. check if stack 2 is empty. If yes, move all elements from stack 1 to stack 2 (reversed order). Return the last element of stack 2.\nFor empty, check if both stack 1 and stack2 are empty.\n\n### 代码\n```python\nclass MyQueue:\n  def __init__(self):\n    self.s1 = []\n    self.s2 = []\n\n  def push(self, x):\n    self.s1.append(x)\n\n  def pop(self):\n    if not self.s2:\n      while self.s1:\n        self.s2.append(self.s1.pop())\n    return self.s2.pop()\n\n  def peek(self):\n    if not self.s2:\n      while self.s1:\n        self.s2.append(self.s1.pop())\n    return self.s2[-1]\n    \n  def empty(self):\n    return len(self.s1) == 0 and len(self.s2) == 0\n\nqueue = MyQueue()\nqueue.push(1)\nqueue.push(2)\nprint(queue.peek()) #1\nprint(queue.pop()) #1\nprint(queue.empty()) #False\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/7#issuecomment-2522027548","body":"### 思路\nCompare prefix sum of sorted and unsorted array\n\n### 代码\n```python\n\ndef maxChunksToSorted( array ):\n  res, s1, s2 = 0, 0, 0\n  for x, y in zip(array, sorted(array)):\n    s1 += x\n    s2 += y\n    res += int(s1==s2)\n  return res\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(nlogn) for sorting\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/8#issuecomment-2524855285","body":"### 代码\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or k==0:\n            return head\n\n        length = 1\n        tail = head\n        while tail.next:\n            tail = tail.next\n            length += 1\n\n        k = k % length\n        tail.next = head\n        \n        newTail = head\n        for _ in range(length-k-1):\n            newTail = newTail.next\n\n        head = newTail.next\n        newTail.next = None\n        return head\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/9#issuecomment-2525363969","body":"### 代码\n```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode(0, head)\n        pre, cur = dummy, head\n\n        while cur and cur.next:\n            # save temp pointers\n            nextPair = cur.next.next\n            second = cur.next\n            # swap pair\n            second.next = cur\n            cur.next = nextPair\n            pre.next = second\n            # update pointers\n            pre = cur\n            cur = nextPair\n\n        return dummy.next\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/10#issuecomment-2526683670","body":"### 代码\n```python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        nums = []\n        while head:\n            nums.append(head.val)\n            head = head.next\n\n        def helper(l, r):\n            if l > r:\n                return None\n            \n            m = (l + r) // 2\n            root = TreeNode( nums[m] )\n            root.left = helper(l, m-1)\n            root.right = helper(m+1, r)\n            return root\n\n        return helper(0, len(nums)-1)\n        \n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/11#issuecomment-2530111458","body":"### 代码\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        ptr1, ptr2 = headA, headB\n\n        while ptr1 != ptr2:          \n            ptr1 = ptr1.next if ptr1 else headB\n            ptr2 = ptr2.next if ptr2 else headA\n\n        return ptr1\n```\n\n**复杂度分析**\n- 时间复杂度：O(m+n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/12#issuecomment-2533564618","body":"class Solution(object):\n    def detectCycle(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n            if slow == fast:\n                break\n\n        else:\n            return None\n\n        fast = head\n        while slow != fast:\n            slow = slow.next\n            fast = fast.next\n        \n        return slow","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/13#issuecomment-2537500729","body":"#use double linked list and hash map\nclass Node:\n    def __init__(self, key = 0, val =0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\nclass LRUCache(object):\n\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.capacity = capacity\n        self.cache = {}\n        self.head = Node() # least recent\n        self.tail = Node() # most recent\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def remove(self, node):\n        prev, nxt = node.prev, node.next\n        prev.next = nxt\n        nxt.prev = prev\n    \n    def insert(self, node):\n        prev, nxt = self.tail.prev, self.tail\n        prev.next = node\n        nxt.prev = node\n        node.prev = prev\n        node.next = nxt\n\n    def get(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: int\n        \"\"\"\n        if key in self.cache:\n            self.remove(self.cache[key])\n            self.insert(self.cache[key])\n            return self.cache[key].val\n        return -1\n\n    def put(self, key, value):\n        \"\"\"\n        :type key: int\n        :type value: int\n        :rtype: None\n        \"\"\"\n        if key in self.cache:\n            self.remove(self.cache[key])\n\n        self.cache[key] = Node(key, value)\n        self.insert(self.cache[key])\n\n        if self.capacity < len(self.cache):\n            lru = self.head.next\n            self.remove(lru)\n            del self.cache[lru.key]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/14#issuecomment-2540369682","body":"### 代码\r\n```python\r\n\r\nclass Solution(object):\r\n    def maxDepth(self, root):\r\n        \"\"\"\r\n        :type root: Optional[TreeNode]\r\n        :rtype: int\r\n        \"\"\"\r\n        if not root:\r\n            return 0\r\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\r\n```\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(log(n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/15#issuecomment-2542652279","body":"```python\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: Optional[TreeNode]\n        :type q: Optional[TreeNode]\n        :rtype: bool\n        \"\"\"\n        if p is None and q is None: return True\n        if p is None or q is None: return False\n        if p.val == q.val:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n        return False\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/16#issuecomment-2543424159","body":"### 思路\ndepth first search traversal\nuse one variable to accumulate the value of nodes traveled so far\n\n### 代码\n```python\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        def dfs(node, pathSum):\n            if not node: return 0\n            pathSum = pathSum * 10 + node.val\n            if not node.left and not node.right:\n                return pathSum\n            return dfs(node.left, pathSum) + dfs(node.right, pathSum)\n        \n        return dfs(root, 0)\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/17#issuecomment-2544176729","body":"### 代码\n```python\nclass Solution(object):\n    def findBottomLeftValue(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        \n        res = None\n        stack = [root]\n        while stack:\n            node = stack.pop(0)\n            res = node.val\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n\n        return res\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/18#issuecomment-2547184445","body":"```python\nclass Codec:\n\n    def serialize(self, root):\n        res = []\n        def dfs(node):\n            if not node:\n                res.append(\"N\")\n                return \n            res.append(str(node.val))\n            dfs(node.left)\n            dfs(node.right)\n\n        dfs(root)\n        return \",\".join(res)\n\n    def deserialize(self, data):\n        vals = data.split(\",\")\n        def dfs():\n            val = vals.pop(0)\n            if val == \"N\":\n                return None\n            \n            node = TreeNode(int(val))\n            node.left = dfs()\n            node.right = dfs()\n\n            return node\n\n        return dfs()\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/19#issuecomment-2550056583","body":"```python\nclass Solution(object):\n    def verticalTraversal(self, root):\n        if not root:\n            return []\n\n        min_col, max_col = 0, 0\n        q = collections.deque()\n        items = collections.defaultdict(list)\n        q.append((root, 0, 0))\n\n        while q:\n            node, row, col = q.popleft()\n            if col < min_col:\n                min_col = col\n            if col > max_col:\n                max_col = col\n\n            items[col].append((node.val, row))\n\n            if node.left:\n                q.append((node.left, row + 1, col - 1))\n            if node.right:\n                q.append((node.right, row + 1, col + 1))\n\n        res = []\n        for i in range(min_col, max_col + 1):\n            item = items[i]\n            item.sort(key = lambda x: (x[1], x[0]))\n            res.append([x[0] for x in item])\n\n        return res\n\n```\n**复杂度分析**\n- 时间复杂度：O(NlogN)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/20#issuecomment-2552569087","body":"### 代码\n```python\nclass Solution(object):\n    def twoSum(self, nums, target):\n        seen = dict()\n        for i in range(len(nums)):\n            if nums[i] in seen:\n                return [seen[nums[i]], i]\n\n            seen[target-nums[i]] = i\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/21#issuecomment-2555672137","body":"### 代码\n```python\nclass Solution(object):\n    def topKFrequent(self, nums, k):\n        \n        res = dict()\n\n        for num in nums:\n            if num in res:\n                res[num] += 1\n            else:\n                res[num] = 1\n\n        res_sort = dict( sorted(res.items(), key = lambda item: item[1]), reverse = True)\n\n        return list(res_sort.keys())[:k]\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(NlogN)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/22#issuecomment-2557632541","body":"```python\nclass Solution(object):\n    def numberOfBoomerangs(self, points):\n        n = 0\n        for x1, y1 in points:\n            count = dict()\n            for x2, y2 in points:\n                distance = (x1-x2)**2 + (y1-y2)**2\n                if distance in count:\n                    n += 2 * count[distance]\n                    count[distance]+=1\n                else:\n                    count[distance] = 1\n        return n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N^2)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/23#issuecomment-2558317705","body":"### 代码\n```python\nclass Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        left = 0\n        res = 0\n\n        subset = set()\n        for right in range(len(s)):\n            while s[right] in subset:\n                subset.remove(s[left])\n                left += 1\n\n            subset.add( s[right] )\n            res = max(res, right-left+1)\n        \n        return res\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/24#issuecomment-2558843050","body":"```python\nclass Solution(object):\n    def findSubstring(self, s, words):\n        word_length = len(words[0])\n        word_n = len(words)\n        word_count = collections.Counter(words)\n        n = len(s)        \n\n        def helper(i):\n            word_copy = word_count.copy()\n            used = 0\n            for j in range(i, i + word_length * word_n, word_length):\n                sub = s[j : j + word_length]\n                if word_copy[sub] >= 1:\n                    word_copy[sub] -= 1\n                    used += 1\n                else:\n                    break\n\n            return used == word_n # word_count.total()\n\n        ans = []\n        for i in range(n - word_n * word_length + 1):\n            if helper(i):\n                ans.append(i)\n\n        return ans\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/25#issuecomment-2560572431","body":"### 代码\n```python\nclass Solution(object):\n    def minSubarray(self, nums, p):\n        n = len(nums)\n        total_sum = 0\n\n        for num in nums:\n            total_sum += num\n\n        target = total_sum % p\n        if target == 0:\n            return 0\n\n        mod_map = { 0: -1 } \n        current_sum = 0\n        min_len = n\n\n        for i in range(n):\n            current_sum = (current_sum + nums[i]) % p\n            needed = (current_sum - target + p) % p\n\n            if needed in mod_map:\n                min_len = min(min_len, i - mod_map[needed])\n\n            mod_map[current_sum] = i\n\n        return -1 if min_len == n else min_len\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/26#issuecomment-2561488555","body":"```python\r\nclass Solution(object):\r\n    def middleNode(self, head):\r\n        slow, fast = head, head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n\r\n        return slow\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/27#issuecomment-2562099532","body":"```python\n\nclass Solution(object):\n    def removeDuplicates(self, nums):\n        slow, fast = 0, 1\n        while fast in range(len(nums)):\n            if nums[slow] == nums[fast]:\n                fast += 1\n            else:\n                nums[slow+1] = nums[fast]\n                fast += 1\n                slow += 1\n        \n        return slow + 1\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/28#issuecomment-2563189234","body":"```python\n\nclass Solution(object):\n    def searchInsert(self, nums, target):\n        left, right = 0, len(nums)-1\n        while left <=right:\n            mid = (left + right) / 2\n            if nums[mid] < target:\n                left = mid+1\n            elif nums[mid] > target:\n                right = mid-1\n            else: \n                return mid\n\n        return left\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(logN)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/29#issuecomment-2564098452","body":"```python\n\nclass Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        dq = collections.deque()\n        res = []\n\n        for i in range(k):\n            while dq and nums[i]>=nums[dq[-1]]:\n                dq.pop()\n            dq.append(i)\n\n        res.append(nums[dq[0]])\n\n        for i in range(k, len(nums)):\n            if dq and dq[0] == i - k:\n                dq.popleft()\n            while dq and nums[i]>=nums[dq[-1]]:\n                dq.pop()\n            dq.append(i)\n            res.append(nums[dq[0]])\n           \n        return res\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/30#issuecomment-2564571143","body":"```python\n\nclass Solution(object):\n    def findJudge(self, n, trust):\n        if len(trust) < n-1:\n            return -1\n        \n        indegree = [0] * n\n        outdegree = [0] * n\n\n        for a, b in trust:\n            outdegree[a-1] += 1\n            indegree[b-1] += 1\n\n        for i in range(n):\n            if indegree[i]==n-1 and outdegree[i]==0:\n                return i+1\n        \n        return -1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/31#issuecomment-2564876877","body":"class Solution(object):\n    def possibleBipartition(self, n, dislikes):\n        g = collections.defaultdict(list)\n        for (u, v) in dislikes:\n            g[u].append(v)\n            g[v].append(u)\n        \n        group_mapping = {}\n        visited = set()\n        for i in range(1, n + 1):\n            if i in visited: \n                continue\n            stack = collections.deque([(i, 0)])\n            while stack:\n                cur_node, group = stack.popleft()\n                if cur_node in group_mapping and group != group_mapping[cur_node]:\n                    return False\n                if cur_node in visited: \n                    continue\n                group_mapping[cur_node] = group\n                visited.add(cur_node)\n                for child in g[cur_node]:\n                    stack.append((child, not group))\n    \n        return True  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/32#issuecomment-2566072295","body":"```python\nclass Solution(object):\n    def sortItems(self, n, m, group, beforeItems):\n        def assignGroupIds():\n            group_id = m\n            for i in range(n):\n                if group[i] == -1:\n                    group[i] = group_id\n                    group_id += 1\n            return group_id\n\n        def buildGraph(group_id):\n            item_graph = defaultdict(list)\n            group_graph = defaultdict(list)\n            item_indegree = [0] * n\n            group_indegree = [0] * group_id\n\n            for i in range(n):\n                for prereq in beforeItems[i]:\n                    item_graph[prereq].append(i)\n                    item_indegree[i] += 1\n                    if group[prereq] != group[i]:\n                        group_graph[group[prereq]].append(group[i])\n                        group_indegree[group[i]] += 1\n            \n            return item_graph, group_graph, item_indegree, group_indegree\n\n        def topologicalSort(graph, indegree):\n            res = []\n            q = deque()\n            for i in range(len(indegree)):\n                if indegree[i] == 0:\n                    q.append(i)\n\n            while q:\n                current = q.popleft()\n                res.append(current)\n                for neighbour in graph[current]:\n                    indegree[neighbour] -= 1\n                    if indegree[neighbour] == 0:\n                        q.append(neighbour)\n\n            return res if len(res) == len(indegree) else []\n\n        # step 1: assign group id to items that do not belong to any group\n        group_id = assignGroupIds()\n        \n        # step 2: build item and group dependency graph and indegree\n        item_graph, group_graph, item_indegree, group_indegree = buildGraph(group_id)\n\n        # step 3: perform topological sort for both item and group\n        item_sort = topologicalSort(item_graph, item_indegree)\n        group_sort = topologicalSort(group_graph, group_indegree)\n        if not item_sort or not group_sort:\n            return []\n\n        # step 4: sort items in each group\n        ordered_group = defaultdict(list)\n        for item in item_sort:\n            ordered_group[group[item]].append(item)\n\n        # step 5: concat sorted items in each group by group order\n        final_order = []\n        for group in group_sort:\n            final_order.extend(ordered_group[group])\n        \n        return final_order\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n^2)\n- 空间复杂度：O(n^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/33#issuecomment-2566794435","body":"```python\n\nclass Solution(object):\n    def judgeCircle(self, moves):\n        x = y = 0\n        for move in moves:\n            if move == 'U': y -= 1\n            elif move == 'D': y += 1\n            elif move == 'L': x -= 1\n            elif move == 'R': x += 1\n\n        return x == y == 0\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/34#issuecomment-2567236696","body":"```python\n\nclass Solution(object):\n    def getOrder(self, tasks):\n        next_task = []\n        tasks_processing_order = []\n        curr_time = 0\n        task_index = 0\n\n        sorted_tasks = [(enqueue, process, idx) for idx, (enqueue, process) in enumerate(tasks)]\n        sorted_tasks.sort()\n        \n        while task_index < len(tasks) or next_task:\n            if not next_task and curr_time < sorted_tasks[task_index][0]:\n                curr_time = sorted_tasks[task_index][0]\n            \n            while task_index < len(sorted_tasks) and curr_time >= sorted_tasks[task_index][0]:\n                _, process_time, original_index = sorted_tasks[task_index]\n                heapq.heappush(next_task, (process_time, original_index))\n                task_index += 1\n            \n            process_time, index = heapq.heappop(next_task)\n            \n            curr_time += process_time\n            tasks_processing_order.append(index)\n\n        return tasks_processing_order","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/35#issuecomment-2568528237","body":"```python\n\nclass Solution(object):\n    def numberOfRounds(self, loginTime, logoutTime):\n        in_hour, in_min = int(loginTime[:2]), int(loginTime[-2:])\n        out_hour, out_min = int(logoutTime[:2]), int(logoutTime[-2:])\n\n        in_min = in_min if in_min % 15 == 0 else in_min // 15 * 15 + 15\n        in_total = in_hour * 60 + in_min\n        out_min = out_min if out_min % 15 == 0 else out_min // 15 * 15\n        out_total = out_hour * 60 + out_min\n\n        total = out_total - in_total if out_total > in_total else out_total - in_total + 24 * 60\n        return total / 15\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/36#issuecomment-2569993054","body":"```python\nclass Solution(object):\n    def minCharacters(self, a, b):\n        c1 = Counter(a)\n        c2 = Counter(b)\n        res3 = len(a) + len(b) - max((c1 + c2).values())\n\n        preSum1, preSum2 = [c1.get(\"a\",0)], [c2.get(\"a\",0)]\n        res1 = res2 = len(a) + len(b)\n        for i in range(1, 26):\n            preSum1.append(c1.get(chr(97+i),0)+preSum1[-1])            \n            preSum2.append(c2.get(chr(97+i),0)+preSum2[-1])\n            res1 = min(res1, len(a)-preSum1[i-1]+preSum2[i-1])\n            res2 = min(res2, len(b)+preSum1[i-1]-preSum2[i-1])\n\n        return min(res1, res2, res3)\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/37#issuecomment-2571479613","body":"```python\n\nclass Solution:\n    def sortArray(self, nums):\n            counts = {}\n            minVal, maxVal = min(nums), max(nums)\n            for val in nums:\n                counts[val] = counts.get(val, 0) + 1\n            index = 0\n            for val in range(minVal, maxVal + 1):\n                while counts.get(val, 0) > 0:\n                    nums[index] = val\n                    index += 1\n                    counts[val] -= 1\n\n        return nums\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/38#issuecomment-2572180388","body":"```python\n\nclass Solution:\n\tdef mySqrt(self, x):\n\t\tif x == 0: return 0\n\t\tleft, right = 1, x\n\t\twhile left <= right:\n\t\t\tmid = (left + right)//2\n\t\t\tif mid * mid == x:\n\t\t\t\treturn mid\n\t\t\telif mid * mid < x:\n\t\t\t\tleft = mid + 1\n\t\t\telse:\n\t\t\t\tright = mid - 1\n\t\treturn right\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/39#issuecomment-2574284132","body":"```python\n\nclass Solution(object):\n    def firstBadVersion(self, n):\n        l, r = 1, n\n        while l < r:\n            mid = (l+r)//2\n            if isBadVersion(mid):\n                r = mid\n            else:\n                l = mid + 1\n\n        return l\n\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/41#issuecomment-2579098129","body":"Leetcode 475\n\n```python\nclass Solution(object):\n    def findRadius(self, houses, heaters):\n        res = 0\n\n        for h in houses:\n\n            left = bisect.bisect_right(heaters, h) - 1\n            right = bisect.bisect_left(heaters, h)\n            if left < 0:\n                res = max(res, heaters[0]-h)\n\n            elif right >= len(heaters):\n                res = max(res, h-heaters[-1])\n\n            else:\n                res = max(res, min(h-heaters[left],heaters[right]-h))\n\n        return res\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/42#issuecomment-2581430042","body":"```python\nclass Solution(object):\n    def smallestDistancePair(self, nums, k):\n        n = len(nums)\n        max_num = max(nums)\n        distance_bucket = [0] * (max_num + 1)\n\n        for i in range(n):\n            for j in range(i+1, n):\n                distance = abs(nums[i] - nums[j])\n                distance_bucket[distance] += 1\n\n        for d in range(max_num + 1):\n            k -= distance_bucket[d]\n            if k <= 0:\n                return d \n        \n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n^2)\n- 空间复杂度：O(m) m is maximum number","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/44#issuecomment-2585470413","body":"```python\nclass Solution(object):\n    def maxVowels(self, s, k):\n        vowel = ['a', 'e', 'i', 'o', 'u']\n        res = 0\n        currRes = 0\n\n        for i in range(k):\n            currRes += int(s[i] in vowel)\n        res = currRes\n\n        for i in range(k, len(s)):\n            currRes += int(s[i] in vowel)\n            currRes -= int(s[i-k] in vowel)\n            res = max(res, currRes)\n\n        return res\n       \n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1) ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/46#issuecomment-2588483941","body":"```python\nclass Solution(object):\n    def findAnagrams(self, s, p):\n        len_s, len_p = len(s), len(p)\n        count_s, count_p = Counter(), Counter(p)\n        res = []\n\n        for i in range(len_p):\n            count_s[s[i]] += 1\n        if count_s == count_p:\n            res.append(0)\n\n        for i in range(len_p, len_s):\n            count_s[s[i]] += 1\n            if count_s[s[i-len_p]] == 1:\n                del count_s[s[i-len_p]]\n            else:\n                count_s[s[i-len_p]] -= 1\n\n            if count_s == count_p:\n                res.append(i - len_p + 1)\n\n        return res\n       \n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1) ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/48#issuecomment-2599467281","body":"```python\nclass Solution(object):\n    def maxScore(self, cardPoints, k):\n        n = len(cardPoints)\n        res = sum(cardPoints[n-k:])\n        s = res\n        for i in range(k):\n            s += cardPoints[i]\n            s -= cardPoints[-(k-i)]\n            res = max(res, s)\n        return res\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/49#issuecomment-2597125443","body":"class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        ans = []\n        for h in range(12):\n            for m in range(60):\n                if (bin(h)+bin(m)).count('1') == turnedOn:\n                    ans.append(f\"{h}:{m:02d}\")\n        return ans\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/50#issuecomment-2599327849","body":"```python\nclass Solution(object):\n    def totalNQueens(self, n):\n        self.res=0\n        visited_cols=set()\n        visited_diagonals=set()\n        visited_antidiagonals=set()\n        \n        res=set()\n        def backtrack(r):\n            if r==n:\n                self.res+=1\n                        \n            for c in range(n):\n                if not(c in visited_cols or (r-c) in visited_diagonals or (r+c) in visited_antidiagonals):\n                    visited_cols.add(c)\n                    visited_diagonals.add(r-c)\n                    visited_antidiagonals.add(r+c)\n                    backtrack(r+1)\n                    \n                    visited_cols.remove(c)\n                    visited_diagonals.remove(r-c)\n                    visited_antidiagonals.remove(r+c)\n                        \n        backtrack(0)\n        return self.res\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n!)\n- 空间复杂度：O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/51#issuecomment-2600271435","body":"```python\nclass Solution(object):\n  def maxAreaOfIsland(self, grid):\n        seen = set()\n        def area(r, c):\n            if not (0 <= r < len(grid) and 0 <= c < len(grid[0]) and (r, c) not in seen and grid[r][c]):\n                return 0\n            seen.add((r, c))\n            return (1 + area(r+1, c) + area(r-1, c) + area(r, c-1) + area(r, c+1))\n\n        return max(area(r, c) for r in range(len(grid)) for c in range(len(grid[0])))         \n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/54#issuecomment-2605290137","body":"```python\n\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        results = defaultdict(list)\n        \n        queue = [ (root, 0, 0) ]\n        \n        while queue:\n            node, pos, depth = queue.pop(0)\n            if not node: continue\n            results[(pos,depth)].append(node.val)\n            results[(pos,depth)].sort()\n            queue.extend( [ (node.left, pos-1, depth+1), (node.right, pos+1, depth+1) ] )\n            \n            \n        res = defaultdict(list)\n        keys = sorted(list(results.keys()), key=lambda x: (x[0], x[1]))\n        \n        \n        for k in keys:\n            pos, depth = k\n            res[pos].extend(results[k])\n\n        return res.values()\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/55#issuecomment-2608643073","body":"```python\n\nclass Solution:\n    def minCostClimbingStairs(self, cost):\n        if not cost:\n            return 0\n\t\t\t\n        dp = [0] * len(cost)\n        dp[0] = cost[0]\n\t\t\n        if len(cost) >= 2:\n            dp[1] =cost[1]\n\n        for i in range(2, len(cost)):\n            dp[i] = cost[i] + min(dp[i-1], dp[i-2])\n\n        return min(dp[-1], dp[-2])\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/57#issuecomment-2613765588","body":"```python \nclass Solution:\n    def findNumberOfLIS(self, nums):\n        if not nums: return 0\n        n = len(nums)\n        m, dp, cnt = 0, [1] * n, [1] * n\n        for i in range(n):\n            for j in range(i):\n                if nums[j] < nums[i]:\n                    if dp[i] < dp[j]+1: dp[i], cnt[i] = dp[j]+1, cnt[j]\n                    elif dp[i] == dp[j]+1: cnt[i] += cnt[j]\n            m = max(m, dp[i])                        \n        return sum(c for l, c in zip(dp, cnt) if l == m)\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n^2)\n- 空间复杂度：O(n) ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tongxw":[{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/2#issuecomment-2509522870","body":"```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n = num.length;\n        int carry = 0;\n        List<Integer> ans = new ArrayList<>(); // SC O(max(n, log k))\n        for (int i=n-1; i>=0 || k > 0; i--) { // TC O(max(n, log k))\n            int sum = (i >= 0 ? num[i] : 0) + k % 10 + carry; // 当前位\n            carry = sum / 10; // 进位\n            ans.add(sum % 10); // 记录结果\n\n            k /= 10; // k向左移\n        }\n\n        if (carry == 1) {\n            ans.add(1); // 最后如果有进位\n        }\n\n        Collections.reverse(ans); // TC O(max(n, log k))\n        return ans;\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/3#issuecomment-2510489922","body":"```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int distance = n + 1;\r\n\r\n        // 统计s[i]距离左边c的距离\r\n        int[] minDistance = new int[n]; // SC O(n)\r\n        for (int i=0; i<n; i++) { // TC O(n)\r\n            distance = s.charAt(i) == c ? 0 : distance + 1;\r\n            minDistance[i] = distance;\r\n        }\r\n\r\n        // 统计s[i]距离右边c的距离, 并且求左右两侧最小\r\n        distance = n + 1;\r\n        for (int i=n-1; i>=0; i--) { // TC O(n)\r\n            distance = s.charAt(i) == c ? 0 : distance + 1;\r\n            minDistance[i] = Math.min(minDistance[i], distance);\r\n        }\r\n\r\n        return minDistance;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/4#issuecomment-2513626200","body":"```java\r\nclass CustomStack {\r\n    Deque<Integer> stack; // SC O(n)\r\n    int maxSize;\r\n\r\n    // 用增量数数组记录增量，出栈时加到栈顶元素\r\n    int[] incr; // SC O(n)\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.stack = new LinkedList<>();\r\n        this.maxSize = maxSize;\r\n        incr = new int[maxSize + 1];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (stack.size() == maxSize) {\r\n            return;\r\n        }\r\n\r\n        stack.push(x); // TC O(1)\r\n        \r\n    }\r\n    \r\n    public int pop() {\r\n        int size = stack.size();\r\n        if (size == 0) {\r\n            return -1;\r\n        }\r\n\r\n        // stack内容如下:\r\n        // [va1, val2, val3, val4]\r\n        //  ^                 ^\r\n        // bottom             top\r\n\r\n        // incr数组内容如下:\r\n        // [ 0,  0,   incr_val, 0]\r\n        //   ^           ^\r\n        // not_used    incr[2] = incr_val，代表stack底部的2个元素都会增加incr_val\r\n\r\n        int top = stack.pop();\r\n        int incr_val = incr[size];\r\n\r\n        if (incr_val != 0) {\r\n            top += incr_val;\r\n\r\n            incr[size - 1] += incr_val;\r\n            incr[size] = 0;\r\n        }\r\n\r\n\r\n        return top; // TC O(1)\r\n    }\r\n    \r\n    public void increment(int k, int val) { // TC O(1)\r\n        int total = Math.min(k, stack.size());\r\n        incr[total] += val;\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/5#issuecomment-2516312539","body":"```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Deque<String> strStack = new LinkedList<>();\r\n        Deque<Integer> numStack = new LinkedList<>();\r\n\r\n        int number = 0;\r\n        StringBuilder ans = new StringBuilder();\r\n\r\n        // number can be more than 1 digit\r\n        // two stacks for the decoded string and number\r\n        for (char c : s.toCharArray()) {\r\n             if (Character.isDigit(c)) {\r\n                number = number * 10 + (c - '0');\r\n\r\n             } else if (Character.isLetter(c)) {\r\n                ans.append(c);\r\n             } else if (c == '[') {\r\n                // push the number and sub string to the stack\r\n                numStack.push(number);\r\n                number = 0;\r\n\r\n                strStack.push(ans.toString());\r\n                ans.setLength(0);\r\n             } else {\r\n                // repeat the string\r\n                int repeat = numStack.pop();\r\n                String cur = ans.toString();\r\n                ans.setLength(0);\r\n                while (repeat-- > 0) {\r\n                    ans.append(cur);\r\n                }\r\n\r\n                // append the repeated string to the top string of the stack\r\n                String top = strStack.pop();\r\n                String appendString = top + ans.toString();\r\n\r\n                // decode complete\r\n                ans = new StringBuilder(appendString);\r\n\r\n             }\r\n        }\r\n\r\n        return ans.toString();\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/6#issuecomment-2519153578","body":"```java\r\nclass MyQueue {\r\n    Deque<Integer> inStack;\r\n    Deque<Integer> outStack;\r\n\r\n    public MyQueue() {\r\n        inStack = new LinkedList<>();\r\n        outStack = new LinkedList<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (peek() == -1) {\r\n            return -1;\r\n        }\r\n\r\n        return outStack.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (empty()) {\r\n            return -1;\r\n        }\r\n\r\n        if (outStack.isEmpty()) {\r\n            // 翻转inStack到outStack,保证FIFO\r\n            while (!inStack.isEmpty()) {\r\n                outStack.push(inStack.pop());\r\n            }\r\n        }\r\n\r\n        return outStack.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return inStack.isEmpty() && outStack.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/7#issuecomment-2522267024","body":"```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        // 对于位置i，\r\n        // 如果[0...i]的最大值(记为maxFromLeft) 小于等于 [i+1...n-1]的最小值(记为minFromRight)，说明此时可以分块，不影响整体排序\r\n        // 否则就不能排序，因为maxFromLeft > minFromRight时，maxFromLeft在排序后必须挪到右侧\r\n\r\n        int n = arr.length;\r\n        int[] maxFromLeft = new int[n];\r\n        int[] minFromRight = new int[n+1];\r\n\r\n        maxFromLeft[0] = arr[0];\r\n        for (int i=1; i<n; i++) {\r\n            maxFromLeft[i] = Math.max(maxFromLeft[i-1], arr[i]);\r\n        }\r\n\r\n        minFromRight[n] = 0x3f3f3f;\r\n        for (int i=n-1; i>=0; i--) {\r\n            minFromRight[i] = Math.min(minFromRight[i+1], arr[i]);\r\n        }\r\n\r\n        int count = 1;\r\n        for (int i=0; i<n-1; i++) {\r\n            if (maxFromLeft[i] <= minFromRight[i+1]) {\r\n                count++;\r\n            }\r\n        }\r\n\r\n        return count;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/8#issuecomment-2524954794","body":"```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null) {\r\n            return null;\r\n        }\r\n\r\n        // 第一步， k = k % n \r\n        // 第二步，把倒数k个节点挪到链表的最前面\r\n        int count = 0;\r\n        ListNode p = head;\r\n        while (p != null) {\r\n            count++;\r\n            p = p.next;\r\n        }\r\n\r\n        k = k % count;\r\n        if (k == 0) {\r\n            return head;\r\n        }\r\n\r\n        p = head;\r\n        ListNode p2 = head;\r\n        ListNode tail = null;\r\n        while (p != null) {\r\n            // k = 2;\r\n            // 1 -> 2 -> 3 -> 4 -> 5 -> null\r\n            //      ^         ^  \r\n            //     p2         p         // when k < 0;\r\n            //           ^        ^\r\n            //          p2        p     // last loop            \r\n\r\n            if (k >= 0) {\r\n                k--;\r\n            } else {\r\n                p2 = p2.next;\r\n            }\r\n\r\n            p = p.next;\r\n            if (p != null && p.next == null) {\r\n                tail = p;\r\n            }\r\n        }\r\n\r\n        ListNode newHead = p2.next;\r\n        p2.next = null;\r\n        tail.next = head;\r\n        return newHead;\r\n    }\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/10#issuecomment-2526710896","body":"```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        return dfs(head, null);\r\n    }\r\n\r\n    // build tree from the list [start, end) => (not including end node)\r\n    // SC O(n)  TC: tree node -> O(n), stack size -> O(h)\r\n    public TreeNode dfs(ListNode start, ListNode end) {\r\n        if (start == end) {\r\n            return null;\r\n        }\r\n\r\n        if (start.next == end) {\r\n            // not including List end node, only return the tree node from the List start node.\r\n            return new TreeNode(start.val);\r\n        }\r\n\r\n        // find mid\r\n        ListNode fast = start;\r\n        ListNode slow = start;\r\n        while (fast != end && fast.next != end) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n\r\n        ListNode mid = slow;\r\n        TreeNode node = new TreeNode(mid.val);\r\n        node.left = dfs(start, slow);\r\n        node.right = dfs(slow.next, end);\r\n\r\n        return node;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/11#issuecomment-2530771023","body":"第一轮初面的时候如果快没时间了可能会出这种题\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if (headA == null || headB == null) {\r\n            return null;\r\n        }\r\n\r\n        // pA ==> A + B = [1, 9, 1 ,2 ,4, 3, 2, 4]\r\n        // pB ==> B + A = [3, 2, 4, 1, 9, 1, 2, 4]\r\n        //                                   ^\r\n        //           intersected node when pA == pB \r\n\r\n        ListNode pA = headA;\r\n        ListNode pB = headB;\r\n        while (pA != pB) {  // TC O(n+m)\r\n            pA = pA != null ? pA.next : headB;\r\n            pB = pB != null ? pB.next : headA;\r\n        }\r\n\r\n        return pA; // pA == null if two lists do not intersect\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/12#issuecomment-2533780428","body":"查表法。。。\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        Set<ListNode> visited = new HashSet<>();\r\n        ListNode p = head;\r\n        while (p != null && !visited.contains(p)) {\r\n            visited.add(p);\r\n            p = p.next;\r\n        }\r\n\r\n        return p;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/13#issuecomment-2537935066","body":"这题太容易碰见了，记得之前面试的时候被问过至少三次。。\r\n```java\r\nclass LRUCache {\r\n    // 双向链表，MRU节点在head之后，LRU节点在tail之前\r\n    // head <-> MRU <-> ... <-> LRU <-> tail\r\n    ListNode head;\r\n    ListNode tail;\r\n\r\n    HashMap<Integer, ListNode> cache; // key -> ListNode\r\n\r\n    int cap;\r\n    \r\n\r\n    public LRUCache(int capacity) {\r\n        head = new ListNode();\r\n        tail = new ListNode();\r\n        head.next = tail;\r\n        tail.prev = head;\r\n        cap = capacity;\r\n        cache = new HashMap<>();\r\n    }\r\n    \r\n    public int get(int key) {\r\n        if (!cache.containsKey(key)) {\r\n            return -1;\r\n        }\r\n\r\n        ListNode node = cache.get(key);\r\n        moveToHead(node);\r\n        return node.value;\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        if (cache.containsKey(key)) {\r\n            ListNode node = cache.get(key);\r\n            moveToHead(node);\r\n            node.value = value;\r\n            return;\r\n        }\r\n\r\n        if (cache.size() == cap) {\r\n            ListNode lruNode = tail.prev;\r\n            unlink(lruNode);\r\n            cache.remove(lruNode.key);\r\n        }\r\n\r\n        ListNode node = new ListNode(key, value);\r\n        moveToHead(node);\r\n        cache.put(key, node);\r\n    }\r\n\r\n    private void unlink(ListNode node) {\r\n        ListNode prev = node.prev;\r\n        ListNode next = node.next;\r\n        if (prev != null) {\r\n            prev.next = next;\r\n        }\r\n        if (next != null) {\r\n            next.prev = prev;\r\n        }\r\n    }\r\n\r\n    private void moveToHead(ListNode node) {\r\n        unlink(node);\r\n        \r\n        ListNode headNext = head.next;\r\n        head.next = node;\r\n        node.prev = head;\r\n        node.next = headNext;\r\n        headNext.prev = node;\r\n    }\r\n\r\n    public class ListNode {\r\n        ListNode prev;\r\n        ListNode next;\r\n        int key;\r\n        int value;\r\n\r\n        public ListNode(int key, int value) {\r\n            this.key = key;\r\n            this.value = value;\r\n            this.prev = null;\r\n            this.next = null;\r\n        }\r\n\r\n        public ListNode() {\r\n            this(-2, -2);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/14#issuecomment-2540686960","body":"```java\r\n// TC O(n), SC O(h)\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n\r\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/15#issuecomment-2542903319","body":"```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null && q == null) {\r\n            return true;\r\n        }\r\n\r\n        if (p == null || q == null) {\r\n            return false;\r\n        }\r\n\r\n        // p != null && q != null\r\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/17#issuecomment-2544136126","body":"层序遍历，先右后左。\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int findBottomLeftValue(TreeNode root) {\r\n        if (root == null) {\r\n            return Integer.MIN_VALUE;\r\n        }\r\n\r\n        int ans = 0;\r\n        Deque<TreeNode> q = new LinkedList<>(); // SC O(n) \r\n        q.offer(root);\r\n        while (!q.isEmpty()) { // TC O(n)\r\n            TreeNode node = q.poll();\r\n            ans = node.val;\r\n            if (node.right != null) {\r\n                q.offer(node.right);\r\n            }\r\n            if (node.left != null) {\r\n                q.offer(node.left);\r\n            }\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/19#issuecomment-2550358870","body":"```java\r\nclass Solution {\r\n    TreeMap<Integer, TreeMap<Integer, List<Integer>>> map; // {col_index -> {row_index -> [val1, val2....valn]}}\r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n        map = new TreeMap<>(); // SC O(N)\r\n        dfs(root, 0, 0); // TC O(N), SC O(logN)\r\n        \r\n        List<List<Integer>> ans = new ArrayList<>();\r\n        for (int col : map.keySet()) { // TC O(X)\r\n            List<Integer> list = new ArrayList<>();\r\n            TreeMap<Integer, List<Integer>> rowVals = map.get(col);\r\n            for (int row : rowVals.keySet()) { // TC O(Y)\r\n                List<Integer> vals = rowVals.get(row);\r\n                Collections.sort(vals); // TC O(K * logK)\r\n                list.addAll(vals);\r\n            }\r\n\r\n            ans.add(list);\r\n        }\r\n        \r\n        return ans;\r\n    }\r\n    \r\n    private void dfs(TreeNode root, int col, int row) {\r\n        if (root == null) {\r\n            return;\r\n        }\r\n        \r\n        // TC O(X * LogX) + O(Y * LogY)\r\n        map.computeIfAbsent(col, k -> new TreeMap<>()).computeIfAbsent(row, k -> new ArrayList<>()).add(root.val);\r\n        dfs(root.left, col - 1, row + 1);\r\n        dfs(root.right, col + 1, row + 1);\r\n    }\r\n}\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/22#issuecomment-2558012525","body":"```java\r\nclass Solution {\r\n    public int numberOfBoomerangs(int[][] points) {\r\n        int n = points.length;\r\n        int total = 0;\r\n        for (int i=0; i<n; i++) { // TC O(N^2)\r\n            int x = points[i][0];\r\n            int y = points[i][1];\r\n            Map<Integer, Integer> distCnt = new HashMap<>(); // 统计其他点到点i的距离\r\n            for (int j=0; j<n; j++) {\r\n                if (i == j) {\r\n                    continue;\r\n                }\r\n                int x1 = points[j][0];\r\n                int y1 = points[j][1];\r\n                int dist = (x - x1) * (x - x1) + (y - y1) * (y - y1);\r\n                distCnt.put(dist, distCnt.getOrDefault(dist, 0) + 1); // SC O(N)\r\n            }\r\n            \r\n            // 假设有n个点到点i距离相同，那么以点i为顶点的等腰三角形数量是n取2的排列数 = n * (n-1)\r\n            for (int count : distCnt.values()) {\r\n                total += count * (count - 1);\r\n            }\r\n        }\r\n        \r\n        return total;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/27#issuecomment-2562102669","body":"读写指针\r\n```java\r\nclass Solution {\r\n    public int removeDuplicates(int[] nums) {\r\n        int n = nums.length;\r\n        int write = 1;\r\n        for (int read=1; read<n; read++) { // TC O(n)\r\n            while (read < n && nums[read] == nums[write-1]) {\r\n                read++;\r\n            }\r\n\r\n            if (read < n) {\r\n                // nums[read] != nums[write-1]\r\n                nums[write++] = nums[read];\r\n            }\r\n        }\r\n\r\n        return write;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/31#issuecomment-2564937566","body":"```java\r\nclass Solution {\r\n    public boolean possibleBipartition(int n, int[][] dislikes) {\r\n        // 1 建图\r\n        List<Integer>[] graph = new List[n + 1];\r\n        for (int i=1; i<=n; i++) {\r\n            graph[i] = new ArrayList<>();\r\n        }\r\n\r\n        for (int[] dislike: dislikes) {\r\n            int p1 = dislike[0];\r\n            int p2 = dislike[1];\r\n            graph[p1].add(p2);\r\n            graph[p2].add(p1);\r\n        }\r\n\r\n        // 2 DFS染色\r\n        int[] colors = new int[n + 1];\r\n        for (int i=1; i<=n; i++) {\r\n            if (colors[i] == 0) {\r\n                if (!setColor(graph, i, colors, 1)) {\r\n                    // 染色失败\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        // 染色成功\r\n        return true;\r\n    }\r\n\r\n    private boolean setColor(List<Integer>[] graph, int node, int[] colors, int color) {\r\n        colors[node] = color;\r\n        for (int neibor : graph[node]) {\r\n            if (colors[neibor] == color) {\r\n                // 染色冲突\r\n                return false;\r\n            } else if (colors[neibor] == 0) {\r\n                // DFS染色\r\n                setColor(graph, neibor, colors, color * -1);\r\n            } else {\r\n                // 已经染色\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/34#issuecomment-2567225486","body":"```java\r\nclass Solution {\r\n    public int[] getOrder(int[][] tasks) {\r\n        // [enqueueTime, processingTime] 这个可以理解为一个时间的区间 [start = enqueueTime, end = start + processingTime]\r\n        // 最后要求执行时间最短\r\n        int n = tasks.length;\r\n        TaskInfo[] taskInfo = new TaskInfo[n]; // SC O(n)\r\n        for (int i=0; i<n; i++) { // TC O(n)\r\n            taskInfo[i] = new TaskInfo(i, tasks[i]);\r\n        }\r\n        Arrays.sort(taskInfo, (t1, t2) -> (t1.startTime - t2.startTime)); // TC O(nlogn)\r\n        \r\n        // 贪心：每次可以执行任务时，选执行时间最短的，这样总时间最短\r\n        PriorityQueue<TaskInfo> minHeap = new PriorityQueue<>((t1, t2) -> {\r\n            // 先按 执行时间 排序，再按索引顺序排序\r\n            if (t1.processingTime != t2.processingTime) {\r\n                return t1.processingTime - t2.processingTime;\r\n            } else {\r\n                return t1.index - t2.index;\r\n            }\r\n        }); // SC O(n)\r\n        \r\n        int[] orders = new int[n]; // SC O(n)\r\n        int orderIndex = 0;\r\n        int taskIndex = 0;\r\n        int usedTime = 1;\r\n        while (orderIndex < n) { // TC O(n)\r\n            while (taskIndex < n &&  taskInfo[taskIndex].startTime <= usedTime) {\r\n                // 这些任务都可以执行了，加入队列 - enqueue\r\n                minHeap.offer(taskInfo[taskIndex++]); // TC O(logn)\r\n            }\r\n            if (!minHeap.isEmpty()) {\r\n                // 从队列中拿出一个任务进行处理\r\n                // 选执行时间最短的(堆顶)\r\n                TaskInfo curTask = minHeap.poll(); // TC O(1)\r\n                orders[orderIndex++] = curTask.index;\r\n                usedTime += curTask.processingTime;\r\n            } else {\r\n                // 没有任务，直接跳转到当前任务的开始时间\r\n                usedTime = taskInfo[taskIndex].startTime;\r\n            }\r\n        }\r\n        \r\n        return orders;\r\n    }\r\n}\r\n\r\nclass TaskInfo {\r\n    int index; // 因为最后要输出任务序号，所以这里需要把任务序号也记录一下，防止排序之后搞乱了\r\n    int startTime;\r\n    int processingTime;\r\n\r\n    public TaskInfo(int index, int[] task) {\r\n        this.index = index;\r\n        this.startTime = task[0];\r\n        this.processingTime = task[1];\r\n    }\r\n}\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/38#issuecomment-2572236589","body":"```java\r\nclass Solution {\r\n    public int mySqrt(int x) {\r\n        if (x == 0 || x == 1) {\r\n            return x;\r\n        }\r\n        \r\n        int l = 1;\r\n        int r = x;\r\n        while (l <= r) { // TC O(logX)\r\n            int mid = l + (r - l) / 2;\r\n            int target = x / mid;\r\n            if (mid == target) {\r\n                return mid;\r\n            } else if (mid > target) {\r\n                r = mid - 1;\r\n            } else {\r\n                l = mid + 1;\r\n            }\r\n        }\r\n        \r\n        return r;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/43#issuecomment-2585064100","body":"用优先队列+BFS 实现DJ算法找最短路径\r\n```java\r\nclass Solution {\r\n    public int swimInWater(int[][] grid) {\r\n        int m = grid.length;\r\n        int n = grid[0].length;\r\n        \r\n        PriorityQueue<int[]> q = new PriorityQueue<>((e1, e2) -> e1[2] - e2[2]); // {i, j, grid[i][j]}\r\n        boolean[][] visited = new boolean[m][n];\r\n        \r\n        q.offer(new int[]{0, 0, grid[0][0]});\r\n        visited[0][0] = true;\r\n        \r\n        int[] dx = {1, 0, -1, 0};\r\n        int[] dy = {0, 1, 0, -1};\r\n        int cost = 0;\r\n        while (!q.isEmpty()) {\r\n            int[] cur = q.poll();\r\n            cost = Math.max(cost, cur[2]);\r\n            if (cur[0] == m - 1 && cur[1] == n-1) {\r\n                return cost;\r\n            }\r\n\r\n            for (int k=0; k<4; k++) {\r\n                int row = cur[0] + dx[k];\r\n                int col = cur[1] + dy[k];\r\n                \r\n                if (row < 0 || row >= m || col < 0 || col >= n || visited[row][col]) {\r\n                    continue;\r\n                }\r\n                 visited[row][col] = true;\r\n                q.offer(new int[]{row, col, grid[row][col]});\r\n            }\r\n        }\r\n        \r\n        return -1;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/48#issuecomment-2594722705","body":"```java\r\nclass Solution {\r\n    public int maxScore(int[] points, int k) {\r\n        long totalSum = 0;\r\n        for (int p : points) {  // TC O(n)\r\n            totalSum += p;\r\n        }\r\n\r\n        int sizeOfWindow = points.length - k;\r\n        if (sizeOfWindow == 0) {\r\n            return (int)totalSum;\r\n        }\r\n        \r\n        // fixed-length sliding window\r\n        long sumOfWindow = 0;\r\n        for (int i=0; i<sizeOfWindow; i++) {\r\n            sumOfWindow += points[i];\r\n        }\r\n        \r\n        long minSumOfWindow = sumOfWindow;\r\n        for (int i=sizeOfWindow; i < points.length; i++) { // TC O(n)\r\n            sumOfWindow -= points[i - sizeOfWindow]; // left\r\n            sumOfWindow += points[i]; // right\r\n            minSumOfWindow = Math.min(minSumOfWindow, sumOfWindow);\r\n        }\r\n        \r\n        return (int)(totalSum - minSumOfWindow);\r\n    }\r\n}\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/51#issuecomment-2600593930","body":"小岛问题，DFS遍历\n\n```java\nclass Solution {\n    int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n    int m = 0;\n    int n = 0;\n    public int maxAreaOfIsland(int[][] grid) {\n        m = grid.length;\n        n = grid[0].length;\n\n        int maxArea = 0;\n        for (int i=0; i<m; i++) {\n            for (int j=0; j<n; j++) {\n                if (grid[i][j] == 1) {\n                    maxArea = Math.max(maxArea, dfs(grid, i, j));\n                }\n            }\n        }\n\n        return maxArea;\n    }\n\n    private int dfs(int[][] grid, int startX, int startY) {\n        int count = 1;\n        grid[startX][startY] = 0;\n        // 上下左右\n        for (int[] d : directions) {\n            int nextX = startX + d[0];\n            int nextY = startY + d[1];\n            if (isValid(grid, nextX, nextY)) {\n                count += dfs(grid, nextX, nextY);\n            }\n        }\n\n        return count;\n    }\n\n    private boolean isValid(int[][] grid, int x, int y) {\n        return x >= 0 && x < m && y >= 0 && y < n && grid[x][y] == 1;\n    }\n}\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/57#issuecomment-2613805126","body":"```java\nclass Solution {\n    public int findNumberOfLIS(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n]; // dp(i): 以nums[i]为结尾的最长子序列的长度\n        int[] counts = new int[n];\n        int maxLen = 0;\n        int total = 0;\n        for (int i=0; i<n; i++) { // TC O(n^2)\n            dp[i] = 1;\n            counts[i] = 1;\n            for (int j=0; j<i; j++) {\n                if (nums[i] > nums[j]) {\n                    if (dp[j] + 1 > dp[i]) {\n                        dp[i] = dp[j] + 1;\n                        counts[i] = counts[j];\n                    } else if (dp[j] + 1 == dp[i]) {\n                        counts[i] += counts[j];\n                    }\n                }\n            }\n            \n            if (dp[i] > maxLen) {\n                maxLen = dp[i];\n                total = counts[i];\n            } else if (dp[i] == maxLen) {\n                total += counts[i];\n            }\n        }\n        \n        return total;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"haodongwang1995":[{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/2#issuecomment-2509583583","body":"### 思路\n1. 代码模拟每一位相加，进位\n2. 通过 / 和 % 分别取出剩余的数值和当前位的数值\n3. 用idx判断第一个参数目前加到哪一位\n4. 用carryOver 判断是否进位\n5. 每一次循环从做往右推入 第一个数当前位数值，第二个数当前位数值 和 是否进位\n6. 判断while循环进行：\n    a. 第一个参数没有遍历完（idx>=0）\n    b. 第二个参数没有遍历完（剩余的数值 和 当前位的数值 不等于 0）\n    c. 进位是否加完\n### 代码\n```java\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let maskedNum = k%10\n    let remainNum = Math.floor(k/10)\n    let idx = num.length-1\n    let carryOver = 0\n    let cur = 0\n    let res = []\n    while(idx>=0 || carryOver !==0 || maskedNum !==0 || remainNum !==0){\n        cur = maskedNum + (num[idx]||0) + carryOver\n        if(cur >9){\n            cur = cur-10\n            carryOver = 1\n        }\n        else {\n            carryOver = 0\n        }\n        maskedNum = remainNum%10\n        remainNum = Math.floor(remainNum/10)\n        idx--\n        res.unshift(cur)\n    }\n    return res\n};\n\n```\n### 复杂度分析\n时间复杂度 O(N) N位最长的数字的位数长度\n空间复杂度 O(N+1) => O(N) N位最长的数字的位数长度\n\n### 总结\n在判断循环结束的时候要仔细，同时判断两个数是否遍历完成，进位是否存在","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/3#issuecomment-2510733024","body":"### 思路\n1. 正序反序依次遍历一次，记录距离上一个匹配的距离\n2. 在每次的赋值判断场景有：\n\n    a. 目前为止还未出现的匹配字母，不赋值\n\n    b. 当前匹配，赋值0\n\n    c. 已经出现匹配，原来的res位置为空，需要赋值\n\n    d. 已经出现匹配，原来的res位置有值，大于当前距离计数，用当前的计数覆盖\n\n    e. 已经出现匹配，原来的res位置有值，小于等于当前距离计数，不进行覆盖\n\n### 代码\n```java\n\n\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let res = new Array(s.length)\n    let inOrderFn = ((a=-1)=>++a)\n    let reverseFn = ((a=s.length)=>--a)\n    let triverse = (res, s,c,getFn)=>{\n        let idx = getFn()\n        let counter = undefined\n        while(idx<s.length && idx > -1){\n            if(s[idx] === c){\n                counter = 0\n                res[idx] = counter\n                counter++\n            }\n            else if(res[idx] < counter || counter === undefined ){\n                // do not replace value \n            }\n            else{\n                res[idx] = counter\n                counter++\n            }\n            idx = getFn(idx)\n        }\n        return res\n    }\n    res = triverse(res, s, c, inOrderFn)\n    res = triverse(res, s, c, reverseFn)\n    return res\n};\n\n```\n\n### 复杂度分析\n时间复杂度 O(2N) -> O(N) N位最长的数字的位数长度\n\n空间复杂度 O(N) -> O(N) N位最长的数字的位数长度\n\n### 总结\n需要注意判断时场景是否全面，以后还是先写思路，这样可以复查","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/4#issuecomment-2513866361","body":"###思路\n\n1. 设置maxSize：\n    a. 创建时记录\n    b. push 时检查当前大小是否小于等于maxSize，大于直接返回\n2. push 功能\n    a. 新增元素\n3. pop功能\n    a. 删除元素\n4. inc 功能\n    a. 判断输入个数是否小于等于当前数量，大于直接返回\n    b. 从底开始根据入参依次相加\n\n### 代码\n```javascript\n\n/**\n */\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.stack = []\n    this.maxSize = maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stack.length >=this.maxSize){\n        return \n    }\n    this.stack.push(x)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    let a = this.stack.pop()\n    return a || -1\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(let i = 0; i< k && i < this.stack.length;i++){\n        this.stack[i] +=val\n    }\n};\n\n/** \n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n\n```\n\n### 复杂度分析\n时间复杂度 O(1) \n\n空间复杂度 O(n) \n\n### 总结\n在创建数组的时候如果用 new Array() 方法会导致长度固定，如果后变要用到 length 属性需要考虑到位","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/5#issuecomment-2517462734","body":"### 思路\n1. 使用一个栈，往里push，直到出现']'，开始处理这一个括号的内容，处理完的结果当成一个字符重新push进栈\n2. 最后把这个栈变成字符串，输出\n\n\n### 代码\n```java\n\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    let stack = []\n    let strStack = []\n    let res = ''\n    \n    for(let i  = 0; i< s.length; i++){\n        if( s[i] === ']'){\n            let tmpStr = ''\n            let char = ''\n            for(let idx = stack.length-1; stack[idx] !== '['; idx-- ){\n                let char = stack.pop()\n                tmpStr = char + tmpStr\n            }\n            stack.pop();\n            let num = ''\n            while(!Number.isNaN(Number(stack.at(-1)))){\n                num = stack.pop() + num\n            }\n            stack.push(tmpStr.repeat(Number(num)))\n        }\n        else {\n            stack.push(s[i])\n        }\n    }\n    return stack.toString().replaceAll(',','')\n};\n```\n\n### 复杂度分析\n时间复杂度 O(N) \n空间复杂度 O(N)\n\n### 总结\n用栈来处理括号","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/6#issuecomment-2519681114","body":"### 思路\n1. 使用一个栈，往里push，直到出现']'，开始处理这一个括号的内容，处理完的结果当成一个字符重新push进栈\n2. 最后把这个栈变成字符串，输出\n\n\n### 代码\n```javascript\n\nvar MyQueue = function() {\n    this.stack1 = []\n    this.stack2 = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.stack1.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.stack2.length === 0){\n        while(this.stack1.length !==0){\n            this.stack2.push(this.stack1.pop())\n        }\n    }\n    return this.stack2.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(this.stack2.length === 0){\n        while(this.stack1.length !==0){\n            this.stack2.push(this.stack1.pop())\n        }\n    }\n    let res = this.stack2.at(-1)\n    return res\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.stack1.length === 0 && this.stack2.length === 0\n};\n\n/** \n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n ```\n\n### 复杂度分析\n时间复杂度 \n    push :O(1) \n    pop :O(n) \n    peek: O(n)\n    empty: O(1)\n空间复杂度 \n    O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/7#issuecomment-2523300389","body":"### 思路\n1. 从左到右依次排查\n    a. 栈中每一项作为一个区域\n    b. 栈中每一项存该区最大值\n    c. 如果大于当前栈顶值，当成一个区,推入栈中\n    d. 如果小于当前栈，记住当前栈顶值，往下pop，直到找到底 或者 找到比当前数小的那一项为止，推入之前记住的栈顶值\n2. 返回栈高度作为最多可分块\n\n### 代码\n``` javascript\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    const stack = [];\n    for (const num of arr) {\n        if (stack.length === 0 || num >= stack[stack.length - 1]) {\n            stack.push(num);\n        } else {\n            const mx = stack.pop();\n            while (stack.length && stack[stack.length - 1] > num) {\n                stack.pop();\n            }\n            stack.push(mx);\n        }\n    }\n    return stack.length;\n\n};\n```\n\n\n### 复杂度分析\n时间复杂度 O(N) \n空间复杂度 O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/8#issuecomment-2525160820","body":"### 思路\n1. 根据题目理解，旋转一次就是把尾断掉，然后作为新的头，连到之前的头之前\n2. 由于旋转次数有可能大于链表长度，所以偏移量应该为 k mod 长度\n3. 所以需要的操作：\n    a. 找到链表的长度\n    b. 计算出偏移量\n    c. 找到最后n+1项目。通过维护一个偏移量长度+1的数组实现，每次超长就把第一个给删掉，从尾部插入新的节点。\n    d. 设置新的尾巴：把数组第0个的next指向空\n    e. 把之前的尾巴连到旧头：把数组最后一项的next指向旧头\n    f. 新的头就是数组的第二项\n     \n### 代码\n``` javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if(head === null || head.next === null) return head\n    let tmp = head;\n    let count = 1\n    let arr = []\n    while( tmp.next){\n        tmp = tmp.next\n        count ++\n    }\n    let shiftNum = k% count;\n    if(shiftNum === 0){\n        return head\n    }\n    tmp = head\n    while( tmp.next){\n        if(arr.length === shiftNum){\n            arr.shift()\n        }\n        arr.push(tmp)\n        tmp = tmp.next\n        count ++\n    }\n    arr.push(tmp)\n    arr[0].next = null\n\n    arr[arr.length-1].next = head\n    return arr[1]\n\n};\n```\n\n### 复杂度分析\n时间复杂度 O(N) \n空间复杂度 O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/9#issuecomment-2525471147","body":"### 思路\n1. 交换两个节点\n    第一个节点的下一个 改为第二个节点的下一个\n    第二个节点的下一个 改为第一个节点\n2. 连接之前的节点\n    之前的节点的下一个 改为第二个节点\n\n\n### 代码\n``` javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    let first = head, second = head?.next, last;\n    let res = second || head\n    let tmp\n    while( first && second){\n        last && (last.next = second)\n        tmp = second.next \n        first.next = second.next\n        second.next = first\n        last = first\n        first = first?.next\n        second = first?.next\n    }\n    return res\n};\n```\n\n### 复杂度分析\n时间复杂度 O(N) \n空间复杂度 O(0)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/10#issuecomment-2527891439","body":"### 思路\r\n快慢指针找到中间项，创建树节点，递归直到最后\r\n\r\n###代码 \r\n``` javascript\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\nvar sortedListToBST = function(head) {\r\n    if(head === null){\r\n        return head\r\n    }\r\n    return buildTreeFn(head,null)\r\n};\r\n\r\nfunction buildTreeFn (left,right){\r\n    if(left === right){\r\n        return null\r\n    }\r\n    let fast = left;\r\n    let slow = left;\r\n    while(fast !== right && fast.next !== right){\r\n        fast = fast.next.next\r\n        slow = slow.next\r\n    }\r\n    let leftTree = buildTreeFn(left,slow)\r\n    let rightTree = buildTreeFn(slow.next,right)\r\n    return new TreeNode(slow.val,leftTree,rightTree)\r\n}\r\n\r\n```\r\n### 复杂度分析\r\n时间复杂度 O(N) \r\n空间复杂度 O(N)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/11#issuecomment-2531514460","body":"### 思路\n两个指针分别遍历A和B，遍历完以后再继续遍历对方，这样两边最后一定会同时走最后一段C\n判断两个指针是否重合，开始重合的地方就是重合处\n\n### 代码\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    let ptrA = headA, ptrB = headB;\n    while(ptrA!==ptrB){\n        ptrA = ptrA === null ? headB: ptrA.next\n        ptrB = ptrB === null ? headA: ptrB.next\n    }\n    return ptrA\n};\n```\n\n### 复杂度分析\n时间复杂度 O(N) \n空间复杂度 O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/12#issuecomment-2535755064","body":"### 思路\r\n快慢指针，相遇以后；重新新建指针从头开始，与慢指针相交点即为环的入口\r\n\r\n### 代码\r\n``` javascript\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n    let fast = head, slow = head, isFirst = true;\r\n    while (isFirst || fast !== slow){\r\n        isFirst && (isFirst = false)\r\n        fast = fast?.next?.next\r\n        slow = slow?.next\r\n        if(fast===null || fast === undefined){\r\n            return null\r\n        }\r\n    }\r\n    let ptr = head\r\n    while (ptr !== slow){\r\n        ptr = ptr?.next\r\n        slow = slow?.next\r\n    }\r\n    return ptr\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度 O(N) \r\n空间复杂度 O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/13#issuecomment-2538618949","body":"### 思路\r\n1. 由于添加删除需要为O(1),又需要随时改变顺序以保存优先级，所以使用双向列表。\r\n2. 由于获取也要为 O(1), 所以用HashMap来保存key和对应node\r\n\r\n### 代码\r\n``` javascript\r\n\r\nclass DoubleLinkedListNode {\r\n    constructor(key, value) {\r\n        this.key = key\r\n        this.value = value\r\n        this.pre = null\r\n        this.next = null\r\n    }\r\n}\r\n\r\nclass LRUCache{\r\n    constructor(capacity){\r\n        this.dummyHead = new DoubleLinkedListNode(null,null)\r\n        this.dummyTail = new DoubleLinkedListNode(null, null)\r\n        this.dummyHead.next = this.dummyTail\r\n        this.dummyTail.pre = this.dummyHead\r\n        this.hashMap = new Map()\r\n        this.capacity = capacity\r\n        this.size = 0\r\n\r\n    }\r\n    _addHead(key,val){\r\n        let newNode = new DoubleLinkedListNode(key,val)\r\n        this.dummyHead.next.pre = newNode\r\n        newNode.next = this.dummyHead.next\r\n        this.dummyHead.next = newNode\r\n        newNode.pre = this.dummyHead\r\n        this.size++\r\n        this.hashMap.set(key,newNode)\r\n    }\r\n    _deleteNode(node){\r\n        node.pre.next = node.next\r\n        node.next.pre = node.pre\r\n        node.next = null\r\n        node.pre = null\r\n        this.size--\r\n        this.hashMap.delete(node.key)\r\n    }\r\n    _deleteTail(){\r\n        this._deleteNode(this.dummyTail.pre)\r\n    }\r\n    get(key){\r\n        let node = this.hashMap.get(key)\r\n        if(!node){\r\n            return -1\r\n        }\r\n        this._deleteNode(node)\r\n        this._addHead(node.key, node.value)\r\n        return node.value\r\n    }\r\n    put(key,val){\r\n        let old = this.hashMap.get(key)\r\n        if(old){\r\n            this._deleteNode(old)\r\n            this._addHead(key, val)\r\n            return \r\n        }\r\n        if(this.size === this.capacity){\r\n            this._deleteTail()\r\n        }\r\n        this._addHead(key, val)\r\n    }\r\n}\r\n\r\n/** \r\n * Your LRUCache object will be instantiated and called as such:\r\n * var obj = new LRUCache(capacity)\r\n * var param_1 = obj.get(key)\r\n * obj.put(key,value)\r\n */\r\n\r\n ```\r\n\r\n### 复杂度分析\r\n时间复杂度 O(1) \r\n空间复杂度 O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/14#issuecomment-2540726726","body":"### 代码\n``` javascript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    return findDeep(root)\n};\nlet findDeep = (root)=>{\n    if(!root){\n        return 0\n    }\n    return 1+Math.max(findDeep(root.left),findDeep(root.right))\n}\n\n```\n### 复杂度分析\n时间复杂度 O(N) \n空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/15#issuecomment-2543046184","body":"### 代码\n```javascript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n    if(p === null && q === null){\n        return true\n    }\n    if(p?.val !== q?.val){\n        return false\n    }\n    return isSameTree(p.left,q.left) && isSameTree(p.right,q.right)\n};\n```\n\n### 复杂度分析\n时间复杂度 O(N) \n空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/16#issuecomment-2543864563","body":"### 代码\n``` javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root) {\n    return triverseTree(root,[])\n    \n};\nfunction triverseTree (node,arr){\n    if(!node){\n        return 0\n    }\n    let newArr = arr.concat(node.val)\n    if(!node.left && ! node.right){\n        return Number(newArr.join(''))\n    }\n    return triverseTree (node.left,newArr) + triverseTree (node.right,newArr)\n}\n\n```\n### 复杂度分析\n时间复杂度 O(N) \n空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/17#issuecomment-2545344571","body":"### 思路\n用 bfs 比较直接\n\n### 代码\n``` javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar findBottomLeftValue = function(root) {\n    if(!root){\n        return null \n    }\n    let levelNodes = [root]\n    let nextLevelNodes = []\n    let firstTimeFlag = true\n    let node = root\n    while(firstTimeFlag || levelNodes.length !==0){\n        firstTimeFlag = false\n        levelNodes.forEach((n)=>{\n            n.left && nextLevelNodes.push(n.left)\n            n.right && nextLevelNodes.push(n.right)\n        })\n        if(nextLevelNodes.length!==0 ){\n            levelNodes = nextLevelNodes\n            nextLevelNodes = []\n        }\n        else if(nextLevelNodes.length==1 ){\n            return nextLevelNodes[0].val\n        }\n        else{\n            return levelNodes[0].val\n        }\n        \n    }\n};\n```\n\n### 复杂度分析\n时间复杂度 O(N) \n空间复杂度 O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/19#issuecomment-2551333294","body":"### 思路 \n用递归dfs遍历树并且带入坐标进行存储，最后处理数据\n\n### 代码\n``` javascript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar verticalTraversal = function(root) {\n   let store = {}\n    visitTree(root,0,0,store)\n    console.log(store)\n    let res = []\n    Object.keys(store).sort((a,b)=>a-b).forEach((idx)=>{\n        res.push(\n            store[idx].filter((a)=>a)\n                .reduce((reducer, item)=>{\n                    reducer.push(item.sort((a,b)=>a-b))\n                    return reducer\n                },[])\n                .flat()\n        )\n    })\n    return res\n};\nlet visitTree = (root,x,y,store)=>{\n    !store[x] && (store[x] = [])\n    !store[x][y] && (store[x][y] = [])\n    store[x][y].push(root.val)\n    root.left && visitTree(root.left,x-1,y+1,store)\n    root.right && visitTree(root.right,x+1,y+1,store)\n}\n```\n\n### 复杂度分析\n时间复杂度 O(N) \n空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/20#issuecomment-2553612194","body":"### 代码\n\n``` javascript\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    let store = {}\n    let result = []\n    nums.forEach((num,idx)=>{\n        let a = target - num\n        if(store[a] !== undefined){\n            result = [store[a],idx]\n        }\n        else{\n        store[num] = idx\n        }\n    })\n    return result\n};\n\n```\n### 复杂度分析\n时间复杂度 O(N) \n空间复杂度 O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shuichicx":[{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/2#issuecomment-2509616185","body":"## 思路\n直接把K加到数组中，在最后一位加上K，再进行进位，到第一位如果还能进位就加在前面\n\n## 代码\n```py\nclass Solution:\n\tdef addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\t\ti=len(num)-1\n\t\tnum[i]+=k\n\t\twhile i>0:\n\t\t\tif num[i]>=10:\n\t\t\t\tnum[i],num[i-1]=num[i]%10,num[i-1]+num[i]//10\n\t\t\ti-=1\n\t\twhile num[0]>=10:\n\t\t\tnum=[num[0]//10]+num\n\t\t\tnum[1]%=10\n\t\treturn num\n```\n\n## 复杂度分析\n- 时间复杂度 O(N)\n- 空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/3#issuecomment-2511211305","body":"## 思路\n数组正向遍历一遍，记录与左边最近的c的距离，反向遍历一遍，记录与右边最近的c的距离，最后对每个位置的距离取最小值，如果左边和右边还没有c，可以将此时的c下标记为正负无穷\n\n## 代码\n```py\nclass Solution:\n\tdef shortestToChar(self, s: str, c: str) -> List[int]:\n\t\tn=len(s)\n\t\tres=[0]*n\n\t\tidx=float('-inf')\n\t\tfor i in range(n):\n\t\t\tif s[i]==c:\n\t\t\t\tidx=i\n\t\t\tres[i]=i-idx\n\t\tidx=float('inf')\n\t\tfor i in range(n-1,-1,-1):\n\t\t\tif s[i]==c:\n\t\t\t\tidx=i\n\t\t\tres[i]=min(res[i],idx-i)\n\t\treturn res\n```\n\n## 复杂度分析\n- 时间复杂度 O(N)\n- 空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/4#issuecomment-2514575932","body":"```py\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack=[]\n        self.maxSize=maxSize\n\n\n    def push(self, x: int) -> None:\n        if len(self.stack)<self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if len(self.stack)==0:\n            return -1\n        else:\n            return self.stack.pop()\n        \n    def increment(self, k: int, val: int) -> None:\n        n=min(k,len(self.stack))\n        for i in range(n):\n            self.stack[i]+=val\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/5#issuecomment-2517438559","body":"```py\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack, res, n = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append([n, res])\n                res, n = \"\", 0\n            elif c == ']':\n                cur_n, last_res = stack.pop()\n                res = last_res + cur_n * res\n            elif '0' <= c <= '9':\n                n = n * 10 + int(c)            \n            else:\n                res += c\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/6#issuecomment-2520690567","body":"```py\nclass MyQueue:\n\n    def __init__(self):\n        self.s1,self.s2=[],[]\n\n    def push(self, x: int) -> None:\n        self.s1.append(x)\n\n    def pop(self) -> int:\n        peek=self.peek()\n        self.s2.pop()\n        return peek\n\n    def peek(self) -> int:\n        if self.s2: return self.s2[-1]\n        if not self.s1: return -1\n        while self.s1:\n            self.s2.append(self.s1.pop())\n        return self.s2[-1]\n\n    def empty(self) -> bool:\n        return not self.s1 and not self.s2\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/8#issuecomment-2525216256","body":"```py\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n\n        tail = head\n        length = 1\n        while tail.next:\n            length += 1\n            tail = tail.next\n        tail.next = head\n\n        k = k % length\n        for _ in range(length - k):\n            tail = tail.next\n\n        head = tail.next\n        tail.next = None\n        return head\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/9#issuecomment-2526190721","body":"```py\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        length = 0\n        lst = head\n        while lst:\n            length += 1\n            lst = lst.next\n        \n        lst = head\n        for i in range(int(length / 2)):\n            temp = lst.val\n            lst.val = lst.next.val\n            lst.next.val = temp\n            lst = lst.next.next\n        return head\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/10#issuecomment-2528473474","body":"```py\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return None\n        elif not head.next:\n            return TreeNode(head.val)      \n        pre, slow, fast = None, head, head\n        while fast and fast.next:\n            pre = slow\n            slow = slow.next\n            fast = fast.next.next\n        root = TreeNode(slow.val)\n        pre.next = None\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        return root\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/11#issuecomment-2532137066","body":"```py\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        A, B = headA, headB\n        while A != B:\n            A = A.next if A else headB\n            B = B.next if B else headA\n        return A\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/12#issuecomment-2536246401","body":"```py\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if fast is slow:\n                while slow is not head:\n                    slow = slow.next\n                    head = head.next\n                return slow\n        return None\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/14#issuecomment-2541746396","body":"```py\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n        l_depth = self.maxDepth(root.left)\n        r_depth = self.maxDepth(root.right)\n        return max(l_depth, r_depth) + 1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/15#issuecomment-2543163173","body":"```py\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p is None or q is None:\n            return p is q\n        return p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/16#issuecomment-2543918710","body":"```py\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        ans=0\n        def dfs(node,x):\n            if node is None:\n                return\n            x=x*10+node.val \n            if node.left is node.right:\n                nonlocal ans \n                ans+=x\n                return \n            dfs(node.left,x)\n            dfs(node.right,x)\n        dfs(root,0)\n        return ans \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/17#issuecomment-2545936155","body":"```py\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        q=deque([root])\n        while q:\n            node=q.popleft()\n            if node.right:\n                q.append(node.right)\n            if node.left:\n                q.append(node.left)\n        return node.val\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/21#issuecomment-2557262646","body":"```py\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        dic = defaultdict(int)\n        for num in nums:\n            dic[num] += 1\n        s = [0] * (n+1)\n        for num in dic:\n            s[dic[num]] += 1\n        cnt, i = 0, n\n        while cnt < k:\n            cnt += s[i]\n            i -= 1\n        res = []\n        for k in dic:\n            if dic[k] > i:\n                res.append(k)       \n        return res\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/23#issuecomment-2558489497","body":"```py\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        dic, res, i = {}, 0, -1\n        for j in range(len(s)):\n            if s[j] in dic:\n                i = max(dic[s[j]], i)\n            dic[s[j]] = j\n            res = max(res, j - i) \n        return res\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/26#issuecomment-2561930580","body":"```py\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast,slow=head,head\n        while fast and fast.next:\n            fast=fast.next.next\n            slow=slow.next\n        return slow\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/27#issuecomment-2562335422","body":"```py\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        i,val=1,nums[0]\n        while i<=len(nums)-1:\n            if nums[i]==val:\n                del nums[i]\n            else:\n                val=nums[i]\n                i+=1\n        return len(nums)\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/33#issuecomment-2567012900","body":"```py\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        x,y=0,0\n        for move in moves:\n            if move=='U':\n                y+=1\n            elif move=='D':\n                y-=1\n            elif move=='L':\n                x-=1\n            elif move=='R':\n                x+=1\n        return x==0 and y==0\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/39#issuecomment-2574531350","body":"```py\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        l,r=1,n\n        while l<=r:\n            mid=(l+r)>>1\n            if isBadVersion(mid):\n                r=mid-1\n            else:\n                l=mid+1\n        return l\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/46#issuecomment-2590327331","body":"```py\nclass Solution:\n    def findAnagrams(self, s: str, p: str) -> List[int]:\n        ans = []\n        cnt_p = Counter(p)  \n        cnt_s = Counter() \n        for right, c in enumerate(s):\n            cnt_s[c] += 1 \n            left = right - len(p) + 1\n            if left < 0:\n                continue\n            if cnt_s == cnt_p:  \n                ans.append(left)\n            cnt_s[s[left]] -= 1  \n        return ans\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/53#issuecomment-2604380344","body":"```py\nclass Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        ans = cnt = 0\n        q = initialBoxes\n        while q:\n            i = q[0]\n            q = q[1:]\n            if status[i] != 1:\n                q.append(i)\n                cnt += 1\n                if cnt == len(q): \n                    break\n                continue\n            cnt = 0\n            ans += candies[i]\n            for box in containedBoxes[i]: q.append(box)\n            for key in keys[i]: status[key] = 1\n        return ans\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qunshanhe":[{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/2#issuecomment-2509762372","body":"# 思路\n写个 numToList 和 listToNum 的函数，把 list 转换为整数然后和k相加，再把结果转换为 list \n\n# 代码\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        return numToList(listToNum(num)+k)\n        \ndef numToList(num: int):\n    numList = []\n    while num !=0:\n        numList.append(num%10)\n        num = num//10\n    return numList[::-1]\n\ndef listToNum(numList: List[int]):\n    length = len(numList)\n    num = 0\n    for i in range(length):\n        num = num*10 + numList[i]\n    return num\n\n# 复杂度\n时间复杂度 O(N)\n空间复杂度 O(N)\n\n# 一个知识点\nnum // 10 是整除 直接获得整数，而且是向下取整\nnum / 10  是正常除法，返回的是浮点数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/3#issuecomment-2511569989","body":"# 思路\n分而治之，最近的字符距离 = min(左边最近的字符距离，右边最近的字符距离)\n因此第一次从左到右遍历s，记录每个字符和其左边最近字符的距离\n第二次从右往左遍历s，记录每个字符和其右边最近字符的距离，同时更新最小值\n\n# 代码\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> list[int]:\n        n = len(s)\n        res = [0]*n\n\n        # 从左到右遍历\n        c_pos_lr = -1\n        for i in range(n):\n            if s[i] == c:\n                c_pos_lr = i\n            if c_pos_lr != -1:\n                res[i] = abs(i-c_pos_lr)\n        # 从右往左遍历\n        c_pos_rl = -1\n        for i in range(n-1,-1,-1):\n            if s[i] == c:\n                c_pos_rl = i\n            if c_pos_rl != -1:\n                if s[i] != c and res[i] ==0:\n                    res[i] = abs(i-c_pos_rl)\n                else:\n                    res[i] = min(abs(i-c_pos_rl),res[i])\n        return res\n\n# 复杂度\n时间复杂度 O(N)\n空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/4#issuecomment-2513403125","body":"class CustomStack:\n\n    def __init__(self, maxSize: int):\n       self.top = -1\n       self.stack = [0] * maxSize\n       self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if self.top < self.maxSize-1:\n            self.stack[self.top+1] = x\n            self.top = self.top+1\n\n    def pop(self) -> int:\n        if self.top > -1:\n            self.top = self.top-1\n            return self.stack[self.top+1]\n        else:\n            return -1\n        \n    def increment(self, k: int, val: int) -> None:\n        lim = min(k,self.top+1)\n        for i in range(lim):\n            self.stack[i] = self.stack[i]+val\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/5#issuecomment-2517831615","body":"class Solution:\n    def decodeString(self, s: str) -> str:\n        stack, res, multi = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append([multi, res])\n                res, multi = \"\", 0\n            elif c == ']':\n                cur_multi, last_res = stack.pop()\n                res = last_res + cur_multi * res\n            elif '0' <= c <= '9':\n                multi = multi * 10 + int(c)            \n            else:\n                res += c\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/6#issuecomment-2520606408","body":"class MyQueue:\n\n    def __init__(self):\n        self.inStack=[]\n        self.outStack=[]\n\n    def push(self, x: int) -> None:\n        self.inStack.append(x)\n\n    def pop(self) -> int:\n        if not self.outStack:self.in2out()\n        return self.outStack.pop()\n\n    def peek(self) -> int:\n        if not self.outStack:self.in2out()\n        return self.outStack[-1]\n\n    def empty(self) -> bool:\n        return not self.inStack and not self.outStack\n\n    def in2out(self)->None:\n        while self.inStack:\n            self.outStack.append(self.inStack.pop())","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hebingliang":[null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/3#issuecomment-2510395821","body":"```\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let result = [];\n    if(!s.length){\n        return result;\n    }\n    let firstShow = true;\n    for(let i = 0;i<s.length;i++){\n        //第一步，先找到C出现的位置\n        let item = s[i];\n        if(item==c){\n            //在当前C出现的位置内，寻找每一个与当前C的位置\n            for(let j = 0;j<s.length;j++){\n                let currentMin = Math.abs(i-j);\n                console.error(`第${i}次的结果是：${currentMin}`)\n                if(firstShow){\n                    result.push(currentMin)\n                }else{\n                    if(result[j]>currentMin){\n                        result[j] = currentMin\n                    }\n                }\n            }\n            firstShow = false\n        }\n    }\n    return result;\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/4#issuecomment-2513372099","body":"/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    arr = [];\n    maxLength = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(arr.length==maxLength){\n        console.error(\"已经超出了\")\n    }else{\n        arr.push(x)\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(arr.length){\n        let num = arr[arr.length-1]\n        arr.splice(arr.length-1,1);\n        return num;\n    }else{\n        return -1\n    }\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(let i = 0;i<(k>arr.length?arr.length:k);i++){\n        arr[i] = arr[i]+val\n    }\n};\n\n/** \n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"baiqz":[null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/3#issuecomment-2511151107","body":"## **【Day 2】821. 字符的最短距离**\n\n\n\n\n\n### 1、问题\n\n````\n```\n给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\n\n示例 1:\n\n输入: S = \"loveleetcode\", C = 'e'\n输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\n说明:\n\n- 字符串 S 的长度范围为 [1, 10000]。\n- C 是一个单字符，且保证是字符串 S 里的字符。\n- S 和 C 中的所有字母均为小写字母。\n\n```\n````\n\n### 2、思路\n\n\n\n把c看作边界，分成以c为分界的窗口，求s中每个元素索引到一个窗口内到边界的距离的最小值。\n\n把最小值放入设定好的数组中，返回数组。\n\n步骤：\n\n1.首先传入字符串s和作为边界的c\n\n2.设定数组res：数组元素个数为n=len(s)，res = [0 for i in range(n)]\n\n3.设定左边界l：l = 0 if s[0] == c else n\n\n3.设定右边界,查找索引1开始查找到的第一个c的位置 r： r = s.find(c, 1)\n\n4.遍历s元素中的索引并求得左边界和右边界距离的最小值，把最小值放入设定数组res中，如果遍历到元素与c相同则说明元素到了边界右端，开启下个窗口，使目前右边界设为新窗口的左边界，继续找下一个c的位置设为右边界：\n\n```py\nfor i in range(n)：\n\n\tres[i] = min(abs(i-l),abs(r-i))\n\n\tif\ti==r：\n    \tl = r\n    \tr = s.find(c,l+1) \nreturn res\n```\n\n​\t\t\t\n\n### 3、代码\n\n```py\nclass Solution(object):\n def shortestToChar(self, s, c):\n      \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n      \"\"\"\n      n = len(s)\n      res = [0 for i in range(n)]\n      l = 0 if s[0]==c else n\n      r = s.find(c, 1)\n    \n      for i in range(n):\n        res[i] = min(abs(i - l), abs(r - i))\n    \n        if  i == r:\n            l = r\n            r = s.find(c,l+1)\n      return res\n```\n\n### 4、复杂度：O（n）\n\n\n\n### 5、总结\n\n基础比较差，只是在理解基础上，背会默写了一遍，算法小白表示即使自己看了题写不出来，但经过看讲义和解答，深入理解后，自己也可以默写出答案，收获很多。以后还要多加练习和学习。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/4#issuecomment-2513973320","body":"# Day 3】1381. 设计一个支持增量操作的栈\r\n\r\n\r\n\r\n## 1、问题\r\n\r\n````\r\n```\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 CustomStack ：\r\n\r\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n\r\n\r\n示例：\r\n\r\n输入：\r\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\r\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\r\n输出：\r\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\r\n解释：\r\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\r\ncustomStack.push(1); // 栈变为 [1]\r\ncustomStack.push(2); // 栈变为 [1, 2]\r\ncustomStack.pop(); // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\ncustomStack.push(2); // 栈变为 [1, 2]\r\ncustomStack.push(3); // 栈变为 [1, 2, 3]\r\ncustomStack.push(4); // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\ncustomStack.increment(5, 100); // 栈变为 [101, 102, 103]\r\ncustomStack.increment(2, 100); // 栈变为 [201, 202, 103]\r\ncustomStack.pop(); // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\ncustomStack.pop(); // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\ncustomStack.pop(); // 返回 201 --> 返回栈顶值 201，栈变为 []\r\ncustomStack.pop(); // 返回 -1 --> 栈为空，返回 -1\r\n\r\n\r\n提示：\r\n\r\n1 <= maxSize <= 1000\r\n1 <= x <= 1000\r\n1 <= k <= 1000\r\n0 <= val <= 100\r\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\r\n```\r\n````\r\n\r\n\r\n\r\n\r\n\r\n## 2、思路\r\n\r\n初始化栈，有储存元素列表、当前元素数量、最大容量和一个随出入栈动态变化的元素增量列表。\r\n\r\n然后实现入栈操作：判断栈的容量是否已满，当前数量小于最大容量\r\n\r\n实现出栈操作：判断栈是否为空，当前数量是否为0，为0返回-1，判断目前数量是否至少有2个元素，如果有则把倒数第一的增量加到倒数第二上，然后再删除末尾元素和末尾增量值并返回末尾元素的值与增量表末尾的增量之和。\r\n\r\n实现增量操作：判断容量是否为空，若不为空，进行增量操作，为使增量范围不超过当前元素数量，在要增量的前个k元素的k值和当前元素数量之间取最小值，并-1得到索引求增量对应位置的目前增量值，再与新加入的要求前k数增量Val求和。\r\n\r\n\r\n\r\n## 3、代码\r\n\r\n```py\r\nclass CustomStack():\r\n  def __init__(self, size: int):\r\n      self.st = []\r\n      self.cnt = 0\r\n      self.size = size\r\n      self.incrementals = []\r\n\r\n  def push(self, x:int) -> None:\r\n      if self.cnt < self.size:\r\n          self.st.append(x)\r\n          self.incrementals.append(0)\r\n          self.cnt += 1\r\n\r\n\r\n  def pop(self)-> int:\r\n      if self.cnt == 0: return -1\r\n      self.cnt -= 1\r\n      if self.cnt >= 1:\r\n         self.incrementals[-2] += self.incrementals[-1]\r\n      return self.st.pop() + self.incrementals.pop()\r\n\r\n  def increment(self, k: int, val:int) -> None:\r\n        if self.incrementals:\r\n            self.incrementals[min(self.cnt, k)-1] += val\r\n\r\n```\r\n\r\n\r\n\r\n## 4、复杂度\r\n\r\n1. **增量值列表动态调整:** 我们不再使用一个固定大小为 `maxSize` 的 `incrementals` 数组，而是使用一个动态的列表，它的大小始终与当前栈的长度保持一致。\r\n2. **入栈和出栈同步操作:** 每次执行 `push` 操作时，我们同时将一个新的增量值 0 入栈到 `incrementals` 列表中。类似地，每次执行 `pop` 操作时，我们也会将增量值与栈顶元素一起出栈。这样就保证了 `incrementals` 列表始终与栈元素保持一致。\r\n3. **空间复杂度降低:** 通过这种优化，我们避免了使用一个大小为 `maxSize` 的固定数组，将空间复杂度从 `O(maxSize)` 降低到了 `O(n)`，其中 `n` 是当前栈的长度。\r\n\r\n\r\n\r\n## 5、总结\r\n\r\n还是没写出来代码，跟着讲义和答案解析，自己尝试理解代码逻辑，背会默写。","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/6#issuecomment-2520349670","body":"## **【Day 5】232. 用栈实现队列**\n\n\n\n\n\n### 1、问题\n\n~~~py\n```\n使用栈实现队列的下列操作：\n\npush(x) -- 将一个元素放入队列的尾部。\npop() -- 从队列首部移除元素。\npeek() -- 返回队列首部的元素。\nempty() -- 返回队列是否为空。\n示例:\n\nMyQueue queue = new MyQueue();\n\nqueue.push(1);\nqueue.push(2);\nqueue.peek(); // 返回 1\nqueue.pop(); // 返回 1\nqueue.empty(); // 返回 false\n说明:\n\n你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n假设所有操作都是有效的、 （例如，一个空的队列不会调用 pop 或者 peek 操作）。\n```\n~~~\n\n\n\n### 2、思路\n\n一个栈推入，另一个栈推出，实现队列需要先进先出，可以把推入栈的的元素pop到推出栈里\n\n- 首先设一个队列类：class MyQueue\n- 初始化栈：推入栈input_stack=[]，推出栈output_stack=[]\n- 定义写入操作：push（self，x:int)，x为要推入的参数，推入只需x把apend仅推入栈\n- 定义一个移动操作：把推入栈的元素转到推出栈里，in2out（），当推出栈为空时，转移所有推入栈的元素，保证推出栈始终有元素\n- 定义推出操作：pop（self），推出操作时，调用in2out把在推入栈先推入的元素pop出来，用返回接收从推出栈中pop出的元素\n- 定义获取元素的操作：peek（self），先调用in2out判断目前推出栈是否有余额，若没有则将，在推出栈位置为-1，返回推出栈索-1位置的元素，也是最先推入的元素\n- 定义判断队列是否为空：empty（self），返回推入栈且推出栈都为空时的布尔值\n\n\n\n### 3、代码\n\n\n\n```py\nclass MyQueue:\n    def __init__(self):\n            self.in_stack = []\n            self.out_stack = []\n\n    def push(self, x: int) -> None:\n            self.in_stack.append(x)\n\n    def in2out(self) :\n        if not self.out_stack:\n            while self.in_stack:\n                self.out_stack.append(self.in_stack.pop())\n\n    def pop(self) -> int:\n        self.in2out()\n        return self.out_stack.pop()\n\n    def peek(self):\n        self.in2out()\n        return self.out_stack[-1]\n\n\n    def empty(self) -> bool:\n        return len(self.in_stack) == 0 and len(self.out_stack) == 0\n\n\n```\n\n\n\n### 4、复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/7#issuecomment-2523222199","body":"## 【Day 6】768. 最多能完成排序的块 II\n\n\n\n### 1、问题\n\n~~~py\n```\n这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10**8。\n\narr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\n\n我们最多能将数组分成多少块？\n\n示例 1:\n\n输入: arr = [5,4,3,2,1]\n输出: 1\n解释:\n将数组分成2块或者更多块，都无法得到所需的结果。\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。\n示例 2:\n\n输入: arr = [2,1,3,4,4]\n输出: 4\n解释:\n我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。\n然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。\n注意:\n\narr的长度在[1, 2000]之间。\narr[i]的大小在[0, 10**8]之间。\n\n```\n~~~\n\n\n\n### 2、思路\n\n遍历元素，如果当前元素小于栈中最大的元素，则表明当前元素不能单独成块，说明之前的块没有分正确，需要pop出栈里的元素直到找到当前元素大于等于的元素，然后以此分块，重新压入栈中\n\n- 如果当前元素大于等于栈里最大元素，则直接可分块\n\n\n\n### 3、代码\n\n```py\nclass Solution:\n    def maxChunksToSorted(self, A:int) -> int:\n        stack = []\n        for a in A:\n            if stack and stack[-1] > a:\n                cur = stack[-1]\n\n                while stack and stack[-1] > a: stack.pop()\n                stack.append(cur)\n            else:\n                stack.append(a)\n        return len(stack)\n\n```\n\n\n\n\n\n### 4、复杂度\n\n- 时间：O(n)\n- 空间：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/9#issuecomment-2525842632","body":"## **【Day 8】24. 两两交换链表中的节点**\r\n\r\n\r\n\r\n\r\n\r\n### 1、问题\r\n\r\n````\r\n```\r\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\r\n\r\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\r\n\r\n \r\n\r\n示例 1：\r\n```\r\n\r\n![image](https://p.ipic.vip/r1afvu.jpg)\r\n\r\n```\r\n输入：head = [1,2,3,4]\r\n输出：[2,1,4,3]\r\n示例 2：\r\n\r\n输入：head = []\r\n输出：[]\r\n示例 3：\r\n\r\n输入：head = [1]\r\n输出：[1]\r\n \r\n\r\n提示：\r\n\r\n链表中节点的数目在范围 [0, 100] 内\r\n0 <= Node.val <= 100\r\n```\r\n````\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 2、思路\r\n\r\n使用递归函数，递归余下的每对数字，然后直到边界，返回最后一层的head，在继续上层递归的操作返回置换位置后的next，直到退出递归，最后继续第一对数字的置换，返回置换后的新节点。\r\n\r\n\r\n\r\n### 3、代码\r\n\r\n```py\r\nclass Solution:\r\n    def swapPairs(self, head:ListNode) -> ListNode:\r\n        if not head or not head.next；\r\n        \treturn head\r\n        \r\n        next= head.next\r\n        head.next = self.swapPairs(next.next)\r\n        next.next = head\r\n        return next\r\n```\r\n\r\n\r\n\r\n### 4、复杂度：\r\n\r\n- 时间：O(n)\r\n- 空间：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/11#issuecomment-2530828021","body":"## **【Day 10】160. 相交链表**\n\n\n\n### 1、问题\n\n````\n```\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\n\n图示两个链表在节点 c1 开始相交：\n\n```\n\n![](https://p.ipic.vip/bkdl1z.jpg)\n\n```\n题目数据 保证 整个链式结构中不存在环。\n\n注意，函数返回结果后，链表必须 保持其原始结构 。\n\n \n\n示例 1：\n```\n\n![](https://p.ipic.vip/bzw15z.jpg)\n\n```\n\n\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n示例 2：\n```\n\n![](https://p.ipic.vip/26cojo.jpg)\n\n```\n\n输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Intersected at '2'\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n示例 3：\n\n```\n\n![](https://p.ipic.vip/2tpyar.jpg)\n\n```\n\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n \n\n提示：\n\nlistA 中节点数目为 m\nlistB 中节点数目为 n\n0 <= m, n <= 3 * 104\n1 <= Node.val <= 105\n0 <= skipA <= m\n0 <= skipB <= n\n如果 listA 和 listB 没有交点，intersectVal 为 0\n如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1]\n \n\n进阶：你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？\n\n```\n````\n\n\n\n### 2、思路\n\n两个指针分别走两条链，走完换另一条，直到两指针相遇，返回交叉点\n\n```py\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        a, b = headA, headB\n        while a != b:\n            a = a.next if a else headB\n            b = b.next if b else headA\n        return a\n```\n\n\n\n### 3、复杂度\n\n- 时间：O(N)\n- 空间：O(1)\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/13#issuecomment-2538249728","body":"## 【Day 12】146. LRU 缓存机制\n\n### 1、问题\n\n````\n```\n运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。\n实现 LRUCache 类：\n\nLRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存\nint get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。\nvoid put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。\n\n\n进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？\n\n\n\n示例：\n\n输入\n\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n输出\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n解释\n\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // 缓存是 {1=1}\nlRUCache.put(2, 2); // 缓存是 {1=1, 2=2}\nlRUCache.get(1);    // 返回 1\nlRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}\nlRUCache.get(2);    // 返回 -1 (未找到)\nlRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}\nlRUCache.get(1);    // 返回 -1 (未找到)\nlRUCache.get(3);    // 返回 3\nlRUCache.get(4);    // 返回 4\n```\n````\n\n\n\n### 2、思路\n\n构建双向链表，并用哈希表进行查询操作\n\n\n\n### 3、代码\n\n```py\nclass Node:\n\n    def __init__(self, key, val):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.head = Node(0, 0)\n        self.tail = Node(0, 0)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.lookup = dict()\n        self.max_len = capacity\n\n    def get(self, key: int) -> int:\n        if key in self.lookup:\n            node = self.lookup[key]\n            self.remove(node)\n            self.add(node)\n            return node.val\n        else:\n            return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.lookup:\n            self.remove(self.lookup[key])\n        if len(self.lookup) == self.max_len:\n            self.remove(self.head.next)\n        self.add(Node(key, value))\n\n    def remove(self, node):\n        del self.lookup[node.key]\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add(self, node):\n        self.lookup[node.key] = node\n        pre_tail = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n        pre_tail.next = node\n        node.prev = pre_tail\n```\n\n### 4、复杂度\n\n- 时间：O(1)\n- 空间：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/15#issuecomment-2543057895","body":"## **【Day 14】100. 相同的树**\n\n\n\n### 1、问题\n\n````\n```\n给定两个二叉树，编写一个函数来检验它们是否相同。\n\n如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n\n示例 1:\n\n输入:       1         1\n          / \\       / \\\n         2   3     2   3\n\n        [1,2,3],   [1,2,3]\n\n输出: true\n示例 2:\n\n输入:      1          1\n          /           \\\n         2             2\n\n        [1,2],     [1,null,2]\n\n输出: false\n示例 3:\n\n输入:       1         1\n          / \\       / \\\n         2   1     1   2\n\n        [1,2,1],   [1,1,2]\n\n输出: false\n```\n````\n\n\n\n\n\n### 2、思路\n\n通过递归调用每一层的对应位置的节点是否相等，考虑节点为空的情况\n\n### 3、代码\n\n```python\nclass Solution:\n\tdef isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n\t\tif not p and not q:\n\t\t\treturn True\n\t\tif not p or not q:\n\t\t\treturn False\n\t\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n\n\n\n### 4、复杂度\n\n- 时间：O(n)\n- 空间：O(h)，h为树高度","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/17#issuecomment-2545355603","body":"## **【Day 16】513. 找树左下角的值**\n\n\n\n### 1、问题\n\n````\n```\n给定一个二叉树，在树的最后一行找到最左边的值。\n\n示例 1:\n\n输入:\n\n    2\n   / \\\n  1   3\n\n输出:\n1\n \n\n示例 2:\n\n输入:\n\n        1\n       / \\\n      2   3\n     /   / \\\n    4   5   6\n       /\n      7\n\n输出:\n7\n \n\n```\n````\n\n\n\n### 2、思路\n\n使用广度优先搜索，建立一个队列记录当前层的节点以及方便实现对应操作，保证先左节点后右节点的顺序搜索，返回最深层最左边的节点值\n\n## 3、代码\n\n```py\nclass Solution(object):\n    def findBottomLeftValue(self,root):\n        queue = collections.deque() #建立双边队列\n        queue.append(root) #初始化，把根节点加入队列\n        while queue:\n            length = len(queue) #记录当前层的节点数\n            res = queue[0].val\t#记录最左边的节点值\n            for _ in range(length):\n                cur = queue.popleft() #取出当前层左边的节点\n                if cur.left:\n                    queue.append(cur.left)\n                if cur.right:\n                    queue.append(cur.right)\n       return res\n                \n```\n\n\n\n### 4、复杂度\n\n- 时间：O(n)\n- 空间：O(队列长度)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/21#issuecomment-2556958971","body":"## **【Day 20】347. 前 K 个高频元素**\n\n\n\n### 1、问题\n\n````\n```\n给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。\n\n \n\n示例 1:\n\n输入: nums = [1,1,1,2,2,3], k = 2\n输出: [1,2]\n示例 2:\n\n输入: nums = [1], k = 1\n输出: [1]\n \n\n提示：\n\n1 <= nums.length <= 10^5\nk 的取值范围是 [1, 数组中不相同的元素的个数]\n题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的\n \n\n进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。\n\n```\n````\n\n\n\n\n\n### 2、思路\n\n使用桶来存储相同频率的元素，用索引表示频率，使用倒序循环出前K个频率最大的元素表\n\n### 3、代码\n\n```py\n# 定义函数,参数为数组nums和要取频率最大的前K项\ndef topKFrequent(self, nums: List[int], k: int) -> List[int]:\n\t# 计算nums中的元素频率，放入字典，键为频率，值为元素\n\tcount = Counter(nums) \n\t# 创建桶，索引为频率，桶存放为对应频率的所有元素,为了使索引对应频率，需要加入索引为0的桶，所以是len(nums)+1\n\tbucket = [[] for _ in range(len(nums) + 1)]\n\t# 遍历出count字典中的元素和频率\n\tfor num, freq in count.items():\n\t\t# 把元素放入索引为频率freq的桶中\n\t\tbucket[freq].append(num)\n\t\t\n\t\t\n\n\t# 从高频到低频遍历桶，收集前k个高频元素\n\tres = []\n\t# 倒序遍历桶，为从索引最大先开始遍历，由于长度有0存在，需要-1，到0停止\n\tfor freq in range(len(bucket)-1, 0, -1):\n\t\t# 把倒序出的频率所对应的元素加入res表中\n\t\tres.extend(bucket[freq])\n\t\t# 如果res表元素数量大于等于k\n\t\tif len(res) >= k:\n\t\t\t# 则返回前K个最大频率元素表\n\t\t\treturn res[:k]\n\t\t\n\t\t\n\t\t\n```\n\n\n\n### 4、空间复杂度\n\n- 时间：O(n)\n- 空间：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/23#issuecomment-2558446321","body":"## **【Day 22】3. 无重复字符的最长子串**\r\n\r\n\r\n### 1、问题\r\n\r\n```\r\n```\r\n给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\r\n\r\n示例 1:\r\n\r\n输入: \"abcabcbb\"\r\n输出: 3\r\n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\r\n\r\n示例 2:\r\n\r\n输入: \"bbbbb\"\r\n输出: 1\r\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\r\n示例 3:\r\n\r\n输入: \"pwwkew\"\r\n输出: 3\r\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\r\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\r\n```\r\n```\r\n\r\n### 2、思路\r\n\r\n使用滑块来寻找最大长度连续子串：\r\n\r\n1. 首先初始化函数，参数为字符串返回长度整数。初始化：一个集合用来存放可能的最大长度字符串；一个初始为0的左边界：当集合中有重复字符时，需要左边界向右移动；一个储存最大长度的整数变量：用来存放当前最大长度，直到最后返回最终最大长度的连续子串的整数长度。\r\n2. 设计滑块。遍历字符长度作为字符串的索引，表示右边界向右逐个移动。\r\n    - 当检测到右边界的元素在集合已经存在相同元素时，需要从左边界开始移除元素直到不重复，每次移除后需要左边界往右移动，因为左边界的元素被移除，没有元素了，左边界往右走了一步。\r\n    - 如果没遇到相同元素出现，则把当前右边界的元素加入到集合中，方便记录长度。\r\n    - 判断每次遍历元素形成的集合长度是否大于记录的最大集合长度，如果大于则把当前集合长度覆盖最大长度。\r\n    - 右边界到结尾，最后返回最大长度。\r\n\r\n### 3、代码\r\n\r\n```python\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n\t\t    char_set = set()\r\n\t\t    left = 0\r\n\t\t    length_max = 0\r\n\t\t    \r\n\t\t    # 设计滑块\r\n\t\t    for s[right] in range(len(s)):\r\n\t\t    \r\n\t\t        # 当遇到重复字符，则从集合移除元素，直到与集合中元素不重复\r\n\t\t        while s[right] in char_set:\r\n\t\t\t\t\t      char_set.remove(s[left])\r\n\t\t\t          left += 1\r\n\t\t\t      \r\n\t\t\t      # 若没遇到相同元素，则继续添加当前元素到集合中\r\n\t\t\t      char_set.add(s[right])\r\n\t\t\t      \r\n\t\t\t      # 记录目前长度\r\n\t\t\t      current_length = right - left + 1\r\n\t\t\t      \r\n\t\t\t      # 判断当前集合长度是否大于记录得最大长度\r\n\t\t\t      if current_length > length_max:\r\n\t\t\t          length_max = current_length\r\n\t\t\t      \r\n\t\t\t   # 返回结果\r\n\t\t\t   return length_max\t\t\t          \r\n\t\t\t        \r\n\t\t    \r\n```\r\n\r\n### 4、复杂度\r\n\r\n- 时间：O(n)\r\n- 空间：O(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/27#issuecomment-2562355631","body":"## **【Day 26】26.删除排序数组中的重复项**\n\n### 1、问题\n\n```\n```\n给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n\n示例 1:\n\n给定数组 nums = [1,1,2],\n\n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。\n\n你不需要考虑数组中超出新长度后面的元素。\n示例 2:\n\n给定 nums = [0,0,1,1,1,2,2,3,3,4],\n\n函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\n\n你不需要考虑数组中超出新长度后面的元素。\n\n说明:\n\n为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n```\n```\n\n### 2、思路\n\n初始化两个指针，读和写：\n\n- 遇到与前项相同，则写指针保持不变，读指针继续前行\n- 遇到不同，则写指针写入读取得元素，然后读指针继续前行\n- 最后返回写指针记录的数\n\n### 3、代码\n\n```python\nclass Solution(object):\n    def removeDuplicates(self, nums):\n        if not nums:\n            return 0\n            \n        l, r = 0, 0\n        while r < len(nums):\n            if nums[l] != nums[r]:\n                l += 1\n                nums[l] = nums[r]\n            r += 1\n            # 从0开始索引，结果需要加1\n        return l + 1\n                       \n      \n```\n\n### 4、复杂度\n\n- 时间：O(n)\n- 空间：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/29#issuecomment-2564271439","body":"## **【Day 28】239. 滑动窗口最大值**\n\n### 1、问题\n\n```python\n```\n给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n\n返回滑动窗口中的最大值。\n\n \n\n进阶：\n\n你能在线性时间复杂度内解决此题吗？\n\n \n\n示例:\n\n输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3\n输出: [3,3,5,5,6,7]\n解释:\n\n  滑动窗口的位置                最大值\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n \n\n提示：\n\n1 <= nums.length <= 10^5\n-10^4 <= nums[i] <= 10^4\n1 <= k <= nums.length\n\n```\n```\n\n### 2、思路\n\n使用双端队列，来保留滑块单调性以及增减操作。记录每个滑块的最大值在一个表中。\n\n### 3、代码\n\n```python\nclass Solution:\n \n    def maxSlidingWindow(self, nums:list[int], k:int) -> List[int]:\n        # 初始化队列和表\n        q = collections.deque()\n        ans = []\n        \n        for i in range(len(nums)):\n            # 队列保持单调性\n            while q and nums[q[-1]] <= nums[i]: q.pop()\n            # 清理滑块外的元素\n            while q and i -q[0] >= k: q.popleft()\n            # 把当前索引假如到队列\n            q.append(i)\n            \n            # 把滑块最大值元素记录到表中\n            if i >=  k -1 : ans.append(nums[q[0]])\n            \n        return ans\n```\n\n### 4、复杂度\n\n- 时间：O(n)\n- 空间：O(k)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/31#issuecomment-2565220201","body":"# \n\n# **【Day 30】886. 可能的二分法**\n\n\n### 1、问题\n\n```\n```\n给定一组 N 人（编号为 1, 2, ..., N）， 我们想把每个人分进任意大小的两组。\n\n每个人都可能不喜欢其他人，那么他们不应该属于同一组。\n\n形式上，如果 dislikes[i] = [a, b]，表示不允许将编号为 a 和 b 的人归入同一组。\n\n当可以用这种方法将每个人分进两组时，返回 true；否则返回 false。\n\n示例 1：\n\n输入：N = 4, dislikes = [[1,2],[1,3],[2,4]]\n输出：true\n解释：group1 [1,4], group2 [2,3]\n示例 2：\n\n输入：N = 3, dislikes = [[1,2],[1,3],[2,3]]\n输出：false\n示例 3：\n\n输入：N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]\n输出：false\n\n提示：\n\n1 <= N <= 2000\n0 <= dislikes.length <= 10000\ndislikes[i].length == 2\n1 <= dislikes[i][j] <= N\ndislikes[i][0] < dislikes[i][1]\n对于dislikes[i] == dislikes[j] 不存在 i != j\n\n```\n```\n\n### 2、思路\n\n创建无向图矩阵来储存相互不喜欢元素的关系，使用深度有限搜索递归遍历图的节点。\n\n首先创建一个深度优先搜索方法，用来对节点进行分组，给定分组颜色\n\n- 遍历当前节点与所有相邻的节点：如果节点颜色相同，则返回False；若不同则使用递归dfs来给此节点进行分配相反颜色，若返回False则不能分\n- 若遍历完，相邻节点没有冲突，则分组成功返回True\n\n然后创建图，并对每个节点遍历：\n\n- 创建一个NxN的矩阵，初始化所有节点的颜色都默认为0\n- 从不喜欢表里遍历出每两个的元素，在图中对应位置设为1，表示不喜欢的颜色分组，注意双向性，以及方便处理，节点表示需对应索引，需要位置-1操作\n- 对每个节点进行遍历以分组，若最终有冲突返回False\n- 若没冲突，则分组成功，返回True\n\n### 3、代码\n\n```python\nclass Solution:\n    def dfs(self, graph, colors, i, color, N):\n        colors[i] = color\n        for j in range(N):\n            # 遇到不喜欢的\n            if graph[i][j] == 1:\n                # 并且颜色相同\n                if colors[j] == color:\n                    # 则不能分组\n                    return False\n                    \n                # 如果为分配颜色,则递归为它分当前节点相反的颜色\n                if colors[j] == 0 and not self.dfs(graph, colors, j, -1 * color, N):\n                    # 分配颜色失败，返回False\n                    return False\n        # 此节点分颜色成功\n        return True\n        \n        \n# 判断是否能把所有节点分组成功\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        # 创建图\n        graph = [[0] * N for i in range(N)]\n        colors = [0] * N\n        \n        for a, b in dislikes:\n            # 不喜欢赋为1\n            graph[a-1][b-1] = 1\n            # 双向\n            graph[b-1][a-1] = 1\n            \n            \n        for i in range(N):\n            if colors[i] == 0 and not self.dfs(graph, colors, i, 1, N):\n                return False\n        return True \n```\n\n### 4、复杂度\n\n V 和 E 分别为图中的点和边的数目\n\n- 时间：O(V+E)\n- 空间：O(V*V)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/33#issuecomment-2566893399","body":"## **【Day 32】657. 机器人能否返回原点**\n\n\n### 1、问题\n\n```python\n在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。\n\n移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。\n\n注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。\n\n \n\n示例 1:\n\n输入: \"UD\"\n输出: true\n解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。\n\n示例 2:\n\n输入: \"LL\"\n输出: false\n解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。\n```\n\n### 2、思路\n\n模拟上下左右移动，初始化左右上下操作\n\n上右加一，下左减一，若结果最后为（0,0）则返回True，表示可以回到原处\n\n### 3、代码\n\n```python\nclass Solution:\n    def judgeCircle(self, moves:str) -> bool:\n        x, y = 0, 0\n        for move in moves:\n            if move == 'R': x += 1\n            if move == 'L': x -= 1\n            if move == 'U': y += 1\n            if move == 'D': y -= 1\n            \n        return x == 0 and y == 0    \n```\n\n### 4、复杂度\n\n- 时间：O(N)\n- 空间：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/35#issuecomment-2568875202","body":"## **【Day 34】1904. 你完成的完整对局数**\n\n### 1、问题\n\n```python\n一款新的在线电子游戏在近期发布，在该电子游戏中，以 刻钟 为周期规划若干时长为 15 分钟 的游戏对局。这意味着，在 HH:00、HH:15、HH:30 和 HH:45 ，将会开始一个新的对局，其中 HH 用一个从 00 到 23 的整数表示。游戏中使用 24 小时制的时钟 ，所以一天中最早的时间是 00:00 ，最晚的时间是 23:59 。\n\n给你两个字符串 startTime 和 finishTime ，均符合 \"HH:MM\" 格式，分别表示你 进入 和 退出 游戏的确切时间，请计算在整个游戏会话期间，你完成的 完整对局的对局数 。\n\n例如，如果 startTime = \"05:20\" 且 finishTime = \"05:59\" ，这意味着你仅仅完成从 05:30 到 05:45 这一个完整对局。而你没有完成从 05:15 到 05:30 的完整对局，因为你是在对局开始后进入的游戏；同时，你也没有完成从 05:45 到 06:00 的完整对局，因为你是在对局结束前退出的游戏。\n如果 finishTime 早于 startTime ，这表示你玩了个通宵（也就是从 startTime 到午夜，再从午夜到 finishTime）。\n\n假设你是从 startTime 进入游戏，并在 finishTime 退出游戏，请计算并返回你完成的 完整对局的对局数 。\n\n \n\n示例 1：\n\n输入：startTime = \"12:01\", finishTime = \"12:44\"\n输出：1\n解释：你完成了从 12:15 到 12:30 的一个完整对局。\n你没有完成从 12:00 到 12:15 的完整对局，因为你是在对局开始后的 12:01 进入的游戏。\n你没有完成从 12:30 到 12:45 的完整对局，因为你是在对局结束前的 12:44 退出的游戏。\n示例 2：\n\n输入：startTime = \"20:00\", finishTime = \"06:00\"\n输出：40\n解释：你完成了从 20:00 到 00:00 的 16 个完整的对局，以及从 00:00 到 06:00 的 24 个完整的对局。\n16 + 24 = 40\n示例 3：\n\n输入：startTime = \"00:00\", finishTime = \"23:59\"\n输出：95\n解释：除最后一个小时你只完成了 3 个完整对局外，其余每个小时均完成了 4 场完整对局。\n \n\n提示：\n\nstartTime 和 finishTime 的格式为 HH:MM\n00 <= HH <= 23\n00 <= MM <= 59\nstartTime 和 finishTime 不相等\n\n```\n\n### 2、思路\n\n将字符转为总分钟，开始时间大于结束表示跨夜，加上到跨夜的时间\n\n- 开始时间不是15倍数，向上取整记到下轮15\n- 结束时间不是15倍数，向下取整记到上轮15\n\n### 3、代码\n\n```python\nclass Solution:\n    def numberOfRounds(self, startTime: str, finishTime: str) -> int:\n        def time2min(t_str):\n            h, m = map(int, t_str.split(\":\"))\n            return h * 60 + m\n            \n        start = time2min(startTime)\n        finish = time2min(finishTime)\n        \n        if finish < start:\n            finish += 24*60\n        \n        if start % 15 != 0: start = start + (15 - start %15)       \n        if finish % 15 != 0: finish -= finish % 15\n        if start > finish:\n            return 0\n        \n        return (finish - start) // 15    \n      \n      \n \n```\n\n### 4、复杂度\n\n- 时间：O(1)\n- 空间：O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/38#issuecomment-2572758793","body":"```python\nclass Solution:\n    def mySqrt(self, x:int) -> int:\n        if x < 2:\n            return x\n            \n        left, right = 0, x // 2 + 1\n        ans = 0\n        \n        while left <= right:\n            mid = (left + right) // 2\n            mid_sq = mid * mid\n            \n            if mid_sq == x:\n                return mid\n                \n            elif mid_sq < x:\n                ans = mid\n                left = mid + 1\n            \n            else:\n                right = mid - 1\n                \n        return ans\n            \n            \n                \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/39#issuecomment-2574748834","body":"## **【Day 38】278. 第一个错误的版本**\n\n### 1、问题\n\n```python\n```\n你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。\n\n假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。\n\n你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。\n\n示例:\n\n给定 n = 5，并且 version = 4 是第一个错误的版本。\n\n调用 isBadVersion(3) -> false\n调用 isBadVersion(5) -> true\n调用 isBadVersion(4) -> true\n\n所以，4 是第一个错误的版本。\n\n```\n```\n\n### 2、思路\n\n使用二分法，初始化left和right分别为开头末尾，判断范围中间是否为坏版本\n\n- 若是则第一次坏版本在中间值左边或等于中间值，使得中间值等于right，缩小范围；\n- 若中间值不是坏版本，则在右边，让l中间值+1赋给left，缩小范围；\n- 当left等于right时，返回结果。\n\n### 3、代码\n\n```python\nclass Solution:\n    def firstBadVersion(self, n:int) -> int:\n        left = 1\n        right = n\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            \n            if isBadVersion(mid):\n                right = mid\n            else:\n                left = mid + 1\n                \n        return left            \n                \n```\n\n#### 复杂度\n\n- 时间：O(logn)\n- 空间：O(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/44#issuecomment-2585600627","body":"### **【Day 43】1456. 定长子串中元音的最大数目**\n\n#### 1、问题\n\n```python\n```\n给你字符串 s 和整数 k 。\n\n请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。\n\n英文中的 元音字母 为（a, e, i, o, u）。\n\n示例 1：\n\n输入：s = \"abciiidef\", k = 3\n输出：3\n解释：子字符串 \"iii\" 包含 3 个元音字母。\n示例 2：\n\n输入：s = \"aeiou\", k = 2\n输出：2\n解释：任意长度为 2 的子字符串都包含 2 个元音字母。\n示例 3：\n\n输入：s = \"leetcode\", k = 3\n输出：2\n解释：\"lee\"、\"eet\" 和 \"ode\" 都包含 2 个元音字母。\n示例 4：\n\n输入：s = \"rhythms\", k = 4\n输出：0\n解释：字符串 s 中不含任何元音字母。\n示例 5：\n\n输入：s = \"tryhard\", k = 4\n输出：1\n\n提示：\n\n1 <= s.length <= 10^5\ns 由小写英文字母组成\n1 <= k <= s.length\n\n```\n```\n\n#### 2、思路\n\n使用滑动窗口计算每个当下窗口的元音数量与之前最大值比较，并返回最终结果。\n\n- 初始化一个最大值：遍历k，判断最初的k个字符子串中元音数量，并把数量存为初始最大值。\n- 滑块进行滑动：从第k个元素开始遍历到末尾，删除当前滑块最左端，若它为元音，则对当前数量进行减1；对新增元素判断是否为元音，若是则对当前数量加1\n- 返回结果：比较最大数量和当前数量，取两者最大值，返回结果。\n\n#### 3、代码\n\n```python\nclass Solution():\n    def maxVowels(self, s:str, k:int) -> int:\n        # 初始化：元音元素集合、最大值、当前值\n        vowels = set('aeiou')\n        max_c = 0\n        current_c = 0\n        \n        # 初始化最大值\n        for i in range(k):\n            if s[i] in vowels:\n                current_c += 1\n        max_c = current_c\n            \n        # 滑块移动\n        for i in range(k, len(s)):\n            # 如果要删除的滑块最左端为元音，则对当前值进行-1\n            if s[i-k] in vowels:\n                current_c -= 1\n            # 如果要增加的新元素为元音，则对当前值进行+1\n            if s[i] in vowels:\n                current_c += 1\n                \n            # 每次移动都笔记比较，取最大值\n            max_c = max(max_c, current_c)\n        \n        return max_c     \n```\n\n- 复杂度\n    - 时间：O(n)\n    - 空间：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/46#issuecomment-2589489323","body":"## **【Day 45】438. 找到字符串中所有字母异位词**\n\n### 1、问题\n\n```\n```\n给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。\n\n字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。\n\n说明：\n\n字母异位词指字母相同，但排列不同的字符串。\n不考虑答案输出的顺序。\n示例 1:\n\n输入:\ns: \"cbaebabacd\" p: \"abc\"\n\n输出:\n[0, 6]\n\n解释:\n起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的字母异位词。\n起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的字母异位词。\n 示例 2:\n\n输入:\ns: \"abab\" p: \"ab\"\n\n输出:\n[0, 1, 2]\n\n解释:\n起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的字母异位词。\n起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的字母异位词。\n起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的字母异位词。\n```\n```\n\n### 2、思路\n\n使用滑块计算每个滑块中各字符的频率，并与所给的p作比较，相同则把子串索引添加到同一个列表中，最后返回列表。\n\n- 初始化：传入s字符串和要比较相同频率的p，初始一个res列表存放每个子串的初始索引，初始最开始的窗口个子串的频率哈希表（在创建之考虑s字符串长度小于p的情况）\n- 寻找异位子串对应的初始索引：从初始窗口的所需最后一位开始遍历，把刚更新的子串所对应的频率加1，刚好长度与p相等，之后与p对应的哈希表子串频率进行比较是否相同，若相同则把子串对应的初始索引添加到res表中\n- 然后为下次循环的右移添加做准备，对当前窗口最左边字符在窗口哈希表对应频率进行减一操作，若最左边所对应字符的窗口频率为0，则需在窗口哈希表中进行删除操作，优化空间。\n\n### 3、代码\n\n```python\nclass Solution:\n    def findAnagrams(self, s:str, p:str) -> List[int]:\n        res = []\n        len_s, len_p = len(s), len(p)\n        \n        if len_s < len_p:\n           return res\n        \n        p_c = Counter(p)\n        win_c = Counter(s[:len_p-1])\n        \n        for i in range(len_p-1, len_s):\n            win_c[s[i]] += 1\n            if win_c == p_c:\n                res.append(i - len_p + 1)\n            win_c[s[i - len_p + 1]] -= 1\n            \n            if win_c[s[i - len_p + 1]] == 0:\n                del win_c[s[i - len_p + 1]]\n       \n        return res              \n```\n\n- 复杂度\n    - 时间：O(n)\n    - 空间：O(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/51#issuecomment-2600800376","body":"## **【Day 50】695. 岛屿的最大面积**\n\n### 1、问题\n\n```\n```\n给定一个包含了一些 0 和 1 的非空二维数组 grid 。\n一个 岛屿 是由一些相邻的 1 （代表土地） 构成的组合，\n这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。\n你可以假设 grid 的四个边缘都被 0（代表水）包围着。\n找到给定的二维数组中最大的岛屿面积。（如果没有岛屿，则返回面积为 0 。)\n\n示例 1:\n\n[[0,0,1,0,0,0,0,1,0,0,0,0,0],\n [0,0,0,0,0,0,0,1,1,1,0,0,0],\n [0,1,1,0,1,0,0,0,0,0,0,0,0],\n [0,1,0,0,1,1,0,0,1,0,1,0,0],\n [0,1,0,0,1,1,0,0,1,1,1,0,0],\n [0,0,0,0,0,0,0,0,0,0,1,0,0],\n [0,0,0,0,0,0,0,1,1,1,0,0,0],\n [0,0,0,0,0,0,0,1,1,0,0,0,0]]\n对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。\n\n示例 2:\n\n[[0,0,0,0,0,0,0,0]]\n对于上面这个给定的矩阵，返回 0。\n\n注意：给定的矩阵 grid 的长度和宽度都不超过 50\n```\n```\n\n### 2、思路\n\n使用dfs深度优先搜索，来记录岛屿最大值\n\n- 首先初始化max_a、岛屿网格行列数量\n- 使用dfs记录当前岛屿面积\n- 循环遍历每个网格，与记录的最大岛屿面积比较，进行更新最大值，返回结果\n\n### 3、代码\n\n```python\nclass Solution:\n    def maxAreaOfIsland(self, grid:List[List[int]]) -> int:\n        if not grid or not grid[0]:\n            return 0\n        \n        max_a = 0\n        rows, cols = len(grid), len(grid[0])\n        \n        def dfs(r, c):\n            if r < 0 or r >= rows or c < 0 or c > cols or grid[r][c] == 0:\n                return 0\n            \n            #当前陆地标记为已访问\n            grid[r][c] = 0\n            # 每个格子面积为1\n            area = 1\n            #递归访问上下左右\n            area += dfs(r + 1, c)\n            area += dfs(r - 1, c)\n            area += dfs(r, c + 1)\n            area += dfs(r, c - 1)\n            return area\n        \n        # 遍历每个格子，更新岛屿面积最大值\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c] == 1:\n                    current_a = dfs(r, c)\n                    max_a = max(current_a, max_a)\n        return max_a                 \n```\n\n复杂度\n\n- 时间：O(n)\n- 空间：O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/54#issuecomment-2607058562","body":"### **【Day 53】987. 二叉树的垂序遍历**\n\n#### 1、问题\n\n```python\n给你二叉树的根结点 `root` ，请你设计算法计算二叉树的 ****垂序遍历** 序列。\n\n对位于 `(row, col)` 的每个结点而言，其左右子结点分别位于 `(row + 1, col - 1)` 和 `(row + 1, col + 1)` 。树的根结点位于 `(0, 0)` 。\n\n二叉树的 **垂序遍历** 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。\n\n返回二叉树的 **垂序遍历** 序列。\n\n**示例 1：**\n\n!https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg\n\n```\n输入：root = [3,9,20,null,null,15,7]\n输出：[[9],[3,15],[20],[7]]\n解释：\n列 -1 ：只有结点 9 在此列中。\n列  0 ：只有结点 3 和 15 在此列中，按从上到下顺序。\n列  1 ：只有结点 20 在此列中。\n列  2 ：只有结点 7 在此列中。\n```\n\n**示例 2：**\n\n!https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg\n\n```\n输入：root = [1,2,3,4,5,6,7]\n输出：[[4],[2],[1,5,6],[3],[7]]\n解释：\n列 -2 ：只有结点 4 在此列中。\n列 -1 ：只有结点 2 在此列中。\n列  0 ：结点 1 、5 和 6 都在此列中。\n          1 在上面，所以它出现在前面。\n          5 和 6 位置都是 (2, 0) ，所以按值从小到大排序，5 在 6 的前面。\n列  1 ：只有结点 3 在此列中。\n列  2 ：只有结点 7 在此列中。\n\n```\n\n**示例 3：**\n\n!https://assets.leetcode.com/uploads/2021/01/29/vtree3.jpg\n\n```\n输入：root = [1,2,3,4,6,5,7]\n输出：[[4],[2],[1,5,6],[3],[7]]\n解释：\n这个示例实际上与示例 2 完全相同，只是结点 5 和 6 在树中的位置发生了交换。\n因为 5 和 6 的位置仍然相同，所以答案保持不变，仍然按值从小到大排序。\n```\n\n**提示：**\n\n- 树中结点数目总数在范围 `[1, 1000]` 内\n- `0 <= Node.val <= 1000`\n```\n\n#### 2、思路\n\n使用广度优先搜索，搜索所有节点并记录每个列每个节点对应的行和值，保存在一个字典中，字典的key为列，值为列表存放对应列的所有节点的行和值，用元组表示。\n\n对字典的列从小到大遍历，同时每次遍历对当前列中的节点行小到大排序，若同行节点值从小到大排序。取出每次遍历列排好序的每个节点的值，放入一个列表并添加到结果的大列表中，遍历结束返回大列表就是结果。\n\n#### 3、代码\n\n```python\n # 定义二叉树节点\nclass TreeNode:\n    def __init__(self, val: int =0, left: 'TreeNode'=None, right: 'TreeNode'=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        \nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n    \n        if not root:\n            return []\n        \n       \n        col_table = defaultdict(list)\n        queue = deque([(root, 0, 0)]) \n        \n        min_col = max_col = 0\n        \n        while queue:\n            node, row, col = queue.popleft()\n            \n            # 将当前节点加入对应的列\n            col_table[col].append((row, node.val))\n            \n            # 更新最小和最大列\n            min_col = min(min_col, col)\n            max_col = max(max_col, col)\n            \n            # 添加左子节点\n            if node.left:\n                queue.append((node.left, row + 1, col - 1))\n            \n            # 添加右子节点\n            if node.right:\n                queue.append((node.right, row + 1, col + 1))\n        \n                \n        result = []\n        for col in range(min_col, max_col + 1):\n            col_table[col].sort()\n            result.append([val for row, val in col_table[col]])\n         \n        return result      \n```\n\n复杂度\n\n- 时间：O(N)\n- 空间：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaogaoddd":[null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/3#issuecomment-2511530056","body":"## 思路\n\n题目的要求也就是\ns[i] 到其左侧最近的字符 c 的距离\ns[i] 到其右侧最近的字符 c 的距离\n这两者当中的最小值。\n\n对于前者，可以从左往右遍历 s，若 s[i]=c， 则记录下此时字符 c 的下标 idx。遍历的同时更新 answer[i]=i−index。\n对于后者，可以从右往左遍历 s，若 s[i]=c，则记录下此时字符 c 的下标 idx。遍历的同时更新 answer[i]=min(answer[i],index−i)。\n代码实现时，在开始遍历的时候 idx 可能不存在，为了简化逻辑，可以用 −n 或 2n 表示，这里 n 是 s 的长度。\n\n\n## 代码\n```\n int min(int a,int b)\n {\n     return a < b ? a : b;\n }\n int* shortestToChar(char * s, char c, int* returnSize)\n {\n     int *ret = (int*)malloc(sizeof(int)*strlen(s));\n     int n = strlen(s);\n     (*returnSize) = strlen(s);\n     for(int i = 0,index = -n; i < strlen(s); i++){\n    //从前往后比较，对c后面的字符距离进行改变，故为i - index\n    //一开始i为0，为了使这个值为正且最大（为字符串长度），index要为-n\n         if(s[i] == c){\n            index = i;\n        }\n         ret[i] = i - index;\n     }\n    for(int i = n-1,index = 2*n;i >= 0;i--){\n    //从后往前比较，对c前面的字符距离进行改变，故为index - i\n    //一开始i为 strlen(s)-1，为了使这个值为正且最大（为字符串长度），index要为2n\n         if(s[i] == c){\n             index = i;\n         }\n         ret[i] = min(ret[i], index - i);\n     }\n    return ret;\n }\n```\n\n\n## 复杂度分析\n时间复杂度：O(n)。\n空间复杂度：O(1)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/4#issuecomment-2514355104","body":"``` c\r\ntypedef struct {\r\n    int *data; //数据域\r\n    int top; //栈顶指针\r\n    int capcaity; //表示栈的最大容量\r\n} CustomStack;\r\n\r\n\r\nCustomStack* customStackCreate(int capcaity) {\r\n     CustomStack* stack = (CustomStack*)malloc(sizeof(CustomStack));\r\n    stack->data = (int*)malloc(sizeof(int) * capcaity);\r\n    stack->capcaity = capcaity;\r\n    stack->top = -1; //栈顶指针始终指向栈顶的元素，将其先初始化为-1\r\n    return stack;\r\n}\r\n\r\nvoid customStackPush(CustomStack* obj, int x) {\r\n    if (obj->top == obj->capcaity - 1) {\r\n        return;\r\n        }\r\n    obj->data[++obj->top] = x;//判断当前元素的个数是否达到上限，如果没有达到，就把 top 后移一个位置并添加一个元素。\r\n}\r\n\r\nint customStackPop(CustomStack* obj) {\r\n    if (obj->top == -1) {\r\n        return -1;\r\n    }\r\n    return obj->data[obj->top--];//非空返回栈顶元素并将 top 前移一位\r\n}\r\n\r\nvoid customStackIncrement(CustomStack* obj, int k, int val) {\r\n     if (obj->top + 1 < k) {\r\n        for (int i = 0; i <= obj->top; i++) { \r\n            //注意这里需要小于等于，此时栈顶指向的位置是栈顶的元素\r\n            obj->data[i] += val;\r\n        }\r\n    }else {\r\n        for (int i = 0; i < k; i++) {\r\n            obj->data[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\nvoid customStackFree(CustomStack* obj) {\r\n    free(obj->data);\r\n    free(obj);//释放\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/5#issuecomment-2517100869","body":"```C++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string res = \"\";\n        stack <int> nums;\n        stack <string> strs;\n        int num = 0;\n        int len = s.size();\n        for(int i = 0; i < len; ++ i)\n        {\n            if(s[i] >= '0' && s[i] <= '9')\n            {\n                num = num * 10 + s[i] - '0';\n            }\n            else if((s[i] >= 'a' && s[i] <= 'z') ||(s[i] >= 'A' && s[i] <= 'Z'))\n            {\n                res = res + s[i];\n            }\n            else if(s[i] == '[') \n            {\n                nums.push(num);\n                num = 0;\n                strs.push(res); \n                res = \"\";\n            }\n            else\n            {\n                int times = nums.top();\n                nums.pop();\n                for(int j = 0; j < times; ++ j)\n                    strs.top() += res;\n                res = strs.top(); \n                strs.pop();\n            }\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/6#issuecomment-2519779511","body":"```C\ntypedef struct {\n    int* stk;\n    int stkSize;\n    int stkCapacity;\n} Stack;\n\nStack* stackCreate(int cpacity) {\n    Stack* ret = malloc(sizeof(Stack));\n    ret->stk = malloc(sizeof(int) * cpacity);\n    ret->stkSize = 0;\n    ret->stkCapacity = cpacity;\n    return ret;\n}\n\nvoid stackPush(Stack* obj, int x) {\n    obj->stk[obj->stkSize++] = x;\n}\n\nvoid stackPop(Stack* obj) {\n    obj->stkSize--;\n}\n\nint stackTop(Stack* obj) {\n    return obj->stk[obj->stkSize - 1];\n}\n\nbool stackEmpty(Stack* obj) {\n    return obj->stkSize == 0;\n}\n\nvoid stackFree(Stack* obj) {\n    free(obj->stk);\n}\n\ntypedef struct {\n    Stack* inStack;\n    Stack* outStack;\n} MyQueue;\n\n\nMyQueue* myQueueCreate() {\n MyQueue* ret = malloc(sizeof(MyQueue));\n    ret->inStack = stackCreate(100);\n    ret->outStack = stackCreate(100);\n    return ret;\n}\nvoid stackSwap(MyQueue* obj) {\n    while (!stackEmpty(obj->inStack)) {\n        stackPush(obj->outStack, stackTop(obj->inStack));\n        stackPop(obj->inStack);\n    }\n}\n\nvoid myQueuePush(MyQueue* obj, int x) {\n     stackPush(obj->inStack, x);\n}\n\nint myQueuePop(MyQueue* obj) {\n     if (stackEmpty(obj->outStack)) {\n       stackSwap(obj);\n    }\n    int x = stackTop(obj->outStack);\n    stackPop(obj->outStack);\n    return x;\n}\n\nint myQueuePeek(MyQueue* obj) {\n     if (stackEmpty(obj->outStack)) {\n        stackSwap(obj);\n    }\n    return stackTop(obj->outStack);\n}\n\nbool myQueueEmpty(MyQueue* obj) {\n     return stackEmpty(obj->inStack) && stackEmpty(obj->outStack);\n}\n\nvoid myQueueFree(MyQueue* obj) {\n     stackFree(obj->inStack);\n    stackFree(obj->outStack);\n}\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/12#issuecomment-2536200162","body":"```C\nListNode *detectCycle(ListNode *head) \n{\n    ListNode *fast = head, *slow = head;\n    while (fast && fast->next) \n   {\n        slow = slow->next;\n        fast = fast->next->next;\n        if (slow == fast) \n        { \n            ListNode *f = fast, *h = head;\n            while (f != h) f = f->next, h = h->next;\n            return h;\n        }\n    }\n    return NULL;\n}\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/19#issuecomment-2551352573","body":"```C\nvoid pre_traving(struct TreeNode* root, int* i, int* max, int* min, int nums[][3], int row, int col)//先序遍历二叉树，并将结点的信息都存入nums数组\n{\n    if(root)\n    {\n        *max=(*max>col)?*max:col;\n        *min=(*min<col)?*min:col;\n        nums[*i][0]=root->val;\n        nums[*i][1]=row;\n        nums[*i][2]=col;\n        ++(*i);\n        pre_traving(root->left, i, max, min, nums, row+1, col-1);\n        pre_traving(root->right, i, max, min, nums, row+1, col+1);\n    }\n}\n\nvoid sort(int temp[][2], int n)//插入排序\n{\n    int i,j,t[2];\n    for(i=1; i<n; i++)\n    {\n        t[0]=temp[i][0],t[1]=temp[i][1];\n        for(j=i; j>=1; j--)\n        {\n            if(temp[j-1][1]>t[1])\n            {\n                temp[j][0]=temp[j-1][0];\n                temp[j][1]=temp[j-1][1];\n            }\n            else if(temp[j-1][1]==t[1]&&temp[j-1][0]>t[0])\n            {\n                temp[j][0]=temp[j-1][0];\n                temp[j][1]=temp[j-1][1];\n            }\n            else break;    \n        }\n        temp[j][0]=t[0];\n        temp[j][1]=t[1];\n    }\n}\n\nint** verticalTraversal(struct TreeNode* root, int* returnSize, int** returnColumnSizes){\n    int nums[1000][3];\n    int temp[500][2];\n    int max=0,min=0,tail=0,i,j,k,lenth;//max和min分别表示最小和最大列\n    pre_traving(root, &tail, &max, &min, nums, 0, 0);\n    *returnSize=max-min+1;\n    *returnColumnSizes=(int*)malloc(sizeof(int)*(*returnSize));\n    int** answer=(int**)malloc(sizeof(int*)*(*returnSize));\n    for(j=0,i=min; i<=max; j++,i++)\n    {\n        lenth=0;\n        for(k=0; k<tail; k++)\n        {\n            if(nums[k][2]==i)\n            {\n                temp[lenth][0]=nums[k][0];\n                temp[lenth++][1]=nums[k][1];\n            }\n        }\n        (*returnColumnSizes)[j]=lenth;\n        sort(temp, (*returnColumnSizes)[j]);\n        answer[j]=(int*)malloc(sizeof(int)*(*returnColumnSizes)[j]);\n        for(k=0; k<(*returnColumnSizes)[j]; k++)\n            answer[j][k]=temp[k][0];\n    }\n    return answer;\n}\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/25#issuecomment-2561253344","body":"```\nstruct HashMapNode\n{\n    int key;\n    int val;\n    UT_hash_handle hh;\n};\n\nint minSubarray(int *nums, int numsSize, int p)\n{\n    struct HashMapNode *table = NULL, *node = NULL, *t = NULL;\n    int i = 0, j = 0, remain = 0, result = numsSize, key = 0;\n    while(numsSize > i)\n    {\n        remain = (remain + nums[i]) % p;\n        i++;\n    }\n    if(0 == remain)\n    {\n        return 0;\n    }\n\n    i = 0;\n    while(numsSize > i)\n    {\n        key = j;\n        HASH_FIND_INT(table, &key, node);\n        if(NULL == node)\n        {\n            node = (struct HashMapNode *)malloc(sizeof(struct HashMapNode));\n            node->key = key;\n            node->val = i;\n            HASH_ADD_INT(table, key, node);\n        }\n        else\n        {\n            node->val = i;\n        }\n\n\n        if(remain == j && i + 1 < result)\n        {\n            result = i + 1;\n        }\n\n\n        key = (j >= remain) ? j - remain : j - remain + p;\n        HASH_FIND_INT(table, &key, node);\n        if(NULL != node && i - node->val < result)\n        {\n            result = i - node->val;\n        }\n\n        i++;\n    }\n\n\n    if(numsSize == result)\n    {\n        result = -1;\n    }\n\n    HASH_ITER(hh, table, node, t)\n    {\n        HASH_DEL(table, node);\n        free(node);\n    }\n\n    return result;\n}\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/32#issuecomment-2566143631","body":"```\nint* topSort(int* returnSize, int* deg, int** graph, int* graphColSize, int* items, int itemsSize) {\n    *returnSize = 0;\n    int Q[itemsSize];\n    int left = 0, right = 0;\n    for (int i = 0; i < itemsSize; i++) {\n        if (deg[items[i]] == 0) {\n            Q[right++] = items[i];\n        }\n    }\n    int* res = malloc(sizeof(int) * itemsSize);\n    while (left < right) {\n        int u = Q[left++];\n        res[(*returnSize)++] = u;\n        for (int i = 0; i < graphColSize[u]; i++) {\n            int v = graph[u][i];\n            if (--deg[v] == 0) {\n                Q[right++] = v;\n            }\n        }\n    }\n    if (*returnSize == itemsSize) {\n        return res;\n    }\n    *returnSize = 0;\n    return NULL;\n}\n\nint* sortItems(int n, int m, int* group, int groupSize, int** beforeItems, int beforeItemsSize, int* beforeItemsColSize, int* returnSize) {\n    int* groupItem[n + m];\n    int groupItemColSize[n + m];\n    int groupItemColCapacity[n + m];\n    for (int i = 0; i < n + m; i++) {\n        groupItem[i] = malloc(sizeof(int));\n        groupItemColSize[i] = 0;\n        groupItemColCapacity[i] = 0;\n    }\n\n    int* groupGraph[n + m];\n    int groupGraphColSize[n + m];\n    int groupGraphColCapacity[n + m];\n    for (int i = 0; i < n + m; i++) {\n        groupGraph[i] = malloc(sizeof(int));\n        groupGraphColSize[i] = 0;\n        groupGraphColCapacity[i] = 0;\n    }\n    int* itemGraph[n];\n    int itemGraphColSize[n];\n    int itemGraphColCapacity[n];\n    for (int i = 0; i < n; i++) {\n        itemGraph[i] = malloc(sizeof(int));\n        itemGraphColSize[i] = 0;\n        itemGraphColCapacity[i] = 0;\n    }\n\n    int groupDegree[n + m];\n    memset(groupDegree, 0, sizeof(groupDegree));\n    int itemDegree[n];\n    memset(itemDegree, 0, sizeof(itemDegree));\n\n    int id[n + m];\n    for (int i = 0; i < n + m; ++i) {\n        id[i] = i;\n    }\n\n    int leftId = m;\n    for (int i = 0; i < n; ++i) {\n        if (group[i] == -1) {\n            group[i] = leftId++;\n        }\n        if (groupItemColSize[group[i]] == groupItemColCapacity[group[i]]) {\n            int* x = &groupItemColCapacity[group[i]];\n            *x = (*x) ? (*x) * 2 : 1;\n            groupItem[group[i]] = realloc(groupItem[group[i]], sizeof(int) * (*x));\n        }\n        groupItem[group[i]][groupItemColSize[group[i]]++] = i;\n    }\n    for (int i = 0; i < n; ++i) {\n        int curGroupId = group[i];\n        for (int j = 0; j < beforeItemsColSize[i]; j++) {\n            int item = beforeItems[i][j];\n            int beforeGroupId = group[item];\n            if (beforeGroupId == curGroupId) {\n                itemDegree[i]++;\n                if (itemGraphColSize[item] == itemGraphColCapacity[item]) {\n                    int* x = &itemGraphColCapacity[item];\n                    (*x) = (*x) ? (*x) * 2 : 1;\n                    itemGraph[item] = realloc(itemGraph[item], sizeof(int) * (*x));\n                }\n                itemGraph[item][itemGraphColSize[item]++] = i;\n            } else {\n                groupDegree[curGroupId]++;\n                if (groupGraphColSize[beforeGroupId] == groupGraphColCapacity[beforeGroupId]) {\n                    int* x = &groupGraphColCapacity[beforeGroupId];\n                    (*x) = (*x) ? (*x) * 2 : 1;\n                    groupGraph[beforeGroupId] = realloc(groupGraph[beforeGroupId], sizeof(int) * (*x));\n                }\n                groupGraph[beforeGroupId][groupGraphColSize[beforeGroupId]++] = curGroupId;\n            }\n        }\n    }\n    int groupTopSortSize;\n    int* groupTopSort = topSort(&groupTopSortSize, groupDegree, groupGraph, groupGraphColSize, id, n + m);\n    if (groupTopSortSize == 0) {\n        *returnSize = 0;\n        return NULL;\n    }\n    int* ans = malloc(sizeof(int) * groupTopSortSize);\n    *returnSize = 0;\n    for (int i = 0; i < groupTopSortSize; i++) {\n        int curGroupId = groupTopSort[i];\n        int size = groupItemColSize[curGroupId];\n        if (size == 0) {\n            continue;\n        }\n        int resSize;\n        int* res = topSort(&resSize, itemDegree, itemGraph, itemGraphColSize, groupItem[curGroupId], groupItemColSize[curGroupId]);\n        if (resSize == 0) {\n            *returnSize = 0;\n            return NULL;\n        }\n        for (int j = 0; j < resSize; j++) {\n            ans[(*returnSize)++] = res[j];\n        }\n    }\n    return ans;\n}\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/39#issuecomment-2574378742","body":"```\nint firstBadVersion(int n)\n {\n    int left = 1, right = n;\n    while (left < right) { \n        int mid = left + (right - left) / 2; \n        if (isBadVersion(mid)) {\n            right = mid; \n        } else {\n            left = mid + 1;  \n        }\n    }\n    return left;\n}\n```\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/45#issuecomment-2587316599","body":"```\ndouble new21Game(int N, int K, int W) {\n    if (!K) \n       return 1.0;\n    double* dp = (double*)malloc(sizeof(double) * (K + W));\n    for (int i = K; i < K + W; i++) {\n        if (i < N + 1)\n            dp[i] = 1.0;\n        else\n            dp[i] = 0.0;\n    }\n    double sum = K + W < N + 1 ? 1.0 : (double)(N + 1 - K) / W;\n    for (int i = K - 1; i >= 0; i--) {\n        if (i < K - 1) sum += (dp[i + 1] - dp[i + W + 1]) / W;\n        dp[i] = sum;\n    }\n    return dp[0];\n}\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/52#issuecomment-2601806828","body":"```\nint maxDistance(int** grid, int gridSize, int* gridColSize){\n    int k = 2;\n\tint flag = 0;\n\tdo {\n\t\tflag = 0;\n\t\tfor (int i = 0; i < gridSize; i++) {\n\t\t\tfor (int j = 0; j < *gridColSize; j++) {\n\t\t\t\tif (grid[i][j] == (k - 1)) {\n\t\t\t\t\t// 上\n\t\t\t\t\tif (i > 0 && grid[i - 1][j] == 0) {\n\t\t\t\t\t\tgrid[i - 1][j] = k;\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t}\n\t\t\t\t\t// 下\n\t\t\t\t\tif (i < gridSize - 1 && grid[i + 1][j] == 0) {\n\t\t\t\t\t\tgrid[i + 1][j] = k;\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t}\n\t\t\t\t\t// 左\n\t\t\t\t\tif (j > 0 && grid[i][j - 1] == 0) {\n\t\t\t\t\t\tgrid[i][j - 1] = k;\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t}\n\t\t\t\t\t// 右\n\t\t\t\t\tif (j < *gridColSize - 1 && grid[i][j + 1] == 0) {\n\t\t\t\t\t\tgrid[i][j + 1] = k;\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag) {\n\t\t\tk++;\n\t\t}\n\t} while (flag);\n\treturn\tk == 2 ? -1 : k - 2;\n}\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/59#issuecomment-2614832345","body":"```\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> f(m, vector<int>(n));\n        for (int i = 0; i < m; ++i) {\n            f[i][0] = 1;\n        }\n        for (int j = 0; j < n; ++j) {\n            f[0][j] = 1;\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                f[i][j] = f[i - 1][j] + f[i][j - 1];\n            }\n        }\n        return f[m - 1][n - 1];\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tuuna":[null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/4#issuecomment-2513471909","body":"#include <vector>\n\nclass CustomStack {\nprivate:\n    std::vector<int> stack;\n    int maxSize;\n\npublic:\n    CustomStack(int maxSize) {\n        this->maxSize = maxSize;\n    }\n    \n    void push(int x) {\n        if (stack.size() < maxSize) {\n            stack.push_back(x);\n        }\n    }\n    \n    int pop() {\n        if (!stack.empty()) {\n            int top = stack.back();\n            stack.pop_back();\n            return top;\n        } else {\n            return -1;\n        }\n    }\n    \n    void increment(int k, int val) {\n        for (int i = 0; i < k && i < stack.size(); i++) {\n            stack[i] += val;\n        }\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/5#issuecomment-2517226488","body":"#include <stack>\n#include <string>\n\nclass Solution {\npublic:\n    string decodeString(string s) {\n        std::stack<int> counts;\n        std::stack<std::string> strings;\n        std::string currentString;\n        int count = 0;\n        \n        for (char ch : s) {\n            if (isdigit(ch)) {\n                count = count * 10 + ch - '0';\n            } else if (ch == '[') {\n                counts.push(count);\n                strings.push(currentString);\n                count = 0;\n                currentString.clear();\n            } else if (ch == ']') {\n                std::string decodedString = strings.top();\n                strings.pop();\n                int repeatCount = counts.top();\n                counts.pop();\n                for (int i = 0; i < repeatCount; i++) {\n                    decodedString += currentString;\n                }\n                currentString = decodedString;\n            } else {\n                currentString += ch;\n            }\n        }\n        \n        return currentString;\n    }\n};","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/9#issuecomment-2525940157","body":"struct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode dummy(0);\n        dummy.next = head;\n        ListNode* prev = &dummy;\n        while (head && head->next) {\n            ListNode* first = head;\n            ListNode* second = head->next;\n\n            // 交换两个节点\n            first->next = second->next;\n            second->next = first;\n            prev->next = second;\n\n            // 移动到下一对节点\n            prev = first;\n            head = first->next;\n        }\n        return dummy.next;\n    }\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/11#issuecomment-2530764213","body":"struct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode dummy(0);\n        dummy.next = head;\n        ListNode* prev = &dummy;\n        while (head && head->next) {\n            ListNode* first = head;\n            ListNode* second = head->next;\n\n            // 交换两个节点\n            first->next = second->next;\n            second->next = first;\n            prev->next = second;\n\n            // 移动到下一对节点\n            prev = first;\n            head = first->next;\n        }\n        return dummy.next;\n    }\n};","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/17#issuecomment-2544696368","body":"#include <queue>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nint findBottomLeftValue(TreeNode* root) {\n    std::queue<TreeNode*> q;\n    q.push(root);\n    int result = root->val;\n    while (!q.empty()) {\n        int size = q.size();\n        for (int i = 0; i < size; ++i) {\n            TreeNode* node = q.front();\n            q.pop();\n            // 对于每一层的第一个元素，更新结果\n            if (i == 0) {\n                result = node->val;\n            }\n            if (node->left) {\n                q.push(node->left);\n            }\n            if (node->right) {\n                q.push(node->right);\n            }\n        }\n    }\n    return result;\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/20#issuecomment-2552675895","body":"#include <algorithm>\n#include <iostream>\n#include <vector>\n\nstd::vector<int> solution(std::vector<int> &nums, int target) {\n  // 对数组进行排序\n  std::sort(nums.begin(), nums.end());\n\n  // 初始化两个指针\n  int left = 0;\n  int right = nums.size() - 1;\n\n  // 使用双指针遍历数组\n  while (left < right) {\n    int sum = nums[left] + nums[right];\n\n    if (sum == target) {\n      // 找到目标值，返回两个指针的下标\n      return {left, right};\n    } else if (sum < target) {\n      // 和小于目标值，移动左指针\n      ++left;\n    } else {\n      // 和大于目标值，移动右指针\n      --right;\n    }\n  }\n\n  // 如果没有找到，返回空数组（题目保证有解，所以这里不会执行）\n  return {};\n}\n\nint main() {\n  std::vector<int> nums = {2, 7, 11, 15};\n  int target = 9;\n  std::vector<int> result = solution(nums, target);\n  std::cout << \"[\" << result[0] << \", \" << result[1] << \"]\" << std::endl;\n  return 0;\n}","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/26#issuecomment-2561640908","body":"#include <iostream>\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n\nListNode* middleNode(ListNode* head) {\n    ListNode* slow = head;\n    ListNode* fast = head;\n\n    while (fast && fast->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n\n    return slow;\n}\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/31#issuecomment-2565066452","body":"#include<vector>\n#include<unordered_map>\nusing namespace std;\n\nclass Solution {\n    public bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\n        unordered_map<int, vector<int>> graph;\n        for (auto& edge : dislikes) {\n            graph[edge[0]].push_back(edge[1]);\n            graph[edge[1]].push_back(edge[0]);\n        }\n        vector<int> group(N+1, 0);\n        for (int i = 1; i <= N; ++i) {\n            if (group[i] == 0 && !dfs(i, 1, group, graph)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public bool dfs(int node, int grp, vector<int>& group, unordered_map<int, vector<int>>& graph) {\n        if (group[node] == 0) {\n            group[node] = grp;\n        } else {\n            return group[node] == grp;\n        }\n        if (graph.count(node)) {\n            for (int neighbor : graph[node]) {\n                if (!dfs(neighbor, -grp, group, graph)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n};","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/38#issuecomment-2572242811","body":"#include <iostream>\n\nint sqrt(int x) {\n    if (x == 0) {\n        return 0;\n    }\n    int left = 1, right = x;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (mid == x / mid) {\n            return mid;\n        } else if (mid < x / mid) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return right;\n}","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/45#issuecomment-2586067066","body":"#include <vector>\nusing namespace std;\n\ndouble new21Game(int N, int K, int W) {\n    if (K == 0 || N >= K + W) {\n        return 1.0;\n    }\n\n    vector<double> dp(N + 1);\n    dp[0] = 1.0;\n    double Wsum = 1.0, res = 0.0;\n\n    for (int i = 1; i <= N; ++i) {\n        dp[i] = Wsum / W;\n        if (i < K) {\n            Wsum += dp[i];\n        } else {\n            res += dp[i];\n        }\n        if (i - W >= 0) {\n            Wsum -= dp[i - W];\n        }\n    }\n\n    return res;\n}","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/52#issuecomment-2601176756","body":"#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxDistance(vector<vector<int>>& grid) {\n        int N = grid.size();\n        queue<pair<int, int>> q;\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                if (grid[i][j] == 1) {\n                    q.push({i, j});\n                }\n            }\n        }\n        if (q.size() == 0 || q.size() == N * N) {\n            return -1;\n        }\n        int distance = -1;\n        while (!q.empty()) {\n            int size = q.size();\n            while (size--) {\n                int x = q.front().first;\n                int y = q.front().second;\n                q.pop();\n                for (auto& d : directions) {\n                    int nx = x + d[0];\n                    int ny = y + d[1];\n                    if (nx >= 0 && nx < N && ny >= 0 && ny < N && grid[nx][ny] == 0) {\n                        grid[nx][ny] = 1;\n                        q.push({nx, ny});\n                    }\n                }\n            }\n            ++distance;\n        }\n        return distance;\n    }\n\nprivate:\n    vector<vector<int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n};","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/58#issuecomment-2614481662","body":"O(m*n)\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int m = text1.size();\n        int n = text2.size();\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n        for (int i = 1; i <= m; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                if (text1[i - 1] == text2[j - 1]) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                }\n                else {\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lxy12l":[null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/4#issuecomment-2514442473","body":"class CustomStack(object):\n\n    def __init__(self, maxSize):\n        \n        self.stack=[]\n        self.maxSize=maxSize\n        \n\n    def push(self, x):\n       \n        if len(self.stack)<self.maxSize:\n            self.stack.append(x)\n        \n\n    def pop(self):\n        \n        if len(self.stack)>0:\n           return self.stack.pop()\n        else:\n            return -1\n        \n\n    def increment(self, k, val):\n      \n        for i in range(min(k,len(self.stack))):\n            self.stack[i] += val","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chxbilly":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/5#issuecomment-2516607851","body":"class Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        number_stack = []\n        string_stack = []\n        current_string = \"\"\n        current_number = 0\n\n        for char in s:\n            if char.isdigit():\n                current_number = current_number * 10 + int(char) #need to include *10 for s= \"123[leetcode]\", for anything bigger than 9\n            elif char == '[':\n                number_stack.append(current_number)\n                string_stack.append(current_string)\n                current_number = 0\n                current_string = \"\"\n            elif char == ']':\n                #when reach the right ), look at whats in side the () and the repeat number related to it\n                repeat_number = number_stack.pop() #the list delete the last one\n                previous_string = string_stack.pop() \n                current_string = previous_string + current_string * repeat_number\n            else:\n                current_string += char\n\n        return current_string\n        ","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/11#issuecomment-2530716669","body":"*### 思路*\n\n要用两个variable分别指向两个链表的头节点head A，B，要用上这两个（初始华）\n\n需要看完整的两个list until intersect or none\n\ni\n\n*### 代码(Python)*\n\n```\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        a, b = headA, headB\n        while a != b:\n            a = a.next if a else headB #if p1 means if p1 is not none\n            b = b.next if b else headA\n        return a\n```\n\n复杂度分析\n\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sentiy-hub":[{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/2#issuecomment-2520185325","body":"```\nvar addToArrayForm = function(num, k) {\n  let sum = BigInt(num.join('')) + BigInt(k);    // O(n)\n  return String(sum).split('').map(Number); // O(n)\n}\n```\n// 时间复杂度：O(n)，其中 n 是数组长度\n// 空间复杂度：O(n)，需要创建新数组存储结果","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/3#issuecomment-2520249765","body":"```\nvar shortestToChar = function(s, c) {\n  const n = s.length;\n  const prev = [];\n  let lastPos = -n;\n\n  // 从左到右遍历,记录上一次出现 c 的位置\n  for (let i = 0; i < n; i++) {\n      if (s[i] === c) {\n          lastPos = i;\n      }\n      prev[i] = i - lastPos;\n  }\n\n  lastPos = 2 * n;\n  // 从右到左遍历,记录下一次出现 c 的位置\n  for (let i = n - 1; i >= 0; i--) {\n      if (s[i] === c) {\n          lastPos = i;\n      }\n      prev[i] = Math.min(prev[i], lastPos - i);\n  }\n\n  return prev;\n};\n```\n时间复杂度 O(n)\n空间复杂度 O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/4#issuecomment-2520263281","body":"```\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n  this.list = []\n  this.maxSize = maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n  if (this.list.length < this.maxSize) {\n    this.list.push(x)\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n  const item = this.list.pop()\n  return item === void 0 ? -1 : item\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n  for (let i = 0; i < k && i < this.list.length; i++) {\n    this.list[i] += val\n  }\n};\n\n/** \n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/5#issuecomment-2520270798","body":"```\nvar decodeString = function(s) {\n    let result = '';\n    let num = 0;\n\n    for (let i = 0; i < s.length; i++) {\n        const char = s[i];\n\n        if (!isNaN(parseInt(char))) {\n            num = num * 10 + parseInt(char);\n        } else if (char === '[') {\n            let j = i;\n            let count = 1;\n            while (count !== 0) {\n                j++;\n                if (s[j] === '[') count++;\n                if (s[j] === ']') count--;\n            }\n            const innerString = decodeString(s.slice(i + 1, j));\n            result += innerString.repeat(num);\n            i = j;\n            num = 0;\n        } else if (char !== ']') {\n            result += char;\n        }\n    }\n\n    return result;\n};\n```\n时间复杂度 O(n)\n空间复杂度 O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/6#issuecomment-2520177599","body":"```\r\nvar addToArrayForm = function(num, k) {\r\n  let sum = BigInt(num.join('')) + BigInt(k);    // O(n)\r\n  return String(sum).split('').map(Number); // O(n)\r\n}\r\n```\r\n// 时间复杂度：O(n)，其中 n 是数组长度\r\n// 空间复杂度：O(n)，需要创建新数组存储结果","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/7#issuecomment-2523113072","body":"思路：\n首先计算每个位置左边的最大值 prevMax 和每个位置右边的最小值 nextMin。\n然后遍历数组,检查每个位置 i 是否满足 prevMax[i] <= nextMin[i+1]。如果满足,说明可以在位置 i 处切分成一个块。\n最后还需要加上最后一个块,所以返回 count + 1。\n\n```\nvar maxChunksToSorted = function(arr) {\n    const n = arr.length;\n    let count = 0;\n    const prevMax = new Array(n).fill(0);\n    const nextMin = new Array(n).fill(0);\n\n    // 计算每个位置左边的最大值\n    prevMax[0] = arr[0];\n    for (let i = 1; i < n; i++) {\n        prevMax[i] = Math.max(prevMax[i - 1], arr[i]);\n    }\n\n    // 计算每个位置右边的最小值\n    nextMin[n - 1] = arr[n - 1];\n    for (let i = n - 2; i >= 0; i--) {\n        nextMin[i] = Math.min(nextMin[i + 1], arr[i]);\n    }\n\n    // 遍历数组,检查是否可以形成一个块\n    for (let i = 0; i < n - 1; i++) {\n        if (prevMax[i] <= nextMin[i + 1]) {\n            count++;\n        }\n    }\n\n    // 最后加上最后一个块\n    return count + 1;\n};\n```\n时间复杂度 O(n)\n空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/8#issuecomment-2525096142","body":"```\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (!head || !head.next) return head; // 空链表或只有一个节点,直接返回\n    \n    // 1. 计算链表长度\n    let n = 0, curr = head;\n    while (curr) {\n        n++;\n        curr = curr.next;\n    }\n    \n    // 2. 计算实际需要旋转的次数\n    k = k % n;\n    if (k === 0) return head; // 不需要旋转\n    \n    // 3. 找到倒数第 k' 个节点\n    curr = head;\n    for (let i = 0; i < n - k - 1; i++) {\n        curr = curr.next;\n    }\n    let newHead = curr.next;\n    \n    // 4. 形成环\n    curr.next = null;\n    curr = newHead;\n    while (curr.next) {\n        curr = curr.next;\n    }\n    curr.next = head;\n    \n    // 5. 返回新的头节点\n    return newHead;\n};\n```\n时间复杂度 O(n)\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/9#issuecomment-2525554848","body":"```\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    // 如果链表为空或只有一个节点,直接返回\n    if (!head || !head.next) {\n        return head;\n    }\n    \n    // 创建一个虚拟头节点,方便处理边界条件\n    let dummy = new ListNode(0);\n    dummy.next = head;\n    \n    // 三个指针:prev用于记录上一个节点,curr用于当前节点,nextNode用于记录下一个节点\n    let prev = dummy;\n    let curr = head;\n    \n    // 遍历链表,每次处理两个节点\n    while (curr && curr.next) {\n        // 保存下一个节点的地址\n        let nextNode = curr.next.next;\n        \n        // 交换当前两个节点\n        prev.next = curr.next;\n        curr.next.next = curr;\n        curr.next = nextNode;\n        \n        // 移动三个指针到下一个要处理的节点对\n        prev = curr;\n        curr = nextNode;\n    }\n    \n    // 返回交换后的链表头部\n    return dummy.next;\n};\n```\n时间复杂度 O(n)\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/10#issuecomment-2527684530","body":"```\n/**\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n\n/**\n * @param {ListNode} head - 输入的有序链表头节点\n * @return {TreeNode} - 返回构造的平衡二叉搜索树的根节点\n */\nvar sortedListToBST = function(head) {\n    // 处理基础情况\n    // 如果链表为空，返回空节点\n    if (!head) return null;\n    // 如果只有一个节点，直接返回树节点\n    if (!head.next) return new TreeNode(head.val);\n    \n    // 使用快慢指针找到链表的中间节点\n    let slow = head;        // 慢指针，每次移动一步\n    let fast = head;        // 快指针，每次移动两步\n    let prev = null;        // 记录慢指针的前一个节点\n    \n    // 当快指针能够继续移动时，移动快慢指针\n    while (fast && fast.next) {\n        fast = fast.next.next;\n        prev = slow;\n        slow = slow.next;\n    }\n    \n    // 在中间节点处断开链表，分成左右两部分\n    prev.next = null;\n    \n    // 用中间节点的值创建根节点\n    const root = new TreeNode(slow.val);\n    \n    // 递归构建左右子树\n    // 左子树由链表的前半部分构建\n    root.left = sortedListToBST(head);\n    // 右子树由链表的后半部分构建\n    root.right = sortedListToBST(slow.next);\n    \n    return root;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/11#issuecomment-2529898613","body":"```\nvar getIntersectionNode = function(headA, headB) {\n    // 如果任一链表为空，则不可能相交\n    if (!headA || !headB) return null;\n    \n    // 初始化两个指针\n    let ptrA = headA;\n    let ptrB = headB;\n    \n    // 当两个指针不相等时继续遍历\n    while (ptrA !== ptrB) {\n        // 移动指针 A\n        ptrA = ptrA ? ptrA.next : headB;\n        // 移动指针 B\n        ptrB = ptrB ? ptrB.next : headA;\n    }\n    \n    // 返回相交点（如果没有相交，ptrA 会是 null）\n    return ptrA;\n};\n```\n时间复杂度 O(n+m) \n空间复杂度 O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/12#issuecomment-2535999072","body":"思路 快慢指针 \n\n```\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    if (!head || !head.next) return null;\n    \n    // 1. 使用快慢指针找相遇点\n    let slow = head;\n    let fast = head;\n    let hasCycle = false;\n    \n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow === fast) {\n            hasCycle = true;\n            break;\n        }\n    }\n    \n    // 如果没有环，返回 null\n    if (!hasCycle) return null;\n    \n    // 2. 一个指针回到起点，两指针同速前进找入口\n    slow = head;\n    while (slow !== fast) {\n        slow = slow.next;\n        fast = fast.next;\n    }\n    \n    return slow;\n};\n```\n\n：\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/13#issuecomment-2537504795","body":"```\r\nclass LRUCache {\r\n  constructor(capacity) {\r\n    this.cache = new Map();\r\n    this.capacity = capacity;\r\n  }\r\n\r\n  get(key) {\r\n    if (!this.cache.has(key)) return -1;\r\n    \r\n    // 获取值并刷新位置\r\n    const value = this.cache.get(key);\r\n    this.cache.delete(key);\r\n    this.cache.set(key, value);\r\n    return value;\r\n  }\r\n\r\n  put(key, value) {\r\n    // 如果键存在,先删除\r\n    if (this.cache.has(key)) {\r\n      this.cache.delete(key);\r\n    }\r\n    // 如果缓存满了,删除最久未使用的\r\n    else if (this.cache.size >= this.capacity) {\r\n      this.cache.delete(this.cache.keys().next().value);\r\n    }\r\n    // 添加新键值对\r\n    this.cache.set(key, value);\r\n  }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/14#issuecomment-2540828302","body":"```\nvar maxDepth = function (root) {\n    // 如果树为空，返回0\n    if (!root) return 0;\n\n    // 使用队列来进行层序遍历\n    const queue = [root];\n    let depth = 0;\n\n    // 当队列不为空时继续遍历\n    while (queue.length > 0) {\n        depth++; // 每遍历一层，深度加1\n\n        // 获取当前层的节点数量\n        const levelSize = queue.length;\n\n        // 遍历当前层的所有节点\n        for (let i = 0; i < levelSize; i++) {\n            // 取出队列头部的节点\n            const node = queue.shift();\n\n            // 如果有左子节点，加入队列\n            if (node.left) {\n                queue.push(node.left);\n            }\n\n            // 如果有右子节点，加入队列\n            if (node.right) {\n                queue.push(node.right);\n            }\n        }\n    }\n\n    return depth;\n\n};\n```\n\n时间、空间复杂度都为 0(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/15#issuecomment-2543128062","body":"```\nvar isSameTree = function(p, q) {\n    const queue = [[p, q]];\n    \n    while (queue.length) {\n        const [node1, node2] = queue.shift();\n        \n        // 相同的检查逻辑\n        if (!node1 && !node2) continue;\n        if (!node1 || !node2) return false;\n        if (node1.val !== node2.val) return false;\n        \n        // 将左右子节点放入队列\n        queue.push([node1.left, node2.left]);\n        queue.push([node1.right, node2.right]);\n    }\n    \n    return true;\n};\n```\n\n时间、空间复杂度均为0(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/16#issuecomment-2543736285","body":"```\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root) {\n    // 边界情况：空树\n    if (!root) return 0;\n    \n    // DFS遍历的辅助函数\n    function dfs(node, currentSum) {\n        // 基础情况：空节点\n        if (!node) return 0;\n        \n        // 计算当前数字：将当前数字乘10并加上当前节点值\n        const newSum = currentSum * 10 + node.val;\n        \n        // 如果是叶子节点，返回当前路径和\n        if (!node.left && !node.right) {\n            return newSum;\n        }\n        \n        // 递归计算左右子树的和并相加\n        return dfs(node.left, newSum) + dfs(node.right, newSum);\n    }\n    \n    // 从根节点开始DFS，初始和为0\n    return dfs(root, 0);\n};\n```\n时间复杂度：O(N)\n空间复杂度：O(H)，H是树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/17#issuecomment-2544542144","body":"```\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar findBottomLeftValue = function(root) {\n    if (!root) return 0;\n    \n    const queue = [root];\n    let leftmost = 0;\n    \n    while (queue.length > 0) {\n        const size = queue.length;\n        \n        for (let i = 0; i < size; i++) {\n            const node = queue.shift();\n            \n            // 记录每一层的第一个节点值\n            if (i === 0) {\n                leftmost = node.val;\n            }\n            \n            // 先加入左子节点，再加入右子节点\n            if (node.left) {\n                queue.push(node.left);\n            }\n            if (node.right) {\n                queue.push(node.right);\n            }\n        }\n    }\n    \n    return leftmost;\n};\n```\n\n时间复杂度：O(n)，其中 n 是二叉树的节点数\n空间复杂度：O(w)，其中 w 是二叉树的最大宽度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/18#issuecomment-2548257653","body":"```\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n    if (!root) return \"[]\";\n    \n    const queue = [root];\n    const result = [];\n    \n    while (queue.length) {\n        const node = queue.shift();\n        \n        if (node) {\n            result.push(node.val);\n            queue.push(node.left);\n            queue.push(node.right);\n        } else {\n            result.push(null);\n        }\n    }\n    \n    // 去掉尾部的 null\n    while (result[result.length - 1] === null) {\n        result.pop();\n    }\n    \n    return `[${result.join(',')}]`;\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n    if (data === \"[]\") return null;\n    \n    // 解析字符串成数组\n    const values = data.slice(1, -1).split(',').map(val => \n        val === \"\" || val === \"null\" ? null : parseInt(val)\n    );\n    \n    const root = new TreeNode(values[0]);\n    const queue = [root];\n    let i = 1;\n    \n    while (queue.length && i < values.length) {\n        const node = queue.shift();\n        \n        // 处理左子节点\n        if (i < values.length && values[i] !== null) {\n            node.left = new TreeNode(values[i]);\n            queue.push(node.left);\n        }\n        i++;\n        \n        // 处理右子节点\n        if (i < values.length && values[i] !== null) {\n            node.right = new TreeNode(values[i]);\n            queue.push(node.right);\n        }\n        i++;\n    }\n    \n    return root;\n};\n```\n\n (serialize):时间复杂度: O(n),空间复杂度: O(n)\n (deserialize):时间复杂度: O(n),空间复杂度: O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/20#issuecomment-2554646910","body":"```\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    const map = new Map();\n\n    for (let i = 0; i < nums.length; i++) {\n        const gap = target - nums[i]\n        if (map.has(gap)) {\n            return [map.get(gap), i]\n        }\n        map.set(nums[i], i)\n    }\n    \n    return []\n    \n};\n```\n时间、空间复杂度：0(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/21#issuecomment-2556034300","body":"```\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar topKFrequent = function(nums, k) {\n    // 统计每个数字出现的频率\n    const map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        const num = nums[i];\n        map.set(num, map.get(num) ? map.get(num) + 1 : 1)\n    }\n\n    // 索引为数字出现的次数 值为该次数的数字数组\n    const arr = []\n    for (let i = 0; i <= nums.length; i++) {\n        arr.push([])\n    }\n    for (const [num, times] of map) {\n        arr[times].push(num)\n    }\n\n    // 出现次数从高到低的数字的数组\n    const res = []\n    for (let i = arr.length - 1; i > 0; i--) {\n        res.push(...arr[i])\n    }\n    // 返回前K项\n    return res.slice(0, k)\n};\n```\n\n时间复杂度 0(N*logn)\n空间复杂度 0(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/22#issuecomment-2558027209","body":"```\n/**\n * @param {number[][]} points\n * @return {number}\n */\nconst numberOfBoomerangs = function(points) {\n    let result = 0;\n    \n    // 遍历每个点作为回旋镖的第一个点\n    for (let i = 0; i < points.length; i++) {\n        // 用 Map 存储到其他点的距离及其出现次数\n        const distMap = new Map();\n        \n        // 计算与其他点的距离\n        for (let j = 0; j < points.length; j++) {\n            if (i === j) continue;\n            \n            // 计算距离（不需要开平方根，因为我们只需要比较距离）\n            const dist = getDist(points[i], points[j]);\n            \n            distMap.set(dist, (distMap.get(dist) || 0) + 1);\n        }\n        \n        // 对于每个距离，如果有 n 个点在这个距离上\n        // 那么可以形成 n * (n-1) 个回旋镖\n        for (const count of distMap.values()) {\n            result += count * (count - 1);\n        }\n    }\n    \n    return result;\n};\n```\n时间复杂度：O(n²)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/23#issuecomment-2558441350","body":"思路：双指针，滑动窗口\n\n```\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    let left = 0\n    let maxLength = 0\n    const map = new Map()\n    for(let right= 0; right < s.length; right++) {\n        const curStr = s[right]\n        if(map.has(curStr)) {\n            left = Math.max(map.get(curStr)+ 1, left)\n        }\n        map.set(curStr, right)\n        maxLength = Math.max(right - left + 1, maxLength)\n    }\n    return maxLength\n};\n```\n\n时间复杂度： O(n)\n空间复杂度： O(min(m, n))，n 是输入字符串的长度,m 是字符集的大小","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/24#issuecomment-2558717266","body":"\n```\n/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nfunction findSubstring(s, words) {\n    if (!s || !words || words.length === 0) return [];\n    \n    const result = [];\n    const wordLen = words[0].length;\n    const totalLen = wordLen * words.length;\n    const wordCount = new Map();\n    \n    // 统计每个单词出现的次数\n    for (const word of words) {\n        wordCount.set(word, (wordCount.get(word) || 0) + 1);\n    }\n    \n    // 对每个可能的起始位置进行检查\n    for (let i = 0; i <= s.length - totalLen; i++) {\n        const seen = new Map();\n        let j = 0;\n        \n        // 检查从位置i开始的子串\n        while (j < words.length) {\n            const start = i + j * wordLen;\n            const currentWord = s.slice(start, start + wordLen);\n            \n            // 如果当前单词不在words中，直接退出\n            if (!wordCount.has(currentWord)) break;\n            \n            // 更新当前看到的单词计数\n            seen.set(currentWord, (seen.get(currentWord) || 0) + 1);\n            \n            // 如果当前单词出现次数超过了允许的次数，退出\n            if (seen.get(currentWord) > wordCount.get(currentWord)) break;\n            \n            j++;\n        }\n        \n        // 如果成功匹配了所有单词\n        if (j === words.length) {\n            result.push(i);\n        }\n    }\n    \n    return result;\n}\n```\n时间复杂度  O(n*k*m)\n空间复杂度 O(k*m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/25#issuecomment-2560488146","body":"```\n/**\n * @param {number[]} nums\n * @param {number} p\n * @return {number}\n */\nvar minSubarray = function(nums, p) {\n    const n = nums.length;\n    // 计算整个数组的余数\n    let need = 0;\n    for (let num of nums) {\n        need = (need + num) % p;\n    }\n    \n    if (need === 0) return 0;\n    \n    // 使用前缀和的余数来找最短子数组\n    const map = new Map();\n    map.set(0, -1);\n    let curr = 0;\n    let minLen = n;\n    \n    for (let i = 0; i < n; i++) {\n        curr = (curr + nums[i]) % p;\n        // 要找的目标余数\n        let target = (curr - need + p) % p;\n        \n        if (map.has(target)) {\n            minLen = Math.min(minLen, i - map.get(target));\n        }\n        map.set(curr, i);\n    }\n    \n    return minLen === n ? -1 : minLen;\n};\n```\n\n时间、空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/27#issuecomment-2562610478","body":"```\r\nfunction removeDuplicates(nums) {\r\n   if(nums.length === 0) return 0;\r\n   let k = 1;\r\n   for(let i = 1; i < nums.length; i++) {\r\n       if(nums[i] !== nums[i-1]) {\r\n           nums[k] = nums[i];\r\n           k++;\r\n       }\r\n   }\r\n   return k;\r\n}\r\n```\r\n\r\n时间复杂度: O(n)\r\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/28#issuecomment-2563347134","body":"```javascript\nvar searchInsert = function(nums, target) {\n    let left = 0, right = nums.length - 1;\n    \n    while(left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        if(nums[mid] === target) return mid;\n        if(nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    \n    return left;\n};\n```\n\n时间复杂度: O(log n)\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/29#issuecomment-2564165277","body":"```\nvar maxSlidingWindow = function(nums, k) {\n    const deque = [];\n    const result = [];\n    \n    for(let i = 0; i < nums.length; i++) {\n        // 移除队首过期元素\n        if(deque.length && deque[0] <= i - k) {\n            deque.shift();\n        }\n        \n        // 移除队尾小于当前元素的值\n        while(deque.length && nums[deque[deque.length - 1]] < nums[i]) {\n            deque.pop();\n        }\n        \n        deque.push(i);\n        \n        // 当窗口至少为k时,记录最大值\n        if(i >= k - 1) {\n            result.push(nums[deque[0]]);\n        }\n    }\n    \n    return result;\n};\n```\n\n时间、空间复杂度: O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/31#issuecomment-2564933042","body":"```\n/**\n * @param {number} n\n * @param {number[][]} dislikes\n * @return {boolean}\n */\nvar possibleBipartition = function(n, dislikes) {\n    const graph = Array.from({length: n + 1}, () => []);\n    for (const [a, b] of dislikes) {\n        graph[a].push(b);\n        graph[b].push(a);\n    }\n    \n    const colors = new Array(n + 1).fill(-1);\n    \n    const dfs = (node, color) => {\n        colors[node] = color;\n        \n        for (const neighbor of graph[node]) {\n            if (colors[neighbor] === -1) {\n                if (!dfs(neighbor, 1 - color)) return false;\n            } else if (colors[neighbor] === color) {\n                return false;\n            }\n        }\n        return true;\n    };\n    \n    for (let i = 1; i <= n; i++) {\n        if (colors[i] === -1) {\n            if (!dfs(i, 0)) return false;\n        }\n    }\n    \n    return true;\n};\n```\n\n时间复杂度: O(N) \n空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/32#issuecomment-2566180408","body":"```\n/**\n * @param {number} n\n * @param {number} m\n * @param {number[]} group\n * @param {number[][]} beforeItems\n * @return {number[]}\n */\nvar sortItems = function(n, m, group, beforeItems) {\n    // 给无组的项目分配新组\n    let groupId = m;\n    for (let i = 0; i < n; i++) {\n        if (group[i] === -1) {\n            group[i] = groupId++;\n        }\n    }\n    \n    // 建立组内和组间图\n    const groupGraph = new Array(groupId).fill(0).map(() => []);\n    const itemGraph = new Array(n).fill(0).map(() => []);\n    const groupDegree = new Array(groupId).fill(0);\n    const itemDegree = new Array(n).fill(0);\n    \n    // 构建依赖关系\n    for (let i = 0; i < n; i++) {\n        const curGroup = group[i];\n        for (const before of beforeItems[i]) {\n            const beforeGroup = group[before];\n            if (beforeGroup !== curGroup) {\n                groupGraph[beforeGroup].push(curGroup);\n                groupDegree[curGroup]++;\n            }\n            itemGraph[before].push(i);\n            itemDegree[i]++;\n        }\n    }\n    \n    // 拓扑排序函数\n    const topologicalSort = (graph, degree) => {\n        const n = graph.length;\n        const queue = [];\n        const res = [];\n        \n        for (let i = 0; i < n; i++) {\n            if (degree[i] === 0) {\n                queue.push(i);\n            }\n        }\n        \n        while (queue.length) {\n            const cur = queue.shift();\n            res.push(cur);\n            for (const next of graph[cur]) {\n                degree[next]--;\n                if (degree[next] === 0) {\n                    queue.push(next);\n                }\n            }\n        }\n        \n        return res.length === n ? res : [];\n    };\n    \n    // 对组进行拓扑排序\n    const groupOrdered = topologicalSort(groupGraph, groupDegree);\n    if (!groupOrdered.length) return [];\n    \n    // 对每个组内的项目进行拓扑排序\n    const ans = [];\n    const groupItems = new Array(groupId).fill(0).map(() => []);\n    \n    for (let i = 0; i < n; i++) {\n        groupItems[group[i]].push(i);\n    }\n    \n    for (const curGroup of groupOrdered) {\n        const items = groupItems[curGroup];\n        const sorted = topologicalSort(\n            itemGraph.map(x => x.filter(y => group[y] === curGroup)),\n            itemDegree.map((x, i) => group[i] === curGroup ? x : 0)\n        );\n        if (sorted.length !== items.length) return [];\n        ans.push(...sorted.filter(item => group[item] === curGroup));\n    }\n    \n    return ans;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/33#issuecomment-2566864134","body":"```\n/**\n * 判断机器人是否回到原点\n * @param {string} moves - 移动指令字符串\n * @return {boolean} - 是否返回原点\n */\nvar judgeCircle = function(moves) {\n    // 初始化水平和垂直坐标\n    let x = 0, y = 0;\n    \n    // 遍历每个移动指令\n    for (let move of moves) {\n        switch (move) {\n            case 'U': // 向上移动\n                y++;\n                break;\n            case 'D': // 向下移动\n                y--;\n                break;\n            case 'R': // 向右移动\n                x++;\n                break;\n            case 'L': // 向左移动\n                x--;\n                break;\n        }\n    }\n    \n    // 检查是否回到原点\n    return x === 0 && y === 0;\n};\n \n```\n时间复杂度：O(n) \n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/34#issuecomment-2567206123","body":"```\n/**\n * @param {number[][]} tasks\n * @return {number[]}\n */\nvar getOrder = function(tasks) {\n    const n = tasks.length;\n    const indices = tasks.map((_, i) => i);\n    indices.sort((a, b) => tasks[a][0] - tasks[b][0]);\n    \n    const result = [];\n    const minHeap = new MinPriorityQueue({\n        priority: x => tasks[x][1] * 1e9 + x\n    });\n    \n    let i = 0;\n    let time = tasks[indices[0]][0];\n    \n    while (result.length < n) {\n        while (i < n && tasks[indices[i]][0] <= time) {\n            minHeap.enqueue(indices[i++]);\n        }\n        \n        if (minHeap.isEmpty()) {\n            time = tasks[indices[i]][0];\n            continue;\n        }\n        \n        const idx = minHeap.dequeue().element;\n        result.push(idx);\n        time += tasks[idx][1];\n    }\n    \n    return result;\n};\n```\n\n时间复杂度: O(nlogn) \n空间复杂度: O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/35#issuecomment-2568988239","body":"```\nvar numberOfRounds = function(startTime, finishTime) {\n    let start = getMinutes(startTime);\n    let end = getMinutes(finishTime);\n    \n    if (start > end) end += 24 * 60;\n    \n    start = Math.ceil(start / 15);\n    end = Math.floor(end / 15);\n    \n    return Math.max(0, end - start);\n};\n\nfunction getMinutes(time) {\n    const [h, m] = time.split(':').map(Number);\n    return h * 60 + m;\n}\n```\n\n\nTime: O(n)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/36#issuecomment-2571267624","body":"```\n/**\n * @param {string} a\n * @param {string} b\n * @return {number}\n * 时间复杂度: O(n)\n * 空间复杂度: O(1)\n */\nvar minCharacters = function(a, b) {\n    // 创建两个长度为26的数组存储字符频次\n    const countA = new Array(26).fill(0);\n    const countB = new Array(26).fill(0);\n    \n    // 统计两个字符串中每个字符出现的频次\n    for (let c of a) countA[c.charCodeAt(0) - 97]++;\n    for (let c of b) countB[c.charCodeAt(0) - 97]++;\n    \n    // 初始化结果为最大可能值\n    let res = a.length + b.length;\n    let sumA = 0, sumB = 0;\n    \n    // 遍历所有可能的分割点(a-y)，检查条件1和2\n    for (let i = 0; i < 25; i++) {\n        sumA += countA[i];\n        sumB += countB[i];\n        \n        // 条件1：使字符串a中所有字符严格小于字符串b中的所有字符\n        res = Math.min(res, sumA + (b.length - sumB));\n        \n        // 条件2：使字符串b中所有字符严格小于字符串a中的所有字符\n        res = Math.min(res, sumB + (a.length - sumA));\n    }\n    \n    // 条件3：使两个字符串中的所有字符相等\n    for (let i = 0; i < 26; i++) {\n        res = Math.min(res, a.length + b.length - countA[i] - countB[i]);\n    }\n    \n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/37#issuecomment-2571601573","body":"```\n// Time: O(nlogn)\n// Space: O(logn)\n\nvar sortArray = function(nums) {\n    if (nums.length <= 1) return nums;\n    \n    const quickSort = (left, right) => {\n        if (left >= right) return;\n        \n        // Random pivot to avoid worst case\n        const randIndex = Math.floor(Math.random() * (right - left + 1)) + left;\n        [nums[left], nums[randIndex]] = [nums[randIndex], nums[left]];\n        \n        const pivot = nums[left];\n        let i = left, j = right;\n        \n        while (i < j) {\n            while (i < j && nums[j] >= pivot) j--;\n            nums[i] = nums[j];\n            while (i < j && nums[i] <= pivot) i++;\n            nums[j] = nums[i];\n        }\n        nums[i] = pivot;\n        \n        quickSort(left, i - 1);\n        quickSort(i + 1, right);\n    };\n    \n    quickSort(0, nums.length - 1);\n    return nums;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/38#issuecomment-2572757272","body":"```\n// 时间复杂度: O(max(a.length, b.length))\n// 空间复杂度: O(max(a.length, b.length))\nvar addBinary = function(a, b) {\n    let result = \"\";\n    let carry = 0;\n    let i = a.length - 1;\n    let j = b.length - 1;\n    \n    while (i >= 0 || j >= 0 || carry > 0) {\n        const sum = (i >= 0 ? parseInt(a[i]) : 0) + \n                   (j >= 0 ? parseInt(b[j]) : 0) + \n                   carry;\n        result = (sum % 2) + result;\n        carry = Math.floor(sum / 2);\n        i--;\n        j--;\n    }\n    \n    return result;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/39#issuecomment-2575116200","body":"```\nvar solution = function(isBadVersion) {\n   return function(n) {\n       let left = 1;\n       let right = n;\n       \n       while(left < right) {\n           let mid = left + Math.floor((right - left) / 2);\n           if(isBadVersion(mid)) {\n               right = mid;\n           } else {\n               left = mid + 1;\n           }\n       }\n       return left;\n   };\n};\n```\n\n时间复杂度 O(logn)\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/40#issuecomment-2576726912","body":"```\n/**\n * @param {number[]} nums\n * @return {number}\n * 时间复杂度 O(nlogn)\n * 空间复杂度 O(n)\n */\nvar reversePairs = function(nums) {\n    return mergeSort(nums, 0, nums.length - 1);\n};\n\nfunction mergeSort(nums, left, right) {\n    if (left >= right) return 0;\n    \n    const mid = left + Math.floor((right - left) / 2);\n    let count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right);\n    \n    // Count pairs\n    let j = mid + 1;\n    for (let i = left; i <= mid; i++) {\n        while (j <= right && nums[i] > 2 * nums[j]) j++;\n        count += j - (mid + 1);\n    }\n    \n    // Merge\n    const temp = [];\n    let i = left, k = mid + 1;\n    \n    while (i <= mid && k <= right) {\n        if (nums[i] <= nums[k]) {\n            temp.push(nums[i++]);\n        } else {\n            temp.push(nums[k++]);\n        }\n    }\n    while (i <= mid) temp.push(nums[i++]);\n    while (k <= right) temp.push(nums[k++]);\n    \n    // Copy back\n    for (let p = 0; p < temp.length; p++) {\n        nums[left + p] = temp[p];\n    }\n    \n    return count;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/41#issuecomment-2579507797","body":"```\n// 时间复杂度: O(nlogn + mlogm)\n// 空间复杂度: O(1)\nconst findRadius = function(houses, heaters) {\n    houses.sort((a, b) => a - b);\n    heaters.sort((a, b) => a - b);\n    \n    let radius = 0;\n    let i = 0;\n    \n    for (const house of houses) {\n        while (i + 1 < heaters.length && \n               Math.abs(heaters[i] - house) >= Math.abs(heaters[i + 1] - house)) {\n            i++;\n        }\n        radius = Math.max(radius, Math.abs(heaters[i] - house));\n    }\n    \n    return radius;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/42#issuecomment-2582814720","body":"```\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n * Time: O(n*log(n) + n*log(w)) \n * Space: O(1)\n */\nvar smallestDistancePair = function(nums, k) {\n    nums.sort((a, b) => a - b);\n    let left = 0;\n    let right = nums[nums.length - 1] - nums[0];\n    \n    while (left < right) {\n        const mid = Math.floor((left + right) / 2);\n        let count = 0;\n        let j = 0;\n        \n        // Count pairs with distance <= mid\n        for (let i = 0; i < nums.length; i++) {\n            while (j < nums.length && nums[j] - nums[i] <= mid) {\n                j++;\n            }\n            count += j - i - 1;\n        }\n        \n        if (count >= k) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    \n    return left;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/43#issuecomment-2585238264","body":"```\n/**\n * @param {number[][]} grid\n * @return {number}\n * 时间复杂度: O(N^2 * log(N)) \n * 空间复杂度: O(N^2) \n */\nvar swimInWater = function(grid) {\n    const n = grid.length;\n    let left = grid[0][0];\n    let right = n * n - 1;\n    \n    // 二分查找最小等待时间\n    while (left < right) {\n        const mid = Math.floor((left + right) / 2);\n        const visited = new Array(n).fill(0).map(() => new Array(n).fill(false));\n        \n        if (canReach(grid, mid, 0, 0, visited, n)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    \n    return left;\n};\n\n// DFS检查是否能从(0,0)到达(n-1,n-1)\nfunction canReach(grid, time, i, j, visited, n) {\n    if (i < 0 || i >= n || j < 0 || j >= n || visited[i][j] || grid[i][j] > time) {\n        return false;\n    }\n    \n    if (i === n-1 && j === n-1) {\n        return true;\n    }\n    \n    visited[i][j] = true;\n    \n    // 四个方向DFS\n    const directions = [[0,1], [1,0], [0,-1], [-1,0]];\n    for (const [di, dj] of directions) {\n        const ni = i + di;\n        const nj = j + dj;\n        if (canReach(grid, time, ni, nj, visited, n)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/44#issuecomment-2585557375","body":"```\nfunction maxVowels(s, k) {\n   const vowels = new Set(['a', 'e', 'i', 'o', 'u']);\n   let count = 0;\n   \n   // 统计前k个字符中元音的数量\n   for(let i = 0; i < k; i++) {\n       if(vowels.has(s[i])) count++;\n   }\n   \n   let max = count;\n   \n   // 滑动窗口\n   for(let i = k; i < s.length; i++) {\n       // 去掉窗口最左边的元音数\n       if(vowels.has(s[i-k])) count--;\n       // 加上新进入窗口的元音数\n       if(vowels.has(s[i])) count++;\n       max = Math.max(max, count);\n   }\n   \n   return max;\n}\n```\n时间复杂度: O(n)\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/45#issuecomment-2586945214","body":"```\n/**\n * 时间复杂度: O(K+W), K是上限值, W是每次可抽取的最大值\n * 空间复杂度: O(K+W)\n * 解法: 动态规划 + 滑动窗口\n */\nvar new21Game = function(n, k, maxPts) {\n    if (k === 0 || n >= k + maxPts - 1) return 1.0;\n    \n    // dp[i]表示从得分i开始到达[k,n]的概率\n    const dp = new Array(k + maxPts).fill(0);\n    \n    // 初始化dp数组，所有>=k且<=n的位置概率为1\n    for (let i = k; i <= n && i < k + maxPts; i++) {\n        dp[i] = 1.0;\n    }\n    \n    // 计算当前滑动窗口的和\n    let windowSum = dp.slice(k, k + maxPts).reduce((a, b) => a + b, 0);\n    \n    // 从k-1开始向前计算概率\n    for (let i = k - 1; i >= 0; i--) {\n        dp[i] = windowSum / maxPts;\n        windowSum = windowSum - dp[i + maxPts] + dp[i];\n    }\n    \n    return dp[0];\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/46#issuecomment-2589737205","body":"```\n/**\n * 时间复杂度: O(n)\n * 空间复杂度: O(1)\n */\nvar findAnagrams = function(s, p) {\n    // 存储结果的数组\n    const result = [];\n    // 记录模式串p中每个字符的出现次数\n    const pCount = new Array(26).fill(0);\n    // 记录滑动窗口中每个字符的出现次数\n    const window = new Array(26).fill(0);\n    \n    // 统计模式串中每个字符的出现次数\n    for (let char of p) {\n        pCount[char.charCodeAt(0) - 97]++; // 转换小写字母为0-25的索引\n    }\n    \n    // 滑动窗口遍历源字符串\n    for (let i = 0; i < s.length; i++) {\n        // 将新字符添加到窗口计数中\n        window[s[i].charCodeAt(0) - 97]++;\n        \n        // 如果窗口大小超过模式串长度，移除最左边的字符\n        if (i >= p.length) {\n            window[s[i - p.length].charCodeAt(0) - 97]--;\n        }\n        \n        // 当窗口大小达到模式串长度时，检查是否为异位词\n        if (i >= p.length - 1) {\n            let isAnagram = true;\n            // 比较窗口和模式串的字符计数是否完全相同\n            for (let j = 0; j < 26; j++) {\n                if (window[j] !== pCount[j]) {\n                    isAnagram = false;\n                    break;\n                }\n            }\n            // 如果是异位词，记录起始索引\n            if (isAnagram) result.push(i - p.length + 1);\n        }\n    }\n    \n    return result;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/47#issuecomment-2592496702","body":"```\n/**\n * @param {string} s 源字符串\n * @param {string} t 目标字符串\n * @return {string} 最小覆盖子串\n */\nconst minWindow = function(s, t) {\n    // 特殊情况处理\n    if (s.length < t.length) return \"\";\n    \n    // 记录目标字符串中每个字符需要的数量\n    const need = {};\n    for (let c of t) {\n        need[c] = (need[c] || 0) + 1;\n    }\n    \n    // 需要匹配的字符种类数量\n    const needTypes = Object.keys(need).length;\n    \n    // 记录当前窗口中已经匹配的字符种类数量\n    let valid = 0;\n    // 窗口中每个字符的数量\n    const window = {};\n    \n    // 记录最小覆盖子串的起始位置和长度\n    let start = 0;\n    let minLen = Infinity;\n    \n    // 窗口的左右边界\n    let left = 0;\n    let right = 0;\n    \n    // 扩大窗口\n    while (right < s.length) {\n        // 获取将移入窗口的字符\n        let c = s[right];\n        right++;\n        \n        // 更新窗口数据\n        if (need[c]) {\n            window[c] = (window[c] || 0) + 1;\n            if (window[c] === need[c]) {\n                valid++;\n            }\n        }\n        \n        // 当找到可行解时，收缩窗口\n        while (valid === needTypes) {\n            // 更新最小覆盖子串\n            if (right - left < minLen) {\n                start = left;\n                minLen = right - left;\n            }\n            \n            // 获取将移出窗口的字符\n            let d = s[left];\n            left++;\n            \n            // 更新窗口数据\n            if (need[d]) {\n                if (window[d] === need[d]) {\n                    valid--;\n                }\n                window[d]--;\n            }\n        }\n    }\n    \n    return minLen === Infinity ? \"\" : s.substr(start, minLen);\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/48#issuecomment-2595016823","body":"```\n/**\n * @param {number[]} cardPoints\n * @param {number} k\n * @return {number}\n * Time: O(n) \n * Space: O(1)\n */\nvar maxScore = function(cardPoints, k) {\n    const n = cardPoints.length;\n    let sum = 0;\n    for (let i = 0; i < k; i++) {\n        sum += cardPoints[i];\n    }\n    \n    let maxSum = sum;\n    for (let i = k - 1, j = n - 1; i >= 0; i--, j--) {\n        sum = sum - cardPoints[i] + cardPoints[j];\n        maxSum = Math.max(maxSum, sum);\n    }\n    \n    return maxSum;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/49#issuecomment-2597248625","body":"```\n/**\n * Time: O(1) \n * Space: O(1) \n */\nvar readBinaryWatch = function(turnedOn) {\n    const result = [];\n    \n    for (let h = 0; h < 12; h++) {\n        for (let m = 0; m < 60; m++) {\n            if (countBits(h) + countBits(m) === turnedOn) {\n                result.push(`${h}:${m < 10 ? '0' + m : m}`);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction countBits(num) {\n    let count = 0;\n    while (num) {\n        count += num & 1;\n        num >>= 1;\n    }\n    return count;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/50#issuecomment-2599649759","body":"```\n/**\n * @param {number} n\n * @return {number}\n * Time: O(N) \n * Space: O(N)\n */\nvar totalNQueens = function(n) {\n    let count = 0;\n    const cols = new Set();\n    const diag1 = new Set();  // r + c\n    const diag2 = new Set();  // r - c\n    \n    const backtrack = (row) => {\n        if (row === n) {\n            count++;\n            return;\n        }\n        \n        for (let col = 0; col < n; col++) {\n            if (cols.has(col) || \n                diag1.has(row + col) || \n                diag2.has(row - col)) {\n                continue;\n            }\n            \n            cols.add(col);\n            diag1.add(row + col);\n            diag2.add(row - col);\n            \n            backtrack(row + 1);\n            \n            cols.delete(col);\n            diag1.delete(row + col);\n            diag2.delete(row - col);\n        }\n    };\n    \n    backtrack(0);\n    return count;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/51#issuecomment-2600788347","body":"```\n/**\n * @param {number[][]} grid\n * @return {number}\n * Time: O(m*n) - 每个格子最多访问一次\n * Space: O(m*n) - 最坏情况下递归栈的深度\n */\nvar maxAreaOfIsland = function(grid) {\n    const m = grid.length;\n    const n = grid[0].length;\n    let maxArea = 0;\n    \n    const dfs = (i, j) => {\n        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] === 0) {\n            return 0;\n        }\n        \n        grid[i][j] = 0; // 标记已访问\n        \n        return 1 + dfs(i-1, j) + dfs(i+1, j) + dfs(i, j-1) + dfs(i, j+1);\n    };\n    \n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (grid[i][j] === 1) {\n                maxArea = Math.max(maxArea, dfs(i, j));\n            }\n        }\n    }\n    \n    return maxArea;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/52#issuecomment-2602483049","body":"```\nconst maxDistance = function(grid) {\n   const n = grid.length;\n   const queue = [];\n   \n   // 将所有陆地格子加入队列\n   for(let i = 0; i < n; i++) {\n       for(let j = 0; j < n; j++) {\n           if(grid[i][j] === 1) {\n               queue.push([i, j]);\n           }\n       }\n   }\n   \n   // 特判:全是陆地或者全是海洋\n   if(queue.length === 0 || queue.length === n * n) return -1;\n   \n   const dirs = [[1,0], [-1,0], [0,1], [0,-1]];\n   let distance = -1;\n   \n   while(queue.length) {\n       distance++;\n       const size = queue.length;\n       \n       for(let i = 0; i < size; i++) {\n           const [x, y] = queue.shift();\n           \n           for(const [dx, dy] of dirs) {\n               const newX = x + dx;\n               const newY = y + dy;\n               \n               if(newX >= 0 && newX < n && newY >= 0 && newY < n && grid[newX][newY] === 0) {\n                   grid[newX][newY] = 1;\n                   queue.push([newX, newY]);\n               }\n           }\n       }\n   }\n   \n   return distance;\n};\n\n// 时间复杂度: O(n^2)\n// 空间复杂度: O(n^2)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/53#issuecomment-2604538301","body":"\n```javascript\n/**\n * @param {number[]} status\n * @param {number[]} candies\n * @param {number[][]} keys\n * @param {number[][]} containedBoxes\n * @param {number[]} initialBoxes\n * @return {number}\n */\nvar maxCandies = function(status, candies, keys, containedBoxes, initialBoxes) {\n    const n = status.length;\n    // 已有的盒子\n    const haveBoxes = new Set(initialBoxes);\n    // 已有的钥匙\n    const haveKeys = new Set();\n    for(let i = 0; i < n; i++) {\n        if(status[i]) haveKeys.add(i);\n    }\n    \n    // 可以打开的盒子队列\n    const queue = initialBoxes.filter(box => haveKeys.has(box));\n    // 已处理过的盒子\n    const processed = new Set();\n    // 总糖果数\n    let totalCandies = 0;\n    \n    while(queue.length) {\n        const box = queue.shift();\n        if(processed.has(box)) continue;\n        \n        processed.add(box);\n        // 收集糖果\n        totalCandies += candies[box];\n        \n        // 收集新钥匙\n        for(const key of keys[box]) {\n            haveKeys.add(key);\n            // 如果有对应盒子且未处理过,加入队列\n            if(haveBoxes.has(key) && !processed.has(key)) {\n                queue.push(key);\n            }\n        }\n        \n        // 收集新盒子\n        for(const newBox of containedBoxes[box]) {\n            haveBoxes.add(newBox);\n            // 如果有对应钥匙且未处理过,加入队列\n            if(haveKeys.has(newBox) && !processed.has(newBox)) {\n                queue.push(newBox);\n            }\n        }\n    }\n    \n    return totalCandies;\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/55#issuecomment-2609468201","body":"```\nconst minCostClimbingStairs = function(cost) {\n   const n = cost.length;\n   const dp = new Array(n + 1).fill(0);\n   \n   for(let i = 2; i <= n; i++) {\n       dp[i] = Math.min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]);\n   }\n   \n   return dp[n];\n};\n\n// 时间复杂度: O(n) \n// 空间复杂度: O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/56#issuecomment-2611411123","body":"```\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar rob = function(nums) {\n    // 处理边界情况\n    if (nums.length === 0) return 0;\n    if (nums.length === 1) return nums[0];\n    \n    // dp数组，dp[i]表示到第i个房子为止能偷到的最大金额\n    const dp = new Array(nums.length);\n    \n    // 初始化前两个状态\n    dp[0] = nums[0];  // 只有一个房子时\n    dp[1] = Math.max(nums[0], nums[1]);  // 两个房子时取较大值\n    \n    // 动态规划过程\n    for (let i = 2; i < nums.length; i++) {\n        // 对于当前房子，有两种选择：\n        // 1. 不偷这个房子，则金额等于dp[i-1]\n        // 2. 偷这个房子，则金额等于dp[i-2] + nums[i]\n        dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);\n    }\n    \n    return dp[nums.length - 1];\n};\n```\n时间、空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/57#issuecomment-2613960312","body":"```\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumberOfLIS = function(nums) {\n    const n = nums.length;\n    if (n <= 1) return n;\n    \n    const lengths = new Array(n).fill(1);\n    const counts = new Array(n).fill(1);\n    \n    let maxLen = 1;\n    \n    for (let i = 1; i < n; i++) {\n        for (let j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n                if (lengths[j] + 1 > lengths[i]) {\n                    lengths[i] = lengths[j] + 1;\n                    counts[i] = counts[j];\n                } else if (lengths[j] + 1 === lengths[i]) {\n                    counts[i] += counts[j];\n                }\n            }\n        }\n        maxLen = Math.max(maxLen, lengths[i]);\n    }\n    \n    let result = 0;\n    for (let i = 0; i < n; i++) {\n        if (lengths[i] === maxLen) {\n            result += counts[i];\n        }\n    }\n    \n    return result;\n};\n\n// 时间复杂度：O(n²)\n// 空间复杂度：O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/58#issuecomment-2614285874","body":"```\n\nfunction longestCommonSubsequence(text1, text2) {\n   const m = text1.length, n = text2.length;\n   const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));\n   \n   for(let i = 1; i <= m; i++) {\n       for(let j = 1; j <= n; j++) {\n           if(text1[i-1] === text2[j-1]) {\n               dp[i][j] = dp[i-1][j-1] + 1;\n           } else {\n               dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\n           }\n       }\n   }\n   return dp[m][n];\n}\n```\n// 时间复杂度 O(mn),\n//空间复杂度 O(mn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/59#issuecomment-2614712023","body":"```\n// Time: O(m*n), Space: O(n)\nconst uniquePaths = (m, n) => {\n   let dp = new Array(n).fill(1);\n   \n   for(let i = 1; i < m; i++) {\n       for(let j = 1; j < n; j++) {\n           dp[j] += dp[j-1];\n       }\n   }\n   return dp[n-1];\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fea1220":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/7#issuecomment-2522026419","body":"class Solution(object):\n    def maxChunksToSorted(self, arr):\n        count_a = collections.defaultdict(int)\n        count_b = collections.defaultdict(int)\n        ans = 0\n\n        for a, b in zip(arr, sorted(arr)):\n            count_a[a] += 1\n            count_b[b] += 1\n            if count_a == count_b: ans += 1\n\n        return ans","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wtbkevin":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/7#issuecomment-2523075197","body":"function maxToSort(arr) {\n    if (!arr || arr.length === 0) {\n        return 0;\n    }\n\n    const n = arr.length;\n    const maxLeft = new Array(n).fill(0);\n    const minRight = new Array(n).fill(0);\n\n    maxLeft[0] = arr[0];\n    for (let i = 1; i < n; i++) {\n        maxLeft[i] = Math.max(maxLeft[i - 1], arr[i]);\n    }\n\n    minRight[n - 1] = arr[n - 1];\n    for (let i = n - 2; i >= 0; i--) {\n        minRight[i] = Math.min(minRight[i + 1], arr[i]);\n    }\n\n    let chunks = 0;\n    for (let i = 0; i < n - 1; i++) {\n        if (maxLeft[i] <= minRight[i + 1]) {\n            chunks++;\n        }\n    }\n\n    return chunks + 1;\n}","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/14#issuecomment-2541114573","body":"function maxDepth(root) {\n    if (root === null) {\n        return 0;\n    }\n\n    let queue = [root];\n    let depth = 0;\n\n    while (queue.length > 0) {\n        let levelSize = queue.length;\n        for (let i = 0; i < levelSize; i++) {\n            let node = queue.shift();\n            if (node.left !== null) {\n                queue.push(node.left);\n            }\n            if (node.right !== null) {\n                queue.push(node.right);\n            }\n        }\n        depth++;\n    }\n    return depth;\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"awenbocc":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/7#issuecomment-2523536578","body":"```\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        \"\"\"\r\n        :type arr: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n        stack = []\r\n        for a in arr:\r\n            if stack and stack[-1] > a:\r\n                cur = stack[-1]\r\n                while stack and stack[-1] > a: stack.pop()\r\n                stack.append(cur)\r\n            else:\r\n                stack.append(a)\r\n        return len(stack)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/8#issuecomment-2525213933","body":"class  Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if k == 0 or not head or not head.next:\n            return head\n        \n        n = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            n += 1\n        \n        if (add := n - k % n) == n:\n            return head\n        \n        cur.next = head\n        while add:\n            cur = cur.next\n            add -= 1\n        \n        ret = cur.next\n        cur.next = None\n        return ret","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/9#issuecomment-2526185791","body":"```\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n        first, second = head, head.next\r\n        prev = None\r\n        new_head = head\r\n        while first.next:\r\n            second = first.next\r\n            first.next = second.next\r\n            second.next = first\r\n            if prev:\r\n                prev.next = second\r\n            if new_head == head:\r\n                new_head = second\r\n            if first.next:\r\n                prev = first\r\n                first = first.next\r\n        return new_head\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/11#issuecomment-2532087617","body":"```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        a, b = headA, headB\r\n        while a != b:\r\n            a = a.next if a else headB\r\n            b = b.next if b else headA\r\n        return a\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/16#issuecomment-2543882655","body":"```\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        def dfs(root: TreeNode, prevTotal: int) -> int:\n            if not root:\n                return 0\n            total = prevTotal * 10 + root.val\n            if not root.left and not root.right:\n                return total\n            else:\n                return dfs(root.left, total) + dfs(root.right, total)\n\n        return dfs(root, 0)\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/22#issuecomment-2558152277","body":"```\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ans = 0\n        for p in points:\n            cnt = defaultdict(int)\n            for q in points:\n                dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1])\n                cnt[dis] += 1\n            for m in cnt.values():\n                ans += m * (m - 1)\n        return ans\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hallcia":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/8#issuecomment-2524974471","body":"```\r\nclass  Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if k == 0 or not head or not head.next:\r\n            return head\r\n        \r\n        n = 1\r\n        cur = head\r\n        while cur.next:\r\n            cur = cur.next\r\n            n += 1\r\n        \r\n        if (add := n - k % n) == n:\r\n            return head\r\n        \r\n        cur.next = head\r\n        while add:\r\n            cur = cur.next\r\n            add -= 1\r\n        \r\n        ret = cur.next\r\n        cur.next = None\r\n        return ret\r\n\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/15#issuecomment-2543000440","body":"```\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        if not p or not q:\r\n            return False\r\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huzhipeng-hu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/17#issuecomment-2546012711","body":"思路：对树进行广度优先遍历，最后一个为的值为答案\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        int temp;//保存最终值\n        queue<TreeNode*> a;//借助队列进行广度优先遍历\n        a.push(root);\n        while(!a.empty())\n        {\n            TreeNode*p=a.front();\n            a.pop();\n            if(p->right)\n                a.push(p->right);\n            if(p->left)\n                a.push(p->left);\n            temp=p->val;\n        } \n        return temp;\n    }\n};\n时间复杂度O（N）；","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/19#issuecomment-2551671889","body":"# 91天算法打卡\n\n## 第18天·\n\n问题链接：https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/description/\n问题分析：大致思路，对树进行遍历并且对于相对应的节点进行大标签（难点，如何进行遍历时将点的值与坐标挂上关联），进行排序，最后输出\n\n代码：\n\n``class Solution {`\n\n`public:`\n\n  `vector<tuple<int,int,int> >temp;`\n\n​    `void dfs(TreeNode*root,int row,int col)`\n\n​    `{`\n\n​      `if(root==nullptr)`\n\n​      \t`return;`\n\n​      `temp.emplace_back(col,row,root->val);`\n\n​      `dfs(root->left,row+1,col-1);`\n\n​      `dfs(root->right,row+1,col+1);`\n\n​    `}`\n\n  `vector<vector<int>> verticalTraversal(TreeNode* root)` \n\n  `{`\n\n  \t  `dfs(root,0,0);`\n\n​    \t`sort(temp.begin(),temp.end());`\n\n​    \t`vector<vector<int>> arry;`\n\n​    \t`int cmpar=INT_MAX;`\n\n​    `for(const auto&[col,row,val]:temp)`\n\n​    `{`\n\n​      \t`if(col!=cmpar)`\n\n​     \t `{`\n\n​        \t`cmpar=col;`\n\n​        \t`arry.emplace_back();`\n\n​      \t`}`\n\n​      `arry.back().push_back(val);`\n\n​    `}`\n\n​    \t`return arry;`\n\n  \t`}`\n\n`}`\n\n时间复杂度为：O（nlogN）\n\n空间复杂度：O（logN）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/20#issuecomment-2554779092","body":"代码:`\n\nclass Solution {\n\npublic:\n\n  vector<int> twoSum(vector<int>& nums, int target) {\n\n​    vector<int> temp2(nums);\n\n​    sort(nums.begin(),nums.end());\n\n​    vector<int> temp;\n\n​    int i=0,j=nums.size()-1;\n\n​    while(1)\n\n​    {\n\n​    if(nums[i]+nums[j]<target)\n\n​    i++;\n\n​    if(nums[i]+nums[j]>target)\n\n​    j--;\n\n​    if(nums[i]+nums[j]==target)\n\n​    break;\n\n​    } \n\n​    int p=distance(temp2.begin(), find(temp2.begin(),temp2.end(),temp[i]));\n\n​    int k=distance(temp2.begin(), find(temp2.begin(),temp2.end(),temp[j]));\n\n​    temp.push_back(p);\n\n​    temp.push_back(k);\n\n​    return temp;\n\n  }\n\n};`\n时间复杂度：O（N）：\n空间复杂度：O（N）：","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/27#issuecomment-2562653377","body":"## 第26天\n\n思路：先排序，后去除相同元素\n\n`   class Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int temp;\n        int cout=1;\n        sort(nums.begin(),nums.end());\n        temp=nums[0];\n        for(int i=1;i<nums.size();)\n        {\n            if(temp==nums[i])\n            {\n                nums.erase(nums.begin()+i);\n            }\n            else\n            {\n                temp=nums[i];\n                i++;\n                cout++;\n            }\n        }\n        return cout;\n    }\n};`\n\n时间复杂度O（n）\n\n空间复杂度（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/28#issuecomment-2563710540","body":"# # #  第二十七天\n思路：利用二分查找进行搜索\n代码：\n```class Solution {\n    public:\n        int searchInsert(vector<int>& nums, int target)\n        {\n            int right=0,left=nums.size()-1,mind,temp=nums.size();\n            while(right<=left)\n        {\n            mind=(right+left)/2;\n            if(target<=nums[mind])\n            {\n                temp=mind;\n                left=mind-1;\n            }\n            else \n            {\n                right=mind+1;\n            }\n            \n        }\n        return temp;\n    }\n};```\n时间复杂度：log（N）\n空间复杂度：O（1）","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/33#issuecomment-2567025830","body":"```c++\nclass Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int temp[4]={0};\n        for(char i:moves)\n        {\n            switch(i)\n            {\n                case 'R':\n                {\n                    temp[0]++;\n                    continue;\n                }\n                case 'L':\n                {\n                    temp[1]++;\n                    continue;\n                }\n                case 'U':\n                {\n                    temp[2]++;\n                    continue;\n                }\n                case 'D':\n                {\n                    temp[3]++;\n                    continue;\n                }\n            }\n        }\n        if(temp[0]==temp[1]&&temp[2]==temp[3])\n        return true;\n        else\n        return false;\n    }\n};\n```\n时间复杂度：O（N）\n空间复杂度：O（4）","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/40#issuecomment-2577534463","body":"\"\"\"class Solution {\npublic:\n    int ans = 0;\n    int tmp[50001];\n    int reversePairs(vector<int>& nums) {\n        merge_sort(nums, 0, nums.size() - 1);\n        return ans;\n    }\n    void merge_sort(vector<int> &q, int l, int r){\n        if(l >= r) return;\n        int mid = l + r >> 1;\n        merge_sort(q, l, mid);\n        merge_sort(q, mid + 1, r);\n        int i = l, j = mid + 1, k = 0;\n        while(i <= mid && j <= r){\n            if((long long) q[i] > (long long) 2 * q[j]){\n                ans += mid - i + 1;\n                j++;\n            }\n            else i++;\n        }\n        i = l;\n        j = mid + 1;\n        while(i <= mid && j <= r){\n            if(q[i] <= q[j]) tmp[k++] = q[i++];\n            else tmp[k++] = q[j++];\n        }\n        while(i <= mid) tmp[k++] = q[i++];\n        while(j <= r) tmp[k++] = q[j++];\n        for(int i = l, j = 0; i <= r; i++, j++){\n            q[i] = tmp[j];\n        }\n    }\n};\n\"\"\"\n时间复杂度：nlongN\n空间复杂度：n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/47#issuecomment-2592184884","body":"```\npublic:\n\n  unordered_map<char,int> temp,num;\n\n  bool check()\n\n  {\n\n​    for(const auto &p:temp)\n\n​    {\n\n​      if(num[p.first]<p.second)\n\n​      {\n\n​        return false;\n\n​      }\n\n​    }\n\n​    return true;\n\n  }\n\n  string minWindow(string s, string t) {\n\n​    for(const auto &c:t)\n\n​    {\n\n​      ++temp[c];\n\n​    }\n\n​    int l=0,r=-1;\n\n​    int len=INT_MAX,ansl=-1,ansr=-1;\n\n​    while(r<int(s.size()))\n\n​    {\n\n​      if(temp.find(s[++r])!=temp.end())\n\n​      {\n\n​        ++num[s[r]];\n\n​      }\n\n​      while(check()&&l<=r)\n\n​      {\n\n​        if(r-l+1<len)\n\n​        {\n\n​          len=r-l+1;\n\n​          ansl=l;\n\n​        }\n\n​        if(temp.find(s[l])!=temp.end())\n\n​        {\n\n​          --num[s[l]];\n\n​        }\n\n​        ++l;\n\n​      }\n\n​    }\n\n​    return ansl==-1?string():s.substr(ansl,len);\n\n  }\n\n};\n```\n时间复杂度：O（n）\n空间复杂度：O (1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tongtz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/29#issuecomment-2564161215","body":"class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        res = []\n        q = deque()\n\n        for idx, num in enumerate(nums):\n            while q and q[-1] < num:\n                q.pop()\n            q.append(num)\n\n            if idx >= k and nums[idx - k] == q[0]:\n                q.popleft()\n            \n            if idx >= k - 1:\n                res.append(q[0])\n        \n        return res\n\n时间复杂度: O(n)\n空间复杂度: O(k)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/30#issuecomment-2564570014","body":"class Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        trusted = [0] * (n+1)\n        for (a,b) in trust:\n            trusted[a] -= 1\n            trusted[b] += 1\n        for i in range(1, len(trusted)):\n            if trusted[i] == n-1:\n                return i\n        return -1\n\nTime Complexity:- O(n) \nSpace Complexity:- O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/31#issuecomment-2564839867","body":"class Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        g = defaultdict(list)\n\n        for x,y in dislikes:\n            g[x].append(y)\n            g[y].append(x)\n\n        color = {}\n\n        def dfs(i,c):\n            if i in color: return color[i] == c\n            color[i] = c\n            for enemy in g[i]:\n                if not dfs(enemy, 1-c):  # Check all neighbors, return False if any conflict\n                    return False\n            return True\n        \n        for i in range(1, n+1):\n            if i not in color:\n                 if not dfs(i, 1):  # Start a DFS for unvisited nodes\n                    return False\n\n        return True\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/38#issuecomment-2571833901","body":"class Solution:\n    def mySqrt(self, x: int) -> int:\n        if x == 0: return 0\n        left, right = 1, x\n        while left <= right:\n            mid = (left + right)//2\n            if mid * mid == x: \n                return mid\n            elif mid * mid < x: \n                left = mid + 1\n            else: \n                right = mid - 1\n        return right","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/39#issuecomment-2574485170","body":"class Solution:\n    def firstBadVersion(self, n: int) -> int:\n        left, right = 0, n\n        while left <= right:\n            mid = (right + left)//2\n            if isBadVersion(mid):\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/43#issuecomment-2584058447","body":"class Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        m = len(grid[0])\n\n        if n == m == 1:\n            return grid[0][0]\n        \n        def get_nexts(i, j, visited):\n            for x, y in ((i - 1, j),\n                         (i + 1, j),\n                         (i, j - 1),\n                         (i, j + 1)):\n                if (\n                    0 <= x < n\n                    and 0 <= y < m\n                    and (x, y) not in visited\n                ):\n                    yield (x, y)\n\n        def check(value):\n            q = [(0, 0)]\n            visited = {(0, 0)}\n            while q:\n                i, j = q.pop()\n                for x, y in get_nexts(i, j, visited):\n                    if grid[x][y] > value:\n                        continue\n                    if x == n - 1 and y == m - 1:\n                        return True\n                    q.append((x, y))\n                    visited.add((x, y))\n            return False\n        \n        left = max(grid[0][0], grid[-1][-1])\n        right = max(max(line) for line in grid)\n\n        if check(left):\n            return left\n        \n        while right - left > 1:\n            middle = (left + right) // 2\n            if check(middle):\n                right = middle\n            else:\n                left = middle\n        \n        return right","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/44#issuecomment-2585613405","body":"```\r\nclass Solution:\r\n    def maxVowels(self, s: str, k: int) -> int:\r\n        vowels = {'a', 'e', 'i', 'o', 'u'}\r\n        count = sum(1 for i in range(k) if s[i] in vowels)\r\n        max_count = count\r\n\r\n        for i in range(k, len(s)):\r\n            if s[i-k] in vowels:\r\n                count -= 1\r\n            if s[i] in vowels:\r\n                count += 1\r\n\r\n            max_count = max(max_count, count)\r\n\r\n        return max_count\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/50#issuecomment-2599574088","body":"class Solution:\n    def totalNQueens(self, n: int) -> int:\n        self.res=0\n\n        state = [['.'] * n for _ in range(n)]\n        res = set()\n\n        placed_col = set()\n        placed_pos = set()\n        placed_neg = set()\n\n        def backtrack(r):\n            if r == n:\n                self.res+=1\n\n            for c in range(n):\n                if c in placed_col or r + c in placed_pos or r - c in placed_neg:\n                    continue\n                \n                placed_col.add(c)\n                placed_pos.add(r+c)\n                placed_neg.add(r-c)\n                state[r][c] = 'Q'\n\n                backtrack(r+1)\n\n                placed_col.remove(c)\n                placed_pos.remove(r+c)\n                placed_neg.remove(r-c)\n                state[r][c] = '.'\n\n        backtrack(0)\n\n        return self.res\n        ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/51#issuecomment-2599836996","body":"class Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n\n        ROWS, COLS = len(grid), len(grid[0])\n        max_area = 0\n\n        def dfs(r,c):\n            if min(r,c) < 0 or r == ROWS or c == COLS or grid[r][c] == 0):\n                return 0\n            grid(r,c) = 0\n            return (1 + dfs(r + 1, c) + dfs(r - 1, c) + dfs(r, c + 1) + dfs(r, c - 1))\n\n        for c in range(ROWS):\n            for c in range(COLS):\n                max_area = max(max_area, dfs(r, c))\n        return max_area","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/57#issuecomment-2613663768","body":"class Solution:\n    def findNumberOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n <= 1:\n            return n\n\n        lengths = [1] * n\n        counts = [1] * n\n\n        for i in range(1, n):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    if lengths[j] + 1 > lengths[i]:\n                        lengths[i] = lengths[j] + 1\n                        counts[i] = counts[j]\n                    elif lengths[j] + 1 == lengths[i]:\n                        counts[i] += counts[j]\n\n        max_length = max(lengths)\n        return sum(count for length, count in zip(lengths, counts) if length == max_length)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lindo146":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/35#issuecomment-2568766284","body":"'''\r\nclass Solution:\r\n    def` numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\r\n        def time_to_minutes(time_str):\r\n            hours, minutes = map(int, time_str.split(':'))\r\n            return hours * 60 + minutes\r\n        login = time_to_minutes(loginTime)\r\n        logout = time_to_minutes(logoutTime)  \r\n        if logout < login:\r\n            logout += 24 * 60          \r\n        login = (login + 14) // 15 * 15\r\n        logout = logout // 15 * 15               \r\n        return max(0, (logout - login) // 15)\r\n'''","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/48#issuecomment-2594392428","body":"class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        l = ans = sub_s = 0\n        n, s = len(cardPoints), sum(cardPoints)\n        if n == k:\n            return s\n\n        for r, x in enumerate(cardPoints):\n            sub_s += x\n            if r - l + 1 == n - k:\n                ans = max(ans, s - sub_s)\n                sub_s -= cardPoints[l]\n                l += 1\n        return ans","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/51#issuecomment-2600893424","body":"class Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        m, n = len(grid),len(grid[0])\n        \n        def dfs(i: int, j: int) -> int:\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != 1:\n                return 0\n            s = 1\n            grid[i][j] = 2\n            s += dfs(i+1, j) + dfs(i-1, j) + dfs(i, j+1) + dfs(i, j-1)\n            return s\n        ans = 0\n        for i, row in enumerate(grid):\n            for j, x in enumerate(row):\n                if x == 1:\n                    ans = max(ans, dfs(i, j))\n        return ans\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/52#issuecomment-2602494656","body":"class Solution:\n    def maxDistance(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n\n        stack = []\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]:\n                    stack.append([i, j])\n\n        if len(stack) == m*n or not stack:\n            return -1\n\n        step = 1\n        while stack:\n            nex = []\n            for i, j in stack:\n                for x, y in [[i+1, j], [i-1, j], [i, j+1], [i, j-1]]:\n                    if 0<=x<m and 0<=y<n and not grid[x][y]:\n                        nex.append([x, y])\n                        grid[x][y] = step\n            stack = nex\n            step += 1\n        return step-2","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/57#issuecomment-2613713546","body":"from typing import List\n\nclass Solution:\n    def findNumberOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        dp = [1] * n  # dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度\n        cnt = [1] * n  # cnt[i] 表示以 nums[i] 结尾的最长递增子序列的个数\n        \n        max_len = 1  # 记录全局最长递增子序列的长度\n        result = 0  # 记录最长递增子序列的个数\n        \n        for i in range(n):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    if dp[j] + 1 > dp[i]:\n                        dp[i] = dp[j] + 1\n                        cnt[i] = cnt[j]\n                    elif dp[j] + 1 == dp[i]:\n                        cnt[i] += cnt[j]\n            \n            if dp[i] > max_len:\n                max_len = dp[i]\n                result = cnt[i]\n            elif dp[i] == max_len:\n                result += cnt[i]\n        \n        return result","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"heye0507":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/55#issuecomment-2608812206","body":"class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        # time complexity O(n)\n        n = len(cost)\n        if n == 2:\n            return min(cost[0], cost[1])\n        \n        prev2 = cost[0]\n        prev1 = cost[1]\n        \n        for i in range(2, n):\n            curr = cost[i] + min(prev1, prev2)\n            prev2, prev1 = prev1, curr\n        \n        return min(prev1, prev2)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-15-daily-check/issues/59#issuecomment-2614697949","body":"```python\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = []\n        for _ in range(m):\n            dp.append([0] * n)\n        for row in range(m):\n            dp[row][0] = 1\n        for col in range(n):\n            dp[0][col] = 1\n        for row in range(1, m):\n            for col in range(1, n):\n                dp[row][col] = dp[row-1][col] + dp[row][col-1]\n        return dp[row][col]\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}