{"michaelxi3":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184635948","body":"# Idea\r\nArray Iterationï¼Œä»åå¾€å‰è¿›ä½\r\n# Code\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int index = num.length - 1;\r\n        \r\n        while (index >= 0 || k!=0) {\r\n            \r\n            if (index >= 0) {\r\n                k = num[index] + k;\r\n                index--;\r\n            }\r\n            // k != 0 æ—¶éƒ½è¦ç»§ç»­loopï¼å› ä¸ºæœ‰è¿›ä½çš„ special caseï¼\r\n            res.addFirst(k % 10);\r\n            k = k / 10;\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(N)\r\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185699268","body":"# Idea\r\n> Two Pass, Array Manipulation\r\n# Code\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] dist = new int[n];\r\n        // Step_1: Initialization\r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) continue;\r\n            dist[i] = Integer.MAX_VALUE;\r\n        }\r\n        // First Pass: Left to Right\r\n        for (int i = 0; i < n-1; i++) {\r\n            if (dist[i] == Integer.MAX_VALUE) continue;\r\n            else dist[i + 1] = Math.min(dist[i+1], dist[i] + 1);\r\n        }\r\n        // Second Pass: Right to Left\r\n        for (int i = n-1; i > 0; i--) {\r\n            dist[i-1] = Math.min(dist[i-1], dist[i] + 1);\r\n        }\r\n        return dist; \r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(N)\r\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186251631","body":"# Idea\r\n> Implement as an Array and keep track of maxSize and curSize\r\n# Code\r\n```java\r\nclass CustomStack {\r\n\r\n    private int[] arr;\r\n    private int maxSize;\r\n    private int curSize;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.arr = new int[maxSize];\r\n        this.maxSize = maxSize;\r\n        this.curSize = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (this.curSize >= this.maxSize) {\r\n            return;\r\n        } else {\r\n            arr[curSize] = x;\r\n            curSize++;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (this.curSize <= 0) {\r\n            return -1;\r\n        } else {\r\n            curSize--;\r\n            return arr[curSize];\r\n        }\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if (curSize > 0) {\r\n            for (int i = 0; i < k && i < this.curSize; i++) {\r\n                arr[i] = arr[i] + val;\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186559715","body":"# Idea\r\n> Manipulation of Stack\r\n# Code\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Stack<Character> stack = new Stack<>(); // Using stack to decode\r\n\r\n        for (int i=0; i < s.length(); i++) {\r\n            char cur = s.charAt(i);\r\n    \r\n            if (cur == ']') {\r\n                StringBuilder sb = new StringBuilder();\r\n\r\n                // Pop out all characters until '['\r\n                while (!stack.isEmpty() && Character.isLetter(stack.peek())) {\r\n                    sb.insert(0, stack.pop());\r\n                }\r\n                String subString = sb.toString();\r\n                stack.pop(); // Pop out '['\r\n\r\n                // Pop out all numbers as frequency\r\n                sb = new StringBuilder();\r\n                while (!stack.isEmpty() && Character.isDigit(stack.peek())) {\r\n                    sb.insert(0, stack.pop());\r\n                }\r\n                String Freq = sb.toString();\r\n\r\n                // Replicate substring based on frequency\r\n                int count = Integer.valueOf(Freq);\r\n                while (count > 0) {\r\n                    count--;\r\n                    for (char j : subString.toCharArray()) {\r\n                        stack.push(j);\r\n                    }\r\n                }\r\n            } else {\r\n                stack.push(cur);\r\n            }\r\n        }\r\n\r\n        // Retrieve answer from stack\r\n        StringBuilder ans = new StringBuilder();\r\n        while (!stack.isEmpty()) {\r\n            ans.insert(0, stack.pop());\r\n        }\r\n        return ans.toString();\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(N)\r\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188398549","body":"# Idea\r\n> Input and Output Stack\r\n# Code\r\n```java\r\nclass MyQueue {\r\n    \r\n    Stack<Integer> input;\r\n    Stack<Integer> output;\r\n    \r\n    public MyQueue() {\r\n        this.input = new Stack<>();\r\n        this.output = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        this.input.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (!this.output.empty()) {\r\n            return this.output.pop();\r\n        } else {\r\n            while (!this.input.empty()) {\r\n                this.output.push(this.input.pop());\r\n            }\r\n            return this.output.pop();\r\n        }\r\n    }\r\n    \r\n    public int peek() {\r\n        if (!this.output.empty()) {\r\n            return this.output.peek();\r\n        } else {\r\n            while (!this.input.empty()) {\r\n                this.output.push(this.input.pop());\r\n            }\r\n            return this.output.peek();\r\n        }\r\n    }\r\n    \r\n    public boolean empty() {\r\n        if (this.input.empty() && this.output.empty()) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189460545","body":"# Idea\r\n> åˆ©ç”¨ä¸¤ä¸ªç»“è®ºè§£å†³é—®é¢˜\r\n- ç»“è®º_1: Decreasing portion of array cannot be partitioned.\r\n- ç»“è®º_2: Non-Decreasing portion of array can be partitioned.\r\n# Code\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        // Maintain a non-decreasing monotonic stack\r\n        for (int i=0; i < arr.length; i++) {\r\n            // 1. å‡ºç°é€’å‡çš„trendï¼Œéœ€è¦è¿›è¡Œèåˆ\r\n            if (!stack.isEmpty() && arr[i] < stack.peek()) {\r\n                // æˆ‘ä»¬éœ€è¦å°†èåˆåçš„åŒºå—çš„æœ€å¤§å€¼é‡æ–°æ”¾å›æ ˆ\r\n                int localMax = stack.pop();\r\n                while (!stack.isEmpty() && stack.peek() > arr[i]) {\r\n                    stack.pop();\r\n                } \r\n                stack.push(localMax);\r\n            // 2. é€’å¢trendç›´æ¥pushåˆ°stackä¸­å°±å¥½\r\n            } else {\r\n                stack.push(arr[i]);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(N)\r\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190558685","body":"# Idea\r\n> å› ä¸ºé¢˜ç›®ä¸­çš„ ListNode åªæœ‰ next pointerï¼Œæ‰€ä»¥æˆ‘ä»¬æœ€å¥½å…ˆæŠŠ list è¿æ¥æˆä¸€ä¸ª cycleï¼Œå¹¶åœ¨æ¯æ¬¡ rotate åéƒ½æ›´æ–° pointers çš„ä½ç½®ã€‚éš¾ç‚¹åœ¨äºï¼špointer å‘ next æ–¹å‘æ‰€éœ€ç§»åŠ¨çš„æ­¥æ•°ä¸º length - k % lengthï¼Œå› ä¸ºè€ƒè™‘åˆ° k (rotate æ•°é‡) å¤§äº List Length çš„æƒ…å†µã€‚æœ€åå†å°† cycle break ä¸€ä¸‹å˜æˆ list è¿”å› head å³å¯ã€‚\r\n# Code\r\n```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        // NULL head situation\r\n        if (head == null) {\r\n            return head;\r\n        }\r\n        \r\n        // Make a cycle\r\n        int length = 1;\r\n        ListNode end = new ListNode();\r\n        end = head;\r\n        while (end.next != null) {\r\n            end = end.next;\r\n            length++;\r\n        }\r\n        end.next = head;\r\n        \r\n        // Move k steps\r\n        for (int i = length - k % length; i >= 1; i--) {\r\n            head = head.next;\r\n            end = end.next;\r\n        }\r\n\t\t\t\t\r\n\t// Break the cycle\r\n        end.next = null;\r\n        \r\n        return head;\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(n)\r\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1191950906","body":"# Idea\r\n> Linked List é¢˜ç›®çš„éš¾ç‚¹åœ¨äºç†æ¸… Nodes ä¹‹é—´çš„ referencesï¼Œä¸€èˆ¬æ¥è¯´æ·»åŠ ä¸€ä¸ªæˆ–å¤šä¸ª Dummy Node ä¼š makes life easier.\r\n# Code\r\n```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        // Using Dummy node to assist swapPairs\r\n        ListNode dummy = new ListNode(-1);\r\n        dummy.next = head;\r\n        ListNode pointer = dummy;\r\n        \r\n        // Start swapping!\r\n        while (pointer.next != null && pointer.next.next != null) {\r\n            ListNode swap1 = pointer.next;\r\n            ListNode swap2 = pointer.next.next;\r\n            \r\n            pointer.next = swap2;\r\n            swap1.next = swap2.next;\r\n            swap2.next = swap1;\r\n            \r\n            pointer = swap1;\r\n        }\r\n        \r\n        return dummy.next; // dummy.next always refer to the head\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(N)\r\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193025145","body":"# Idea\r\n> ç†è§£é¢˜ç›®ï¼š\r\nè§‚å¯Ÿé¢˜ç›®ç»™å‡ºçš„ä¾‹å­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹å‡º the middle of sorted list is the root of BSTï¼Œè¿™ä¸ª observation å¯ä»¥ apply åˆ° root.left å’Œ root.right çš„æ„å»º recursivelyï¼\r\n\r\n> è§£é¢˜æ–¹æ³•ï¼š\r\nä¸ºäº†æ‰¾åˆ° the middle of LinkedListï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¿«æŒ‡é’ˆå’Œæ…¢æŒ‡é’ˆçš„æ–¹æ³•ã€‚æœ€å¼€å§‹å¿«æ…¢æŒ‡é’ˆéƒ½ä» head å‡ºå‘ï¼Œå¿«æŒ‡é’ˆæ¯æ¬¡èµ°ä¸¤æ­¥ã€æ…¢æŒ‡é’ˆæ¯æ¬¡èµ°ä¸€æ­¥ã€‚æˆ‘ä»¬éœ€è¦è®¾ç½®ä¸€ä¸ª Right Boundary, å½“å¿«æŒ‡é’ˆåˆ°è¾¾æˆ–å³å°†ä¸‹ä¸€æ­¥è¶Šè¿‡å³è¾¹ç•Œæ—¶åœæ­¢ï¼Œæ­¤æ—¶æ…¢æŒ‡é’ˆæ‰€åœ¨ä½ç½®åº”ä¸º list çš„ä¸­é—´ã€‚æˆ‘ä»¬æŠŠè¿™ä¸ªä½ç½®çš„æ…¢æŒ‡é’ˆå½“ä½œæœ¬è½®çš„ root nodeã€‚\r\n# Code\r\n```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        // Empty tree case\r\n        if (head == null) { return null;}\r\n        // Initially, tail is null, the right boundary.\r\n        return buildTree(head, null); \r\n    }\r\n    \r\n    public TreeNode buildTree(ListNode head, ListNode tail) {\r\n        // Base case: NULL node\r\n        if (head == tail) { return null;}\r\n        \r\n        // Find the current tree root, the middle of List\r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n        while (fast != tail && fast.next != tail) {\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        TreeNode root = new TreeNode(slow.val);\r\n        \r\n        // Keep recursively build the tree\r\n        root.left = buildTree(head, slow);\r\n        root.right = buildTree(slow.next, tail);\r\n        return root;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193158709","body":"# Idea\r\n> Use two pointers to one pass m+n\r\n# Code\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        // Boundary Check\r\n        if (headA == null || headB == null) { return null;}\r\n        // Two Pointers\r\n        ListNode aPointer = headA;\r\n        ListNode bPointer = headB;\r\n        \r\n        while (aPointer != bPointer) {\r\n            if (aPointer == null) { aPointer = headB;} else { aPointer = aPointer.next;}\r\n            if (bPointer == null) { bPointer = headA;} else { bPointer = bPointer.next;}\r\n        }\r\n        \r\n        return aPointer;\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(m+n) // Two LinkedList Total Sum\r\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193383091","body":"# Idea\r\n> Fast & Slow Pointers\r\n# Code\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        \r\n        // Find the point of intersection b/w fast and slow pointers\r\n        while(fast != null && fast.next != null) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n            // Identify the intersection point\r\n            // Start the slow2 pointer to find the start of cycle\r\n            if (fast == slow) {\r\n                ListNode slow2 = head;\r\n                while (slow != slow2) {\r\n                    slow = slow.next;\r\n                    slow2 = slow2.next;\r\n                }\r\n                return slow;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(N)\r\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194368980","body":"# Idea\r\n> Dummy nodes as head and tail && Hashmap to store key and val\r\n# Code\r\n```java\r\nclass LRUCache {\r\n    // ã€æ ¸å¿ƒæ€æƒ³ã€‘\r\n    // LinkedList: maintain a Double Linked List -> Switch Order based on LRU Rules\r\n    // With Dummy Head and Tail node to assist\r\n    \r\n    private int curSize;\r\n    private int maxSize; // Capacity\r\n    private Node head;   // Dummy Node\r\n    private Node tail;   // Dummy Node\r\n    private HashMap<Integer, Node> map; // Key & Node -> For 'get' method\r\n    \r\n    // Node Class for DLL\r\n    public class Node {\r\n        // Private fields of Node\r\n        private int key;\r\n        private int val;\r\n        private Node prev;\r\n        private Node next;\r\n        \r\n        public Node (int key, int val) {\r\n            this.key = key;\r\n            this.val = val;\r\n        }\r\n\r\n        public Node () {}\r\n    } \r\n    \r\n    // Constructor\r\n    public LRUCache(int capacity) {\r\n        this.head = new Node();\r\n        this.tail = new Node();\r\n        this.maxSize = capacity;\r\n        this.curSize = 0;\r\n        // Build connections\r\n        this.head.next = this.tail;\r\n        this.head.prev = null;\r\n        this.tail.prev = this.head;\r\n        this.tail.next = null;\r\n        this.map = new HashMap<>();\r\n    }\r\n    \r\n    // Get method: get value if key exists\r\n    public int get(int key) {\r\n        Node cur = map.get(key);\r\n        // Case_1: Key doesn't exist\r\n        if (cur == null) { return -1;}\r\n        // Case_2: Key exists, return and move to front since used\r\n        // Action_LRU: Move to the front\r\n        remove(cur);\r\n        addFront(cur);\r\n        return cur.val;\r\n    }\r\n      \r\n    // Put method: maintain size under capacity\r\n    public void put(int key, int value) {\r\n        Node cur = this.map.get(key);\r\n        // Case_1: If this key doesn't exist, add new pair of key and val\r\n        if (cur == null) {\r\n            Node newNode = new Node(key, value);\r\n            addFront(newNode);\r\n            // Check if exceeds size limitation\r\n            if (this.curSize > this.maxSize) {\r\n                remove(this.tail.prev);\r\n            }\r\n        // Case_2: If this key already existed, update value and move to front! Do not create a new one again!!!\r\n        } else {\r\n            cur.val = value;\r\n            // Updated val & Move to front\r\n            remove(cur);\r\n            addFront(cur);\r\n        }\r\n    }\r\n    \r\n    // Helper Methods\r\n    public void addFront (Node cur) {\r\n        // Insert between head dummy node and previous head\r\n        cur.next = this.head.next;\r\n        this.head.next.prev = cur;\r\n        this.head.next = cur;\r\n        cur.prev = head;\r\n        // If new key, add. Otherwise, just move to front\r\n        if (!map.containsKey(cur.key)) {\r\n            this.curSize++;\r\n            this.map.put(cur.key, cur);\r\n        }\r\n    }\r\n    \r\n    public void remove (Node cur) {\r\n        cur.prev.next = cur.next;\r\n        cur.next.prev = cur.prev;\r\n        map.remove(cur.key, cur);\r\n        this.curSize--;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196010591","body":"# Idea\r\n- Recursively find the maxDepth\r\n# Code\r\n```java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n        \r\n        TreeNode left = root.left;\r\n        TreeNode right = root.right;\r\n        \r\n        int leftDepth = maxDepth(left);\r\n        int rightDepth = maxDepth(right);\r\n        \r\n        return 1 + Math.max(leftDepth, rightDepth);\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(N)\r\n- Space: O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197315981","body":"# Idea\r\n> Recursion DFS check\r\n# Code\r\n```java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        // Base case\r\n        // è‹¥å½“å‰èŠ‚ç‚¹éƒ½ä¸ºnullï¼Œåˆ™ä¸€è‡´\r\n        if (p == null && q == null) { \r\n            return true; \r\n        } \r\n        // è‹¥å½“å‰èŠ‚ç‚¹æ¯”è¾ƒä¸­ï¼Œä¸€ä¸ªä¸ºnullã€ä¸€ä¸ªä¸ä¸ºnullï¼Œåˆ™ä¸ä¸€è‡´\r\n        if (p == null || q == null) { \r\n            return false; \r\n        }\r\n\r\n        // Inductive steps\r\n        // è‹¥å½“å‰èŠ‚ç‚¹æ¯”è¾ƒä¸­ï¼Œä¸¤ä¸ªnodeéƒ½ä¸ä¸ºnullæ—¶ï¼Œéœ€åˆ¤è¯»valæ˜¯å¦ä¸€æ · \r\n        // æ¯”è¾ƒ Left branch æ˜¯å¦ä¸€æ · && æ¯”è¾ƒ Right branch æ˜¯å¦ä¸€æ · \r\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198639061","body":"# Idea\r\n> Tree DFS -> Add sum recursively and think about base cases carefully\r\n# Code\r\n```java\r\nclass Solution {\r\n    public int sumNumbers(TreeNode root) {\r\n        // We need a method to keep track of currentSum\r\n\t\t\t\t // The Initial value of currentSum is 0\r\n        return sumNumber(root, 0);\r\n    }\r\n    \r\n\t\tpublic int sum(TreeNode root, int curSum) {\r\n        // Base case_1: NULL node\r\n        if (root == null) { return 0;}\r\n        // Base case_2: Leaf node\r\n        if (root.left == null && root.right == null) { \r\n            return curSum * 10 + root.val;\r\n        }\r\n        // Inductive Step\r\n        int val = root.val;\r\n        curSum = curSum * 10 + val;\r\n        return sum(root.left, curSum) + sum(root.right, curSum);\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(n) **Number of nodes**\r\n- Space: O(logN) **Tree height**","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1199855455","body":"# Idea\r\n> DFS - Preorder Traversal\r\n> BFS - Record every layer's first node at bottom left\r\n# Code\r\n```java\r\nclass solution {\r\n    int maxDepth = 0;\r\n    int bottomLeft = 0;\r\n    \r\n    public int findBottomLeftValue(TreeNode root) {\r\n        inorderT(root, 0);\r\n        return bottomLeft;\r\n    }\r\n    \r\n    public void inorderT(TreeNode root, int curDepth) {\r\n        // Base case\r\n        if (root == null) { return;}\r\n        // Inductive step: Use preorder traversal\r\n        curDepth++;\r\n        if (curDepth > maxDepth) { \r\n            maxDepth = curDepth;\r\n            bottomLeft = root.val;\r\n        }\r\n        inorderT(root.left, curDepth + 1);\r\n        inorderT(root.right, curDepth + 1);\r\n    }\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200262960","body":"# Idea\r\n> BFS serialize and deserialize using Queue\r\n# Code\r\n```java\r\npublic class Codec {\r\n\r\n    // Encodes a tree to a single string.\r\n    public String serialize(TreeNode root) {\r\n        // Special case: Empty Tree\r\n        if (root == null) { return \"\";}\r\n        StringBuilder sb = new StringBuilder();\r\n        // BFS Initialization\r\n        Queue<TreeNode> q = new LinkedList<>();\r\n        q.offer(root); \r\n        // BFS\r\n        while (!q.isEmpty()) {\r\n            TreeNode cur = q.poll();\r\n            // NULL node case\r\n            if (cur == null) {\r\n                sb.append(\"n\"); \r\n                sb.append(\" \");\r\n                continue;\r\n            }\r\n            sb.append(cur.val); \r\n            sb.append(\" \");\r\n            q.offer(cur.left);\r\n            q.offer(cur.right);\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    public TreeNode deserialize(String data) {\r\n        // Special case: Empty Tree\r\n        if (data.equals(\"\")) { return null;}\r\n        // Deserialize in BFS sequence\r\n        String[] arr = data.split(\" \");\r\n        TreeNode root = new TreeNode(Integer.parseInt(arr[0]));\r\n        Queue<TreeNode> q = new LinkedList<>();\r\n        q.offer(root);\r\n        for (int i = 1; i < arr.length; i++) {\r\n            TreeNode curRoot = q.poll();\r\n            if (!arr[i].equals(\"n\")) {\r\n                TreeNode left = new TreeNode(Integer.parseInt(arr[i]));\r\n                curRoot.left = left;\r\n                q.offer(left);\r\n            }\r\n            if (!arr[++i].equals(\"n\")) {\r\n                TreeNode right = new TreeNode(Integer.parseInt(arr[i]));\r\n                curRoot.right = right;\r\n                q.offer(right);\r\n            }\r\n        }\r\n        return root;\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(n)\r\n- Space: O(w)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200492257","body":"# Idea\r\n> DFS traversal, then input res by columns\r\n# Code\r\n```java\r\nclass Solution {\r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n        // Marking each node with coordinates for verticalTraversal\r\n        // Param: (KEY) column in ascending, (Val) TreeMap<Row in ascending, Node Val in ascending>\r\n        TreeMap<Integer, TreeMap<Integer, PriorityQueue<Integer>>> map = new TreeMap<>();\r\n        dfs(map, root, 0, 0);\r\n        \r\n        // Printout res in Column order\r\n        List<List<Integer>> res = new ArrayList<>();\r\n        for (TreeMap<Integer, PriorityQueue<Integer>> col : map.values()) {\r\n            List<Integer> curColumn = new ArrayList<>();\r\n            for (PriorityQueue<Integer> row : col.values()) {\r\n                while (!row.isEmpty()) {\r\n                    curColumn.add(row.poll());\r\n                }\r\n            }\r\n            res.add(new ArrayList<>(curColumn));\r\n        }\r\n        return res;\r\n    }\r\n    \r\n    public void dfs(TreeMap<Integer,TreeMap<Integer, PriorityQueue<Integer>>> map, TreeNode root, int x, int y) {\r\n        // Base case\r\n        if (root == null) { return;}\r\n        // If column visited\r\n        if (map.containsKey(y)) {\r\n            // If row visited\r\n            if (map.get(y).containsKey(x)) {\r\n                map.get(y).get(x).offer(root.val);\r\n            } else {\r\n                // Column visited, row didn't visit\r\n                TreeMap<Integer, PriorityQueue<Integer>> rows = map.get(y);\r\n                rows.put(x, new PriorityQueue<>());\r\n                rows.get(x).offer(root.val);\r\n            }\r\n        } else {\r\n            // Column didn't visit\r\n            TreeMap<Integer, PriorityQueue<Integer>> row = new TreeMap<>();\r\n            row.put(x, new PriorityQueue<>());\r\n            row.get(x).offer(root.val);\r\n            map.put(y, row);\r\n        }\r\n        // Keep DFS\r\n        dfs(map, root.left, x + 1, y - 1);\r\n        dfs(map, root.right, x + 1, y + 1);\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201652228","body":"# Idea\r\n> HashMap<IntegerVal, Index>\r\n# Code\r\n```java\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int target) {\r\n        int[] res = new int[2];\r\n        // IntegerVal, index\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        for (int i = 0; i < nums.length; i++) {\r\n            if (map.containsKey(target - nums[i])) {\r\n                res[0] = map.get(target - nums[i]);\r\n                res[1] = i;\r\n                return res;\r\n            }\r\n            map.put(nums[i], i);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(N)\r\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203225624","body":"# Idea\r\n> minPQ to maintain the maxFreq kth element\r\n# Code\r\n```java\r\nclass Solution {\r\n    public int[] topKFrequent(int[] nums, int k) {\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        for (int num : nums) {\r\n            map.put(num, map.getOrDefault(num, 0) + 1);\r\n        }\r\n        \r\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[1] - b[1]));\r\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\r\n            int val = entry.getKey();\r\n            int freq = entry.getValue();\r\n            pq.offer(new int[]{val, freq});\r\n            \r\n            if (pq.size() > k) {\r\n                pq.poll();\r\n            }\r\n        }\r\n        \r\n        List<Integer> res = new ArrayList<>();\r\n        while (!pq.isEmpty()) {\r\n            res.add(pq.poll()[0]);\r\n        }\r\n        int[] ans = new int[res.size()];\r\n        for (int i = 0; i < res.size(); i++) {\r\n            ans[i] = res.get(i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(logN)\r\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204411008","body":"# Idea\r\n> å›æ—‹é•–ğŸªƒé—®é¢˜çš„æœ¬è´¨æ˜¯ç”¨ HashMap çš„ç©ºé—´æ¢æ—¶é—´ï¼Œå°† Oï¼ˆn^3ï¼‰çš„æš´åŠ›è§£æ³•ç”¨ HashMapä¼˜åŒ–åˆ°äº† O(n^2).\r\n# Code\r\n```java\r\nclass Solution {\r\n    public int numberOfBoomerangs(int[][] points) {\r\n        int count = 0;\r\n        // Special case: impossible boomerangs\r\n        if (points.length < 3) { return 0;}\r\n        \r\n        // Key: dist, Val: distFreq\r\n        Map<Integer, Integer> map = new HashMap<>(); \r\n        \r\n        // ä»æ¯ä¸€ä¸ªpointçš„è§†è§’æ€è€ƒï¼Œæšä¸¾å°†è¯¥ç‚¹å½“ä½œå›æ—‹é•–ä¸­å¿ƒæ—¶çš„å…¨éƒ¨ç»„åˆå¯èƒ½æ€§\r\n        for (int i = 0; i < points.length; i++) {\r\n            for (int j = 0; j < points.length; j++) {\r\n                int dist = getDistance(points[i][0], points[i][1], points[j][0], points[j][1]);\r\n                map.put(dist, map.getOrDefault(dist, 0) + 1);\r\n            }\r\n            // Permutation å…¨éƒ¨çš„å›æ—‹é•–ç»„åˆå¯èƒ½æ€§\r\n            for (int k : map.values()) {\r\n                count += k * (k-1); // ä»å¤šä¸ªç‚¹ä¸­é€‰ä¸¤ä¸ªç‚¹ä½œä¸ºå›æ—‹é•–çš„ä¸¤è¾¹ nP2\r\n            }\r\n            map.clear();\r\n        }\r\n        return count;\r\n    }\r\n    \r\n    public int getDistance(int x1, int y1, int x2, int y2) {\r\n        int dist = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\r\n        return dist;\r\n    }\r\n}\r\n```\r\n- Time: O(n^2)\r\n- Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205744117","body":"# Idea\r\n> HashSet + Sliding Window\r\n# Code\r\n```java\r\nclass Solution {\r\n    public int lengthOfLongestSubstring(String s) {\r\n        Set<Character> set = new HashSet<>();\r\n        int maxSize = 0;\r\n        int left = 0;\r\n        \r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (!set.add(s.charAt(i))) {\r\n                maxSize = Math.max(maxSize, set.size());\r\n                // Empty the set\r\n                char curChar = s.charAt(i);\r\n                while (s.charAt(left) != curChar) {\r\n                    set.remove(s.charAt(left));\r\n                    left++;\r\n                }\r\n                left++;\r\n            }\r\n        }\r\n        return Math.max(maxSize, set.size());\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1206811956","body":"# Idea\r\n```mermaid\r\ngraph LR\r\nA[Sliding Window] -->|æ»šåŠ¨|B(HashMap)\r\n```\r\n# Code\r\n```java\r\nclass Solution {\r\n    public List<Integer> findSubstring(String s, String[] words) {\r\n        List<Integer> res = new ArrayList<>();\r\n        // Target substring length\r\n        int targetL = words.length * words[0].length();\r\n        // Map: Key is words[] string, Value is corresponding freqency\r\n        Map<String, Integer> map = new HashMap<>();\r\n        for (String i : words) {\r\n            map.put(i, map.getOrDefault(i, 0) + 1);\r\n        }\r\n        // Sliding Window Begin\r\n        for (int i = 0; i <= s.length() - targetL; i++) {\r\n            String cur = s.substring(i, i + targetL);\r\n            if (isValid(cur, map, words[0].length())) { res.add(i);}\r\n        }\r\n        return res;\r\n    }\r\n    \r\n    public boolean isValid(String cur, Map<String, Integer> map, int wordLength) {\r\n        // tmpMap: Key is string, Value is freqency\r\n        Map<String, Integer> tmpMap = new HashMap<>();\r\n        // Traversal by the length of word\r\n        for (int i = 0; i <= cur.length() - wordLength; i+=wordLength) {\r\n            String curS = cur.substring(i, i + wordLength);\r\n            // Does not contain\r\n            if (!map.containsKey(curS)) { \r\n                return false;\r\n            }\r\n            // Contain, but freq not right\r\n            tmpMap.put(curS, tmpMap.getOrDefault(curS, 0) + 1);\r\n            if (tmpMap.get(curS) > map.get(curS)) { \r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207279584","body":"# Idea\r\n> åŒä½™å®šç†\r\n# Code\r\n```java\r\nclass Solution {\r\n    public int minSubarray(int[] nums, int p) {\r\n\r\n        // Find target module\r\n        int target = 0, res = nums.length;\r\n        for (int n : nums)\r\n            target = (target + n) % p;\r\n        // No need to remove any sublist\r\n        if (target == 0) {return 0;}\r\n        \r\n        // Key: prefixSumModP, Value: position index\r\n        Map<Integer, Integer> pos = new HashMap<>();\r\n        pos.put(0, -1);\r\n        \r\n        int curMod = 0;\r\n        for (int i = 0; i < nums.length; ++i) {\r\n            curMod = (curMod + nums[i]) % p;\r\n            // Comp Equation!\r\n            int comp = (p - target + curMod) % p;\r\n            if (pos.containsKey(comp))\r\n                res = Math.min(res, i - pos.get(comp));\r\n            pos.put(curMod, i);\r\n        }    \r\n        return res >= nums.length ? -1 : res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207455458","body":"# Idea\r\n> å¿«æŒ‡é’ˆå’Œæ…¢æŒ‡é’ˆ\r\n# Code\r\n```java\r\nclass Solution {\r\n    public ListNode middleNode(ListNode head) {\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        \r\n        while (fast != null && fast.next != null) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        \r\n        return slow;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208519914","body":"# Idea\r\n> è¯»æŒ‡é’ˆ + å†™æŒ‡é’ˆï¼Œä¸€å¿«ä¸€æ…¢\r\n# Code\r\n```java\r\nclass Solution {\r\n    public int removeDuplicates(int[] nums) {\r\n        int read = nums[0];\r\n        int write = 0;\r\n        \r\n        for (int i = 0; i < nums.length; i++) {\r\n            read = nums[i];\r\n            if (read == nums[write]) { continue;}\r\n            nums[++write] = read;\r\n        }\r\n        \r\n        return write + 1;\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(n)\r\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/42#issuecomment-1209786357","body":"# Idea\r\n> åŒæŒ‡é’ˆæœç´¢ Binary Search\r\n# Code\r\n```java\r\nclass Solution {\r\n    public int searchInsert(int[] nums, int target) {\r\n        int l = 0, r = nums.length - 1;\r\n        int mid = 0;\r\n        \r\n        // Two edge cases\r\n        if(target < nums[0]) { return 0;}\r\n        if(target > nums[nums.length-1]) { return nums.length;}\r\n        \r\n        while (l < r) {\r\n            mid = l + (r - l) / 2;\r\n            \r\n            if (nums[mid] == target) {\r\n                return mid;\r\n            } else if (nums[mid] > target) {\r\n                r = mid;\r\n            } else if (nums[mid] < target) {\r\n                l = mid + 1;\r\n            }\r\n        }\r\n        return l;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"darknightwriter":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184674932","body":"## æ€è·¯\næ³¨æ„ k ã€numæ•°ç»„ã€ä»¥åŠè¿›ä½é—®é¢˜å³å¯ã€‚\n- Javaï¼šæ•°ç»„éå†\n- Pythonï¼š å­—ç¬¦ä¸²å·æ‡’\n\n## è§£é¢˜\nJava:\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> arr = new LinkedList<>();\n        int index = num.length - 1;\n        int plus = 0;\n        while (k > 0 || plus != 0 || index > -1) {\n            int mod = k % 10 + plus;\n            k /= 10;\n            if (index > -1) {\n                mod += num[index--];\n            }\n            arr.addFirst(mod % 10);\n            plus = mod / 10;\n        }\n        return arr;\n    }\n}\n```\nPython:\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = reduce(lambda x, y: x * 10 + y, num) + k\n        return [0] if n == 0 else [int(i) for i in str(n)]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186186080","body":"## æ€è·¯\n1. éå†æŸ¥è¯¢æ‰€æœ‰sä¸­ç­‰äºcçš„ä¸‹æ ‡å¹¶ä¿å­˜\n2. äºŒæ¬¡éå†å¹¶å¯¹æ¯”è¯¥å­—ç¬¦åˆ°ä¸¤ç«¯çš„æœ€çŸ­è·ç¦»\n\n## ä»£ç \n```Java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] ret = new int[s.length()];\n        ArrayList<Integer> index = new ArrayList<>();\n        index.add(-s.length() - 1);\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c){\n                index.add(i);\n            }\n        }\n        index.add(s.length() * 2);\n        int point = 1;\n        for (int i = 0; i < s.length(); i++) {\n            ret[i] = Math.min(i - index.get(point - 1),index.get(point) - i);\n            if (i == index.get(point)){\n                point++;\n            }\n        }\n        return ret;\n    }\n}\n```\n\n## å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦ï¼š O(N)\nç©ºé—´å¤æ‚åº¦ï¼š O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186522499","body":"## æ€è·¯\nä½¿ç”¨æ•°ç»„æ¨¡æ‹Ÿæ ˆæ“ä½œ\n\n## è§£é¢˜\n```Java\nclass CustomStack {\n    int[] stack;\n    int[] nums;\n    int p = -1;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        nums = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (p < stack.length - 1) {\n            stack[++p] = x;\n        }\n    }\n\n    public int pop() {\n        if (p >= 0) {\n            int val = stack[p];\n            int num = nums[p];\n            nums[p--] = 0;\n            if (p >= 0) {\n                nums[p] += num;\n            }\n            return val + num;\n        }\n        return -1;\n    }\n\n    public void increment(int k, int val) {\n        if ( p >= 0){\n            k = Math.min(k - 1, p);\n            nums[k] += val;\n        }\n    }\n}\n```\n## å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦: O(1)\nç©ºé—´å¤æ‚åº¦: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186565468","body":"## æ€è·¯\nä½¿ç”¨æ ˆçš„å‹å…¥å¼¹å‡ºï¼Œæ ¹æ®å³æ‹¬å·ä½œä¸ºå¼¹æ ˆçš„è§¦å‘ã€‚\n\n## ä»£ç \n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for i in s:\n            if i == ']':\n                strs = ''\n                repeat = ''\n                while stack[-1] != '[':\n                    strs = stack.pop() + strs\n                stack.pop()\n                while stack and stack[-1].isdigit():\n                    repeat = stack.pop() + repeat\n                stack.append(int(repeat) * strs)\n                continue\n            stack.append(i)\n        return ''.join(stack)\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼š O(N)\n- ç©ºé—´å¤æ‚åº¦ï¼š O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188936014","body":"## æ€è·¯\nä½¿ç”¨ä¸¤ä¸ªæ ˆï¼Œæ¥å®ç°é˜Ÿåˆ—çš„æ“ä½œ\n## ä»£ç \n```python\nclass MyQueue:\n    def __init__(self):\n        self.stack1, self.stack2 = [], []\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self) -> int:\n        return self.stack2[-1] if self.stack2 else self.stack1[0]\n\n    def empty(self) -> bool:\n        return len(self.stack1) + len(self.stack2) == 0\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190382731","body":"## æ€è·¯\nåŸºç¡€æ ˆæ“ä½œ\n## ä»£ç \n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for i in arr:\n            if stack and i < stack[-1]:\n                head = stack[-1]\n                while stack and i < stack[-1]:\n                    stack.pop()\n                stack.append(head)\n            else:\n                stack.append(i)\n        return len(stack)\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191540789","body":"## æ€è·¯\nå¿«æ…¢æŒ‡é’ˆï¼Œå®Œæˆç¯çš„æ–­å¼€æ“ä½œã€‚\n## ä»£ç \n```python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        count = 0\n        cur = head\n        while cur:\n            count += 1\n            cur = cur.next\n        if count <= 1 or k % count == 0:\n            return head\n        k = k % count\n        slow = fast = head\n        while k:\n            fast = fast.next\n            k -= 1\n        while fast.next:\n            fast = fast.next\n            slow = slow.next\n        new_head = slow.next\n        slow.next = None\n        fast.next = head\n        return new_head\n        \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192641820","body":"## æ€è·¯\nä½¿ç”¨æŒ‡é’ˆå¤åˆ¶ï¼Œå®Œæˆäº¤æ¢\n## ä»£ç \n```python\nclass Solution:\n    def swapPairs(self, head):\n        ret = ListNode()\n        ret.next = head\n        tmp = ret\n        while tmp.next and tmp.next.next:\n            t3 = tmp.next.next.next\n            t2 = tmp.next\n            tmp.next = tmp.next.next\n            tmp.next.next = t2\n            t2.next = t3\n            tmp = t2\n        return ret.next\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193146136","body":"## æ€è·¯\nåˆå§‹åŒ–äºŒå‰æ ‘ï¼Œå¹¶æ ¹æ®é“¾è¡¨æ„é€ äºŒå‰æ ‘\n## ä»£ç \n```python\nclass Solution:\n    def sortedListToBST(self, head):\n        def get_mid(left, right):\n            fast = slow = left\n            while fast != right and fast.next != right:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n\n        def tree(left, right):\n            if left == right:\n                return None\n            mid = get_mid(left, right)\n            root = TreeNode(mid.val)\n            root.left = tree(left, mid)\n            root.right = tree(mid.next, right)\n            return root\n\n        return tree(head, None)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193296735","body":"## æ€è·¯\nä½¿ç”¨å¿«æ…¢æŒ‡é’ˆï¼Œå®Œæˆç›¸äº¤é“¾è¡¨çš„ç¡®å®š\n## ä»£ç \n```python\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        d = {}\n        while headA:\n            d[headA] = headA.val\n            headA = headA.next\n        while headB:\n            if d.get(headB):\n                return headB\n            headB = headB.next\n        return None\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193995380","body":"## æ€è·¯\né‡‡ç”¨å¿«æ…¢æŒ‡é’ˆï¼Œçœ‹æ˜¯å¦ä¸¤ä¸ªæŒ‡é’ˆä¼šç›¸é‡ï¼Œå³å¯åˆ¤æ–­é“¾è¡¨æ˜¯å¦æœ‰ç¯ã€‚\n## ä»£ç \n```python\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                point = head\n                while point!=slow:\n                    point = point.next\n                    slow = slow.next\n                return point\n\n        return None\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196618976","body":"## ä»£ç \n```python\nclass Solution:\n    def maxDepth(self, root):\n        if not root:\n            return 0\n        else:\n            return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198020883","body":"## ä»£ç \n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        def bfs(root):\n            ret = []\n            queue = deque([root])\n            while queue:\n                tmp = []\n                for i in range(len(queue)):\n                    child = queue.popleft()\n                    if child:\n                        tmp.append(child.val)\n                        queue.append(child.left)\n                        queue.append(child.right)\n                    else:\n                        tmp.append(None)\n                if tmp:\n                    ret.append(tmp)\n            return ret\n\n        return bfs(p) == bfs(q)\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200408877","body":"## ä»£ç \n```python\nfrom collections import deque\n\nclass Codec:\n    \n    def serialize(self, root):\n        if not root:\n            return \"\"\n        dq = deque([root])\n        res = []\n        while dq:\n            node = dq.popleft()\n            if node:\n                res.append(str(node.val))\n                dq.append(node.left)\n                dq.append(node.right)\n            else:\n                res.append('None')\n        return ','.join(res)\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n\n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        if not data:\n            return []\n        dataList = data.split(',')\n        root = TreeNode(int(dataList[0]))\n        dq = deque([root])\n        i = 1\n        while dq:\n            node = dq.popleft()\n            if dataList[i] != 'None':\n                node.left = TreeNode(int(dataList[i]))\n                dq.append(node.left)\n            i += 1\n            if dataList[i] != 'None':\n                node.right = TreeNode(int(dataList[i]))\n                dq.append(node.right)\n            i += 1\n        return root\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201339590","body":"## ä»£ç \n```python\nclass Solution(object):\n    def verticalTraversal(self, root):\n        seen = collections.defaultdict(\n                  lambda: collections.defaultdict(list))\n\n        def dfs(node, x=0, y=0):\n            if node:\n                seen[x][y].append(node)\n                dfs(node.left, x-1, y+1)\n                dfs(node.right, x+1, y+1)\n\n        dfs(root)\n        ans = []\n\n        for x in sorted(seen):\n            report = []\n            for y in sorted(seen[x]):\n                report.extend(sorted(node.val for node in seen[x][y]))\n            ans.append(report)\n\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202405282","body":"## ä»£ç \n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        tmp = {}\n        for k, v in enumerate(nums):\n            if target - v in tmp:\n                return [tmp[target - v], k]\n            tmp[v] = k\n```\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205389473","body":"##  ä»£ç \n```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ans = 0\n        for p in points:\n            cnt = defaultdict(int)\n            for q in points:\n                dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1])\n                cnt[dis] += 1\n            for m in cnt.values():\n                ans += m * (m - 1)\n        return ans\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"findlayzhou":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184759423","body":"**æ™ºå•†ä¸å¤Ÿï¼Œç¡¬è§£æ¥å‡‘**\n\n----------------------\n\n> æ€è·¯ï¼šæŠŠæ•´æ•°è½¬æˆæ•°ç»„ï¼ŒåŒæ—¶åˆ›å»ºä¸€ä¸ªé•¿åº¦+1çš„å¤‡ç”¨æ•°ç»„é˜²æ­¢æº¢å‡ºï¼Œå„ä½åˆ†åˆ«åšåè¿›åˆ¶åŠ æ³•ï¼Œä¸æº¢å‡ºåˆ™æˆªæ–­æ•°ç»„è¿”å›ç­”æ¡ˆã€‚\n\n------------\n\n*ä»£ç *\n\n```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\n\n/**\n * @author boyu\n */\npublic class Solution {\n    static int[] addArrAndInt(int[] nums,int k){\n        ArrayList<Integer> al = new ArrayList<>();\n        do{\n            al.add(k % 10);\n        }while ((k /= 10) > 0);\n        Collections.reverse(al);\n        int[] arr = new int[al.size()];\n        for (int i = 0; i < al.size(); i ++) {\n            arr[i] = al.get(i);\n\n        }\n        return addTwoArr(nums, arr);\n    }\n    static int[] addTwoArr(int[] arr1, int[] arr2){\n        int tag = 0;\n        int t;\n        int ptr1 = arr1.length;\n        int ptr2 = arr2.length;\n        int[] res = new int[Math.max(ptr1, ptr2) + 1];\n        Arrays.fill(res, 0);\n        for (int i = res.length - 1; i >= 0 ; i --) {\n            if(ptr1 < 1 && ptr2 < 1) {\n                res[i] = tag;\n                break;\n            }else if(ptr1 < 1){\n                t = arr2[-- ptr2] ;\n            }else if(ptr2 < 1){\n                t = arr1[-- ptr1] ;\n            }else {\n                t = arr1[-- ptr1] + arr2[-- ptr2];\n            }\n            res[i] = (t + tag) % 10;\n            if (t + tag >= 10){\n                tag = 1;\n            }else {\n                tag = 0;\n            }\n        }\n        if ( res[0] != 1 ){\n            return Arrays.copyOfRange(res, 1, res.length);\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        int[] arr= {9, 9, 9};\n        int k = 1;\n        System.out.println(\"{9, 9, 9} + 1 = \" + Arrays.toString(Solution.addArrAndInt(arr, k)));\n    }\n}\n```\n\n--------------\n\n***èŒæ–°åˆšæ¥è§¦ç®—æ³•æ²¡æ€è·¯æ±‚å¤§ä½¬ä»¬è½»å–·ï¼Œåç»­ä¼šåŠªåŠ›å­¦ä¹ å¤§ä½¬è§£æ³•ï¼ŒçŒ®ä¸‘äº†ã€‚***\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185723846","body":"> æ€è·¯ï¼šå¯¹æ¯ä¸€ä¸ªç‚¹è¿›è¡Œå·¦å³éå†ï¼Œå–æœ€å°å€¼ã€‚\r\n\r\n------------\r\n\r\nä»£ç \r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] ans = new int[len];\r\n        Arrays.fill(ans, Integer.MAX_VALUE);\r\n        int t;\r\n        for (int i = 0; i < len; i++) {\r\n            t = i; //æ‰«å·¦è¾¹\r\n            while (t >= 0){\r\n                if (s.charAt(t) == c){\r\n                    ans[i] = Math.min(ans[i], Math.abs(i - t));\r\n                }\r\n                t --;\r\n            }\r\n            t = i; //æ‰«å³è¾¹\r\n            while (t < len){\r\n                if (s.charAt(t) == c){\r\n                    ans[i] = Math.min(ans[i], Math.abs(t - i));\r\n                }\r\n                t ++;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186482276","body":"> æ€è·¯ï¼šåŸºç¡€æ ˆæ“ä½œï¼Œä½¿ç”¨æ•°ç»„ä½œä¸ºæ ˆç»“æ„\n\n------------\n\n*ä»£ç *\n\n```java\nclass CustomStack {\n\n    int[] myStack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        this.myStack = new int[maxSize];\n        this.top = -1;\n    }\n    \n    public void push(int x) {\n        if (this.top < myStack.length - 1){\n            this.top ++;\n            this.myStack[this.top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (this.top <= -1){\n            return -1;\n        }\n        return this.myStack[this.top --];\n    }\n    \n    public void increment(int k, int val) {\n        if (this.top <= k - 1){\n            for (int i = 0; i < this.myStack.length; i++) {\n                this.myStack[i] += val;\n            }\n        }else {\n            for (int i = 0; i < k; i++) {\n                this.myStack[i] += val;\n            }\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187136118","body":"\n> æ€è·¯ï¼šåˆ©ç”¨æ ˆè¿›è¡Œæ‹¬å·åŒ¹é…ã€‚\n\n------------\n\n*ä»£ç *\n\n```java\nclass Solution {\n    int p;\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<String>();\n        p = 0;\n\n        while (p < s.length()){\n            char c = s.charAt(p);\n            if (Character.isDigit(c)){\n                StringBuilder sb = new StringBuilder();\n                while (Character.isDigit(s.charAt(p))){\n                    sb.append(s.charAt(p ++));\n                }\n                stk.addLast(sb.toString());\n            }else if (Character.isLetter(c) || c == '['){\n                stk.addLast(String.valueOf(s.charAt(p ++)));\n            }else{\n                ++ p;\n                LinkedList<String> su = new LinkedList<String>();\n                while (! \"[\".equals(stk.peekLast())){\n                    su.add(stk.removeLast());\n                }\n                Collections.reverse(su);\n                stk.removeLast();\n                int time = Integer.parseInt(stk.removeLast());\n                StringBuilder t = new StringBuilder();\n                String o = getString(su);\n                while (time -- > 0) {\n                    t.append(o);\n                }\n                stk.addLast(t.toString());\n            }\n        }\n        return getString(stk);\n\n    }\n    public String getString(LinkedList<String> v) {\n        StringBuilder ret = new StringBuilder();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n}\n```\n\n--------------\n\nday4\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189016953","body":"\n----------------------\n\n> æ€è·¯ï¼šåˆ©ç”¨è¾…åŠ©ç©ºé—´å®Œæˆä¸¤ä¸ªæ ˆä¹‹é—´å†…å®¹çš„äº¤æ¢ï¼Œä¸€ä¸ªæ ˆå‘ç”Ÿå˜åŒ–æ—¶åŒæ—¶æ”¹å˜å¦ä¸€ä¸ªæ ˆã€‚\n\n------------\n\n*ä»£ç *\n\n```java\nclass MyQueue {\n    Stack<Integer> stackHead;\n    Stack<Integer> stackTail;\n    List<Integer> tmp;\n    \n    public MyQueue() {\n        this.stackHead = new Stack<>();\n        this.stackTail = new Stack<>();\n        this.tmp = new ArrayList<>();\n    }\n    \n    public void push(int x) {\n        this.stackTail.push(x);\n        exchangeStackContents(this.stackTail, this.stackHead);\n    }\n    public int pop() {\n        int x = stackHead.pop();\n        exchangeStackContents(this.stackHead, this.stackTail);\n        return x;\n    }\n    public void exchangeStackContents(Stack<Integer> stackA, Stack<Integer> stackB){\n        this.tmp.clear();\n        stackB.clear();\n        while (!stackA.empty()){\n            this.tmp.add(stackA.pop());\n        }\n        for (int i = 0; i < this.tmp.size(); i++) {\n            stackA.push(this.tmp.get(this.tmp.size() - i -1));\n            stackB.push(this.tmp.get(i));\n        }\n    }\n    \n    public int peek() {\n        return this.stackHead.peek();\n    }\n    \n    public boolean empty() {\n        return this.stackHead.empty();\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190395437","body":"\n> æ€è·¯ï¼šåˆ©ç”¨å•è°ƒæ ˆçš„æ€§è´¨ã€‚\n\n------------\n\n*ä»£ç *\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0, nonzero = 0;\n\n        int[] t = arr.clone();\n        Arrays.sort(t);\n\n        for (int i = 0; i < arr.length; ++i) {\n            int x = arr[i], y = t[i];\n\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if (count.get(x) == 0) nonzero--;\n            if (count.get(x) == 1) nonzero++;\n\n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if (count.get(y) == -1) nonzero++;\n            if (count.get(y) == 0) nonzero--;\n\n            if (nonzero == 0) ans++;\n        }\n\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191615226","body":"----------------------\n\n> æ€è·¯ï¼šç§»åŠ¨é“¾è¡¨æˆç¯ï¼Œé€‰å¥½ä½ç½®åˆ‡å¼€ã€‚\n\n------------\n\n*ä»£ç *\n\n```java\npublic ListNode rotateRight(ListNode head, int k) {\n\n        int length = 0;\n        ListNode left = head;\n        ListNode right = head;\n        if (head == null) {\n            return head;\n        }\n        while (right.next != null) {\n            length++;\n            right = right.next;\n        }\n        length ++;\n        right.next = head;\n        k = (length - k % length) - 1;\n        right = head;\n        while (k > 0) {\n            k --;\n            right = right.next;\n        }\n        left = right.next;\n        right.next = null;\n        return left;\n    }\n```\n--------------","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192639706","body":"> æ€è·¯ï¼šé€’å½’äº¤æ¢èŠ‚ç‚¹\n\n------------\n\n*ä»£ç *\n\n```java\npublic ListNode swapPairs(ListNode head) { \n        if (head == null || head.next == null) { \n            return head; \n        } \n        ListNode newHead = head.next; \n        head.next = swapPairs(newHead.next); \n        newHead.next = head; \n        return newHead; \n    }\n```\n--------------\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193112537","body":"```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n      if(head == null)return null;\r\n      if(head.next == null)return new TreeNode(head.val);\r\n\r\n      List<Integer> list = new ArrayList<>();\r\n      while(head != null){\r\n        list.add(head.val);\r\n        head = head.next;\r\n      }\r\n      return buildTree(0, list.size() - 1, list);\r\n    }\r\n\r\n    TreeNode buildTree(int left, int right, List<Integer> list){\r\n      if(left > right)return null;\r\n      int mid = left + (right - left + 1) / 2;\r\n      TreeNode root = new TreeNode(list.get(mid));\r\n      root.left = buildTree(left, mid - 1, list);\r\n      root.right = buildTree(mid + 1, right, list);\r\n      return root;\r\n    }\r\n}\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193261334","body":"å°†å·²è®¿é—®ç»“ç‚¹åŠ å…¥listè¿›è¡Œåˆ¤æ–­ï¼Œé€ä¸ªéå†ä¸¤ä¸ªé“¾è¡¨å¹¶åˆ¤æ–­æ˜¯å¦å­˜åœ¨\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ArrayList<ListNode> al=new ArrayList<>();\r\n        while(headA!=null){\r\n           if(al.contains(headA)){\r\n                    return headA;\r\n                }else{\r\n                    al.add(headA);\r\n                }\r\n                headA=headA.next;\r\n            }\r\n            \r\n            while(headB!=null){\r\n                if(al.contains(headB)){\r\n                    return headB;\r\n                }else{\r\n                    al.add(headB);\r\n                }\r\n                headB=headB.next;\r\n            }   \r\n        return null;\r\n    }\r\n}\r\n\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194053388","body":"åˆ©ç”¨setæ€§è´¨è§£å†³\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        Set<ListNode> arr=new HashSet<>();\r\n        while (head!=null){\r\n            if (!arr.add(head)) {\r\n                return head;\r\n            }\r\n            head=head.next;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195433538","body":"```java\r\nâ€‚class LRUCache extends LinkedHashMap<Integer, Integer>{\r\n    private int capacity;\r\n    \r\n    public LRUCache(int capacity) {\r\n        super(capacity, 0.75F, true);\r\n        this.capacity = capacity;\r\n    }\r\n\r\n    public int get(int key) {\r\n        return super.getOrDefault(key, -1);\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        super.put(key, value);\r\n    }\r\n\r\n    @Override\r\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\r\n        return size() > capacity; \r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196755817","body":"æ¯ä¸ªå­æ ‘çš„é«˜åº¦ç­‰äºé«˜åº¦æœ€å¤§çš„å­æ ‘é«˜åº¦+1\r\n\r\n```java\r\npublic int maxDepth(TreeNode root) {\r\n        if (root == null){\r\n            return 0;\r\n        }\r\n        return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198213577","body":"é€’å½’\r\n\r\n```java\r\npublic boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if(p==null&&q==null){\r\n            return true;\r\n        }\r\n        if(p==null||q==null){\r\n            return false;\r\n        }\r\n        if(p.val==q.val){\r\n            return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);\r\n        }\r\n        else return false;\r\n    }\r\n\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199179454","body":"```java\r\n\r\n    public int sumNumbers(TreeNode root) {\r\n        return helper(root, 0);\r\n    }\r\n    public int helper(TreeNode root, int i){\r\n        if (root == null) return 0;\r\n        int temp = i * 10 + root.val;\r\n        if (root.left == null && root.right == null)\r\n            return temp;\r\n        return helper(root.left, temp) + helper(root.right, temp);\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200228295","body":"```java\r\nclass Solution {\r\n    int ans = 0, h = 0;\r\n    public int findBottomLeftValue(TreeNode root) {\r\n        dfs(root, 1);\r\n        return ans;\r\n    }\r\n    \r\n    public void dfs(TreeNode root, int depth) {\r\n        if (root == null) return;\r\n        \r\n        if (h < depth) {\r\n            ans = root.val;\r\n            h = depth;\r\n        }\r\n        \r\n        dfs(root.left, depth+1);\r\n        dfs(root.right, depth+1);\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200414599","body":"```java\r\npublic class Codec {\r\n    public String serialize(TreeNode root) {\r\n        if(root==null) return \"null\";\r\n        return root.val+\",\"+serialize(root.left)+\",\"+serialize(root.right);\r\n    }\r\n    public TreeNode deserialize(String data) {\r\n        String[] req=data.split(\",\");\r\n        ArrayList<String> r=new ArrayList<>(Arrays.asList(req));\r\n        return dfsdeserialize(r);     \r\n    }\r\n\r\n    public TreeNode dfsdeserialize(ArrayList<String> r){\r\n        if(\"null\".equals(r.get(0))){\r\n            r.remove(0);\r\n            return null;\r\n        }\r\n        TreeNode node=new TreeNode(Integer.valueOf(r.get(0)));\r\n        r.remove(0);\r\n        node.left=dfsdeserialize(r);\r\n        node.right=dfsdeserialize(r);\r\n        return node;\r\n    }\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201258222","body":"```java\r\n\r\nclass Solution {\r\n    Map<TreeNode, int[]> map = new HashMap<>(); // col, row, val\r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n        map.put(root, new int[]{0, 0, root.val});\r\n        dfs(root);\r\n        List<int[]> list = new ArrayList<>(map.values());\r\n        Collections.sort(list, (a, b)->{\r\n            if (a[0] != b[0]) return a[0] - b[0];\r\n            if (a[1] != b[1]) return a[1] - b[1];\r\n            return a[2] - b[2];\r\n        });\r\n        int n = list.size();\r\n        List<List<Integer>> ans = new ArrayList<>();\r\n        for (int i = 0; i < n; ) {\r\n            int j = i;\r\n            List<Integer> tmp = new ArrayList<>();\r\n            while (j < n && list.get(j)[0] == list.get(i)[0]) tmp.add(list.get(j++)[2]);\r\n            ans.add(tmp);\r\n            i = j;\r\n        }\r\n        return ans;\r\n    }\r\n    void dfs(TreeNode root) {\r\n        if (root == null) return ;\r\n        int[] info = map.get(root);\r\n        int col = info[0], row = info[1], val = info[2];\r\n        if (root.left != null) {\r\n            map.put(root.left, new int[]{col - 1, row + 1, root.left.val});\r\n            dfs(root.left);\r\n        }\r\n        if (root.right != null) {\r\n            map.put(root.right, new int[]{col + 1, row + 1, root.right.val});\r\n            dfs(root.right);\r\n        }\r\n    }\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202045412","body":"```java\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int target) {\r\n        Map<Integer,Integer> hm=new HashMap<>();\r\n        for(int i=0;i<nums.length;i++){\r\n            if(hm.containsKey(target-nums[i])){\r\n                return new int[]{i, hm.get(target-nums[i])};\r\n         }else{\r\n                hm.put(nums[i],i);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203922825","body":"```java\r\nclass Solution {\r\n    public List<Integer> topKFrequent(int[] nums, int k) {\r\n        HashMap<Integer,Integer> map = new HashMap();\r\n        for(int num : nums){\r\n            if (map.containsKey(num)) {\r\n               map.put(num, map.get(num) + 1);\r\n             } else {\r\n                map.put(num, 1);\r\n             }\r\n        }\r\n        PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {\r\n            @Override\r\n            public int compare(Integer a, Integer b) {\r\n                return map.get(a) - map.get(b);\r\n            }\r\n        });\r\n        for (Integer key : map.keySet()) {\r\n            if (pq.size() < k) {\r\n                pq.add(key);\r\n            } else if (map.get(key) > map.get(pq.peek())) {\r\n                pq.remove();\r\n                pq.add(key);\r\n            }\r\n        }\r\n        List<Integer> res = new ArrayList<>();\r\n        while (!pq.isEmpty()) {\r\n            res.add(pq.remove());\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205316897","body":"```java\r\nclass Solution {\r\n    public int numberOfBoomerangs(int[][] points) {\r\n        int ans = 0;\r\n        for (int[] p : points) {\r\n            Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();\r\n            for (int[] q : points) {\r\n                int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\r\n                cnt.put(dis, cnt.getOrDefault(dis, 0) + 1);\r\n            }\r\n            for (Map.Entry<Integer, Integer> entry : cnt.entrySet()) {\r\n                int m = entry.getValue();\r\n                ans += m * (m - 1);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1207195843","body":"```java\r\nclass Solution {\r\n    public int lengthOfLongestSubstring(String s) {\r\n        int ans=0;\r\n        int cur=0;\r\n        int len=s.length();\r\n        int t;\r\n        HashMap<Character,Integer> hm=new HashMap<>();\r\n        while(ans<len-cur){\r\n            t= cur;\r\n            hm.clear();\r\n            while(hm.get(s.charAt(t))==null){\r\n                hm.put(s.charAt(t),1);\r\n                t++;\r\n                if(t>=len) break;\r\n            }\r\n            ans=Math.max(ans,t-cur);\r\n            cur++;         \r\n        }               \r\n        return ans;\r\n    }\r\n}\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207196272","body":"```java\r\n\r\nclass Solution {\r\n    public List<Integer> findSubstring(String s, String[] words) {\r\n        int n = s.length(), m = words.length, w = words[0].length();\r\n        Map<String, Integer> map = new HashMap<>();\r\n        for (String word : words) map.put(word, map.getOrDefault(word, 0) + 1);\r\n        List<Integer> ans = new ArrayList<>();\r\n        out:for (int i = 0; i + m * w <= n; i++) {\r\n            Map<String, Integer> cur = new HashMap<>();\r\n            String sub = s.substring(i, i + m * w);\r\n            for (int j = 0; j < sub.length(); j += w) {\r\n                String item = sub.substring(j, j + w);\r\n                if (!map.containsKey(item)) continue out;\r\n                cur.put(item, cur.getOrDefault(item, 0) + 1);\r\n            }\r\n            if (cur.equals(map)) ans.add(i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207414108","body":"```java\r\n\r\nimport java.util.*;\r\n\r\nclass Solution {\r\n    public int solve(int[] nums, int k) {\r\n        int len = nums.length;\r\n        int res = len;\r\n        int re = 0, cur = 0;\r\n        for (int i : nums){\r\n            re = (re + i) % k;\r\n        }\r\n            \r\n        Map<Integer, Integer> hm = new HashMap<>();\r\n        hm.put(0, -1);\r\n        for (int i = 0; i < len; ++ i) {\r\n            cur = (cur + nums[i]) % k;\r\n            hm.put(cur, i);\r\n            int r = (cur - re + k) % k;\r\n            res = Math.min(res, i - hm.getOrDefault(r, -len));\r\n        }\r\n        if(res < len){\r\n            return res;\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208308589","body":"```java\r\nclass Solution {\r\n    public ListNode middleNode(ListNode head) {\r\n        ListNode node1 = head;\r\n        ListNode node2 = head;\r\n\r\n        while (node2 != null && node2.next != null) {\r\n            node1 = node1.next;\r\n            node2 = node2.next.next;\r\n        }\r\n\r\n        return node1;\r\n    }\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208411551","body":"```\r\nclass Solution {\r\n    public int removeDuplicates(int[] nums) {\r\n        int i=0;\r\n        for(int j=1;j<nums.length;j++){\r\n            if(nums[i]!=nums[j]){\r\n                i++;\r\n                nums[i]=nums[j];\r\n            }\r\n        }\r\n        return i+1;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laofuwf":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184788930","body":"```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        s = \"\"\n        for i in num:\n            s += str(i)\n            \n        answer = int(s) + k\n        \n        return  \"\".join(str(answer))\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186315034","body":"```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = deque()\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) == self.maxSize:\n            return\n        self.stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack: return -1\n        return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        stack2 = deque()\n        if k < len(self.stack):\n            for i in range(len(self.stack) - k):\n                stack2.append(self.stack.pop())\n        while self.stack:\n            stack2.append(self.stack.pop() + val)\n        while stack2:\n            self.stack.append(stack2.pop())\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186584817","body":"```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = deque()\n        count = 0\n        string = ''\n        \n        for char in s:\n            if char.isdigit():\n                count = count * 10 + int(char)\n            elif char == '[':\n                stack.append(string)\n                stack.append(count)\n                count = 0\n                string = ''\n            elif char == ']':\n                last_count = stack.pop()\n                last_string = stack.pop()\n                \n                string = last_string + last_count * string\n            else:\n                string += char\n        \n        return string\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1187778722","body":"```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = deque()\n        self.stack2 = deque()\n\n    # O(1)\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    # O(N)\n    def pop(self) -> int:\n        while len(self.stack1) > 1:\n            self.stack2.append(self.stack1.pop())\n        res = self.stack1.pop()\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n        \n        return res\n    \n    # O(N)\n    def peek(self) -> int:\n        res = -1\n        while self.stack1:\n            if len(self.stack1) == 1:\n                res = self.stack1[0]\n            self.stack2.append(self.stack1.pop())\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n        return res\n    \n    # O(1)\n    def empty(self) -> bool:\n        return len(self.stack1) == 0\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189441929","body":"```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        res = []\n        \n        for i, n in enumerate(arr):\n            maxn = n\n            while res and res[-1] > n:\n                maxn = max(maxn, res.pop())\n            res.append(maxn)\n        \n        return len(res)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190757842","body":"```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head: return head\n        count = 0\n        curr = head\n        tail = None\n        while curr:\n            if not curr.next: tail = curr\n            curr = curr.next\n            count += 1\n                \n        k = k % count\n        \n        if k == 0: return head\n        \n        curr = head\n        for i in range(k):\n            curr = curr.next\n        \n        curr2 = head\n        while curr.next:\n            curr = curr.next\n            curr2 = curr2.next\n        dummy = curr2.next\n        curr2.next = None\n        tail.next = head\n        \n        return dummy\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1191778580","body":"```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next: \n            return head\n        \n        next_node = head.next.next\n        new_head = head.next\n        new_head.next = head\n        head.next = self.swapPairs(next_node)\n        \n        return new_head\n        \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1192970594","body":"```python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head: \n            return None\n        if not head.next:\n            return TreeNode(head.val)\n        \n        # find mid node\n        slow = head\n        fast = head.next.next\n        while fast and fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        node = TreeNode(slow.next.val)\n        temp_right = slow.next.next\n        slow.next = None\n        node.right = self.sortedListToBST(temp_right)\n        node.left = self.sortedListToBST(head)\n        \n        return node\n        \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193231517","body":"```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        p1 = headA\n        p2 = headB\n        \n        swap_1 = False\n        swap_2 = False\n        \n        while p1 and p2:\n            if p1 == p2:\n                return p1\n            \n            p1 = p1.next\n            p2 = p2.next\n            \n            if not p1 and not swap_1:\n                p1 = headB\n                swap_1 = True\n            if not p2 and not swap_2:\n                p2 = headA\n                swap_2 = True\n        \n        return None\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193385407","body":"```python\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head: return head\n        \n        slow = head\n        fast = head\n        meet = None\n        # meet somewhere inside cycle if any\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                meet = slow\n                fast = head\n                break\n        # no cycle\n        if not meet: return None\n        \n        while slow != fast:\n            slow = slow.next\n            fast = fast.next\n        \n        return slow\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194493371","body":"```python\nclass ListNode:\n    def __init__(self, key, val):\n        self.key = key\n        self.val = val\n        self.next = None\n        self.prev = None\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.head = ListNode(-1, -1)\n        self.tail = ListNode(-1, -1)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        # key - node\n        self.mapping = {}\n        self.capacity = capacity\n\n    def delete(self, node):\n        prev_node = node.prev\n        next_node = node.next\n        prev_node.next = next_node\n        next_node.prev = prev_node\n        node.prev = None\n        node.next = None\n        \n        self.capacity += 1\n        del self.mapping[node.key]\n        \n    def add(self, node):\n        prev_node = self.tail.prev\n        prev_node.next = node\n        node.next = self.tail\n        self.tail.prev = node\n        node.prev = prev_node\n        \n        self.capacity -= 1\n        self.mapping[node.key] = node\n        \n    def get(self, key: int) -> int:\n        if key not in self.mapping: return -1\n        node = self.mapping[key]\n        self.delete(node)\n        self.add(node)\n        return node.val\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.mapping:\n            self.delete(self.mapping[key])\n        elif self.capacity == 0:\n            self.delete(self.head.next)\n        node = ListNode(key, value)\n        self.add(node)\n        \n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1195747599","body":"```python\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root: return 0\n        \n        left = self.maxDepth(root.left)\n        right = self.maxDepth(root.right)\n        \n        return max(left, right) + 1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197019493","body":"```python\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q: return True\n        if not p or not q: return False\n        if p.val != q.val: return False\n        \n        left_check = self.isSameTree(p.left, q.left)\n        right_check = self.isSameTree(p.right, q.right)\n        \n        return left_check and right_check\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198384862","body":"```python\nclass Solution:\n    def __init__(self):\n        self.res = 0\n    \n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        self.traverse(root, 0)\n        return self.res\n    \n    def traverse(self, node, curr_sum):\n        if not node: return\n        \n        if not node.left and not node.right:\n            self.res += curr_sum * 10 + node.val\n            return \n        \n        self.traverse(node.left, curr_sum * 10 + node.val)\n        self.traverse(node.right, curr_sum * 10 + node.val)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1199795625","body":"```python\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        # bfs\n        queue = deque()\n        queue.append(root)\n        candidate = root\n        \n        while queue:\n            count = len(queue)\n            for i in range(count):\n                node = queue.popleft()\n                if i == 0:\n                    candidate = node.val\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        \n        return candidate\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200309119","body":"```python\nclass Codec:\n    def __init__(self):\n        self.node_index = 0\n    \n    # preorder traversal\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root: return 'x,'\n        return str(root.val) + ',' + self.serialize(root.left) + self.serialize(root.right)\n        \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        data_list = data[:len(data) - 1].split(',')\n        return self.construct(data_list)\n    \n    def construct(self, data_list):\n        if self.node_index > len(data_list) - 1:\n            return None\n        \n        curr_string = data_list[self.node_index]\n        self.node_index += 1\n        \n        node = None\n        if curr_string != 'x':\n            node = TreeNode(int(curr_string))\n        else:\n            return node\n        \n        node.left = self.construct(data_list)\n        node.right = self.construct(data_list)\n        \n        return node\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200477769","body":"```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n# x > y > val\n# time: O(N + hlogh), space: O(N)\nclass Solution:\n    def __init__(self):\n        self.min_x = float('inf')\n        self.max_x = float('-inf')\n        \n    def comparator(self, node1, node2):\n        # [y, val]\n        if node1[0] != node2[0]:\n            return node1[0] - node2[0]\n        return node1[1] - node2[1]\n    \n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        if not root: return []\n        x_cord = {} # x: [y, val]\n        self.traverse(root, x_cord, 0, 0)\n        res = []\n        \n        for i in range(self.min_x, self.max_x + 1):\n            if i in x_cord:\n                curr_list = []\n                x_cord[i].sort(key=cmp_to_key(self.comparator))\n                for n in x_cord[i]:\n                    curr_list.append(n[1])\n                res.append(curr_list.copy())\n            \n        return res\n    \n    def traverse(self, node, x_cord, x, y):\n        if not node: return\n        \n        self.min_x = min(self.min_x, x)\n        self.max_x = max(self.max_x, x)\n        \n        if x not in x_cord:\n            x_cord[x] = []\n        x_cord[x].append([y, node.val])\n        \n        self.traverse(node.left, x_cord, x - 1, y + 1)\n        self.traverse(node.right, x_cord, x + 1, y + 1)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201505011","body":"```python\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        target_indices = {}\n        for i, num in enumerate(nums):\n            if num in target_indices:\n                return [target_indices[num], i]\n            target_indices[target - num] = i\n        return []\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203326585","body":"```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        pq = []\n        counter = defaultdict(int)\n        for n in nums:\n            counter[n] += 1\n        \n        for key in counter:\n            heapq.heappush(pq, (counter[key], key))\n            \n            if len(pq) > k:\n                heapq.heappop(pq)\n        \n        res = []\n        while pq:\n            res.append(heapq.heappop(pq)[1])\n        \n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204313826","body":"```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        res = 0\n        for x0, y0 in points:\n            counter = defaultdict(int)\n            for x1, y1 in points:\n                dist = abs(x1 - x0) ** 2 + abs(y1 - y0) ** 2\n                counter[dist] += 1\n            \n            for key in counter:\n                res += counter[key] * (counter[key] - 1)\n                \n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205606352","body":"```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        res = 0\n        \n        # 2 pointers\n        left = 0\n        visited = set()\n        for right in range(len(s)):\n            # found duplicates, remove until prev char until curr duplicates removed\n            while s[right] in visited:\n                visited.remove(s[left])\n                left += 1\n            visited.add(s[right])\n            res = max(res, right - left + 1)\n        \n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1206769846","body":"```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        counter = defaultdict(int)\n        res = []\n        single_length = len(words[0])\n        total_count = len(words)\n        total_words_length = total_count * single_length\n        \n        for word in words:\n            counter[word] += 1\n        \n        i = 0\n        while i + total_words_length <= len(s):\n            temp = defaultdict(int)\n            valid_count = 0\n            for j in range(i + single_length, i + total_words_length + 1, single_length):\n                temp_word = s[j - single_length:j]\n                if temp_word not in counter:\n                    break\n                temp[temp_word] += 1\n                if temp[temp_word] > counter[temp_word]:\n                    break\n                \n                valid_count += 1\n            \n            if valid_count == total_count: \n                res.append(i)\n            \n            i += 1\n        \n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207295759","body":"```python\n# prefix sum dict + <prefix sum mode k, index> dict\n\nclass Solution:\n    def solve(self, nums, k):\n        mod = 0\n        total = 0\n        for num in nums:\n            total += num\n        \n        mod = total % k\n        if mod == 0:\n            return 0\n\n        res = len(nums)\n        total = 0\n        mod_index_map = {0: -1}\n        for j in range(len(nums)):\n            total += nums[j]\n            curr_mod = total % k\n            target = (curr_mod - mod + k) % k\n            if target in mod_index_map:\n                res = min(res, j - mod_index_map[target])\n            mod_index_map[curr_mod] = j\n\n        if res == len(nums):\n            return -1\n        return res\n      \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207443046","body":"```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next: return head\n        \n        slow = head\n        fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        return slow\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208848562","body":"```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        curr_i = 0\n        \n        for n in nums:\n            if curr_i < 1 or n != nums[curr_i - 1]:\n                nums[curr_i] = n\n                curr_i += 1\n        \n        return curr_i\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/42#issuecomment-1209652085","body":"```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            \n            if target > nums[mid]:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return left\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lbc546":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184790165","body":"## Add Entire K to the first column to the right and carry over ```addend // 10``` to the next (left) column\n## Python Solution\n```\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        index = len(num) - 1\n        add = k\n        result = []\n        \n        # Iterate from right end of the array\n        while index >= 0 or add > 0:\n             # Whenever not at the end of the array, add the digit\n             if index >= 0:\n                add += num[index]\n            add, mod = divmod(add, 10)\n            result.insert(0, mod)\n            index -= 1\n        return result\n```\n## Complexity\nTime: O(n)   Space: O(n) where n is the length of the array num","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185890807","body":"## Two Pass\n## Python solution\n```\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        prev = float('-inf')\n        ans = []\n        # left\n        for i in range(len(s)):\n            if s[i] == c:\n                prev = i\n            ans.append(i - prev)\n        # right\n        prev = float('inf')\n        for i in range(len(s)-1, -1, -1):\n            if s[i] == c:\n                prev = i\n            ans[i] = min(ans[i], prev - i)\n        return ans\n```\n## Complexity\nTime: O(n)\nSpace: O(n) where n is the length of array s","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186247118","body":"## OOD with python list\n## Python solution\n```\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n\n        self.maxSize = maxSize\n        self.data = []\n        \n\n    def push(self, x):\n\n        if len(self.data) < self.maxSize:\n            self.data.append(x)\n        else:\n            pass\n        \n\n    def pop(self):\n\n        if len(self.data) == 0:\n            return -1\n        else:\n            return self.data.pop()\n        \n\n    def increment(self, k, val):\n\n        for i in range(min(len(self.data), k)):\n            self.data[i] += val\n    \n```\n## Complexity\n```push()``` O(1)\n```pop()``` O(1)\n```increment``` O(min(n, k))\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186738383","body":"## Use stack to complete the decode within each pairs of bracket, pushing the decoded string in the brackets to the stack again.\n## Python solution\n```\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        ans = \"\"\n        \n        for c in s:\n            # Not closing brackets, push into stack\n            if c != ']':\n                stack.append(c)\n            else:\n                # Otherwise, first get the characters within the brackets\n                r = \"\"\n                while stack and stack[-1] != '[':\n                    # reverse the order\n                    r = stack.pop() + r\n\n                # pop the opening bracket out\n                stack.pop()\n                \n                # get the number of times to repeat\n                n = \"\"\n                while stack and stack[-1].isnumeric():\n                    f = stack.pop()\n                    # reverse order\n                    n = f + n\n                \n                # push the cleaned and decoded string into the stack\n                stack.append(r * int(n))\n        for c in stack:\n            ans += c\n        \n        return ans\n```\n## Complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1187711286","body":"## Use two stacks to handle push\n## Python solution\n```\nclass MyQueue(object):\n\n    def __init__(self):\n        self.s1 = []\n        self.s2 = []\n\n    def push(self, x):\n        while self.s1:\n            self.s2.append(self.s1.pop())\n        self.s1.append(x)\n        while self.s2:\n            self.s1.append(self.s2.pop())\n            \n    def pop(self):\n        return self.s1.pop()\n\n    def peek(self):\n        return self.s1[-1]\n\n    def empty(self):\n        return not self.s1\n```\n## Complexity\nPush O(n) others O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189454716","body":"## Current min greater than previous high, add to stack\r\n## Python sol\r\n```\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        \"\"\"\r\n        :type arr: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n        stack = []\r\n        \r\n        stack.append((arr[0], arr[0]))\r\n        \r\n        for i in range(1, len(arr)):\r\n            low, high = arr[i], arr[i]\r\n            while stack and stack[-1][1] > low:\r\n                prev_low, prev_high = stack.pop()\r\n                low, high = min(prev_low, low), max(prev_high, high)\r\n            stack.append((low, high))\r\n        return len(stack)\r\n```\r\n## Complexity\r\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190938089","body":"## Idea\nCount total nodes and make a cycle\nUse to mod to determine the break point in the middle\n## Python Solution\n```\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return None\n        if not head.next:\n            return head\n        \n        n = 1\n        dummy = head\n        while dummy.next:\n            n += 1\n            dummy = dummy.next\n        \n        dummy.next = head\n        \n        current = head\n        for i in range(n-k % n-1):\n            current = current.next\n        \n        new = current.next\n        current.next = None\n        return new\n```\n## Complexity\nSpace: O(1)\nTime: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1191954438","body":"## Dummy node\n## Python solution\n```\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode(-1)\n        dummy.next = head\n        prev = dummy\n        while head and head.next:\n            first = head\n            second = head.next\n            \n            prev.next = second\n            first.next = second.next\n            second.next = first\n            \n            prev = first\n            head = first.next\n        return dummy.next\n```\n## Complexity\nSpace O(1)\nTime O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193046193","body":"## Idea, find mid point, break linked list into left and right part, then use recursion to build mid value node\n## Python Solution\n```\nclass Solution:\n    def findMid(self, head):\n        slow = head\n        fast = head\n        prev = None\n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        if prev:\n            prev.next = None\n        return slow\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return None\n        mid = self.findMid(head)\n        node = TreeNode(mid.val)\n        \n        if head == mid:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(mid.next)\n        return node\n```\n## Complexity\nTime O(nlogn)\nSpace O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193162405","body":"## Hashset\n## Python solution\n```\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        a = set()\n        while headA:\n            a.add(headA)\n            headA = headA.next\n        \n        while headB:\n            if headB in a:\n                return headB\n            headB = headB.next\n        return None\n```\n## Complexity\nTime: O(n)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194271897","body":"## Hash table\n## Python Solution\n```\nclass Solution(object):\n    def detectCycle(self, head):\n        visited = set()\n\n        node = head\n        while node:\n            if node in visited:\n                return node\n            else:\n                visited.add(node)\n                node = node.next\n\n        return None\n```\n## Complexity\nTime: O(n)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194972865","body":"## ä»æ¥æ²¡æ‡‚è¿‡ï¼Œé¢è¯•é‡åˆ°ä¹Ÿæ˜¯ç›´æ¥èƒŒç­”æ¡ˆ\n## Python solution\n```\nclass Node:\n    def __init__(self, k, v):\n        self.key = k\n        self.val = v\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.dic = dict()\n        self.head = Node(0, 0)\n        self.tail = Node(0, 0)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def get(self, key):\n        if key in self.dic:\n            n = self.dic[key]\n            self._remove(n)\n            self._add(n)\n            return n.val\n        return -1\n\n    def put(self, key, value):\n        if key in self.dic:\n            self._remove(self.dic[key])\n        n = Node(key, value)\n        self._add(n)\n        self.dic[key] = n\n        if len(self.dic) > self.capacity:\n            n = self.head.next\n            self._remove(n)\n            del self.dic[n.key]\n\n    def _remove(self, node):\n        p = node.prev\n        n = node.next\n        p.next = n\n        n.prev = p\n\n    def _add(self, node):\n        p = self.tail.prev\n        p.next = node\n        self.tail.prev = node\n        node.prev = p\n        node.next = self.tail\n```\n## Complexity\nTime: O(n), O(1)\nSpace: O(capacity)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1195716705","body":"## Recursion\n## Python solution\n```\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if root:\n            left = self.maxDepth(root.left)\n            right = self.maxDepth(root.right)\n            return max(left, right) + 1\n        else:\n            return 0\n```\n## Complexity\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197092113","body":"```\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not p and not q:\n            return True\n        if not p:\n            return False\n        if not q:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.right, q.right) and self.isSameTree(p.left, q.left)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198528285","body":"## Recursion\n## Python solution\n```\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        return self.sumNumbersHelper(root, 0)\n    def sumNumbersHelper(self, root, sum):\n        if not root:\n            return 0\n        sum = sum * 10 + root.val\n        if not root.left and not root.right:\n            return sum\n        return self.sumNumbersHelper(root.left, sum) + self.sumNumbersHelper(root.right, sum)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200236140","body":"## Java solution\n```\nclass Solution {\n    int max = Integer.MIN_VALUE;\n    int result;\n    public int findBottomLeftValue(TreeNode root) {\n        if (root.left == null && root.right == null) {\n            return root.val;\n        }\n        goDown(root, 0);\n        return result;\n    }\n    \n    private TreeNode goDown(TreeNode root, int level) {\n        if (root == null) {\n            return null;\n        }\n        \n        goDown(root.left, level + 1);\n        goDown(root.right, level + 1);\n        \n        if (max < level) {\n            max = level;\n            result = root.val;\n        }\n        return null;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200329542","body":"## Recursion dfs\n## Python solution\n```\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        def serial(root, s):\n            if not root:\n                s += \"None,\"\n            else:\n                s += str(root.val) + ','\n                s = serial(root.left, s)\n                s = serial(root.right, s)\n            return s\n        return serial(root, '')\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        def deserial(s):\n            if s[0] == 'None':\n                s.pop(0)\n                return None\n            root = TreeNode(s[0])\n            s.pop(0)\n            root.left = deserial(s)\n            root.right = deserial(s)\n            return root\n        data_list = data.split(',')\n        root = deserial(data_list)\n        return root\n```\n## Complexity\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200608993","body":"## DFS preorder\n##\n```\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        if not root:\n            return []\n\n        columnTable = defaultdict(list)\n        min_column = max_column = 0\n\n        def DFS(node, row, column):\n            if node is not None:\n                nonlocal min_column, max_column\n                columnTable[column].append((row, node.val))\n                min_column = min(min_column, column)\n                max_column = max(max_column, column)\n\n                DFS(node.left, row + 1, column - 1)\n                DFS(node.right, row + 1, column + 1)\n\n        DFS(root, 0, 0)\n\n        result = []\n        for col in range(min_column, max_column + 1):\n            result.append([val for row, val in sorted(columnTable[col])])\n\n        return result\n```\n## Complexity O(nlogn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201531433","body":"## Hashmap\n## Python solution\n```\nclass Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        hashmap = {}\n        for i in range(len(nums)):\n            complement = target - nums[i]\n            if complement in hashmap:\n                return [i, hashmap[complement]]\n            hashmap[nums[i]] = i\n```\n## Complexity\nTime and Space O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1202981376","body":"## Heap\n## Python soluton\n```\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        counter = Counter(nums)\n        hp = [(-counter[w], w) for w in counter]\n        heapq.heapify(hp)\n        return [heapq.heappop(hp)[1] for x in range(k)]\n```\n## Complexity\nnlogn","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204331297","body":"## hashmap with distance count\n## Python solution\n```\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ans = 0\n        for p in points:\n            cnt = defaultdict(int)\n            for q in points:\n                dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1])\n                cnt[dis] += 1\n            for count in cnt.values():\n                ans += count * (count - 1)\n        return ans\n```\n## Complexity\nO(n^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205990462","body":"## Sliding window\n## Python Solution\n```\nclass Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        count = {}\n        ans = 0\n        left = 0\n        for right in range(len(s)):\n            count[s[right]] = count.get(s[right], 0) + 1\n            if len(count) == right - left + 1:\n                ans = max(ans, right - left + 1)\n            while right - left + 1 > len(count):\n                count[s[left]] -= 1\n                if count[s[left]] == 0:\n                    del count[s[left]]\n                left += 1\n        return ans\n```\n## Complexity\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207130719","body":"## Sliding window and compare Counter\n## Python solution\n```\nclass Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        word_count = collections.Counter(words)\n        single = len(words[0])\n        all_length = len(words)\n        end = single * all_length - 1\n        start = 0\n        ans = []\n        while end < len(s):\n            current = s[start : end + 1]\n            in_window = []\n            for i in range(0, len(current), single):\n                word = current[i : i + single]\n                in_window.append(word)\n            if word_count == collections.Counter(in_window):\n                ans.append(start)\n            start += 1\n            end += 1\n        return ans\n```\n## Complexity\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207266626","body":"##åŒä½™å®šç†ï¼Œ æ²¡æœ‰æ•°ç†åŸºç¡€ï¼Œåªèƒ½ç¡¬æŠ„ç­”æ¡ˆ\n## Py sol\n```\nclass Solution:\n    def solve(self, nums, k):\n        total = (sum(nums) + k) % k\n        prefix_sum = 0\n        hashmap = {0: -1}\n        res = len(nums)\n        for i, num in enumerate(nums):\n            prefix_sum += num\n            mod = (prefix_sum + k) % k\n            hashmap[mod] = i\n            if (mod - total + k) % k in hashmap:\n                res = min(res, i - hashmap[(mod - total + k) % k])\n        return res if res != len(nums) else -1\n```\n## Complexity\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207511072","body":"## Two pointers\n## Python solution\n```\nclass Solution(object):\n    def middleNode(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n```\n## Complexity\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208544230","body":"## Two pointers\n## Python solution\n```\nclass Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0:\n            return 0\n        result = 1\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[result] = nums[i]\n                result += 1\n        return result\n```\n## Complexity\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/42#issuecomment-1209594423","body":"## Binary Search\n## Python solution\n```\nclass Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        start = 0\n        end = len(nums) - 1\n        while start <= end:\n            mid = start + (end - start) // 2\n            if nums[mid] >= target:\n                end = mid - 1\n            else:\n                start = mid + 1\n        return start\n```\n## Complexity\nO(logn)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zch-bit":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184793730","body":"## Go Solution\r\nAdd the last digit of k to the last element in `num` as `sum`, then drop the last digit of k(k=k/10); eventually, check if k is equal to zero, if not, convert it to a new array and attach the num to the end.\r\n\r\n```go\r\nfunc addToArrayForm(num []int, k int) []int {\r\n\ti := len(num) - 1\r\n\tfor i >= 0 || k > 0 {\r\n\t\tif i > 0 && k > 0 {\r\n\t\t\tsum := num[i] + k%10\r\n\t\t\tnum[i] = sum\r\n\t\t\tk = k / 10  // drop the last element of k\r\n\r\n\t\t\tif sum > 9 {\r\n\t\t\t\tnum[i] = sum % 10\r\n\t\t\t\tk++ //  add carry(1) to k\r\n\t\t\t}\r\n\t\t\ti--\r\n\t\t} else if i >= 0 {\r\n\t\t\tbreak\r\n\t\t} else {\r\n\t\t\tnum = append([]int{k % 10}, num...) \r\n\t\t}\r\n\t}\r\n\r\n\treturn num\r\n}\r\n```\r\n\r\n## Complexity: \r\nTIme: O(n)\r\nSpace: O(n) where m is the max between the length of num and k.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186121758","body":"## Day 2\r\n\r\n1. first loop: Save position of char c\r\n2. second loop: Compute the min distance between char c and other chars\r\n\r\nTime: O(n), space: O(n)\r\n\r\n```go\r\nfunc shortestToChar(s string, c byte) []int {\r\n\tvar pos []int\r\n\tfor i, ch := range s {\r\n\t\tif byte(ch) == c {\r\n\t\t\tpos = append(pos, i)\r\n\t\t}\r\n\t}\r\n\tfmt.Printf(\"%v\", pos)\r\n\r\n\tres := []int{}\r\n\tfor i, ch := range s {\r\n\t\tif byte(ch) == c {\r\n\t\t\tres = append(res, 0)\r\n\t\t} else {\r\n\t\t\tmin := math.MaxInt16\r\n\t\t\tfor _, j := range pos {\r\n\t\t\t\tif min > abs(j-i) {\r\n\t\t\t\t\tmin = abs(j - i)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tres = append(res, min)\r\n\t\t}\r\n\t}\r\n\tfmt.Printf(\"%v\", res)\r\n\treturn res\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186433869","body":"## Day 3\r\n\r\n\r\n```go\r\ntype CustomStack struct {\r\n\tstack   []int\r\n\tmaxSize int\r\n\ttop     int\r\n}\r\n\r\nfunc Constructor(maxSize int) CustomStack {\r\n\tcustomStack := CustomStack{}\r\n\tcustomStack.stack = make([]int, maxSize)\r\n\tcustomStack.maxSize = maxSize\r\n\tcustomStack.top = -1\r\n\r\n\treturn customStack\r\n}\r\n\r\n// Time: O(1)\r\nfunc (this *CustomStack) Push(x int) {\r\n\tif this.top+1 < this.maxSize {\r\n\t\tthis.top++\r\n\t\tthis.stack[this.top] = x\r\n\t}\r\n}\r\n\r\n// Time: O(1)\r\nfunc (this *CustomStack) Pop() int {\r\n\tif this.top < 0 {\r\n\t\treturn -1\r\n\t}\r\n\tx := this.stack[this.top]\r\n\tthis.top--\r\n\treturn x\r\n}\r\n\r\n// Time: O(n)\r\nfunc (this *CustomStack) Increment(k int, val int) {\r\n\tincrements := this.top + 1 // default value\r\n\tif increments > k {\r\n\t\tincrements = k\r\n\t}\r\n\r\n\tfor i := 0; i < increments; i++ {\r\n\t\tthis.stack[i] += val\r\n\t}\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186892128","body":"## Day 4\r\n\r\n```go\r\nfunc decodeString(s string) string {\r\n\tstr, _ := expand([]byte(s), 0)\r\n\treturn string(str)\r\n}\r\n\r\nfunc expand(s []byte, i int) ([]byte, int) {\r\n\tvar expanded []byte\r\n\tvar digits []byte\r\n\tfor i < len(s) && s[i] != ']' {\r\n\t\tc := s[i]\r\n\t\tif c >= 'a' && c <= 'z' {\r\n\t\t\texpanded = append(expanded, c)\r\n\t\t} else if c >= '0' && c <= '9' {\r\n\t\t\tdigits = append(digits, c)\r\n\t\t} else if c == '[' {\r\n\t\t\tnested, idx := expand(s, i+1)\r\n\t\t\tnumTimes, _ := strconv.Atoi(string(digits))\r\n\t\t\tdigits = digits[:0]\r\n\t\t\tfor numTimes > 0 {\r\n\t\t\t\texpanded = append(expanded, nested...)\r\n\t\t\t\tnumTimes--\r\n\t\t\t}\r\n\t\t\ti = idx\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\treturn expanded, i\r\n}\r\n```\r\nComplexity: Time: O(n), Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188529736","body":"## Day 5\r\n\r\n```java\r\nclass MyQueue {\r\n\r\n    /** Initialize your data structure here. */\r\n    Stack<Integer> s1;\r\n    Stack<Integer> s2;\r\n    int front;\r\n    public MyQueue() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        if(s1.isEmpty()) {\r\n            front = x;\r\n        }\r\n    \r\n        s1.add(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if(s2.isEmpty()) {\r\n            while(!s1.isEmpty()){\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        \r\n        return s2.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(!s2.isEmpty()) {\r\n            return s2.peek();\r\n        }\r\n        \r\n        return front;\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return s2.isEmpty() && s1.isEmpty();\r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190154617","body":"```go \r\nfunc maxChunksToSorted(arr []int) int {\r\n\tchunks := 0\r\n\tsortedArray := make([]int, len(arr))\r\n\tcopy(sortedArray, arr)\r\n\tsort.Ints(sortedArray)\r\n\tdiffer := make(map[int]int)\r\n\tfor i := 0; i < len(arr); i++ {\r\n\t\tdiffer[sortedArray[i]]++\r\n\t\tdiffer[arr[i]]--\r\n\t\tif differ[sortedArray[i]] == 0 {\r\n\t\t\tdelete(differ, sortedArray[i])\r\n\t\t}\r\n\t\tif differ[arr[i]] == 0 {\r\n\t\t\tdelete(differ, arr[i])\r\n\t\t}\r\n\t\tif len(differ) == 0 {\r\n\t\t\tchunks++\r\n\t\t}\r\n\t}\r\n\treturn chunks\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191091790","body":"## Day 07\r\n\r\n```go\r\nfunc rotateRight(head *ListNode, k int) *ListNode {\r\n    length := 0\r\n    tail := head\r\n    cur := head\r\n    for tail != nil && tail.Next != nil {\r\n        length++\r\n        tail = tail.Next\r\n    }\r\n    length++\r\n    \r\n    // 1,2,3,4,5->null => 1,2,3, 4(curr),5,1,2,3 ->null\r\n    for i := 0; i < length - (k % length); i++ {\r\n        if tail != nil {\r\n            tail.Next = &ListNode{ Val: cur.Val, }\r\n            tail = tail.Next\r\n            cur = cur.Next\r\n        }\r\n    }\r\n    \r\n    return cur\r\n}\r\n```\r\n\r\nTime: O(n), Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192202775","body":"## Day 8\r\n```go\r\nfunc swapPairs(head *ListNode) *ListNode {\r\n    if head == nil {\r\n        return nil\r\n    }\r\n    \r\n    return helper(head, true)\r\n}\r\n\r\nfunc helper(head *ListNode, toSwap bool) *ListNode {\r\n    if head.Next == nil {\r\n        return head\r\n    }\r\n    \r\n    if toSwap {\r\n        temp := head.Next.Val\r\n        head.Next.Val = head.Val\r\n        head.Val = temp\r\n    }\r\n    \r\n    return &ListNode{\r\n        Val: head.Val,\r\n        Next: helper(head.Next, !toSwap),\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193064281","body":"## Day 9\r\n\r\n```go\r\nfunc sortedListToBST(head *ListNode) *TreeNode {\r\n\tif head == nil {\r\n\t\treturn nil\r\n\t}\r\n\r\n\tif head.Next == nil {\r\n\t\treturn &TreeNode{head.Val, nil, nil}\r\n\t}\r\n\r\n\tvar prev *ListNode\r\n\tslow, fast := head, head\r\n\r\n\tfor fast != nil && fast.Next != nil {\r\n\t\tprev = slow\r\n\t\tslow = slow.Next\r\n\t\tfast = fast.Next.Next\r\n\t}\r\n\tprev.Next = nil               // break slow and previous node\r\n\troot := NewTreeNode(slow.Val) // set mid point as the root\r\n\r\n\troot.Left = sortedListToBST(head)\r\n\troot.Right = sortedListToBST(slow.Next)\r\n\r\n\treturn root\r\n}\r\n```\r\n\r\nTime: O(n), space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193256679","body":"## Day 10\r\n```go\r\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\r\n\tset := map[*ListNode]struct{}{}\r\n\r\n\tfor headA != nil || headB != nil {\r\n\t\tif headA != nil {\r\n\t\t\tif _, ok := set[headA]; ok {\r\n\t\t\t\treturn headA\r\n\t\t\t}\r\n\t\t\tset[headA] = struct{}{}\r\n\t\t\theadA = headA.Next\r\n\t\t}\r\n\r\n\t\tif headB != nil {\r\n\t\t\tif _, ok := set[headB]; ok {\r\n\t\t\t\treturn headB\r\n\t\t\t}\r\n\t\t\tset[headB] = struct{}{}\r\n\t\t\theadB = headB.Next\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n```\r\n\r\nTime: O(m+n), space: O(m+n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193658695","body":"## Day 11\r\n\r\n```go\r\nfunc detectCycle(head *ListNode) *ListNode {\r\n\r\n\tif head == nil || head.Next == nil {\r\n\t\treturn nil\r\n\t}\r\n\r\n\tslow, fast := head, head\r\n\r\n\tfor fast != nil && fast.Next != nil {\r\n\t\tslow = slow.Next\r\n\t\tfast = fast.Next.Next\r\n\r\n\t\tif slow == fast {\r\n\t\t\tslow = head\r\n\t\t\tfor slow != fast {\r\n\t\t\t\tslow = slow.Next\r\n\t\t\t\tfast = fast.Next\r\n\t\t\t}\r\n\t\t\treturn slow\r\n\t\t}\r\n\t}\r\n\r\n\treturn nil\r\n}\r\n```\r\n\r\nTime: O(n), Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194986937","body":"## Day 12\r\n```go\r\ntype Node struct {\r\n\tkey  int\r\n\tval  int\r\n\tprev *Node\r\n\tnext *Node\r\n}\r\n\r\ntype LRU struct {\r\n\tcap   int\r\n\tcache map[int]*Node\r\n\tleft  *Node\r\n\tright *Node\r\n}\r\n\r\nfunc NewLRU(cap int) *LRU {\r\n\tleft := &Node{key: 0, val: 0}\r\n\tright := &Node{key: 0, val: 0}\r\n\r\n\tleft.next = right\r\n\tright.prev = left\r\n\r\n\treturn &LRU{\r\n\t\tcap:   cap,\r\n\t\tcache: make(map[int]*Node),\r\n\t\tleft:  left,\r\n\t\tright: right,\r\n\t}\r\n}\r\n\r\n\r\n// Insert a new node to the right side\r\n// pre ----> NODE ----> right\r\n//     <----      <----\r\nfunc (l *LRU) insert(n *Node) {\r\n\tpre := l.right.prev\r\n\tpre.next = n\r\n\tn.next = l.right\r\n\tl.right.prev = n\r\n\tn.prev = pre\r\n}\r\n\r\nfunc (l *LRU) remove(n *Node) {\r\n\tpre, next := n.prev, n.next\r\n\tpre.next = next\r\n\tnext.prev = pre\r\n}\r\n\r\nfunc (l *LRU) Get(key int) int {\r\n\tif node, ok := l.cache[key]; ok {\r\n\t\tl.remove(node)\r\n\t\tl.insert(node)\r\n\t\tfmt.Printf(\"Find the key/val: %v, %v \\n\", key, node.val)\r\n\t\treturn node.val\r\n\t}\r\n\tfmt.Println(\"no such key =\", key)\r\n\treturn -1\r\n}\r\n\r\nfunc (l *LRU) Put(key, value int) {\r\n\t// Check existing key/value\r\n\tif node, ok := l.cache[key]; ok {\r\n\t\tfmt.Println(\"found existing key, removing node\")\r\n\t\tl.remove(node)\r\n\t}\r\n\tl.cache[key] = &Node{key: key, val: value}\r\n\tl.insert(l.cache[key])\r\n\r\n\t// Check capacity, evict lru\r\n\tif len(l.cache) > l.cap {\r\n\t\tlru := l.left.next\r\n\t\tl.remove(lru)\r\n\t\tdelete(l.cache, lru.key)\r\n\t\tfmt.Printf(\"too many node, remove lru: %v,%v \\n\", lru.key, lru.val)\r\n\t}\r\n\r\n}\r\n\r\nfunc (l *LRU) Show() {\r\n\tfor n := l.left.next; n != l.right; n = n.next {\r\n\t\tfmt.Printf(\"(%v, %v), \", n.key, n.val)\r\n\t}\r\n\tfmt.Println()\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196327653","body":"## Day 13\r\n\r\n```go\r\nfunc maxDepth(root *TreeNode) int {\r\n\tif root == nil {\r\n\t\treturn 0\r\n\t}\r\n\r\n\treturn 1 + max(maxDepth(root.Left), maxDepth(root.Right))\r\n}\r\n```\r\nTIme: O(logn), space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197738983","body":"## Day 14\r\n```go\r\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\r\n\tif p == nil && q == nil {\r\n\t\treturn true\r\n\t}\r\n\tif p == nil || q == nil {\r\n\t\treturn false\r\n\t}\r\n\tif p.Val != q.Val {\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\r\n}\r\n\r\n```\r\nTime: O(n), space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1200367222","body":"## Day 15\r\n```go\r\nfunc sumNumbers(root *TreeNode) int {\r\n\treturn dfs(root, 0)\r\n}\r\n\r\nfunc dfs(root *TreeNode, currSum int) int {\r\n\tif root == nil {\r\n\t\treturn 0\r\n\t}\r\n\r\n\tcurrSum = currSum*10 + root.Val\r\n\tif root.Left == nil && root.Right == nil {\r\n\t\treturn currSum\r\n\t}\r\n\r\n\tleftSum, rightSum := dfs(root.Left, currSum), dfs(root.Right, currSum)\r\n\r\n\treturn leftSum + rightSum\r\n}","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200095319","body":"## Day 15\r\n```go\r\nfunc sumNumbers(root *TreeNode) int {\r\n\treturn dfs(root, 0)\r\n}\r\n\r\nfunc dfs(root *TreeNode, currSum int) int {\r\n\tif root == nil {\r\n\t\treturn 0\r\n\t}\r\n\r\n\tcurrSum = currSum*10 + root.Val\r\n\tif root.Left == nil && root.Right == nil {\r\n\t\treturn currSum\r\n\t}\r\n\r\n\tleftSum, rightSum := dfs(root.Left, currSum), dfs(root.Right, currSum)\r\n\r\n\treturn leftSum + rightSum\r\n}\r\n```\r\nTIme: O(log(n), space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200366819","body":"## Day 17\r\n\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"strconv\"\r\n\t\"strings\"\r\n)\r\n\r\ntype Codec struct {\r\n\tarr []string\r\n}\r\n\r\nfunc Constructor() Codec {\r\n\treturn Codec{\r\n\t\tarr: []string{},\r\n\t}\r\n}\r\n\r\n// Serializes a tree to a single string.\r\nfunc (this *Codec) serialize(root *TreeNode) string {\r\n\tvar dfs func(root *TreeNode)\r\n\tdfs = func(root *TreeNode) {\r\n\t\tif root == nil {\r\n\t\t\tthis.arr = append(this.arr, \"nil\")\r\n\t\t\treturn\r\n\t\t}\r\n\t\tthis.arr = append(this.arr, strconv.Itoa(root.Val))\r\n\t\t\r\n\t\tdfs(root.Left)\r\n\t\tdfs(root.Right)\r\n\t}\r\n\tdfs(root)\r\n\treturn strings.Join(this.arr, \",\")\r\n}\r\n\r\n// Deserializes your encoded data to tree.\r\nfunc (this *Codec) deserialize(data string) *TreeNode {\r\n\tthis.arr = strings.Split(data, \",\")\r\n\tvar dfs func(root *TreeNode) *TreeNode\r\n\ti := 0\r\n\tdfs = func(root *TreeNode) *TreeNode {\r\n\t\tif this.arr[i] == \"nil\" {\r\n\t\t\ti++\r\n\t\t\treturn nil\r\n\t\t}\r\n\t\t\r\n\t\tval, _ := strconv.ParseInt(this.arr[i], 10, 32)\r\n\t\troot = &TreeNode{Val: int(val)}\r\n\t\ti++\r\n\t\t\r\n\t\troot.Left = dfs(root.Left)\r\n\t\troot.Right = dfs(root.Right)\r\n\t\treturn root\r\n\t}\r\n\treturn dfs(nil)\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200772355","body":"## Day 18\r\n```go\r\nimport \"sort\"\r\n\r\ntype XTreeNode struct {\r\n    t *TreeNode\r\n    X int\r\n}\r\n\r\nfunc verticalTraversal(root *TreeNode) [][]int {\r\n    if root == nil {\r\n        return [][]int{}\r\n    }\r\n    \r\n    solutions := make(map[int][]int) // X -> elems ordered by Y and X\r\n    notevaluated := []XTreeNode { XTreeNode{ root, 0} }\r\n    minX := 0\r\n    \r\n    for len(notevaluated) > 0 {\r\n        sort.Slice(notevaluated, func (i, j int) bool {\r\n            if notevaluated[i].X > notevaluated[j].X {\r\n                return false\r\n            }\r\n            if notevaluated[i].X < notevaluated[j].X {\r\n                return true\r\n            } else {\r\n                return notevaluated[i].t.Val < notevaluated[j].t.Val\r\n            }\r\n        })\r\n        evaluatenext := make([]XTreeNode, 0, len(notevaluated)*2)\r\n        for _, v := range notevaluated {\r\n            solutions[v.X] = append(solutions[v.X], v.t.Val)\r\n            if v.X < minX {\r\n                minX = v.X\r\n            }\r\n            if v.t.Left != nil {\r\n                evaluatenext = append(evaluatenext, XTreeNode{v.t.Left, v.X-1})\r\n            }\r\n            if v.t.Right != nil {\r\n                evaluatenext = append(evaluatenext, XTreeNode{v.t.Right, v.X+1})\r\n            }\r\n        }\r\n        notevaluated = evaluatenext\r\n    }\r\n    \r\n    ret := make([][]int, len(solutions))\r\n    for k, v := range solutions {\r\n        ret[k-minX] = v\r\n    }\r\n    return ret\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202123388","body":"## Day 19\r\n```go\r\nfunc twoSum(nums []int, target int) []int {\r\n\tm := make(map[int]int)\r\n\tvar result []int\r\n\tfor i, item := range nums {\r\n\t\tif j, ok := m[item]; ok {\r\n\t\t\tresult = append(result, j)\r\n\t\t\tresult = append(result, i)\r\n\t\t}\r\n\t\tm[target-item] = i\r\n\t}\r\n\treturn result\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203535747","body":"## Day 20\r\n```go\r\n// KMostElement solves Top K Frequent Elements - LeetCode 347\r\nfunc KMostElement(nums []int, k int) []int {\r\n\t// Compose frequency map\r\n\tfq := map[int]int{}\r\n\tfor _, val := range nums {\r\n\t\tif _, ok := fq[val]; !ok {\r\n\t\t\tfq[val] = 1\r\n\t\t} else {\r\n\t\t\tfq[val] = fq[val] + 1\r\n\t\t}\r\n\t}\r\n\tfmt.Printf(\"freq map=%v \\n\", fq)\r\n\r\n\t// Bucket sort index = number, value=occurrence\r\n\tbucket := make([]int, len(nums)+1)\r\n\tfor key, val := range fq {\r\n\t\tbucket[val] = key\r\n\t}\r\n\tfmt.Printf(\"bucket=%v \\n\", bucket)\r\n\r\n\t// Count and return\r\n\tvar res []int\r\n\tfor i := len(bucket) - 1; i >= 0; i-- {\r\n\t\tif bucket[i] != 0 { // Attention: check zero\r\n\t\t\tres = append(res, bucket[i])\r\n\t\t\tif len(res) >= k {\r\n\t\t\t\treturn res\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn res\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204861752","body":"## Day 20\r\n```go\r\nfunc numberOfBoomerangs(points [][]int) int {\r\n\tdist := func(i, j int) int {\r\n\t\tp1 := points[i]\r\n\t\tp2 := points[j]\r\n\t\tdx := p2[0] - p1[0]\r\n\t\tdy := p2[1] - p1[1]\r\n\t\treturn dx*dx + dy*dy\r\n\t}\r\n\r\n\tvar res int\r\n\tdists := make(map[int]int, len(points))\r\n\tfor i := 0; i < len(points); i++ {\r\n        for k := range dists {\r\n            delete(dists, k)\r\n        }\r\n\t\tfor j := 0; j < len(points); j++ {\r\n\t\t\t// No need to check if i == j here, points are unique so\r\n\t\t\t// there is no way to end up with a triplet of distance 0\r\n\t\t\tdists[dist(i, j)]++\r\n\t\t}\r\n\t\tfor _, count := range dists {\r\n\t\t\tres += count * (count - 1)\r\n\t\t}\r\n\t}\r\n\treturn res\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206172093","body":"## Day 22 \r\n```go\r\nfunc LongestSubstringWithoutRepeatingChar(str string) int {\r\n\tmaxLen := 0\r\n\tslow, fast := 0, 0\r\n\tset := map[uint8]struct{}{}\r\n\tfor fast < len(str) {\r\n\t\tfor fast < len(str) && !contains(set, str[fast]) {\r\n\t\t\tset[str[fast]] = struct{}{}\r\n\t\t\tfast = fast + 1\r\n\t\t}\r\n\t\tmaxLen = max(maxLen, len(set))\r\n\r\n\t\tdelete(set, str[slow])\r\n\t\tslow = slow + 1\r\n\t}\r\n\treturn maxLen\r\n}\r\n\r\nfunc contains(set map[uint8]struct{}, key uint8) bool {\r\n\t_, ok := set[key]\r\n\treturn ok\r\n}\r\n```\r\n\r\nTime: O(n), space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207154481","body":"## Day 23\r\n```go\r\nfunc findSubstring(s string, words []string) []int {\r\n\twordFrequency := make(map[string]int)\r\n\r\n\tfor _, word := range words {\r\n\t\twordFrequency[word]++\r\n\t}\r\n\r\n\tvar res []int\r\n\tlength := len(words[0])\r\n\tfor i := 0; i < len(s)-length*len(words)+1; i++ {\r\n\t\tseen := make(map[string]int)\r\n\r\n\t\tfor j := 0; j < len(words); j++ {\r\n\t\t\tnextIndex := i + j*length\r\n\t\t\tword := s[nextIndex : nextIndex+length]\r\n\r\n\t\t\tif _, ok := wordFrequency[word]; !ok {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tseen[word]++\r\n\r\n\t\t\tseenFrequency, _ := seen[word]\r\n\t\t\toriginFrequency, _ := wordFrequency[word]\r\n\r\n\t\t\tif seenFrequency > originFrequency {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tif j+1 == len(words) {\r\n\t\t\t\tres = append(res, i)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn res\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207341167","body":"\nfunc minSubarray(nums []int, k int) int {\n\ttotalSum := int64(0)\n\tfor _, v := range nums {\n\t\ttotalSum += int64(v)\n\t}\n\n\t// Total sum is divisible by k\n\tif totalSum%int64(k) == 0 {\n\t\treturn 0\n\t}\n\n\tm := map[int64]int{} // key: res, value: index\n\tm[0] = len(nums)\n\tminLen := len(nums)\n\tcurrent := totalSum\n\t// Check from the last element\n\tfor i := len(nums) - 1; i >= 0; i-- {\n\t\tcurrent -= int64(nums[i])\n\t\tres := current % int64(k)\n\t\tif index, exist := m[(int64(k)-res)%int64(k)]; exist {\n\t\t\tif curWidth := index - i; curWidth < minLen {\n\t\t\t\tminLen = curWidth\n\t\t\t}\n\t\t}\n\t\tm[(totalSum-res)%int64(k)] = i\n\t}\n\tif minLen == len(nums) {\n\t\treturn -1\n\t}\n\treturn minLen\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207721581","body":"## Day 25\r\n```go\r\nfunc MiddleOfLinkedList(head *listnode) *listnode {\r\n\tslow := head\r\n\tfast := head\r\n\tfor fast != nil && fast.next != nil {\r\n\t\tslow = slow.next\r\n\t\tfast = fast.next.next\r\n\t}\r\n\treturn slow\r\n}\r\n```\r\nTime: O(n), space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209031375","body":"## Day 26\r\n```go\r\nfunc removeDuplicates(nums []int) int {\r\n\tif len(nums) <= 1 {\r\n\t\treturn len(nums)\r\n\t}\r\n\tj := 0\r\n\tfor i := 0; i < len(nums); i++ {\r\n\t\tif nums[j] != nums[i] {\r\n\t\t\tj++\r\n\t\t\tnums[j] = nums[i]\r\n\t\t}\r\n\t}\r\n\tfmt.Printf(\"remove duplicates: nums=%v, res=%v\\n\", nums, nums[:j+1])\r\n\treturn j + 1 // count how many (index + 1)\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"frankelzeng":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184838625","body":"## Idea\r\nKeep in mind that string is just a list of char, then there is no need to do decimal manipulation but can simply use six-stage conversion: \r\n1. convert int list to char list\r\n2. join char list into singe word\r\n3. convert the single word to int\r\n4. add int with k\r\n5. convert the sum to string\r\n6. map string to int list\r\n## Python Code\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num_int = int(\"\".join(map(str, num)))\r\n        re = num_int + k\r\n        return list(map(int, str(re)))\r\n```\r\n## Complexity\r\nSpace: O(N)\r\nTime: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186222897","body":"## Idea\nUse to pointers to track the distance\n## Python Code\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        strlen = len(s)\n        re = [-1 for _ in range(strlen)]\n        idx_li = []\n        for i in range(strlen):\n            if s[i] == c:\n                re[i] = 0\n                idx_li.append(i)\n        le = 0\n        ri = 0\n        for i in range(len(idx_li) + 1):\n            if i == 0:\n                re[:idx_li[0]] = [x for x in range(idx_li[0],0,-1)]\n            elif i == len(idx_li):\n                ran = len(re[idx_li[len(idx_li) - 1]:])\n                re[idx_li[len(idx_li) - 1]:] = [x for x in range(ran)]\n            else:\n                curr = 0\n                le = idx_li[i - 1]\n                ri = idx_li[i]\n                while le <= ri:\n                    re[le] = re[ri] = curr\n                    le += 1\n                    ri -= 1\n                    curr += 1\n        return re\n```\n## Complexity\nSpace: O(N)\nTime: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186538783","body":"## Idea\nUse second stack to track the increment of elements\n## Python Code\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.size = maxSize\n        self.stk = []\n        self.inc = []\n\n    def push(self, x: int) -> None:\n        if len(self.stk) < self.size:\n            self.stk.append(x)\n            self.inc.append(0)\n    def pop(self) -> int:\n        if not self.stk:\n            return -1\n        if len(self.inc) > 1:\n            self.inc[-2] += self.inc[-1]\n        return self.inc.pop() + self.stk.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if self.inc:\n            idx = min(len(self.inc), k) - 1\n            self.inc[idx] += val\n```\n## Complexity\nO(1) in time and space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186765529","body":"## Idea\nUse a single stack to track the input\n## Python Code\n```python\nimport collections\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stk = collections.deque()\n        for idx,c in enumerate(s):\n            if c == ']':\n                curr = stk.pop()\n                temp = \"\"\n                while curr.isalpha():\n                    temp = curr + temp\n                    curr = stk.pop()\n                temp_num = \"\"\n                if curr == '[':\n                    curr = stk.pop()\n                # print(\"curr=\",curr)\n                while curr.isdigit():\n                    temp_num = curr + temp_num\n                    if stk and stk[-1].isdigit():\n                        curr = stk.pop()\n                    else:\n                        curr = \"\"\n                num = int(temp_num)\n                for _ in range(num):\n                    for t in temp:\n                        stk.append(t)\n            else:\n                stk.append(c)\n            # print(stk)\n        return \"\".join(list(stk))\n```\n## Complexity\nTime: O(max(k) * n)\nSpace: O(max(k) * n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189216168","body":"## Idea\nstraight forward\n## Python Code\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stk1 = []\n        self.stk2 = []\n\n    def push(self, x: int) -> None:\n        while self.stk1:\n            self.stk2.append(self.stk1.pop())\n        self.stk1.append(x)\n        while self.stk2:\n            self.stk1.append(self.stk2.pop())\n        return\n\n    def pop(self) -> int:\n        return self.stk1.pop()\n\n    def peek(self) -> int:\n        return self.stk1[-1]\n\n    def empty(self) -> bool:\n        return not self.stk1\n```\n## Complexity\nSpace: O(N) for all \nTime: O(N) for push, O(1) for pop, O(1) for peek","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190301483","body":"## Idea\nUse monotonic stack to track the largest number in each partition\n## Python Code\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for num in arr:\n            la = num\n            while stack and stack[-1] > num:\n                la = max(la, stack.pop())\n            stack.append(la)\n        return len(stack)\n```\n## Complexity\nSpace O(N)\nTime O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191520718","body":"## Idea\nTraverse the list to assign the n - k - 1 element as the new head\n## Python Code\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return None\n        last = head\n        count = 1\n        while last.next:\n            count += 1\n            last = last.next\n        if count == 1:\n            return head\n        newTail = head\n        k = k % count\n        if k == 0:\n            return head\n        for _ in range(count - k - 1):\n            newTail = newTail.next\n        newHead = newTail.next\n        newTail.next = None\n        last.next = head\n        # print(\"count=%d, newHead=%d, newTail=%d, last=%d, head=%d\" % (count, newHead.val, newTail.val, last.val, head.val))\n        return newHead\n```\n## Complexity\nSpace: O(1)\nTime: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192708685","body":"## Idea\nUse iterative and temp node\n## Python Code\n```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        node1 = ListNode(-1)\n        node1.next = head\n        prev = node1\n        while head and head.next:\n            first = head\n            second = head.next\n            prev.next = second\n            first.next = second.next\n            second.next = first\n            prev = first\n            head = first.next\n        return node1.next\n```\n## Complexity\nSpace: O(1)\nTime: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193147005","body":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return\n        if not head.next:\n            return TreeNode(head.val)\n        pre, slow, fast = None, head, head\n        while fast and fast.next:\n            pre = slow\n            slow = slow.next\n            fast = fast.next.next\n        pre.next = None\n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        return root","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193316147","body":"## Idea\nUse two pointers for iteration, move one pointer to another head.\n## Python Code\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        dummyA = headA\n        dummyB = headB\n        while headA or headB:\n            if not headA:\n                headA = dummyB\n            if not headB:\n                headB = dummyA\n            if headA == headB:\n                return headA\n            # print(\"A:\",headA.val, \"B:\",headB.val)\n            headA = headA.next\n            headB = headB.next\n        return None\n```\n## Complexity\nSpace: O(1)\nTime: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194059169","body":"## Idea\nTwo pointers and reset the fats\n## Python Code\n```python\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return None\n        slow = head\n        fast = head\n        meet = False\n        while slow and fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next if not meet else fast.next\n            if slow == fast:\n                if meet:\n                    return slow\n                else:\n                    fast = head\n                    if slow == fast:\n                        return slow\n                    meet = True\n        return None\n```\n## Complexity\nSpace: O(1)\nTime: O(N) traverse the linked list twice","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195666655","body":"```python\nfrom collections import OrderedDict\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.dic = collections.OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key not in self.dic:\n            return -1\n        p = self.dic.pop(key)\n        self.dic[key] = p\n        return p\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.dic:    \n            self.dic.pop(key)\n        else:\n            if self.capacity > 0:\n                self.capacity -= 1\n            else:\n                self.dic.popitem(last=False)\n        self.dic[key] = value\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1195791472","body":"## Idea\nUse dfs to track the maximum height\n## Python Code\n```python\nclass Solution:\n    def dfs(self, node, curr, re):\n        if not node:\n            re = max(curr, re)\n            return re\n        re = max(curr, re)\n        re_le = self.dfs(node.left, curr+1, re)\n        re_ri = self.dfs(node.right, curr+1, re)\n        return max(re_le, re_ri)\n        \n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        re = self.dfs(root, 0, 0)\n        return re\n```\n## Complexity:\nSpace O(1)\nTime O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197662250","body":"## Idea\ndfs iteration\n## Python Code:\n```python\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not q and not p:\n            return True\n        if not q or not p:\n            return False\n        if q.val != p.val:\n            return False\n        return self.isSameTree(q.left, p.left) and self.isSameTree(q.right, p.right)\n```\n## Complexity\nSpace O(1)\nTime O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199601562","body":"## Idea\nUse stack to store the string of int\n## Python Code\n```python\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        if not root: return 0\n        stk = [(root, str(root.val))]\n        res = 0\n        while stk:\n            root, s = stk.pop()\n            if not root.left and not root.right:\n                res += int(s)\n            if root.left:\n                stk.append((root.left, s+str(root.left.val)))\n            if root.right:\n                stk.append((root.right, s+str(root.right.val)))\n        return res\n```\n## Complexity\nSpace O(1)\nTime O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1199667652","body":"## Idea\nBFS, store the level in the second index of tuple when pushing into the queue\n## Python Code\n```python\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        queue = []\n        queue.append((root, 0))\n        re = [root.val, 0]\n        while queue:\n            node, dep = queue.pop(0)\n            # print(node.val, dep)\n            if dep > re[1]:\n                re = [node.val, dep]\n            if node.left:\n                queue.append((node.left, dep+1))\n            if node.right:\n                queue.append((node.right, dep+1))\n        return re[0]\n```\n## Complexity\nSpace O(N)\nTime O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200450991","body":"```python\nclass Codec:\n    def serialize(self, root):\n        if not root: return 'x'\n        return ','.join([str(root.val), self.serialize(root.left), self.serialize(root.right)])\n\n    def deserialize(self, data):\n        self.data = data\n        if self.data[0] == 'x': return None\n        node = TreeNode(self.data[:self.data.find(',')]) \n        node.left = self.deserialize(self.data[self.data.find(',')+1:])\n        node.right = self.deserialize(self.data[self.data.find(',')+1:])\n        return node\n```\n## Complexity\nSpace O(N)\nTime O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201272767","body":"```python\nclass Solution:\n    def helper(self, place, level, root, dic):\n        if not root: return\n        dic[place].append((level, root.val))\n        self.helper(place-1, level+1, root.left, dic)\n        self.helper(place+1, level+1, root.right, dic)\n        \n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        dic = defaultdict(list)\n        self.helper(0, 0, root, dic)\n        result = []\n        for i in sorted(dic.keys()):\n            temp = []\n            for j in sorted(dic[i]):\n                temp.append(j[1])\n            result.append(temp)\n        return result\n```\n## Complexity\nSpace O(N)\nTime O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202717411","body":"```python\ndef twoSum(self, nums: List[int], target: int) -> List[int]:\n        dic = {}\n        for i in range(len(nums)):\n            diff = target - nums[i]\n            if diff in dic:\n                return [dic[diff], i]\n            dic[nums[i]] = i\n        return []\n```\n## Complexity\nSpace O(N)\nTime O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203895786","body":"## Idea\nUse priority queue\n## Python Code\n```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        heap = []\n        counter = collections.Counter(nums)\n        return heapq.nsmallest(k, counter.keys(), lambda x:(-counter[x], x))\n```\n## Complexity\nSpace O(N)\nTime O(NLogN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205446076","body":"## Idea\nHashmap to store the circle\n```python\ndef numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        res = 0\n        for p in points:\n            dic = {}\n            for q in points:\n                f = p[0]-q[0]\n                s = p[1]-q[1]\n                dic[f*f + s*s] = 1 + dic.get(f*f + s*s, 0)\n            for k in dic:\n                res += dic[k] * (dic[k] -1)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206610566","body":"\n## Idea\nUse hashmap to store the maximum length\n## Python code\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        if s is None:\n            return 0\n\n        if len(s) <= 1:\n            return len(s)\n\n        charMap = dict()\n        start = 0\n        longest = 0\n        \n        for i,c in enumerate(s):\n            if c in charMap:\n                start = max(start, charMap[c]+1)\n            longest = max(longest, i-start+1)\n            charMap[c] = i\n        \n        return longest\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207226956","body":"```python\n from collections import Counter\n        from collections import defaultdict\n        c = Counter(words)\n        m = len(words)\n        n = len(words[0])\n        ret = []\n        total_length = m * n            \n   \n        #Loop over word length\n        for k in xrange(n):\n            left = k\n            subd = defaultdict(int)\n            count = 0\n            for j in xrange(k, len(s) - n + 1, n):\n                word = s[j:j+n]\n                if word in c:\n                    subd[word] += 1\n                    count += 1\n                    while subd[word] > c[word]:\n                        subd[s[left:left+n]] -= 1\n                        left += n\n                        count -= 1\n                    if count == m:\n                        ret.append(left)\n                else:\n                    left = j + n\n                    subd = defaultdict(int)\n                    count = 0\n        return ret\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208299116","body":"## Idea\nfast and slow pointer\n## Python code\n```python\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209567924","body":"```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        curr = 1\n        for i in range(1, len(nums)):\n            if nums[i - 1] == nums[i]:\n                continue\n            else:\n                nums[curr - 1] = nums[i - 1]\n                nums[curr] = nums[i]\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhaodev":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184887447","body":"**Swift Solution**\r\n\r\næ€è·¯ï¼š\r\nKä½œä¸ºä½æ•°ç´¯åŠ ç„¶åè¿›ä½\r\nä»£ç ï¼š\r\n```\r\n\r\n    func addToArrayForm(_ num: [Int], _ k: Int) -> [Int] {\r\n        if num.isEmpty { return [] }\r\n        \r\n        var k = k, ans = [Int](), i =  num.count - 1, carry = 0\r\n        while i >= 0 || k > 0 {\r\n            var sum = (i >= 0 ? num[i] : 0) + (k > 0 ? k % 10 : 0) + carry\r\n            ans.append(sum % 10)\r\n            carry = sum / 10\r\n            i -= 1\r\n            k /= 10 \r\n        }\r\n        \r\n        if carry > 0 {\r\n            ans.append(carry)\r\n        }\r\n        \r\n        return Array(ans.reversed())\r\n    }\r\n```\r\n\r\nå¤æ‚åº¦ï¼š\r\næ—¶é—´å¤æ‚åº¦ï¼š Oï¼ˆnï¼‰\r\nç©ºé—´å¤æ‚åº¦: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185867186","body":"æ€è·¯:\r\nä¸¤æ¬¡éå†ï¼š ä»å·¦å¾€å³ï¼Œä»å³å¾€å·¦ï¼›ç”¨æ•°ç»„åˆ†åˆ«è®°å½•è·ç¦»Cçš„å€¼ï¼Œç„¶åå–ä¸¤è€…ä¹‹é—´çš„æœ€å°å€¼\r\nä»£ç :\r\n\r\n```\r\n func shortestToChar(_ s: String, _ c: Character) -> [Int] {\r\n        let arr = Array(s)\r\n        let n = arr.count\r\n        var res = Array(repeating: 0, count:n)\r\n        var prev = Int.min/2\r\n        for (i, char) in arr.enumerated() {\r\n            if char == c {\r\n                prev = i\r\n            }\r\n            res[i] = i - prev\r\n        }\r\n        \r\n        prev = Int.max/2\r\n        \r\n        for (i, char) in arr.enumerated().reversed() {\r\n            if char == c {\r\n                prev = i\r\n            }\r\n            res[i] = min(res[i], prev - i)\r\n        }\r\n        \r\n        return res\r\n    }\r\n```\r\n\r\nå¤æ‚åº¦ï¼š\r\næ—¶é—´å¤æ‚åº¦ï¼š O(n) næ˜¯sçš„é•¿åº¦\r\nç©ºé—´å¤æ‚åº¦: O(n) å…¶å®å¯ä»¥ä¸ºOï¼ˆ1)ï¼Œä½†æ˜¯Swifté‡ŒæŠŠStringè½¬æ¢ä¸ºArrayæ€§èƒ½æ›´é«˜","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186418704","body":"æ€è·¯ï¼š\r\nç”¨æ•°ç»„æ¨¡æ‹Ÿä¸€ä¸ªæ ˆçš„Push(add), Pop(remove),ç„¶ååªä¿®æ”¹kä¸ªå…ƒç´ çš„å€¼(inc)\r\nä»£ç :\r\n```\r\nclass CustomStack {\r\n\r\n    let maxSize: Int\r\n    var items: [Int]\r\n    \r\n    init(_ maxSize: Int) {\r\n        self.maxSize = maxSize\r\n        self.items = [Int]()\r\n    }\r\n    \r\n    func push(_ x: Int) {\r\n        guard items.count < maxSize else { return }\r\n        items.append(x)\r\n    }\r\n    \r\n    func pop() -> Int {\r\n        if items.isEmpty { return -1 }\r\n        return items.popLast()!\r\n    }\r\n    \r\n    func increment(_ k: Int, _ val: Int) {\r\n        let maxCount = min(k, items.count)\r\n        for i in 0..<maxCount {\r\n            items[i] += val\r\n        }\r\n    }\r\n}\r\n```\r\nå¤æ‚åº¦:\r\næ—¶é—´å¤æ‚åº¦: O(n)\r\nç©ºé—´å¤æ‚åº¦: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186793893","body":"æ€è·¯: Stack\r\nä»£ç ï¼š\r\n```\r\nfunc decodeString(_ s: String) -> String {\r\n\tvar stack = [String]()\r\n\r\n\tfor char in s {\r\n\t\tif char != \"]\" {\r\n\t\t\tstack.append(String(char))\r\n\t\t} else {\r\n\t\t\tvar decoded = \"\"\r\n\r\n\t\t\twhile stack.last! != \"[\" {\r\n\t\t\t\tdecoded = stack.popLast()! + decoded\r\n\t\t\t}\r\n\t\t\tstack.popLast()\r\n\r\n\t\t\tvar k = 0\r\n\t\t\tvar offset = 1\r\n\t\t\twhile !stack.isEmpty, let digit = Int(stack.last!) {\r\n\t\t\t\tstack.popLast()\r\n\t\t\t\tk += offset * digit\r\n\t\t\t\toffset *= 10\r\n\t\t\t}\r\n\r\n\t\t\tstack.append(String(repeating: decoded, count: k))\r\n\t\t}\r\n\t}\r\n\r\n\treturn stack.joined()\r\n}\r\n```\r\nå¤æ‚åº¦:\r\nTime: O(K * N), Space: O(K * N) where K is the product of all \"k\"s and N is the number of encoded characters","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188335642","body":"æ€è·¯ï¼š ä¸¤ä¸ªæ ˆInputï¼Œ Outputï¼› Outputç”¨æ¥å­˜æ”¾æœ€ç»ˆæä¾›ç»™å¤–éƒ¨çš„æ•°æ®ï¼Œpop, empty, peek;  Inputç”¨äºæ¥æ”¶Outputçš„æ•°æ®ä»¥åŠpushæ–°å…ƒç´ ï¼Œæœ€ç»ˆå†æŠŠInputé‡Œçš„æ•°æ®å…¨éƒ¨pushå…¥Output\r\nä»£ç :\r\n```\r\nclass MyQueue {\r\n\r\n    var input: [Int] //ç”¨æˆ·ä¸´æ—¶å­˜æ”¾å’Œè½¬ç§»å…ƒç´ \r\n    var output:[Int] //å¯¹å¤–æä¾›ä¿¡æ¯ï¼Œpopï¼Œ peek, empty\r\n    \r\n    init() {\r\n        input = [Int]()\r\n        output = [Int]()\r\n    }\r\n    \r\n    func push(_ x: Int) {\r\n        // æŸ¥çœ‹outputé‡Œæœ‰æ²¡æœ‰å…ƒç´ ï¼Œæœ‰ï¼Œå°±å…¨éƒ¨pushåˆ°input\r\n        // input æ–°å¢å…ƒç´ x\r\n        // å…¨éƒ¨å†æ”¾å›ouput\r\n        while let e = output.popLast() {\r\n            input.append(e)\r\n        }\r\n        input.append(x) // åŠ å…¥æ–°å…ƒç´ ï¼Œæ­¤æ—¶xåœ¨inputçš„æ ˆé¡¶\r\n        \r\n        //æ”¾å›output\r\n        while let e = input.popLast() {\r\n            output.append(e)\r\n        }\r\n    }\r\n    \r\n    func pop() -> Int {\r\n        // ç›´æ¥æ“ä½œoutput\r\n        guard let last = output.popLast() else {\r\n            return -1\r\n        }\r\n        return last\r\n    }\r\n    \r\n    func peek() -> Int {\r\n        // outputçš„æœ€åä¸€ä¸ªå…ƒç´ å°±æ˜¯æ ˆé¡¶å…ƒç´ \r\n        if self.empty() { return -1 }\r\n        return output.last!\r\n    }\r\n    \r\n    func empty() -> Bool {\r\n        return output.isEmpty\r\n    }\r\n}\r\n```\r\nå¤æ‚åº¦ï¼š\r\næ—¶é—´å¤æ‚åº¦ï¼š Oï¼ˆnï¼‰\r\nç©ºé—´å¤æ‚åº¦: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189659902","body":"æ€è·¯ï¼šå•è°ƒæ ˆ\r\nä»£ç ï¼š\r\n```\r\nstruct Stack<T> {\r\n    var items = [T]()\r\n    \r\n    mutating func push(_ element: T) {\r\n        items.append(element)\r\n    }\r\n    \r\n    mutating func pop() -> T? {\r\n        guard self.isEmpty == false else { return nil }\r\n        return items.popLast()!\r\n    }\r\n    \r\n    func top() -> T? {\r\n        guard self.isEmpty == false else { return nil }\r\n        return items.last\r\n    }\r\n    \r\n    var count: Int {\r\n        return items.count\r\n    }\r\n    \r\n    var isEmpty: Bool {\r\n        return items.isEmpty\r\n    }\r\n}\r\n\r\nclass Solution {\r\n    func maxChunksToSorted(_ arr: [Int]) -> Int {\r\n        if arr.isEmpty { return 0 }\r\n        var stack = Stack<Int>()\r\n        stack.push(arr[0])\r\n        print(stack)\r\n        \r\n        for i in 1..<arr.count {\r\n            if arr[i] >= stack.top()! {\r\n                stack.push(arr[i])\r\n                continue\r\n            }\r\n            let temp = stack.top()\r\n            while !stack.isEmpty && arr[i] < stack.top()! {\r\n                stack.pop()\r\n            }\r\n            stack.push(temp!)\r\n        }\r\n        return stack.count\r\n    }\r\n}\r\n```\r\n\r\nå¤æ‚åº¦ï¼š\r\næ—¶é—´ï¼š O(n)\r\nç©ºé—´:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191055659","body":"æ€è·¯ï¼šå®˜æ–¹é¢˜è§£çš„æ€è·¯ï¼Œå¿«æ…¢æŒ‡é’ˆ+ æ±‚å€’æ•°ç¬¬kä¸ªèŠ‚ç‚¹\r\nä»£ç :\r\n```\r\nclass Solution {\r\n    func rotateRight(_ head: ListNode?, _ k: Int) -> ListNode? {\r\n        if head == nil { return nil }\r\n        var cur: ListNode? = head\r\n        var count = 0\r\n        while cur != nil {\r\n            count += 1\r\n            cur = cur?.next\r\n        }\r\n        var k = k % count\r\n        print(\"k is \\(k) and count is \\(count)\")\r\n        var slow: ListNode? = head\r\n        var fast: ListNode? = head\r\n        \r\n        while fast?.next != nil {\r\n            k -= 1\r\n            if k < 0 {\r\n                slow = slow?.next\r\n            }\r\n            fast = fast?.next\r\n        }\r\n        \r\n        fast?.next = head\r\n        let res: ListNode? = slow?.next\r\n        slow?.next = nil\r\n        \r\n        return res\r\n    }\r\n}\r\n```\r\nå¤æ‚åº¦:\r\næ—¶é—´: O(n)\r\nç©ºé—´: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192183692","body":"æ€è·¯: çœ‹å®Œå®˜æ–¹é¢˜è§£åå‹‰å¼ºåšå‡ºæ¥\r\nä»£ç :\r\n```\r\npublic ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next == null) return head;\r\n        ListNode dummy = new ListNode(-1);\r\n        ListNode cur = dummy;\r\n        dummy.next = head;\r\n        \r\n        while(cur.next != null && cur.next.next != null) {\r\n            ListNode first = cur.next;\r\n            ListNode second = cur.next.next;\r\n            cur.next = second;\r\n            first.next = second.next;\r\n            second.next = first;\r\n            cur = cur.next.next;\r\n        }\r\n        return dummy.next;\r\n    }\r\n```\r\nå¤æ‚åº¦ï¼š\r\næ—¶é—´å¤æ‚åº¦: O(n)\r\nç©ºé—´å¤æ‚åº¦: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193011217","body":"æ€è·¯ï¼šæœ‰åºé“¾è¡¨->æ•°ç»„->åˆ©ç”¨BSTç‰¹æ€§ + äºŒåˆ†æ³•æ„å»º\r\nä»£ç ï¼š\r\n```\r\nclass Solution {\r\n    func sortedListToBST(_ head: ListNode?) -> TreeNode? {\r\n        let nums = toArray(head)\r\n        guard let nums = nums else { return nil }\r\n        \r\n        return buildBST(nums, 0, nums.count - 1)\r\n    }\r\n    \r\n    private func buildBST(_ nums: [Int], _ left: Int, _ right: Int) -> TreeNode? {\r\n        if nums.isEmpty { return nil }\r\n        if left > right { return nil }\r\n        let mid = left + (right - left) / 2\r\n        var root = TreeNode(nums[mid])\r\n        root.left = buildBST(nums, left, mid - 1)\r\n        root.right = buildBST(nums, mid + 1, right)\r\n        return root\r\n    }\r\n    \r\n    private func toArray(_ head: ListNode?) -> [Int]? {\r\n        if head == nil { return nil }\r\n        var nums = [Int]()\r\n        var cur = head\r\n        while cur != nil {\r\n            nums.append(cur!.val)\r\n            cur = cur?.next\r\n        }\r\n        return nums\r\n    }\r\n}\r\n```\r\nå¤æ‚åº¦åˆ†æï¼š\r\næ—¶é—´å¤æ‚åº¦ï¼š Oï¼ˆnï¼‰\r\nç©ºé—´å¤æ‚åº¦: O(logn) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193252238","body":"æ€è·¯ï¼šåŒæŒ‡é’ˆ\r\nä»£ç ï¼š\r\n```\r\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if(headA == null || headB == null) return null;\r\n        ListNode a = headA;\r\n        ListNode b = headB;\r\n        \r\n        while(a != b) {\r\n            a = a == null ? headB : a.next;\r\n            b = b == null ? headA : b.next;\r\n        }\r\n        return a;\r\n    }\r\n```\r\nå¤æ‚åº¦ï¼š \r\næ—¶é—´ï¼šO(n)\r\nç©ºé—´: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194148813","body":"æ€è·¯:å¿«æ…¢æŒ‡é’ˆ\r\nä»£ç ï¼š\r\n```\r\nfunc detectCycle(_ head: ListNode?) -> ListNode? {\r\n        if head == nil { return nil }\r\n        var slow = head\r\n        var fast = head\r\n        \r\n        while(fast != nil && fast!.next != nil) {\r\n            fast = fast?.next?.next\r\n            slow = slow?.next\r\n            \r\n            if(slow === fast) {\r\n                break\r\n            }\r\n        }\r\n        if fast == nil || fast!.next == nil { return nil } \r\n        fast = head\r\n        while( slow !== fast) {\r\n            fast = fast?.next\r\n            slow = slow?.next\r\n        }\r\n        return slow\r\n    }\r\n```\r\næ—¶é—´: O(n)\r\nç©ºé—´:O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196035276","body":"æ€è·¯ï¼šDFS\r\nä»£ç ï¼š\r\n```\r\nclass Solution {\r\n    func maxDepth(_ root: TreeNode?) -> Int {\r\n        guard let root = root else { return 0 }\r\n        let leftHeight = maxDepth(root.left)\r\n        let rightHeight = maxDepth(root.right)\r\n        \r\n        return 1 + max(leftHeight, rightHeight)\r\n    }\r\n}\r\n```\r\næ—¶é—´ï¼š Oï¼ˆnï¼‰\r\nç©ºé—´ï¼šO(log n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197350759","body":"æ€è·¯ï¼šå¯¹æ¯”ä¸¤ä¸ªç»“ç‚¹å€¼æ˜¯å¦ç›¸ç­‰ï¼Œå¦‚æœç›¸ç­‰ï¼Œåœ¨é€’å½’æ¯”è¾ƒä¸¤ä¸ªç»“ç‚¹çš„å·¦å­æ ‘å’Œå³å­æ ‘ï¼›ç©ºæ ‘æ˜¯ç›¸ç­‰çš„\r\nä»£ç ï¼š\r\n```\r\n    func isSameTree(_ p: TreeNode?, _ q: TreeNode?) -> Bool {\r\n        // å¯¹æ¯”æ¯ä¸ªç»“ç‚¹çš„å€¼æ˜¯ä¸æ˜¯ç›¸ç­‰ï¼› ä¸¤ä¸ªç©ºæ ‘æ˜¯ç›¸ç­‰çš„\r\n        if p == nil && q == nil { return true }\r\n        if p == nil || q == nil { return false }\r\n        if p?.val == q?.val {\r\n            return isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)    \r\n        }\r\n        return false\r\n    }\r\n```\r\n\r\næ—¶é—´å¤æ‚åº¦ï¼š Oï¼ˆnï¼‰\r\nç©ºé—´å¤æ‚åº¦ï¼š Oï¼ˆnï¼‰","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198614635","body":"æ€è·¯ï¼š æ±‚ä»æ ¹åˆ°å¶å­çš„è·¯å¾„ä¹‹å’Œï¼Œé‚£æˆ‘ä»¬åªéœ€è¦æŠŠæ¯æ¡æ ¹åˆ°å¶å­çš„è·¯å¾„æ‰¾å‡ºæ¥ï¼Œå¹¶æ±‚å’Œå³å¯ -ã€‹ DFS\r\nä»£ç ï¼š\r\n```\r\nclass Solution {\r\n    var sum = 0\r\n    \r\n    func sumNumbers(_ root: TreeNode?) -> Int {\r\n        if root == nil { return sum }     \r\n        dfs(root, 0)\r\n        return sum\r\n    }\r\n    \r\n    private func dfs(_ node: TreeNode? , _ levelSum: Int) {\r\n        guard let node = node else { return }\r\n        if node.left == nil && node.right == nil { \r\n            // éå†åˆ°è¯¥ç»“ç‚¹æ²¡æœ‰å­ç»“ç‚¹è¯´æ˜åˆ°åº•äº†ï¼Œé‚£ä¹ˆå°±æŠŠç´¯è®¡çš„è·¯å¾„ååŠ å…¥åˆ°sum\r\n            sum += levelSum * 10 + node.val\r\n            return\r\n        }\r\n        dfs(node.left, levelSum * 10 + node.val)  // ç»§ç»­éå†å·¦ç»“ç‚¹ï¼ŒåŒæ—¶æŠŠå½“å‰å±‚ç´¯è®¡çš„å’Œç»§ç»­ä¼ ä¸‹å»\r\n        dfs(node.right, levelSum * 10 + node.val) // ç»§ç»­éå†å³ç»“ç‚¹ï¼ŒåŒæ—¶æŠŠå½“å‰å±‚ç´¯è®¡çš„å’Œç»§ç»­ä¼ ä¸‹å»\r\n    }\r\n}\r\n```\r\nTime: O(N)\r\nSpace: O(h) hä¸ºæ ‘çš„é«˜åº¦","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200237869","body":"æ€è·¯:BFS\r\nä»£ç :\r\n```\r\n   func findBottomLeftValue(_ root: TreeNode?) -> Int {\r\n        var currentLevel = [TreeNode]()\r\n        var nextLevel = [TreeNode]()\r\n        var nextFirstNodeVal = root!.val\r\n        \r\n        currentLevel.append(root!)\r\n        \r\n        while currentLevel.count > 0 {\r\n            var currNode = currentLevel.removeFirst()\r\n            if let left = currNode.left {\r\n                nextLevel.append(left)\r\n            }\r\n            if let right = currNode.right {\r\n                nextLevel.append(right)\r\n            }\r\n            if currentLevel.count == 0 {\r\n                currentLevel = nextLevel\r\n                if nextLevel.count > 0 { nextFirstNodeVal = nextLevel[0].val }\r\n                nextLevel = []\r\n            }\r\n        }\r\n        return nextFirstNodeVal\r\n    }\r\n}\r\n```\r\nTime complexity: O(n)\r\nSpace complexity: O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201479202","body":"æ€è·¯: å“ˆå¸Œè¡¨\r\nä»£ç :\r\n```\r\n    func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\r\n        if nums.isEmpty { return [] }\r\n        var numMap = [Int: Int]()\r\n        for i in 0..<nums.count {\r\n            let remain = target - nums[i]\r\n            if let remainKey = numMap[remain] {\r\n                return [i, remainKey]\r\n            } else {\r\n                numMap[nums[i]] = i\r\n            }\r\n        }\r\n        return []\r\n    }\r\n```\r\nT: O(n)\r\nS: O(n) as we use an extra map to store the keys","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203336647","body":"æ€è·¯ï¼šå“ˆå¸Œè¡¨ï¼Œç„¶åå–å‡ºå‰Kå¤§çš„å…ƒç´ \r\nä»£ç ï¼š\r\n```\r\n    func topKFrequent(_ nums: [Int], _ k: Int) -> [Int] {\r\n        var freqMap = [Int: Int]()\r\n        for i in 0..<nums.count {\r\n            freqMap[nums[i], default: 0] += 1\r\n        }\r\n        var keyArray = freqMap.sorted { $0.value > $1.value }.map { $0.key }\r\n        return Array(keyArray[0..<k])\r\n    }\r\n```\r\nTime: O(nlogk)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204369017","body":"æ€è·¯ï¼šå›ºå®šä¸€ä¸ªç‚¹ï¼Œç„¶åå»éå†æ¯ä¸ªç‚¹ï¼ŒæŠŠè·ç¦»ç›¸åŒçš„ç‚¹è®°å½•åˆ°å“ˆå¸Œè¡¨\r\n```\r\nclass Solution {\r\n    func numberOfBoomerangs(_ points: [[Int]]) -> Int {\r\n        if points.isEmpty { return 0 }\r\n        var result = 0\r\n        var dicts = [Int: Int]()\r\n        \r\n        for i in 0..<points.count {\r\n            \r\n            for j in 0..<points.count {\r\n                if samePonit(points[i], points[j]) {\r\n                    continue\r\n                }\r\n                let distance = distanceOfTwoPoints(points[i], points[j])\r\n                \r\n                if let d = dicts[distance] {\r\n                    result += d\r\n                    dicts[distance] = d + 1\r\n                } else {\r\n                    dicts[distance] = 1\r\n                }\r\n            }\r\n            dicts.removeAll()\r\n        }\r\n        \r\n        return result * 2\r\n    }\r\n    \r\n    private func samePonit(_ a: [Int], _ b: [Int]) -> Bool {\r\n        return a[0] == b[0] && a[1] == b[1]\r\n    }\r\n    \r\n    private func distanceOfTwoPoints(_ a: [Int], _ b: [Int]) -> Int {\r\n        let x1 = b[0] - a[0]\r\n        let y1 = b[1] - a[1]\r\n        return x1 * x1 + y1 * y1\r\n    }\r\n}\r\n```\r\nT: O(n * n)\r\nS: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205650408","body":"æ€è·¯ï¼šæ»‘åŠ¨çª—å£ + HashMap\r\n ```\r\nfunc lengthOfLongestSubstring(_ s: String) -> Int {\r\n        if s.isEmpty { return 0 }\r\n        let s = Array(s)\r\n        let count = s.count\r\n        \r\n        var left = 0, right = 0, maxlen = 0\r\n        var dict = [Character: Int]()\r\n        \r\n        while right < count {\r\n            let c = s[right]\r\n            if let position = dict[c], position >= left && position <= right {\r\n                left = position + 1\r\n            }\r\n            dict[c] = right\r\n            maxlen = max(maxlen, right - left + 1)\r\n            right += 1\r\n        }\r\n        \r\n        return maxlen\r\n  }\r\n```\r\nTC: O(n)\r\nSC: O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207444083","body":"æ€è·¯ï¼šå¿«æ…¢æŒ‡é’ˆï¼Œå¿«æŒ‡é’ˆæ¯æ¬¡èµ°ä¸¤æ­¥ï¼Œæ…¢æŒ‡é’ˆæ¯æ¬¡èµ°ä¸€æ­¥ï¼›å¦‚æœå¿«æŒ‡é’ˆèµ°åˆ°åº•ï¼Œå°±ç»“æŸå¾ªç¯\r\nä»£ç ï¼š\r\n```\r\n    func middleNode(_ head: ListNode?) -> ListNode? {\r\n        var slow = head, fast = head\r\n        while fast != nil && fast?.next != nil {\r\n            slow = slow?.next\r\n            fast = fast?.next?.next\r\n        }\r\n        return slow\r\n    }\r\n```\r\nTC: O(n)\r\nSC: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209621697","body":"åŒæŒ‡é’ˆ\r\n```\r\npublic int removeDuplicates(int[] nums) {\r\n        if(nums == null || nums.length == 0) return 0;\r\n        int start = 0;\r\n        for(int j = 1; j < nums.length; j++) {\r\n            if(nums[start] != nums[j]) {\r\n                start++;\r\n                nums[start] = nums[j];\r\n            }\r\n        }\r\n        return start + 1;\r\n    }\r\n```\r\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\r\n\r\nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/42#issuecomment-1210021174","body":"æ€è·¯ï¼šbinary search    \r\n```\r\nfunc searchInsert(_ nums: [Int], _ target: Int) -> Int {\r\n        if nums.isEmpty { return -1 }\r\n        var start = 0\r\n        var end = nums.count - 1\r\n        while start <= end {\r\n            let mid = start + (end - start) / 2\r\n            if nums[mid] == target {\r\n                return mid\r\n            } else if nums[mid] > target {\r\n                end = mid - 1\r\n            } else {\r\n                start = mid + 1\r\n            }\r\n        }\r\n        return start\r\n    }\r\n```\r\nTC: O(logN)\r\nSC: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joeymoso":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184914351","body":"```python3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n\r\n        idx = len(num) - 1\r\n        while k > 0 and idx >= 0:\r\n            if num[idx] + k % 10 < 10:\r\n                num[idx] = num[idx] + k % 10\r\n                k //= 10\r\n            else:\r\n                num[idx] = (num[idx] + k % 10) % 10\r\n                k //= 10\r\n                k += 1\r\n            idx -= 1\r\n        while k:\r\n            if idx < 0:\r\n                num = [k % 10] + num\r\n                k //= 10\r\n            else:\r\n                if num[idx] + k % 10 < 10:\r\n                    num[idx] += k % 10\r\n                    k //= 10\r\n                else:\r\n                    num[idx] = 0\r\n                    k //= 10\r\n                    k += 1\r\n                idx -= 1\r\n            \r\n\r\n        return num\r\n```\r\n\r\n* Time: O(n)\r\n* Space: O(n)\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186447070","body":"```python3\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.max_size = maxSize\r\n        self.cur_size = 0\r\n        self.stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cur_size == self.max_size:\r\n            return\r\n        self.stack.append(x)\r\n        self.cur_size += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.cur_size == 0:\r\n            return -1\r\n        self.cur_size -= 1\r\n        return self.stack.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(0, min(k, self.cur_size)):\r\n            self.stack[i] += val\r\n\r\n```\r\n\r\n* Time: O(n)\r\n* Space: O()n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186607379","body":"```python3\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        \r\n        stack = []\r\n\r\n        for c in s:\r\n            if c == ']':\r\n                cur_str = ''\r\n                cur_count = ''\r\n                # get repeat string\r\n                while stack and stack[-1] != '[':\r\n                    cur_str = stack.pop() + cur_str\r\n                # pop '['\r\n                stack.pop()\r\n                # get repeat count\r\n                while stack and stack[-1].isnumeric():\r\n                    cur_count = stack.pop() + cur_count\r\n                # push back to the stack\r\n                stack.append(int(cur_count) * cur_str)\r\n            \r\n            else:\r\n                stack.append(c)\r\n\r\n        return ''.join(stack)\r\n```\r\n\r\n* Time: O(n)\r\n* Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188297075","body":"Two stacks to implement a queue. \r\n\r\n```python3\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.push_stack = []\r\n        self.pop_stack = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        while self.pop_stack:\r\n            self.push_stack.append(self.pop_stack.pop())\r\n\r\n        self.push_stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        while self.push_stack:\r\n            self.pop_stack.append(self.push_stack.pop())\r\n        return self.pop_stack.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        while self.push_stack:\r\n            self.pop_stack.append(self.push_stack.pop())\r\n        return self.pop_stack[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return len(self.pop_stack) + len(self.push_stack) == 0\r\n\r\n```\r\n\r\n* Time: O(n)\r\n* Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189680587","body":"monostack\r\n\r\n```python3\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        monostack = []\r\n\r\n        # max(current chunk) <= min(next chunk) \r\n\r\n        for n in arr:\r\n            if not monostack or monostack[-1] <= n:\r\n                # new chunk\r\n                monostack.append(n)\r\n            else:\r\n                maxx = monostack.pop()\r\n                while monostack and monostack[-1] > n:\r\n                    monostack.pop()\r\n                monostack.append(maxx)\r\n\r\n        return len(monostack)\r\n```\r\n\r\nTime: O(N)\r\nSpace: O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1192975790","body":"* D&C\r\n* Fast slow pointer to find median\r\n\r\n```python3\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n\r\n        def get_median(left, right):\r\n            fast = slow = left\r\n            while fast != right and fast.next != right:\r\n                fast = fast.next.next\r\n                slow = slow.next\r\n            return slow\r\n\r\n\r\n        def build_tree(left: ListNode, right: ListNode) -> TreeNode:\r\n            if left == right:\r\n                return None\r\n            mid = get_median(left, right)\r\n            root = TreeNode(mid.val)\r\n            root.left = build_tree(left, mid)\r\n            root.right = build_tree(mid.next, right)\r\n            return root\r\n\r\n        return build_tree(head, None)\r\n\r\n```\r\n\r\n* Time: O(nlogn)\r\n* Space: O(logn)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193283271","body":"* Len(A) + Len(B) = Len(B) + Len(A)\r\n* while loop will stop \r\n   * if:\r\n        * Find insection\r\n    * else:\r\n        * Reaches the end of A+B and B+A\r\n```python3\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        cur_A, cur_B = headA, headB\r\n        while cur_A != cur_B:\r\n            if not cur_A:\r\n                cur_A = headB\r\n            else:\r\n                cur_A = cur_A.next\r\n            if not cur_B:\r\n                cur_B = headA\r\n            else:\r\n                cur_B = cur_B.next\r\n        return cur_A\r\n```\r\n* Time: O(N)\r\n* Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193750016","body":"Fast slow pointers\r\n\r\n```python3\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        \r\n        fast, slow = head, head\r\n        \r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            if fast == slow:\r\n                break\r\n                \r\n        if not fast or not fast.next:\r\n            return None\r\n        \r\n        fast = head\r\n        while fast != slow:\r\n            fast = fast.next\r\n            slow = slow.next\r\n        return fast\r\n```\r\n\r\n* Time: O(N)\r\n* Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195120679","body":"```python3\r\nclass Node:\r\n    def __init__(self, k, v):\r\n        self.key = k\r\n        self.val = v\r\n        self.prev = None\r\n        self.next = None\r\n\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.size = 0\r\n        self.head = Node(0, 0)\r\n        self.tail = Node(0, 0)\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n        self.data = {}\r\n\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.data:\r\n            node = self.data[key]\r\n            self.remove(node)\r\n            self.append(node)\r\n            return node.val\r\n        else:\r\n            return -1\r\n\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.data:\r\n            node = self.data[key]\r\n            self.remove(node)\r\n            self.append(node)\r\n            node.val = value\r\n        else:\r\n            node = Node(key, value)\r\n            self.data[key] = node\r\n            if self.size < self.capacity:\r\n                self.size += 1\r\n            else:\r\n                key = self.removeTail()\r\n                del self.data[key]\r\n            self.append(node)   \r\n\r\n    def remove(self, node: Node) -> None:\r\n        prev = node.prev\r\n        next = node.next\r\n        prev.next = next\r\n        next.prev = prev\r\n\r\n    def append(self, node: Node) -> None:\r\n        first = self.head.next\r\n        self.head.next = node\r\n        node.prev = self.head\r\n        node.next = first\r\n        first.prev = node\r\n\r\n\r\n    def removeTail(self) -> int:\r\n        key = self.tail.prev.key\r\n        self.remove(self.tail.prev)\r\n        return key\r\n```\r\n\r\n* Time: O(1)\r\n* Space: O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198683175","body":"* DFS\r\n\r\n```python\r\nclass Solution:\r\n    def sumNumbers(self, root: TreeNode) -> int:\r\n\r\n        def dfs(root, cur):\r\n            if not root: \r\n                return 0\r\n            if not root.left and not root.right: \r\n                return cur * 10 + root.val\r\n            return dfs(root.left, cur * 10 + root.val) + dfs(root.right, cur * 10 + root.val)\r\n        return dfs(root, 0)\r\n\r\n```\r\n\r\nTime: O(N)\r\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1199991119","body":"* dfs\r\n\r\n```python3\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def __init__(self):\r\n        self.ans = 0\r\n        self.max_depth = 0\r\n\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        self.ans = root.val\r\n        \r\n        def dfs(root, cur_depth):\r\n            if not root:\r\n                return\r\n            if cur_depth > self.max_depth:\r\n                self.ans = root.val\r\n                self.max_depth = cur_depth\r\n            dfs(root.left, cur_depth + 1)\r\n            dfs(root.right, cur_depth + 1)\r\n\r\n        dfs(root, 0)\r\n\r\n        return self.ans\r\n ```\r\n\r\n* Time: O(N)\r\n* Space: O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200480231","body":"```python3\r\nclass Solution:\r\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\r\n        # dictionary to store the coordinates of nodes \r\n        dic=collections.defaultdict(list)\r\n        # node, col, row\r\n        queue = collections.deque([[root, 0, 0]])\r\n        \r\n        # bfs\r\n        while queue:\r\n            node, c, r = queue.popleft()\r\n            dic[(c, r)].append(node.val)\r\n            if node.left:\r\n                queue.append([node.left, c - 1, r + 1])\r\n            if node.right:\r\n                queue.append([node.right, c + 1, r + 1])\r\n                \r\n         # sort\r\n        ans, temp = [], []\r\n        currentCol = None\r\n        for j, i in sorted(dic.keys()):\r\n            if j != currentCol:\r\n                ans.append(temp)\r\n                temp = []\r\n                currentCol = j\r\n            temp.extend(sorted(dic[(j, i)]))\r\n        ans.append(temp)\r\n        return ans[1:]\r\n```\r\n\r\n* Time: O(NlogN)\r\n* Space: O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203530136","body":"```python3\r\nfrom collections import defaultdict\r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n\r\n        ans = []\r\n        dic = defaultdict(int)\r\n\r\n        for i in nums:\r\n            dic[i] += 1\r\n\r\n        for key, val in dic.items():\r\n            if len(ans) < k:\r\n                heapq.heappush(ans, [val,key])\r\n            else:\r\n                heapq.heappushpop(ans, [val,key])\r\n        return [j for i, j in ans]\r\n```\r\n\r\n* Time: O(nlogn)\r\n* Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204869747","body":"```python3\r\nclass Solution:\r\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\r\n\r\n        ans = 0\r\n\r\n        for p in points:\r\n            dic = defaultdict(int)\r\n            for i in points:\r\n                dis = (p[0] - i[0]) ** 2 + (p[1] - i[1]) ** 2\r\n                dic[dis] += 1\r\n\r\n            for d in dic.values():\r\n                ans += d * (d - 1)\r\n\r\n        return ans\r\n```\r\n* Time: O(N^2)\r\n* Space: O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1206842104","body":"```python3\r\nclass Solution:\r\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\r\n\r\n        window = len(words[0]) * len(words)\r\n\r\n        target = Counter(words)\r\n        i = 0\r\n        res = []\r\n        while i < len(s) - window + 1:\r\n            cut = []\r\n            start = i\r\n            for _ in range(len(words)):\r\n                cut.append(s[start:start + len(words[0])])\r\n                start += len(words[0])\r\n            if Counter(cut) == target:\r\n                res.append(i)\r\n            i += 1\r\n\r\n        return res\r\n\r\n```\r\n\r\n* Time: O(mnk) m = len(s)  n = len(words) k = len(words[0])\r\n* Space: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hackbl":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184950463","body":"```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        \r\n        for (int i = num.length-1; i >= 0; i--) {\r\n            int curr = k%10 + num[i];\r\n            k /= 10;\r\n            \r\n            if (curr >= 10) {\r\n                k += 1;\r\n            }\r\n            \r\n            res.add(0, curr%10); \r\n        }\r\n        \r\n        while (k > 0) {\r\n            res.add(0, k%10);\r\n            k /= 10;\r\n        }\r\n        \r\n        \r\n        return res;\r\n    }\r\n}\r\n```\r\n* Time: O(n)\r\n* Space: O(n)\r\n* Where n is Max(num.length, k.length)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185869150","body":"å·¦å³éå†\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len];\r\n        int curr = len;\r\n        \r\n        for (int i = 0; i < len; i++) {\r\n            if (s.charAt(i) == c) {\r\n                res[i] = 0;\r\n                curr = i;\r\n            } else {\r\n                res[i] = Math.min(len, Math.abs(i-curr));\r\n            }\r\n        }\r\n        \r\n        for (int i = len-1; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                curr = i;\r\n            } else {\r\n                res[i] = Math.min(res[i], Math.abs(curr-i));\r\n            }\r\n            \r\n        }\r\n               \r\n        return res;\r\n    }\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186755547","body":"åˆ¤æ–­å‡ ç§å¯èƒ½æ€§ï¼Œå¯¹ä¸åŒå¯èƒ½æ€§è¿›è¡Œå•ç‹¬åˆ¤æ–­\r\n```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        StringBuilder res = new StringBuilder();\r\n        \r\n        Stack<String> sbStack = new Stack<>();\r\n        Stack<Integer> digitStack = new Stack<>();\r\n        int idx = 0;\r\n        while (idx < s.length()) {\r\n            char c = s.charAt(idx);\r\n            if (Character.isDigit(c)) {\r\n                int freq = 0;\r\n                while(Character.isDigit(s.charAt(idx))) {\r\n                    freq = freq * 10 + s.charAt(idx) - '0';\r\n                    idx++;\r\n                }\r\n                \r\n                digitStack.push(freq);\r\n            } else if (c == '[') {\r\n                sbStack.push(res.toString());\r\n                res = new StringBuilder();\r\n                idx++;\r\n            } else if (c == ']') {\r\n                StringBuilder tmp = new StringBuilder();\r\n                tmp.append(sbStack.pop());\r\n                \r\n                int freq = digitStack.pop();\r\n                \r\n                for (int j = 0; j < freq; j++) {\r\n                    tmp.append(res.toString());\r\n                }\r\n                \r\n                res = tmp;\r\n                idx++;\r\n            } else {\r\n                res.append(c);\r\n                idx++;\r\n            }\r\n        }\r\n                      \r\n        return res.toString();\r\n    }\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1187947131","body":"2ä¸ªstackï¼Œä¸€è¿›ä¸€å‡ºæ€è·¯\r\n```\r\nclass MyQueue {\r\n    private Stack<Integer> inStack = new Stack<>(); \r\n    private Stack<Integer> outStack = new Stack<>();\r\n\r\n    public MyQueue() {\r\n        \r\n    }\r\n    \r\n    public void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (empty()) return -1;\r\n        \r\n        if (outStack.isEmpty()) {\r\n            move();\r\n        }\r\n        \r\n        return outStack.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (empty()) return -1;\r\n        \r\n        if (outStack.isEmpty()) {\r\n            move();\r\n        }\r\n        \r\n        return outStack.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return inStack.isEmpty() && outStack.isEmpty();\r\n    }\r\n    \r\n    public void move() {\r\n        while (!inStack.isEmpty()) {\r\n            outStack.push(inStack.pop());\r\n        }\r\n    }\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189780663","body":"```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int res = 0;\r\n        \r\n        Deque<Integer> deque = new ArrayDeque<>();\r\n        \r\n        for (int num: arr) {\r\n            int largest = num;\r\n            while (!deque.isEmpty() && num < deque.peekFirst()) {\r\n                largest = Math.max(largest, deque.pollFirst());\r\n            }\r\n            \r\n            deque.offerFirst(largest);\r\n        }\r\n        \r\n        return deque.size();\r\n    }\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190592750","body":"å…ˆå¯¹kè¿›è¡Œç®€åŒ–ï¼Œä½¿k <= list.length\r\nå…¶æ¬¡è¿›è¡Œrotation\r\n```\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null) return null;\r\n        \r\n        int count = 1;\r\n        ListNode tail = head;\r\n        \r\n        while (tail.next != null) {\r\n            count++;\r\n            tail = tail.next;\r\n        }\r\n        \r\n        k %= count;\r\n        if (k == 0) return head;\r\n        \r\n        k = count - k;\r\n        \r\n        ListNode dummy = new ListNode();\r\n        dummy.next = head;\r\n        ListNode curr = dummy;\r\n        \r\n        for (int i = 0; i < k; i++) {\r\n            curr = curr.next;\r\n        }\r\n        \r\n        tail.next = dummy.next;\r\n        dummy.next = curr.next;\r\n        curr.next = null;\r\n        \r\n        \r\n        return dummy.next;\r\n    }\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192775350","body":"éœ€è¦ä¸€äº›è¾…åŠ©çš„ListNodeæ¥è¿›è¡Œè®°å½•ï¼Œprevï¼Œnextï¼Œè¿˜æœ‰å½“å‰çš„ä¸¤ä¸ª\r\n```\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if (head == null || head.next == null) {return head;}\r\n        \r\n        ListNode first = head;\r\n        ListNode second = null;\r\n        ListNode prev = null;\r\n        ListNode nextNode = null;\r\n        \r\n        while (first != null) {\r\n            if (first.next == null) {\r\n                break;\r\n            }\r\n            \r\n            second = first.next;\r\n            nextNode = second.next;\r\n            \r\n            if (head == first) {\r\n                head = second;\r\n            } \r\n            if (prev != null) {\r\n                prev.next = second;\r\n            }\r\n            second.next = first;\r\n            first.next = nextNode;\r\n            prev = first;\r\n            first = first.next;\r\n            \r\n        }\r\n        \r\n        return head;\r\n    }\r\n}\r\n```\r\nT: O(n)\r\nS: O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1192855243","body":"é€’å½’PostOrder\r\n```\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if (head == null) {return null;}\r\n        \r\n        return dfs(head, null);\r\n    }\r\n\r\n    public TreeNode dfs(ListNode head, ListNode tail) {\r\n        if (head == tail) return null;\r\n        \r\n        ListNode slow = head, fast = head;\r\n        \r\n        while (fast != tail && fast.next != tail) {\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        \r\n        TreeNode node = new TreeNode(slow.val);\r\n        \r\n        node.left = dfs(head, slow);\r\n        node.right = dfs(slow.next, tail);\r\n        \r\n        return node;\r\n    }\r\n}\r\n```\r\nT: O(nlgn)\r\nS: O(lgn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193251768","body":"```\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if (headA == null || headB == null) {return null;}\r\n        \r\n        ListNode a = headA;\r\n        ListNode b = headB;\r\n        \r\n        while (a != b) {\r\n            a = a == null ? headB : a.next;\r\n            b = b == null ? headA : b.next;\r\n        }\r\n        \r\n        return a;\r\n    }\r\n}\r\n```\r\nT: O(m+n)\r\nS: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193532973","body":"åŒæŒ‡é’ˆ\r\n```\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if (head == null) {return null;}\r\n        ListNode slow = head, fast = head;\r\n        \r\n        while (fast.next != null && fast.next.next != null) {\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n            \r\n            if (slow == fast) {\r\n                fast = head;\r\n                \r\n                while (slow != fast) {\r\n                    slow = slow.next;\r\n                    fast = fast.next;\r\n                }\r\n                return slow;\r\n            }\r\n        }\r\n        \r\n        return null;\r\n    }\r\n}\r\n```\r\nT: O(n)\r\nS: O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196208599","body":"é€’å½’ï¼Œå–æœ€å¤§è¾¹\r\n```\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        return maxDepth(root, 0);\r\n    }\r\n    \r\n    public int maxDepth(TreeNode root, int depth) {\r\n        if (root == null) return depth;\r\n        \r\n        return Math.max(maxDepth(root.left, depth), maxDepth(root.right, depth)) + 1;\r\n    }\r\n}\r\n```\r\n\r\nT: O(n)\r\nS: O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197599540","body":"```\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null || q == null) return p == q;\r\n        \r\n        if (p.val != q.val) {\r\n            return false;\r\n        }\r\n        \r\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n```\r\nT: O(n)\r\nS: O(lgn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198506945","body":"dfséå†æ¯ä¸€æ¡è¾¹ï¼Œç„¶åç›¸åŠ å³å¯\r\n```\r\nclass Solution {\r\n    public int sumNumbers(TreeNode root) {\r\n        return sumNumbers(root, 0);\r\n    }\r\n    \r\n    public int sumNumbers(TreeNode root, int sum) {\r\n        if (root == null) {return 0;}\r\n        \r\n        sum += root.val;\r\n\r\n        if (root.left == null && root.right == null) {\r\n            return sum;\r\n        }\r\n        \r\n        return sumNumbers(root.left, sum*10) + sumNumbers(root.right, sum*10);\r\n    }\r\n}\r\n```\r\nT: O(n) \r\nS: O(lgn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1199835443","body":"```\r\nclass Solution {\r\n    int ans = 0, h = 0;\r\n    public int findBottomLeftValue(TreeNode root) {\r\n        dfs(root, 1);\r\n        return ans;\r\n    }\r\n    \r\n    public void dfs(TreeNode root, int depth) {\r\n        if (root == null) return;\r\n        \r\n        if (h < depth) {\r\n            ans = root.val;\r\n            h = depth;\r\n        }\r\n        \r\n        dfs(root.left, depth+1);\r\n        dfs(root.right, depth+1);\r\n    }\r\n}\r\n```\r\nT: O(n)\r\nS:O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200368601","body":"```\r\npublic class Codec {\r\n\r\n    // Encodes a tree to a single string.\r\n    public String serialize(TreeNode root) {\r\n        StringBuilder sb = new StringBuilder();\r\n        buildSerialize (root, sb);\r\n        return sb.toString();\r\n    }\r\n    \r\n    public void buildSerialize(TreeNode root, StringBuilder sb) {\r\n        if (root == null) {\r\n            sb.append(\"null\").append(\",\");    \r\n            return;\r\n        } else {\r\n            sb.append(root.val).append(\",\");\r\n        }\r\n        \r\n        buildSerialize (root.left, sb);\r\n        buildSerialize (root.right, sb);\r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    public TreeNode deserialize(String data) {\r\n        Queue<String> queue = new LinkedList<>();\r\n        queue.addAll(Arrays.asList(data.split(\",\")));\r\n        \r\n        return buildDeserialize(queue);\r\n    }\r\n    \r\n    public TreeNode buildDeserialize(Queue<String> data) {\r\n        String curr = data.poll();\r\n        \r\n        if (curr.equals(\"null\")) {\r\n            return null;\r\n        }\r\n        TreeNode node = new TreeNode(Integer.valueOf(curr));\r\n        \r\n        node.left = buildDeserialize(data);\r\n        node.right = buildDeserialize(data);\r\n        \r\n        return node;\r\n    }\r\n}\r\n```\r\nT: O(n)\r\nS: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200757559","body":"```\r\n\r\nclass Solution {\r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n        List<List<Integer>> res = new ArrayList<>();\r\n        \r\n        TreeMap<Integer, TreeMap<Integer, PriorityQueue<Integer>>> map = new TreeMap<>();\r\n        dfs(root, 0, 0, map);\r\n        \r\n        \r\n        for (TreeMap<Integer, PriorityQueue<Integer>> entry : map.values()) {\r\n            res.add(new ArrayList<>());\r\n            \r\n            for (PriorityQueue<Integer> pq : entry.values()) {\r\n                while (!pq.isEmpty()) {\r\n                    res.get(res.size()-1).add(pq.poll());       \r\n                }\r\n            }\r\n        }\r\n        \r\n        \r\n        return res;\r\n    }\r\n    \r\n    public void dfs(TreeNode root, int x, int y, TreeMap<Integer, TreeMap<Integer, PriorityQueue<Integer>>> map) {\r\n        if (root == null) return;\r\n        \r\n        if (!map.containsKey(x)) {\r\n            map.put(x, new TreeMap<>());\r\n        }\r\n        \r\n        if (!map.get(x).containsKey(y)) {\r\n            map.get(x).put(y, new PriorityQueue<>());\r\n        }\r\n        \r\n        map.get(x).get(y).add(root.val);\r\n        \r\n        dfs(root.left, x-1, y+1, map);\r\n        dfs(root.right, x+1, y+1, map);\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201467406","body":"```\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int target) {\r\n        int[] res = new int[2];\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        \r\n        for (int i = 0; i < nums.length; i++) {\r\n            if (map.containsKey(target - nums[i])) {\r\n                res[0] = map.get(target - nums[i]);\r\n                res[1] = i;\r\n            }\r\n            \r\n            if (!map.containsKey(nums[i])) {\r\n                map.put(nums[i], i);\r\n            }\r\n        }\r\n        \r\n        \r\n        return res;\r\n    }\r\n}\r\n```\r\nT: O(n)\r\nS: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203083600","body":"```\r\nclass Solution {\r\n    public int[] topKFrequent(int[] nums, int k) {\r\n        int[] res = new int[k];        \r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>((a,b) -> a.getValue() - b.getValue());\r\n        \r\n        for (int n: nums) {\r\n            map.put(n, map.getOrDefault(n, 0) + 1);        \r\n        }\r\n        \r\n        for (Map.Entry<Integer, Integer> entry: map.entrySet()) {\r\n            pq.offer(entry);\r\n            \r\n            if (pq.size() > k) {\r\n                pq.poll();\r\n            }\r\n        }\r\n        \r\n        int idx = 0;\r\n        while (pq.size() > 0) {\r\n            int val = pq.poll().getKey();\r\n            res[idx++] = val;\r\n        }\r\n        \r\n            \r\n        \r\n        return res;\r\n    }\r\n}\r\n```\r\nT: O(nlgk)\r\nS: o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204760220","body":"```\r\nclass Solution {\r\n    public int numberOfBoomerangs(int[][] points) {\r\n        int res = 0;\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        \r\n        for (int i = 0; i < points.length; i++) {\r\n            for (int j = 0; j < points.length; j++) {\r\n                if (i != j) {\r\n                    int p = dist(points[i], points[j]);\r\n                    map.put(p, map.getOrDefault(p, 0) + 1);\r\n                }\r\n            }\r\n            \r\n            for (int v: map.values()) {\r\n                res += v * (v-1);\r\n            }\r\n            map.clear();\r\n        }\r\n        \r\n        return res;\r\n    }\r\n    \r\n    public int dist(int[] p1, int[] p2) {\r\n        int l1 = p1[0] - p2[0];\r\n        int l2 = p1[1] - p2[1];\r\n        \r\n        return l1*l1 + l2*l2;\r\n    }\r\n}\r\n```\r\nT: O(n^2)\r\nS: O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207344189","body":"```\r\nclass Solution {\r\n    public int minSubarray(int[] nums, int p) {\r\n        int n = nums.length, res = n;\r\n        int need = 0, cur = 0;\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        map.put(0, -1);\r\n        for (int num: nums) {\r\n            need = (need + num) % p;\r\n        }\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            cur = (cur + nums[i]) % p;\r\n            map.put(cur, i);\r\n            \r\n            int rem = (cur - need + p) % p;\r\n            \r\n            if (map.containsKey(rem)) {\r\n                res = Math.min(res, i - map.get(rem));\r\n            }\r\n        }\r\n        \r\n        \r\n        return res < n ? res : -1;\r\n    }\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208887727","body":"```\r\nclass Solution {\r\n    public int removeDuplicates(int[] nums) {\r\n        if (nums.length < 2) return nums.length;\r\n        \r\n        int idx = 1;\r\n        \r\n        for (int i = 1; i < nums.length; i++) {\r\n            if (nums[i] != nums[i-1]) {\r\n                nums[idx++] = nums[i];\r\n            }\r\n        }\r\n        return idx;\r\n    }\r\n}\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"q815101630":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185032289","body":"```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        i = 0\r\n        num = num[::-1]\r\n        while k:\r\n            mod = k % 10\r\n            k = k//10\r\n            if i < len(num):\r\n                num[i] += mod\r\n            else:\r\n                num.append(mod)\r\n            if num[i] >= 10:\r\n                if i+1 < len(num):\r\n                    num[i+1] += 1\r\n                else:\r\n                    num.append(1)\r\n\r\n                num[i] -= 10\r\n            i+=1\r\n        while i < len(num):\r\n            if num[i] >= 10:\r\n                if i+1 < len(num):\r\n                    num[i+1] += 1\r\n                else:\r\n                    num.append(1)\r\n                num[i] -= 10\r\n                i+=1\r\n            else:\r\n                break\r\n        return num[::-1]\r\n```\r\nä¸€ä½ä¸€ä½åœ°åŠ å¹¶ä¸”è¿›ä½ ripple adder\r\n\r\nTime O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1188563652","body":"```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = [99999999999] * len(s)\r\n        left_c = -99999999999\r\n        for i,v in enumerate(s):\r\n            if v == c:\r\n                ans[i] = 0\r\n                left_c = i\r\n            ans[i] = min(ans[i], i-left_c)\r\n        \r\n        left_c = 99999999999\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                left_c = i\r\n            \r\n            ans[i] = min(ans[i], left_c-i)\r\n        \r\n\r\n        return ans\r\n```\r\n\r\næ­£ç€å€’ç€å„parseä¸€æ¬¡~~\r\næ—¶ç©º O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1188593761","body":"```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = [0]*maxSize\r\n        self.add = [0]*maxSize\r\n        self.size = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size < len(self.stack):\r\n            self.stack[self.size] = x\r\n            self.size += 1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.size > 0:\r\n            ret = self.stack[self.size - 1] + self.add[self.size -1]\r\n            if self.size > 1:\r\n                # if there's more than 1 element \r\n                # propogate\r\n                self.add[self.size - 2] += self.add[self.size - 1]\r\n\r\n\r\n            # must reset because it may incorrectly propogate some add number\r\n            self.add[self.size - 1] = 0\r\n            self.stack[self.size - 1] = 0\r\n            \r\n\r\n            self.size -= 1\r\n\r\n            return ret\r\n\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, self.size)\r\n        if lim > 0:\r\n            self.add[lim-1] += val\r\n\r\n```\r\nè¿™é“é¢˜ä¸€å®šè¦åšä¸‹increment ä¸ºO(1)çš„followupï¼Œå»å¹´æŠ–éŸ³è€ƒè¿‡è¿™ä¸ªfollowup\r\n\r\næ—¶é—´O(1)\r\nç©ºé—´ O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1188596859","body":"```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        num = \"\"\r\n        string = \"\"\r\n        for i,v in enumerate(s):\r\n            if \"a\" <= v <= \"z\":\r\n                string += v\r\n            elif \"0\" <= v <= \"9\":\r\n                num += v\r\n            elif v == \"[\":\r\n                stack.append((int(num),string))\r\n                string = \"\"\r\n                num = \"\"\r\n            elif v == \"]\":\r\n                prevNum, prevStr = stack.pop()\r\n                string = prevStr + prevNum*string\r\n            \r\n        \r\n        return string\r\n```\r\nè¿™é“é¢˜å¤ªç»å…¸äº†ï¼Œç”¨stack\r\næ—¶ç©ºO(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188603854","body":"```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.pushStack = []\r\n        self.popStack = []\r\n        self.front = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if not self.pushStack:\r\n            self.front = x\r\n        self.pushStack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.popStack:\r\n            return self.popStack.pop()\r\n        else:\r\n            while self.pushStack:\r\n                self.popStack.append(self.pushStack.pop())\r\n            self.front = None\r\n            return self.popStack.pop()\r\n\r\n    def peek(self) -> int:\r\n        if self.popStack:\r\n            return self.popStack[-1]\r\n        else:\r\n            return self.front\r\n\r\n\r\n    def empty(self) -> bool:\r\n        if not self.pushStack and not self.popStack:\r\n            return True\r\n        else:\r\n            return False\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\n# Thought\r\n1. Assign a `self.front` when `self.pushStack` is empty when pushing, so that `peek` is always O(1)\r\n\t\tWhether the existing elements are in self.pushStack or self.popStack, `peek()` is always O(1)\r\n2. For each element, it will only be appended and popped from the two stack twice. Amortized O(1)\r\n\r\n# Time\r\næ—¶é—´ O(1)\r\nç©ºé—´ O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189523970","body":"# non-strictly increasing stack\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for v in arr:\r\n            if not stack:\r\n                stack.append(v)\r\n            else:\r\n                if v >= stack[-1]:\r\n                    stack.append(v)\r\n                else:\r\n                    top = stack.pop()\r\n                    while stack and stack[-1] > v:\r\n                        stack.pop()\r\n                    \r\n                    stack.append(top)\r\n        \r\n        return len(stack)\r\n```\r\n\r\nè¿™é“é¢˜è¶…çº§ç»å…¸ï¼Œç¬¬ä¸€æ¬¡æƒ³stackæ–¹æ³•å¾ˆå¤æ‚ï¼Œå…¶å®ç†è§£åå°±æ˜ç™½ä»–çš„ç„æœºä¸éš¾ã€‚é‡ç‚¹åœ¨äºï¼š\r\n1. æ¯ä¸€ä¸ªchunkæˆ‘ä»¬ç”¨chunkä¸­æœ€å¤§çš„æ•°è¡¨ç¤º\r\n2. ç»´æŠ¤ä¸€ä¸ª non-strictgly increasing stackï¼Œè¡¨ç¤ºå¯æ’åºçš„array\r\n3. æ¯å½“æ–°è¿›æ¥çš„æ•°æ˜¯å¤§äºç­‰äºæ ˆé¡¶ï¼Œå³å¯ä»¥ç›´æ¥è¿›å…¥æ’åºåarray\r\n4. å¦‚æœå°äºæ ˆé¡¶ï¼ŒæŒç»­pop æ ˆé¡¶ç›´åˆ°æ ˆé¡¶å°äºç­‰äºæ–°è¿›æ¥çš„æ•°ï¼Œè¿™è¡¨æ˜chunkéœ€è¦èåˆçš„è¿‡ç¨‹\r\n\r\næ—¶é—´ O(n)\r\nç©ºé—´ O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190790492","body":"```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return None\r\n        cur = head\r\n        n = 0\r\n        while cur:\r\n            cur = cur.next\r\n            n += 1\r\n        \r\n        k %= n\r\n\r\n        if k == 0:\r\n            return head\r\n\r\n        steps = n - k\r\n        \r\n        cur = head\r\n        prev = None\r\n        for _ in range(steps):\r\n            prev = cur\r\n            cur = cur.next\r\n\r\n        end = cur\r\n        while end and end.next:\r\n            end = end.next\r\n        \r\n        if prev:\r\n            prev.next = None\r\n\r\n        end.next = head\r\n\r\n        return cur\r\n        \r\n```\r\nè¿™é“é¢˜ä¸éš¾ï¼Œä½†æ˜¯æœ‰å‡ ä¸ªedge case éœ€è¦æ³¨æ„\r\n1. k > é“¾è¡¨é•¿åº¦æ—¶ï¼Œå–ä½™\r\n2. é“¾è¡¨ä¸ºç©º\r\n3. k == é“¾è¡¨é•¿åº¦\r\n\r\næ—¶é—´ O(n)\r\nç©ºé—´ O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192190772","body":"```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        dummy = prev = ListNode()\r\n        dummy.next = head\r\n        cur = head\r\n        while cur and cur.next:\r\n            n = cur.next\r\n            nn = cur.next.next\r\n\r\n            prev.next = n\r\n            n.next = cur\r\n            cur.next = nn\r\n\r\n            prev = cur\r\n            cur = cur.next\r\n        \r\n        return dummy.next\r\n```\r\nç»å…¸è€é¢˜ç›®äº†ï¼Œç»´æŠ¤ä¸¤å›½variablesç„¶åäº¤æ¢ä¾¿æ˜¯\r\n\r\næ—¶é—´ O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1197635952","body":"```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n\r\n        def recur(head):\r\n            if not head:\r\n                return\r\n            if not head.next:\r\n                return TreeNode(val=head.val)\r\n\r\n            size = 0\r\n            cur = head\r\n            while cur:\r\n                cur = cur.next\r\n                size += 1\r\n\r\n            mid = size//2\r\n            prev = None\r\n            cur = head\r\n            for _ in range(mid):\r\n                prev = cur\r\n                cur = cur.next\r\n            \r\n            prev.next = None\r\n\r\n            node = TreeNode(val=cur.val, left= recur(head), right= recur(cur.next))\r\n\r\n            return node\r\n\r\n        return recur(head)\r\n```\r\nç»å…¸Recursion\r\næ—¶é—´ O(nlogn)ï¼Œæ¯æ¬¡éœ€è¦næ¬¡éå†é•¿åº¦ï¼Œéœ€è¦lognæ¬¡ï¼Œ\r\nç©ºé—´ O(logn)ï¼Œæ ˆä¸ºæ ‘é«˜åº¦","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1197636921","body":"```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        a = headA\r\n        b = headB\r\n        while a != b:\r\n\r\n            a = a.next\r\n            b = b.next\r\n            \r\n            if not a and not b:\r\n                return None\r\n\r\n            if not a:\r\n                a = headB\r\n            \r\n            if not b:\r\n                b = headA\r\n            \r\n        return a\r\n``` \r\næ—¶é—´ O(n)\r\nç©ºé—´ O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1197637349","body":"```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        fast = slow = head\r\n        while True:\r\n            if not fast or not fast.next:\r\n                return None\r\n            \r\n            fast = fast.next.next\r\n            slow = slow.next\r\n\r\n            if fast == slow:\r\n                break\r\n        \r\n        fast = head\r\n        while fast != slow:\r\n            fast = fast.next\r\n            slow = slow.next\r\n        \r\n        return fast\r\n```\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1197637685","body":"```python\r\nclass Node:\r\n    def __init__(self,key=0, value=0):\r\n        self.key = key\r\n        self.val = value\r\n        self.prev = None\r\n        self.next = None\r\n    \r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.hash = {}\r\n        self.head = Node()\r\n        self.last = Node()\r\n        self.head.next = self.last\r\n        self.last.prev = self.head\r\n        self.capacity = capacity\r\n        self.size = 0\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.hash:\r\n            return -1\r\n        node = self.hash[key]\r\n\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n        self.appendToHead(node)\r\n        return node.val\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.hash:\r\n            node = self.hash[key]\r\n            node.val = value\r\n            \r\n            node.prev.next = node.next\r\n            node.next.prev = node.prev\r\n\r\n            self.appendToHead(node)\r\n            return\r\n        if self.size < self.capacity:\r\n            node = Node(key, value)\r\n            self.hash[key] = node\r\n            self.appendToHead(node)\r\n            self.size+=1\r\n        else:\r\n            self.replaceNode(key, value)\r\n    \r\n    def appendToHead(self, node):\r\n        node.next = self.head.next\r\n        node.prev = self.head\r\n        self.head.next.prev = node\r\n        self.head.next = node\r\n    \r\n    def replaceNode(self, newKey, newVal):\r\n        deleted = self.last.prev\r\n\r\n        del self.hash[deleted.key]\r\n        deleted.key = newKey\r\n        deleted.val = newVal\r\n        self.hash[newKey] = deleted\r\n\r\n        deleted.prev.next = deleted.next\r\n        deleted.next.prev = deleted.prev\r\n        self.appendToHead(deleted)\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1197642487","body":"```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        res = 0\r\n        def recur(head, depth):\r\n            if not head:\r\n                return\r\n\r\n            nonlocal res\r\n            if depth > res:\r\n                res = depth\r\n            \r\n            recur(head.left, depth +1)\r\n            recur(head.right, depth +1)\r\n\r\n        recur(root,1)\r\n        return res\r\n            \r\n```\r\næ—¶é—´ O(n)\r\nç©ºé—´ O(logn)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197648002","body":"```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        lis1 = []\r\n        lis2 = []\r\n        \r\n        def serialize(node, lis):\r\n            if not node:\r\n                lis.append(\"*\")\r\n                return\r\n            \r\n            if node.left:\r\n                serialize(node.left, lis)\r\n            else:\r\n                lis.append(\"*\")\r\n\r\n\r\n            if node.right:\r\n                serialize(node.right, lis)\r\n            else:\r\n                lis.append(\"*\")\r\n\r\n            lis.append(node.val)\r\n\r\n        serialize(p, lis1)\r\n        serialize(q, lis2)\r\n        return lis1 == lis2\r\n```\r\n\r\næµ‹è¯• Inorder ä¼šå¤±è´¥ï¼Œpostorderå¯ä»¥work\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1207483159","body":"# DFS\r\n```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\r\n        total = 0\r\n\r\n        def dfs(node, numStr):\r\n            nonlocal total\r\n            if not node.left and not node.right:\r\n                total += numStr*10+node.val\r\n                return\r\n            if node.left:\r\n                dfs(node.left, numStr*10+node.val)\r\n            if node.right:\r\n                dfs(node.right, numStr*10+node.val)\r\n        \r\n        dfs(root, 0)\r\n        return total\r\n```\r\næ—¶é—´ï¼š O(n)\r\nç©ºé—´: O(logn)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1207486665","body":"```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nfrom collections import deque\r\n\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        queue = deque([root])\r\n        leaf = 0\r\n        while queue:\r\n            \r\n            for i in range(len(queue)):\r\n                node = queue.popleft()\r\n                if i == 0:\r\n                    possible = node.val\r\n                if node.left:\r\n                    queue.append(node.left)\r\n                if node.right:\r\n                    queue.append(node.right)\r\n                \r\n        return possible\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1207489730","body":"```python\r\n# Definition for a binary tree node.\r\n# class TreeNode(object):\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\nclass Codec:\r\n\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        output = []\r\n\r\n        def dfs(node):\r\n            nonlocal output\r\n            if not node:\r\n                output.append(\"#\")\r\n                return\r\n            output.append(str(node.val))\r\n            dfs(node.left)\r\n            dfs(node.right)\r\n        dfs(root)\r\n        print(\",\".join(output))\r\n        return \",\".join(output)\r\n\r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        input = data.split(\",\")[::-1]\r\n        if input == [\"#\"]:\r\n            return None\r\n\r\n        def dfs():\r\n            nonlocal input\r\n            \r\n            node = None\r\n            if input:\r\n                val = input.pop()\r\n                if val == '#':\r\n                    return None\r\n                node = TreeNode(val)\r\n                node.left = dfs()\r\n                node.right = dfs()\r\n\r\n            return node\r\n        return dfs()\r\n\r\n\r\n\r\n        \r\n\r\n# Your Codec object will be instantiated and called as such:\r\n# ser = Codec()\r\n# deser = Codec()\r\n# ans = deser.deserialize(ser.serialize(root))\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1207492137","body":"```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\r\n        col = collections.defaultdict(list)\r\n        left, right = 0,0 \r\n        def dfs(node, column, row):\r\n            nonlocal col\r\n            nonlocal left\r\n            nonlocal right\r\n            if not node:\r\n                return\r\n            \r\n            col[column].append((node.val, row))\r\n            left = min(left, column)\r\n            right = max(right, column)\r\n\r\n            if node.left:\r\n                dfs(node.left, column-1, row+ 1)\r\n            if node.right:\r\n                dfs(node.right, column + 1, row+1)\r\n            \r\n\r\n        dfs(root, 0, 0)\r\n\r\n        ans = []\r\n\r\n        for i in range(left, right+1):\r\n            lis = col[i]\r\n            lis.sort(key=lambda x:x[0])\r\n            ans.append([val for val,_ in sorted(lis, key=lambda x:x[1])])\r\n\r\n        return ans\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1207492318","body":"```python\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        dic = {}\r\n        for i,v in enumerate(nums):\r\n            if target-v in dic:\r\n                return [dic[target-v],i]\r\n            dic[v] = i\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1207495960","body":"heap\r\n```python\r\nimport heapq\r\n\r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        cnt = collections.defaultdict(int)\r\n        for i in nums:\r\n            cnt[i]+=1\r\n        # Min-heap\r\n        heap = []\r\n        for num, freq in cnt.items():\r\n            if len(heap) < k:\r\n                heapq.heappush(heap, (freq, num))\r\n            else:\r\n                if freq > heap[0][0]:\r\n                    heapq.heapreplace(heap, (freq, num))\r\n        return [n for _, n in heap]\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204216617","body":"å…ˆæ‰“å¡ï¼Œæ™šä¸Šå›æ¥è¡¥å……ç»†èŠ‚\n```\n\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        def distance(x,y):\n            return (y[1]-x[1])**2+(y[0]-x[0])**2\n\n        \n        ans = 0\n        \n        for i,v in enumerate(points):\n            \n            cnt = collections.defaultdict(int)\n            \n            for j in range(len(points)):\n                if points[j] != v:\n                    cnt[distance(points[j], v)]+=1\n            \n            for i,v in cnt.items():\n                ans += v*(v-1)\n                \n        return ans\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1207499856","body":"```python\r\nclass Solution(object):\r\n    def lengthOfLongestSubstring(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: int\r\n        \"\"\"\r\n        left = 0\r\n        curZone = set()\r\n        maxLength = 0\r\n\r\n\r\n        for right in range(len(s)):\r\n            while s[right]in curZone:\r\n                curZone.remove(s[left])\r\n                left+=1\r\n            \r\n            curZone.add(s[right])\r\n            maxLength = max(maxLength,right-left+1)\r\n\r\n        return maxLength\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207504490","body":"```python\r\nclass Solution:\r\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\r\n        cnt = collections.defaultdict(int)\r\n        total = 0\r\n        for w in words:\r\n            cnt[w] += 1\r\n            total += 1\r\n        if not s or not total:\r\n            return []\r\n        n = len(words[0])    \r\n        size = n * total\r\n        if len(s) < size:\r\n            return []\r\n        \r\n        left, right = 0, size - 1\r\n        ans = []\r\n        while right <= len(s):\r\n\r\n            curL = left\r\n            curTotal = total\r\n            curCnt = cnt.copy()\r\n\r\n            invalid = False\r\n            while curL <= right:\r\n                if s[curL: curL+n] in curCnt and curCnt[s[curL:curL+n]] > 0:\r\n                    curTotal -= 1\r\n                    curCnt[s[curL:curL+n]] -= 1\r\n\r\n                    curL += n\r\n                else:\r\n                    invalid = True\r\n                    break\r\n                \r\n            if invalid:\r\n                left += 1\r\n                right += 1\r\n                continue\r\n            if curTotal == 0:\r\n                ans.append(left)\r\n\r\n\r\n            left += 1\r\n            right += 1\r\n        return ans\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207518353","body":"```python\r\nclass Solution:\r\n    def minSubarray(self, nums: List[int], p: int) -> int:\r\n        sm = 0\r\n        res = len(nums)\r\n\r\n        # key is the preSum%p, val is the current index, default is 0:-1\r\n        mp = {0:-1}\r\n\r\n        target = sum(nums) % p\r\n\r\n        for i,v in enumerate(nums):\r\n            sm += v\r\n            \r\n            mp[sm%p] = i\r\n\r\n            if (sm-target) % p in mp:\r\n                res = min(res, i-mp[(sm-target) % p])\r\n\r\n            \r\n        \r\n        if res == len(nums):\r\n            return -1\r\n\r\n        return res\r\n\r\n```\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207492692","body":"éå†ä¸€éå®Œäº‹\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def middleNode(self, head: ListNode) -> ListNode:\r\n        l = 0 \r\n        cur = head\r\n        while cur:\r\n            cur = cur.next\r\n            l += 1\r\n        cur = head\r\n        for i in range(l//2):\r\n            cur = cur.next\r\n        return cur\r\n```\r\næ—¶é—´O(n)\r\nç©ºé—´ O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208643314","body":"```python\r\n\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        fast = slow = 0\r\n        while fast < len(nums):\r\n\r\n            # duplicate\r\n            if nums[fast] == nums[slow]:\r\n                fast += 1\r\n            \r\n            # non-duplicagte\r\n            else:\r\n                nums[slow+1] = nums[fast]\r\n                slow+=1\r\n                fast+=1\r\n        \r\n        return slow+1\r\n\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiyishuoshuo":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185034114","body":"explanation:\r\ntake K as a carry and use k to extract the lowest digit with K % 10 and update k with k /10 as the next higher digit\r\ncorner case is once the loop ended, if k is still > 0 need to put 1 on the leftmost digit\r\n\r\ncode\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n\r\n        int len = num.length;\r\n        List<Integer> ans = new ArrayList<>();\r\n        \r\n        for(int j = len - 1; j>=0 || k > 0; j--){\r\n            ans.add(0, (j>=0 ? num[j] + k : k) % 10);\r\n            k = (j>=0 ? num[j] + k : k) / 10;\r\n        }\r\n\r\n        return ans;\r\n\r\n    }\r\n}\r\n```\r\n\r\nTime: O(n) since iterate array once\r\nSpace: O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186163128","body":"Explanation:\r\nloop through the array twice first from left to right and keep update pos for char c and calculate the potential distance between each character and matching c\r\nthen loop through the same from right to left and then the result should be taking the min of current distance and previous min distance looping from left to right\r\n\r\ncode:\r\n'''\r\npublic int[] shortestToChar(String s, char c) {\r\n        \r\n        int len = s.length(), pos = -2*len ;\r\n        int[] result = new int[len];\r\n        \r\n        // from left to right\r\n        for(int i = 0; i< len; i++){\r\n            if(s.charAt(i) == c) {\r\n                pos = i;\r\n            }\r\n            result[i] = i - pos;\r\n        }\r\n        \r\n        // from right to left\r\n        pos = 2 * len;\r\n        for(int j = len - 1; j>=0; j--){\r\n            if(s.charAt(j) == c){\r\n                pos = j;\r\n            }\r\n            result[j] = Math.min(result[j], pos - j);\r\n        }\r\n        \r\n        return result;\r\n        \r\n    }\r\n'''\r\n\r\nTime: O(n) loop through twice so will be O(2n) but will be treated as O(n)\r\nSpace: O(n) result array with n length\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186575830","body":"Explanation:\r\nUse an array to represent the stack. Push will add a new integer to the array. Pop removes the last element in the array and increment will add value to the first k elements of the array.\r\n\r\ncode:\r\n```\r\nclass CustomStack {\r\n    \r\n    private int maxSize;\r\n    private List<Integer> stack;\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize; \r\n        this.stack = new ArrayList<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        int size = this.stack.size();\r\n        if(size >= maxSize) return;\r\n        this.stack.add(size, x);        \r\n    }\r\n    \r\n    public int pop() {\r\n        if(this.stack.isEmpty()) return -1;\r\n        int lastVal = stack.get(this.stack.size() - 1);\r\n        this.stack.remove(this.stack.size() - 1);\r\n        return lastVal;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int increment_size = k<=stack.size() ? k : this.stack.size();\r\n        for(int i = 0; i < increment_size; i++){\r\n            stack.set(i, stack.get(i) + val);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nTime: for push and pop which is going to be O(1), for increment is O(k) \r\nSpace: O(n) - as we used an array for backing up ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186690012","body":"code:\r\n```\r\npublic String decodeString(String s) {\r\n        int n = s.length();\r\n        Deque<Character> stack = new LinkedList<>();\r\n        char[] ss = s.toCharArray();\r\n        for (char c : ss) {\r\n            if (c != ']') {\r\n                stack.push(c);\r\n            } else {\r\n                StringBuilder sb = new StringBuilder();\r\n                while (!stack.isEmpty() && Character.isLetter(stack.peek())) {\r\n                    sb.insert(0, stack.pop());\r\n                }\r\n                stack.pop(); // skip :[\r\n                int num = 0;\r\n                int base = 1;\r\n                while (!stack.isEmpty() && Character.isDigit(stack.peek())) {\r\n                    num  += (stack.pop() - '0') * base;\r\n                    base *= 10;\r\n                }\r\n                String str = sb.toString();\r\n                 String temp = \"\";\r\n                while (num !=0){\r\n                    temp += str;\r\n                    num--;\r\n                }\r\n                for (Character t : temp.toCharArray()){\r\n                    stack.push(t);\r\n                }\r\n            }\r\n        }\r\n        StringBuilder sb = new StringBuilder();\r\n        for (char c : stack) {\r\n            sb.insert(0, c);\r\n        }\r\n        return sb.toString();\r\n    }\r\n```\r\n\r\ntime: O(n)\r\nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188951908","body":"code:\r\n```\r\nclass MyQueue {\r\n    \r\n    Deque<Integer> stack1;\r\n    Deque<Integer> stack2;\r\n\r\n    public MyQueue() {\r\n        stack1 = new ArrayDeque<>();\r\n        stack2 = new ArrayDeque<>();\r\n        \r\n    }\r\n    \r\n    public void push(int x) {\r\n        stack1.push(x);\r\n        \r\n    }\r\n    \r\n    public int pop() {\r\n        int result = this.peek();\r\n        stack2.poll();\r\n        return result;\r\n        \r\n    }\r\n    \r\n    public int peek() {\r\n        //ä»€ä¹ˆæ—¶å€™stack2 empty æ‰ä»stack1 é‡Œé¢ä¸æ–­çš„push æ–°çš„data è¿›æ¥\r\n        if(stack2.isEmpty()){\r\n            while(!stack1.isEmpty()){\r\n                stack2.push(stack1.poll());      \r\n            }\r\n        }\r\n        return stack2.peek();       \r\n    }\r\n    \r\n    public boolean empty() {\r\n        return stack1.isEmpty() && stack2.isEmpty();\r\n    }\r\n}\r\n\r\n```\r\ntime: peek and pop worst case O(n)\r\nspace: use two additional stack with O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189709208","body":"code\r\n```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int n = arr.length;\r\n        int[] maxOfLeft = new int[n];\r\n        int[] minOfRight = new int[n];\r\n\r\n        maxOfLeft[0] = arr[0];\r\n        for (int i = 1; i < n; i++) {\r\n            maxOfLeft[i] = Math.max(maxOfLeft[i-1], arr[i]);\r\n        }\r\n\r\n        minOfRight[n - 1] = arr[n - 1];\r\n        for (int i = n - 2; i >= 0; i--) {\r\n            minOfRight[i] = Math.min(minOfRight[i + 1], arr[i]);\r\n        }\r\n\r\n        int res = 0;\r\n        for (int i = 0; i < n - 1; i++) {\r\n            if (maxOfLeft[i] <= minOfRight[i + 1]) res++;\r\n        }\r\n\r\n        return res + 1;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191351570","body":"code \r\n```\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || head.next == null) return head;\r\n        int count = 0;\r\n        ListNode now = head;\r\n        while(now != null){\r\n            now = now.next;\r\n            count++;\r\n        }\r\n        k = k % count;\r\n        ListNode slow = head, fast = head;\r\n        while(fast.next != null){\r\n            if(k-- <= 0){\r\n                slow = slow.next;\r\n            }\r\n            fast = fast.next;\r\n        }\r\n        fast.next = head;\r\n        ListNode res = slow.next;\r\n        slow.next = null;\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\ntime: O(n)\r\nspace:O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193113227","body":"explanation:\r\nconvert LinkedList to Array so that finding middle will be O(1) and this question is down to convert sorted array to binary search tree which will be using recursion approcach.\r\n\r\ncode:\r\n```\r\nclass Solution {\r\n    private List<Integer> values = new ArrayList<>();\r\n    \r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        mapLinkedListToArray(head);\r\n        return convertToBSTHelper(0, values.size() - 1);\r\n        \r\n    }\r\n    \r\n    private void mapLinkedListToArray(ListNode head){\r\n        while(head != null){\r\n            values.add(head.val);\r\n            head = head.next;\r\n        }\r\n    }\r\n    \r\n    private TreeNode convertToBSTHelper(int left, int right){\r\n        if(left>right) return null;\r\n        int mid = (right-left) / 2 + left;\r\n        TreeNode root = new TreeNode(values.get(mid));\r\n        if(left == right){\r\n            return root;\r\n        }\r\n        root.left = convertToBSTHelper(left, mid - 1);\r\n        root.right = convertToBSTHelper(mid + 1, right);\r\n        return root;\r\n    }\r\n}\r\n\r\n```\r\n\r\ntime: O(n)\r\nspace: O(n) since we used additional array to hold whole linkedlist","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193300501","body":"explanation:\r\ntwo pointers to go through both m + n and check if there is an intersection.\r\n\r\ncode\r\n```\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode p1 = headA, p2 = headB;\r\n        \r\n        while(p1 != p2){\r\n            if(p1 == null){\r\n                p1 = headB;\r\n            }else{\r\n                p1 = p1.next;\r\n            }\r\n            if(p2 == null){\r\n                p2 = headA;\r\n            }else{\r\n                p2 = p2.next;\r\n            }\r\n        }\r\n        return p1;\r\n        \r\n    }\r\n}\r\n```\r\n\r\ntime: O(m+n) where m is the length of first LinkedList and n is the length of second LinkedList\r\nspace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193397247","body":"explanation:\r\nfast and slow pointer to check if there is a cycle(which downgrades to problem 1) and if there is a cycleï¼Œ then reassign the slow pointer to the head and move both slow and fast pointer forward at same pace until they met which is the intersection node\r\n\r\ncode:\r\n```\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode slow, fast;\r\n        slow = fast = head;\r\n        boolean hasCycle = false;\r\n        \r\n        while(fast != null && fast.next != null){\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n            if(slow == fast){\r\n                hasCycle = true;\r\n                break;\r\n            }         \r\n        }\r\n        \r\n        if(hasCycle){\r\n            slow = head;\r\n        }else{\r\n            return null;\r\n        }\r\n        \r\n        \r\n        while(slow != fast){\r\n            slow = slow.next;\r\n            fast = fast.next;\r\n        }\r\n        return slow;\r\n        \r\n    }\r\n}\r\n```\r\n\r\ntime: O(n) iterate the whole list to check the cycle \r\nSpace: O(1) didn't use any additional auxiliary ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194797359","body":"explanation:\r\nusing linked hash map which by default utilizes map and doubly LinkedList so map get operation returns O(1) and put will also be O(1) since that is a doubly linked list which makes put operation become O(1)\r\n\r\ncode\r\n```\r\nclass LRUCache {\r\n    private int capacity;\r\n    private LinkedHashMap<Integer, Integer> cache;\r\n    \r\n    public LRUCache(int capacity) {\r\n        this.capacity = capacity;\r\n        this.cache = new LinkedHashMap<>(); \r\n    }\r\n    \r\n    public int get(int key) {\r\n        if(!cache.containsKey(key)){\r\n            return -1;\r\n        }\r\n        makeRecently(key);\r\n        return cache.get(key);\r\n        \r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        if(cache.containsKey(key)){\r\n            cache.put(key, value);\r\n            makeRecently(key);\r\n            return;\r\n        }\r\n        \r\n        if(cache.size() >= capacity){\r\n            int oldestKey = cache.keySet().iterator().next();\r\n            cache.remove(oldestKey);\r\n        }\r\n        \r\n        cache.put(key, value);\r\n        \r\n    }\r\n    \r\n    private void makeRecently(int key){\r\n        int value = cache.get(key);\r\n        cache.remove(key);\r\n        cache.put(key, value);\r\n    }\r\n}\r\n```\r\n\r\nTime: O(1) since get and put operation both leveraging map and linked list\r\nSpace: O(capacity) need to initialize a map with at most capacity of keys \r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196203778","body":"code\r\n\r\n```\r\nclass Solution {\r\n  public int maxDepth(TreeNode root) {\r\n    if (root == null) {\r\n      return 0;\r\n    } else {\r\n      int left_height = maxDepth(root.left);\r\n      int right_height = maxDepth(root.right);\r\n      return java.lang.Math.max(left_height, right_height) + 1;\r\n    }\r\n  }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197469539","body":"explanation:\r\ntree post order traversal and condition is left tree and right tree are same tree and current value equals which then treated as same tree\r\n\r\ncode:\r\n```\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if( p == null && q != null) return false;\r\n        if( p != null && q == null) return false;\r\n        if(p == null && q == null) return true;        \r\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right) && p.val == q.val;\r\n\r\n    }\r\n    \r\n}\r\n```\r\n\r\ntime:  O( max(p, q)) because we need to traverse the whole tree either for p or q\r\nspace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199275997","body":"explanation:\r\ntree traversal: post order and pass current sum to the next level\r\n\r\ncode:\r\n```\r\nclass Solution {\r\n    int rootToLeaf = 0;\r\n    \r\n    public int sumNumbers(TreeNode root) {\r\n        \r\n        sumNumbersDFS(root, 0);\r\n        return rootToLeaf;\r\n        \r\n    }\r\n    \r\n    private void sumNumbersDFS(TreeNode root, int currentSum){\r\n        if(root == null) return;\r\n\r\n        currentSum = currentSum * 10 + root.val;\r\n        \r\n         if(root.left == null && root.right == null){\r\n             rootToLeaf += currentSum;\r\n             return;\r\n         }\r\n        sumNumbersDFS(root.left, currentSum);\r\n        sumNumbersDFS(root.right, currentSum);\r\n\r\n    }\r\n}\r\n```\r\n\r\ntime: O(n) - whole tree traversal\r\nspace:O(1) - didn't allocate more space just traverse on the tree itself","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200154081","body":"explanation:\r\nessentially it is tree pre-order traversal, and you need to keep track of the first time when it goes to a new depth of a tree and also confirms that is the leaf node which is our value.\r\n\r\ncode\r\n```\r\nclass Solution {\r\n    \r\n    int maxLevel = -1;\r\n    int mostLeftValue = 0;\r\n    public int findBottomLeftValue(TreeNode root) {\r\n        this.getLeafNodes(root, 0);\r\n        return mostLeftValue;\r\n    }\r\n\r\n    private void getLeafNodes(TreeNode node, int level){\r\n        if(node == null) return;\r\n        if(level > maxLevel && node.left == null && node.right == null){\r\n            mostLeftValue = node.val;\r\n            maxLevel = level;\r\n            return;\r\n        } \r\n        getLeafNodes(node.left, level + 1);\r\n        getLeafNodes(node.right, level + 1);\r\n       \r\n        \r\n    }\r\n}\r\n```\r\n\r\ntime: O(n) - pre-order traversal of tree\r\nspace:O(1) - as we didn't use extra or additional memory storage ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200598113","body":"code\r\n```\r\nclass Triplet<F, S, T> {\r\n    public final F first;\r\n    public final S second;\r\n    public final T third;\r\n\r\n    public Triplet(F first, S second, T third) {\r\n        this.first = first;\r\n        this.second = second;\r\n        this.third = third;\r\n    }\r\n}\r\n\r\nclass Solution {\r\n    List<Triplet<Integer, Integer, Integer>> nodeList = new ArrayList<>();\r\n\r\n    private void DFS(TreeNode node, Integer row, Integer column) {\r\n        if (node == null)\r\n            return;\r\n        nodeList.add(new Triplet(column, row, node.val));\r\n        // preorder DFS traversal\r\n        this.DFS(node.left, row + 1, column - 1);\r\n        this.DFS(node.right, row + 1, column + 1);\r\n    }\r\n\r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n        List<List<Integer>> output = new ArrayList();\r\n        if (root == null) {\r\n            return output;\r\n        }\r\n\r\n        // step 1). DFS traversal\r\n        DFS(root, 0, 0);\r\n\r\n        // step 2). sort the list by <column, row, value>\r\n        Collections.sort(this.nodeList, new Comparator<Triplet<Integer, Integer, Integer>>() {\r\n            @Override\r\n            public int compare(Triplet<Integer, Integer, Integer> t1,\r\n                    Triplet<Integer, Integer, Integer> t2) {\r\n                if (t1.first.equals(t2.first))\r\n                    if (t1.second.equals(t2.second))\r\n                        return t1.third - t2.third;\r\n                    else\r\n                        return t1.second - t2.second;\r\n                else\r\n                    return t1.first - t2.first;\r\n            }\r\n        });\r\n\r\n        // step 3). extract the values, grouped by the column index.\r\n        List<Integer> currColumn = new ArrayList();\r\n        Integer currColumnIndex = this.nodeList.get(0).first;\r\n\r\n        for (Triplet<Integer, Integer, Integer> triplet : this.nodeList) {\r\n            Integer column = triplet.first, value = triplet.third;\r\n            if (column == currColumnIndex) {\r\n                currColumn.add(value);\r\n            } else {\r\n                output.add(currColumn);\r\n                currColumnIndex = column;\r\n                currColumn = new ArrayList();\r\n                currColumn.add(value);\r\n            }\r\n        }\r\n        output.add(currColumn);\r\n\r\n        return output;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201932927","body":"code\r\n```\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int target) {\r\n        \r\n        HashMap<Integer, Integer> map = new HashMap<>();\r\n        int[] result = new int[2];\r\n        for(int i = 0; i < nums.length; i++){\r\n            map.put(nums[i], i);\r\n        }\r\n        \r\n        for(int j = 0; j < nums.length; j++){\r\n            int other = target - nums[j];\r\n            if(map.containsKey(other) && map.get(other) != j){\r\n                result[0] = j;\r\n                result[1] = map.get(other);\r\n            }\r\n        }\r\n        \r\n        return result;\r\n        \r\n    }\r\n}\r\n```\r\n\r\ntime: O(n)\r\nspace: O(n) - since we used hashmap and stored at most n elements.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203848212","body":"code\r\n```\r\nclass Solution {\r\n    public int[] topKFrequent(int[] nums, int k) {\r\n        \r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        \r\n        for(int num: nums){\r\n            map.put(num, map.getOrDefault(num, 0) + 1);\r\n        }\r\n        \r\n        Queue<Integer> frqQ = new PriorityQueue<Integer>(k, (a, b) -> {\r\n            return map.get(a) - map.get(b);\r\n        });\r\n        \r\n        for(int frq: map.keySet()){\r\n            frqQ.offer(frq);\r\n            if(frqQ.size() > k){\r\n                frqQ.poll();\r\n            }\r\n        }\r\n        \r\n        int[] result = new int[k];\r\n        while(k>0){\r\n                result[--k] = frqQ.poll();  \r\n        }\r\n        \r\n        return result;\r\n    }\r\n    \r\n    \r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204688526","body":"code\r\n```\r\npublic int numberOfBoomerangs(int[][] points) {\r\n\r\n    if (points == null || points.length <= 2)\r\n        return 0;\r\n\r\n    int res = 0;\r\n    Map<Integer, Integer> equalCount = new HashMap<>();\r\n\r\n    for (int i = 0; i < points.length; ++i) {\r\n\r\n        for (int j = 0; j < points.length; ++j) {\r\n\r\n            int dinstance = getDistance(points[i], points[j]);\r\n            equalCount.put(dinstance, equalCount.getOrDefault(dinstance, 0) + 1);\r\n        }\r\n\r\n        for (int count : equalCount.values())\r\n            res += count * (count - 1);\r\n        equalCount.clear();\r\n    }\r\n\r\n    return res;\r\n}\r\n\r\nprivate int getDistance(int[] x, int[] y) {\r\n\r\n    int x1 = y[0] - x[0];\r\n    int y1 = y[1] - x[1];\r\n\r\n    return x1 * x1 + y1 * y1;\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205860998","body":"code:\r\n```\r\nclass Solution {\r\n    public int lengthOfLongestSubstring(String s) {\r\n        int left = 0, right = 0;\r\n        int maxLen = 0;\r\n        if(s.isEmpty()) return maxLen;\r\n        \r\n        Map<Character, Integer> window = new HashMap<>();\r\n        \r\n        while(right < s.length()){\r\n            char c = s.charAt(right);\r\n            right++;\r\n            window.put(c, window.getOrDefault(c, 0) + 1);\r\n            \r\n            while(window.get(c) > 1){\r\n                char d = s.charAt(left);\r\n                left++;\r\n                window.put(d, window.get(d) - 1);              \r\n            }\r\n            \r\n            maxLen = Math.max(maxLen, right - left);\r\n        }\r\n        \r\n        return maxLen;\r\n        \r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207204854","body":"sliding window:\r\n\r\ncode\r\n```\r\nclass Solution {\r\n    private HashMap<String, Integer> wordCount = new HashMap<String, Integer>();\r\n    private int n;\r\n    private int wordLength;\r\n    private int substringSize;\r\n    private int k;\r\n    \r\n    private void slidingWindow(int left, String s, List<Integer> answer) {\r\n        HashMap<String, Integer> wordsFound = new HashMap<>();\r\n        int wordsUsed = 0;\r\n        boolean excessWord = false;\r\n        \r\n        // Do the same iteration pattern as the previous approach - iterate\r\n        // word_length at a time, and at each iteration we focus on one word\r\n        for (int right = left; right <= n - wordLength; right += wordLength) {\r\n            \r\n            String sub = s.substring(right, right + wordLength);\r\n            if (!wordCount.containsKey(sub)) {\r\n                // Mismatched word - reset the window\r\n                wordsFound.clear();\r\n                wordsUsed = 0;\r\n                excessWord = false;\r\n                left = right + wordLength;\r\n            } else {\r\n                // If we reached max window size or have an excess word\r\n                while (right - left == substringSize || excessWord) {\r\n                    String leftmostWord = s.substring(left, left + wordLength);\r\n                    left += wordLength;\r\n                    wordsFound.put(leftmostWord, wordsFound.get(leftmostWord) - 1);\r\n\r\n                    if (wordsFound.get(leftmostWord) >= wordCount.get(leftmostWord)) {\r\n                        // This word was an excess word\r\n                        excessWord = false;\r\n                    } else {\r\n                        // Otherwise we actually needed it\r\n                        wordsUsed--;\r\n                    }\r\n                }\r\n                \r\n                // Keep track of how many times this word occurs in the window\r\n                wordsFound.put(sub, wordsFound.getOrDefault(sub, 0) + 1);\r\n                if (wordsFound.get(sub) <= wordCount.get(sub)) {\r\n                    wordsUsed++;\r\n                } else {\r\n                    // Found too many instances already\r\n                    excessWord = true;\r\n                }\r\n                \r\n                if (wordsUsed == k && !excessWord) {\r\n                    // Found a valid substring\r\n                    answer.add(left);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    public List<Integer> findSubstring(String s, String[] words) {\r\n        n = s.length();\r\n        k = words.length;\r\n        wordLength = words[0].length();\r\n        substringSize = wordLength * k;\r\n        \r\n        for (String word : words) {\r\n            wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);\r\n        }\r\n        \r\n        List<Integer> answer = new ArrayList<>();\r\n        for (int i = 0; i < wordLength; i++) {\r\n            slidingWindow(i, s, answer);\r\n        }\r\n        \r\n        return answer;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207406352","body":"ç›´æ¥æŠ„ä½œä¸šäº†\r\n\r\n```\r\nimport java.util.*;\r\n\r\nclass Solution {\r\n\r\n    public int solve(int[] nums, int k) {\r\n\r\n        int tar = 0;\r\n\r\n        for (int n : nums)\r\n            tar += n;\r\n\r\n        tar = Math.floorMod(tar, k);\r\n\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        map.put(0, -1);\r\n\r\n        int prefix = 0, res = nums.length;\r\n\r\n        for (int i = 0; i < nums.length; i++) {\r\n\r\n            prefix += nums[i];\r\n            int mod = Math.floorMod(prefix, k);\r\n            map.put(mod, i);\r\n\r\n            if (map.containsKey(Math.floorMod(prefix - tar, k)))\r\n                res = Math.min(res, i - map.get(Math.floorMod(prefix - tar, k)));\r\n        }\r\n\r\n        return res == nums.length ? -1 : res;\r\n    }\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207538367","body":"å¿«æ…¢æŒ‡é’ˆ \r\n\r\ncode \r\n```\r\nclass Solution {\r\n    public ListNode middleNode(ListNode head) {\r\n        \r\n        ListNode slow, fast;\r\n        slow = fast = head;\r\n        \r\n        while(fast != null && fast.next != null){\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        \r\n        return slow;\r\n        \r\n    }\r\n}\r\n```\r\n\r\ntime: O(n)\r\nspace:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208736996","body":"code\r\n```\r\nclass Solution {\r\n    public int removeDuplicates(int[] nums) {\r\n        \r\n        int slow = 0, fast = 0, length = nums.length;\r\n        \r\n        while(fast < length){\r\n            if(nums[slow] != nums[fast]){\r\n                nums[++slow] = nums[fast];\r\n            }\r\n            fast++;\r\n        }\r\n        \r\n        return slow + 1;\r\n        \r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/42#issuecomment-1210005080","body":"code:\r\n```\r\nclass Solution {\r\n    public int searchInsert(int[] nums, int target) {\r\n        \r\n         int low = 0, high = nums.length - 1;\r\n        \r\n        while(low + 1 < high){\r\n            int mid = low + (high - low) / 2;\r\n            if(target == nums[mid]){\r\n                return mid;\r\n            } else if(nums[mid] < target){\r\n                low = mid;\r\n            } else {\r\n                high = mid;\r\n            }\r\n        }\r\n        \r\n        if(target < nums[low]){\r\n            return low - 1 < 0 ? 0 : low - 1;\r\n        }else if(target == nums[low]){\r\n            return low;\r\n        }else if(target > nums[high]){\r\n            return high + 1 > nums.length ? nums.length : high + 1;\r\n        }else if (target == nums[high]){\r\n            return high;\r\n        }\r\n        \r\n        return low + 1;\r\n        \r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aouos":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185043729","body":"```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n  const len = num.length;\n  const stack = [];\n\n  for (let i = len - 1; i >= 0 || k > 0; i--) {\n    k = k + (num[i] || 0);\n    stack.push(k % 10);\n    k = Math.floor(k / 10);\n  }\n\n  return stack.reverse();\n};\n```\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186120127","body":"## æ€è·¯\nå·¦å³ä¸¤æ¬¡éå†\n\n## ä»£ç \n```js\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function (s, c) {\n  const len = s.length;\n  const ans = new Array(len).fill(10001);\n\n  for (let i = 0; i < len; i++) {\n    if (s[i] === c) {\n      ans[i] = 0;\n    } else {\n      if (i === 0) {\n        continue;\n      }\n      ans[i] = ans[i - 1] + 1;\n    }\n  }\n\n  for (let j = len - 1; j >= 0; j--) {\n    if (j + 1 !== len) {\n      ans[j] = Math.min(ans[j], ans[j + 1] + 1);\n    }\n  }\n\n  return ans;\n};\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´ï¼šO(n)\n- ç©ºé—´ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186465815","body":"```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n  this.max = maxSize;\n  this.stack = [];\n  this.top = 0;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n  if (this.top < this.max) {\n    this.stack.push(x);\n    this.top++;\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n  if (this.top > 0) {\n    this.top--;\n    return this.stack.pop();\n  }\n\n  return -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n  const min = Math.min(k, this.top);\n  for (let i = 0; i < min; i++) {\n    this.stack[i] += val;\n  }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187606409","body":"```js\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function (s) {\n  const numStack = [];\n  const strStack = [];\n  const len = s.length;\n  let num = 0;\n  let str = '';\n\n  for (let i = 0; i < len; i++) {\n    if (s[i] >= 0 && s[i] < 10) {\n      num = num * 10 + parseInt(s[i]);\n    } else if (s[i] === '[') {\n      numStack.push(num);\n      strStack.push(str);\n      num = 0;\n      str = '';\n    } else if (s[i] === ']') {\n      const times = numStack.pop();\n      str = strStack.pop() + str.repeat(times);\n    } else {\n      str += s[i];\n    }\n  }\n\n  return str;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189138547","body":"```js\nvar MyQueue = function () {\n  this.orderStack = [];\n  this.rOrderStack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n  this.orderStack.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n  if (!this.rOrderStack.length) {\n    while (this.orderStack.length) {\n      this.rOrderStack.push(this.orderStack.pop());\n    }\n  }\n  return this.rOrderStack.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n  if (!this.rOrderStack.length) {\n    while (this.orderStack.length) {\n      this.rOrderStack.push(this.orderStack.pop());\n    }\n  }\n  return this.rOrderStack[this.rOrderStack.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n  return !this.orderStack.length && !this.rOrderStack.length;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190359101","body":"```js\n/**\n * @param {number[]} arr\n * @return {number}\n */\n var maxChunksToSorted = function (arr) {\n  const len = arr.length;\n  const stack = [];\n\n  for (let i = 0; i < len; i++) {\n    if (!stack.length || stack[stack.length - 1] <= arr[i]) {\n      stack.push(arr[i]);\n    } else {\n      const temp = stack.pop();\n      while (stack.length && stack[stack.length - 1] > arr[i]) {\n        stack.pop();\n      }\n      stack.push(temp);\n    }\n  }\n\n  return stack.length;\n};\n\n// æ—¶é—´å¤æ‚åº¦ O(N)\n// ç©ºé—´å¤æ‚åº¦ O(N)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191589115","body":"## æ€è·¯\nåŒæŒ‡é’ˆ\n## ä»£ç \n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function (head, k) {\n  if (!head || !head.next || k === 0) {\n    return head;\n  }\n\n  let p = head;\n  let len = 1;\n\n  while (p.next) {\n    p = p.next;\n    len++;\n  }\n\n  k = k % len;\n  p.next = head;\n\n  for (let i = 0; i < len - k; i++) {\n    p = p.next;\n  }\n\n  const newLink = p.next;\n  p.next = null;\n\n  return newLink;\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193329977","body":"````js\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n  // åŒæŒ‡é’ˆï¼Œä¸¤ä¸ªæŒ‡é’ˆç›¸é‡å³ä¸ºç›¸äº¤èŠ‚ç‚¹\n  let P1 = headA, P2 = headB;\n  while (P1 != P2) {\n    // åˆ°è¾¾ç»“å°¾æŒ‡å‘B\n    P1 = P1 ? P1.next : headB;\n    // åˆ°è¾¾ç»“å°¾æŒ‡å‘A\n    P2 = P2 ? P2.next : headA;\n  }\n  return P1 ? P1 : null;\n};\n\n// æ—¶é—´å¤æ‚åº¦ O(M+N)\n// ç©ºé—´å¤æ‚åº¦ O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194176957","body":"```js\nvar detectCycle = function (head) {\n  let fast = head;\n  let slow = head;\n  let iscycle = false;\n\n  while (fast && fast.next) {\n    fast = fast.next.next;\n    slow = slow.next;\n\n    if (fast === slow) {\n      iscycle = true;\n      break;\n    }\n  }\n\n  if (!iscycle) {\n    return null;\n  }\n\n  fast = head;\n  while (fast !== slow) {\n    fast = fast.next;\n    slow = slow.next;\n  }\n\n  return fast;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195607925","body":"```js\nvar ListNode = function (key, value) {\n  this.key = key;\n  this.value = value;\n  this.prev = null;\n  this.next = null;\n};\n\n/**\n * @param {number} capacity\n */\nvar LRUCache = function (capacity) {\n  this.size = capacity;\n  this.map = {};\n  this.dummyHead = new ListNode(null, null);\n  this.dummyTail = new ListNode(null, null);\n  this.dummyHead.next = this.dummyTail;\n  this.dummyTail.prev = this.dummyHead;\n};\n\nLRUCache.prototype.isFull = function () {\n  return this.size === Object.keys(this.map).length;\n};\n\nLRUCache.prototype.remove = function (node) {\n  node.prev.next = node.next;\n  node.next.prev = node.prev;\n  node.prev = null;\n  node.next = null;\n\n  return node;\n};\n\nLRUCache.prototype.toHead = function (node) {\n  const tempNode = this.dummyHead.next;\n  node.next = tempNode;\n  tempNode.prev = node;\n  this.dummyHead.next = node;\n  node.prev = this.dummyHead;\n};\n\n/**\n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function (key) {\n  if (key in this.map) {\n    const node = this.map[key];\n    this.toHead(this.remove(node));\n    return node.value;\n  } else {\n    return -1;\n  }\n};\n\n/**\n * @param {number} key\n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function (key, value) {\n  if (key in this.map) {\n    const node = this.map[key];\n    node.value = value;\n    this.toHead(this.remove(node));\n  } else {\n    if (this.isFull()) {\n      const deNode = this.dummyTail.prev;\n      const key = deNode.key;\n      delete this.map[key];\n      this.remove(deNode);\n    }\n    const node = new ListNode(key, value);\n    this.map[key] = node;\n    this.toHead(node);\n  }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196821850","body":"```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n  if (!root) {\n    return 0;\n  }\n  let depth = 0;\n  let queue = [root];\n\n  while (queue.length) {\n    let len = queue.length;\n    while(len--) {\n      const temp = queue.shift();\n      temp.left && queue.push(temp.left);\n      temp.right && queue.push(temp.right);\n    }\n    depth++;\n  }\n\n  return depth;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198274695","body":"```js\nvar isSameTree = function (p, q) {\n  if (!p && !q) {\n    return true;\n  }\n\n  if (!p || !q) {\n    return false;\n  }\n\n  if (p.val !== q.val) {\n    return false;\n  }\n\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200437607","body":"```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function (root) {\n  if (!root) return 'x';\n\n  const left = serialize(root.left);\n  const right = serialize(root.right);\n\n  return root.val + ',' + left + ',' + right;\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function (data) {\n  const arr = data.split(',');\n\n  function buildTree(list) {\n    const item = list.shift();\n    if (item === 'x') {\n      return null;\n    }\n\n    const node = new TreeNode(item);\n    node.left = buildTree(list);\n    node.right = buildTree(list);\n\n    return node;\n  }\n\n  return buildTree(arr);\n};\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201379074","body":"```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar verticalTraversal = function (root) {\n  const map = {};\n\n  const dfs = function (node, x, y) {\n    if (!node) {\n      return;\n    }\n    if (x in map) {\n      map[x].push([node.val, y]);\n    } else {\n      map[x] = [[node.val, y]];\n    }\n    node.left && dfs(node.left, x - 1, y - 1);\n    node.right && dfs(node.right, x + 1, y - 1);\n  }\n\n  dfs(root, 0, 0);\n\n  const arr = Object.entries(map).sort((a, b) => a[0] - b[0]).map(item => item[1]);\n  const ret = arr.map(item => {\n    if (item.length > 1) {\n      item.sort((a, b) => {\n        if (a[1] !== b[1]) {\n          return b[1] - a[1];\n        } else {\n          return a[0] - b[0];\n        }\n      });\n    }\n    return item.map(item => item[0]);\n  })\n\n  return ret;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202653808","body":"```js\nvar twoSum = function (nums, target) {\n  const n = nums.length;\n  const map = {};\n\n  for (let i = 0; i < n; i++) {\n    const diff = target - nums[i];\n\n    if (diff in map) {\n      return [map[diff], i];\n    }\n    map[nums[i]] = i;\n  }\n\n  return [];\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206481414","body":"```js\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n  const map = new Map();\n  const len = s.length;\n  let ans = 0;\n  let l = 0;\n\n  for (let r = 0; r < len; r++) {\n    if (map.has(s[r]) && map.get(s[r]) >= l) {\n      l = map.get(s[r]) + 1;\n    } else {\n      ans = Math.max(ans, r - l + 1);\n    }\n    map.set(s[r], r);\n  }\n\n  return ans;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207221712","body":"```js\nvar findSubstring = function(s, words) {\n  const wordSize = words[0].length;\n  const wordsLen = wordSize * words.length;\n  let map = new Map();\n  let ans = [];\n  for (let i = 0; i< words.length; i++) {\n    map.has(words[i]) ? map.set(words[i], map.get(words[i]) + 1) : map.set(words[i], 1);\n  }\n  for (let i = 0; i < s.length - wordsLen + 1; i++) {\n    const tmap = new Map(map);\n    let count = words.length;\n    for (let p = i; p < i + wordsLen; p += wordSize) {\n      const word = s.slice(p, p + wordSize);\n      if (!tmap.has(word) || tmap.get(word) <= 0) {\n        break;\n      }\n      tmap.set(word, tmap.get(word) - 1);\n      count--;\n    }\n    if (count === 0) {\n      ans.push(i);\n    }\n  }\n  return ans;\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208252080","body":"```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function(head) {\n  let fast = slow = head;\n\n  while (fast && fast.next) {\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n\n  return slow;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209427213","body":"```js\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n  let left = right = 0;\n\n  while (right < nums.length) {\n    if (right !== left && nums[left] !== nums[right]) {\n      left++;\n      nums[left] = nums[right];\n    }\n    right++;\n  }\n\n  return left + 1;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"thinkfurther":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185062953","body":"```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        import math\r\n        n = max(len(num), int(math.log10(k))+1) + 1\r\n        result = [0] * n\r\n        num = [0] * (n - len(num)) + num\r\n        \r\n        carry = 0\r\n        for i in range(n - 1, -1, -1):\r\n            result[i] = num[i] + k % 10 + carry\r\n            carry = result[i] // 10\r\n            result[i] = result[i] % 10\r\n            k = k // 10\r\n            \r\n        if result[0] == 0:\r\n            return result[1:]\r\n        else:\r\n            return result\r\n```\r\n\r\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\r\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185734047","body":"```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        left = [float('inf')] * len(s)\n        right = [float(\"inf\")] * len(s)\n        \n        index_left = []\n        index_right = []\n        \n        for idx, ch in enumerate(s):\n            if ch == c:\n                index_left.append(idx)\n                index_right.append(idx)\n        \n        for i in range(len(s)-1, -1, -1):\n            if not index_left:\n                break\n            d = i - index_left[-1]\n            left[i] = d\n            if d == 0:\n                index_left.pop()\n        \n        for i in range(len(s)):\n            if not index_right:\n                break\n            d = index_right[0] - i\n            right[i] = d\n            if d == 0:\n                index_right = index_right[1:]\n                \n        result = []\n        for i in range(len(s)):\n            result.append(min(left[i],right[i]))\n        return result\n```\næ—¶é—´å¤æ‚åº¦ï¼šO(n)\nç©ºé—´å¤æ‚åº¦ï¼šO(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186255230","body":"# Increase every number for the increment operation\n```python\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.s = []\n        self.maxSize = maxSize\n    def push(self, x: int) -> None:\n        if len(self.s) < self.maxSize:\n            self.s.append(x)\n    def pop(self) -> int:\n        if not self.s:\n            return -1\n        return self.s.pop()\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,len(self.s))):\n            self.s[i] += val\n```\næ—¶é—´å¤æ‚åº¦ï¼šO(1) for pop and push, O(n) for increment\nç©ºé—´å¤æ‚åº¦ï¼šO(1)\n\n# Increase at pop\n```python\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.s = []\n        self.maxSize = maxSize\n    def push(self, x: int) -> None:\n        if len(self.s) < self.maxSize:\n            self.s.append(x)\n    def pop(self) -> int:\n        if not self.s:\n            return -1\n        return self.s.pop()\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,len(self.s))):\n            self.s[i] += val\n```\næ—¶é—´å¤æ‚åº¦ï¼šO(1)\nç©ºé—´å¤æ‚åº¦ï¼šO(len(s))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186767291","body":"```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == ']':\n                num = ''\n                cur_s = ''\n                while stack[-1] != '[':\n                    cur_s = stack.pop() + cur_s\n                stack.pop()\n                while stack and stack[-1].isdigit():\n                    num = stack.pop() + num\n                stack.append(int(num) * cur_s)\n            else:\n                stack.append(c)\n        return ''.join(stack)\n                \n```\næ—¶é—´å¤æ‚åº¦ï¼šO(n)\nç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1187977739","body":"```python\nclass MyQueue:\n    def __init__(self):\n        self.main_s = []\n        self.alt_s = []\n\n    def push(self, x: int) -> None:\n        self.main_s.append(x)\n\n    def pop(self) -> int:\n        while len(self.main_s) != 1:\n            self.alt_s.append(self.main_s.pop())\n        result = self.main_s.pop()\n        while self.alt_s:\n            self.main_s.append(self.alt_s.pop())\n        return result\n\n    def peek(self) -> int:\n        while len(self.main_s) != 1:\n            self.alt_s.append(self.main_s.pop())\n        result = self.main_s[-1]\n        while self.alt_s:\n            self.main_s.append(self.alt_s.pop())\n        return result\n\n    def empty(self) -> bool:\n        return bool(self.main_s)\n```\næ—¶é—´å¤æ‚åº¦ï¼šO(n)\nç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189810329","body":"```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        s = []\n\n        for num in arr:\n            if s and s[-1] > num:\n                cur = s[-1]\n                while s and s[-1] > num:\n                    s.pop()\n                s.append(cur)\n            else:\n                s.append(num)\n        return len(s)\n```\næ—¶é—´å¤æ‚åº¦ï¼šO(n)\nç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190937521","body":"```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        \n        n = 0\n        current = head\n        while current.next:\n            n += 1\n            current = current.next\n        \n        tail = current\n        n = n + 1\n        \n        if k%n == 0:\n            return head\n        \n        k = n - k % n - 1\n                \n        new_tail = head\n        for _ in range(k):\n            new_tail = new_tail.next\n        \n        new_head = new_tail.next\n        new_tail.next = None\n        tail.next = head\n        \n        return new_head\n```\næ—¶é—´å¤æ‚åº¦ï¼šO(n)\nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192150377","body":"```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n\n        dummy = ListNode(0, head)\n\n        cur = dummy\n        \n        while cur.next and cur.next.next:\n            tmp = cur.next\n            tmp1 = cur.next.next.next\n            \n            cur.next = cur.next.next\n            cur.next.next = tmp\n            cur.next.next.next = tmp1\n            \n            cur = cur.next.next\n        return dummy.next\n```\næ—¶é—´å¤æ‚åº¦ï¼šO(n)\nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193061720","body":"```python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return None\n        \n        pre = None\n        fast = head\n        slow = head\n        \n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n            \n        node =TreeNode(slow.val)\n        \n        if slow == fast:\n            return node\n        \n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        \n        return node\n```\næ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)\nç©ºé—´å¤æ‚åº¦ï¼šO(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193197025","body":"```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:        \n        A = headA\n        lenA = 0\n        B = headB\n        lenB = 0\n        \n        while A:\n            lenA += 1\n            A = A.next\n        \n        while B:\n            lenB += 1\n            B = B.next\n        \n        if lenB > lenA:\n            headA , headB = headB, headA\n            lenA , lenB = lenB, lenA\n        \n        \n        for _ in range(lenA - lenB):\n            headA = headA.next\n\n        while headA and headA != headB:\n            headA = headA.next\n            headB = headB.next\n        \n        return headA\n```\næ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)\nç©ºé—´å¤æ‚åº¦ï¼šO(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193387566","body":"```python\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast = head\n        slow = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                fast = head\n                break\n        \n        if not fast or not fast.next:\n            return None\n        \n        while fast != slow:\n            slow = slow.next\n            fast = fast.next\n        return slow\n```\næ—¶é—´å¤æ‚åº¦ï¼šO(n)\nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194453410","body":"```python\nclass doublyLinkedListNode:\n    def __init__(self, key = 0, val = 0, pre_node = None, next_node = None):\n        self.key = key\n        self.val = val\n        self.pre_node = pre_node\n        self.next_node = next_node        \n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache_map = dict()\n        self.dummy_head = doublyLinkedListNode()\n        self.dummy_tail = doublyLinkedListNode()\n        self.dummy_head.next_node = self.dummy_tail\n        self.dummy_tail.pre_node = self.dummy_head        \n    \n    def remove_mode(self, node):\n        node.pre_node.next_node, node.next_node.pre_node = node.next_node, node.pre_node\n        node.pre_node, node.next_node = None, None        \n        del self.cache_map[node.key]\n        return node\n    \n    def insert_node(self, node):\n        node.next_node = self.dummy_head.next_node\n        node.pre_node = self.dummy_head\n        self.dummy_head.next_node.pre_node = node\n        self.dummy_head.next_node = node\n        self.cache_map[node.key] = node\n        return node\n        \n    def get(self, key: int) -> int:\n        if key not in self.cache_map:\n            return -1\n        node = self.cache_map[key]\n        self.remove_mode(node)\n        self.insert_node(node)\n        return node.val\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache_map:\n            node = self.cache_map[key]\n            node.val = value\n            self.remove_mode(node)\n            self.insert_node(node)\n            return\n            \n        if len(self.cache_map) >= self.capacity:\n            to_remove_node = self.dummy_tail.pre_node\n            self.remove_mode(to_remove_node)\n        new_node = doublyLinkedListNode(key = key, val = value)\n        self.insert_node(new_node)\n```\næ—¶é—´å¤æ‚åº¦ï¼šO(1)\nç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1195852688","body":"```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        \n        left_depth = self.maxDepth(root.left)\n        \n        right_depth = self.maxDepth(root.right)\n        \n        return 1 + max(left_depth, right_depth)\n```\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\nç©ºé—´å¤æ‚åº¦ï¼šO(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197088770","body":"```python\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        \n        if p and not q:\n            return False\n        \n        if not p and q:\n            return False\n        \n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\nç©ºé—´å¤æ‚åº¦ï¼šO(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198564516","body":"```python\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        return self.dfs(root,0)\n    \n    def dfs(self, root, cum):\n        if not root:\n            return 0\n        if not root.left and not root.right:\n            return cum*10 + root.val\n        \n        return self.dfs(root.left, cum*10 + root.val) + self.dfs(root.right, cum*10 + root.val)\n```\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\nç©ºé—´å¤æ‚åº¦ï¼šO(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1199852254","body":"```python\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        return self.bfs(root)\n        \n        self.dfs(root, 0)\n        return self.res\n        \n    \n    def bfs(self,root):\n        q = collections.deque()\n        q.append(root)\n        \n        left_most = root.val\n        while q:\n            left_most = q[0].val\n            n = len(q)\n            \n            for _ in range(n):\n                node = q.popleft()\n                \n                if node.left:\n                    q.append(node.left)\n                \n                if node.right:\n                    q.append(node.right)\n        \n        return left_most\n    \n    def __init__(self):\n        self.max_level = -1\n        self.res = 0\n        \n    def dfs(self, root, level):\n        if not root:\n            return\n        \n        if level > self.max_level:\n            self.max_level = level\n            self.res = root.val\n            \n        self.dfs(root.left, level + 1)\n        self.dfs(root.right, level + 1)\n```\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\nç©ºé—´å¤æ‚åº¦ï¼šO(h) for dfs, O(N) for bfs","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200287815","body":"```python\nclass Codec:\n\n    def serialize(self, root):\n        output = \"\"        \n        q = collections.deque()       \n        q.append(root)        \n        while q:\n            n = len(q)\n            \n            node = q.popleft()\n            if node:\n                output += str(node.val) + ','\n                q.append(node.left)\n                q.append(node.right)\n            else:\n                output += 'null,'\n        return output[:-1]\n        \n\n    def deserialize(self, data):\n        if not data or data == 'null':\n            return None\n        data = data.split(',')\n        node_count = len(data)\n        root = TreeNode(int(data[0]))        \n        q = collections.deque()\n        q.append(root)\n        i = 0\n        while q and i < node_count - 2:\n            node = q.popleft()\n            left = data[i + 1]\n            right = data[i + 2]\n            \n            i += 2\n            if left != 'null':\n                l_node = TreeNode(int(left))\n                node.left = l_node\n                q.append(node.left)\n            if right != 'null':\n                r_node = TreeNode(int(right))\n                node.right = r_node\n                q.append(node.right)\n        \n        return root\n```\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200706050","body":"```python\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        if not root:\n            return None\n        q = collections.deque()\n        q.append((root,0,0))\n        result = collections.defaultdict(list)\n        \n        while q:\n            n = len(q)\n            \n            for _ in range(n):\n                node, col, row = q.popleft()\n                result[(col,row)].append(node.val)                \n               \n                if node.left:\n                    q.append((node.left,col-1, row+1))\n                \n                if node.right:\n                    q.append((node.right,col+1, row+1))\n       \n        \n        sorted_result = sorted(result.items(), key = lambda x: x[0])        \n        print(sorted_result)\n        \n        final_result = []\n        current_col, _ = sorted_result[0][0]\n        current_col_data = []\n        \n        for i in range(len(sorted_result)):\n            next_col, next_row = sorted_result[i][0]\n            next_data = sorted_result[i][1]\n            \n            if next_col != current_col:\n                final_result.append(current_col_data)\n                current_col_data = sorted(next_data)\n                current_col = next_col\n            else:\n                current_col_data.extend(sorted(next_data))\n                print(current_col_data)\n        final_result.append(current_col_data)        \n        \n        return final_result\n```\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201458668","body":"```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        nums_map = dict()\n        \n        for idx, num in enumerate(nums):\n            if target - num in nums_map:\n                return [idx, nums_map[target - num]]\n            else:\n                nums_map[num] = idx\n```\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203446818","body":"```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        d = collections.Counter(nums)\n        \n        sorted_d = sorted(d.items(), key = lambda x:x[1], reverse = True)\n        \n        result = []\n        for i in range(k):\n            result.append(sorted_d[i][0])\n        \n        return result\n```\næ—¶é—´å¤æ‚åº¦ï¼šO(NlogN)\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204547887","body":"```python\nclass Solution:\n    def distance(self, p1, p2):\n        return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2\n    \n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n <= 2:\n            return 0\n        result = 0\n        for p1 in points:\n            distances = collections.defaultdict(int)\n            \n            for p2 in points:\n                current_distance = self.distance(p1,p2)\n                distances[current_distance] += 1\n                \n            for value in distances.values():\n                result += value * (value - 1)\n        \n        return result\n```\næ—¶é—´å¤æ‚åº¦ï¼šO(N^2)\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205900324","body":"```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        if not s:\n            return 0\n\n        left = 0\n        right = 0\n        current_string = set()\n        longest_substring = 0\n        while right < len(s):\n            if s[right] not in current_string:\n                current_string.add(s[right])\n                right += 1\n                longest_substring = max(longest_substring, right - left)\n                continue\n\n            while s[left] != s[right]:                \n                current_string.remove(s[left])\n                left += 1\n                \n            left += 1\n            right += 1\n\n        return longest_substring\n```\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207133801","body":"```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        if not words or not s:\n            return []\n        \n        all_words = collections.Counter(words)\n        \n        word_num = len(words)\n        word_length = len(words[0])\n        total_length = word_num * word_length\n        \n        result = []\n        for i in range(len(s) - total_length + 1):\n            has_words = collections.defaultdict(int)\n            num = 0\n            while num < word_num:\n                current_word = s[i + num * word_length : i + (num+1) * word_length]\n                if current_word in all_words:\n                    has_words[current_word] += 1\n                    if has_words[current_word] > all_words[current_word]:\n                        break\n                else:\n                    break                    \n                num += 1\n            if num == word_num:\n                result.append(i)\n                \n        return result\n```\næ—¶é—´å¤æ‚åº¦ï¼šO(M*N)\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207322725","body":"```python\nclass Solution:\n    def solve(self, nums, k):\n        def floorMod(a,b):\n            return a - a // b * b\n\n        target = sum(nums)\n\n        target = floorMod(target, k)\n        map = {0:-1}\n\n        prefix = 0\n        res = len(nums)\n\n        for i in range(len(nums)):\n            prefix += nums[i]\n            mod = floorMod(prefix, k)\n            map[mod] = i\n\n            remaining = floorMod(prefix - target, k)\n\n            if remaining in map:\n                res = min(res, i - map[remaining] )\n\n\n        return -1 if res == len(nums) else res\n```\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207488033","body":"```python\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast = head\n        slow = head\n        \n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            \n        return slow\n```\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208429406","body":"```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        n = len(nums)\n        pre = 0\n        \n        for current in range(n):\n            if nums[current] != nums[pre]:\n                pre += 1\n                nums[pre] = nums[current]                \n        return pre + 1\n```\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/42#issuecomment-1209792027","body":"```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left+right) // 2\n            \n            if nums[mid] == target:\n                return mid\n            \n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return left\n```\næ—¶é—´å¤æ‚åº¦ï¼šO(logN)\nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wengzhouyunfan":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185063354","body":"\n```java\n  // key point : A > 0  add digit by digit\n  // input : int A[], int k     return: int []\n  // A.length <= 10000     T: O(n) < n^2\n  // brute force : \n  //   1) get last digit from k and cur A[i]; \n  //   2) add to array, renew carry and digit; \n  //   3) check carry, return array;\n\t  public int[] addInteger(int[]A, int K){\n\t    LinkedList<Integer> list = new LinkedList<Integer>();\n\t    int curA = A.length - 1;\n\t    int curK = K;\n\t    int carry = 0;\n\t    while(curA >= 0 || curK != 0){\n\t      int sum = curA < 0 ? carry + curK%10 : carry + A[curA] + curK%10;\n\t      int digit = sum % 10;\n\t      carry = sum / 10;\n\t      list.add(digit);  // add to end O(1) \n\t      curK/=10;\n\t      curA--;\n\t    }\n\t    if(carry != 0) list.addFirst(1); // add to head O(1)\n\t    return list.stream().mapToInt(x -> x).toArray(); // can't directly turn into primitive type O(n)\n\t  }\n```\nT: O(n)\nS: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185992291","body":"```java\n// S > 0   shortest dist   DP \n// input : char S[], char C   return int[]\n// A.length <= 10000   O(n) < n^2\n// brute force : \n//\t 1) find every s[i] == target, fill to left and right with dist until reach next target;  \n//\t 2) while finish filling, stop and find next target; \n//\t 3) finish filling and return res;\n//\n// improve:\n//   1) traverse from left to right, get left shortest dist from every target\n//   2) traverse from right to left, get right shortest dist from every target \n//   3) compare left and right and return res;\n\t  public int[] shortestToChar(char[]S, char C){\n\t\t  if(S.length == 1) return new int[] {0};\n\t\t  int[] res = new int[S.length];\n\t\t  Arrays.fill(res, S.length);\n\t\t  for(int i = 0, c = -1; i < S.length; i++){\n\t\t\t  if(S[i] == C) {\n\t\t\t\t  c = i;\n\t\t\t  }\n\t\t\t  if(c != -1) {\n\t\t\t\t  res[i] = i - c;\n\t\t\t  }\n\t\t  }\n\t\t  for(int i = S.length -1, c = -1; i >= 0; i--) {\n\t\t\t  if(S[i] == C) {\n\t\t\t\t  c = i;\n\t\t\t  }\n\t\t\t  if(c != -1) {\n\t\t\t\t  res[i] = Math.min(c - i, res[i]);\n\t\t\t  }\n\t\t  }\n\t\t  return res;\n\t  }\n```\nT:O(n)\nS:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186550641","body":"```java\n// use array to stimulate stack\n// every method must <= O(n^2)\nclass CustomStack {\n\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top < stack.length - 1) stack[++top] = x;\n    }\n    \n    public int pop() {  \n        return  top <= -1 ? -1 : stack[top --];\n    }\n    \n    public void increment(int k, int val) {\n        int len = Math.min(k, stack.length);\n        for (int i = 0; i < len; i++) {\n            stack[i] += val;\n        }      \n    }\n}\n```\nT:\npush(): O(1)\npop(): O(1)\nincrement(): O(n)\nS: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187576674","body":"\n```java\n    // key point : stack  decode string\n    public String decodeString(String s) {\n        String res = \"\";\n        String repeat = \"\";\n        Deque<String> stack = new ArrayDeque<>();\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                stack.push(res.toString());\n                res = \"\";\n                stack.push(repeat);\n                repeat = \"\";\n            }\n            else if(c == ']') {\n                String tmp = \"\";\n                int cur_rpeat = Integer.parseInt(stack.pop());\n                for(int i = 0; i < cur_rpeat; i++) tmp += res;\n                res = stack.pop() + tmp;\n            }\n            else if(c >= '0' && c <= '9') repeat += c ;\n            else res += c;\n        }\n        return res.toString();\n    }\n```\nT:O(n)\nS:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188415329","body":"```java\n\n// design data structure\n// input integer 1 - 9    S <= O(n^4)\nclass MyQueue{\n    Stack<Integer> out, in;\n    public MyQueue() {\n        in = new Stack<>();\n        out = new Stack<>();\n    }\n    \n    public void push(int x) {\n        in.push(x); // O(1)\n    }\n    \n    public int pop() {\n        if (out.isEmpty()) {\n            while (!in.isEmpty()) out.push(in.pop());\n        } // O(n)\n        return out.pop();\n    }\n    \n    public int peek() {\n        if (out.isEmpty()) {\n            while (!in.isEmpty()) out.push(in.pop());\n        }//O(n)\n        return out.peek();\n    }\n    \n    public boolean empty() {//O(1)\n        return out.isEmpty() && in.isEmpty();\n    }\n}\n// T: push: O(1), peek: O(n), pop: O(n), empty: O(1) \n// Amortized T: push: O(1), peek: O(1), pop: O(1), empty: O(1) \n// S: O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190461632","body":"find chunck  =>   check sum\n```java\n    public int maxChunksToSorted(int[] arr) {\n        int curMax = arr[0];\n        Deque<Integer> stack = new ArrayDeque<>();\n        stack.push(arr[0]);\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] >= stack.peek()){\n                stack.push(arr[i]);\n                curMax = arr[i];\n            }else {\n                stack.pop();\n                while (!stack.isEmpty()){\n                    if (arr[i]>=stack.peek()){\n                        stack.push(curMax);\n                        break;\n                    }\n                    stack.pop();\n                }\n                if (stack.isEmpty()){\n                    stack.push(curMax);\n                }\n            }\n        }\n        return stack.size();\n    }\n//T:O(n) S:O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191590901","body":"```java\n// use two pointers to locate the k+1 element from right\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null) return head;\n        ListNode cur = head, tail = head;\n        int len = 1;\n        while (cur.next != null) {\n            cur = cur.next;\n            len++;\n        }\n        cur.next = head;\n        k %= len;\n        for (int i = 0; i < len - k - 1; i++) {\n            tail = tail.next;\n        }\n        cur = tail.next;\n        tail.next = null;\n        return cur;\n    }\n}\n// T:O(n)  S:O(1)\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193138292","body":"```java\n// construct tree   BST  \n// T < O(n^2)  get mid\nclass Solution {\n\t  public TreeNode sortedListToBST(ListNode head) {\n\t      if(head == null) return null;\n\t      return buildTree(head,null);\n\t  }\n\t  private TreeNode buildTree(ListNode head, ListNode tail){\n\t      if(head == tail) return null;\n\t      ListNode fast = head, slow = head;\n\t      while(fast != tail && fast.next != tail){// O(n/2)\n\t          fast = fast.next.next;\n\t          slow = slow.next;\n\t      }\n\t      TreeNode root = new TreeNode(slow.val);\n\t      root.left = buildTree(head, slow); \n\t      root.right = buildTree(slow.next, tail);\n\t      return root;\n\t  }\n\t}\n// T:O(nlogn)  n(num of nodes for recurtion tree) * logn (accumulated binary search  operation)\n// S:O(logn)  depth of call stack\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193990889","body":"\n```java\n// two pointer approach \npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast != null && fast.next != null){\n            fast = fast.next.next;\n            slow = slow.next;\n            if(slow == fast){\n                fast = head;\n                while(slow != fast){\n                    slow = slow.next;\n                    fast = fast.next;\n                }\n                return slow;\n            }\n        }\n        return null;\n    }\n}\n// T: O(n)  S: O(1)\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198108096","body":"```java\n// top-down \nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if(p == null || q == null ) return false;\n        if(p.val != q.val) return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n// T:O(n)   S:O(h) logn - n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199375456","body":"```java\n// top down recursion\nclass Solution {\n\tpublic int sumNumbers(TreeNode root) {\n\t\tint[] sum = new int[] {0};\n\t\tbackTracking(root, 0, sum);\n\t\treturn sum[0];\n\t}\n\n\tprivate void backTracking(TreeNode root, int curSum, int[] sum) {\n\t\tif (root == null) return;\n\t\tcurSum = curSum * 10 + root.val;\n\t\tif (root.left == null && root.right == null) {\n\t\t\tsum[0] += curSum;\n\t\t\treturn;\n        }\n\t\t\tbackTracking(root.left, curSum, sum);\n\t\t\tbackTracking(root.right, curSum, sum);\n\t}\n}\n\n//T:(n)   S:(h)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200149962","body":"```java\n// level order traversal\n    public int findBottomLeftValue(TreeNode root) {\n\tint level = 0;\n\tint res = -1;\n\tDeque<TreeNode> q = new ArrayDeque<>();\n\tq.offer(root);\n\twhile(!q.isEmpty()){\n\t\tint size = q.size();\n\t\tfor(int i = 0 ;i < size; i++){\n\t\t\tTreeNode cur = q.poll();\n\t\t\tif(i == 0) res = cur.val;\n\t\t\tif(cur.left != null) q.offer(cur.left);\n\t\t\tif(cur.right!= null) q.offer(cur.right);\n        }\n    }\n        return res;\n    }\n// T:O(n) S:O(size) Maximum input in the while loop\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206451777","body":"```java\n//åˆ©ç”¨mapä½œä¸ºå­—å…¸è¿›è¡Œè®¡æ•°åˆ¤å®š\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int res = 0;\n        int l = 0;\n        int r = 0;\n       while(r < s.length()){\n            char cur = s.charAt(r);\n            map.put(cur, map.getOrDefault(cur, 0) + 1);\n            if(map.size() == r - l + 1){\n                res = Math.max(res, r - l + 1);\n            }\n            while(r - l + 1 > map.size()){\n                char head = s.charAt(l);                \n                map.put(head, map.get(head) - 1);\n                if(map.get(head) == 0){\n                    map.remove(head);\n                }\n                l++;\n            }\n           r++;\n        }\n        return res;\n}\n}\n// T:O(n)   S:O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207234149","body":"\n```java\n// for every possible ending index we want to find every valid index such that subString [end - allwordlen + 1, end] is valid\nclass Solution {\n    public static List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> res = new ArrayList<>();\n        if(words == null || words.length == 0 || s.length() == 0) return res;\n        int wordLen = words[0].length();\n        int numWord = words.length;\n        int windowLen = wordLen * numWord;\n        int sLen = s.length();\n        HashMap<String, Integer> map = new HashMap<>();\n        for(String word : words) map.put(word, map.getOrDefault(word, 0) + 1);\n\n        for(int i = 0; i < wordLen; i++) {  \n            HashMap<String, Integer> curMap = new HashMap<>();\n            for(int j = i, count = 0, start = i; j + wordLen <= sLen; j += wordLen) {  \n                if(start + windowLen > sLen) break;\n                String word = s.substring(j, j + wordLen);\n                if(!map.containsKey(word)) {\n                    curMap.clear();\n                    count = 0;\n                    start = j + wordLen;\n                }\n                else {\n                    if(j == start + windowLen) { \n                        String preWord = s.substring(start, start + wordLen);\n                        start += wordLen;\n                        int val = curMap.get(preWord);\n                        if(val == 1) curMap.remove(preWord);\n                        else curMap.put(preWord, val - 1);\n                        if(val - 1 >= map.get(preWord)) count--;  \n                    }\n                    \n                    curMap.put(word, curMap.getOrDefault(word, 0) + 1);\n                    if(curMap.get(word) > map.get(word)) count++;  \n                    if(count == 0 && start + windowLen == j + wordLen) {\n                        res.add(start);\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}\nT:O(sLen * wordLen)\nS:O(wordLen * wordNum)\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208564117","body":"```java\n//two pointer\nclass Solution {\n    public int removeDuplicates(int[] nums) {    \n      int i = 1;\n      int j = 1;\n      while(j < nums.length){        \n          if(nums[j] != nums[i - 1]){\n                int tmp = nums[i];\n                nums[i] = nums[j];\n                nums[j] = tmp;\n                i++;\n          }\n          j++;\n      }   \n        return i;\n    }\n}\n//T:O(N)  S:O(1)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whisht":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185072053","body":"1. å°† num è½¬ä¸º æ•°å­—\r\n``` python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        t = 10\r\n        n = len(num)\r\n        res = 0\r\n        for i in range(n):\r\n            res += t**i*num[n-i-1]\r\n        res += k\r\n        print(res)\r\n        out = []\r\n        while res:\r\n            out.append(res%10)\r\n            res = res//10\r\n        return out[::-1]\r\n```\r\næ—¶é—´å¤æ‚åº¦ï¼š$O(N)$\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(N)$\r\n\r\n2. é€ä½ç›¸åŠ \r\n>  ![image](https://user-images.githubusercontent.com/16497652/179130663-29ae5da6-b53c-4569-bd7c-327bf30c97e6.png)\r\n> [https://leetcode.cn/problems/add-to-array-form-of-integer/solution/989-ji-zhu-zhe-ge-jia-fa-mo-ban-miao-sha-8y9r/](url)\r\n\r\n``` python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        carry = 0\r\n        res = []\r\n        if len(num)<len(str(k)):\r\n            num = [0]*(len(str(k))-len(num))+num\r\n        n = max(len(str(k)),len(num))-1\r\n        while n>=0 or k:\r\n            sums = num[n]+k%10+carry\r\n\r\n            basic = sums%10\r\n            carry = sums//10\r\n            res.insert(0,basic)\r\n\r\n            n -= 1\r\n            k//=10\r\n        if carry:\r\n            res.insert(0,carry)\r\n            return res\r\n        else:\r\n            return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186098194","body":"* ä»å·¦åˆ°å³æ­£åºéå†ä¸€æ¬¡å­—ç¬¦ä¸² `s`ï¼Œè®°å½•å­—ç¬¦ä¸² `s` ä¸­æ¯ä¸ªå­—ç¬¦åˆ°å·¦ä¾§å­—ç¬¦ `c` çš„è·ç¦»\n* ä»å³åˆ°å·¦é€†åºéå†ä¸€æ¬¡å­—ç¬¦ä¸² `s`ï¼Œè®°å½•å­—ç¬¦ä¸² `s` ä¸­æ¯ä¸ªå­—ç¬¦åˆ°å³ä¾§å­—ç¬¦ `c` çš„è·ç¦»\néœ€è¦è€ƒè™‘çš„æ˜¯æœ€å¼€å§‹æ²¡æœ‰å‡ºç° `c` æ—¶ï¼Œ`c` çš„ä½ç½®è¯¥å¦‚ä½•å¤„ç†ï¼Œè¦ä¿è¯ä½¿ç”¨è¯¥ä½ç½®è®¡ç®—åçš„è·ç¦»ä¸ä¼šå½±å“æœ€ç»ˆçš„ç»“æœã€‚\n* åˆå§‹åŒ– `s` ä¸­å„å­—ç¬¦çš„è·ç¦»ä¸ºæ— ç©·å¤§ï¼ˆ s é•¿åº¦ï¼‰\n* æ­£åºéå†è®°æœªå‡ºç°`c`çš„ä½ç½®ä¸º `-1`\n* é€†åºéå†è®°æœªå‡ºç°`c`çš„ä½ç½®ä¸º `n`\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        res = [n+1]*n\n        idx = -1\n        for i in range(n):  # å·¦ä¾§ c ä½ç½®\n            if s[i]==c:\n                idx = i\n            if idx!=-1:\n                res[i] = i - idx\n        idx = n\n        for i in range(n-1,-1,-1): # å³ä¾§ c ä½ç½®\n            if s[i] == c:\n                idx = i\n            if idx!= n:\n                res[i]= min(idx - i,res[i])\n        return res\n        \n```\n## å¤æ‚åº¦\n* æ—¶é—´å¤æ‚åº¦ï¼šéå†`s`å³å¯ï¼Œ$O(N)$\n* ç©ºé—´å¤æ‚åº¦ï¼š å’Œ`s`ç­‰é•¿çš„ç»“æœæ•°ç»„ï¼Œ$O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186423067","body":"``` python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.size = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack)<self.size:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if len(self.stack)>0:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack)<k:\n            self.stack = [i+val for i in self.stack]\n        else:\n            self.stack[:k] = [i+val for i in self.stack[:k]]\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186677475","body":"### æ€è·¯\nå°†æ¯ä¸ªå­—ç¬¦å…¥æ ˆï¼Œå½“é‡åˆ°`']'`æ—¶å‡ºæ ˆï¼Œç›´è‡³é‡åˆ°`'['`ï¼Œ`'['`å‰çš„æ‰€æœ‰æ•°å­—å‡ºæ ˆï¼Œå³ä¸º`k`ï¼Œå°†å‡ºæ ˆå¾—åˆ°çš„æ‹¬å·å†…æ‰€æœ‰å­—ç¬¦é‡å¤ `k`æ¬¡ï¼Œå…¥æ ˆã€‚\n### ä»£ç \n``` python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        res = \"\"\n        for i in s:\n            if i == \"]\":\n                tmp = stack.pop()\n                ch = \"\"\n                while tmp != \"[\":\n                    ch = tmp + ch\n                    tmp = stack.pop()\n                time = 0\n                c = 0\n                while stack and stack[-1].isdigit():\n                    t1 = stack.pop()\n                    time += int(t1) * 10 ** c\n                    c+=1\n                ch = ch * time\n                stack.append(ch)\n            else:\n                stack.append(i)\n        if stack:\n            res = \"\".join(i for i in stack)\n        return res\n```\n### å¤æ‚åº¦\n* æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$ï¼Œéœ€è¦éå†ä¸€éå­—ç¬¦\n* ç©ºé—´å¤æ‚åº¦ï¼š$O(N)$ï¼Œä¸»è¦æ¥æºäºæ ˆ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188499379","body":"## æ€è·¯\nç”¨ä¸¤ä¸ªæ ˆå®ç°é˜Ÿåˆ—ã€‚ä¸€ä¸ªæ ˆæ‰§è¡Œ `push`æ“ä½œï¼Œå¦ä¸€ä¸ªæ ˆæ‰§è¡Œ `pop` å’Œ `peek` æ“ä½œã€‚å½“é˜Ÿåˆ—å‡ºé˜Ÿæ—¶ï¼Œå°†`push`åˆ°ç¬¬ä¸€ä¸ªæ ˆçš„æ‰€æœ‰å…ƒç´ å‡ºæ ˆè‡³ç¬¬äºŒä¸ªæ ˆï¼Œæ ˆä¸­å…ƒç´ å³ä¸ºç¬¬ä¸€ä¸ªæ ˆçš„é€†åºæ’åˆ—ï¼Œæ ˆé¡¶å…ƒç´ å³ä½¿é˜Ÿå¤´å…ƒç´ ã€‚\n## ä»£ç \n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.inqueue = []\n        self.outqueue = []\n\n    def push(self, x: int) -> None:\n        self.inqueue.append(x)\n\n    def pop(self) -> int:\n        if not self.outqueue:\n            while self.inqueue:\n                self.outqueue.append(self.inqueue.pop())\n        return self.outqueue.pop()\n\n    def peek(self) -> int:\n        if not self.outqueue:\n            while self.inqueue:\n                self.outqueue.append(self.inqueue.pop())\n        return self.outqueue[-1]\n\n    def empty(self) -> bool:\n        if not self.inqueue and not self.outqueue: # ä¸¤ä¸ªæ ˆå‡ä¸ºç©ºæ—¶\n            return True\n        else:\n            return False\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n## å¤æ‚åº¦\n* ç©ºé—´å¤æ‚åº¦ï¼š $2N \\rightarrow O(N)$\n* æ—¶é—´å¤æ‚åº¦ï¼š\n    * å…¥é˜Ÿï¼š$O(1)$\n    * å‡ºé˜Ÿï¼š$O(N)$\n    * peekï¼š$O(N)$\n    * emptyï¼š$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189804822","body":"## æ€è·¯\n* ä»é¢˜ç›®å¯çŸ¥å·¦ä¾§å—çš„æœ€å¤§å€¼åº”å°äºå³ä¾§å—çš„æœ€å°å€¼ï¼Œä»è€Œè®°å½•ä¸‹æ¯ä¸€ä¸ªå±€éƒ¨æœ€å¤§å€¼å³æ˜¯ç­”æ¡ˆã€‚\n* æ¯ä¸ªå—çš„æœ€å¤§å€¼ä»å·¦åˆ°å³é¡ºåºé€’å¢ï¼Œä½¿ç”¨å•è°ƒé€’å¢æ ˆï¼ˆå…¥æ ˆå…ƒç´ å¤§äºç­‰äºæ ˆä¸­æ‰€æœ‰å…ƒç´ ï¼‰è¿›è¡Œè®°å½•ã€‚\n* ç”±äºå•è°ƒé€’å¢æ ˆæ¯ä¸ªå…ƒç´ å…¥æ ˆæ—¶éƒ½è¦æŠŠæ¯”å½“å‰å…ƒç´ å¤§çš„æ‰€æœ‰å€¼å‡ºæ ˆåå†å…¥æ ˆï¼Œä¿®æ”¹åŸå§‹é€’å¢æ ˆä¸ºå±€éƒ¨æœ€å¤§å€¼å…¥æ ˆå³å¯ã€‚\n## ä»£ç \n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: [int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]: \n                head = stack.pop()\n                while stack and num < stack[-1]: \n                    stack.pop()\n                stack.append(head)\n            else: stack.append(num)\n#        print(stack)\n        return len(stack)\n```\n## å¤æ‚åº¦\n* T: $O(N)$\n* S: $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190931989","body":"## æ€è·¯\n* å°†é“¾è¡¨é¦–å°¾ä¸²è”å½¢æˆå¾ªç¯é“¾è¡¨\n* æ—‹è½¬ k æ¬¡åçš„å°¾ç»“ç‚¹ä½ç½®ä¸º $(len(link) - k)\\% len(link)$ï¼Œä»è¯¥ä½ç½®æ–­å¼€ï¼Œå–è¯¥ä½ç½®ä¸‹ä¸ªç»“ç‚¹ä¸ºå¤´èŠ‚ç‚¹å³å¯ã€‚\n## ä»£ç \n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return None\n        length = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            length+=1\n        target = (length-k)%length \n        # print(target)\n        cur.next = head\n        # cur = head\n        for _ in range(target):\n            cur = cur.next\n        head = cur.next\n        cur.next = None\n        return head\n```\n## å¤æ‚åº¦\n* T: $O(N)$\n* S:$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192086784","body":"## æ€è·¯\r\né“¾è¡¨ä¸­é—´äº¤æ¢ä¸¤ä¸ªç»“ç‚¹`->a->b->`éœ€è¦ç”¨åˆ°ä¸‰ä¸ªç»“ç‚¹\r\n* è¦äº¤æ¢çš„ä¸¤ä¸ªç»“ç‚¹ `a,b`;\r\n* `a` å‰é¢çš„ç»“ç‚¹ `pre`ã€‚\r\näº¤æ¢æ“ä½œæ—¶ **ä¿®æ”¹æœªæ ‡è®°çš„ç»“ç‚¹`b.next`è¦å…ˆæŒ‡å‘`b.next`**ï¼Œé˜²æ­¢ä¸¢å¤±é“¾æ¥ ï¼Œä¹Ÿå°±æ˜¯ 1 å¿…é¡»åœ¨ 2ä¹‹å‰æ‰§è¡Œï¼Œå…¶ä½™å¯ä»»æ„äº¤æ¢å…ˆåé¡ºåºï¼Œå¦‚ `1->3->2`ï¼š\r\n1. `a.next = b.next `\r\n2.  `b.next = a`\r\n3. ` pre.next = b`\r\n## ä»£ç \r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        pre = ListNode()\r\n        pre.next = head\r\n        st = pre\r\n        slow,fast = head,head.next\r\n        while slow and fast:\r\n            # print(f\"{pre.val}-{slow.val}-{fast.val}\")\r\n            slow.next = fast.next\r\n            fast.next = slow\r\n            pre.next = fast\r\n            if slow.next:\r\n                pre = slow\r\n                slow = slow.next\r\n                fast = slow.next\r\n            else:\r\n                break\r\n        return st.next\r\n```\r\nç²¾ç®€ç‰ˆ\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n\r\n        st=pre = ListNode()\r\n        pre.next = head \r\n        while pre.next and pre.next.next:\r\n\r\n            slow,fast = pre.next, pre.next.next\r\n\r\n            slow.next = fast.next\r\n            fast.next = slow\r\n            pre.next = fast\r\n\r\n            pre = slow\r\n\r\n        return st.next\r\n````\r\n## å¤æ‚åº¦\r\n* T:$O(N)$\r\n* S:$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193122006","body":"## æ€è·¯\nä¸­åºéå† + äºŒåˆ†\n``` python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def getLength(head: ListNode) -> int:\n            ret = 0\n            while head:\n                ret += 1\n                head = head.next\n            return ret\n        \n        def buildTree(left: int, right: int) -> TreeNode:\n            if left > right:\n                return None\n            mid = (left + right + 1) // 2\n            root = TreeNode()\n            root.left = buildTree(left, mid - 1)\n            nonlocal head\n            root.val = head.val\n            head = head.next\n            root.right = buildTree(mid + 1, right)\n            return root\n        \n        length = getLength(head)\n        return buildTree(0, length - 1)\n```\n## å¤æ‚åº¦\nT: $O(N)$\nS: $O\\log(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193263695","body":"## æ€è·¯\r\nä¸å¤±ä¸€èˆ¬æ€§ï¼Œå‡è®¾é“¾è¡¨ `headA` æ¯”é“¾è¡¨ `headB` é•¿ï¼Œè®°å½•ä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦å·® $ diff = l_a - l_b$ï¼Œå°† `a` å‘å‰ç§»åŠ¨ $diff$ æ­¥ï¼Œä¿è¯å‰©ä½™é•¿åº¦å’Œ `b` ç›¸ç­‰ï¼Œç„¶åäºŒè€…åŒæ—¶å‘å‰ç§»åŠ¨ï¼Œè‹¥èƒ½æŒ‡å‘åŒä¸€ç»“ç‚¹åˆ™è¿”å›è¯¥ç»“ç‚¹å³å¯ï¼Œå¦åˆ™äºŒè€…æ²¡æœ‰ç›¸äº¤ç»“ç‚¹ã€‚\r\n## ä»£ç \r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        dummy1,dummy2 = ListNode(),ListNode()\r\n        dummy1.next = headA\r\n        dummy2.next = headB\r\n        p1,p2 = dummy1,dummy2\r\n\r\n        while p1.next and p2.next:\r\n            p1 = p1.next\r\n            p2 = p2.next\r\n        \r\n        diff1 = 0\r\n        while p1.next: # len(p1) > len(p2)\r\n            p1 = p1.next\r\n            diff1 += 1\r\n        \r\n        diff2 = 0\r\n        while p2.next:\r\n            p2 = p2.next\r\n            diff2 +=1\r\n        \r\n        p1,p2 = dummy1,dummy2\r\n        while diff1>0:\r\n            p1 = p1.next\r\n            diff1 -= 1\r\n        while diff2>0:\r\n            p2 = p2.next\r\n            diff2 -= 1\r\n\r\n        \r\n        while p1.next and p2.next:\r\n            # print(f\"{p1} {p2} {p1==p2}\")\r\n            if p1.next == p2.next:\r\n                return p1.next\r\n            else:\r\n                p1 = p1.next\r\n                p2 = p2.next\r\n        return None\r\n ```\r\n## å¤æ‚åº¦ï¼š\r\nT: $O(m+n)$\r\nS: $O(1)$\r\n## ä¼˜åŒ–ç‰ˆæœ¬\r\n### æ€è·¯\r\né“¾è¡¨ `headA` å’Œ `headB` çš„é•¿åº¦åˆ†åˆ«æ˜¯ $m$ å’Œ $n$ã€‚å‡è®¾é“¾è¡¨ `headA` çš„ä¸ç›¸äº¤éƒ¨åˆ†æœ‰ $a$ ä¸ªèŠ‚ç‚¹ï¼Œé“¾è¡¨ `headB` çš„ä¸ç›¸äº¤éƒ¨åˆ†æœ‰ $b$ ä¸ªèŠ‚ç‚¹ï¼Œä¸¤ä¸ªé“¾è¡¨ç›¸äº¤çš„éƒ¨åˆ†æœ‰ $c$ ä¸ªèŠ‚ç‚¹ï¼Œåˆ™æœ‰ $a+c=m$ï¼Œ$b+c=n$ã€‚\r\nå½“ `a` ç§»åŠ¨ $a+c+b$, `b` ç§»åŠ¨ $b+c+a$ å**äºŒè€…ç§»åŠ¨ç›¸åŒæ­¥æ•°**ï¼Œè‹¥æŒ‡å‘åŒä¸€ç»“ç‚¹ï¼Œåˆ™ç›¸äº¤ï¼Œå¦åˆ™ä¸ç›¸äº¤ã€‚\r\n### ä»£ç \r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        if not headA or not headB:\r\n            return None\r\n        a, b = headA, headB\r\n        while a != b:\r\n            a = a.next if a else headB\r\n            b = b.next if b else headA\r\n        return a\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193997986","body":"## æ€è·¯\nç¯é•¿å‡å»å…¥ç¯ç‚¹åˆ°ç›¸é‡ä½ç½®çš„é•¿åº¦ç­‰äºå¤´ç»“ç‚¹åˆ°å…¥ç¯ç‚¹çš„è·ç¦»ã€‚\n## ä»£ç \n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow,fast = head,head\n        while True:\n            if not fast or not fast.next:\n                return None\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                break\n        fast = head\n        while slow!=fast:\n            slow = slow.next\n            fast = fast.next\n        return slow\n```\n## å¤æ‚åº¦ï¼š\n* T: $O(N)$\n* S: $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195104051","body":"## æ€è·¯\né‡‡ç”¨å“ˆå¸Œé“¾è¡¨å®ç°ï¼Œè¡¨å¤´æ˜¯æœ€è¿‘ä½¿ç”¨çš„å…ƒç´ ï¼Œè¡¨å°¾æ˜¯æœ€è¿œä½¿ç”¨çš„å…ƒç´ ã€‚\npython ä¸­ä½¿ç”¨ `collections.Ordereddict` å®ç°ï¼š\n* `get(key)`\n  * è‹¥`key`åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œæ¯æ¬¡è®¿é—® `key` æ—¶ï¼Œå°† `key` ç§»åŠ¨è‡³é“¾è¡¨å¤´ï¼›\n* `put(key, val)`\n  * è‹¥å“ˆå¸Œè¡¨ä¸æ»¡ï¼Œç›´æ¥æ’å…¥å“ˆå¸Œè¡¨ï¼Œå¹¶å°†`key`ç§»åŠ¨è‡³é“¾è¡¨å¤´ï¼›\n  * è‹¥å“ˆå¸Œè¡¨å·²æ»¡\n    * è‹¥ `key` åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œæ›¿æ¢ `key` çš„å€¼å³å¯;\n    * è‹¥ä¸åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œåˆ é™¤é“¾è¡¨å°¾éƒ¨å…ƒç´ ï¼Œå†æ’å…¥ `{key: val}`ã€‚\n## ä»£ç \n```python\nfrom collections import OrderedDict\n\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.dict = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key not in self.dict:\n            return -1\n        else:\n            self.dict.move_to_end(key)\n            return self.dict[key]\n\n    def put(self, key: int, value: int) -> None:\n        self.dict[key] = value\n        self.dict.move_to_end(key)\n        if len(self.dict) > self.capacity:\n            self.dict.popitem(last=False)\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197606233","body":"## äºŒå‰æ ‘çš„ç¡®å®š\n### æ€è·¯\n* ç»™å®šä¸€æ£µäºŒå‰æ ‘ï¼Œå…¶å‰åºéå†/ä¸­åºéå†/ååºéå†çš„åºåˆ—æ˜¯å”¯ä¸€çš„\n* å¯ä»¥é€šè¿‡å‰ä¸­åä¸‰ç§éå†çš„é¡ºåºå”¯ä¸€ç¡®å®šä¸€æ£µäºŒå‰æ ‘ï¼š\n  * å‰åºéå†+ä¸­åºéå†\n  * ä¸­åºéå†+ååºéå†\n\nä»è€Œï¼Œç»™å®šä¸¤æ£µæ ‘ï¼Œå¦‚æœå…¶å‰åºéå†çš„ç»“æœå’Œä¸­åºéå†çš„ç»“æœéƒ½ä¸€æ ·çš„è¯ï¼Œé‚£ä¹ˆè¿™ä¸¤æ£µæ ‘çš„ç»“æ„æ˜¯ä¸€æ ·çš„ã€‚\n\n### ä»£ç \n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        p_pre_res, p_in_res = [], []\n        q_pre_res, q_in_res = [], []\n        self.preorderTraversal(p, p_pre_res)\n        self.inorderTraversal(p, p_in_res)\n        self.preorderTraversal(q, q_pre_res)\n        self.inorderTraversal(q, q_in_res)\n        if p_pre_res == q_pre_res and p_in_res == q_in_res:\n            return True\n        else:\n            return False\n\n    def preorderTraversal(self, p: TreeNode, res=[]):\n        if not p:\n            res.append(None)\n            return\n        res.append(p.val)\n        self.preorderTraversal(p.left, res)\n        self.preorderTraversal(p.right, res)\n\n    def inorderTraversal(self, p: TreeNode, res=[]):\n        if not p:\n            res.append(None)\n            return\n        self.inorderTraversal(p.left, res)\n        res.append(p.val)\n        self.inorderTraversal(p.right, res)\n```\n\n#### ä¼˜åŒ–éå†ä»£ç \n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n\n        p_pre_res = self.preorderTraversal(p)\n        p_in_res = self.inorderTraversal(p)\n        q_pre_res = self.preorderTraversal(q)\n        q_in_res = self.inorderTraversal(q)\n        print(f\"{p_pre_res} {q_pre_res}\")\n        print(f\"{p_in_res} {q_in_res}\")\n        if p_pre_res == q_pre_res and p_in_res == q_in_res:\n            return True\n        else:\n            return False\n\n    def preorderTraversal(self, p: TreeNode):\n        if not p:\n            return [None]\n        return (\n            [p.val] + self.preorderTraversal(p.left) + self.preorderTraversal(p.right)\n        )\n\n    def inorderTraversal(self, p: TreeNode):\n        if not p:\n            return [None]\n        return self.inorderTraversal(p.left) + [p.val] + self.inorderTraversal(p.right)\n```\n### å¤æ‚åº¦\n* T: $O(\\max\\{n_p,n_q\\})$ï¼Œéœ€è¦éå†ä¸¤ä¸ªäºŒå‰æ ‘ï¼Œå–è¾ƒå¤§å€¼\n* S: $O(\\max\\{h_p,h_q\\})$ï¼Œå–è¾ƒæ·±è€…\n\n## åŒæ—¶éå†ä¸¤æ£µæ ‘\n### æ€è·¯\nåŒæ—¶å¯¹ä¸¤æ£µæ ‘è¿›è¡Œéå†ï¼Œå¦‚æœéå†è¿‡ç¨‹ä¸­æ‰€æœ‰ç»“ç‚¹å€¼å…¨éƒ¨ä¸€è‡´ï¼Œåˆ™ä¸¤æ£µæ ‘ç»“ æ„ä¸€è‡´ã€‚\n> https://leetcode.cn/problems/same-tree/solution/xie-shu-suan-fa-de-tao-lu-kuang-jia-by-wei-lai-bu-/\n\n### ä»£ç \n```python\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:  # äºŒè€…å‡ä¸ºç©º\n            return True\n        if (not p and q) or (p and not q):  # ä¸€ä¸ªä¸ºç©ºï¼Œå¦ä¸€ä¸ªéç©º\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198926748","body":"é€’å½’åˆ†è§£\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        return self.preorderTraversal(root,0)\n    \n    def preorderTraversal(self,root,tmp=0):\n        if not root:return 0\n        if not root.left and not root.right:return tmp*10+root.val\n        return self.preorderTraversal(root.left,tmp*10+root.val) + self.preorderTraversal(root.right,tmp*10+root.val)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200122628","body":"## å¹¿åº¦ä¼˜å…ˆæœç´¢\n### æ€è·¯\n* å±‚åºéå†æ—¶ï¼Œæ¯å±‚æŒ‰**ä»å³åˆ°å·¦**é¡ºåºè¿›è¡Œï¼Œåˆ™è¯¥å±‚æœ€åä¸€ä¸ªç»“ç‚¹ï¼Œåˆ™æ˜¯è¯¥å±‚æœ€å·¦ç»“ç‚¹ã€‚\n* ä»è€Œæœ€å·¦ä¸‹ç»“ç‚¹ä¸ºå±‚åºéå†çš„æœ€åä¸€ä¸ªç»“ç‚¹\n### ä»£ç \n```python\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        return self.levelTraversal(root)\n\n    def levelTraversal(self, root):\n        queue = [root]\n        tmp = None\n        while queue:\n            for _ in range(len(queue)):\n                # print([i.val for i in queue])\n                tmp = queue.pop(0)\n                if tmp.right:\n                    queue.append(tmp.right)\n                if tmp.left:\n                    queue.append(tmp.left)\n        ans = tmp.val\n        return ans\n```\nä»å·¦åˆ°å³éå†æ—¶ï¼Œæ¯å±‚ç¬¬ä¸€ä¸ªå…ƒç´ å³æ˜¯è¯¥å±‚ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚\n```python\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        return self.levelTraversal(root)\n\n    def levelTraversal(self, root):\n        queue = [root]\n        ans = None\n        while queue:\n            ans = queue[0].val\n            # å¼€å§‹éå†æ¯ä¸€å±‚\n            for _ in range(len(queue)):  # æ¯ä¸€å±‚çš„å¤„ç†\n                tmp = queue.pop(0)\n                if tmp.left:\n                    queue.append(tmp.left)\n                if tmp.right:\n                    queue.append(tmp.right)\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200386134","body":"## æ€è·¯\nå±‚åºéå†\n## ä»£ç \n```python\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        from collections import deque\n        ans = ''\n        queue = deque([root])\n        while queue:\n            tmp = queue.popleft()\n            if tmp:\n                ans+=(str(tmp.val)+',')\n                queue.append(tmp.left)\n                queue.append(tmp.right)\n            else:\n                ans+='x,'\n        return ans\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"       \n        data = data.split(',')\n        if data[0]=='x':return None\n        root = TreeNode(data[0])\n        i = 1\n        que = [root]\n        while i<len(data)-1:\n            tmp = que.pop(0)\n            left = data[i]\n            right = data[i+1]\n            if left!='x':\n                tmp.left = TreeNode(left)\n                que.append(tmp.left)\n            if right!='x':\n                tmp.right = TreeNode(right)\n                que.append(tmp.right)\n            i+=2\n        return root\n\n        \n\n# Your Codec object will be instantiated and called as such:\n# ser = Codec()\n# deser = Codec()\n# ans = deser.deserialize(ser.serialize(root))\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200588220","body":"## æ€è·¯\n* å…ˆéå†è®°å½•ä¸‹æ¯ä¸ªå…ƒç´ çš„è¡Œåˆ—å€¼ï¼Œç„¶åå†æ ¹æ®ï¼ˆåˆ—ï¼Œè¡Œï¼Œå€¼ï¼‰è¿›è¡Œæ’åºã€‚\n* ç”±äºé¢˜ä¸­è¦æ±‚æŒ‰åˆ—ä¼˜å…ˆï¼Œæ‰€ä»¥ä¸‰å…ƒç»„ç§æŠŠåˆ—æ’åœ¨ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚\n* python ä¸­ `sorted` å‡½æ•°å¯ä»¥å¯¹å…ƒç»„è¿›è¡Œæ’åºï¼ŒæŒ‰ç…§å„å…ƒç´ å‡åºè¿›è¡Œæ’åºï¼Œå…ˆæ ¹æ®ç¬¬ä¸€ä¸ªå…ƒç´ æ’åºï¼Œå†æ ¹æ®ç¬¬äºŒä¸ªå…ƒç´ æ’åºï¼Œæ­£å¥½æ»¡è¶³é¢˜ä¸­è¦æ±‚ã€‚\n## ä»£ç ï¼š\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        self.info = []\n        self.dfs(root,0,0)\n        \n        info = sorted(self.info)\n        ans = [[]]\n        pre_col = info[0][0]\n        for col,row,val in info:\n            if col == pre_col:\n                ans[-1].append(val)\n            else:\n                ans.append([val])\n                pre_col = col\n        return ans\n    \n    def dfs(self,root,row,col):\n        if not root:\n            return None\n        self.info.append((col,row,root.val))\n        self.dfs(root.left,row+1,col-1)\n        self.dfs(root.right,row+1,col+1)\n```\n### å¤æ‚åº¦ï¼š\nT: $O(N\\log(n))$ï¼Œä¸»è¦æ˜¯æ’åºçš„å¤æ‚åº¦ï¼›\nS: $O(N)$éœ€è¦å­˜å‚¨æ ‘ä¸­å„å…ƒç´ å€¼ã€‚","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201953967","body":"## æ€è·¯\né‡‡ç”¨å“ˆå¸Œè¡¨æ±‚è§£\n* è®¾å…ƒç´ å€¼ä¸º$x$ï¼Œåˆ™å…¶å¯¹åº”çš„hashå€¼ä¸º $target-x$\n* è‹¥åç»­æœ‰å…ƒç´ $y$å¤„äºhashè¡¨ä¸­ï¼Œåˆ™$x$ä¸$y$æ„æˆä¸€å¯¹å’Œä¸º$target$çš„å€¼\n## ä»£ç \n* å“ˆå¸Œè¡¨ä¸­è®°å½•`target-val`çš„ä½ç½®ï¼Œåç»­åŒ¹é…`val`\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        hash_table = {}\n        for index, val in enumerate(nums):\n            if val in hash_table:\n                return [hash_table[val], index]\n            else:\n                hash_table[target - val] = index\n        return []\n```\n* å“ˆå¸Œè¡¨ä¸­è®°å½•`val`çš„ä½ç½®ï¼Œåç»­åŒ¹é…`target-val`\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        hash_table = {}\n        for i, val in enumerate(nums):\n            if (target - val) in hash_table:\n                return [hash_table[target - val], i]\n            else:\n                hash_table[val] = i\n        return []\n```\n## å¤æ‚åº¦\n* T:$O(n^2)$ï¼Œæ•°ç»„éå†ä¸€æ¬¡($O(n)$)ï¼Œæ¯ä¸ªå…ƒç´ `val`éœ€è¦åœ¨å“ˆå¸Œè¡¨ä¸­æŸ¥æ‰¾($O(n)$)ã€‚\n* S:$O(n)$ï¼Œæœ€åæƒ…å†µä¸‹ï¼Œå½“`[0,n-1]`å’Œä¸º`target`æ—¶éœ€è¦å­˜å‚¨æ‰€æœ‰çš„é”®å€¼å¯¹ã€‚","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203361638","body":"```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        from collections import Counter\n        count = Counter(nums)\n        out,_ = zip(*count.most_common(k))\n        return out\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204676889","body":"## æ€è·¯\nå›æ—‹é•–ä¸ºä»¥ä¸€ä¸­å¿ƒç‚¹ï¼Œå·¦å³ä¸¤åˆ†æ”¯é•¿åº¦ç›¸ç­‰çš„å›¾å½¢ã€‚\n* è¦ç»Ÿè®¡å›æ—‹é•–çš„æ•°é‡ï¼Œåªéœ€ä»¥ä»»æ„ä¸€ç‚¹ä¸ºä¸­å¿ƒç‚¹ï¼Œè®°å½•å…¶ä»–æ‰€æœ‰ç‚¹åˆ°è¯¥ç‚¹çš„è·ç¦»ï¼Œä»è€Œå†…éƒ¨åµŒå¥—çš„å¾ªç¯ä¸èƒ½æ˜¯ $i+1 \\rightarrow \\mathrm{len} (points)$ï¼Œè€Œæ˜¯$0\\rightarrow \\mathrm{len}(points)$ã€‚\n* é€‰æ‹©è·ç¦»ç‚¹ $p$ ä¸º $d$ çš„é›†åˆï¼Œä»¥ $p$ ä¸ºä¸­å¿ƒç‚¹ï¼Œä»»é€‰å…¶ä¸­ä¸¤ç‚¹$i,j$ï¼Œå³å¯ç»„æˆå›æ—‹é•–$\\{p,i,j\\}$\n* ç”±äºè¦è€ƒè™‘é¡ºåºï¼Œ$\\{p,i,j\\}$ ä¸åŒäº$\\{p,j,i\\}$ï¼Œä»è€Œå…¶æ’åˆ—æ•°$A_m^2$ å³æ˜¯ä»¥ $p$ ä¸ºä¸­å¿ƒç‚¹ï¼Œè·ç¦»ä¸º $d$ çš„å›æ—‹é•–ä¸ªæ•°ã€‚\n## ä»£ç \n```python\nclass Solution:\n    def numberOfBoomerangs(self, points) -> int:\n        from collections import defaultdict\n\n        ans = 0\n        for p in points:\n            cnt = defaultdict(int)\n            for q in points:\n                dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1])\n                cnt[dis] += 1  # åˆ°ç‚¹pè·ç¦»ä¸ºdisçš„ç‚¹çš„ä¸ªæ•°\n            for m in cnt.values():\n                ans += m * (m - 1)\n        return ans\n```\n## å¤æ‚åº¦\n* T: $O(n^2)$\n* S: $O(n)$, æœ€åéœ€è¦å­˜å‚¨ $n$ ä¸ªè·ç¦»\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205956946","body":"```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        dic = {}\n        res = 0\n        tmp = 0\n        for j in range(len(s)): \n            i = dic.get(s[j],-1)\n            dic[s[j]] = j\n            tmp = tmp + 1 if tmp < j - i else j - i \n            res = max(res, tmp)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207194278","body":"## æ€è·¯\n* ä¸€ä¸ªå®Œæ•´çš„å­ä¸²åŒ¹é…ï¼š\n    * å•è¯æ€»æ•°ä¸€è‡´\n    * å•è¯å†…å®¹ä¸€è‡´\n* é‡‡ç”¨ å“ˆå¸Œè¡¨ è®°å½• `words`ä¸­å„ä¸ªå•è¯çš„ä¸ªæ•°ï¼Œä»`s`çš„æ¯ä¸ªå­—æ¯å¼€å§‹ä¾æ¬¡å¾€åé¡ºåº**å–å•è¯**ï¼ˆ`s[i,i+word_len]`ï¼‰è¿›è¡Œéå†\n    * è®°å½•åŒ¹é…çš„å•è¯ä¸ªæ•°\n    * è‹¥ä¸ªæ•°ä¸ä¸€è‡´ï¼Œè·³å‡ºå¾ªç¯ï¼Œä»ä¸‹ä¸€ä¸ªå­—æ¯å¼€å§‹\n    * è‹¥å•è¯å†…å®¹ä¸ä¸€è‡´ï¼ŒåŒæ ·è·³å‡ºå¾ªç¯\n## ä»£ç \n```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        if not s or not words:return []\n        from collections import Counter\n        dict1 = Counter(words)\n        n_words = len(words)\n        word_len = len(words[0])\n        res = []\n        for i in range(len(s)-word_len*n_words+1):\n            hash_words = {}\n            num = 0\n            while num < n_words:\n                word = s[i+num*word_len:i+(num+1)*word_len]\n                if word in dict1:\n                    word_time = hash_words.get(word,0)\n                    hash_words[word] = word_time + 1\n                    if hash_words.get(word) > dict1.get(word): # æŸä¸ªå•è¯ä¸ªæ•°ä¸ä¸€è‡´\n                        break\n                else:\n                    break\n                num+=1\n            if num == n_words:\n                res.append(i)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207345694","body":"```python\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        mod=sum(nums)%p\n        if mod==0:\n            return 0\n        n=len(nums)\n        res,pre_mod=n,0\n        hash={0:-1}\n        for i,num in enumerate(nums):\n            pre_mod=(pre_mod+num)%p\n            target=(pre_mod-mod+p)%p\n            if target in hash:\n                res=min(res,i-hash[target])\n                if res==1:\n                    return res\n            hash[pre_mod]=i\n        if res==n:\n            return -1\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207663424","body":"```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        slow,fast=head,head\n        while fast and fast.next:\n            slow=slow.next\n            fast=fast.next.next\n        return slow\n```\n* å¤æ‚åº¦ï¼š\n    * T:$O(n)$\n    * S: $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208774034","body":"## æ€è·¯\n* ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆ\n\t* å¿«æŒ‡é’ˆ `fast` ä¸åœå‘å‰ç§»åŠ¨ï¼Œè‹¥é‡åˆ°ä¸é‡å¤çš„æ•°å­—ï¼Œæ…¢æŒ‡é’ˆ `slow` å‘å‰ç§»åŠ¨ä¸€æ­¥ï¼Œä¿®æ”¹ `nums[slow]` ä¸º `nums[fast]`ã€‚\n## ä»£ç \n```python\nclass Solution:  \n    def removeDuplicates(self, nums: List[int]) -> int:  \n        slow = 0  \n        for fast in range(len(nums)):  \n            if nums[fast] != nums[slow]:  \n                slow += 1  \n                nums[slow] = nums[fast]  \n        return slow + 1\n```\n## å¤æ‚åº¦\n* Tï¼š$O(n)$\n* S: $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/42#issuecomment-1210019507","body":"äºŒåˆ†æŸ¥æ‰¾\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        l= 0\n        r=len(nums)\n        while l<r:\n            m=l+(r-l)//2\n            if nums[m]>=target:r=m\n            else: l=m+1\n        return r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bzlff":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185074522","body":"### æ€è·¯\nå°†listâ†’strâ†’int â†’ result+k â†’ str â†’ list\n\n### ä»£ç \n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        \n        result = int(''.join(map(str, num))) + k\n        \n        return [int(i) for i in str(result)]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186187289","body":"```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        \n        n = len(s)\n        ans = [0] * n\n        idx = -n\n\n        for i, ch in enumerate(s):\n            if ch == c:\n                idx = i\n            ans[i] = i - idx\n\n        idx = 2 * n\n        for i in range(n-1, -1, -1):\n            if s[i] == c:\n                idx = i\n            ans[i] = min(ans[i], idx-i)\n\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186540856","body":"```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = [0] * maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.stack) - 1:\n            self.top += 1\n            self.stack[self.top] = x\n\n    def pop(self) -> int:\n        if self.top == -1: \n            return -1\n        ans = self.stack[self.top]\n        self.top -= 1\n\n        return ans\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k, self.top + 1)\n        for i in range(lim):\n            self.stack[i] += val\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186999400","body":"```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        \n        ans = []\n        \n        for c in s:\n            \n            if c == ']':\n                temp_str = ''\n                temp_iter = ''\n                while ans and ans[-1] != '[':\n                    temp_str = ans.pop() + temp_str\n                ans.pop()\n                \n                while ans and ans[-1].isdigit():\n                    temp_iter = ans.pop() + temp_iter\n                    \n                ans.append(temp_str * int(temp_iter))\n            else:\n                ans.append(c)\n                \n        return ''.join(ans)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189157737","body":"```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self._in_stack, self._out_stack, self._front = [], [], None\n\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        if not self._in_stack:  # åˆ¤æ–­æœ‰æ²¡æœ‰å…ƒç´ \n            self._front = x  # è¡¨ç¤ºé˜Ÿé¦–\n        \n        self._in_stack.append(x)\n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if self.empty():\n            raise Exception(\"[ERROR] The queue is empty!\")\n\n        if not self._out_stack:  # å¦‚æœç©º, æ·»åŠ å…ƒç´ \n            while self._in_stack:\n                self._out_stack.append(self._in_stack.pop())\n        \n        return self._out_stack.pop()\n\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if self.empty():\n            raise Exception(\"[ERROR] The queue is empty!\")\n\n        if not self._out_stack:  # ç©ºçš„è¯ï¼Œç›´æ¥è¾“å‡ºNone\n            return self._front\n        else:\n            return self._out_stack[-1]\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return not self._in_stack and not self._out_stack\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191611666","body":"```c++\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n\n        if k == 0 or not head or not head.next:\n            return head\n        \n        n = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            n += 1\n\n        iters = (n - k) % n\n        if iters == n: return head\n\n        cur.next = head\n        while iters:\n            iters -= 1\n            cur = cur.next\n\n        ans = cur.next\n        cur.next = None\n\n        return ans\n\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194245982","body":"```python\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode fast;\n        ListNode slow;\n        fast = slow = head;\n        while ((fast != null) && (fast.next != null)) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) {\n                fast = head;\n                while (slow != fast) {\n                    fast = fast.next;\n                    slow = slow.next;\n                }\n                return slow;\n            }\n        }\n        return null;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzzkains":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185077761","body":"yæ€»è¯´è¿™ä¸ªæ˜¯é«˜ç²¾åº¦åŠ æ³•\n# é«˜ç²¾åº¦åŠ æ³•\nc++ä¸­çš„é«˜ç²¾åº¦åŠ æ³•ä¸€èˆ¬æ˜¯ä»ä½ä½åˆ°é«˜ä½\næ‰€ä»¥éœ€è¦reverse\nç„¶åæ­£å¸¸åŠ å°±è¡Œ\n# ä»£ç \n```C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        reverse(num.begin(), num.end());\n        for (int & c : num) {\n            k += c;\n            c = k % 10;\n            k /= 10;\n        }\n        while (k) num.push_back(k % 10), k /= 10;\n        reverse(num.begin(), num.end());\n        return num;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186107567","body":"# æ€è·¯\nå·¦è¾¹å³è¾¹åˆ†åˆ«æ±‚ä¸€ä¸‹æœ€è¿‘çš„å€¼ï¼Œç„¶åæ±‚æœ€å°\n# ä»£ç \n```C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> res(n, INT_MAX);\n        for (int i = 0, j = -1; i < n; i ++) {\n            if (s[i] == c) j = i;\n            if (j != -1) res[i] = i - j;\n        }\n        for (int i = n - 1, j = -1; i >= 0; i --) {\n            if (s[i] == c) j = i;\n            if (j != -1) res[i] = min(res[i], j - i);\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186394469","body":"# æ€è·¯\næ•°ç»„æ¨¡æ‹Ÿæ ˆ\n# ä»£ç \n```C++\nclass CustomStack {\npublic:\n    vector<int> stk, inc;\n    int maxsize;\n    \n    CustomStack(int maxSize) {\n        maxsize = maxSize;\n    }\n    \n    void push(int x) {\n        if (stk.size() < maxsize) {\n            stk.push_back(x);\n        }\n        return ;\n    }\n    \n    int pop() {\n        // è€ƒè™‘æ•°ç»„ä¸ºç©ºçš„æƒ…å†µ\n        if (stk.size()) {\n            int t = stk.back();\n            stk.pop_back();\n            return t;\n        }\n        return -1;\n    }\n    \n    void increment(int k, int val) {\n        int l = min(k, (int)stk.size());\n        for (int i = 0; i < l; i ++) {\n            stk[i] += val;\n        }\n        return ;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186781852","body":"# æ€è·¯\næŒ‰è§„åˆ™ dfs ç»“æœ\n# ä»£ç \n```C++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        int u = 0;\n        return dfs(s, u);\n    }\n\n    string dfs(string& s, int& u) {\n        string res;\n        while (u < s.size() && s[u] != ']') {\n            if (s[u] >= 'a' && s[u] <= 'z') res += s[u ++];\n            else if (s[u] >= '0' && s[u] <= '9') {\n                int k = u;\n                while (s[k] >= '0' && s[k] <= '9') k ++;\n                int t = stoi(s.substr(u, k - u));\n                u = k + 1;\n                string sa = dfs(s, u);\n                u ++;\n                while (t --) res += sa;\n            }\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188480408","body":"# æ€è·¯\nç®€å•æ¨¡æ‹Ÿé¢˜\n# ä»£ç \n```C++\nclass MyQueue {\npublic:\n    stack<int> a, b;\n\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        a.push(x);\n    }\n    \n    int pop() {\n        while (a.size()) {\n            b.push(a.top());\n            a.pop();\n        }\n        int c = b.top();\n        b.pop();\n        while (b.size()) {\n            a.push(b.top());\n            b.pop();\n        }\n        return c;\n    }\n    \n    int peek() {\n        while (a.size()) {\n            b.push(a.top());\n            a.pop();\n        }\n        int c = b.top();\n        while (b.size()) {\n            a.push(b.top());\n            b.pop();\n        }\n        return c;\n    }\n    \n    bool empty() {\n        return a.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189700997","body":"# æ€è·¯\nè´ªå¿ƒè§£æ³•ï¼Œæ’åºåæ•°ç»„å’ŒåŸæ•°ç»„ç›¸æ¯”è¾ƒï¼Œæ‰¾åˆ°åˆ†ç•Œç‚¹\n# ä»£ç \n```C++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        vector<int> sarr = arr;\n        sort(sarr.begin(), sarr.end());\n        unordered_map<int, int> cnt;\n        int res = 0;\n        for (int i = 0, s = 0; i < arr.size(); i ++) {\n            if (cnt[arr[i]] == 1) s --;\n            else if (cnt[arr[i]] == 0) s ++;\n            cnt[arr[i]] --;\n            if (cnt[sarr[i]] == -1) s --;\n            else if (cnt[sarr[i]] == 0) s ++;\n            cnt[sarr[i]] ++;\n            if (!s) res ++;\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191186843","body":"# æ€è·¯\né“¾è¡¨æ¨¡æ‹Ÿé¢˜\n# ä»£ç \n```C++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (!head) return head;\n        int n = 0;\n        for (ListNode* p = head; p; p = p->next) n ++;\n        k %= n;\n        if (!k) return head;\n\n        ListNode* f = head;\n        while (k -- && f) f = f->next;\n        ListNode* s = head;\n        while (f->next) {\n            s = s->next;\n            f = f->next;\n        }\n        f->next = head;\n        head = s->next;\n        s->next = NULL;\n        return head;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192294693","body":"# æ€è·¯\né“¾è¡¨æ¨¡æ‹Ÿé¢˜ï¼Œå¯ä»¥å…ˆæ¯”åˆ’æ¯”åˆ’è¯¥æ€ä¹ˆåè½¬\n# ä»£ç \n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (!head || !head->next) return head;\n        ListNode* dummy = new ListNode;\n        dummy->next = head;\n        ListNode* pre = dummy;\n        while (pre->next && pre->next->next) {\n            ListNode* cur = pre->next, * t = cur->next;\n            pre->next = t;\n            cur->next = t->next;\n            t->next = cur;\n            pre = cur;\n        }\n        return dummy->next;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193111787","body":"# ä»£ç \n```C++\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if (!head) return NULL;\n        int n = 0;\n        for (auto p = head; p; p = p->next) n ++ ;\n        if (n == 1) return new TreeNode(head->val);\n        auto cur = head;\n        for (int i = 0; i < n / 2 - 1; i ++ ) cur = cur->next;\n        auto root = new TreeNode(cur->next->val);\n        root->right = sortedListToBST(cur->next->next);\n        cur->next = NULL;\n        root->left = sortedListToBST(head);\n        return root;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193292237","body":"# æ‰“å¡\n```C++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* p = headA, * q = headB;\n        while (p != q) {\n            p = p ? p->next : headB;\n            q = q ? q->next : headA;\n        }\n        return p;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193448465","body":"# æ€è·¯\nå¿«æ…¢æŒ‡é’ˆ\n# ä»£ç \n```C++\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if (!head || !head->next) return NULL;\n        ListNode* f = head;\n        ListNode* s = head;\n        while (f->next && f->next->next) {\n            f = f->next->next;\n            s = s->next;\n            if (f == s) {\n                s = head;\n                while (f != s) {\n                    s = s->next;\n                    f = f->next;\n                }\n                return f;\n            }\n        }\n        return NULL;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194821407","body":"# æ€è·¯\nå“ˆå¸Œè¡¨å­˜å‚¨èŠ‚ç‚¹ç´¢å¼•ï¼ŒåŒé“¾è¡¨æ›´æ–°ç”¨åˆ°çš„å€¼\n# ä»£ç \n```C++\nclass LRUCache {\npublic:\n    struct Node{\n        int key, val;\n        Node* left, * right;\n        Node(int _key, int _val) : key(_key), val(_val), left(NULL), right(NULL) {}\n    }*L, *R;\n    unordered_map<int, Node*> h;\n    int n;\n\n    void remove(Node* node) {\n        node->left->right = node->right;\n        node->right->left = node->left;\n    }\n\n    void insert(Node* node) {\n        L->right->left = node;\n        node->right = L->right;\n        L->right = node;\n        node->left = L;\n    }\n\n    LRUCache(int capacity) {\n        n = capacity;\n        L = new Node(-1, -1), R = new Node(-1, -1);\n        L->right = R, R->left = L;\n    }\n    \n    int get(int key) {\n        if (!h.count(key)) return -1;\n        Node* p = h[key];\n        remove(p);\n        insert(p);\n        return p->val;\n    }\n    \n    void put(int key, int value) {\n        if (h.count(key)) {\n            Node* p = h[key];\n            p->val = value;\n            remove(p);\n            insert(p); \n        } else {\n            if (h.size() == n) {\n                Node* p = R->left;\n                remove(p);\n                h.erase(p->key);\n                delete(p);\n            }\n            Node* p = new Node(key, value);\n            h[key] = p;\n            insert(p);\n        }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196157783","body":"# æ€è·¯\nç®€å•é€’å½’\n# ä»£ç \n```C++\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (!root) return 0;\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197545786","body":"# æ€è·¯\néå†ï¼Œåˆ†æƒ…å†µè®¨è®º\n# ä»£ç \n```C++\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (!p && !q) return true;\n        if (!p || !q || p->val != q->val) return false;\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199285901","body":"# æ‰“å¡\n# ä»£ç \n```C++\nclass Solution {\npublic:\n    int ans = 0;\n\n    int sumNumbers(TreeNode* root) {\n        if (root) dfs(root, 0);\n        return ans;\n    }\n\n    void dfs(TreeNode* root, int number) {\n        number = number * 10 + root->val;\n        if (!root->left && !root->right) ans += number;\n        if (root->left) dfs(root->left, number);\n        if (root->right) dfs(root->right, number);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200052547","body":"# æ€è·¯\næ ‡è®°å±‚æ•°ï¼Œè®°å½•æ¯ä¸€å±‚ç¬¬ä¸€ä¸ªæ•°çš„å€¼\n# ä»£ç \n## è¿­ä»£\n```C++\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        int res = 0;\n        queue<TreeNode*> q;\n        if (root) q.push(root);\n        while (q.size()) {\n            int n = q.size();\n            for (int i = 0; i < n; i ++) {\n                TreeNode* node = q.front();\n                q.pop();\n                if (!i) res = node->val;\n                if (node->left) q.push(node->left);\n                if (node->right) q.push(node->right);\n            }\n        }\n        return res;\n    }\n};\n```\n## é€’å½’\n```C++\nclass Solution {\npublic:\n    int res, maxc;\n\n    int findBottomLeftValue(TreeNode* root) {\n        maxc = 0;\n        dfs(root, 1);\n        return res;\n    }\n    void dfs(TreeNode* root, int c) {\n        if (!root) return ;\n        if (c > maxc) {\n            maxc = c;\n            res = root->val;\n        }\n        dfs(root->left, c + 1);\n        dfs(root->right, c + 1);\n        return ;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200326046","body":"# æ€è·¯\nå–ä¸€ä¸ªç‰¹æ®Šå­—ç¬¦ä½œä¸ºå“¨å…µ\n# ä»£ç \n```C++\nclass Codec {\npublic:\n    string path;\n\n    void dfs(TreeNode* root) {\n        if (!root) {\n            path += \"#,\";\n            return;\n        } else {\n            path += to_string(root->val) + ',';\n            dfs(root->left);\n            dfs(root->right);\n            return ;\n        }\n    }\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        path = \"\";\n        dfs(root);\n        return path;\n    }\n    TreeNode* dfs_d(string& data, int &u) {\n        if (u == data.size()) return NULL;\n        if (data[u] == '#') {\n            u += 2;\n            return NULL;\n        } else {\n            int k = u;\n            while (data[k] != ',') k ++;\n            TreeNode* root = new TreeNode(stoi(data.substr(u, k - u)));\n            u = ++k;\n            root->left = dfs_d(data, u);\n            root->right = dfs_d(data, u);\n            return root;\n        }\n\n    }\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        int u = 0;\n        return dfs_d(data, u);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200609271","body":"# æ€è·¯\n1. åˆ©ç”¨ dfs å°†äºŒå‰æ ‘å„ä¸ªèŠ‚ç‚¹ç¼–å·å­˜å‚¨ï¼›\n2. æ’åºï¼Œå¹¶å°†æ’åºå¥½çš„æ•°ç»„è¾“å‡º\n# ä»£ç \n```C++\nclass Solution {\npublic:\n    map<int, vector<vector<int>>> S;\n    void dfs(TreeNode* root, int x, int y) {\n        if (!root) return ;\n        S[y].push_back({x, root->val});\n        dfs(root->left, x + 1, y - 1);\n        dfs(root->right, x + 1, y + 1);\n    }\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        dfs(root, 0, 0);\n        vector<vector<int>> res;\n        for(auto& [k, v] : S) {\n            sort(v.begin(), v.end());\n            vector<int> col;\n            for (auto& p : v) col.push_back(p[1]);\n            res.push_back(col);\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201944410","body":"# æ€è·¯\nå“ˆå¸Œè¡¨\n# ä»£ç \n```C++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> h;\n        for (int i = 0; i < nums.size(); i ++) {\n            if (h.count(target - nums[i])) return {h[target - nums[i]], i};\n            h[nums[i]] = i;\n        }\n        return {-1, -1};\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203926929","body":"# ä»£ç \n```C++\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int, int> h;\n        for (int x : nums) h[x] ++;\n        int n = nums.size();\n        vector<int> s(n + 1);\n        for(auto [x, c] : h) s[c] ++;\n        int l = 0, i = n;\n        while (l < k) l += s[i --];\n        vector<int> res;\n        for(auto [x, c] : h) {\n            if (c > i) res.push_back(x);\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205287387","body":"## ä»£ç \n```C++\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& p) {\n        int res = 0;\n        for (int i = 0; i < p.size(); i ++ ) {\n            unordered_map<int, int> cnt;\n            for (int j = 0; j < p.size(); j ++ )\n                if (i != j) {\n                    int dx = p[i][0] - p[j][0];\n                    int dy = p[i][1] - p[j][1];\n                    int dist = dx * dx + dy * dy;\n                    cnt[dist] ++ ;\n                }\n            for (auto [d, c]: cnt) res += c * (c - 1);\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206427206","body":"# æ€è·¯\nå…ˆæ·»åŠ å…ƒç´ ï¼Œå†æ£€æµ‹æ˜¯å¦ç¬¦åˆæ¡ä»¶\n# ä»£ç \n```C++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        unordered_map<char, int> h;\n        int res;\n        for (int i = 0, j = 0; i < s.size(); i ++) {\n            h[s[i]] ++;\n            while (h[s[i]] > 1) h[s[j++]] --;\n            res = max(res, i - j + 1);\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207124334","body":"# æ€è·¯\nå­—ç¬¦ä¸²å“ˆå¸Œ\n# ä»£ç \n```C++\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        vector<int> res;\n        int n = s.size(), m = words.size(), w = words[0].size();\n        unordered_map<string, int> tot;\n        for (auto& word: words) tot[word] ++;\n        for (int i = 0; i < w; i ++) {\n            unordered_map<string, int> wd;\n            int cnt = 0;\n            for (int j = i; j + w <= n; j += w) {\n                if (j >= i + m * w) {\n                    auto word = s.substr(j - m * w, w);\n                    wd[word] --;\n                    if (wd[word] < tot[word]) cnt --;\n                }\n                auto word = s.substr(j, w);\n                wd[word] ++;\n                if (wd[word] <= tot[word]) cnt ++;\n                if (cnt == m) res.push_back(j - (m - 1) * w);\n            }\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207304209","body":"# æ€è·¯\nåŒä½™å®šç†\nè¿™ä¸ªé¢˜å’Œ lc é‡Œçš„ 1590 é¢˜ç±»ä¼¼ï¼Œå°±ç›´æ¥åœ¨ lc é‡Œåšäº†\n# ä»£ç \n```C++\nclass Solution {\npublic:\n    int minSubarray(vector<int>& nums, int p) {\n        long long allSum = 0;\n        for (auto& num : nums)\n            allSum += num;        \n        if (allSum < p) return -1;\n\n        int mod = 0;        \n        mod = allSum % p;\n        if (mod == 0) return 0;\n        unordered_map<int, int> dict; \n        dict[0] = -1;\n        const int len = nums.size();\n        int minLen = len;\n        long long preSum = 0;\n        for (int i = 0; i < len; i++)\n        {\n            preSum += nums[i];\n            int curMod = preSum % p;\n            int target = (curMod - mod + p) % p; \n            if (dict.count(target))\n                minLen = min(minLen, i - dict[target]);\n            dict[curMod] = i; \n        }\n        return minLen == len ? -1 : minLen;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207555802","body":"# æ€è·¯\nå¿«æ…¢æŒ‡é’ˆ\n# ä»£ç \n```C++\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* dummy = new ListNode;\n        dummy->next = head;\n        ListNode* f = dummy;\n        ListNode* s = dummy;\n        while (f) {\n            s = s->next;\n            if (!f->next) f = NULL;\n            else f = f->next->next;\n        }\n        return s;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208853659","body":"# æ€è·¯\nåŒæŒ‡é’ˆ\n# ä»£ç \n```C++\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int res = 0;\n        for (int i = 0; i < nums.size(); i ++) {\n            if (!i || nums[i] != nums[i - 1])\n                nums[res ++] = nums[i];\n        }\n        return res;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenmengyu":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185084170","body":"# æ€è·¯\nç±»ä¼¼äºå¤§æ•°ç›¸åŠ ï¼Œç”±äºå¯èƒ½æº¢å‡ºï¼Œæ‰€ä»¥æŠŠä¸¤ä¸ªæ•°è½¬æˆæ•°ç»„å­˜å‚¨ï¼Œä»æ•°ç»„å¯¹åº”çš„æ•°å­—ä½ä½å¼€å§‹ç›¸åŠ ï¼Œè‹¥åŒä½ç›¸åŠ å¤§äº10ï¼Œéœ€è¦è¿›ä½ã€‚\n\n# ä»£ç JS\n```js\nvar addToArrayForm = function(num, k) {\n    let num2 = (k + '').split('')\n    let len = Math.max(num.length, num2.length)\n    let flag = 0 // è¿›ä½æ ‡å¿—\n    let result = []\n    num.reverse()\n    num2.reverse()\n    for (let i = 0; i < len; i++) {\n        let sum = (num[i] || 0) + (num2[i] || 0) / 1 + flag\n        flag = Math.floor(sum / 10)\n        sum = sum % 10\n        result.push(sum)\n    }\n    if (flag) {\n        result.push(flag)\n    }\n    return result.reverse()\n};\n```\n# å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦ï¼šO(n)  \nç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186191642","body":"### æ€è·¯\r\nå…ˆæ‰¾å‡ºå­—ç¬¦cåœ¨å­—ç¬¦ä¸²sä¸­çš„æ‰€æœ‰ä¸‹æ ‡æ•°ç»„cArrï¼Œç„¶åå…ˆéå†å­—ç¬¦ä¸²sï¼Œå†éå†æ•°ç»„cArrï¼Œè·å¾—å­—ç¬¦ä¸²sä¸­æ¯ä¸ªå­—ç¬¦ä¸‹æ ‡å’ŒcArrä¸­å€¼çš„æœ€å°è·ç¦»ã€‚\r\n### ä»£ç \r\n```js\r\nvar shortestToChar = function(s, c) {\r\n    let len = s.length\r\n    let cArr = []\r\n    let start = 0\r\n    let index, answer = []\r\n    while(~(index = s.indexOf(c, start))) {\r\n        cArr.push(index)\r\n        start = index + 1\r\n    }\r\n    for (let i = 0; i < s.length; i++) {\r\n        let temp\r\n        for (let j = 0; j < cArr.length; j++) {\r\n            if (temp === void 0) {\r\n                temp = Math.abs(i - cArr[j])\r\n            } else {\r\n                temp = Math.min(Math.abs(i - cArr[j]), temp)\r\n            }\r\n        }\r\n        answer.push(temp)\r\n    }\r\n    return answer\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186501052","body":"### æ€è·¯\r\næ•°ç»„æ¨¡æ‹Ÿæ ˆ\r\n### ä»£ç \r\njs\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.stack = []\r\n    this.maxSize = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.stack.length < this.maxSize) {\r\n        this.stack.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if (this.stack.length > 0) {\r\n        return this.stack.pop()\r\n    } else {\r\n        return -1\r\n    }\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for (let i = 0; i < this.stack.length && i < k; i++) {\r\n        this.stack[i] += val\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187595971","body":"### æ€è·¯\r\n### ä»£ç \r\n```js\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let stack = [], resStack = []\r\n    let num = 0\r\n    let str = ''\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === '[') {\r\n            stack.push(num)\r\n            resStack.push(str)\r\n            num = 0\r\n            str = ''\r\n        } else if (s[i] === ']') {\r\n            let count = stack.pop()\r\n            let temp = new Array(count).fill(str).join('')\r\n            str = resStack.pop() + temp\r\n        } else if (/\\d/.test(s[i])) {\r\n            num = num * 10 + s[i] * 1\r\n        } else {\r\n            str += s[i]\r\n        }\r\n    }\r\n    return str\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188839685","body":"### æ€è·¯\næ ˆåªèƒ½åè¿›å…ˆå‡º\n### ä»£ç \n```js\nvar MyQueue = function() {\n    this.inStack = []\n    this.outStack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.inStack.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if (!this.outStack.length) {\n        this.in2out()\n    }\n    return this.outStack.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if (!this.outStack.length) {\n        this.in2out()\n    }\n     return this.outStack[this.outStack.length - 1];\n};\nMyQueue.prototype.in2out = function() {\n    while (this.inStack.length) {\n        this.outStack.push(this.inStack.pop());\n    }\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.outStack.length === 0 && this.inStack.length === 0;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190051620","body":"### ä»£ç \n\n```JS\nvar maxChunksToSorted = function (arr) {\n    const sorted = [...arr];\n    sorted.sort((a, b) => a - b);\n\n    let count = 0,\n        sum1 = 0,\n        sum2 = 0;\n\n    for (let i = 0; i < arr.length; i++) {\n        sum1 += arr[i];\n        sum2 += sorted[i];\n\n        if (sum1 === sum2) {\n            count++;\n        }\n    }\n\n    return count;\n};\n```\n### å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦ï¼šO(NlogN) \næ§ä»¶å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191554442","body":"### ä»£ç \r\n```js\r\nvar rotateRight = function(head, k) {\r\n    if (k === 0 || !head || !head.next) {\r\n        return head;\r\n    }\r\n    let len = 1;\r\n    let cur = head;\r\n    while (cur.next) {\r\n        cur = cur.next;\r\n        len++;\r\n    }\r\n\r\n    k = len - k % len;\r\n    if (k === len) {\r\n        return head;\r\n    }\r\n\r\n    cur.next = head;\r\n    while (k) {\r\n        cur = cur.next;\r\n        k--;\r\n    }\r\n\r\n    const ret = cur.next;\r\n    cur.next = null;\r\n    return ret;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192596118","body":"### ä»£ç \r\n```js\r\nvar swapPairs = function(head) {\r\n    const dummyHead = new ListNode(0);\r\n    dummyHead.next = head;\r\n    let temp = dummyHead;\r\n    while (temp.next !== null && temp.next.next !== null) {\r\n        const node1 = temp.next;\r\n        const node2 = temp.next.next;\r\n        temp.next = node2;\r\n        node1.next = node2.next;\r\n        node2.next = node1;\r\n        temp = node1;\r\n    }\r\n    return dummyHead.next;\r\n};\r\n```\r\n### å¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦: O(N)\r\n- ç©ºé—´å¤æ‚åº¦: O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193130431","body":"### è¿›åº¦å¤ªå¿«äº†ï¼Œå·²ç»ä¸ä¼šäº†\r\n### ä»£ç \r\nå€Ÿé‰´çš„\r\n```js\r\nvar sortedListToBST = function(head) {\r\n    if (head === null) return null;\r\n    let node = head;\r\n    let valArr = [];\r\n    while (node !== null) {\r\n        valArr.push(node.val);\r\n        node = node.next;\r\n    }\r\n    let left = 0, right = valArr.length-1;\r\n    return help(valArr, left, right);\r\n};\r\n\r\nfunction help(valArr, left, right) {\r\n    if (left > right) return null;\r\n    let mid = Math.floor((left + right) / 2);\r\n    let node = new TreeNode(valArr[mid]);\r\n    node.left = help(valArr, left, mid-1);\r\n    node.right = help(valArr, mid+1, right);\r\n    return node;\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193332172","body":"### ä»£ç \r\n```js\r\nvar getIntersectionNode = function(headA, headB) {\r\n    const visited = new Set();\r\n    let temp = headA;\r\n    while (temp !== null) {\r\n        visited.add(temp);\r\n        temp = temp.next;\r\n    }\r\n    temp = headB;\r\n    while (temp !== null) {\r\n        if (visited.has(temp)) {\r\n            return temp;\r\n        }\r\n        temp = temp.next;\r\n    }\r\n    return null;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193826881","body":"### ä»£ç \n```js\nvar detectCycle = function(head) {\n    const visited = new Set();\n    while (head !== null) {\n        if (visited.has(head)) {\n            return head;\n        }\n        visited.add(head);\n        head = head.next;\n    }\n    return null;\n};\n```\n### å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195268428","body":"### ä»£ç \n```js\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.map = new Map();\n    this.capacity = capacity;\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if(this.map.has(key)){\n        let value = this.map.get(key);\n        this.map.delete(key); // åˆ é™¤åï¼Œå† set ï¼Œç›¸å½“äºæ›´æ–°åˆ° map æœ€åä¸€ä½\n        this.map.set(key, value);\n        return value\n    } else {\n        return -1\n    }\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    // å¦‚æœå·²æœ‰ï¼Œé‚£å°±è¦æ›´æ–°ï¼Œå³è¦å…ˆåˆ äº†å†è¿›è¡Œåé¢çš„ set\n    if(this.map.has(key)){\n        this.map.delete(key);\n    }\n    this.map.set(key, value);\n    // put ååˆ¤æ–­æ˜¯å¦è¶…è½½\n    if(this.map.size > this.capacity){\n        this.map.delete(this.map.keys().next().value);\n    }\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196791673","body":"### ä»£ç \r\n```js\r\nvar maxDepth = function(root) {\r\n    if(!root) {\r\n        return 0;\r\n    } else {\r\n        const left = maxDepth(root.left);\r\n        const right = maxDepth(root.right);\r\n        return Math.max(left, right) + 1;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198073370","body":"### ä»£ç \n```js\nvar isSameTree = function(p, q) {\n    if(p == null && q == null) \n        return true;\n    if(p == null || q == null) \n        return false;\n    if(p.val != q.val) \n        return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199258064","body":"### ä»£ç \r\n```js\r\nconst dfs = (root, prevSum) => {\r\n    if (root === null) {\r\n        return 0;\r\n    }\r\n    const sum = prevSum * 10 + root.val;\r\n    if (root.left == null && root.right == null) {\r\n        return sum;\r\n    } else {\r\n        return dfs(root.left, sum) + dfs(root.right, sum);\r\n    }\r\n}\r\nvar sumNumbers = function(root) {\r\n    return dfs(root, 0);\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uancen":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185084621","body":"## Idea\n\né¦–å…ˆå¾ªç¯å¤„ç†numï¼Œkæä¾›åŠ æ•°/è¾…åŠ©å¤„ç†è¿›ä½\n\nå†å•ç‹¬æ‹¿å‡ºä¸€ä¸ªå¾ªç¯å¤„ç†å‰©ä¸‹çš„kï¼Œç›´æ¥åŠ åœ¨numå¤´éƒ¨\n\n## Code\n\n```GO\nfunc reverse(num []int) {\n\tfor i, n := 0, len(num); i < n/2; i++ {\n\t\tnum[i], num[n-1-i] = num[n-1-i], num[i]\n\t}\n}\nfunc addToArrayForm(num []int, k int) []int {\n\tvar res_head []int\n\tvar n int = len(num)\n\ti := n - 1\n\tfor i >= 0 || k > 0 {\n\t\tif i < 0 {\n\t\t\tbreak\n\t\t}\n\t\tsum := num[i] + k%10\n\t\tk /= 10\n\t\tif sum >= 10 {\n\t\t\tsum -= 10\n\t\t\tk++ // add the 10 as 1 to k\n\t\t}\n\t\tnum[i] = sum // 0<=sum<=9\n\t\ti--\n\t}\n\tfor k > 0 {\n\t\tres_head = append(res_head, k%10)\n\t\tk /= 10\n\t}\n\treverse(res_head)\n\tnum = append(res_head, num...)\n\treturn num\n}\n```\n\n## Complexity\n\n* Time O(N)\n* Space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186197390","body":"## Idea\n\nres[i] = min(d to left c, d to right c)\n\n* first loop from l to r: record \"c\" as idx and update res[i]=i-idx\n* second loop from r to l: record \"c\" as idx and update res[i]=min(res[i], idx-i) \n\n## Code\n\n```go\nfunc min(a, b int) int {\n\tif a > b {\n\t\treturn b\n\t} else {\n\t\treturn a\n\t}\n}\nfunc shortestToChar(s string, c byte) []int {\n\t// res[i] = min(d to left c, d to right c)\n\tn := len(s)\n\tres := make([]int, n)\n    // -n --> make res[i] = (i + n) large enough for the second round iteration to overwrite it\n\tidx := -10007 \n\tfor i, a := range s {\n\t\tif byte(a) == c {\n\t\t\tidx = i\n\t\t}\n\t\tres[i] = i - idx\n\t}\n    // \n    // 2n --> make (2n - i) large enough for the first iteration record to be min\n\tidx = 20007\n\tfor i := n - 1; i >= 0; i-- {\n\t\tif s[i] == c {\n\t\t\tidx = i\n\t\t}\n\t\tres[i] = min(res[i], idx-i)\n\t}\n\treturn res\n}\n```\n\n## Complexity\n\n* Time O(N)\n* Space O(1) | return not considered ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186371628","body":"## Idea\n\nstk array +  cur --> top\n\nuse diff to implement incrementing \n\n## Code\n\n```go\ntype CustomStack struct {\n\tstk  []int\n\tdiff []int\n\tcur  int\n}\n\nfunc Constructor(maxSize int) CustomStack {\n\treturn CustomStack{\n\t\tcur:  -1,\n\t\tstk:  make([]int, maxSize, maxSize),\n\t\tdiff: make([]int, maxSize, maxSize),\n\t}\n}\n\nfunc (this *CustomStack) Push(x int) {\n\tif this.cur < len(this.stk)-1 {\n\t\tthis.cur++\n\t\tthis.stk[this.cur] = x\n\t}\n}\n\nfunc (this *CustomStack) Pop() int {\n\tif this.cur == -1 {\n\t\treturn -1\n\t}\n\tres := this.stk[this.cur] + this.diff[this.cur]\n\tif this.cur != 0 {\n\t\tthis.diff[this.cur-1] += this.diff[this.cur]\n\t}\n\tthis.diff[this.cur] = 0\n\tthis.cur--\n\treturn res\n}\n\nfunc (this *CustomStack) Increment(k int, val int) {\n\tif this.cur == -1 {\n\t\treturn\n\t}\n\tif k > this.cur+1 {\n\t\tthis.diff[this.cur] += val\n\t} else {\n\t\tthis.diff[k-1] += val\n\t}\n}\n```\n\n## Complexity\n\n* Time O(1)\n* Space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187636290","body":"## Idea\n\néå†å­—ç¬¦ä¸²ï¼Œåˆ†æƒ…å†µå¤„ç†\n\n* æ•°å­—\n* å­—æ¯\n* [\n  * è¿›å…¥åˆ°æ–°çš„[]ï¼Œéœ€è¦é‡æ–°è®°å½•å¯¹åº”çš„numå’Œstr\n  * åˆ™ä¸Šä¸ª[]çš„numå’Œstrå…¥æ ˆï¼Œè®°å½•è¯¥numå’Œstr\n* ]\n  * numå’Œstrå‡ºæ ˆï¼Œæ‹¼æ¥\n\næ•´ä½“ç†è§£ä¸ºè¿›å…¥åˆ°æœ€é‡Œé¢çš„[]ï¼Œå‘å¤–æ‰©å±•ï¼›è‚¯å®šè¿˜å¯ä»¥ç”¨é€’å½’å®ç°ï¼Œä¸‹æ¬¡çœ‹åˆ°å†å†™å§~\n\n## Code\n\n```cpp\nclass Solution\n{\npublic:\n    string decodeString(string s)\n    {\n        vector<string> strstk;\n        vector<int> numstk;\n\n        int num = 0;\n        string str = \"\";\n        for (char c : s)\n        {\n            if (c >= '0' && c <= '9')\n            {\n                num *= 10;\n                num += (c - '0');\n            }\n            else if (c == '[')\n            {\n                numstk.push_back(num);\n                strstk.push_back(str);\n                num = 0;\n                str = \"\";\n            }\n            else if (c == ']')\n            {\n                int numtmp = numstk.back();\n                string strtmp = strstk.back();\n                numstk.pop_back();\n                strstk.pop_back();\n                for (int i = 0; i < numtmp; i++)\n                {\n                    strtmp = strtmp + str;\n                }\n                str = strtmp;\n            }\n            else\n            {\n                str += c;\n            }\n        }\n        return str;\n    }\n};\n```\n\n## Complexity\n\n* Time O(N)\n* Space O(N)\n  * è¾…åŠ©æ ˆçš„æç«¯æƒ…å†µ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188484263","body":"## Idea\n\nåŒæ ˆæ¨¡æ‹Ÿé˜Ÿåˆ—ï¼›è€Œéæ ˆ+è¾…åŠ©æ ˆæ¨¡æ‹Ÿé˜Ÿåˆ—\n\n**åè€…pushæ€»æ˜¯O(N)**ï¼Œpopç®€å•ä¸ºO(1)ã€‚\n\nä½†æ˜¯åœ¨åŒæ ˆæ¨¡æ‹Ÿæƒ…å†µä¸‹ï¼Œä»èƒ½ä¿è¯popä¸ºO(1)ï¼Œå³è¿›è¡Œä¸€æ¬¡O(N)æ“ä½œåï¼Œåœ¨s2ä¸ä¸ºç©ºå‰ï¼Œæ€»æ˜¯O(1)çš„æ“ä½œã€‚\n\n## Code\n\n```cpp\nclass MyQueue {\npublic:\n\t// stack in\n\tstack<int> s1;\n\t// stack out\n\tstack<int> s2;\n    MyQueue() {\n    \n    }\n    \n    void push(int x) {\n    \ts1.push(x);\n    }\n    \n    int pop() {\n    \tif(s2.empty())\n    \t{\n    \t\twhile(!s1.empty())\n    \t\t{\n    \t\t\ts2.push(s1.top());\n    \t\t\ts1.pop();\n    \t\t}\n    \t}\n    \tint res = s2.top();\n    \ts2.pop();\n    \treturn res;\n    }\n    \n    int peek() {\n    \tint res = this->pop();\n    \ts2.push(res);\n    \treturn res;\n    }\n    \n    bool empty() {\n    \treturn s1.empty()&&s2.empty();\n    }c\n};\n```\n\n## Complexity\n\n* Time O(1)\n* Space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190460557","body":"## Idea\n\nå•è°ƒæ ˆ\n\n## Code\n\n```java\n// å‚è€ƒé¢˜è§£ï¼Œæ²¡æœ‰ç‰¹åˆ«ç†è§£\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr) {\n            if(!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\n                stack.addLast(head);\n            }\n            else stack.addLast(num);\n        }\n        return stack.size();\n    }\n}\n```\n\n## Complexity\n\n* Time O(N)\n* Space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190929199","body":"## Idea\n\nåˆ©ç”¨ç¯æ‰¾åˆ°æ–°çš„å¤´å°¾èŠ‚ç‚¹ï¼Œå› ä¸ºå†…éƒ¨å…³ç³»æ²¡å˜ï¼Œåªä¿®æ”¹\n\n* å°¾èŠ‚ç‚¹æŒ‡å‘å¤´èŠ‚ç‚¹\n* æ‰¾åˆ°æ–°çš„å°¾èŠ‚ç‚¹å\n  * è®¾ç½®æ–°å¤´èŠ‚ç‚¹ï¼ˆæ–°å°¾èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªï¼‰\n  * è®¾ç½®æ–°å°¾èŠ‚ç‚¹ï¼ˆnextç½®ä¸ºnullptrï¼‰\n\n## Code\n\n```cpp\nclass Solution\n{\npublic:\n    ListNode *rotateRight(ListNode *head, int k)\n    {\n        if (head == nullptr || head->next == nullptr)\n        {\n            return head;\n        }\n        if (k == 0)\n        {\n            return head;\n        }\n        ListNode *tail = head;\n        ListNode *newtail = head;\n        ListNode *newhead;\n        int n = 1;\n        // åŸæ¥çš„å°¾ç»“ç‚¹æŒ‡å‘åŸæ¥çš„å¤´ç»“ç‚¹ï¼Œå½¢æˆç¯\n        while (tail->next != nullptr)\n        {\n            tail = tail->next;\n            n++;\n        }\n        tail->next = head;\n        // æ‰¾åˆ°æ–­å¼€ç¯çš„ä½ç½®\n        for (int i = 0; i < (n - k % n - 1); i++)\n        {\n            newtail = newtail->next;\n        }\n        // æ–°çš„å¤´ç»“ç‚¹æŒ‡å‘æ–­å¼€ç¯çš„ä½ç½®\n        newhead = newtail->next;\n        newtail->next = nullptr;\n\n        return newhead;\n    }\n};\n```\n\n## Complexity\n\n* Time O(N)\n* Space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192285735","body":"#### Idea\n\n```\n// preA -> A -> B -> nextB\n// preA -> B -> A -> nextB \n```\n\n> åˆ›å»ºè™šæ‹Ÿå¤´èŠ‚ç‚¹ï¼Œä»¥é¿å…åˆ¤æ–­è¾¹ç•Œæ¡ä»¶ã€‚\n\n#### Code\n\n```\nclass Solution\n{\npublic:\n    ListNode *swapPairs(ListNode *head)\n    {\n        if (head == nullptr || head->next == nullptr)\n        {\n            return head;\n        }\n        ListNode *dummy = new ListNode(-1, head);\n        ListNode *pre = dummy;\n        ListNode *cur = pre->next;\n        while (cur != nullptr && cur->next != nullptr)\n        {\n            // pre->cur->(cur->next)->(cur->next->next)\n            // pre->(cur->next)->cur->(cur->next->next)\n            // curæŒ‡å‘(cur->next->next)\n            ListNode *next = cur->next;\n            cur->next = next->next;\n\n            // (cur->next)æŒ‡å‘cur\n            next->next = cur;\n\n            // preæŒ‡å‘cur->next\n            pre->next = next;\n\n            // æ›´æ–°\n            pre = cur;\n            cur = cur->next;\n        }\n        return dummy->next;\n    }\n};\n```\n\n#### Complexity\n\n* Time O(N)\n* Space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193026046","body":"#### Idea\n\nå¿«æ…¢æŒ‡é’ˆæ‰¾ä¸­ç‚¹ï¼Œé€’å½’æ„é€ å·¦å³å­æ ‘ã€‚\n\n/åˆ©ç”¨æ•°ç»„å­˜å‚¨é“¾è¡¨çš„å€¼ï¼Œç©ºé—´æ¢æ—¶é—´ã€‚\n\n#### Code\n\n```c++\nclass Solution\n{\npublic:\n    TreeNode *sortedListToBST(ListNode *head, ListNode *tail)\n    {\n        if (head == tail)\n            return nullptr;\n        // æ‰¾ä¸­ç‚¹\n        ListNode *fast = head;\n        ListNode *slow = head;\n        while (fast != tail && fast->next != tail)\n        {\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n        // ä¸»é€»è¾‘ï¼šæ„é€ æ ‘\n        TreeNode *root = new TreeNode(slow->val);\n        root->left = sortedListToBST(head, slow);\n        root->right = sortedListToBST(slow->next, tail);\n        return root;\n    }\n    TreeNode *sortedListToBST(ListNode *head)\n    {\n        if (head == nullptr)\n            return nullptr;\n        return sortedListToBST(head, nullptr);\n    }\n};\n```\n#### Complexity\n\nå¿«æ…¢æŒ‡é’ˆ\n\n* Time O(nlogn)\n* Space O(logn)\n\næ•°ç»„è½¬å­˜\n\n* Time O(n)\n  * æ¯ä¸ªèŠ‚ç‚¹O(1)\n* Space O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193223156","body":"#### Idea\n\nä½¿pAæŒ‡é’ˆèµ°è¿‡A+C+Bï¼›pBæŒ‡é’ˆèµ°è¿‡B+C+Aï¼Œåˆ™ç›¸é‡è‡³ä¸¤é“¾è¡¨ç›¸äº¤ä½ç½®ã€‚\n\n#### Code\n\n```cpp\nclass Solution\n{\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB)\n    {\n        ListNode *pa = headA;\n        ListNode *pb = headB;\n        while (pa != pb)\n        {\n            pa = pa == nullptr ? headB : pa->next;\n            pb = pb == nullptr ? headA : pb->next;\n        }\n        return pa;\n    }\n};\n```\n\n#### Complexity\n\n* Time O(N)\n* Space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193440259","body":"#### Idea\n\næ„é€ D==Lï¼›ä½¿fastä»èµ·ç‚¹å‡ºå‘èµ°Låˆ°å…¥å£ï¼Œslowä»ç¬¬ä¸€æ¬¡äº¤ç‚¹å‡ºå‘èµ°Dåˆ°å…¥å£ï¼Œå¾—åˆ°å…¥å£æŒ‡é’ˆã€‚\n\n#### Code\n\n```cpp\nclass Solution\n{\npublic:\n    ListNode *detectCycle(ListNode *head)\n    {\n        if (head == nullptr || head->next == nullptr)\n        {\n            return nullptr;\n        }\n        ListNode *fast = head;\n        ListNode *slow = head;\n        do\n        {\n            if (fast != nullptr && fast->next != nullptr)\n            {\n                fast = fast->next->next;\n            }\n            else\n            {\n                fast = nullptr;\n            }\n            slow = slow->next;\n        } while (fast != slow);\n        if (fast == nullptr)\n        {\n            return nullptr;\n        }\n        fast = head;\n        while (fast != slow)\n        {\n            slow = slow->next;\n            fast = fast->next;\n        }\n        return fast;\n    }\n};\n```\n\n#### Complexity\n\n* Time O(N)\n* Space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194995629","body":"#### Idea\n\n* é€»è¾‘ä¸Šä¿æŒé¡ºåºå…³ç³» --> æ•°ç»„ã€é“¾è¡¨\n* å¯¹æ•°æ®è¿›è¡Œé¢‘ç¹çš„å¢åˆ O(1) -->é“¾è¡¨\n* æ•°æ®è¯»å–O(1) -->å“ˆå¸Œ\n\n--> åŒå‘é“¾è¡¨+å“ˆå¸Œ\n\n> åŒå‘é“¾è¡¨æŒ‰æœ€åä¸€æ¬¡è®¿é—®çš„æ—¶é—´çš„é¡ºåºè¿›è¡Œæ’åˆ—ï¼Œ**é“¾è¡¨å¤´éƒ¨ä¸ºæœ€è¿‘è®¿é—®çš„èŠ‚ç‚¹**ã€‚\n\n#### Code\n\n```cpp\nstruct LinkedNode\n{\n    int key;\n    int val;\n    LinkedNode *pre;\n    LinkedNode *next;\n    LinkedNode() : key(0), val(0), pre(nullptr), next(nullptr) {}\n    LinkedNode(int _key, int _val) : key(_key), val(_val), pre(nullptr), next(nullptr) {}\n};\n\nclass LRUCache\n{\npublic:\n    LRUCache(int _capacity) : capacity(_capacity), size(0)\n    {\n        // ä½¿ç”¨è™šæ‹Ÿå¤´èŠ‚ç‚¹ã€å°¾èŠ‚ç‚¹\n        head = new LinkedNode();\n        tail = new LinkedNode();\n        head->next = tail;\n        tail->pre = head;\n    }\n\n    int get(int key)\n    {\n        if (!cache.count(key))\n        {\n            return -1;\n        }\n        LinkedNode *node = cache[key];\n        moveToHead(node);\n        return node->val;\n    }\n\n    void put(int key, int val)\n    {\n        if (!cache.count(key))\n        {\n            LinkedNode *node = new LinkedNode(key, val);\n            cache[key] = node;\n            addToHead(node);\n            size++;\n            if (size > capacity)\n            {\n                LinkedNode *removed = removeTail();\n                cache.erase(removed->key);\n                delete removed;\n                size--;\n            }\n        }\n        else\n        {\n            LinkedNode *node = cache[key];\n            node->val = val;\n            moveToHead(node);\n        }\n    }\n    void addToHead(LinkedNode *node)\n    {\n        node->pre = head;\n        node->next = head->next;\n        head->next->pre = node;\n        head->next = node;\n    }\n    void removeNode(LinkedNode *node)\n    {\n        node->pre->next = node->next;\n        node->next->pre = node->pre;\n    }\n    void moveToHead(LinkedNode *node)\n    {\n        removeNode(node);\n        addToHead(node);\n    }\n    LinkedNode *removeTail()\n    {\n        LinkedNode *node = tail->pre;\n        removeNode(node); // åŒå‘é“¾è¡¨ä¸å¯ä»¥ç›´æ¥åˆ é™¤\n        return node;\n    }\n\nprivate:\n    unordered_map<int, LinkedNode *> cache;\n    LinkedNode *head;\n    LinkedNode *tail;\n    int size;\n    int capacity;\n};\n```\n\n#### Complexity\n\n* Time\n  * put O(1)\n  * get O(1)\n* Space O(capacity)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196155638","body":"#### Idea\n\n`f(root)=1+max(f(root->left),f(root->right))`\n\n/å±‚åºéå†ï¼Œè®¡æ•°å±‚æ•°\n\n#### Code\n\n```cpp\nclass Solution\n{\npublic:\n    int maxDepth(TreeNode *root)\n    {\n        if (root == nullptr)\n        {\n            return 0;\n        }\n        int left = maxDepth(root->left);\n        int right = maxDepth(root->right);\n        return 1 + max(left, right);\n    }\n};\n```\n\n#### Complexity\n\n* Time O(N)\n  * N: nodes\n* Space O(h)\n  * h: depth","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197531458","body":"### 100 ç›¸åŒçš„æ ‘\n\n#### Idea\n\néå†ï¼Œé€»è¾‘å¤„ç†ä¸­åˆ¤æ–­æ˜¯å¦ç›¸åŒã€‚\n\n#### Code\n\n```cpp\nclass Solution\n{\npublic:\n    bool isSameTree(TreeNode *p, TreeNode *q)\n    {\n        if (p == nullptr && q == nullptr)\n        {\n            return true;\n        }\n        else if (p == nullptr || q == nullptr)\n        {\n            return false;\n        }\n        else if (p->val != q->val)\n        {\n            return false;\n        }\n        return isSameTree(p->left, q->left) &&\n               isSameTree(p->right, q->right);\n    }\n};\n```\n\n#### Complexity\n\n* Time O(N)\n* Space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198784793","body":"### 129 æ±‚æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹æ•°å­—ä¹‹å’Œ\n\n#### Idea\n\nDFSï¼šæ‰¾å‡ºæ¯æ¡æ ¹åˆ°èŠ‚ç‚¹çš„è·¯å¾„ï¼Œæ±‚å’Œç›¸åŠ ã€‚\n\nBFSï¼šé€å±‚å–å€¼ï¼Œä¸‹ç§»ï¼Œæœ€åç›¸åŠ ã€‚\n\n#### Code\n\n```cpp\nclass Solution\n{\nprivate:\n    int sum = 0;\n\npublic:\n    void dfs(TreeNode *root, int num)\n    {\n        if (!root)\n        {\n            return;\n        }\n        if (!root->left && !root->right)\n        {\n            sum += num * 10 + root->val;\n        }\n        dfs(root->left, num * 10 + root->val);\n        dfs(root->right, num * 10 + root->val);\n    }\n    int sumNumbers(TreeNode *root)\n    {\n        dfs(root, 0);\n        return sum;\n    }\n};\n```\n\n```cpp\nclass Solution\n{\npublic:\n    int sumNumbers(TreeNode *root)\n    {\n        if (!root)\n        {\n            return 0;\n        }\n        queue<TreeNode *> qt;\n        qt.push(root);\n        int sum = 0;\n\n        while (!qt.empty())\n        {\n            int size = qt.size();\n            while (size--)\n            {\n                TreeNode *node = qt.front();\n                qt.pop();\n                if (node->left)\n                {\n                    node->left->val += 10 * node->val;\n                    qt.push(node->left);\n                }\n                if (node->right)\n                {\n                    node->right->val += 10 * node->val;\n                    qt.push(node->right);\n                }\n                if (!node->left && !node->right)\n                {\n                    sum += node->val;\n                }\n            }\n        }\n        return sum;\n    }\n};\n```\n\n#### Complexity\n\n* BFS\n\n  * Time O(N)\n\n  * Space O(h)\n\n* DFS\n  * Time O(N)\n  * Space O(q)\n  * æç«¯æƒ…å†µä¸ºå®Œå…¨äºŒå‰æ ‘ï¼Œå¶å­èŠ‚ç‚¹ä¸ºn/2 -->O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200446099","body":"#### Idea\n\nEncode: DFS\n\nDecode: DFS + queue\n\n#### Code\n\n```\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n    private String SEP = \",\";\n    private String NULL = \"#\";\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        shelp(root, sb);\n        return sb.toString();\n    }\n    \n    private void shelp(TreeNode root, StringBuilder sb) {\n        if (root == null) {\n            sb.append(NULL).append(SEP);\n            return ;\n        }\n        sb.append(root.val).append(SEP);\n        shelp(root.left, sb);\n        shelp(root.right, sb);\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        String[] input = data.split(SEP);\n        Queue<String> q = new ArrayDeque<>();\n        for (String s : input) {\n            q.offer(s);\n        }\n        return dhelp(q);\n    }\n    \n    private TreeNode dhelp(Queue<String> q) {\n        String cur = q.poll();\n        if (cur.equals(NULL)) {\n            return null;\n        }\n        int val = Integer.parseInt(cur);\n        TreeNode root = new TreeNode(val);\n        root.left = dhelp(q);\n        root.right = dhelp(q);\n        return root;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser = new Codec();\n// Codec deser = new Codec();\n// TreeNode ans = deser.deserialize(ser.serialize(root));\n```\n\n#### Complexity\n\n* Time: O(N)\n* Space: O(N)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207414186","body":"#### Brute Idea\n\næšä¸¾æ‰€æœ‰çš„è¿ç»­å­æ•°ç»„ï¼Œè®¡ç®—sum_rangeï¼›å–æœ€çŸ­ã€‚\n\n#### Idea\n\nè¢« x æ•´é™¤ï¼Œæ±‚ä½™æ•°ç­‰é—®é¢˜ --> å°è¯•ä½¿ç”¨åŒä½™å®šç†ä¼˜åŒ–ï¼›è¿ç»­å­æ•°ç»„å’Œ --> å°è¯•ä½¿ç”¨å‰ç¼€å’Œè¿›è¡Œä¼˜åŒ–ã€‚\n\nå°†å‰ç¼€å’Œæ¨¡ k çš„ä½™æ•° x æ”¾åˆ°å“ˆå¸Œè¡¨ä¸­ï¼Œå“ˆå¸Œè¡¨å……å½“å‰ç¼€å’Œçš„è§’è‰²ï¼Œæ¥è®°å½•æœ€æ–°çš„ä½™æ•° x å¯¹åº”çš„ä¸‹æ ‡ï¼Œè®°å½•æœ€æ–°çš„ç›®çš„æ˜¯ä¸ºäº†æ‰¾å‡ºç¬¦åˆè¦æ±‚çš„æœ€çŸ­çš„è¿ç»­å­æ•°ç»„ã€‚å…ˆè®¡ç®—å‡ºæ€»ä½“çš„æ•°ç»„å’Œ total æ¨¡ k çš„ä½™æ•°ï¼Œè®°ä¸º targetï¼Œå†æ‰¾ä¸€æ®µæ¨¡ k ç­‰äº target çš„å­æ•°ç»„å³å¯ã€‚\n$$\nfind\\ delete\\ s.t.\\ (total-delete)\\%k=0\n\\\\total\\%k=delete\\%k\n\\\\delete\\%k=(pre[j]-pre[i-1])\\%k\n\\\\and\\ target=total\\%k\n\\\\equal\\ to\\ find\\ (pre[j]-pre[i-1])\\%k=target\n\\\\target=target\\%k\n\\\\(pre[j]-pre[i-1]-target)\\%k=0\n\\\\(pre[j]-target)\\%k=pre[i-1]\\%k\n$$\n\n#### Code\n\n```c++\nint floorMod(const int& a,const int& b)\n{\n    // è§£å†³æ­£è´Ÿæ•°æ±‚ä½™ç»Ÿä¸€\n    // -1%4 --> 3\n    // -1+4 % 4 --> 3\n    return (a%b+b)%b;\n}\n\nint solve(vector<int>& nums, int k) {\n    int total=0;\n    for(int& num:nums)\n    {\n        total+=num;\n    }\n    int target=floorMod(total,k);\n    unordered_map<int,int> dict;\n    // æå‰åœ¨å“ˆå¸Œè¡¨ä¸­æ”¾ä¸€ä¸ª0:-1ï¼Œä»¥åº”å¯¹ä»æ•°ç»„ç´¢å¼•0å¤„å¼€å§‹å–å­æ•°ç»„çš„æƒ…å†µ\n    dict[0]=-1;\n\n    int pre=0;\n    int minLen=nums.size();\n    for(int i=0;i<nums.size();i++)\n    {\n        pre+=nums[i];\n        int mod=floorMod(pre,k);\n        dict[mod]=i;\n\n        if(dict.count(floorMod(pre-target,k)))\n        {\n            minLen=min(minLen,i-dict[floorMod(pre-target,k)]);\n        }\n    }\n    return minLen==nums.size()?-1:minLen;\n}\n```\n\n#### Complexity\n\n* The time complexity is O(n) since hash table operations are O(1).\n\n* The space complexity is O(min(n,k)) because there can be at most O(min(n,k)) elements in the hash table.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207662439","body":"Ideaï¼šå¿«æ…¢æŒ‡é’ˆ\nclass Solution\n{\npublic:\n    ListNode *middleNode(ListNode *head)\n    {\n        ListNode *fast = head;\n        ListNode *slow = head;\n        while (fast && fast->next)\n        {\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208772826","body":"#### Idea \nè¯»å†™æŒ‡é’ˆ\n#### Code\n\n```c++\nclass Solution\n{\npublic:\n    int removeDuplicates(vector<int> &nums)\n    {\n        int p1 = 0;\n        int p2 = 1;\n        while (p2 < nums.size())\n        {\n            if (nums[p2] != nums[p1])\n            {\n                p1++;\n                nums[p1] = nums[p2];\n            }\n            p2++;\n        }\n        return p1 + 1;\n    }\n};\n```\n\n#### Complexity\n\n* Time O(N)\n* Space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/42#issuecomment-1210022102","body":"Ideaï¼šäºŒåˆ†æŸ¥æ‰¾\nclass Solution\n{\npublic:\n    int searchInsert(vector<int> &nums, int target)\n    {\n        int n = nums.size();\n        if (nums[0] > target)\n        {\n            return 0;\n        }\n        if (nums[n - 1] < target)\n        {\n            return n;\n        }\n        // å·¦è¾¹ç•Œ<=target\n        int l = 0;\n        int r = n - 1;\n        while (l < r)\n        {\n            int mid = (l + r + 1) >> 1;\n            if (nums[mid] <= target)\n            {\n                l = mid;\n            }\n            else\n            {\n                r = mid - 1;\n            }\n        }\n        // æ‰¾åˆ°è¿”å›ä½ç½®\n        if (nums[l] == target)\n        {\n            return l;\n        }\n        else\n        {\n            return l + 1;\n        }\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nuomituxedo":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185093417","body":"## æ€è·¯\r\n1. convert to num to integer\r\n2. add k to integer to get sum\r\n3. convert sum to list of integers\r\n\r\n## ä»£ç  ï¼ˆPython)\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num_int = int(''.join(map(str, num)))\r\n        sum = num_int + k\r\n        new_num = []\r\n        for d in str(sum):\r\n            new_num.append(int(d))\r\n        return new_num\r\n```\r\n\r\næ—¶é—´å¤æ‚åº¦ï¼š O(n)\r\nç©ºé—´å¤æ‚åº¦ï¼š O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186098624","body":"## æ€è·¯\r\n1. initialize the res array with the largest possible distanceï¼šlen(s) \r\n2. iterate through the input, if we encounter c, update res for indices < index of latest c and memorize the index of the latest c\r\n3. update res for indices >= index of latest c until we encounter the next c\r\n\r\n## Code\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        last_c = 0\r\n        for i in range(0, len(s)):\r\n            res.append(len(s))\r\n        for i in range(0, len(s)):\r\n            if s[i] == c:\r\n                #update left hand side up to the last seen c\r\n                for j in range (last_c, i):\r\n                    res[j] = min(res[j], i-j)\r\n                last_c = i\r\n                #update right hand side\r\n                for j in range (i, len(s)):\r\n                    res[j] = j - i\r\n                    # stop updating right side if see next c\r\n                    if s[j] == c:\r\n                        continue\r\n        return res\r\n```\r\n\r\n### time complexity: O(n)\r\n### space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186290559","body":"## æ€è·¯ (python)\nç”¨listæ¥å®ç°stack\n\n## Code\n\n```python\n\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.n = maxSize\n        self.stack = []\n        self.inc = []\n        \n    def push(self, x: int) -> None:\n        if len(self.stack) == self.n: return\n        self.stack.append(x)\n        return\n        \n\n    def pop(self) -> int:\n        if not self.stack: return -1\n        return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(0, min(len(self.stack), k)):\n            self.stack[i] += val\n```\n\n## æ—¶é—´å¤æ‚åº¦\npop: O(1) \npush: O(1)\nincrement: O(k), 1<= k <=n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187674314","body":"## æ€è·¯ ï¼ˆç”¨stack)\néå†input string\nå¦‚æœelementä¸æ˜¯â€œ]\", æ”¾è¿›stack\nå¦‚æœelementæ˜¯â€[\", ç®—å‡ºrepeatSubstring, ç„¶åæ”¾å…¥stack\næœ€åæŠŠè¿”å›stacké‡Œçš„elements as a string\n\n## Code (python)\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack=[]\n        for c in s:\n            if c != \"]\":\n                stack.append(c)\n            else:\n                repeatSubstring=\"\"\n                multiplier=\"\"\n                while stack and stack[-1] !='[':\n                    repeatSubstring = stack.pop() + repeatSubstring\n                stack.pop() #remove '['\n                while stack and stack[-1].isnumeric():\n                    multiplier=stack.pop() + multiplier\n                stack.append(repeatSubstring*int(multiplier))\n        return \"\".join(stack)\n```\n\n### time complexity: O(n)\n### space compolexity: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189212437","body":"## æ€è·¯ \nç”¨ä¸¤ä¸ªstackæ¥å®ç°queue, stack2çš„ä½œç”¨æ˜¯æš‚æ—¶ç¼“å­˜stack1çš„elements\n\n## Code (python)\n```Python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1=[]\n        self.stack2=[]\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n        \n\n    def pop(self) -> int:\n        front_element=None\n        while(self.stack1):\n            self.stack2.append(self.stack1.pop())\n        front_element=self.stack2.pop()\n        while(self.stack2):\n            self.stack1.append(self.stack2.pop())\n        return front_element\n\n    def peek(self) -> int:\n        front_element=None\n        while(self.stack1):\n            self.stack2.append(self.stack1.pop())\n        front_element=self.stack2[-1]\n        while(self.stack2):\n            self.stack1.append(self.stack2.pop())\n        return front_element\n\n    def empty(self) -> bool:\n        return len(self.stack1)==0\n```\n\n### æ—¶é—´å¤æ‚åº¦ï¼š push O(1), popå’Œpeek O(n), empty O(1)\n### ç©ºé—´å¤æ‚åº¦ï¼š O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190445393","body":"## æ€è·¯\nå‚è€ƒäº†ç­”æ¡ˆ è‡ªå·±æ²¡æƒ³å‡ºæ¥\nThe key idea here is: at any time where both counter arrays are identical it means we've reached a new sortable chunk \n\n## code:\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        chunks, counter_a, counter_b = 0, collections.Counter(), collections.Counter()\n        for a, b in zip(arr, sorted(arr)):\n            counter_a[a] += 1\n            counter_b[b] += 1\n            #at any time where both counter arrays are identical\n            #it means we've reached a new sortable chunk \n            chunks += counter_a == counter_b\n        return chunks\n```\n\n### time complexity:  sorting: O(nlogn), check for identical counter arrays: O(n^2) --> overall: O(n^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190970849","body":"## æ€è·¯\r\nbrute force\r\nå¦‚æœheadä¸ºç©º ç›´æ¥è¿”å›ç©º\r\nå…ˆéå†ä¸€élinkedlistæ‰¾åˆ°é•¿åº¦ï¼Œå…ˆç®€åŒ–ä¸€ä¸‹k (k=k % length)\r\néå†åˆ°å€’æ•°kçš„node åˆ‡æ–­ä¸å‰é¢nodeçš„è¿æ¥ è®©å®ƒå˜æˆæ–°çš„head node\r\næŠŠç¬¬äºŒä¸ªlinkedlistçš„å°¾å·´è¿åˆ°åŸå§‹çš„headä¸Š\r\n\r\n##ä»£ç ï¼ˆPythonï¼‰\r\n```python\r\n\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        ### return if head is empty\r\n        if not head: return None\r\n        \r\n        # find out the total number of nodes in the linkedlist\r\n        # apply modulo to k to get the actual number of rotations needed\r\n        length = -1\r\n        dummy = ListNode(0)\r\n        dummy.next = head\r\n        while dummy:\r\n            length += 1\r\n            dummy = dummy.next\r\n        k = k % length\r\n        # if no rotation is needed, directly return head\r\n        if k == 0: return head\r\n        \r\n        # 1. create a dummy node, travel the list nodes to the node to be cut (new end)\r\n        # 2. after this operation we end up with 2 smaller linkedlists\r\n        dummy = ListNode(0)\r\n        dummy.next = head\r\n        for i in range(0, length - k):\r\n            dummy = dummy.next\r\n        new_head = ListNode(0)\r\n        new_head = dummy.next # new_head points to the new head node\r\n        \r\n        dummy.next = None #make dummy the end node, now we have 2 linkedlists\r\n        \r\n        # 3. create dummy2 to point to the second linkedlist and travel to its end node\r\n        dummy2 = ListNode(0)\r\n        dummy2 = new_head\r\n        \r\n        while dummy2.next:\r\n            dummy2 = dummy2.next\r\n        \r\n        # 4. now relink the two linkedlists\r\n        dummy2.next = head\r\n        return new_head\r\n```\r\nç©ºé—´å¤æ‚åº¦ï¼š O(1)\r\næ—¶é—´å¤æ‚åº¦ï¼š O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192169689","body":"## æ€è·¯ \nReturn head if it's empty or is a single node\nSwap two nodes at a time, and recursion with the next node\n\n## Code (Python)\n```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next: return head\n        \n        #swap two nodes at a time and recursion with the next node\n        a = head #first node\n        b = head.next #second node\n        c = head.next.next #third node\n        \n        #let the first node point to the third node\n        #the third node passed in the next recursive call\n        a.next = self.swapPairs(c)\n        #let the second node point to the first node (backtracking)\n        b.next = a\n        return b\n```\nTime complexity: O(n)\nSpace complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193063477","body":"## æ€è·¯ recursion\n## ä»£ç \n```python\n\nclass Solution:\n    def sortedListToBST(self, head):\n        if not head:\n            return \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow, fast = head, head.next.next\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n\n        # mid points to root\n        mid = slow.next\n\n        # cut down the left child\n        slow.next = None\n       \n        # recursion\n        root = TreeNode(mid.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(mid.next)\n        return root\n```\n\nO(n) time, O(1) space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193339415","body":"## æ€è·¯ \nTwo pointers: first pointer iterate linkedlist A then linkedlist B, second point iterates linkedlist B then linkedlistA\nAssuming there is an intersection, if linkedlist A and linkedlist B have different lengths before the intersection, both pointers would have visited the same nodes (but in different order) prior to both reaching the intersection node.\n\nIf there's no intersection, after both pointers have travelled both linkedlists, the iteration loop will terminate and return null.\n\n## code\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        dummyA=ListNode(0)\n        dummyB=ListNode(0)\n        dummyA.next = headA\n        dummyB.next = headB\n        while headA or headB:\n            if headA == headB:\n                return headA\n            headA = headA.next if headA else dummyB.next\n            headB = headB.next if headB else dummyA.next\n        return None\n```\nTime: O(n)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193558504","body":"##æ€è·¯ \r\nhash set\r\n## code\r\n\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        visited = {} # a hash set\r\n        \r\n        while head and head not in visited:\r\n            visited[head] = index\r\n            head = head.next\r\n           \r\n        return head\r\n```\r\ntime: O(n), space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195619382","body":"## æ€è·¯\nOrderedDict\n\n## Code\n\n```python\n\nfrom collections import OrderedDict\n\nclass LRUCache(OrderedDict):\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key not in self:\n            return - 1\n        self.move_to_end(key)\n        return self[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self:\n            self.move_to_end(key)\n        self[key] = value\n        if len(self) > self.capacity:\n            self.popitem(last = False)\n            \n```\ntime complexity: get and put: O(1)\nspace complexity: O(n), n = capacity","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196275531","body":"## æ€è·¯\nRecursion, at each level of the recursive call, return 1 + the max of the node's left and right\n\n## code\n\n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root: return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n```\ntime: O(n)  space: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198321758","body":"## æ€è·¯ \r\nrecursion\r\n\r\n## code\r\n```python\r\nclass Solution:\r\n    #recursion\r\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n        if not p and not q: \r\n            return True\r\n        \r\n        if not p or not q: \r\n            return False\r\n        if p.val != q.val: return False\r\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```\r\ntime: O(n) \r\nspace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199601069","body":"## æ€è·¯ Recursion, at each recursive call, multiply parent node's sum by 10\n\n## code\n\n```python\nclass Solution:\n    #recursion\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        self.res = 0\n        self.dfs(root, 0)\n        return self.res\n    \n    def dfs(self, root, path):\n        if root:\n            if not root.left and not root.right:\n                path = path*10 + root.val\n                self.res += path\n            self.dfs(root.left, path*10+root.val)\n            self.dfs(root.right, path*10+root.val)\n```\n\ntimeï¼šO(n)\nspace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200238636","body":"# æ€è·¯  BFS\n\n## code\n```python\n\nclass Solution:\n    def findBottomLeftValue(self, root: 'TreeNode') -> 'int':\n        queue = [root]\n        while queue:\n            node = queue.pop(0)\n            res = node.val\n            if node.right:\n                queue.append(node.right)\n            if node.left:\n                queue.append(node.left)\n        return res\n\n```\n\ntime: O(n) \nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200484168","body":"## æ€è·¯\nrecursive DFS to serialize to string\nto deserialize, convert string to a list of string first, then recursively reconstruct the tree in the same order as it was previously serialized.\n\n## code\n```python\n\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        def serializeNode(node, serializedString):\n            if node == None:\n                serializedString += 'None,'\n            else:\n                serializedString += str(node.val) + ','\n                serializedString = serializeNode(node.left, serializedString)\n                serializedString = serializeNode(node.right, serializedString)\n            \n            return serializedString\n\n        return serializeNode(root, '')\n\n                \n        \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        def deserializeNode(serializedStringList):\n            if serializedStringList[0] == 'None':\n                serializedStringList.pop(0)\n                return None\n            \n            node = TreeNode(serializedStringList[0])\n            serializedStringList.pop(0)\n            node.left = deserializeNode(serializedStringList)\n            node.right = deserializeNode(serializedStringList)\n            return node\n        \n        #convert serialized string to a list of string values, \n        #each string represents the value of a node\n        serializedStringList = data.split(',')\n        print(serializedStringList)\n        root=deserializeNode(serializedStringList)\n        return root\n\n```\nserialize: time is O(n), space is O(1) if we count the serialized string as 1\ndeserialize: time is O(n), space is O(n) since we had to convert he serialized string to a list of strings where length of string == total number of tree nodes","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200713421","body":"## æ€è·¯\nStep 1: use recursion to travel through the tree to build a list containing each node's [value, row col] values.\n\nStep 2: construct a nested dictionary where the key is col, value is a dict where the row is key, and a list of values as value.\n\nStep 3: construct result from above dictionary\n\n## code\n\n```python\n\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        #Step 1: recursively (DFS) map each node with its value, row and col\n        #res becomes a list containing lists of such value, row, col pairs\n        def mapper(root, res, row, col):\n            if not root:\n                return\n            res.append([root.val, row, col])\n            mapper(root.left, res, row+1, col-1)\n            mapper(root.right, res, row+1, col+1)\n            return res\n        \n        #nodes is a list containing lists. Each list contains a node's value, row, col \n        nodes = mapper(root, [], 0, 0)\n        \n        #Step 2: create a dictionary where key is the col value, values is a list of node values \n        verticalOrderTraversal = {}\n        for node in nodes:\n            val = node[0]\n            row = node[1]\n            col = node[2]\n            if col in verticalOrderTraversal:\n                if row in verticalOrderTraversal[col]:\n                    verticalOrderTraversal[col][row].append(val)\n                    print('exisitng row, add val to list',verticalOrderTraversal[col][row] )\n                else:\n                    newList = [val]\n                    verticalOrderTraversal[col][row] = newList\n                    print('adding new row', newList, verticalOrderTraversal[col][row] )\n            else:\n                newColDict = {}\n                newColDict[row] = [val]\n                verticalOrderTraversal[col] = newColDict\n                \n                \n        #Sort the dictionary by column key\n        sortedTraversal = dict(sorted(verticalOrderTraversal.items(), key=lambda x:x[0]))\n        \n        #Sort the dictionary by row key\n        for col in sortedTraversal:\n            sortedTraversal[col] = dict(sorted(sortedTraversal[col].items(), key=lambda x:x[0]))\n            \n        #Step 3: create the final result from the dictionary with sorted keys\n        resultList = []\n        for col in sortedTraversal.keys():\n            item = []\n            for row in sortedTraversal[col]:\n                #before adding the value list to resultList, remember to sort the list\n                for value in sorted(sortedTraversal[col][row]):\n                    item.append(value)\n            resultList.append(item)\n        return resultList\n        \n```\ntime: O(nlogn)\nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202848257","body":"## æ€è·¯\nç”¨dictionaryè®°å½•å·²ç»éå†è¿‡å¾—å€¼å’ŒIndex\n\n## code\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        mapper = {} #dictionary\n        for i in range(0, len(nums)):\n            complement = target - nums[i]\n            if complement in mapper:\n                j = mapper[complement]\n                return [j, i]\n            else:\n                mapper[nums[i]] = i\n        return\n```\ntimeï¼šO(n)\nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1204148448","body":"## æ€è·¯ \nHeap\n\n##  Code\n```python\nfrom collections import Counter\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]: \n        # O(1) time \n        if k == len(nums):\n            return nums\n        \n        # Step 1. build hash map : character as key and frequency as value\n        # O(N) time\n        count = Counter(nums)   \n        # Step 2. build heap of top k frequent elements\n        # Step3. convert it into an output array\n        return heapq.nlargest(k, count.keys(), key=count.get) \n```\nTime O(N log k) \nSpace O(N + k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205443728","body":"```python\nclass Solution:\n    def numberOfBoomerangs(self, points):\n        n = 0\n        for a,b in points:\n            counter = {}\n            for x,y in points:\n                #x,y == a,b can only be registered once\n                key = (x-a)**2 + (y-b)**2\n                if key in counter:\n                    n += 2*counter[key]\n                    counter[key] += 1\n                else:\n                    counter[key] = 1\n        return n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206611073","body":"```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        def check(start, end):\n            chars = set()\n            for i in range(start, end + 1):\n                c = s[i]\n                if c in chars:\n                    return False\n                chars.add(c)\n            return True\n\n        n = len(s)\n\n        maxlen = 0\n        for i in range(n):\n            for j in range(i, n):\n                if check(i, j):\n                    res = max(res, j - i + 1)\n        return m\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207435096","body":" è‡ªå·±æ²¡æƒ³å‡ºæ¥ æŠ„ç­”æ¡ˆäº†\n\n```python\nclass Solution:\n    def solve(self, nums, k):\n        total = sum(nums)\n        mod = total % k\n\n        ans = len(nums)\n        total = 0\n        dic = {0: -1}\n        for j in range(len(nums)):\n            total += nums[j]\n            cur = total % k\n            target = (cur - mod + k) % k\n            if target in dic:\n                ans = min(ans, j - dic[target])\n            dic[cur] = j\n\n        if ans == len(nums):\n            return -1\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207439875","body":"## æ€è·¯\nå¿«æ…¢æŒ‡é’ˆ å¿«çš„æ¯æ¬¡èµ°ä¸¤æ­¥ æ…¢çš„æ¯æ¬¡èµ°ä¸€æ­¥\n\n## ä»£ç \n```python\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow = ListNode(0)\n        slow.next = head\n        fast = ListNode(0)\n        fast.next = head\n        #move slow and fast to head\n        slow = slow.next\n        fast = fast.next\n        while fast != None and slow.next != None and fast.next!= None:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n```\næ—¶é—´O(n) ç©ºé—´O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209529382","body":"æ€è·¯ï¼štwo pointers\n ```python\nclass Solution:\n    #two pointers\n    def removeDuplicates(self, nums: List[int]) -> int:\n        i = 1\n        for j in range(len(nums)-1):\n            if nums[j] != nums[j+1]:\n                nums[i] = nums[j+1]\n                i+=1\n        return i\n    \n```\ntime O(n) space O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhongranherz":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185096544","body":"## æ€è·¯\n1.å°† numå’Œkä»åå¾€å‰ç›¸åŠ ï¼Œä¸¤è€…é•¿åº¦æœªçŸ¥ï¼Œé€šè¿‡ while k!=0 or i>=0 æ¥ä½¿é•¿åº¦ç»Ÿä¸€ã€‚\n2.æ¯ä¸€ä½çš„ç´¯åŠ å’Œsumæ”¾å…¥resä¸­ï¼Œæ˜¯å¦è¿›ä½é€šè¿‡carryåˆ¤æ–­ã€‚\n3.whileå®Œæ¯•åï¼Œéœ€è¦åˆ¤æ–­carryæ˜¯å¦ä¸ºé›¶ã€‚\n\n##  pythonä»£ç \n``` python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res=[]\n        carry=0\n        i=len(num)-1\n        while k!=0 or i>=0:\n            x=num[i] if i>=0 else 0 \n            y=k%10 if k!=0 else 0\n\n            sum = x+y+carry\n            res.append(sum%10)\n            carry=sum//10\n\n            i-=1\n            k//=10\n        \n        if carry!=0: res.append(carry)\n\n        return res[::-1]\n```\n## å¤æ‚åº¦åˆ†æ\nè®¾Nä¸ºæ•°ç»„é•¿åº¦\næ—¶é—´å¤æ‚åº¦ï¼š O(max(Nï¼ŒK))\nç©ºé—´å¤æ‚åº¦ï¼š O(max(Nï¼ŒK))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186190287","body":"```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        res = [n+1]*n\n        idx = -1\n        for i in range(n):  # å·¦ä¾§ c ä½ç½®\n            if s[i]==c:\n                idx = i\n            if idx!=-1:\n                res[i] = i - idx\n        idx = n\n        for i in range(n-1,-1,-1): # å³ä¾§ c ä½ç½®\n            if s[i] == c:\n                idx = i\n            if idx!= n:\n                res[i]= min(idx - i,res[i])\n        return res\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186413552","body":"## pythonä»£ç \n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack=[]\n        self.length=0\n        self.maxSize=maxSize\n    def push(self, x: int) -> None:\n        if self.length!=self.maxSize:\n            self.stack.append(x)\n            self.length+=1\n\n    def pop(self) -> int:\n        if self.stack:\n            self.length-=1\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,self.length)):\n            self.stack[i]+=val\n\n```\n## å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦ï¼šO(n)\nç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186814030","body":"è§£æ³•ä¸€ï¼šè¾…åŠ©æ ˆæ³•\næœ¬é¢˜éš¾ç‚¹åœ¨äºæ‹¬å·å†…åµŒå¥—æ‹¬å·ï¼Œéœ€è¦ä»å†…å‘å¤–ç”Ÿæˆä¸æ‹¼æ¥å­—ç¬¦ä¸²ï¼Œè¿™ä¸æ ˆçš„å…ˆå…¥åå‡ºç‰¹æ€§å¯¹åº”ã€‚\n\nç®—æ³•æµç¨‹ï¼š\n\næ„å»ºè¾…åŠ©æ ˆ stackï¼Œ éå†å­—ç¬¦ä¸² s ä¸­æ¯ä¸ªå­—ç¬¦ cï¼›\n\tå½“ c ä¸ºæ•°å­—æ—¶ï¼Œå°†æ•°å­—å­—ç¬¦è½¬åŒ–ä¸ºæ•°å­— multiï¼Œç”¨äºåç»­å€æ•°è®¡ç®—ï¼›\n\tå½“ c ä¸ºå­—æ¯æ—¶ï¼Œåœ¨ res å°¾éƒ¨æ·»åŠ  cï¼›\n\tå½“ c ä¸º [ æ—¶ï¼Œå°†å½“å‰ multi å’Œ res å…¥æ ˆï¼Œå¹¶åˆ†åˆ«ç½®ç©ºç½® 0ï¼š\n\t\tè®°å½•æ­¤ [ å‰çš„ä¸´æ—¶ç»“æœ res è‡³æ ˆï¼Œç”¨äºå‘ç°å¯¹åº” ] åçš„æ‹¼æ¥æ“ä½œï¼›\n\t\tè®°å½•æ­¤ [ å‰çš„å€æ•° multi è‡³æ ˆï¼Œç”¨äºå‘ç°å¯¹åº” ] åï¼Œè·å– multi Ã— [...] å­—ç¬¦ä¸²ã€‚\n\t\tè¿›å…¥åˆ°æ–° [ åï¼Œres å’Œ multi é‡æ–°è®°å½•ã€‚\n\tå½“ c ä¸º ] æ—¶ï¼Œstack å‡ºæ ˆï¼Œæ‹¼æ¥å­—ç¬¦ä¸² res = last_res + cur_multi * resï¼Œå…¶ä¸­:\n\t\tlast_resæ˜¯ä¸Šä¸ª [ åˆ°å½“å‰ [ çš„å­—ç¬¦ä¸²ï¼Œä¾‹å¦‚ \"3[a2[c]]\" ä¸­çš„ aï¼›\n\t\tcur_multiæ˜¯å½“å‰ [ åˆ° ] å†…å­—ç¬¦ä¸²çš„é‡å¤å€æ•°ï¼Œä¾‹å¦‚ \"3[a2[c]]\" ä¸­çš„ 2ã€‚\nè¿”å›å­—ç¬¦ä¸² resã€‚\n\nå¤æ‚åº¦åˆ†æï¼š\n\næ—¶é—´å¤æ‚åº¦ O(N)ï¼Œä¸€æ¬¡éå† sï¼›\nç©ºé—´å¤æ‚åº¦ O(N)ï¼Œè¾…åŠ©æ ˆåœ¨æç«¯æƒ…å†µä¸‹éœ€è¦çº¿æ€§ç©ºé—´ï¼Œä¾‹å¦‚ 2[2[2[a]]]ã€‚\n\n```\n# kç¥å†™æ³•\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack, res, multi = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append([multi, res])\n                res, multi = \"\", 0\n            elif c == ']':\n                cur_multi, last_res = stack.pop()\n                res = last_res + cur_multi * res\n            elif '0' <= c <= '9': # è¿™é‡Œç”¨isdigitï¼ˆï¼‰åˆé€‚\n                multi = multi * 10 + int(c)            \n            else:\n                res += c\n        return res\n\n# è‡ªå·±çš„\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []  # (str, int) è®°å½•ä¹‹å‰çš„å­—ç¬¦ä¸²å’Œæ‹¬å·å¤–çš„ä¸Šä¸€ä¸ªæ•°å­—\n        num = 0\n        res = \"\"  # å®æ—¶è®°å½•å½“å‰å¯ä»¥æå–å‡ºæ¥çš„å­—ç¬¦ä¸²\n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c == \"[\":\n                stack.append((res, num))\n                res, num = \"\", 0\n            elif c == \"]\":\n                top = stack.pop()\n                res = top[0] + res * top[1]\n            else:\n                res += c\n        return res\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188539903","body":"# ç”¨ä¸¤ä¸ªæ ˆè§£å†³\n```\nclass MyQueue:\n\n    def __init__(self):\n        self.A, self.B = [], []\n    \n    def push(self, x: int) -> None:\n        self.A.append(x)\n\n    def pop(self) -> int:\n        if self.B: return self.B.pop()\n        #if not self.A: return -1\n        while self.A:\n            self.B.append(self.A.pop())\n        return self.B.pop()\n\n    def peek(self) -> int:\n        if self.B: return self.B[-1]\n        #if not self.A: return -1\n        while self.A:\n            self.B.append(self.A.pop())\n        return self.B[-1]\n\n    def empty(self) -> bool:\n        if self.A or self.B:\n            return False\n        else:\n            return True\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189768482","body":"ç†è§£æ’åºå—ï¼šä¹Ÿå°±æ˜¯åˆ†å¥½å—ä¹‹åè¿›è¡Œæ’åºï¼Œå°†æ‰€æœ‰å—è¿åœ¨ä¸€èµ·å¯ä»¥æˆä¸ºå‡åºæ’åºã€‚\næ¯”å¦‚[7ï¼Œ8ï¼Œ1]ï¼Œåé¢å‡ºç°äº†ä¸€ä¸ª1ï¼Œå¯¼è‡´å‰é¢çš„éƒ½éœ€è¦ä¸€èµ·æ’åºã€‚\n\nå¦‚ä½•å°†é¢˜ç›®å’Œå•è°ƒæ ˆè”ç³»åœ¨ä¸€èµ·ï¼š\n1 å•è°ƒæ ˆï¼Œä¿è¯æ ˆæ˜¯é€’å¢çš„ï¼Œå¦‚æœå‡ºç°ä¸€ä¸ªå°äºæ ˆé¡¶çš„æ•°å­—xï¼Œä¿å­˜æ ˆé¡¶å¹¶å¼¹å‡ºï¼Œç„¶åå¼¹å‡ºæ ˆä¸­æ¯”xå°çš„æ•°å­—ï¼Œæœ€åå­˜å…¥æ ˆé¡¶ã€‚è®°å½•æ ˆçš„é•¿åº¦\n2 é¢˜ç›®ä¸­ï¼Œæ•°ç»„éœ€è¦æ˜¯é€’å¢çš„ï¼Œå¦‚æœå‡ºç°ä¸€ä¸ªå°äºå‰é¢æ•°å­—çš„æ•°å­—xï¼Œåˆ™å°†å‰é¢å¤§äºxçš„æ•°å­—éƒ½éœ€è¦è¿›è¡Œæ’åºï¼ˆç±»ä¼¼ä¸Šé¢æ ˆé¡¶å¼¹å‡ºçš„æ“ä½œï¼‰\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: [int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]: \t\t\t\t\t # æ ˆé¡¶å¯¹æ¯”\n                head = stack.pop()\t\t\t\t\t\t\t # ä¿å­˜æ ˆé¡¶\n                while stack and num < stack[-1]: stack.pop() # å¼¹å‡ºæ ˆä¸­æ¯”xå°çš„æ•°å­—ï¼Œ\n                stack.append(head)\t\t\t\t\t\t     # å­˜å…¥æ ˆé¡¶\n            else: stack.append(num)\n        return len(stack)\n```\n\nå¤æ‚åº¦åˆ†æï¼š\næ—¶é—´å¤æ‚åº¦ O(N) \nç©ºé—´å¤æ‚åº¦ O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191123114","body":"# æ–¹æ³•1ï¼šæ¯æ¬¡å³ç§»1æ ¼ï¼Œkæ¬¡æ‰§è¡Œkæ¬¡ã€‚ä½†æ˜¯æ–¹æ³•è¶…æ—¶ã€‚\n```\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next: return head\n        def rightmove(head):\n            pre=head\n            cur=head\n            tailpre=ListNode(-1)\n            tailpre.next=head\n            tail=head\n            while cur:\n                cur=cur.next\n                if cur:\n                    tail=tail.next\n                    tailpre=tailpre.next\n            tailpre.next=None\n            tail.next=pre\n\n            return tail\n        \n        while k>0:\n            k-=1\n            head=rightmove(head)\n        \n        return head\n```\n# æ–¹æ³•2ï¼Œæˆç¯ï¼Œæˆç¯ä¹‹åå³ç§»åŠ¨kæ¬¡ï¼Œç„¶åæ–­å¼€ã€‚\nä»£ç å°±ä¸å†™äº†ï¼Œæƒ³æ³•æ¯”è¾ƒé‡è¦","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192253761","body":"# é€’å½’æ³•ï¼ˆå…³æ³¨æ€æƒ³ï¼‰\nå…³æ³¨æœ€å°å­ç»“æ„ï¼Œå³å°†ä¸¤ä¸ªèŠ‚ç‚¹è¿›è¡Œé€†è½¬ã€‚\nå°†é€†è½¬åçš„å°¾èŠ‚ç‚¹.next æŒ‡å‘ä¸‹ä¸€æ¬¡é€’å½’çš„è¿”å›å€¼\nè¿”å›é€†è½¬åçš„é“¾è¡¨å¤´èŠ‚ç‚¹ï¼ˆps:é€†è½¬å‰çš„ç¬¬äºŒä¸ªèŠ‚ç‚¹ï¼‰\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if head == None or head.next == None:\n            return head\n\n        l1 = head.next\n        head.next = self.swapPairs(head.next.next)\n        l1.next = head\n\n        return l1\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196345467","body":"BFS\n```\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root: return 0\n        queue,res=[root],0\n        while queue:\n            tmp=[]\n            for node in queue:\n                if node.left: tmp.append(node.left)\n                if node.right: tmp.append(node.right)\n            \n            queue=tmp\n            res+=1\n        return res\n```\nDFS(ååºéå†)\n```\nclass Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        def dfs(root):\n            if not root:return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            return max(left,right) + 1\n        return dfs(root)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197856175","body":"DFS\n```\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n+ æ—¶é—´å¤æ‚åº¦ï¼šOï¼ˆminï¼ˆp,qï¼‰ï¼‰\n+ ç©ºé—´å¤æ‚åº¦ï¼šOï¼ˆmin(height1,height2)ï¼‰","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198980914","body":"```\n# DFS\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        def dfs(root,cur):\n            if not root: return 0\n            if not root.right and not root.left: return cur*10+root.val\n            return dfs(root.left,cur*10+root.val)+dfs(root.right,cur*10+root.val)\n        \n        return dfs(root,0)\n\n# BFS\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        queue = collections.deque([(root, root.val)])\n        res = 0\n        while queue:\n            node, num = queue.popleft()\n            if not node.left and not node.right:\n                res += num\n            if node.left:\n                queue.append((node.left, num * 10 + node.left.val))\n            if node.right:\n                queue.append((node.right, num * 10 + node.right.val))\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200099293","body":"```\n#BFS\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n         if not root: return 0\n         queue, res = collections.deque([root]), 0\n         while queue:\n            tmp = []\n            ans=queue[0].val\n            for node in queue:\n                if node.left: tmp.append(node.left)\n                if node.right: tmp.append(node.right)\n            queue = tmp\n\n         return ans\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206193373","body":"```\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        dic, res, i = {}, 0, -1   #iæ˜¯å·¦æŒ‡é’ˆ\n        for j in range(len(s)):  #jæ˜¯å³æŒ‡é’ˆ\n            if s[j] in dic:     #è‹¥å½“å‰å…ƒç´ åœ¨ä¹‹å‰å‡ºç°è¿‡ï¼Œæ›´æ–°å·¦æŒ‡é’ˆ\n                #å½“ä¹‹å‰å‡ºç°çš„å…ƒç´ åœ¨å·¦å³æŒ‡é’ˆä¸­é—´ï¼Œå·¦æŒ‡é’ˆæ›´æ–°ä¸ºä¹‹å‰å…ƒç´ ä¸‹æ ‡ï¼Œè‹¥ä¸åœ¨ä¸­é—´ï¼Œå·¦æŒ‡é’ˆä¸å˜\n                i = max(i, dic[s[j]]) \n            dic[s[j]] = j    #å°†å½“å‰å…ƒç´ åŠ å…¥å“ˆå¸Œè¡¨ä¸­\n            res = max(res, j - i)   \n        return res\n\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207617612","body":"```\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        fast = slow = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        return slow\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208836782","body":"```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        slow, fast = 0, 1\n        while fast < len(nums):\n            if nums[fast] != nums[slow]:\n                slow = slow + 1\n                nums[slow] = nums[fast]\n            fast = fast + 1\n        return slow + 1\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gr52":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185097387","body":"/*\r\næ€è·¯ \r\nå…ˆå°†æ•°ç»„xéå†,ç”¨å­—ç¬¦ä¸²ç±»å‹æ‹¼æ¥,å¼ºåˆ¶è½¬æ¢ä¸kç›¸åŠ ,\r\nåœ¨csdn æ‰¾åˆ°çš„æ–¹æ³•(å¤§ä½¬æ±‚è§£é‡Š,ä¸å¤ªæ‡‚)ç›´æ¥å°†æ•°å€¼,è½¬æ¢æˆå­—ç¬¦ä¸²\r\n*/\r\n//ä»£ç \r\nvar x=[1,2,3,4]\r\nvar k=54\r\nfor(var i=0,str='';i<x.length;i++){\r\n        str+=x[i]\r\n}\r\nvar A=Number(str)+k\r\n const converToArray = number => [...`${number}`].map(el => parseInt(el))\r\nconsole.log(converToArray(A) ); \r\n//å¤æ‚åº¦ï¼š\r\n//æ—¶é—´å¤æ‚åº¦ï¼š Oï¼ˆnï¼‰\r\n//ç©ºé—´å¤æ‚åº¦: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186209924","body":"var shortLen = function(s, c) {\r\nvar s2 = Array(s.length).fill(0);\r\nfor (var i = 0; i < s.length; i++) {\r\n                       if (s1[i] === c) {\r\n                       continue;\r\n                       }\r\nfor (let j = i, count1 = 0; j < s.length; j++, count1++) {\r\n                        if (s1[j] === c) {\r\n                        return count1;\r\n                      }\r\n}\r\nfor (let j = s.length, count2 = 0; j >= 0; j--, count2++) {\r\n                      if (s1[j] === c) {\r\n                      return count2;\r\n                        }\r\n}\r\n         s2[i] = Math.min(count1, count2);\r\n}\r\nconsole.log(s2);\r\n}\r\n\r\nvar s = \"loveleetcode\", c = 'e';\r\nconsole.log(shortLen(s, c));\r\n##æ—¶é—´å¤æ‚åº¦\r\nç©ºé—´O(N^2)\r\næ—¶é—´O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188954566","body":"### æ€è·¯å°±æ˜¯ç”¨ä¸¤ä¸ªæ ˆæ¥æ¨¡æ‹Ÿé˜Ÿåˆ—ï¼Œå½“è¿›è¡Œå¼¹å‡ºæ“ä½œæ—¶ï¼Œå°†ä¸€ä¸ªæ ˆçš„å…ƒç´ å…¨éƒ¨å¼¹å‡ºï¼Œå†å‹å…¥å¦ä¸€ä¸ªæ ˆï¼Œæ ˆé¡¶å…ƒç´ å°±ä¸ºæœ€å…ˆè¿›å…¥çš„å…ƒç´ \r\nvar MyQueue = function() {\r\n  this.stack1 = [];\r\n  this.stack2 = [];\r\n};\r\n\r\n\r\nMyQueue.prototype.push = function(x) {\r\n  this.stack1.push(x);\r\n};\r\n\r\n\r\nMyQueue.prototype.pop = function() {\r\n  if (this.stack2.length === 0) {\r\n    while (this.stack1.length > 0) {\r\n      this.stack2.push(this.stack1.pop());\r\n    }\r\n  }\r\n\r\n  return this.stack2.pop();\r\n};\r\n\r\n\r\nMyQueue.prototype.peek = function() {\r\n  if (this.stack2.length > 0) {\r\n    return this.stack2[this.stack2.length - 1];\r\n  } else {\r\n    return this.stack1[0];\r\n  }\r\n};\r\n\r\n\r\nMyQueue.prototype.empty = function() {\r\n  return this.stack1.length === 0 && this.stack2.length === 0;\r\n};\r\n### å¤æ‚åº¦\r\næ—¶é—´å¤æ‚åº¦ï¼šOï¼ˆ1ï¼‰\r\nç©ºé—´å¤æ‚åº¦ï¼šOï¼ˆnï¼‰","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193519470","body":"`æ€è·¯` ä¸¤ä¸ªæŒ‡é’ˆéå†æ•´ä¸ªé“¾è¡¨ï¼Œå¦‚æœä¸¤è€…ç›¸é‡åˆ™è¡¨ç¤ºé“¾è¡¨æœ‰ç¯\r\n\r\n> ä»£ç \r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {boolean}\r\n */\r\nvar hasCycle = function(head) {\r\n    if (!head) return false;\r\n    let stepOne = head;\r\n    let stepTwo = head;\r\n\r\n    while(stepOne && stepTwo) {\r\n        stepOne = stepOne.next;\r\n        stepTwo = stepTwo.next && stepTwo.next.next;\r\n        if (stepOne && stepOne === stepTwo) return true;\r\n    }\r\n\r\n    return false;\r\n};\r\nå¤æ‚åº¦\r\næ—¶é—´å¤æ‚åº¦O(N)\r\nç©ºé—´å¤æ‚åº¦Oï¼ˆNï¼‰","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197878949","body":"ä»£ç \r\n/**\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {boolean}\r\n */\r\nvar isSameTree = function(p, q) {\r\n    if (p === null && q === null) {\r\n        return true;\r\n    } \r\n    if (p === null || q === null) {\r\n        return false;\r\n    }\r\n    return ((p && p.val) === (q && q.val)) \r\n        && isSameTree(p.left, q.left) \r\n        && isSameTree(p.right, q.right);\r\n};\r\nå¤æ‚åº¦ï¼š\r\næ—¶é—´å¤æ‚åº¦O(N)\r\nç©ºé—´å¤æ‚åº¦O(1)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203437255","body":"æ€è·¯ï¼šåˆ©ç”¨ä¼˜å…ˆé˜Ÿåˆ—çš„è‡ªåŠ¨æ’åºç‰¹æ€§,æ¯æ¬¡æ’å…¥åªéœ€å°†æœ«å°¾çš„å…ƒç´ ç§»é™¤å³å¯ï¼Œéå¸¸ç®€å•ç²—æš´.\r\n#include<iostream>\r\n#include<windows.h>\r\n#include< vector >\r\n#include< algorithm >\r\n#include< unordered_map >\r\n#include< queue >\r\nvector<int> topKFrequent(vector<int>& nums, int k) {\r\n\tunordered_map<int, int> mp;\r\n\tfor (auto n : nums) {\r\n\t\tmp[n]++;\r\n\t}\r\n\tpriority_queue<pair<int, int>>pq;\t// å£°æ˜ä¼˜å…ˆçº§é˜Ÿåˆ—\r\n\tfor (auto m : mp) {\r\n\t\tpq.push({ -m.second, m.first });//å°†å…ƒç´ å…¥æ ˆï¼Œè‡ªåŠ¨æŒ‰å‡åºæ’åºï¼Œé¢‘ç‡å–è´Ÿæ•°ï¼Œåˆ™é¢‘ç‡é«˜çš„æ’å‰é¢\r\n\t\tif (pq.size() > k) {\r\n\t\t\tpq.pop();\t// æ’å…¥å…ƒç´ åä¼šè‡ªåŠ¨æ’åºï¼Œåªéœ€å°†æœ€åä¸€ä½å‡ºé˜Ÿå³å¯\r\n\t\t}\r\n\t}\r\n\tvector<int> res;\r\n\twhile (k--) {\r\n\t\tres.emplace_back(pq.top().second);\t// å¾ªç¯è·å–æ‰€æœ‰å…ƒç´ \r\n\t\tpq.pop();\r\n\t}\r\n\treturn res;\r\n}\r\nå¤æ‚åº¦\r\næ—¶é—´å¤æ‚åº¦ï¼šO(nlogk)\r\nç©ºé—´å¤æ‚åº¦  Oï¼ˆNï¼‰","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207528989","body":"/**\r\n     * åšå·¦åŠè¾¹\r\n     *\r\n     * @param head\r\n     * @return\r\n     */\r\n    public Node getMiddleNodeLeft(Node head) {\r\n        Node slow = head;\r\n        Node fast = head;\r\n        while (fast.next != null && fast.next.next != null) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n\r\n    /**\r\n     * å³åŠè¾¹\r\n     *\r\n     * @param head\r\n     * @return\r\n     */\r\n    public Node getMiddleNodeRight(Node head) {\r\n\r\n        Node slow = head;\r\n        Node fast = head;\r\n        while (fast != null && fast.next != null) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hydelovegood":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185097824","body":"# æ•´ä½“æ€è·¯\r\n1. è½¬æ¢numæˆ–è½¬æ¢Kï¼Œç›¸åŠ åå†è½¬æ¢æˆæ•°ç»„\r\n2. é˜²æ­¢è¿›ä½é—®é¢˜ï¼Œå¯ä»¥å°†æ•°ç»„è½¬æ¢æˆæ•°å­—ï¼Œè€Œåå’Œkç›¸åŠ ï¼Œå†è½¬æ¢æˆæ•°ç»„\r\n# ä»£ç \r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        s, m = 0, 1\r\n        ans = []\r\n        for i in num[::-1]:\r\n            s += i * m\r\n            m *= 10\r\n        s += k\r\n        for i in str(s):\r\n            ans.append(int(i))\r\n        return ans\r\n```\r\n# å¤æ‚åº¦åˆ†æ\r\n- æ—¶é—´å¤æ‚åº¦On\r\n- ç©ºé—´å¤æ‚åº¦On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186075787","body":"# æ€è·¯\né¦–å°¾ä¸¤æ¬¡éå†\n# ä»£ç \n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        ans = [0] * n\n\n        idx = -n\n        for i, ch in enumerate(s):\n            if ch == c:\n                idx = i\n            ans[i] = i - idx\n\n        idx = 2 * n\n        for i in range(n - 1, -1, -1):\n            if s[i] == c:\n                idx = i\n            ans[i] = min(ans[i], idx - i)\n        return ans\n```\n# å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦On\nç©ºé—´å¤æ‚åº¦On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186546631","body":"# æ€è·¯\næ¨¡æ‹Ÿæ‰€æœ‰çš„æ“ä½œï¼Œæ³¨æ„è¾¹ç•Œæ¡ä»¶å’Œç‰¹åˆ¤\n# ä»£ç \n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stk = [0] * maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.stk) - 1:\n            self.top += 1\n            self.stk[self.top] = x\n\n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.stk[self.top + 1]\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k, self.top + 1)\n        for i in range(lim):\n            self.stk[i] += val\n```\n# å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦On\nç©ºé—´å¤æ‚åº¦On\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187612890","body":"# æ€è·¯\r\nä½¿ç”¨ä¸€ä¸ªæ ˆå’Œä¸€ä¸ªæ•°ç»„è§£å†³é—®é¢˜\r\n# ä»£ç \r\n ```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []  # (str, int) è®°å½•å·¦æ‹¬å·ä¹‹å‰çš„å­—ç¬¦ä¸²å’Œå·¦æ‹¬å·å¤–çš„ä¸Šä¸€ä¸ªæ•°å­—\r\n        num = 0\r\n        res = \"\"  # å®æ—¶è®°å½•å½“å‰å¯ä»¥æå–å‡ºæ¥çš„å­—ç¬¦ä¸²\r\n        for c in s:\r\n            if c.isdigit():\r\n                num = num * 10 + int(c)\r\n            elif c == \"[\":\r\n                stack.append((res, num))\r\n                res, num = \"\", 0\r\n            elif c == \"]\":\r\n                top = stack.pop()\r\n                res = top[0] + res * top[1]\r\n            else:\r\n                res += c\r\n        return res\r\n```\r\n# å¤æ‚åº¦åˆ†æ\r\næ—¶é—´å¤æ‚åº¦On\r\nç©ºé—´å¤æ‚åº¦On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188535834","body":"# æ€è·¯\nä½¿ç”¨ä¸¤ä¸ªæ ˆï¼Œç¬¬ä¸€ä¸ªè®°å½•è¿›é˜Ÿå…ƒç´ ï¼Œç¬¬äºŒä¸ªè®°å½•é˜Ÿå¤´å…ƒç´ \n# ä»£ç \n```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.s1 = []\n        self.s2 = []\n        self.front = None\n\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        if not self.s1: self.front = x\n        self.s1.append(x)\n        \n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if not self.s2:\n            while self.s1:\n                self.s2.append(self.s1.pop())\n            self.front = None\n        return self.s2.pop()\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if self.s2: \n            return self.s2[-1]\n        return self.front\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        if not self.s1 and not self.s2:\n            return True\n        return False\n```\n# å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦On\nç©ºé—´å¤æ‚åº¦On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190270184","body":"ä»Šå¤©çš„é¢˜ç›®æœ‰ç‚¹éš¾ï¼Œæ²¡æœ‰æ€è·¯ï¼Œå­¦ä¹ äº†ä¸€æ³¢å•è°ƒæ ˆ\n# æ€è·¯\nå¯¹äºç¬¬iä¸ªæ•° å½“ä¸”ä»…å½“iå’Œå®ƒå‰é¢æ‰€æœ‰æ•°çš„æœ€å¤§å€¼ å°äº iåé¢æ‰€æœ‰æ•°çš„æœ€å°å€¼æ—¶ å¯ä»¥æŠŠiå’Œå®ƒå‰é¢çš„æ•°åˆ†å‡ºå» ç»“æœ + 1\n# ä»£ç \n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        arr = zip(arr, range(len(arr)))\n        arr = sorted(arr)\n        arrs = [0]*len(arr)\n        for idx,i in enumerate(arr):\n            arrs[i[1]] = idx\n        m = -float('inf')\n        res = 0\n        for i in range(len(arrs)):\n            m = max(m, arrs[i])\n            if m == i:\n                res += 1\n        return res\n```\nå¼•ç”¨è‡ªåŠ›æ‰£ @Thinking first\n# å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦On\nç©ºé—´å¤æ‚åº¦On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191071447","body":"# æ€è·¯\nåŒæŒ‡é’ˆå…¸å‹é¢˜ï¼Œå–å·§çš„è¯å¯ä»¥è½¬æˆæ•°ç»„å†è½¬å›æ¥\n# ä»£ç \n```python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        # åŒæŒ‡é’ˆ\n        if head:\n            p1 = head\n            p2 = head\n            count = 1\n            i = 0\n            while i < k:\n                if p2.next:\n                    count += 1\n                    p2 = p2.next\n                else:\n                    k = k % count\n                    i = -1\n                    p2 = head\n                i += 1\n\n            while p2.next:\n                p1 = p1.next\n                p2 = p2.next\n\n            if p1.next:\n                tmp = p1.next\n            else:\n                return head\n            p1.next = None\n            p2.next = head\n            return tmp\n```\n# å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦On\nç©ºé—´å¤æ‚åº¦O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192254152","body":"# æ€è·¯\nä½¿ç”¨è™šæ‹Ÿå¤´èŠ‚ç‚¹ï¼Œé€’å½’è¿›è¡Œ\n# ä»£ç \n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        thead = ListNode(-1)\n        thead.next = head\n        c = thead\n        while c.next and c.next.next:\n            a, b=c.next, c.next.next\n            c.next, a.next = b, b.next\n            b.next = a\n            c = c.next.next\n        return thead.next\n```\n# å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦On\nç©ºé—´å¤æ‚åº¦O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193144298","body":"# æ€è·¯\nå¿«æ…¢æŒ‡é’ˆé€’å½’è¿›è¡Œ\n# ä»£ç \n```python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n```\n# å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦Onlogn\nç©ºé—´å¤æ‚åº¦On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193241430","body":"# æ€è·¯\nä¸¤ä¸ªé“¾è¡¨çš„æŒ‡é’ˆèµ°è¿‡ç­‰é•¿çš„è·¯\n# ä»£ç \n```python\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        if not headA or not headB: return null\n        A, B = headA, headB\n        while A != B:\n            A = A.next if A else headB\n            B = B.next if B else headA\n        return A\n```\n# å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦Onï¼Œå› ä¸ºæœ€å¤šè¿›è¡Œäº†ä¸¤è½®å¾ªç¯\nç©ºé—´å¤æ‚åº¦O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193718303","body":"# æ€è·¯\nåŒæŒ‡é’ˆå¿«æ…¢æŒ‡é’ˆï¼Œå»å¹´å°ç±³ç®—æ³•å·¥ç¨‹å¸ˆé¢è¯•é—®äº†è¿™é“\n# ä»£ç \n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        quick, slow = head, head\n        while quick != None and quick.next != None:\n            quick = quick.next.next\n            slow = slow.next\n            if quick == slow:\n                break\n        if quick == None or quick.next == None:\n            return None\n        quick = head\n        while quick != slow:\n            quick = quick.next\n            slow = slow.next\n        return quick\n```\n# å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦On\nç©ºé—´å¤æ‚åº¦O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195231632","body":"# æ€è·¯\nè¿™é¢˜ç¬¬ä¸€æ¬¡è§ï¼Œçœ‹äº†å¾ˆå¤šç¯‡é¢˜è§£ï¼Œè®°å½•ä¸€ä¸‹åé¢åå¤å­¦ä¹ å‡ é\n# ä»£ç \n```python\nclass ListNode:\n    def __init__(self, key=None, value=None):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.hashmap = {}\n        # æ–°å»ºä¸¤ä¸ªèŠ‚ç‚¹ head å’Œ tail\n        self.head = ListNode()\n        self.tail = ListNode()\n        # åˆå§‹åŒ–é“¾è¡¨ä¸º head <-> tail\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    # å› ä¸ºgetä¸putæ“ä½œéƒ½å¯èƒ½éœ€è¦å°†åŒå‘é“¾è¡¨ä¸­çš„æŸä¸ªèŠ‚ç‚¹ç§»åˆ°å¤´éƒ¨(å˜æˆæœ€æ–°è®¿é—®çš„)ï¼Œæ‰€ä»¥å®šä¹‰ä¸€ä¸ªæ–¹æ³•\n    def move_node_to_header(self, key):\n            # å…ˆå°†å“ˆå¸Œè¡¨keyæŒ‡å‘çš„èŠ‚ç‚¹æ‹å‡ºæ¥ï¼Œä¸ºäº†ç®€æ´èµ·ånode\n            #      hashmap[key]                               hashmap[key]\n            #           |                                          |\n            #           V              -->                         V\n            # prev <-> node <-> next         pre <-> next   ...   node\n            node = self.hashmap[key]\n            node.prev.next = node.next\n            node.next.prev = node.prev\n            # ä¹‹åå°†nodeæ’å…¥åˆ°å¤´éƒ¨èŠ‚ç‚¹å‰\n            #                   hashmap[key]                     hashmap[key]\n            #                       |                                 |\n            #                       V        -->                      V\n            # header <-> next  ... node                   header <-> node <-> next\n            node.prev = self.head\n            node.next = self.head.next\n            self.head.next.prev = node\n            self.head.next = node\n            \n    def add_node_to_header(self, key,value):\n        new = ListNode(key, value)\n        self.hashmap[key] = new\n        new.prev = self.head\n        new.next = self.head.next\n        self.head.next.prev = new\n        self.head.next = new\n        \n    def pop_tail(self):\n        last_node = self.tail.prev\n        # å»æ‰é“¾è¡¨å°¾éƒ¨çš„èŠ‚ç‚¹åœ¨å“ˆå¸Œè¡¨çš„å¯¹åº”é¡¹\n        self.hashmap.pop(last_node.key)\n        # å»æ‰æœ€ä¹…æ²¡æœ‰è¢«è®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼Œå³å°¾éƒ¨Tailä¹‹å‰çš„ä¸€ä¸ªèŠ‚ç‚¹\n        last_node.prev.next = self.tail\n        self.tail.prev = last_node.prev\n        return last_node\n    \n    def get(self, key: int) -> int:\n        if key in self.hashmap:\n            # å¦‚æœå·²ç»åœ¨é“¾è¡¨ä¸­äº†ä¹…æŠŠå®ƒç§»åˆ°å¤´éƒ¨ï¼ˆå˜æˆæœ€æ–°è®¿é—®çš„ï¼‰\n            self.move_node_to_header(key)\n        res = self.hashmap.get(key, -1)\n        if res == -1:\n            return res\n        else:\n            return res.value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.hashmap:\n            # å¦‚æœkeyæœ¬èº«å·²ç»åœ¨å“ˆå¸Œè¡¨ä¸­äº†å°±ä¸éœ€è¦åœ¨é“¾è¡¨ä¸­åŠ å…¥æ–°çš„èŠ‚ç‚¹\n            # ä½†æ˜¯éœ€è¦æ›´æ–°å­—å…¸è¯¥å€¼å¯¹åº”èŠ‚ç‚¹çš„value\n            self.hashmap[key].value = value\n            # ä¹‹åå°†è¯¥èŠ‚ç‚¹ç§»åˆ°é“¾è¡¨å¤´éƒ¨\n            self.move_node_to_header(key)\n        else:\n            if len(self.hashmap) >= self.capacity:\n            # è‹¥cacheå®¹é‡å·²æ»¡ï¼Œåˆ é™¤cacheä¸­æœ€ä¸å¸¸ç”¨çš„èŠ‚ç‚¹ \n                self.pop_tail()\n            self.add_node_to_header(key,value)\n```\n# å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦On\nç©ºé—´å¤æ‚åº¦O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196389430","body":"# æ€è·¯\næ·±åº¦ä¼˜å…ˆéå†\n# ä»£ç \n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        return max(self.maxDepth(root.left)+1, self.maxDepth(root.right)+1)\n```\n# å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦Onlogn\nç©ºé—´å¤æ‚åº¦ä¸ºæ ‘çš„é«˜åº¦","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197582481","body":"# æ€è·¯\nè¦æƒ³å­¦ä¼šé€’å½’ï¼Œå°±è¦å­¦ä¼šé€’å½’\n# ä»£ç \n```python\nif p==None and q!=None: return False\n        if p!=None and q==None: return False\n        if p==None and q==None: return True\n        if p.val!=q.val: return False\n        #2.é€’å½’æœ¬ä½“\n        if p.val==q.val:\n            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\n```\n# å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦On\nç©ºé—´å¤æ‚åº¦On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198810492","body":"# æ€è·¯\nç›´æ¥æ·±åº¦ä¼˜å…ˆéå†ï¼Œæ”¹å˜èŠ‚ç‚¹å€¼\n# ä»£ç \n```python\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        tempsum = []\n        if not root: return 0\n        if not (root.left or root.right): return root.val\n        if root.left:\n            root.left.val = root.val*10 + root.left.val\n        if root.right:\n            root.right.val = root.val*10 + root.right.val\n        return self.sumNumbers(root.left) + self.sumNumbers(root.right)\n```\n# å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦ On\nç©ºé—´å¤æ‚åº¦ On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200109268","body":"# æ€è·¯\nå±‚åºéå†ï¼Œå–æœ€åä¸€å±‚çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å€¼\n# ä»£ç \n```python\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return []\n\n        # è¿”å›ç»“æœ\n        res = []\n\n        from collections import deque\n        # å®šä¹‰é˜Ÿåˆ—\n        queue = deque()\n        # å°†æ ¹èŠ‚ç‚¹å…¥é˜Ÿ\n        queue.append(root)\n        # é˜Ÿåˆ—ä¸ä¸ºç©ºï¼Œè¡¨è¾¾å¼äºŒå‰æ ‘è¿˜æœ‰èŠ‚ç‚¹ï¼Œå¾ªç¯éå†\n        while queue:\n            # å…ˆæ ‡è®°æ¯å±‚çš„èŠ‚ç‚¹æ•°\n            size = len(queue)\n            # å®šä¹‰å˜é‡ï¼Œè®°å½•æ¯å±‚èŠ‚ç‚¹å€¼\n            level = []\n            # è¿™é‡Œå¼€å§‹éå†å½“å‰å±‚çš„èŠ‚ç‚¹\n            for _ in range(size):\n                # å‡ºé˜Ÿ\n                node = queue.popleft()\n                # å…ˆå°†å½“å‰èŠ‚ç‚¹çš„å€¼å­˜å‚¨\n                level.append(node.val)\n                # èŠ‚ç‚¹çš„å·¦å³èŠ‚ç‚¹éç©ºæ—¶ï¼Œå…¥é˜Ÿ\n                if node.left is not None:\n                    queue.append(node.left)\n                if node.right is not None:\n                    queue.append(node.right)\n            # æ·»åŠ æ¯å±‚çš„èŠ‚ç‚¹å€¼åˆ—è¡¨\n            res.append(level)\n        return res[-1][0]\n```\n# å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦On\nç©ºé—´å¤æ‚åº¦On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200444322","body":"# è¿™é¢˜æŒºéš¾çš„\nå±‚åºéå†å­˜è´®\n# ä»£ç \n```python \ndef serialize(self, root):\n\n        s = \"\"\n        queue = []\n        queue.append(root)\n        while queue:\n            root = queue.pop(0)\n            if root:\n                s += str(root.val)\n                queue.append(root.left)\n                queue.append(root.right)\n            else:\n                s += \"n\"\n            s += \" \"        \n        return s\n\n    def deserialize(self, data):\n \n        tree = data.split()\n        print(tree)\n        if tree[0] == \"n\":\n            return None\n        queue = []\n        root = TreeNode(int(tree[0]))\n        queue.append(root)\n        i = 1\n        while queue:\n            cur = queue.pop(0)\n            if cur == None:\n                continue\n            cur.left = TreeNode(int(tree[i])) if tree[i] != \"n\" else None\n            cur.right = TreeNode(int(tree[i + 1])) if tree[i + 1] != \"n\" else None\n            i += 2\n            queue.append(cur.left)\n            queue.append(cur.right)\n        return root\n```\n# å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦On\nç©ºé—´å¤æ‚åº¦On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201379296","body":"# æ€è·¯\nè®°å½•æ‰€æœ‰ç»“ç‚¹çš„åæ ‡ (x,y) ï¼Œç›¸åŒ x çš„ç»“ç‚¹æ”¾åœ¨åŒä¸€ä¸ªåˆ—è¡¨ã€‚\n\nè¾“å‡ºæ—¶åˆ—è¡¨æŒ‰ x æ’åºã€‚åˆ—è¡¨ä¸­å…ˆæŒ‰ y æ’åºï¼Œå†æŒ‰å€¼æ’åºå³å¯ã€‚\n# ä»£ç \n```python\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        stack, d = [(root, 0, 0)], defaultdict(list)\n        while stack:\n            node, x, y = stack.pop()\n            if node:\n                d[x].append((y, node.val))\n                stack.extend([(node.right, x+1, y+1), (node.left, x-1, y+1)])\n        return [[val for _, val in sorted(d[x])] for x in sorted(d)]\n```\n#  å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦On\nç©ºé—´å¤æ‚åº¦On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202812651","body":"# æ€è·¯\næœ‰äººç›¸çˆ±ï¼Œæœ‰äººå¼€è½¦çœ‹æµ·ï¼Œæœ‰äººåŠ›æ‰£ç¬¬ä¸€é¢˜å†™ä¸å‡ºæ¥\n# ä»£ç \n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        hashmap = {}\n        for ind,num in enumerate(nums):\n            hashmap[num] = ind\n        for i,num in enumerate(nums):\n            j = hashmap.get(target - num)\n            if j is not None and i!=j:\n                return [i,j]\n```\n# å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦On\nç©ºé—´å¤æ‚åº¦On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1204130179","body":"# æ€è·¯\nå“ˆå¸Œå’Œå †æ’åº\n# ä»£ç \n```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        count = collections.Counter(nums)\n        num_cnt = list(count.items())\n        topKs = self.findTopK(num_cnt, k, 0, len(num_cnt) - 1)\n        return [item[0] for item in topKs]\n    \n    def findTopK(self, num_cnt, k, low, high):\n        pivot = random.randint(low, high)\n        num_cnt[low], num_cnt[pivot] = num_cnt[pivot], num_cnt[low]\n        base = num_cnt[low][1]\n        i = low\n        for j in range(low + 1, high + 1):\n            if num_cnt[j][1] > base:\n                num_cnt[i + 1], num_cnt[j] = num_cnt[j], num_cnt[i + 1]\n                i += 1\n        num_cnt[low], num_cnt[i] = num_cnt[i], num_cnt[low]\n        if i == k - 1:\n            return num_cnt[:k]\n        elif i > k - 1:\n            return self.findTopK(num_cnt, k, low, i - 1)\n        else:\n            return self.findTopK(num_cnt, k, i + 1, high)\n```\n# å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦Onlogn\nç©ºé—´å¤æ‚åº¦On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205235309","body":"# æ€è·¯\nä½¿ç”¨å“ˆå¸Œè¡¨å°†å¤æ‚åº¦ä»ä¸‰æ¬¡æ–¹é™ä½åˆ°äºŒæ¬¡æ–¹\n# ä»£ç \n```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        n = len(points)\n        ans = 0\n        for i in range(n):\n            m = collections.defaultdict(int)\n            for j in range(n):\n                dist = abs(points[i][0] - points[j][0]) ** 2 + abs(points[i][1] - points[j][1]) ** 2\n                m[dist] += 1\n            for count in m.values():\n                ans += count * (count-1)\n        return ans\n```\n# å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦On2\nç©ºé—´å¤æ‚åº¦On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206308768","body":"# æ€è·¯\nä½¿ç”¨åŒæŒ‡é’ˆè´Ÿè´£æ»‘åŠ¨çª—å£ï¼Œæ³¨æ„è¾¹ç•Œæ¡ä»¶ï¼Œä½¿ç”¨å“ˆå¸Œè¡¨å»é‡\n# ä»£ç \n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        left = 0\n        lookup = set()\n        n = len(s)\n        max_len = 0\n        cur_len = 0\n        for i in range(n):\n            cur_len += 1\n            while s[i] in lookup:\n                lookup.remove(s[left])\n                left += 1\n                cur_len -= 1\n            if cur_len > max_len:max_len = cur_len\n            lookup.add(s[i])\n        return max_len\n```\n# å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦On\nç©ºé—´å¤æ‚åº¦æœ€å¤§On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207224108","body":"# æ€è·¯\nåˆ’åˆ†wordsï¼ŒåŒæŒ‡é’ˆ\n# ä»£ç \n```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        res = []\n        m, n, ls = len(words), len(words[0]), len(s)\n        for i in range(n):\n            if i + m * n > ls:\n                break\n            differ = Counter()\n            for j in range(m):\n                word = s[i + j * n: i + (j + 1) * n]\n                differ[word] += 1\n            for word in words:\n                differ[word] -= 1\n                if differ[word] == 0:\n                    del differ[word]\n            for start in range(i, ls - m * n + 1, n):\n                if start != i:\n                    word = s[start + (m - 1) * n: start + m * n]\n                    differ[word] += 1\n                    if differ[word] == 0:\n                        del differ[word]\n                    word = s[start - n: start]\n                    differ[word] -= 1\n                    if differ[word] == 0:\n                        del differ[word]\n                if len(differ) == 0:\n                    res.append(start)\n        return res\n```\n# å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦Omn\nç©ºé—´å¤æ‚åº¦Omn","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208212885","body":"# æ€è·¯\nå¿«æ…¢æŒ‡é’ˆ\n# ä»£ç \n```python\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n```\n# å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦On\nç©ºé—´å¤æ‚åº¦O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209043503","body":"# æ€è·¯\nåŒæŒ‡é’ˆ\n# ä»£ç \n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        \n        n = len(nums)\n        fast = slow = 1\n        while fast < n:\n            if nums[fast] != nums[fast - 1]:\n                nums[slow] = nums[fast]\n                slow += 1\n            fast += 1\n        \n        return slow\n```\n# å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦On\nç©ºé—´å¤æ‚åº¦O1","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nikojxie":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185098164","body":"## æ€è·¯\r\næ¯æ¬¡å¾ªç¯ï¼ŒæŠŠæ•°ç»„çš„æœ€åä¸€ä½popå‡ºæ¥ å’Œ Ké™¤10å–ä½™çš„ç»“æœç›¸åŠ ï¼Œå¦‚æœæœ‰è¿›ä½å†åŠ 1ï¼ŒKç­‰äºK/10å–æ•´ï¼Œå†è®°ä¸€ä¸‹å½“å‰è¿›ä½æ ‡è®°ï¼Œå¼€å§‹ä¸‹ä¸€æ¬¡å¾ªç¯ï¼Œç›´åˆ° Aä¸ºç©º ä¸” Kä¸º0 ä¸” è¿›ä½æ ‡è®°ä¸ºfalse\r\n\r\n## ä»£ç ï¼ˆJSï¼‰\r\n```javascript\r\nfunction addToArrayFormOfInteger(A, K) {\r\n  // reså­˜ç»“æœï¼Œsumæ˜¯æ¯ä¸€ä½åŠ çš„ç»“æœï¼ŒaddOneFlagæ˜¯è¿›ä½æ ‡è®°\r\n  let res = [], sum = 0, addOneFlag = false\r\n  while(A.length || K || addOneFlag) {\r\n    sum = (A.pop() || 0) + K % 10 + addOneFlag\r\n    K && (K = Math.floor(K / 10))\r\n    addOneFlag = sum >= 10\r\n    res.push(sum % 10)\r\n  }\r\n  return res.reverse()\r\n}\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186092929","body":"## æ€è·¯\néå†æ¯ä¸€ä¸ªå­—ç¬¦ï¼Œåœ¨å‰ååŒæ—¶å¯»æ‰¾ç›®æ ‡å­—ç¬¦ï¼Œæ‰¾åˆ°äº†å°±åœæ­¢ï¼Œå¼€å§‹éå†ä¸‹ä¸€ä¸ªå­—ç¬¦\n\n```javascript\nfunction shortestToChar(s, c) {\n  let res = []\n  for (let i = 0; i < s.length; i++) {\n    let count = 0\n    while (i - count >= 0 || count < s.length - i) {\n      if (s[i - count] === c || s[i + count] === c) {\n        res.push(count)\n        break\n      }\n      count ++\n    }\n  }\n  return res\n}\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ O(n^2)\n- ç©ºé—´å¤æ‚åº¦ O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186431946","body":"## æ€è·¯\r\næ•°ç»„å®ç°ï¼Œpushæ—¶åˆ¤æ–­é•¿åº¦è¶…å‡ºï¼Œpopæ—¶åˆ¤æ–­æ•°ç»„å†…æ˜¯å¦è¿˜æœ‰æ•°æ®\r\n\r\n## ä»£ç \r\n```javascript\r\nclass CustomStack {\r\n  constructor(maxSize) {\r\n    this.data = []\r\n    this.maxSize = maxSize\r\n  }\r\n\r\n  push(x) {\r\n    if(this.data.length < this.maxSize) {\r\n      this.data.push(x)\r\n    }\r\n  }\r\n\r\n  pop() {\r\n    return this.data.pop() || -1\r\n  }\r\n\r\n  increment(k, val) {\r\n    for(let i = 0; i < this.data.length; i++) {\r\n      if(i >= k) break\r\n      this.data[i] += val\r\n    }\r\n  }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186825671","body":"## æ€è·¯\n1.åˆ›å»ºä¸¤ä¸ªæ ˆï¼Œä¸€ä¸ªå­˜æ•°å­—ï¼Œä¸€ä¸ªå­˜å­—ç¬¦\n2.é‡åˆ° '[' æ—¶ï¼ŒæŠŠæ•°å­—å’Œå½“å‰çš„ç»“æœåˆ†åˆ«æ”¾å…¥ä¸¤ä¸ªæ ˆå†…\n3.é‡åˆ° ']' æ—¶ï¼ŒæŠŠå½“å‰çš„ç»“æœ * (æ•°å­—æ ˆé¡¶çš„æ•°å­—ï¼‰æ¬¡ï¼Œå†åŠ ä¸Šå­—ç¬¦æ ˆé¡¶çš„å­—ç¬¦ï¼Œè§†ä½œå½“å‰çš„ç»“æœ\n4.é‡åˆ°æ•°å­—æ—¶ï¼Œmultiå€¼è®°å½•ï¼Œå¯èƒ½ä¼šæœ‰å‡ ä½æ•°ï¼Œæ‰€ä»¥ * 10\n5.é‡åˆ°æ™®é€šå­—ç¬¦æ—¶ï¼Œç›´æ¥åœ¨å½“å‰ç»“æœåé¢åŠ ä¸Šè¯¥å­—ç¬¦\n\n## ä»£ç \n```javascript\nfunction decodeString (s) {\n  let multiStack = [], resStack = [], res = '', multi = 0\n  for(let str of s) {\n    if(str === '[') {\n      multiStack.push(multi)\n      resStack.push(res)\n      multi = 0\n      res = ''\n    } else if(str === ']') {\n      res = resStack.pop() + res.repeat(multiStack.pop())\n    } else if(!isNaN(str)) {\n      multi = multi*10 + parseInt(str)\n    } else {\n      res += str\n    }\n  }\n  return res\n}\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ O(n)\n- ç©ºé—´å¤æ‚åº¦ O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189095766","body":"## æ€è·¯\r\n\r\nåˆ›å»ºä¸¤ä¸ªæ ˆï¼Œä¸€ä¸ªè¡¨ç¤ºé˜Ÿåˆ—å†…çš„æ•°æ®ï¼Œä¸€ä¸ªä½œä¸ºæ•°æ®è½¬ç§»çš„ä¸´æ—¶æ ˆ\r\n\r\n\r\n## ä»£ç \r\n```javascript\r\nvar MyQueue = function() {\r\n    this.stack1 = []\r\n    this.stack2 = []\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack1.push(x)\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    while(this.stack1.length > 1) {\r\n        this.stack2.push(this.stack1.pop())\r\n    }\r\n    let res = this.stack1.pop()\r\n    while(this.stack2.length) {\r\n        this.stack1.push(this.stack2.pop())\r\n    }\r\n    return res\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    while(this.stack1.length > 1) {\r\n        this.stack2.push(this.stack1.pop())\r\n    }\r\n    let res = this.stack1[0]\r\n    while(this.stack2.length) {\r\n        this.stack1.push(this.stack2.pop())\r\n    }\r\n    return res\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.stack1.length === 0\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190319047","body":"## æ€è·¯\r\nå‚è€ƒäº†ç­”æ¡ˆï¼Œä½¿ç”¨mapè®¡æ•°åˆ†æ¡¶çš„æ–¹å¼å®ç°\r\n\r\n## ä»£ç \r\n```javascript\r\nfunction maxChunksToSorted(arr) {\r\n  let sortArr = [...arr].sort((x,y) => x-y)\r\n  let countMap = new Map();\r\n  let ans = 0\r\n  let diffNum = 0\r\n  for(let i = 0; i < arr.length; i++) {\r\n    let m = arr[i]\r\n    countMap.set(m, (countMap.get(m) || 0) + 1)\r\n    if(countMap.get(m) === 1) {\r\n      diffNum ++\r\n    }\r\n    if(countMap.get(m) === 0) {\r\n      diffNum --\r\n    }\r\n\r\n    let n = sortArr[i]\r\n    countMap.set(n, (countMap.get(n) || 0) - 1)\r\n    if(countMap.get(n) === -1) {\r\n      diffNum ++\r\n    }\r\n    if(countMap.get(n) === 0) {\r\n      diffNum --\r\n    }\r\n\r\n    if(diffNum === 0) ans ++\r\n  }\r\n  return ans\r\n}\r\n```\r\n\r\n## å¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ O(n*logn)\r\n- ç©ºé—´å¤æ‚åº¦ O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191177194","body":"## æ€è·¯\n1.å…ˆéå†ä¸€éè·å–é“¾è¡¨é•¿åº¦ï¼Œk/é•¿åº¦å–ä½™å¾—åˆ°éœ€è¦ç§»åŠ¨çš„æ¬¡æ•°\n\n2.å¾ªç¯ç¬¬ä¸€æ­¥å¾—åˆ°çš„æ¬¡æ•°ï¼Œæ¯ä¸€æ¬¡éƒ½æŠŠæœ€åä¸€ä¸ªnodeçš„nextæŒ‡å‘å½“å‰çš„ç¬¬ä¸€ä¸ªnodeï¼Œå€’æ•°ç¬¬äºŒä¸ªnodeçš„nextç½®ä¸ºnull\n\n3.éœ€è¦æ³¨æ„é“¾è¡¨ä¸ºç©ºå’Œåªæœ‰ä¸€ä¸ªnodeçš„æƒ…å†µ\n\n## ä»£ç \n```javascript\nvar rotateRight = function(head, k) {\n  if(!head || !head.next) return head\n  let cur = head\n  let length = 1\n  while(cur.next) {\n    length ++\n    cur = cur.next\n  }\n  let count = k % length\n  while(count > 0) {\n    let pre = null\n    let cur = head\n    while(head.next) {\n      pre = head\n      head = head.next\n    }\n    head.next = cur\n    pre.next = null\n    count --\n  }\n  return head\n};\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ O(n)\n- ç©ºé—´å¤æ‚åº¦ O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192380001","body":"## æ€è·¯\n\nä¸¤ä¸¤äº¤æ¢ä¼šæ¶‰åŠåˆ°4ä¸ªèŠ‚ç‚¹ï¼Œæ­¥éª¤æ‹†è§£å¦‚ä¸‹ï¼ŒåŒæ—¶newä¸€ä¸ªè™šæ‹ŸèŠ‚ç‚¹preè§£å†³è¾¹ç•Œé—®é¢˜\n\nåˆå§‹ï¼špre -> A -> B -> next\n\npre -> A -> next , B -> next\n\npre -> A -> next , B -> A\n\npre -> B -> A -> next\n\n## ä»£ç \n```javascript\nfunction swapPairs(head) {\n  if(!head || !head.next) return head\n  let res = head.next\n  let node = head\n  let preNode = new ListNode()\n  while(node && node.next) {\n    let nNode = node.next\n    let nnNode = nNode.next\n    node.next = nnNode\n    nNode.next = node\n    preNode.next = nNode\n\n    preNode = node\n    node = nnNode\n  }\n  return res\n}\n```\n\n## å¤æ‚åº¦\n- ç©ºé—´å¤æ‚åº¦ O(1)\n- æ—¶é—´å¤æ‚åº¦ O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193126981","body":"## æ€è·¯\r\nçœ‹äº†é¢˜è§£å†™å‡ºæ¥çš„ï¼Œé€šè¿‡å¿«æ…¢æŒ‡é’ˆæ–¹æ³•æ‰¾åˆ°ä¸­é—´èŠ‚ç‚¹ï¼Œä»¥æ­¤ä¸ºæ ¹ï¼Œå·¦èŠ‚ç‚¹æ˜¯å†ä»¥ç›¸åŒæ–¹æ³•æ‰¾åˆ°é¦–èŠ‚ç‚¹å’Œæ­¤æ ¹èŠ‚ç‚¹çš„ä¸­é—´èŠ‚ç‚¹ï¼Œå³èŠ‚ç‚¹æ˜¯æ­¤æ ¹èŠ‚ç‚¹åˆ°å°¾èŠ‚ç‚¹çš„ä¸­é—´èŠ‚ç‚¹ï¼Œé€šè¿‡é€’å½’æ„å»ºæ ‘ï¼Œä¸­é—´ç¢°åˆ°é¦–å°¾èŠ‚ç‚¹ç›¸åŒåˆ™è¯´æ˜æ²¡æœ‰ä¸­é—´èŠ‚ç‚¹ï¼Œè¿”å›null\r\n\r\n## ä»£ç \r\n```javascript\r\nfunction sortedListToBST(head) {\r\n    if(!head) return null\r\n    return dfs(head, null)\r\n};\r\nfunction dfs(head, tail) {\r\n    if(head === tail) return null\r\n    let fast = head, slow = head\r\n    while(fast !== tail && fast.next !== tail) {\r\n        fast = fast.next.next\r\n        slow = slow.next\r\n    }\r\n    let root = new TreeNode(slow.val)\r\n    root.left = dfs(head, slow)\r\n    root.right = dfs(slow.next, tail)\r\n    return root\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193257940","body":"## æ€è·¯\r\nåŒæŒ‡é’ˆ\r\n\r\n## ä»£ç \r\n```javascript\r\nfunction getIntersectionNode(headA, headB) {\r\nlet a = headA, b = headB\r\n  while (a != b) {\r\n    a = a ? a.next : headB\r\n    b = b ? b.next : headA\r\n  }\r\n  return a;\r\n};\r\n```\r\n\r\n## å¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ O(n)\r\n- ç©ºé—´å¤æ‚åº¦ O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194074127","body":"## æ€è·¯\r\néå†èŠ‚ç‚¹ å“ˆå¸Œåˆ¤æ–­\r\n\r\n## ä»£ç \r\n```javascript\r\nvar detectCycle = function(head) {\r\n    let map = new Map();\r\n    while(head) {\r\n        if(map.has(head)) {\r\n            return head\r\n        }\r\n        map.set(head, 1)\r\n        head = head.next\r\n    }\r\n    return null\r\n};\r\n```\r\n\r\n## å¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195142078","body":"## æ€è·¯\nä½¿ç”¨Mapå®ç°ï¼Œgetæ—¶æŠŠå½“å‰getçš„è¿™ä¸ªæ”¾åˆ°æœ€åï¼Œputæ—¶åˆ¤æ–­é•¿åº¦æ˜¯ä¸æ˜¯è¶…å‡ºäº†ï¼Œè¶…å‡ºåˆ™åˆ æ‰ç¬¬ä¸€ä¸ªï¼Œå†æŠŠéœ€è¦putçš„å€¼å¡åˆ°æœ€å\n\n## ä»£ç \n```javascript\nvar LRUCache = function(capacity) {\n  this.limit = capacity\n  this.data = new Map()\n};\n\nLRUCache.prototype.get = function(key) {\n  if(this.data.has(key)) {\n    let tmp = this.data.get(key)\n    this.data.delete(key)\n    this.data.set(key, tmp)\n    return tmp\n  }\n  return -1\n};\n\nLRUCache.prototype.put = function(key, value) {\n  if(this.data.has(key)) {\n    this.data.delete(key)\n    this.data.set(key, value)\n    return\n  }\n  if(this.data.size >= this.limit) {\n    this.data.delete(this.data.keys().next().value)\n    this.data.set(key, value)\n  } else {\n    this.data.set(key, value)\n  }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196441585","body":"## æ€è·¯\né€’å½’ï¼ŒæŠŠå½“å‰nodeå’Œæ·±åº¦ä½œä¸ºå‚æ•°ï¼Œæ‰¾å·¦å³ä¸¤ä¸ªèŠ‚ç‚¹æ·±åº¦è¾ƒæ·±çš„é‚£ä¸ª\n\n## ä»£ç \n```javascript\nvar maxDepth = function(root) {\n  return dfs(root, 0)\n};\n\nvar dfs = function(node, max) {\n  if(!node) return max\n  return Math.max(dfs(node.left, max + 1), dfs(node.right, max + 1))\n}\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ O(n)\n- ç©ºé—´å¤æ‚åº¦ O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197879902","body":"## æ€è·¯\né€’å½’ï¼Œåˆ¤æ–­å·¦å³èŠ‚ç‚¹æ˜¯å¦éƒ½ç›¸åŒï¼Œé€’å½’é€€å‡ºæ¡ä»¶ä¸ºå¯¹æ¯”çš„ä¸¤ä¸ªèŠ‚ç‚¹éƒ½æ˜¯null\n\n## ä»£ç \n```javascript\nvar isSameTree = function(p, q) {\n  if(!p && !q) {\n    return true\n  }\n  if(p && q && p.val === q.val) {\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n  }\n  return false\n};\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ O(n)\n- ç©ºé—´å¤æ‚åº¦ O(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198916154","body":"## æ€è·¯\né€’å½’ï¼ŒæŠŠåˆ°å½“å‰èŠ‚ç‚¹ç´¯è®¡æ‹¼æ¥çš„å€¼å½“ä½œå‚æ•°ï¼Œé‡åˆ°å¶å­èŠ‚ç‚¹åšç´¯åŠ \n\n## ä»£ç \n```javascript\nvar sumNumbers = function(root) {\n  return dfs(root, '')\n};\n\nfunction dfs(node, sum) {\n  if(!node.left && !node.right) return parseInt(sum + node.val)\n  else if(!node.left && node.right) return dfs(node.right, sum + node.val)\n  else if(!node.right && node.left) return dfs(node.left, sum + node.val)\n  else return dfs(node.left, sum + node.val) + dfs(node.right, sum + node.val)\n};\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ O(n)\n- ç©ºé—´å¤æ‚åº¦ O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200122844","body":"## æ€è·¯\r\né€’å½’ï¼Œè®°å½•æŒ‰å½“å‰æ·±åº¦å’Œå½“å‰æœ€å·¦çš„èŠ‚ç‚¹å€¼ï¼Œå¦‚æœæ·±åº¦å¤§äºå·²è®°å½•çš„æ·±åº¦ï¼Œåˆ™æ›´æ–°å½“å‰æ·±åº¦å’Œå½“å‰èŠ‚ç‚¹å€¼ï¼Œå› ä¸ºå½“å‰æ·±åº¦ç¬¬ä¸€ä¸ªæ‰¾åˆ°çš„èŠ‚ç‚¹å°±æ˜¯æ­¤æ·±åº¦æœ€å·¦çš„é‚£ä¸ªèŠ‚ç‚¹\r\n\r\n## ä»£ç \r\n```javascript\r\nvar findBottomLeftValue = function(root) {\r\n  let curVal = root.val\r\n  let curLevel = 0\r\n  function dfs(node, level) {\r\n      if(node) {\r\n          if(++level > curLevel) {\r\n              curLevel = level\r\n              curVal = node.val\r\n          }\r\n          dfs(node.left, level)\r\n          dfs(node.right, level)\r\n      }\r\n  }\r\n  dfs(root, 0)\r\n  return curVal\r\n};\r\n```\r\n\r\n## å¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ O(n)\r\n- ç©ºé—´å¤æ‚åº¦ O(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200413068","body":"## æ€è·¯\r\nåºåˆ—åŒ–æ—¶ éå†ä¸ºé˜Ÿåˆ—å­˜å‚¨æ‰€æœ‰çš„valï¼Œé‡åˆ°nullèŠ‚ç‚¹å­˜ä¸ºç©ºä¸²ï¼Œæœ€åè¿”å›å‡ºä¸€ä¸ªjoinåçš„å­—ç¬¦ä¸²ï¼›\r\nååºåˆ—åŒ–æ—¶ å…ˆè½¬ä¸ºæ•°ç»„ï¼Œæ‹¿åˆ°ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œéå†å¡leftï¼Œrightå€¼ï¼Œç¢°åˆ°ç©ºä¸²å°±ç»™èŠ‚ç‚¹å€¼ä¸ºnullï¼Œ\r\n\r\n## ä»£ç \r\n```javascript\r\nvar serialize = function(root) {\r\n  let res = []\r\n  function encode(node) {\r\n    if(node) {\r\n      res.push(node.val)\r\n      encode(node.left)\r\n      encode(node.right)\r\n    } else {\r\n      res.push('')\r\n    }\r\n  }\r\n  encode(root)\r\n  return res.join(',')\r\n}\r\n\r\nvar deserialize = function(data) {\r\n  let arr = data.split(',')\r\n  let root = arr[0] ? new TreeNode(arr[0]) : null\r\n  function decode(node) {\r\n      if(!node) return\r\n      if(arr.length) {\r\n        let tmp = arr.shift()\r\n        node.left = tmp ? new TreeNode(tmp) : null\r\n        decode(node.left)\r\n      } else {\r\n        node.left = null\r\n      }\r\n    if(arr.length) {\r\n      let tmp = arr.shift()\r\n      node.right = tmp ? new TreeNode(tmp) : null\r\n      decode(node.right)\r\n    } else {\r\n      node.right = null\r\n    }\r\n  }\r\n  arr.shift()\r\n  decode(root)\r\n  return root\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200653034","body":"## æ€è·¯\né¦–å…ˆé€’å½’éå†ï¼ŒæŠŠç›¸åŒåˆ—çš„æ•°æ®å…ˆå¡åˆ°ä¸€èµ·ï¼Œé€šè¿‡ä¸€ä¸ªmapå­˜å‚¨ï¼Œkeyä¸ºåˆ—å·ï¼Œvalueä¸ºè¯¥åˆ—æ•°æ®çš„é›†åˆï¼Œæ•°æ®è®°å½•äº†èŠ‚ç‚¹çš„valueå’Œæ‰€å¤„çš„rowï¼›\nç„¶åéå†å¾—åˆ°çš„mapï¼Œå…ˆæŒ‰keyï¼Œä¹Ÿå°±æ˜¯æ‰€å¤„çš„åˆ—å·ä»å°åˆ°å¤§æ’ï¼ŒåŒä¸€åˆ—çš„æ•°æ®å¦‚æœrowç›¸åŒåˆ™ä»¥valä»å°åˆ°å¤§æ’ï¼Œå¦åˆ™æŒ‰rowä»å°åˆ°å¤§æ’\n\n## ä»£ç \n```javascript\nvar verticalTraversal = function(root) {\n  let map = {};\n  function dfs (node, row, col) {\n    if(node) {\n      if(map[col]) map[col].push({row: row, val:node.val})\n      else map[col] = [{row: row, val:node.val}]\n      dfs(node.left, row + 1, col - 1)\n      dfs(node.right, row + 1, col + 1)\n    }\n  }\n  dfs(root, 0 , 0)\n  let res = []\n  Object.keys(map).sort((x,y) => x-y).forEach(key => {\n    res.push(map[key].sort((x,y) => {\n      if(x.row === y.row) return x.val - y.val\n      else return x.row - y.row\n    }).map(e => e.val))\n  })\n  return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202125979","body":"## æ€è·¯\néå†numsï¼Œç”¨mapå­˜å½“å‰çš„ä¸‹æ ‡å’Œå€¼ï¼Œå€¼ä¸ºkeyï¼Œä¸‹æ ‡ä¸ºvalue\néå†è¿‡ç¨‹ä¸­å‘ç°mapä¸­æœ‰ keyä¸º (target-å½“å‰å€¼) çš„é”®å€¼å¯¹ï¼Œå°±è¯´æ˜æ‰¾åˆ°äº†\n\n## ä»£ç \n```javascript\nvar twoSum = function(nums, target) {\n  let map = new Map()\n  for(let i = 0; i < nums.length; i++) {\n    if(map.has(target - nums[i])) return [i, map.get(target - nums[i])]\n    else map.set(nums[i], i)\n  }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203610329","body":"## æ€è·¯\néå†ä¸€éï¼ŒæŠŠå½“å‰å€¼å’Œå®ƒå‡ºç°çš„æ¬¡æ•°ä»¥key-valueå­˜å‚¨ï¼›\nè½¬æ¢æˆæ•°ç»„ï¼ŒæŒ‰å‡ºç°æ¬¡æ•°ä»å¤§åˆ°å°æ’åºï¼›\nå–æ•°ç»„(0,k)ä½çš„å€¼\n\n## ä»£ç \n```javascript\nvar topKFrequent = function(nums, k) {\n  let map = {}\n  nums.forEach(v => {\n    if(map[v]) map[v]++\n    else map[v] = 1\n  })\n  let res = Object.keys(map).map(key => {\n    return {k: key, v: map[key]}\n  }).sort((x,y) => {\n    return y.v - x.v\n  }).map(_v => _v.k).slice(0,k)\n  return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204809889","body":"## æ€è·¯\nä¸¤å±‚å¾ªç¯ï¼Œç¬¬ä¸€ä¸ªå¾ªç¯å†…åˆ›å»ºä¸€ä¸ªmapï¼Œç¬¬äºŒä¸ªå¾ªç¯å†…é‡åˆ°ç›¸åŒçš„ç‚¹å°±è·³è¿‡ï¼Œå¦åˆ™å°±è®¡ç®—iå’Œjçš„è·ç¦»ï¼Œå­˜åˆ°mapé‡Œï¼Œkeyæ˜¯è·ç¦»ï¼Œvalueæ˜¯1ï¼›\nå¦‚æœå¾ªç¯è¿‡ç¨‹ä¸­å‘ç°mapå†…å·²ç»å­˜åœ¨äº†è¯¥è·ç¦»ä¸ºkeyçš„é”®å€¼å¯¹ï¼Œå°±æŠŠç»“æœå€¼åŠ ä¸Š 2* valueï¼›valueè‡ªå¢1ï¼›\n2*valueæ˜¯å› ä¸ºé¡ºåºä¸åŒçš„æƒ…å†µæ˜¯ä¸¤ä¸ªè§£ï¼Œæ‰€ä»¥æ¯æ¬¡æ‰¾åˆ°ç›¸åŒè·ç¦»èŠ‚ç‚¹ï¼Œå°±ä¼šå¤šå‡º2ä¸ªè§£\n\n## ä»£ç \n```javascript\nvar numberOfBoomerangs = function(points) {\n  if(points.length < 3) return 0\n  let res = 0\n  for(let i = 0; i < points.length; i++) {\n    let map = new Map()\n    for(let j = 0; j<points.length; j++) {\n      if(i === j) continue\n      let dist = Math.pow(points[i][0] - points[j][0], 2) + Math.pow(points[i][1] - points[j][1], 2)\n      if(map.get(dist)) {\n        res += 2 * map.get(dist)\n        map.set(dist, map.get(dist) + 1)\n      }\n      else map.set(dist, 1)\n    }\n  }\n  return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206216454","body":"## æ€è·¯\néå†å­—ç¬¦ä¸²ï¼Œå­—ç¬¦ä¾æ¬¡å¡è¿›é˜Ÿåˆ—ï¼Œå¦‚æœé˜Ÿåˆ—å†…å·²ç»æœ‰äº†è¯¥å­—ç¬¦ï¼Œåˆ™æŠŠè¯¥å­—ç¬¦åŠå…¶ä¹‹å‰çš„æ‰€æœ‰å­—ç¬¦æ¨å‡ºé˜Ÿåˆ—ï¼Œæ¯æ¬¡å¾ªç¯éƒ½çœ‹ä¸€ä¸‹å½“å‰é˜Ÿåˆ—çš„é•¿åº¦ï¼Œè¿”å›éå†è¿‡ç¨‹ä¸­é˜Ÿåˆ—æœ€é•¿çš„é‚£ä¸€æ¬¡çš„é•¿åº¦ã€‚\n\n## ä»£ç \n```javascript\nvar lengthOfLongestSubstring = function(s) {\n  let queue = [], res = 0\n  for(let item of s) {\n    let index = queue.indexOf(item)\n    if(index > -1) {\n      queue.splice(0, index + 1)\n    }\n    queue.push(item)\n    res = Math.max(res, queue.length)\n  }\n  return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207148512","body":"## æ€è·¯\r\n1. å…ˆå®šä¹‰ä¸€ä¸ªmapï¼Œéå†wordså­˜å‚¨æ¯ä¸ªå•è¯å‡ºç°çš„æ¬¡æ•°ï¼›\r\n2. å‡è®¾å•ä¸ªwordé•¿åº¦ä¸ºnï¼Œä»å­—ç¬¦ä¸²å¼€å¤´å¼€å§‹ï¼Œéå†é•¿åº¦ä¸ºn*words.lengthçš„å­ä¸²ï¼Œä»è¯¥å­ä¸²å¤´å¼€å§‹æ¯æ¬¡å–nä¸ªå­—ç¬¦ï¼ˆå‡è®¾ä¸ºkeyï¼‰åˆ¤æ–­æ˜¯å¦å­˜åœ¨åœ¨mapå†…ï¼Œè‹¥å­˜åœ¨ï¼Œåˆ™map[key]--ï¼Œè‹¥ä¸å­˜åœ¨æˆ–å°äºç­‰äº0ï¼Œé€€å‡ºéå†ï¼Œè¯´æ˜è¯¥å­ä¸²ä¸ç¬¦åˆæ¡ä»¶ï¼›\r\n3. è‹¥éå†åˆ°æœ€åï¼Œå‘å…ˆéƒ½æ˜¯ç¬¦åˆæ¡ä»¶çš„ï¼Œåˆ™è¯¥å­ä¸²æ»¡è¶³ï¼Œè®°å½•å…¶é¦–ä½ä¸‹æ ‡ï¼›\r\n4. å¾€åæ¨ä¸€ä½ï¼Œç»§ç»­æ­¥éª¤2ã€‚\r\n\r\n## ä»£ç \r\n```javascript\r\nvar findSubstring = function(s, words) {\r\n    let res = []\r\n    let map = {}\r\n    words.forEach(e => {\r\n        if(map[e]) map[e] = map[e] + 1\r\n        else map[e] = 1\r\n    })\r\n    let charLength = words[0].length\r\n    let strLength = charLength * words.length\r\n    let l = 0, r = strLength - 1;\r\n    while(r < s.length) {\r\n        let [left,right] = [l,r]\r\n        let tmpMap = {...map}\r\n        let flag = true\r\n        while(left <= right) {\r\n            let strLeft = s.slice(left, left + charLength)\r\n            if(tmpMap[strLeft] > 0) {\r\n                tmpMap[strLeft] --\r\n                left += charLength\r\n            } else {\r\n                flag = false\r\n                break;\r\n            }\r\n        }\r\n        if(flag) {\r\n            res.push(l)\r\n        }\r\n        l += 1\r\n        r += 1\r\n    }\r\n    return res\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207426721","body":"## æ€è·¯\nçœ‹äº†é¢˜è§£åšå‡ºæ¥çš„\nåŒä½™å®šç†ï¼šä¸¤ä¸ªæ¨¡ k ä½™æ•°ç›¸åŒçš„æ•°å­—ç›¸å‡ï¼Œå¾—åˆ°çš„å·®å€¼ä¸€å®šå¯ä»¥è¢« k æ•´é™¤\n\n## ä»£ç \n```javascript\nfloorMod = function (a, b) {\n  return ((a % b) + b) % b;\n};\nclass Solution {\n    solve(nums, k) {\n        let map = new Map();\n        map.set(0, -1);\n        let res = nums.length;\n        let target = 0;\n        let currSum = 0;\n        for (let i = 0; i < nums.length; i++) {\n            target += nums[i];\n        }\n        target = target % k;\n        for (let i = 0; i < nums.length; i++) {\n            currSum = (nums[i] + currSum) % k;\n            map.set(currSum, i);\n            let prevSum = floorMod(currSum - target, k);\n            if (map.has(prevSum)) {\n                res = Math.min(res, i - map.get(prevSum));\n            }\n        }\n        return res === nums.length ? -1 : res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207595171","body":"## æ€è·¯\nå¿«æ…¢æŒ‡é’ˆ\n\n## ä»£ç \n```javascript\nvar middleNode = function(head) {\n  let slow = head\n  let fast = head.next\n  while(fast) {\n    slow = slow.next\n    fast = fast.next?.next\n  }\n  return slow\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209008568","body":"## æ€è·¯\nåŒæŒ‡é’ˆï¼Œå·¦æŒ‡é’ˆåˆå§‹ä¸º0ï¼Œå³æŒ‡é’ˆåˆå§‹ä¸º1ï¼Œéå†numsï¼Œå¦‚æœå·¦å³æŒ‡é’ˆå¯¹åº”çš„å€¼ä¸åŒä¸”ä¸ç›¸é‚»ï¼Œåˆ™å·¦æŒ‡é’ˆåä¸€ä½ä¸å·¦æŒ‡é’ˆå€¼äº¤æ¢ï¼Œå·¦æŒ‡é’ˆåç§»ä¸€ä½ï¼Œå³æŒ‡é’ˆæ¯æ¬¡éå†éƒ½éœ€è¦åç§»ä¸€ä½ï¼Œæœ€åè¿”å›å·¦æŒ‡é’ˆåŠ 1\n\n## ä»£ç \n```javascript\nvar removeDuplicates = function(nums) {\n  let l = 0, r = 1;\n  while(r < nums.length) {\n    if(nums[r] !== nums[l]) {\n      if(r !== l + 1) {\n        nums[l + 1] = nums[r]\n        nums[r] = nums[l]\n      } \n      l ++\n    }\n    r ++\n  }\n  return l + 1\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fangxianshen":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185100852","body":"##Goè§£æ³•æ€è·¯\n```\nfunc addToArrayForm(num []int,k int)(ans []int){\n\tfor i := len(num)-1;i>=0;i--{\n\t\tsum := num[i] + k%10\n\t\tk /= 10\n\t\tif sum >=10{\n\t\t\tk ++\n\t\t\tsum -= 10\n\t\t}\n\t\tans = append(ans,sum)\n\t}\n\tfor ; k>0;k/=10{\n\t\tans = append(ans,k%10)\n\t}\n\treverse(ans)\n\treturn\n}\n\nfunc reverse(num []int){\n\tfor i,n := 0,len(num);i<n/2;i++{\n\t\tnum[i],num[n-1-i] = num[n-1-i],num[i]\n\t}\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186893829","body":"##Goä»£ç \r\n\r\n'''\r\npackage main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"math\"\r\n)\r\n\r\nfunc shortestToChar(s string, c byte) []int {\r\n\tpos, answer := -len(s), make([]int, len(s))\r\n\tfor i := 0; i < len(s); i++ {\r\n\t\tif s[i] == c {\r\n\t\t\tpos = i\r\n\t\t}\r\n\t\tanswer[i] = i - pos\r\n\t}\r\n\tfor i := pos - 1; i >= 0; i-- {\r\n\t\tif s[i] == c {\r\n\t\t\tpos = i\r\n\t\t}\r\n\t\tanswer[i] = int(math.Min(float64(answer[i]), float64(pos-i)))\r\n\t}\r\n\treturn answer\r\n}\r\n\r\nfunc main() {\r\n\ts := \"loveleetcode\"\r\n\tvar str byte = 'e'\r\n\tfmt.Println(shortestToChar(s,str))\r\n}\r\n\r\n'''","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186911685","body":"#Day 4  GOè§£æ³•\n```\nvar i int\n\nfunc run(s string) string{\n\tres := \"\"\n\tnum := 0\n\tfor ; i<len(s);i++{\n\t\tif s[i] >= '0' && s[i] <= '9'{\n\t\t\tnum = num *10 + int(s[i]-'0')\n\t\t}else if (s[i] >= 'a'&& s[i] <= 'z'){\n\t\t\tres += string(s[i])\n\t\t}else if s[i] == '[' {\n\t\t\ti++\n\t\t\ttmp := run(s)\n\t\t\tfor j := 0;j<num;j++{\n\t\t\t\tres += tmp\n\t\t\t}\n\t\t\tnum =0\n\t\t}else{\n\t\t\tbreak\n\t\t}\n\t}\n\treturn res\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jokertzw":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185100878","body":"### æ€è·¯\nlistå˜ä¸ºstrå†å˜ä¸ºintç„¶åæ±‚å’Œåå†è½¬åŒ–ä¸ºlist\n### ä»£ç \n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        sum = int(''.join(map(str, num))) + k\n        return [int(i) for i in str(sum)]\n```\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n) \n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186084611","body":"### æ€è·¯\néå†sï¼Œå¦‚æœåœ¨ç›¸åº”ä½ç½®çš„å­—ç¬¦ç­‰äºcï¼Œåˆ™è¯¥ä½ç½®çš„æœ€çŸ­è·ç¦»ä¸€å®šä¸º0ã€‚å¦‚æœä¸æ˜¯cï¼Œåˆ™é‡æ–°éå†sï¼Œè®¡ç®—ç¦»æ¯ä¸ªcçš„è·ç¦»ï¼Œä»ä¸­å–æœ€å°å€¼\n### ä»£ç \n```python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        for i in range(len(s)):\n            if s[i] == c:\n                res.append(0)\n            else:\n                res.append(min(abs(i - j) for j in range(len(s)) if s[j] == c))\n        return res\n```\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n^2) è¿™é‡ŒåµŒå¥—äº†ä¸¤å±‚forå¾ªç¯\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n) nä¸ºresé•¿åº¦","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186393084","body":"### ä»£ç \n```python\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        self.n = maxSize\n        self.stack = []\n        self.inc = []\n\n\n    def push(self, x):\n        if(len(self.stack) < self.n):\n            self.stack.append(x)\n            self.inc.append(0)\n\n    def pop(self):\n        if(len(self.stack) == 0):\n            return -1\n        else:\n            return self.stack.pop() + self.inc.pop()\n\n\n    def increment(self, k, val):\n        for i in range(min(k, len(self.inc))):\n            self.inc[i] += val\n```\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n) \n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187081216","body":"### æ€è·¯\nè¿™é‡Œé¢æ‹¬å·éƒ½æ˜¯æ•´å¯¹å‡ºç°çš„ï¼Œæ˜¯ä¸€ä¸ªå¾ˆç»å…¸çš„æ‹¬å·é—®é¢˜ï¼Œå¯ä»¥ç”¨åˆ°æ ˆæ¥è§£å†³ã€‚ï¼Œé‡åˆ°å·¦æ‹¬å·è¿›æ ˆï¼Œå³æ‹¬å·å‡ºæ ˆ\n### ä»£ç \n```python\nclass Solution(object):\n    def decodeString(self, s):\n        stack = [(1, [])]\n        currK = []\n        for i in range(len(s)):\n            if s[i].isdigit():\n                currK.append(s[i])\n            elif s[i] == '[':\n                k = int(\"\".join(currK))\n                stack.append((k, []))\n                currK = []\n            elif s[i] == ']':\n                k, cstr = stack.pop()\n                stack[-1][1].extend(k*cstr)\n            else:\n                stack[-1][1].append(s[i])\n\n        return \"\".join(stack[0][1])\n```\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n),å…¶ä¸­nä¸ºè§£ç åçš„sçš„é•¿åº¦ã€‚\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n),å…¶ä¸­nä¸ºè§£ç åçš„sçš„é•¿åº¦ã€‚","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188442598","body":"### æ€è·¯\nè¿›é˜Ÿåˆ—å’Œè¿›æ ˆæ“ä½œç›¸åŒï¼Œéƒ½å¯ä»¥ç”¨appendæ¥å®ç°ï¼Œè¿™é‡Œè®¾ç½®ä¸¤ä¸ªæ ˆï¼Œå‡ºé˜Ÿåˆ—çš„æ—¶å€™ï¼Œéœ€è¦å…ˆç”¨æ ˆä¸€å…ƒç´ å…¨éƒ¨åˆ°æ ˆäºŒï¼Œç„¶åæ ˆäºŒå‡ºæ ˆå³å¯å¾—åˆ°ç›¸åº”å…ƒç´ \n### ä»£ç \n```python\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack = []\n        self.stack2 = []\n\n    def push(self, x):\n        self.stack.append(x)\n\n    def pop(self):\n        if len(self.stack) == 0:\n            return -1\n        else:\n            while len(self.stack) > 1:\n                self.stack2.append(self.stack.pop())\n            res = self.stack.pop()\n            while len(self.stack2) > 0:\n                self.stack.append(self.stack2.pop())\n            return res\n\n    def peek(self):\n        if len(self.stack) == 0:\n            return -1\n        else:\n            return self.stack[0]\n\n    def empty(self):\n        return len(self.stack) == 0\n```\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189697436","body":"### å€Ÿé‰´å®˜æ–¹é¢˜è§£\n### ä»£ç \n```python\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        stack = []\n        for a in arr:\n            if stack and stack[-1] > a:\n                cur = stack[-1]\n                while stack and stack[-1] > a:\n                    stack.pop()\n                stack.append(cur)\n            else:\n                stack.append(a)\n        return len(stack)\n```\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n) \n- ç©ºé—´å¤æ‚åº¦ï¼šO(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190937927","body":"### æ€è·¯\næˆ‘ä»¬å¯ä»¥å…ˆç¡®å®šé“¾è¡¨çš„é•¿åº¦å’Œé“¾è¡¨çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼ŒæŠŠé“¾è¡¨å˜æˆä¸€ä¸ªç¯ã€‚ç„¶åæ‰¾åˆ°ç¬¬length-k-1çš„ä½ç½®å°†å¹»åˆ‡å‰²å³å¯å¾—åˆ°æœ€ç»ˆç­”æ¡ˆ\n### ä»£ç \n```python\nclass Solution(object):\n    def rotateRight(self, head, k):\n        lastElement = head\n        length = 1\n        while ( lastElement.next ):\n            lastElement = lastElement.next\n            length += 1\n        k = k % length\n        lastElement.next = head\n        tempNode = head\n        for _ in range( length - k - 1 ):\n            tempNode = tempNode.next\n        answer = tempNode.next\n        tempNode.next = None\n        return answer\n```\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192194926","body":"### æ€è·¯\néå†é“¾è¡¨ï¼Œä¸¤ä¸¤è¿›è¡Œäº¤æ¢\n### ä»£ç \n```python\nclass Solution(object):\n    def swapPairs(self, head):\n        pre = head\n        while pre and pre.next:\n            a = pre.val\n            b = pre.next.val\n            pre.val = b\n            pre.next.val = a\n            pre = pre.next.next\n        return head\n```\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193032471","body":"```\nclass Solution(object):\n    def sortedListToBST(self, head):\n        if not head:\n            return None\n        if not head.next:\n            return TreeNode(head.val)\n        slow,fast = head,head.next.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        tmp = slow.next\n        slow.next = None\n        root = TreeNode(tmp.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(tmp.next)\n        return root\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193234551","body":"### æ€è·¯\nä»¥ç›¸åçš„é¡ºåºè¿æ¥ABï¼ŒA+Bå’ŒB+Aã€‚è¿™æ ·ï¼Œéå†è¿æ¥åçš„é“¾è¡¨ï¼Œæœ€åä¸€å®šä¼šé‡åˆ°ç›¸äº¤çš„èŠ‚ç‚¹\n### ä»£ç \n```python\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        a,b = headA,headB\n        while (a != b):\n            a = headB if not a else a.next\n            b = headA if not b else b.next\n        return a\n```\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193475712","body":"```python\nclass Solution(object):\n    def detectCycle(self, head):\n        slow = fast = head\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n            if slow == fast: break\n        if not (fast and fast.next): return None\n        while head != slow:\n            head, slow = head.next, slow.next\n        return head\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195461532","body":"```python\nclass LRUCache(object):\n    def __init__(self,capacity):\n        self.dic = collections.OrderedDict()\n        self.remain = capacity\n    def get(self,key):\n        if key not in self.dic:\n            return -1\n        v = self.dic.pop(key)\n        self.dic[key] = v\n        return v\n    def set(self,key,value):\n        if key in self.dic:\n            self.dic.pop(key)\n        else:\n            if self.remain > 0:\n                self.remain -= 1\n            else:\n                self.dic.popitem(last=False)\n        self.dic[key] = value\n```\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(1)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196271612","body":"```python\nclass Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197580305","body":"```\ndef isSameTree1(self, p, q):\n    if p and q:\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n    else:\n        return p == q\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199307370","body":"```\nclass Solution(object):\n    def sumNumbers(self, root): # DFS recursively \n        self.res = 0\n        self.dfs(root, 0)\n        return self.res\n    \n    def dfs(self, root, path):\n        if root:\n            if not root.left and not root.right:\n                path = path*10 + root.val\n                self.res += path\n            self.dfs(root.left, path*10+root.val)\n            self.dfs(root.right, path*10+root.val)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200088961","body":"```\nclass Solution:\n    def findBottomLeftValue(self, root):\n        \n        res = [root.val, 0]\n        self.search(root, res, 0)\n        return res[0]\n    \n    def search(self, node, res, curDepth):\n        \n        if node:\n            if curDepth > res[1]:\n                res[0], res[1] = node.val, curDepth\n            \n            self.search(node.left, res, curDepth+1)\n            self.search(node.right, res, curDepth+1)\n```\n            ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200329159","body":"```python\nclass Codec:\n\n    def serialize(self, root):\n        def doit(node):\n            if node:\n                vals.append(str(node.val))\n                doit(node.left)\n                doit(node.right)\n            else:\n                vals.append('#')\n        vals = []\n        doit(root)\n        return ' '.join(vals)\n\n    def deserialize(self, data):\n        def doit():\n            val = next(vals)\n            if val == '#':\n                return None\n            node = TreeNode(int(val))\n            node.left = doit()\n            node.right = doit()\n            return node\n        vals = iter(data.split())\n        return doit()\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200920589","body":"```python\nclass Solution:\n    def __init__(self):\n        self.point_list = []\n        \n    def dfs(self, root, x, y):\n        self.point_list.append([x,y,root.val]) # keep in list all points\n        if root.left:\n            self.dfs(root.left, x-1, y-1)\n        if root.right:\n            self.dfs(root.right, x+1, y-1)\n        \n    def verticalTraversal(self, root):\n        self.dfs(root, 0, 0)\n        self.point_list.sort(key = lambda a:a[2]) # sort by value\n        self.point_list.sort(key = lambda a:a[1], reverse = True) # sort by y\n        self.point_list.sort(key = lambda a:a[0]) # sort by x\n\t\t\n        res = []\n        left = abs(self.point_list[0][0])\n        right = self.point_list[-1][0]\n\t\t\n        for i in range(left+right+1):\n            res.append([j[2] for j in self.point_list if j[0]==i-left])\n\t\t\t\n        return res \n    ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202080176","body":"```python\nclass Solution(object):\n    def twoSum(self, nums, target):\n        seen = {}\n        for i, num in enumerate(nums):\n            if target - num in seen:\n                return [seen[target - num], i]\n            seen[num] = i\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203521864","body":"```python\nclass Solution(object):\n    def topKFrequent(self, nums, k):\n        hs = {}\n        frq = {}\n        for i in range(0,len(nums)):\n            if nums[i] not in hs:\n                hs[nums[i]] = 1\n            else:\n                hs[nums[i]] += 1\n        \n        for z,v in hs.iteritems():\n            if v not in frq:\n                frq[v] = [z]\n            else:\n                frq[v].append(z)\n        arr = []\n\n        for x in range(len(nums),0,-1):\n            if x in frq:\n                for i in frq[x]:\n                    arr.append(i)\n        return [arr[x] for x in range(0, k)]\n```\n        \n        ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204793089","body":"```python\nclass Solution:\n    def numberOfBoomerangs(self, points):\n        n = 0\n        for a,b in points:\n            counter = {}\n            for x,y in points:\n                key = (x-a)**2 + (y-b)**2\n                if key in counter:\n                    n += 2*counter[key]\n                    counter[key] += 1\n                else:\n                    counter[key] = 1 \n        return n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205873075","body":"```python\nclass Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        start = maxLength = 0\n        usedChar = {}\n        for i in range(len(s)):\n            if s[i] in usedChar and start <= usedChar[s[i]]:\n                start = usedChar[s[i]] + 1\n            else:\n                maxLength = max(maxLength, i - start + 1)\n            usedChar[s[i]] = i\n        return maxLength\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207151767","body":"```python\nclass Solution(object):\n    def findSubstring(self, s, words):\n        if len(words) == 0:\n            return []\n        l = len(words[0])\n        d = {}\n        for w in words:\n            if w not in d:\n                d[w] = 1\n            else:\n                d[w] += 1\n        i = 0\n        ans = []\n\n        for k in range(1):\n            left = k\n            subd = {}\n            count = 0\n            for j in range(k,len(s)-l+1,l):\n                tword = s[j:j+l]\n                if tword in d:\n                    if tword in subd:\n                        subd[tword] += 1\n                    else:\n                        subd[tword] = 1\n                    count += 1\n                    while subd[tword] > d[tword]:\n                        subd[s[left:left+l]] -= 1\n                        count -= 1\n                        left += l\n                    if count == len(words):\n                        ans.append(left)\n                else:\n                    subd = {}\n                    count = 0\n                    left = j + l\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207349657","body":"```python\nclass Solution:\n    def solve(self, nums, k):\n        total = sum(nums)\n        mod = total % k\n        ans = len(nums)\n        total = 0\n        dic = {0:-1}\n        for i in range(len(nums)):\n            total += nums[i]\n            cur = total % k\n            target = (cur - mod) % k\n            if target in dic:\n                ans = min(ans, i - dic[target])\n            if cur not in dic:\n                dic[cur] = i\n        return ans if ans < len(nums) else -1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207510699","body":"```python\nclass Solution(object):\n    def middleNode(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        fast = slow = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        return slow\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208763155","body":"```python\nx = 1\n\n    for i in range(len(nums)-1):\n        if(nums[i] != nums[i+1]):\n            nums[x] = nums[i+1]\n            x += 1\n    return(x)\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/42#issuecomment-1210027224","body":"```python\nclass Solution(object):\n    def searchInsert(self, nums, target):\n        l,r = 0,len(nums)-1\n        while l <= r:\n            mid = (l+r)//2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return l\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cyang258":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185102829","body":"```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n        int kLength = 0;\n        int kcounter = k;\n        while(kcounter > 0){\n            kcounter /= 10;\n            kLength++;\n        }\n        int numLength = num.length;\n        List<Integer> res = new ArrayList<Integer>();\n        // find num or k whichever has smallest length as counter to loop\n        int counter = kLength > numLength ? numLength : kLength;\n        int carry = 0;\n        // add digit with digit and if exceed 10 then add 1 to carry and remainder to list\n        while(counter > 0){\n            int remainder = k % 10;\n            k /= 10;           \n            int digit = (num[numLength - 1] + remainder + carry) % 10;\n            carry = (num[numLength - 1] + remainder + carry) / 10;\n            // add remainder to each digit\n            res.add(0, digit);\n            counter--;\n            numLength--;\n        }\n        // if k is longer digit, then we add remaining k to list\n        while(k > 0){\n            int remainder = k % 10;\n            k /= 10;\n            int digit = (remainder + carry) % 10;\n            carry = (remainder + carry) / 10;\n            // add remainder to each digit\n            res.add(0, digit);\n        }\n        // if num array is longer, then we add remaining num array to list\n        while(numLength > 0){\n            int digit = (num[numLength - 1] + carry) % 10;\n            carry = (num[numLength - 1] + carry) / 10;\n            res.add(0, digit);\n            numLength--;\n        }\n        // if we have remaining carry, we add carry to list\n        if(carry > 0){\n            res.add(0, carry);\n        }\n        return res;\n    }\n```\n\n  Time Complexity: O(max(N,M)) which N is length of num array and M is digit of k  <br/>\n  Space Complexity: O(max(N, M)) since we need to store the result and it is the longest number between length num array and digit of k <br/>\n## æ€è·¯\n#### æˆ‘éœ€è¦æŠŠä¸¤ä¸ªæ•°ç›¸åŠ ï¼Œé‚£æˆ‘å°±åªéœ€è¦æŠŠæ¯ä¸ªdigitçš„æ•°ç›¸åŠ ç„¶åé™¤ä»¥10ï¼Œä½™æ•°å°±æ˜¯ç°åœ¨çš„digitçš„æ•°ï¼Œå¦‚æœè¶…è¿‡10å°±åŠ å…¥carry åŠ åˆ°ä¸‹ä¸€ä¸ªdigit æ¯”å¦‚ä¸ªä½ä¸Š num arrayæ˜¯5ï¼Œkçš„ä¸ªä½æ˜¯6ï¼Œé‚£æœ€ç»ˆç»“æœçš„ä¸ªä½å¿…ç„¶æ˜¯1ï¼Œæˆ‘ä»¬æŠŠå¤šå‡ºæ¥çš„10åŠ åˆ°åä½æ•°å°±è¡Œï¼Œå…·ä½“å¯è§†åŒ–å‚ç…§å°å­¦åŠ æ³•åˆ—å¼å­","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186091786","body":"#### æ€è·¯\n- å…ˆä»å·¦å¾€å³éå†æ•´ä¸ªstringï¼Œé‡åˆ°å’Œcä¸€æ ·çš„å­—æ¯ï¼Œé‚£å®ƒçš„distanceå°±æ˜¯0ï¼Œå¾€å³çš„å­—æ¯å°±ä»¥å·¦è¾¹çš„è¿™ä¸ªå­—æ¯ä¸ºåŸºå‡†è®°å½•è·ç¦»\n- ç„¶åä»å³å¾€å·¦éå†æ•´ä¸ªstringï¼ŒåŒæ ·é“ç†ï¼Œé‡åˆ°å’Œcä¸€æ ·çš„å­—æ¯ï¼Œé‚£å®ƒçš„distanceå°±æ˜¯0ï¼Œå¾€å·¦çš„å­—æ¯å°±ä»¥è¿™ä¸ªå­—æ¯ä¸ºåŸºå‡†è®°å½•è·ç¦»ï¼Œä½†æ˜¯éœ€è¦å’ŒåŸæœ¬ä½ç½®çš„array itemæ¯”å°ï¼Œå°çš„æ‰æ˜¯ç­”æ¡ˆ\n\n```java\npublic int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] res = new int[n];\n        int prev = Integer.MIN_VALUE / 2;\n        \n        for(int i = 0; i < n; i++){\n            if(s.charAt(i) == c) \n                prev = i;\n            \n            res[i] = i - prev;\n        }\n        \n        prev = Integer.MAX_VALUE / 2;\n        for (int i = n-1; i >= 0; --i) {\n            if (s.charAt(i) == c) \n                prev = i;\n            res[i] = Math.min(res[i], prev - i);\n        }\n\n        return res;\n    }\n```\nTime Complexity: O(N) -- loop through string twice, N is length of string <br/>\nSpace Complexity: O(N) -- we store the answer with an array in length N which is the length of string","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186520151","body":"### æ€è·¯\r\n- ç”¨arrayæ¨¡æ‹Ÿ\r\n\r\n```java\r\nclass CustomStack {\r\n    int maxSize;\r\n    int size;\r\n    int[] data;\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize;\r\n        this.size = 0;\r\n        this.data = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(size < maxSize)\r\n            data[size++] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(size == 0) return -1;\r\n        return data[--size];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if(k > size){\r\n            for(int i = 0; i < size; i++){\r\n                data[i] += val;\r\n            }\r\n        }else{\r\n            for(int i = 0; i < k; i++){\r\n                data[i] += val;\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\nTime complexity: <br/>\r\n- push O(1)\r\n- pop O(1)\r\n- inc O(min(k, size))\r\nSpace complexity: O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187342571","body":"#### æ€è·¯ <br/>\nuse two stack\n- one hold the multiplier\n- one to hold the string characters\nwe push the string characters to charStack and we convert the multiplier to digit and store into count stack. Once we meet ']' that means we have a complete '[ ]' so we could apply the mulitplier on the top of countStack to the char pattern inside the bracket. Then we get the decoded char arrays and push it back to charStack. we continue doing this until the string input is at the end. Then we would have the result string character in stack. Then we need to use string builder to convert the char stack to string.\n\n```java\npublic String decodeString(String s) {\n        Stack<Character> charStack = new Stack<>();\n        Stack<Integer> countStack = new Stack<>();\n        for(int i = 0; i < s.length(); i++){\n            // start to pop when we find ]\n            if(s.charAt(i) == ']'){\n                List<Character> tempString = new ArrayList<Character>();\n                while(charStack.peek() != '['){\n                    tempString.add(charStack.pop());\n                }\n                // remove [\n                charStack.pop();\n                int k = 0;\n                // get the number k\n                if(!countStack.isEmpty()){\n                    k = countStack.pop();\n                }\n                // push back multiplied partial string back to stack\n                while(k > 0){\n                    for (int j = tempString.size() - 1; j >= 0; j--) {\n                        charStack.push(tempString.get(j));\n                    }\n                    k--;\n                }\n            }else if(Character.isDigit(s.charAt(i))){\n                int k = s.charAt(i) - '0';\n                while(Character.isDigit(s.charAt(i+1))){\n                    k = k*10 + (s.charAt(i+1) - '0');\n                    i++;\n                }\n                countStack.push(k);\n            }else{\n                charStack.push(s.charAt(i));\n            }\n        }\n        StringBuilder res = new StringBuilder();\n        while(!charStack.isEmpty()){\n            res.insert(0, charStack.pop());\n        }\n        return res.toString();\n    }\n```\nTime Complexity: O(N* M) we loop through all characters in string thus it will have N loops, which N is the length of string, and for each time we need to run k times in order to apply multiplier, so the worst case is Max(k), thus M, so it is N * M\n\nSpace Complexity: we use to stacks which the total length is the length of string, we also use stringBuilder to hold result, so the space is O(N), N is the length of result.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189061235","body":"##### æ€è·¯\n\nä½¿ç”¨ä¸¤ä¸ªstackæ¥æ¨¡æ‹Ÿqueueçš„è¿è¡Œæ¨¡å¼ï¼Œå› ä¸ºstackæ˜¯FILOï¼Œæ‰€ä»¥æˆ‘ä»¬è¦æŠŠå®ƒè°ƒä¸ªå¤´ã€‚å‡è®¾queueçš„é¡ºåºæ˜¯FIFOï¼Œé‚£æ–°çš„elementè¿›æ¥æ—¶æˆ‘ä»¬åº”è¯¥æŠŠå®ƒåŠ åœ¨å±è‚¡ä¸Šï¼Œæ‰€ä»¥æŠŠæ‰€æœ‰queueçš„elementéƒ½åŠ å…¥holderé‡Œé¢ç„¶ååœ¨æŠŠelementåŠ å…¥è¿›å»å°±æ˜¯åŠ åœ¨å±è‚¡ä¸Šäº†ï¼Œç„¶åæˆ‘ä»¬å†æŠŠholderçš„æ‰€ä»¥elementéƒ½è¿”å›ç»™queue\n\n```java\nclass MyQueue {\n    Stack<Integer> queue;\n    Stack<Integer> holder;\n    public MyQueue() {\n        queue = new Stack<>();\n        holder = new Stack<>();\n    }\n    \n    public void push(int x) {\n        while(!queue.isEmpty()){\n            holder.push(queue.pop());\n        }\n        holder.push(x);\n        while(!holder.isEmpty()){\n            queue.push(holder.pop());\n        }\n    }\n    \n    public int pop() {\n        return queue.pop();\n    }\n    \n    public int peek() {\n        return queue.peek();\n    }\n    \n    public boolean empty() {\n        return queue.isEmpty();\n    }\n}\n```\nTime Complexity:\n- push: O(n)\n- pop: O(1)\n- peek: O(1)\n- empty: O(1) \n\nSpace Complexity: using two stack, so it is O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189747262","body":"##### æ€è·¯\nå¯ä»¥è§‚å¯Ÿåˆ°åœ¨sortå¥½çš„arrayä¸­ï¼Œå·¦è¾¹chunkçš„æœ€å¤§å€¼ä¸€å®šå°äºç­‰äºå³è¾¹chunkçš„æœ€å°å€¼ï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€è¦æ‰¾åˆ°arrayé‡Œé¢æ¯ä¸ªpositionçš„å³è¾¹chunkæœ€å°å€¼(å¯ä»¥é€šè¿‡åå‘éå†å¾—åˆ°)ï¼Œç„¶åæˆ‘ä»¬å†éå†arrayå¹¶è®°å½•å·¦è¾¹çš„æœ€å¤§å€¼ï¼Œå¯¹æ¯”ä¸¤ä¸ªå€¼ï¼Œåªè¦æœ€å°å€¼å¤§äºç­‰äºæœ€å¤§å€¼ï¼Œé‚£è¿™ä¾¿è¯´æ˜ç¬¦åˆæ¡ä»¶\n\n```java\npublic int maxChunksToSorted(int[] arr) {\n        // we need to find right side chunk min for each position\n        int[] rightMin = new int[arr.length + 1];\n        rightMin[arr.length] = Integer.MAX_VALUE;\n        for(int i = arr.length - 1; i >= 0; i--){\n            rightMin[i] = Math.min(arr[i], rightMin[i+1]);\n        }\n        int leftMax = Integer.MIN_VALUE;\n        int res = 0;\n        for(int i = 0; i < arr.length; i++){\n            leftMax = Math.max(leftMax, arr[i]);\n            if(leftMax <= rightMin[i+1]){\n                res++;\n            }\n        }\n        return res;\n    }\n```\nTime Complexity: O(N) which N is the length of array - éå†ä¸¤éarray\n\nSpace Complxity: O(N) which N is the length of array - ç”¨ä¸€ä¸ªarrayå‚¨å­˜å³è¾¹chunkæœ€å°å€¼","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190954446","body":"##### æ€è·¯\nå› ä¸ºlistæœ‰é•¿åº¦ï¼Œæ‰€ä»¥ç§»åŠ¨äº†kæ¬¡ï¼Œå…¶å®æ˜¯ç§»åŠ¨äº†k%lengthæ¬¡ã€‚æˆ‘ä»¬å…ˆç®—å‡ºå®é™…ç§»åŠ¨çš„kï¼Œç„¶ååˆ©ç”¨å¿«æ…¢åŒæŒ‡é’ˆï¼Œè®©å¿«æŒ‡é’ˆå…ˆç§»åŠ¨å®é™…kæ¬¡ï¼Œç„¶åå¿«æ…¢æŒ‡é’ˆåŒæ—¶å‘åç§»åŠ¨ï¼Œç›´åˆ°å¿«æŒ‡é’ˆåˆ°è¾¾listæœ«å°¾æ—¶åœæ­¢ã€‚æ­¤æ—¶æ…¢æŒ‡é’ˆçš„ä¸‹ä¸€ä¸ªnodeå°±æ˜¯æ–°çš„å¤´ï¼Œæ…¢æŒ‡é’ˆæœ¬èº«æ˜¯æ–°çš„å°¾å·´ï¼Œæ‰€ä»¥æˆ‘ä»¬å°±æŠŠæ–°çš„å¤´æ‹¿å‡ºæ¥ï¼Œç„¶åæŠŠæ…¢æŒ‡é’ˆçš„nextè®¾ç½®ä¸ºnullï¼Œæœ€åæŠŠå¿«æŒ‡é’ˆçš„nextè®¾ç½®æˆè€çš„headï¼Œç„¶åreturnæ–°çš„å¤´å°±å¾—åˆ°æ­£ç¡®ç­”æ¡ˆ\n\n```java\npublic ListNode rotateRight(ListNode head, int k) {\n        if(head == null) return head;\n        // find the length of list\n        ListNode count = head;\n        int counter = 0;\n        while(count != null){\n            count = count.next;\n            ++counter;\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n        k = k % counter;\n        if(k == 0) return head;\n        while(k > 0){\n            fast = fast.next;\n            --k;\n        }\n        while(fast.next != null){\n            fast = fast.next;\n            slow = slow.next;\n        }\n        ListNode newHead = slow.next;\n        slow.next = null;\n        fast.next = head;\n        return newHead;\n    }\n```\nTime Complexity: O(N) which N is length of list\n\nSpace Complextiy: O(1), we did not use additional data structure ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192593911","body":"##### æ€è·¯\nwe repeatedly swap two node, so we could use recursion to repeat the swap steps\n\n```java\npublic ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null) return head;\n        \n        // Nodes to be swapped\n        ListNode firstNode = head;\n        ListNode secondNode = head.next;\n        \n        // Swap\n        firstNode.next = swapPairs(secondNode.next);\n        secondNode.next = firstNode;\n        \n        // Now the head is second node, so return it\n        return secondNode;\n}\n```\nTime Complexity: for each recursion the time complexity is O(1), and we run through the whole list nodes, thus it is O(N)\n\nSpace Complexity: we didn't use additional data structures, so it is O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193124003","body":"```java\n    public TreeNode sortedListToBST(ListNode head) {\n        // ä½¿ç”¨dfs å¿«æ…¢åŒæŒ‡é’ˆèƒ½å®šä½ä¸­ç‚¹\n        if(head == null) return null;\n        return dfs(head, null);\n    }\n    \n    public TreeNode dfs(ListNode head, ListNode tail){\n        if(head == tail) return null;\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast != tail && fast.next != tail){\n          fast = fast.next.next;\n          slow = slow.next;\n       }\n       TreeNode root = new TreeNode(slow.val);\n       root.left = dfs(head, slow);\n       root.right = dfs(slow.next, tail);\n       return root;\n    }\n```\nTime Complexity: O(nlog(n))\n\nSpace Complexity: O(log(n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193317905","body":"##### æ€è·¯\nåŒæŒ‡é’ˆ å½“åŒæŒ‡é’ˆåœ¨åŒä¸€nodeä¸Š é‚£ä¸ªnodeä¸€å®šæ˜¯äº¤å‰çš„node\n\n```java\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null) return null;\n        ListNode a = headA;\n        ListNode b = headB;\n        \n        while(a != b){\n            a = a == null ? headB : a.next;\n            b = b == null ? headA : b.next;\n        }\n        return a;\n    }\n```\nTime Complexity: O(N) which N is the total length of list A and B\n\nSpace Complexity: O(1) we didn't use additional data structure","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194111195","body":"```java\npublic ListNode detectCycle(ListNode head) {\n        if(head == null) return null;\n        ListNode slow = head, fast = head;\n        while(fast != null){\n            slow = slow.next;\n            if(fast.next != null){\n                fast = fast.next.next;\n            }else{\n                return null;\n            }\n            if(fast == slow){\n                ListNode ptr = head;\n                while(ptr != slow){\n                    ptr = ptr.next;\n                    slow = slow.next;\n                }\n                return ptr;\n            }\n        }\n        return null;\n    }\n```\nTime Complexity: O(N)\n\nSpace Complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194992894","body":"Using LinkedHashMap to keep order\n\n```java\nclass LRUCache extends LinkedHashMap<Integer, Integer> {\n\n    private int capacity;\n    public LRUCache(int capacity) {\n        super(capacity, 0.75F, true);\n        this.capacity = capacity;\n    }\n    \n    public int get(int key) {\n        return super.getOrDefault(key, -1);\n    }\n    \n    public void put(int key, int value) {\n        super.put(key, value);      \n    }\n    \n    @Override\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\n        return size() > capacity; \n    }\n}\n```\nTime Complexity: O(1)\n\nSpace Complexity: O(capacity)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196228604","body":"##### æ€è·¯\r\nä½¿ç”¨DFSï¼Œæ ‘çš„æœ€å¤§é«˜åº¦å–å†³äºå®ƒçš„å·¦è¾¹å’Œå³è¾¹çš„æœ€å¤§é«˜åº¦ï¼Œæ‰€ä»¥å®ƒçš„æœ€å¤§é«˜åº¦å°±æ˜¯1+Maxï¼ˆå·¦è¾¹é«˜åº¦ï¼Œå³è¾¹é«˜åº¦ï¼‰ï¼Œå¦‚æœnodeæ˜¯nullï¼Œé‚£å°±è¯´æ˜åˆ°åº•éƒ¨äº†ï¼Œreturn 0\r\n\r\n```java\r\npublic int maxDepth(TreeNode root) {\r\n        if(root == null) return 0;\r\n        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\r\n}\r\n```\r\nTime Complexity: O(N) which n is the total number of node in tree\r\n\r\nSpace Complexity: O(height) since we use recursion call stack","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198223133","body":"##### æ€è·¯\nç”¨recursionï¼Œå¦‚æœä¸¤ä¸ªnodeçš„valueä¸ä¸€æ ·ï¼Œæˆ–è€…å·¦è¾¹/å³è¾¹valueä¸ä¸€æ ·ï¼Œé‚£å®ƒå°±ä¸æ˜¯ç›¸åŒçš„tree\n\n``` java\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null) return true;\n        if((p == null && q != null) || (p != null && q == null)) return false;\n        \n        return (p.val == q.val) && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}\n```\nTime Complexity: O(n) which n is the total number of tree node\n\nSpace Complexity: O(height) because we use dfs to traverse tree which would use the hight of tree space for call stack","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1200229110","body":"##### æ€è·¯\nuse dfs to traverse the tree, we know that \n1) the value of a node's left node is current sum * 10 + leftNode.value, and the value of a node's right node is current sum * 10 + rightNode.value\n2) if we reached a leaf node, then it would be this path's outcome, so we return the total sum of leaf node\n\n```java\n    public int sumNumbers(TreeNode root) {\n        int sum = 0;\n        if(root == null) return 0;\n        return dfs(root, sum);\n    }\n    \n    public int dfs(TreeNode node, int sum){\n        int currentSum = node.val + sum;\n        \n        if(isLeaf(node)) return currentSum;\n        \n        int leftNodeSum = node.left == null ? 0 : dfs(node.left, currentSum * 10);\n        int rightNodeSum = node.right == null ? 0 : dfs(node.right, currentSum * 10);\n        return leftNodeSum + rightNodeSum;\n    }\n    \n    public boolean isLeaf(TreeNode node){\n        return node.left == null && node.right == null;\n    }\n```\nTime Complexity: O(N) which n is the total number of node in tree\n\nSpace Complexity: O(height) we dfs the tree, so there is a tree height of call stacks","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200224372","body":"##### æ€è·¯\nä½¿ç”¨BFSï¼Œç”¨queueè®°å½•ä¸‹å½“å‰levelçš„æ‰€æœ‰nodeï¼Œç¬¬ä¸€ä¸ªnodeå°±æ˜¯å¯èƒ½çš„ç­”æ¡ˆï¼Œç„¶åæˆ‘ä»¬è®°å½•ä¸‹æ‰€æœ‰å½“å‰levelçš„nodeçš„å·¦å³nodeä½œä¸ºä¸‹ä¸€ä¸ªlevelçš„queueï¼Œå¾ªç¯å¾€å¤ç›´åˆ°æ‰¾åˆ°æœ€åä¸€ä¸ªlevel\n\n```java\npublic int findBottomLeftValue(TreeNode root) {\n        int res = -1;\n        LinkedList<TreeNode> queue = new LinkedList<TreeNode>();\n        queue.add(root);\n        while(!queue.isEmpty()){\n            int currLevelSize = queue.size();\n            res = queue.getFirst().val;\n            for(int i = 0; i < currLevelSize; i++){\n                TreeNode node = queue.pollFirst();\n                if(node.left != null) queue.addLast(node.left);\n                if(node.right != null) queue.addLast(node.right);\n            }\n        }\n        return res;\n}\n```\nTime Complexity: O(N) which n is the total number of node in tree\n\nSpace Complexity: O(N) since we have a queue to store the node in 2 levels","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200445097","body":"```java\n// Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        String res = dfs(root, \"[\");\n        res = res.substring(0, res.length()-1);\n        res += \"]\";\n        return res;\n    }\n    \n    public String dfs(TreeNode node, String str){\n        if(node == null){\n            str += \"null,\";\n        }else{\n            str += String.valueOf(node.val) + \",\";\n            str = dfs(node.left, str);\n            str = dfs(node.right, str);\n        }\n        return str;\n        \n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        data = data.substring(1, data.length()-1);\n        String[] dataArr = data.split(\",\");\n        List<String> dataList = new LinkedList<String>(Arrays.asList(dataArr));\n        return buildTree(dataList);\n    }\n    \n    public TreeNode buildTree(List<String> dataList){\n        // if it is null then return null\n        if(dataList.get(0).equals(\"null\")){\n            dataList.remove(0);\n            return null;\n        }\n        TreeNode node = new TreeNode(Integer.valueOf(dataList.get(0)));\n        dataList.remove(0);\n        node.left = buildTree(dataList);\n        node.right = buildTree(dataList);\n        return node;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1205934326","body":"```java\npublic List<List<Integer>> verticalTraversal(TreeNode root) {\n        // Marking each node with coordinates for verticalTraversal\n        // Param: (KEY) column in ascending, (Val) TreeMap<Row in ascending, Node Val in ascending>\n        TreeMap<Integer, TreeMap<Integer, PriorityQueue<Integer>>> map = new TreeMap<>();\n        dfs(map, root, 0, 0);\n        \n        // Printout res in Column order\n        List<List<Integer>> res = new ArrayList<>();\n        for (TreeMap<Integer, PriorityQueue<Integer>> col : map.values()) {\n            List<Integer> curColumn = new ArrayList<>();\n            for (PriorityQueue<Integer> row : col.values()) {\n                while (!row.isEmpty()) {\n                    curColumn.add(row.poll());\n                }\n            }\n            res.add(new ArrayList<>(curColumn));\n        }\n        return res;\n    }\n    \n    public void dfs(TreeMap<Integer,TreeMap<Integer, PriorityQueue<Integer>>> map, TreeNode root, int x, int y) {\n        // Base case\n        if (root == null) { return;}\n        // If column visited\n        if (map.containsKey(y)) {\n            // If row visited\n            if (map.get(y).containsKey(x)) {\n                map.get(y).get(x).offer(root.val);\n            } else {\n                // Column visited, row didn't visit\n                TreeMap<Integer, PriorityQueue<Integer>> rows = map.get(y);\n                rows.put(x, new PriorityQueue<>());\n                rows.get(x).offer(root.val);\n            }\n        } else {\n            // Column didn't visit\n            TreeMap<Integer, PriorityQueue<Integer>> row = new TreeMap<>();\n            row.put(x, new PriorityQueue<>());\n            row.get(x).offer(root.val);\n            map.put(y, row);\n        }\n        // Keep DFS\n        dfs(map, root.left, x + 1, y - 1);\n        dfs(map, root.right, x + 1, y + 1);\n    }\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202823652","body":"```java\npublic int[] twoSum(int[] nums, int target) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for(int i = 0; i < nums.length; i++){\n            int remain = target - nums[i];\n            if(map.containsKey(nums[i])){\n                return new int[]{map.get(nums[i]), i};\n            }else{\n                map.put(remain, i);\n            }\n        }\n        return new int[2];\n    }\n```\nTime: O(N)\n\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1204720751","body":"##### Thought\nuse max heap to store the most frequent elements\n\n```java\npublic int[] topKFrequent(int[] nums, int k) {\n        if(k == nums.length) return nums;\n        \n        Map<Integer, Integer> count = new HashMap<>();\n        // initiate map\n        for(int n : nums){\n            count.put(n, count.getOrDefault(n, 0) + 1);\n        }\n        \n        // use max heap\n        Queue<Integer> heap = new PriorityQueue<>((a, b) -> count.get(b) - count.get(a));\n        \n        for(int n : count.keySet()){\n            heap.add(n);\n        }\n        int[] res = new int[k];\n        for(int i = 0; i < k; i++){\n            res[i] = heap.poll();\n        }\n        return res;\n    }\n```\nTime Complexity: O(nlogk)\n\nSpace Complexity: O(n + k)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204713508","body":"```java\n    public int numberOfBoomerangs(int[][] points) {\n        if(points == null || points.length <= 2) return 0;\n        \n        int res = 0;\n        Map<Integer, Integer> equalCount = new HashMap<Integer, Integer>();\n        \n        for(int i = 0; i < points.length; i++){\n            for(int j = 0; j < points.length; j++){\n                int distance = getDistance(points[i], points[j]);\n                equalCount.put(distance, equalCount.getOrDefault(distance, 0) + 1);\n            }\n            for(int count : equalCount.values()){\n                res += count * (count - 1);\n            }\n            equalCount.clear();\n        }\n        return res;\n    }\n    \n    private int getDistance(int[] x, int[] y){\n        int x1 = y[0] - x[0];\n        int y1 = y[1] - x[1];\n        return x1 * x1 + y1 * y1;\n    }\n```\nTime Complexity: O(n^2)\n\nSpace Complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205933000","body":"##### Thought\r\nuse sliding window, put right and left start from 0, use hashmap to track the position of latest appeared characters, if character at right pointer does not in hashmap, then it mean it is brand new character, thus the maxlength should be right - left + 1. if the character at right pointer is in hashmap, we use hashmap to retrieve the last position and store right + 1 as new position for this character. and maxlength should also be right - left + 1.\r\n\r\n```java\r\npublic int lengthOfLongestSubstring(String s) {\r\n        int left = 0;\r\n        int right = 0;\r\n        int res = 0;\r\n        HashMap<Character, Integer> map = new HashMap<Character, Integer>();\r\n        while (right < s.length()) {\r\n            char r = s.charAt(right);\r\n            if(map.containsKey(r)){\r\n                left = Math.max(map.get(r), left);\r\n            }\r\n            res = Math.max(res, right - left + 1);\r\n            map.put(r, right + 1);\r\n            right++;\r\n        }\r\n        return res;\r\n    }\r\n```\r\nTime Complexity: O(n) which n is the length of string\r\n\r\nSpace Complexity: O(n) we use hashmap to store character, which the wrost case is all characters in string is different.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207446543","body":"##### æ€è·¯\nwe first use hashmap to store the number of word in words list, then we use sliding window technique to solve the problem\n``` java\npublic List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> res = new ArrayList<Integer>();\n        HashMap<String, Integer> map = new HashMap<>();\n        int wordLen = words[0].length();\n        int strLen = s.length();\n        int numOfWords = words.length;\n        for(String word : words){\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        }\n        for(int slowPtr = 0; slowPtr < wordLen; slowPtr++){\n            int count = 0;\n            HashMap<String, Integer> copyMap = new HashMap<>(map);\n            for(int fastPtr = slowPtr; fastPtr <= strLen - wordLen; fastPtr += wordLen){\n                String cur = s.substring(fastPtr, fastPtr + wordLen);\n                copyMap.put(cur, copyMap.getOrDefault(cur, 0) - 1);\n                if(copyMap.get(cur) >= 0){\n                    count++;\n                }\n                int pop_start = fastPtr - numOfWords * wordLen;\n                if(pop_start >= 0){\n                    String pop_word = s.substring(pop_start, pop_start + wordLen);\n                    copyMap.put(pop_word, copyMap.getOrDefault(pop_word, 0) + 1);\n                    if(copyMap.get(pop_word) > 0)\n                        count--;\n                }\n                if(count == numOfWords){\n                    res.add(pop_start + wordLen);\n                }\n            }\n        }\n        return res;\n    }\n```\nTime Complexity: O(N*M) where n is (length of string / length of words list) and m is length of word\n\nSpace Compelxity: we use two hashMap to store, so it is O(N) where n is length of words list","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207433159","body":"#####æ€è·¯\nå®åœ¨çœ‹ä¸æ‡‚ åªèƒ½æŠ„äº† :(\n\n```java\npublic int solve(int[] nums, int k) {\n\n        int tar = 0;\n\n        for (int n : nums)\n            tar += n;\n\n        tar = Math.floorMod(tar, k);\n\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, -1);\n\n        int prefix = 0, res = nums.length;\n\n        for (int i = 0; i < nums.length; i++) {\n\n            prefix += nums[i];\n            int mod = Math.floorMod(prefix, k);\n            map.put(mod, i);\n\n            if (map.containsKey(Math.floorMod(prefix - tar, k)))\n                res = Math.min(res, i - map.get(Math.floorMod(prefix - tar, k)));\n        }\n\n        return res == nums.length ? -1 : res;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207461031","body":"#### æ€è·¯\nuse two pointer, slow pointer will update to slow.next, and fast pointer will update to fast.next.next, therefore when fast pointer reach to the end, slow pointer will point to the middle node\n\n```java\npublic ListNode middleNode(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast != null && fast.next != null){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n}\n```\nTime Complexity: O(N) where N is length of list\n\nSpace Complexity: O(1) as we didn't use additional space\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208707740","body":"##### æ€è·¯\nuse two pointer to check, left pointer will point to first character of kind, then right pointer will traverse and check if next index of character is same as the character that left pointer pointed at.\n```java\npublic int removeDuplicates(int[] nums) {\n        if (nums.length == 0) return 0;\n        int left = 0;\n        for (int right = 1; right < nums.length; right++) {\n            if (nums[left] != nums[right]) {\n                left++;\n                nums[left] = nums[right];\n            }\n        }\n        return left + 1;\n}\n```\nTime Complexity: O(N)\n\nSpace Complexity: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kernelsue":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185108946","body":"```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n\t\tLinkedList<Integer> list = new LinkedList<Integer>();\r\n    \t        int carry = 0;\r\n\t\tint i = num.length-1;\r\n    \twhile(i >= 0||k != 0){\r\n    \t\tif(k == 0 && carry == 0){\r\n    \t\t\tlist.push(num[i]);\r\n    \t\t\ti--;\r\n    \t\t\tcontinue;\r\n\t\t     }\r\n    \t\tint cur = carry + k%10;\r\n\t\tif(i >= 0)  cur += num[i];\r\n\t\tlist.push(cur%10);\r\n\t\tcarry = cur/10;\r\n\t\tk /= 10;\r\n\t\ti--;\r\n\t}\r\n    \tif(carry != 0){\r\n    \t\tlist.push(1);\r\n\t}\r\n    \treturn list;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186383932","body":"```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n    \tif(s.length() == 1)  return new int[]{0};\r\n    \tint left = 0;\r\n    \tint right = 0;\r\n    \tint temp = Integer.MAX_VALUE;\r\n    \tint[] dist = new int[s.length()];\r\n    \twhile(right < s.length()){\r\n    \t\twhile(right != s.length() && s.charAt(right) != c)  right++;\r\n    \t\twhile(left < right){\r\n    \t\t\tif(right != s.length())  dist[left] = Math.min(Math.abs(left-temp), right-left);\r\n    \t\t\telse  dist[left] = left-temp;\r\n\t\t\tleft++;\r\n\t\t}\r\n    \t\tif(right != s.length()){\r\n\t\t\tdist[left] = 0;\r\n\t\t\ttemp = left;\r\n\t\t\tright++;\r\n\t\t}\r\n\t}\r\n    \treturn dist;\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186394234","body":"```java\r\nclass CustomStack {\r\n\t     private int[] arr;\r\n\t     private int top;\r\n    public CustomStack(int maxSize) {\r\n        arr = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top != arr.length-1)\r\n            arr[++top] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top != -1){\r\n            top--;\r\n            return arr[top+1];\r\n        }else  return -1;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int i = 0;\r\n        while(k != 0 && i <= top){\r\n            arr[i++] += val;\r\n            k--;\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186949660","body":"```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n\t\tLinkedList<Character> stack = new LinkedList<Character>();\r\n\t\tLinkedList<Character> temp = new LinkedList<Character>();\r\n\t\tStringBuilder str = new StringBuilder();\r\n\t\t//æš´åŠ›æ ˆ\r\n\t\tfor(int i = 0; i < s.length(); i++){\r\n\t\t\tchar c = s.charAt(i);\r\n\t\t\tif(c >= 'a' && c <= 'z' && stack.isEmpty())  str.append(c);\r\n\t\t\telse if(c != ']')  stack.push(c);\r\n\t\t\telse{\r\n\t\t\t\twhile(stack.peek() != '[')\r\n\t\t\t\t\ttemp.push(stack.pop());\r\n\t\t\t\tstack.pop();\r\n\t\t\t\tString times = \"\";\r\n\t\t\t\twhile(!stack.isEmpty() && stack.peek() >= '0' && stack.peek() <= '9')\r\n\t\t\t\t\ttimes = stack.pop() + times;\r\n\t\t\t\tif(stack.isEmpty()){\r\n\t\t\t\t\tString t = \"\";\r\n\t\t\t\t\tfor(char ch : temp)\r\n\t\t\t\t\t\tt += ch;\r\n\t\t\t\t\tfor(int j = 0; j < Integer.valueOf(times); j++)\r\n\t\t\t\t\t\tstr.append(t);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tCollections.reverse(temp);\r\n\t\t\t\t\tfor(int j = 0; j < Integer.valueOf(times); j++)\r\n\t\t\t\t\t\tstack.addAll(0, temp);\r\n\t\t\t\t}\r\n\t\t\t\ttemp.clear();\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\treturn str.toString();\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1192632713","body":"```java\r\nclass MyQueue {\r\n\tprivate LinkedList<Integer> stack1 ;\r\n    private LinkedList<Integer> stack2 ;\r\n    //ç»´æŠ¤é˜Ÿé¦–å…ƒç´ ï¼Œè¿™æ ·å°±ä¸éœ€è¦åŒºåˆ†popå’Œpeekäº†\r\n    //é˜Ÿé¦–å…ƒç´ è¦ä¹ˆå‡ºç°åœ¨stack1æ ˆåº•ï¼Œè¦ä¹ˆå‡ºç°åœ¨stack2æ ˆé¡¶\r\n    private int front;\r\n\r\n    public MyQueue() {\r\n        stack1 = new LinkedList<Integer>();\r\n        stack2 = new LinkedList<Integer>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(stack2.isEmpty() && stack1.isEmpty())\r\n            front = x;\r\n        stack1.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if(stack2.isEmpty()){\r\n            while(!stack1.isEmpty())\r\n                stack2.push(stack1.pop());\r\n        }\r\n        int top = stack2.pop();\r\n        if(empty())  return top;\r\n\r\n        if(stack2.isEmpty()){\r\n            while(!stack1.isEmpty())\r\n                stack2.push(stack1.pop());\r\n        }\r\n        front = stack2.peek();\r\n        return top;\r\n    }\r\n    \r\n    public int peek() {\r\n        return front;\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return stack1.isEmpty() && stack2.isEmpty();\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1193091951","body":"```java\r\nclass Solution {\r\n\tpublic int maxChunksToSorted(int[] arr) {\r\n\t\tif(arr.length == 1)  return 1;\r\n\t\tif(arr.length == 2){\r\n\t\t\tif(arr[0] <= arr[1])  return 2;\r\n\t\t\telse return 1;\r\n\t\t}\r\n\r\n\t\tLinkedList<Integer> stack = new LinkedList<Integer>();\r\n\t\tfor(int i = 0; i < arr.length; i++){\r\n\t\t\tif(stack.isEmpty() || arr[i] >= stack.peek())  stack.push(arr[i]);\r\n\t\t\telse{\r\n\t\t\t\tint head = stack.pop();\r\n\t\t\t\twhile(!stack.isEmpty() && arr[i] < stack.peek())\r\n\t\t\t\t\tstack.pop();\r\n\t\t\t\tstack.push(head);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn stack.size();\r\n\t}\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1193127212","body":"```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n    \tif(head == null || head.next == null)  return head;\r\n    \tif(k == 0)  return head;\r\n\r\n    \t//é“¾è¡¨å°¾å€’æ•°ç¬¬kä¸ªæ˜¯å¤´ç»“ç‚¹ï¼Œå¿«æŒ‡é’ˆå’Œæ…¢æŒ‡é’ˆé—´çš„åˆå§‹è·ç¦»ä¸ºk-1\r\n\t\tListNode fast = head;\r\n\t\tfor(int i = 0; i < k-1; i++){\r\n\t\t\tif(fast.next != null)  fast = fast.next;\r\n\t\t\telse  fast = head;\r\n\t\t}\r\n\t\tListNode slow = head;\r\n\t\twhile(fast.next != null){\r\n\t\t\tfast = fast.next;\r\n\t\t\tslow = slow.next;\r\n\t\t}\r\n\t\tfast.next = head;\r\n\t\tfast = head;\r\n\t\twhile(fast.next != slow)\r\n\t\t\tfast = fast.next;\r\n\t\tfast.next = null;\r\n\t\treturn slow;\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1193224227","body":"```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n    \tif(head == null || head.next == null)  return head;\r\n\r\n    \tListNode temp = head.next.next;\r\n    \tListNode newHead = head.next;\r\n    \thead.next.next = head;\r\n    \thead.next = swapPairs(temp);\r\n    \treturn newHead;\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193238078","body":"```java\r\n//ç»“åˆå¿«æ…¢æŒ‡é’ˆ\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n    \t//æ’é™¤é—®é¢˜è§„æ¨¡<=2çš„æƒ…å†µ\r\n    \tif(head == null)  return null;\r\n    \tif(head.next == null)  return new TreeNode(head.val);\r\n    \tif(head.next.next == null)  return new TreeNode(head.val, null, new TreeNode(head.next.val));\r\n\r\n    \tListNode slow = head;\r\n    \tListNode fast = head.next;\r\n    \tListNode tail = null;\r\n    \twhile(fast.next != null){\r\n    \t\ttail = slow;\r\n    \t\tslow = slow.next;\r\n    \t\tif(fast.next.next != null)  fast = fast.next.next;\r\n    \t\telse fast = fast.next;\r\n\t\t}\r\n    \tif(tail != null)  tail.next = null;\r\n\r\n    \tTreeNode root = new TreeNode(slow.val);\r\n    \troot.right = sortedListToBST(slow.next);\r\n    \tslow.next = null;\r\n    \troot.left = sortedListToBST(head);\r\n\r\n    \treturn root;\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1194922683","body":"```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n    \t//å•ä¸ªç»“ç‚¹çš„æƒ…å†µ\r\n\t\tif(headA.next == null || headB.next == null){\r\n\t\t\twhile(headA.next != null)  headA = headA.next;\r\n\t\t\twhile(headB.next != null)  headB = headB.next;\r\n\t\t\tif(headA == headB)  return headA;\r\n\t\t\telse return null;\r\n\t\t}\r\n\r\n        ListNode p1 = headA;\r\n        ListNode p2 = headB;\r\n\r\n        boolean p1Flag = false;\r\n        boolean p2Flag = false;\r\n        while(p1 != p2 && (p1.next != null && p2.next != null)){\r\n        \tp1 = p1.next;\r\n        \tp2 = p2.next;\r\n\t\t\tif(p1.next == null && !p1Flag){\r\n\t\t\t\tp1 = headB;\r\n\t\t\t\tp1Flag = true;\r\n\t\t\t}\r\n\t\t\tif(p2.next == null && !p2Flag){\r\n\t\t\t\tp2 = headA;\r\n\t\t\t\tp2Flag = true;\r\n\t\t\t}\r\n\t\t}\r\n        if(p1 == p2)  return p1;\r\n        else  return null;\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194955584","body":"```java\r\n//åŸºäºä¸¤ä¸ªæ•°å­¦å…³ç³»ï¼šï¼ˆ1ï¼‰å¿«æ…¢æŒ‡é’ˆç›¸é‡æ—¶ï¼šå¿«æŒ‡é’ˆèµ°è¿‡è·ç¦»æ˜¯æ…¢æŒ‡é’ˆçš„2å€ a+b = 2(a+c)\r\n//                ï¼ˆ2ï¼‰å¿«æŒ‡é’ˆçš„ç¯å†…è·¯ç¨‹b æ…¢æŒ‡é’ˆç¯å†…è·¯ç¨‹c ç¯é•¿l b = k1l+x c = k2l+x\r\n// (2)ä»£å…¥ï¼ˆ1)å¾—åˆ° a+k1l+x = 2a+2k2l+2x ---> (k1-2k2)l-x = a\r\n//æ˜¾ç„¶æ•´æ•°å€ç¯é•¿å‡å»ç›¸é‡æ—¶å…¥ç¯è·ç¦»x--->å‰©ä½™ç¯é•¿ï¼Œä¹Ÿå°±æ˜¯è¯´ç›¸é‡ä¹‹åä¸€ä¸ªæŒ‡é’ˆç»§ç»­èµ°ï¼Œå¦ä¸€ä¸ªæŒ‡é’ˆä»é“¾è¡¨å¤´èµ°ï¼Œç›¸é‡ç‚¹å°±æ˜¯å…¥ç¯ç‚¹\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n    \tif(head == null || head.next == null || head.next.next == null)  return null;\r\n\r\n    \tListNode slow = head;\r\n    \tListNode fast = head.next;\r\n    \twhile(fast.next != null && fast != slow){\r\n    \t\tslow = slow.next;\r\n    \t\tif(fast.next.next != null)  fast = fast.next.next;\r\n    \t\telse  fast = fast.next;\r\n\t\t}\r\n    \tif(fast.next == null)  return null;\r\n    \t//faståº”è¯¥ä»è™šæ‹Ÿç»“ç‚¹å‡ºå‘\r\n    \tfast = new ListNode(-1);\r\n    \tfast.next = head;\r\n    \twhile(fast != slow){\r\n    \t\tfast = fast.next;\r\n    \t\tslow = slow.next;\r\n\t\t}\r\n    \treturn fast;\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1196259121","body":"```java\r\nclass LRUCache {\r\n\tprivate class ListNode{\r\n\t    private int key;\r\n\t    private int value;\r\n\t    private ListNode next;\r\n\t    private ListNode pre;\r\n\t    ListNode(int key, int value){\r\n\t        this.key = key;\r\n\t        this.value = value;\r\n        }\r\n    }\r\n\r\n    private HashMap<Integer, ListNode> map;\r\n\tprivate ListNode head;\r\n\tprivate ListNode tail;\r\n\tprivate int capacity;\r\n\r\n    public LRUCache(int capacity) {\r\n        this.capacity = capacity;\r\n        map = new HashMap<Integer, ListNode>();\r\n    }\r\n    \r\n    public int get(int key) {\r\n       ListNode x = map.get(key);\r\n       if(x == null)  return -1;\r\n\r\n       if(x.next != null){\r\n           if(x.pre != null)  x.pre.next = x.next;\r\n           else  head = x.next;\r\n\r\n           x.next.pre = x.pre;\r\n           tail.next = x;\r\n           x.pre = tail;\r\n           x.next = null;\r\n           tail = x;\r\n       }\r\n       return x.value;\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        ListNode x = map.get(key);\r\n        if(x == null && map.size() == capacity){\r\n            map.remove(head.key);\r\n            if(head.next == null){\r\n                head = null;\r\n                tail = null;\r\n            }else{\r\n                head.next.pre = null;\r\n                head = head.next;\r\n            }\r\n        }\r\n\r\n        if(x != null){\r\n            x.value = value;\r\n            if(x.next != null){\r\n                if(x.pre != null)  x.pre.next = x.next;\r\n                else  head = x.next;\r\n\r\n                x.next.pre = x.pre;\r\n                tail.next = x;\r\n                x.pre = tail;\r\n                x.next = null;\r\n                tail = x;\r\n            }\r\n        }else{\r\n            x = new ListNode(key, value);\r\n            if(map.isEmpty()){\r\n                head = x;\r\n                tail = x;\r\n            }else{\r\n                tail.next = x;\r\n                x.pre = tail;\r\n                tail = x;\r\n            }\r\n        }\r\n        map.put(key, x);\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1197893010","body":"```java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n    \tif(root == null)  return 0;\r\n    \treturn 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197916693","body":"```java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n    \tif(p == null || q == null)  return (p == null)&&(q == null);\r\n    \tif(((p.left == null) && (q.left != null))||((p.left != null) && (q.left == null)))  return false;\r\n\t\tif(((p.right == null) && (q.right != null))||((p.right != null) && (q.right == null)))  return false;\r\n\t\tif((p.left == null) && (p.right == null) && (q.left == null) && (q.right == null))  return p.val == q.val;\r\n\r\n\t\treturn p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198801907","body":"```java\r\nclass Solution {\r\n    public int sumNumbers(TreeNode root) {\r\n    \treturn  search(root, 0);\r\n    }\r\n    private int search(TreeNode x, int num){\r\n    \tint temp = num*10+x.val;\r\n    \tif(x.left == null && x.right == null)  return temp;\r\n\r\n    \tif(x.left == null)  return search(x.right, temp);\r\n    \telse if(x.right == null)  return search(x.left, temp);\r\n    \telse  return search(x.left, temp) + search(x.right, temp);\r\n\t}\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200062358","body":"```java\r\nclass Solution {\r\n    public int findBottomLeftValue(TreeNode root) {\r\n    \treturn search(root)[1];\r\n    }\r\n    private int[] search(TreeNode x){\r\n    \tif(x.left == null && x.right == null)  return new int[]{1, x.val};\r\n\r\n    \tint leftInfo[] = {0};\r\n    \tint rightInfo[] = {0};\r\n    \tif(x.left != null) leftInfo = search(x.left);\r\n    \tif(x.right != null)  rightInfo = search(x.right);\r\n    \tif(rightInfo[0] > leftInfo[0])  return new int[]{rightInfo[0]+1, rightInfo[1]};\r\n    \telse  return new int[]{leftInfo[0]+1, leftInfo[1]};\r\n\t}\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200378084","body":"```java\r\npublic class Codec {\r\n    private class MyNum{\r\n        private int n;\r\n        public MyNum(int n){\r\n            this.n = n;\r\n        }\r\n    }\r\n\r\n    // Encodes a tree to a single string.\r\n    public String serialize(TreeNode root) {\r\n        if(root == null)  return \"\";\r\n\r\n        StringBuilder str = new StringBuilder();\r\n        traverse(root, str);\r\n        return str.toString();\r\n    }\r\n    private void traverse(TreeNode x, StringBuilder str){\r\n       if(x == null)  return;\r\n\r\n       str.append(x.val);\r\n       if(x.left == null)  str.append(\"L\");\r\n       if(x.right == null)  str.append(\"R\");\r\n        str.append(\" \");\r\n\r\n        traverse(x.left, str);\r\n        traverse(x.right, str);\r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    public TreeNode deserialize(String data) {\r\n        if(data == \"\")  return null;\r\n        return buildTree(data, new MyNum(0));\r\n    }\r\n    private TreeNode buildTree(String data, MyNum index){\r\n        if(index.n == data.length())  return null;\r\n\r\n        int j = index.n;\r\n        while(data.charAt(j) != ' ')  j++;\r\n        String s = data.substring(index.n, j);\r\n        index.n = j+1;\r\n        TreeNode x;\r\n\r\n        if(s.endsWith(\"LR\"))  x = new TreeNode(Integer.parseInt(s.substring(0, s.length()-2)));\r\n        else if(s.endsWith(\"R\")){\r\n            x = new TreeNode(Integer.parseInt(s.substring(0, s.length()-1)));\r\n            x.left = buildTree(data, index);\r\n        }\r\n        else if(s.endsWith(\"L\")){\r\n            x = new TreeNode(Integer.parseInt(s.substring(0, s.length()-1)));\r\n            x.right = buildTree(data, index);\r\n        }\r\n        else{\r\n            x = new TreeNode(Integer.parseInt(s));\r\n            x.left = buildTree(data, index);\r\n            x.right = buildTree(data, index);\r\n        }\r\n        return x;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200865534","body":"```java\r\nclass Solution {\r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n\t\tList<List<Integer>> res = new ArrayList<>();\r\n    \tif(root.left == null && root.right == null){\r\n    \t\tList<Integer> list = new ArrayList<>();\r\n    \t\tlist.add(root.val);\r\n\t\t\tres.add(list);\r\n\t\t\treturn res;\r\n\t\t}\r\n    \tMap<Integer, Map<TreeNode, Integer>> maps = new HashMap<>();\r\n    \tDFSearch(root, maps, 0, 0);\r\n\t\tmaps.keySet().stream().sorted().forEachOrdered(e -> res.add(mySort(maps.get(e))));\r\n\t\treturn res;\r\n    }\r\n    private void DFSearch(TreeNode x, Map<Integer, Map<TreeNode, Integer>> maps, int col, int row){\r\n    \tif(x == null)  return;\r\n\r\n\r\n    \tif(maps.get(col) == null){\r\n    \t\tMap<TreeNode, Integer> map = new HashMap<>();\r\n    \t\tmap.put(x, row);\r\n    \t\tmaps.put(col, map);\r\n\t\t}\r\n    \telse  maps.get(col).put(x, row);\r\n    \tDFSearch(x.left, maps, col-1, row+1);\r\n    \tDFSearch(x.right, maps, col+1, row+1);\r\n\t}\r\n    private List<Integer> mySort(Map<TreeNode, Integer> m){\r\n\t\tList<Integer> list = new ArrayList<>();\r\n    \tm.entrySet().stream().sorted(new Comparator<Map.Entry<TreeNode, Integer>>() {\r\n\t\t\t@Override\r\n\t\t\tpublic int compare(Map.Entry<TreeNode, Integer> o1, Map.Entry<TreeNode, Integer> o2) {\r\n\t\t\t\tif(o1.getValue().compareTo(o2.getValue()) == 0)  return o1.getKey().val - o2.getKey().val;\r\n\t\t\t\telse  return o1.getValue().compareTo(o2.getValue());\r\n\t\t\t}\r\n\t\t}).forEachOrdered(e -> list.add(e.getKey().val));\r\n    \treturn list;\r\n\t}\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201925788","body":"```java\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int target) {\r\n    \tif(nums.length == 2){\r\n    \t\tif(nums[0]+nums[1] == target)  return new int[]{0, 1};\r\n    \t\telse return new int[]{};\r\n\t\t}\r\n    \tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\r\n    \tfor(int i = 0; i < nums.length; i++){\r\n    \t\tif(map.containsKey(target-nums[i]))  return new int[]{map.get(target-nums[i]), i};\r\n    \t\telse  map.put(nums[i], i);\r\n\t\t}\r\n    \treturn new int[]{};\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203441656","body":"```java\r\nclass Solution {\r\n    public int[] topKFrequent(int[] nums, int k) {\r\n\t\tif(nums.length == 1)  return nums;\r\n\r\n\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\r\n\t\tfor(int i = 0; i < nums.length; i++)\r\n\t\t\tmap.put(nums[i], map.getOrDefault(nums[i], 0)+1);\r\n\t\tList<int[]> list = new ArrayList<>();\r\n\t\tfor(Map.Entry<Integer, Integer> e: map.entrySet())\r\n\t\t\tlist.add(new int[]{e.getKey(), e.getValue()});\r\n\t\tquick3way(list, 0, list.size()-1);\r\n\t\tint[] res = new int[k];\r\n\t\tint j = list.size()-1;\r\n\t\tfor(int i = 0 ; i < k; i++)\r\n\t\t\tres[i] = list.get(j--)[0];\r\n\t\treturn res;\r\n    }\r\n    //ä¸‰å‘åˆ‡åˆ†å¿«æ’ï¼šæ ¹æ®åˆ‡åˆ†å…ƒç´ ï¼Œåˆ†æˆ<v =v >vçš„éƒ¨åˆ†ï¼Œç„¶ååœ¨<v >véƒ¨åˆ†ç»§ç»­è°ƒç”¨quick3wayåˆ‡åˆ†ï¼Œç›´åˆ°åˆ‡åˆ†ååªå«ä¸€ä¸ªå…ƒç´ \r\n\t//åˆ‡åˆ†å®Œä¹‹å[lo, lt-1] [lt, gt] [gt+1, hi]åˆ†åˆ«è¡¨ç¤º <v =v >vçš„éƒ¨åˆ†\r\n\tprivate void quick3way(List<int[]> list, int lo, int hi){\r\n    \tif(lo >= hi)  return;\r\n\r\n    \tint v = list.get(lo)[1];\r\n    \tint lt = lo;\r\n    \tint gt = hi;\r\n    \tint i = lo+1;\r\n\r\n    \twhile(i <= gt){\r\n    \t\tif(list.get(i)[1] < v)  exch(list, lt++, i++);\r\n    \t\telse if(list.get(i)[1] > v) exch(list, i, gt--);\r\n    \t\telse  i++;\r\n\t\t}\r\n    \tquick3way(list, lo, lt-1);\r\n    \tquick3way(list, gt+1, hi);\r\n\r\n\t}\r\n\tprivate void exch(List<int[]> list, int i, int j){\r\n    \tint[] temp = list.get(i);\r\n    \tlist.set(i, list.get(j));\r\n    \tlist.set(j, temp);\r\n\t}\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204720769","body":"```java\r\nclass Solution {\r\n    public int numberOfBoomerangs(int[][] points) {\r\n    \tif(points.length < 3)  return 0;\r\n\r\n    \tMap<Integer, Integer> countMap = new HashMap<Integer, Integer>();\r\n\tMap<String, Integer> distMap = new HashMap<String, Integer>();\r\n\tint dist = 0;\r\n\tint res = 0;\r\n    \tfor(int i = 0; i < points.length; i++){\r\n    \t\tfor(int j = 0; j < points.length; j++){\r\n    \t\t\tif(j == i)  continue;\r\n    \t\t\tif(j < i)  dist = distMap.get(String.valueOf(j)+\":\"+String.valueOf(i));\r\n    \t\t\telse{\r\n    \t\t\t\tdist = (int)(Math.pow(points[i][0]-points[j][0], 2) + Math.pow(points[i][1]-points[j][1], 2));\r\n    \t\t\t\tdistMap.put(String.valueOf(i)+\":\"+String.valueOf(j), dist);\r\n\t\t\t\t}\r\n\t\t\t\tcountMap.put(dist, countMap.getOrDefault(dist, 0)+1);\r\n\t\t\t}\r\n    \t\tfor(int count : countMap.values())\r\n    \t\t\tif(count >= 2)\r\n\t\t\t\tres += count*(count-1);\r\n    \t\tcountMap.clear();\r\n\t\t}\r\n    \treturn res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1207133009","body":"```java\r\nclass Solution {\r\n    public int lengthOfLongestSubstring(String s) {\r\n    \tif(s.length() < 2)  return s.length();\r\n\r\n    \tint left = 0;\r\n    \tint right = 1;\r\n    \tint max = 0;\r\n    \tMap<Character, Integer> map = new HashMap<Character, Integer>();\r\n    \tmap.put(s.charAt(left), 0);\r\n    \twhile(s.length()-left > max && right < s.length()){\r\n    \t\tif(map.containsKey(s.charAt(right))){\r\n\t\t\t\tint temp = map.get(s.charAt(right)) + 1;\r\n\t\t\t\twhile(left < temp)\r\n\t\t\t\t     map.remove(s.charAt(left++));\r\n\t\t\t}\r\n\t\t\tmap.put(s.charAt(right), right);\r\n    \t\t        right++;\r\n\t\t\tmax = Math.max(max, right-left);\r\n\t\t}\r\n    \treturn max;\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207215980","body":"```java\r\nclass Solution {\r\n    public List<Integer> findSubstring(String s, String[] words) {\r\n    \tint single = words[0].length();\r\n\t\tList<Integer> list = new ArrayList<>();\r\n    \tif(s.length() < single)  return list;\r\n\r\n    \tMap<String, Integer> map = new HashMap<>();\r\n    \tfor(String str : words)\r\n    \t\tmap.put(str, map.getOrDefault(str, 0)+1);\r\n    \tint left = 0;\r\n    \tint right = 0;\r\n    \tfor(int i = 0; i < single; i++){\r\n    \t\tleft = i;\r\n    \t\tright= i;\r\n\t\t\tMap<String, Integer> tsMap = new HashMap<>();\r\n\t\t\twhile(right + single <= s.length()){\r\n\t\t\t\tString ts = s.substring(right, right+single);\r\n\t\t\t\tint tCount = tsMap.getOrDefault(ts, 0);\r\n\t\t\t\tint mCount = map.getOrDefault(ts, 0);\r\n\t\t\t\tif(mCount == 0){\r\n\t\t\t\t\twhile(left != right){\r\n\t\t\t\t\t\ttsMap.put(s.substring(left, left+single), tsMap.get(s.substring(left, left+single))-1);\r\n\t\t\t\t\t\tleft += single;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tleft += single;\r\n\t\t\t\t}\r\n\t\t\t\telse if(tCount < mCount)  tsMap.put(ts, tCount+1);\r\n\t\t\t\telse{\r\n\t\t\t\t\ttsMap.put(ts, tCount+1);\r\n\t\t\t\t\twhile(tsMap.getOrDefault(ts, 0) > map.getOrDefault(ts, 0)){\r\n\t\t\t\t\t\tString ls = s.substring(left, left+single);\r\n\t\t\t\t\t\ttsMap.put(ls, tsMap.get(ls)-1);\r\n\t\t\t\t\t\tleft += single;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tright += single;\r\n\t\t\t\tif(right-left == single*words.length){\r\n\t\t\t\t\tlist.add(left);\r\n\t\t\t\t\ttsMap.put(s.substring(left, left+single), tsMap.get(s.substring(left, left+single))-1);\r\n\t\t\t\t\tleft += single;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n    \treturn list;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1208863398","body":"```java\r\nclass Solution {\r\n    public int solve(int[] nums, int k) {\r\n        if(k == 1)  return 0;\r\n\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        int sum = Arrays.stream(nums).sum() % k;\r\n        int len = nums.length;\r\n        int pre = 0;\r\n        map.put(0, -1);\r\n        for(int i = 0; i < nums.length; i++){\r\n            pre += nums[i];\r\n            map.put(pre%k, i);\r\n            if(map.containsKey((pre-sum)%k)){\r\n                len = Math.min(len, i-map.get((pre-sum)%k));\r\n            }\r\n        }\r\n        len = len == nums.length? -1:len;\r\n        return len;\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208871094","body":"```java\r\nclass Solution {\r\n    public ListNode middleNode(ListNode head) {\r\n    \tif(head.next == null)  return head;\r\n\r\n    \tListNode slow = head;\r\n    \tListNode fast = head.next;\r\n    \tboolean flag = false;\r\n    \twhile(fast.next != null){\r\n    \t\tslow = slow.next;\r\n\t\t\tif(fast.next.next != null)  fast = fast.next.next;\r\n\t\t\telse{\r\n\t\t\t\tfast = fast.next;\r\n\t\t\t\tflag = true;\r\n\t\t\t}\r\n\t\t}\r\n    \tif(flag)  return slow;\r\n    \telse  return slow.next;\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208878450","body":"```java\r\nclass Solution {\r\n    public int removeDuplicates(int[] nums) {\r\n    \tif(nums.length == 1)  return 1;\r\n    \tif(nums.length == 2){\r\n    \t\tif(nums[0] == nums[1])  return 1;\r\n    \t\telse  return 2;\r\n\t\t}\r\n    \tint i = 1;\r\n    \tfor(int j = 0; j < nums.length-1; j++){\r\n    \t\tif(nums[j+1] != nums[j]){\r\n    \t\t\tnums[i++] = nums[j+1];\r\n\t\t\t}\r\n\t\t}\r\n    \treturn i;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erikahuang":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185110660","body":"```\r\nclass Solution:\r\n    def listsum1(self, a: list[int], k: int) -> list[int]:\r\n        # æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦éƒ½ä¸ºO(n)\r\n        carry = 0\r\n        n = max(len(a), len(str(k))+1\r\n        res = [0] * n\r\n        a = [0] * (n-len(a)) + a\r\n\r\n        for i in range(n-1, -1, -1):\r\n            res[i] = a[i] + k % 10 + carry\r\n            carry = res[i] // 10\r\n            res[i] = res[i] % 10\r\n            k = k // 10\r\n\r\n        return res[1:] if res[0] == 0 else res\r\n\r\n    def listsum2(self, a: list[int], k: int) -> list[int]:\r\n        a = \"\".join(map(str,a))\r\n        res = int(a) + k\r\n        return list(map(int, str(res)))\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186078578","body":"## æ€è·¯\r\n\r\n> ä¸‰æŒ‡é’ˆï¼šslowæŒ‡é’ˆæŒ‡å‘ç›®å‰çš„å­—ç¬¦ä½ç½®ï¼Œfast1å’Œfast2æŒ‡å‘ç¦»s[solw]æœ€è¿‘çš„ä¸¤ä¸ª'e'çš„ä½ç½®ã€‚\r\n\r\n##ä»£ç \r\n\r\n```python\r\n#ä»£ç \r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        from collections import defaultdict\r\n        s = list(s)\r\n        distance = [0]*len(s)\r\n        slow = fast1 = 0\r\n        fast2 = float(\"inf\")\r\n        while slow < len(s):\r\n            while fast1 < len(s) and s[fast1] != c:\r\n                fast1 +=1\r\n            while slow < len(s) and slow <= fast1:\r\n                if fast1 < len(s):\r\n                    distance[slow] = min(abs(fast1-slow), abs(fast2-slow))\r\n                    slow +=1\r\n                else:\r\n                    distance[slow] = abs(fast2-slow)\r\n                    slow +=1\r\n            fast2 = fast1\r\n            fast1 +=1\r\n        return distance\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n> + æ—¶é—´å¤æ‚åº¦: O(n)\r\n> + ç©ºé—´å¤æ‚åº¦:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186370986","body":"## æ€è·¯\r\n\r\n> ç”¨listå®ç°æ ˆ\r\n\r\n##ä»£ç \r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        return self.stack.pop() if self.stack else -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, len(self.stack))):\r\n            self.stack[i] +=val\r\n\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n> + æ—¶é—´å¤æ‚åº¦: push-O(1);pop-O(1);inc-O(n)\r\n> + ç©ºé—´å¤æ‚åº¦:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186688323","body":"## æ€è·¯\r\n\r\n> \"åœ¨æ ˆé‡Œé¢æ¯æ¬¡å­˜å‚¨ä¸¤éƒ¨åˆ†ä¿¡æ¯ï¼šå·¦æ‹¬å·å‰çš„å­—ç¬¦ä¸², å·¦æ‹¬å·å‰çš„æ•°å­—, æ¯”å¦‚abc3[def], å½“é‡åˆ°ç¬¬ä¸€ä¸ªå·¦æ‹¬å·çš„æ—¶å€™ï¼Œå‹å…¥æ ˆä¸­çš„æ˜¯(\"abc\", 3), ç„¶åéå†æ‹¬å·é‡Œé¢çš„å­—ç¬¦ä¸²def, å½“é‡åˆ°å³æ‹¬å·çš„æ—¶å€™, ä»æ ˆé‡Œé¢å¼¹å‡ºä¸€ä¸ªå…ƒç´ (s1, n1), å¾—åˆ°æ–°çš„å­—ç¬¦ä¸²ä¸ºs1+n1*\"def\", ä¹Ÿå°±æ˜¯abcdefdefdefã€‚å¯¹äºæ‹¬å·é‡Œé¢åµŒå¥—çš„æƒ…å†µä¹Ÿæ˜¯åŒæ ·å¤„ç†æ–¹å¼ã€‚\"\r\n>å·¦æ‹¬å·è§¦å‘å‹æ ˆï¼Œå³æ‹¬å·è§¦å‘å¼¹å‡ºã€‚\r\n\r\n##ä»£ç \r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = deque()\r\n        cnt = 0\r\n        string = ''\r\n\r\n        for char in s:\r\n            if char.isdigit():\r\n                cnt = int(char) + cnt*10\r\n                continue\r\n            elif char == '[':\r\n                stack.append((string, cnt))\r\n                string = ''\r\n                cnt = 0\r\n            elif char == ']':\r\n                tmp = stack.pop()\r\n                string = tmp[0] + tmp[1]*string\r\n            else:\r\n                string +=char\r\n\r\n        return string\r\n\r\n\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n> + æ—¶é—´å¤æ‚åº¦: O(n)\r\n> + ç©ºé—´å¤æ‚åº¦:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188677459","body":"## æ€è·¯\r\n\r\n> + åŒæ ˆ\r\n\r\n##ä»£ç \r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack_in = []\r\n        self.stack_out = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack_in.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.empty():\r\n            return None\r\n\r\n        if self.stack_out:\r\n            return self.stack_out.pop()\r\n        else:\r\n            for i in range(len(self.stack_in)):\r\n                self.stack_out.append(self.stack_in.pop())\r\n            return self.stack_out.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        ans = self.pop()\r\n        self.stack_out.append(ans) # popå®Œéœ€è¦è¡¥å›å»æ‰èƒ½ä¿æŒæ ˆå†…å…ƒç´ ä¸å˜\r\n        return ans\r\n\r\n\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return not (self.stack_in or self.stack_out)\r\n\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n> + æ—¶é—´å¤æ‚åº¦: O(n)\r\n> + ç©ºé—´å¤æ‚åº¦: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189785879","body":"### [æ€è·¯]\r\n>+ å•è°ƒæ ˆ\r\n\r\n### ä»£ç \r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n\r\n        for i in range(len(arr)):\r\n    \r\n            if stack and stack[-1] > arr[i]: # arr[i] å°äºæ ˆé¡¶å…ƒç´ è¯´æ˜ä¼šæ”¹å˜å‰é¢çš„æ•°ç»„æ’åº\r\n                head = stack.pop() \r\n                #å‚¨å­˜å½“å‰çš„æ ˆé¡¶ï¼Œä»¥æ–¹ä¾¿åç»­å‹æ ˆï¼Œå› ä¸ºè¯¥æ ˆé¡¶ä»æ˜¯ç›®å‰æ’åºå—çš„æœ€å¤§å€¼\r\n                while stack and stack[-1] > arr[i]:\r\n                    stack.pop() # å»æ‰ä¸èƒ½æˆä¸ºæ’åºå—æœ€å¤§å€¼çš„å…ƒç´ \r\n                stack.append(head)\r\n            else:\r\n                stack.append(arr[i])\r\n        \r\n        return len(stack)\r\n```\r\n\r\n### å¤æ‚åº¦\r\n>+æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n>+ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191019155","body":"## æ€è·¯\r\n\r\n> + æ‰¾åˆ°é“¾è¡¨å°¾å·´å’Œé“¾è¡¨é•¿åº¦ï¼Œå½¢æˆç¯é“¾æ¡ï¼Œå†æ‰¾åˆ°æ–°é“¾è¡¨å¤´ï¼Œæ–­å¼€é“¾è¡¨ã€‚\r\n\r\n##ä»£ç \r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n        \r\n        start = head\r\n        end = head\r\n        cnt = 1 # è®¡ç®—é“¾è¡¨é•¿åº¦\r\n\r\n        while end.next:\r\n            end = end.next\r\n            cnt += 1\r\n        \r\n        end.next = head\r\n\r\n        pos = cnt - k%cnt # ä»é“¾è¡¨å¤´å‘åç§»åŠ¨çš„æ­¥æ•°ï¼Œåˆ°è¾¾æ–°é“¾è¡¨å¤´\r\n\r\n        while pos > 1:\r\n            start = start.next\r\n            pos -= 1\r\n\r\n        head = start.next\r\n        start.next = None\r\n\r\n        return head\r\n\r\n\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n> + æ—¶é—´å¤æ‚åº¦: O(n)\r\n> + ç©ºé—´å¤æ‚åº¦:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192324679","body":"## æ€è·¯\r\n\r\n> + pre, cur, postä¸‰ä¸ªèŠ‚ç‚¹è¿›è¡Œæ“ä½œï¼Œæ¯æ¬¡äº¤æ¢åpreåç§»è‡³postèŠ‚ç‚¹ç»§ç»­äº¤æ¢ã€‚\r\n\r\n##ä»£ç \r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        dummy_head = ListNode(next = head)\r\n        pre = dummy_head\r\n        \r\n        while pre.next and pre.next.next:\r\n            cur = pre.next\r\n            post = pre.next.next\r\n\r\n            pre.next = post\r\n            cur.next = post.next\r\n            post.next = cur\r\n\r\n            pre = pre.next.next\r\n        return dummy_head.next\r\n\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n> + æ—¶é—´å¤æ‚åº¦: O(n)\r\n> + ç©ºé—´å¤æ‚åº¦:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193116800","body":"```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        return self.helper(head,None)\r\n\r\n    def helper(self,head,tail):\r\n        if head==tail:\r\n            return\r\n        slow=head\r\n        fast=head\r\n        while fast!=tail and fast.next!=tail:\r\n            slow=slow.next\r\n            fast=fast.next.next\r\n        root=TreeNode(slow.val)\r\n        root.left=self.helper(head,slow)\r\n        root.right=self.helper(slow.next,tail)\r\n        return root\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193235372","body":"## æ€è·¯\r\n\r\n> + æœ€å…³é”®çš„ç‚¹åœ¨äºé˜Ÿå°¾å¯¹é½ï¼Œç„¶åä»çŸ­é“¾è¡¨çš„å¤´å¼€å§‹æ¯”è¾ƒã€‚\r\n\r\n##ä»£ç \r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        cnt_A = 0\r\n        cnt_B = 0\r\n\r\n        curA = headA\r\n        curB = headB\r\n\r\n        while curA != None:\r\n            cnt_A +=1\r\n            curA = curA.next\r\n        \r\n        while curB != None:\r\n            cnt_B +=1\r\n            curB = curB.next\r\n\r\n        curA = headA\r\n        curB = headB\r\n\r\n        if cnt_A < cnt_B:\r\n            curA, curB = headB, headA\r\n            cnt_A, cnt_B = cnt_B, cnt_A\r\n            \r\n        while cnt_A - cnt_B > 0:\r\n            cnt_A -=1\r\n            curA = curA.next\r\n            \r\n        while curA != None:\r\n            if(curA == curB):\r\n                return curA\r\n            else:\r\n                curA = curA.next\r\n                curB = curB.next\r\n\r\n        return None\r\n\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n> + æ—¶é—´å¤æ‚åº¦: O(n+m)\r\n> + ç©ºé—´å¤æ‚åº¦:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194001596","body":"## æ€è·¯\r\n\r\n> + è®¾ä»headéœ€è¦èµ° a æ­¥åˆ°è¾¾ç¯çš„å…¥å£ï¼Œå¦‚æœç¯å­˜åœ¨çš„è¯ï¼Œå†èµ° b æ­¥å¯ä»¥å†æ¬¡åˆ°è¾¾è¯¥å…¥å£ï¼ˆå³ç¯çš„é•¿åº¦ä¸ºb)\r\n> + å¦‚æœå­˜åœ¨ç¯çš„è¯ï¼Œå¿«æŒ‡é’ˆ fast å’Œæ…¢æŒ‡é’ˆslow ï¼ˆç›¸å¯¹é€Ÿåº¦ä¸º1 -- å› cæ­¤å¿«æ…¢æŒ‡é’ˆå¿…ç„¶ä¼šç›¸é‡ï¼‰å¿…ç„¶ä¼šç›¸é‡ï¼Œä¸”æ­¤æ—¶slowèµ°çš„è·¯é•¿ä¸º a + xï¼Œå½“å¿«æ…¢æŒ‡é’ˆç›¸é‡æ—¶ï¼Œå¿«æŒ‡é’ˆå·²ç»è‡³å°‘èµ°å®Œä¸€åœˆç¯äº†ï¼Œä¸å¦¨è®¾ç›¸é‡æ—¶èµ°äº†å®Œæ•´çš„måœˆ(m >= 1)ï¼Œæœ‰ï¼š\r\n        å¿«æŒ‡é’ˆèµ°çš„è·¯é•¿ä¸º a + mb + x\r\n        æ…¢æŒ‡é’ˆèµ°çš„è·¯é•¿ä¸º a + x\r\n> + ç”±äºå¿«æŒ‡é’ˆfast èµ°çš„è·¯é•¿å§‹ç»ˆæ˜¯æ…¢æŒ‡é’ˆçš„ 2å€ï¼Œæ‰€ä»¥ï¼ša + mb + x = 2(a + x)\r\n\r\n\r\n## ä»£ç \r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        fast = head\r\n        slow = head\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            if slow == fast:\r\n                p = head\r\n                q = slow\r\n\r\n                while p!=q:\r\n                    p = p.next\r\n                    q = q.next\r\n                return p\r\n\r\n        return None\r\n\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n> + æ—¶é—´å¤æ‚åº¦: O(n)\r\n> + ç©ºé—´å¤æ‚åº¦: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195581523","body":"```python\r\nclass ListNode:\r\n    def __init__(self, key=None, value=None):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = None\r\n        self.next = None\r\n\r\n\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.hashmap = {}\r\n        # æ–°å»ºä¸¤ä¸ªèŠ‚ç‚¹ head å’Œ tail\r\n        self.head = ListNode()\r\n        self.tail = ListNode()\r\n        # åˆå§‹åŒ–é“¾è¡¨ä¸º head <-> tail\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n\r\n    # å› ä¸ºgetä¸putæ“ä½œéƒ½å¯èƒ½éœ€è¦å°†åŒå‘é“¾è¡¨ä¸­çš„æŸä¸ªèŠ‚ç‚¹ç§»åˆ°æœ«å°¾ï¼Œæ‰€ä»¥å®šä¹‰ä¸€ä¸ªæ–¹æ³•\r\n    def move_node_to_tail(self, key):\r\n            # å…ˆå°†å“ˆå¸Œè¡¨keyæŒ‡å‘çš„èŠ‚ç‚¹æ‹å‡ºæ¥ï¼Œä¸ºäº†ç®€æ´èµ·ånode\r\n            #      hashmap[key]                               hashmap[key]\r\n            #           |                                          |\r\n            #           V              -->                         V\r\n            # prev <-> node <-> next         pre <-> next   ...   node\r\n            node = self.hashmap[key]\r\n            node.prev.next = node.next\r\n            node.next.prev = node.prev\r\n            # ä¹‹åå°†nodeæ’å…¥åˆ°å°¾èŠ‚ç‚¹å‰\r\n            #                 hashmap[key]                 hashmap[key]\r\n            #                      |                            |\r\n            #                      V        -->                 V\r\n            # prev <-> tail  ...  node                prev <-> node <-> tail\r\n            node.prev = self.tail.prev\r\n            node.next = self.tail\r\n            self.tail.prev.next = node\r\n            self.tail.prev = node\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.hashmap:\r\n            # å¦‚æœå·²ç»åœ¨é“¾è¡¨ä¸­äº†ä¹…æŠŠå®ƒç§»åˆ°æœ«å°¾ï¼ˆå˜æˆæœ€æ–°è®¿é—®çš„ï¼‰\r\n            self.move_node_to_tail(key)\r\n        res = self.hashmap.get(key, -1)\r\n        if res == -1:\r\n            return res\r\n        else:\r\n            return res.value\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.hashmap:\r\n            # å¦‚æœkeyæœ¬èº«å·²ç»åœ¨å“ˆå¸Œè¡¨ä¸­äº†å°±ä¸éœ€è¦åœ¨é“¾è¡¨ä¸­åŠ å…¥æ–°çš„èŠ‚ç‚¹\r\n            # ä½†æ˜¯éœ€è¦æ›´æ–°å­—å…¸è¯¥å€¼å¯¹åº”èŠ‚ç‚¹çš„value\r\n            self.hashmap[key].value = value\r\n            # ä¹‹åå°†è¯¥èŠ‚ç‚¹ç§»åˆ°æœ«å°¾\r\n            self.move_node_to_tail(key)\r\n        else:\r\n            if len(self.hashmap) == self.capacity:\r\n                # å»æ‰å“ˆå¸Œè¡¨å¯¹åº”é¡¹\r\n                self.hashmap.pop(self.head.next.key)\r\n                # å»æ‰æœ€ä¹…æ²¡æœ‰è¢«è®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼Œå³å¤´èŠ‚ç‚¹ä¹‹åçš„èŠ‚ç‚¹\r\n                self.head.next = self.head.next.next\r\n                self.head.next.prev = self.head\r\n            # å¦‚æœä¸åœ¨çš„è¯å°±æ’å…¥åˆ°å°¾èŠ‚ç‚¹å‰\r\n            new = ListNode(key, value)\r\n            self.hashmap[key] = new\r\n            new.prev = self.tail.prev\r\n            new.next = self.tail\r\n            self.tail.prev.next = new\r\n            self.tail.prev = new\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kuang-mou":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185111126","body":"### æ€è·¯\r\nç”±äºkçš„ä½æ•°æ˜¯å°äºç­‰äºAæ•°ç»„ä½æ•°çš„ï¼Œç›´æ¥åˆ©ç”¨pythonè½¬åŒ–ä¸ºå­—ç¬¦è¿›è¡Œç›¸åŠ \r\n### ä»£ç \r\n```class Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        s =  int(''.join(map(str,num))) + k\r\n        return [int(i) for i in str(s)]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186196104","body":"```\nclass Solution:\n    def shortestToChar(self, S: str, C: str) -> List[int]:\n        \n        return [min(abs(i- j)  for j in [i for i in range(len(S)) if S[i] == C]) for i in range(len(S))]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186545431","body":"```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.length = 0\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if self.length < self.maxSize:\n            self.length += 1\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.length is 0:\n            return -1\n        else:\n            self.length -= 1\n            return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,self.length)):\n            self.stack[i] += val\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iloveqier":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185112285","body":"```\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n    let narr = []\r\n    // kä½œä¸ºæ¯ä¸€é¡¹éƒ½åŠ çš„ä¸œè¥¿ï¼Œä½™æ•°æ˜¯è¦å­˜ä¸‹çš„å€¼ï¼Œé™¤æ•°æ˜¯ä¸‹ä¸€æ¬¡è¦åŠ çš„ä¸œè¥¿\r\n    for (let i = num.length - 1; i > -1 || k > 0; i--, k = Math.floor(k / 10)) {\r\n        // é˜²æ­¢numéå†åˆ°æœ€å¤´éƒ¨çš„æ—¶å€™ï¼Œkä¾ç„¶æœ‰å€¼,éœ€è¦ç»§ç»­ä½¿ç”¨\r\n        if (i > -1) {\r\n            k = k + num[i]\r\n        }\r\n        narr.unshift(k % 10)\r\n    }\r\n    return narr\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186096624","body":"```js\nvar shortestToChar = function (s, c) {\n    let res = Array(s.length).fill(Infinity);\n    let cindexs = []\n   for(let i=0;i<s.length;i++){\n       if(s[i]===c) {\n           cindexs.push(i)\n           \n       }\n   }\n   for(let i=0;i<s.length;i++){\n       if(s[i]===c) {\n           res.push(0)\n           continue\n       }\n       for(let ci of cindexs) {\n           let distance = Math.abs(ci-i)\n           //å½“å‘ç°distanceå¼€å§‹å¤§äºå½“å‰res[i]äº†ï¼Œè¯´æ˜res[i]å·²ç»æ˜¯æœ€å°è·ç¦»äº†ï¼Œåè¾¹åªä¼šè¶Šæ¥è¶Šå¤§\n           if(distance>res[i]) break\n           res[i] = distance\n       }\n\n   }\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186360684","body":"```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n    this.maxSize = maxSize\n    this.curSize = 0\n    this.stack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n    if (this.curSize < this.maxSize) {\n        this.stack.push(x)\n        this.curSize++\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n    if (this.curSize === 0) {\n        return -1\n    }\n    this.curSize--\n    return this.stack.pop()\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n    this.stack.map((item,i)=>{\n        if(i<k){\n            this.stack[i] += val\n        }\n    })\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186911027","body":"```js\nvar decodeString = function (s) {\n    let stack = []\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] == ']') {\n            let repeatStr = ''\n            let repeatCount = ''\n            while (stack && stack[stack.length - 1] != '[') {\n                repeatStr = stack.pop() +repeatStr\n            }\n            stack.pop()\n            while (stack && /\\d/.test(stack[stack.length - 1])) {\n                repeatCount = stack.pop() + repeatCount\n            }\n            repeatStr = repeatStr.repeat(repeatCount * 1);\n            stack.push(repeatStr)\n        } else {\n            stack.push(s[i])\n        }\n    }\n    return stack.join('')\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188822222","body":"```js\n\nvar MyQueue = function () {\n    this.inStack = []\n    this.outStack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n    this.inStack.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n    if (!this.outStack.length) {\n        this.in2out()\n    }\n    return this.outStack.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n    if (!this.outStack.length) {\n        this.in2out()\n    }\n    return this.outStack[this.outStack.length-1]\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n    return !this.inStack.length && !this.outStack.length\n};\n\nMyQueue.prototype.in2out = function () {\n    while (this.inStack.length) {\n        this.outStack.push(this.inStack.pop())\n    }\n};\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189717710","body":"```js\nvar maxChunksToSorted = function (arr) {\n    let stack = []\n    for (let i = 0; i < arr.length; i++) {\n        let ac = arr[i]\n        let stc = stack[stack.length - 1]\n        if (stack.length && stc > ac) {\n            while (stack.length && stack[stack.length-1] > ac) stack.pop()\n            stack.push(stc)\n        } else {\n            stack.push(ac)\n        }\n    }\n    return stack.length\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190973981","body":"```js\nvar rotateRight = function (head, k) {\n    if(!head || !head.next) return head\n    let count = 0,now = head\n    while (now) {\n        now = now.next\n        count++\n    }\n    k = k % count\n    let slow = (fast = head)\n    while (fast.next) {\n        if (k-- <= 0) {\n            slow = slow.next\n        }\n        fast = fast.next\n    }\n    fast.next = head\n    let res = slow.next\n    slow.next = null\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192108622","body":"```js\nvar swapPairs = function(head) {\n    if(!head || !head.next) return head\n    let res = head.next\n    let preNode =new ListNode()\n    preNode.next = head\n    let now = head\n    while(now&&now.next) {\n        let nextNode = now.next\n        let lastNode = nextNode.next\n\n        now.next = lastNode\n        nextNode.next = now\n        preNode.next = nextNode\n\n        preNode = now\n        now = lastNode\n\n    }\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193068780","body":"```js\nvar sortedListToBST = function(head) {\n    if(!head) return head\n    return dfs(head,null)\n};\nfunction dfs(head,tail) {\n    if(head === tail) return null\n    let fast = head\n    let slow = head\n\n    while(fast !== tail && fast.next !== tail) {\n        fast = fast.next.next\n        slow = slow.next\n    }\n\n    let root = new TreeNode(slow.val)\n    root.left = dfs(head,slow)\n    root.right = dfs(slow.next,tail)\n\n    return root\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193251694","body":"```js\nvar getIntersectionNode = function(A, B) {\n    let data = new Set()\n    while(A){\n        data.add(A)\n        A = A.next\n    }\n    while(B) {\n        if(data.has(B)) return B\n        B = B.next\n    }\n    return null\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193476826","body":"```js\nvar detectCycle = function(head) {\n    let data = new Set()\n    while(head) {\n        if(data.has(head)) return head\n        data.add(head)\n        head = head.next\n    }\n    return null\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194886350","body":"```js\nclass DoubleLinkedListNode {\n    constructor(key, value) {\n        this.key = key\n        this.value = value\n        this.prev = null\n        this.next = null\n    }\n}\n\nclass LRUCache {\n    constructor(capacity) {\n        this.capacity = capacity\n        this.usedSpace = 0\n        // Mappings of key->node.\n        this.hashmap = {}\n        this.dummyHead = new DoubleLinkedListNode(null, null)\n        this.dummyTail = new DoubleLinkedListNode(null, null)\n        this.dummyHead.next = this.dummyTail\n        this.dummyTail.prev = this.dummyHead\n    }\n\n    _isFull() {\n        return this.usedSpace === this.capacity\n    }\n\n    _removeNode(node) {\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        node.prev = null\n        node.next = null\n        return node\n    }\n\n    _addToHead(node) {\n        const head = this.dummyHead.next\n        node.next = head\n        head.prev = node\n        node.prev = this.dummyHead\n        this.dummyHead.next = node\n    }\n\n    get(key) {\n        if (key in this.hashmap) {\n            const node = this.hashmap[key]\n            this._addToHead(this._removeNode(node))\n            return node.value\n        }\n        else {\n            return -1\n        }\n    }\n\n    put(key, value) {\n        if (key in this.hashmap) {\n            // If key exists, update the corresponding node and move it to the head.\n            const node = this.hashmap[key]\n            node.value = value\n            this._addToHead(this._removeNode(node))\n        }\n        else {\n        // If it's a new key.\n            if (this._isFull()) {\n                // If the cache is full, remove the tail node.\n                const node = this.dummyTail.prev\n                delete this.hashmap[node.key]\n                this._removeNode(node)\n                this.usedSpace--\n            }\n            // Create a new node and add it to the head.\n            const node = new DoubleLinkedListNode(key, value)\n            this.hashmap[key] = node\n            this._addToHead(node)\n            this.usedSpace++\n        }\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196188800","body":"```js\nvar maxDepth = function(root) {\n    if(root === null) return 0\n    return Math.max(maxDepth(root.left),maxDepth(root.right))+1\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197560900","body":"```js\nvar isSameTree = function (p, q) {\n    if (!p || !q) {\n        return !p && !q\n    }\n    return (\n        p.val === q.val && isSameTree(p.left,q.left) && isSameTree(p.right,q.right)\n    )\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1200755157","body":"```js\nvar sumNumbers = function(root) {\n    let sum=0\n\n    function dfs(root,cur) {\n        if(!root) {\n            return\n        }\n        let curSum = cur*10+root.val \n        if(!root.left&&!root.right){\n            sum += curSum\n        }\n        dfs(root.left,curSum)\n        dfs(root.right,curSum)\n    }\n\n    dfs(root,0)\n    return sum\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1201070335","body":"```js\nvar findBottomLeftValue = function(root) {\n    let curLevel = [root]\n    let res = root.val\n    while(curLevel.length) {\n        let nextLevel = []\n        for(let i=0;i<curLevel.length;i++){\n            let cur = curLevel[i]\n            cur.left && nextLevel.push(cur.left)\n            cur.right && nextLevel.push(cur.right)\n        }\n        res = curLevel[0].val\n        curLevel = nextLevel\n    }\n    return res\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1201095037","body":"```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function (root) {\n    let queue = [root]\n    let res = []\n    while (queue.length) {\n        let node = queue.shift()\n        if (node) {\n            res.push(node.val)\n            queue.push(node.left)\n            queue.push(node.right)\n        } else {\n            res.push('#')\n        }\n\n    }\n    return res.join(',')\n\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function (data) {\n    if (data === '#') return null\n\n    let list = data.split(',')\n    let root = new TreeNode(list[0])\n    let queue = [root]\n    let cursor = 1\n\n    while (cursor < list.length) {\n        let node = queue.shift()\n\n        let leftVal = list[cursor]\n        let rightVal = list[cursor + 1]\n\n        if (leftVal !== '#') {\n            let lnode = new TreeNode(leftVal)\n            node.left = lnode\n            queue.push(lnode)\n        }\n        if (rightVal !== '#') {\n            let rnode = new TreeNode(rightVal)\n            node.right = rnode\n            queue.push(rnode)\n        }\n        cursor += 2\n    }\n    return root\n};\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200601281","body":"Â·Â·Â·js\nvar verticalTraversal = function (root) {\n  if (!root) return [];\n\n  // åæ ‡é›†åˆä»¥ x åæ ‡åˆ†ç»„\n  const pos = {};\n  // dfs éå†èŠ‚ç‚¹å¹¶è®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„åæ ‡\n  dfs(root, 0, 0);\n\n  // å¾—åˆ°æ‰€æœ‰èŠ‚ç‚¹åæ ‡åï¼Œå…ˆæŒ‰ x åæ ‡å‡åºæ’åº\n  let sorted = Object.keys(pos)\n    .sort((a, b) => +a - +b)\n    .map((key) => pos[key]);\n\n  // å†ç»™ x åæ ‡ç›¸åŒçš„æ¯ç»„èŠ‚ç‚¹åæ ‡åˆ†åˆ«æ’åº\n  sorted = sorted.map((g) => {\n    g.sort((a, b) => {\n      // y åæ ‡ç›¸åŒçš„ï¼ŒæŒ‰èŠ‚ç‚¹å€¼å‡åºæ’\n      if (a[0] === b[0]) return a[1] - b[1];\n      // å¦åˆ™ï¼ŒæŒ‰ y åæ ‡é™åºæ’\n      else return b[0] - a[0];\n    });\n    // æŠŠ y åæ ‡å»æ‰ï¼Œè¿”å›èŠ‚ç‚¹å€¼\n    return g.map((el) => el[1]);\n  });\n\n  return sorted;\n\n  // *********************************\n  function dfs(root, x, y) {\n    if (!root) return;\n\n    x in pos || (pos[x] = []);\n    // ä¿å­˜åæ ‡æ•°æ®ï¼Œæ ¼å¼æ˜¯: [y, val]\n    pos[x].push([y, root.val]);\n\n    dfs(root.left, x - 1, y - 1);\n    dfs(root.right, x + 1, y - 1);\n  }\n};\nÂ·Â·Â·","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201926852","body":"ä½¿ç”¨target-å½“å‰å€¼ å¾—åˆ°ç»“æœä½œä¸ºkey\n```js\n\nvar twoSum = function (nums, target) {\n    let map = new Map()\n    for (let i = 0; i < nums.length; i++) {\n        if (map.has(nums[i])) {\n            return [map.get(nums[i]), i]\n        }\n        map.set(target - nums[i], i)\n    }\n    return [-1, -1]\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203515145","body":"```js\nvar topKFrequent = function (nums, k) {\n  const counts = {};\n  for (let num of nums) {\n    counts[num] = (counts[num] || 0) + 1;\n  }\n  let pairs = Object.keys(counts).map((key) => [counts[key], key]);\n\n  select(0, pairs.length - 1, k);\n  return pairs.slice(0, k).map((item) => item[1]);\n\n  // å¿«é€Ÿé€‰æ‹©\n  function select(left, right, offset) {\n    if (left >= right) {\n      return;\n    }\n    const pivotIndex = partition(left, right);\n    console.log({ pairs, pivotIndex });\n    if (pivotIndex === offset) {\n      return;\n    }\n\n    if (pivotIndex <= offset) {\n      select(pivotIndex + 1, right, offset);\n    } else {\n      select(left, pivotIndex - 1);\n    }\n  }\n\n  // æ‹†åˆ†æ•°ç»„ä¸ºä¸¤ä¸ªpart\n  function partition(left, right) {\n    const [pivot] = pairs[right];\n    let cur = left;\n    let leftPartIndex = left;\n    while (cur < right) {\n      if (pairs[cur][0] > pivot) {\n        swap(leftPartIndex++, cur);\n      }\n      cur++;\n    }\n    swap(right, leftPartIndex);\n    return leftPartIndex;\n  }\n\n  function swap(x, y) {\n    const term = pairs[x];\n    pairs[x] = pairs[y];\n    pairs[y] = term;\n  }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204672203","body":"```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        n = len(points)\n        ans = 0\n        for i in range(n):\n            m = collections.defaultdict(int)\n            for j in range(n):\n                dist = abs(points[i][0] - points[j][0]) ** 2 + abs(points[i][1] - points[j][1]) ** 2\n                m[dist] += 1\n            for count in m.values():\n                ans += count * (count-1)\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206041477","body":"```js\nvar lengthOfLongestSubstring = function (s) {\n    let l = r = max = 0\n    let map = new Map()\n    while(r<s.length) {\n        let pos = map.get(s[r])\n        if(pos>=l && pos<=r) l = pos+1\n        map.set(s[r],r)\n        max = Math.max(max,r-l+1)\n        r++\n    }\n    return max\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207142014","body":"```js\nvar findSubstring = function(s, words) {\n    const res = [];\n    const m = words.length, n = words[0].length, ls = s.length;\n    for (let i = 0; i < n; i++) {\n        if (i + m * n > ls) {\n            break;\n        }\n        const differ = new Map();\n        for (let j = 0; j < m; j++) {\n            const word = s.substring(i + j * n, i + (j + 1) * n);\n            differ.set(word, (differ.get(word) || 0) + 1);\n        }\n        for (const word of words) {\n            differ.set(word, (differ.get(word) || 0) - 1);\n            if (differ.get(word) === 0) {\n                differ.delete(word);\n            }\n        }\n        for (let start = i; start < ls - m * n + 1; start += n) {\n            if (start !== i) {\n                let word = s.substring(start + (m - 1) * n, start + m * n);\n                differ.set(word, (differ.get(word) || 0) + 1);\n                if (differ.get(word) === 0) {\n                    differ.delete(word);\n                }\n                word = s.substring(start - n, start);\n                differ.set(word, (differ.get(word) || 0) - 1);\n                if (differ.get(word) === 0) {\n                    differ.delete(word);\n                }\n            }\n            if (differ.size === 0) {\n                res.push(start);\n            }\n        }\n    }\n    return res;\n};\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207326535","body":"```js\nvar floorMod = function (a, b) {\n  return ((a % b) + b) % b;\n};\nclass Solution {\n  solve(nums, k) {\n    var map = new Map();\n    map.set(0, -1);\n    var res = nums.length;\n    var target = 0;\n    var currSum = 0;\n    for (let i = 0; i < nums.length; i++) {\n      target += nums[i];\n    }\n    target = target % k;\n    for (let i = 0; i < nums.length; i++) {\n      currSum = (nums[i] + currSum) % k;\n      map.set(currSum, i);\n      var prevSum = floorMod(currSum - target, k);\n      if (map.has(prevSum)) {\n        res = Math.min(res, i - map.get(prevSum));\n      }\n    }\n    return res === nums.length ? -1 : res;\n  }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207563106","body":"```js\n\nvar middleNode = function(head) {\n    let slow = (fast = head)\n    while(fast && fast.next) {\n        slow = slow.next\n        fast = fast.next.next\n    }\n    return slow\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208939843","body":"```js\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function (nums) {\n    let r = 0, w = 0\n    while (r < nums.length) {\n        if (nums[r] !== nums[w]) {\n            w++\n            nums[w] = nums[r]\n        }\n        r++\n    }\n    return w + 1\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duke-github":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185112936","body":"## æ€è·¯\n    å°†æ•°ç»„ä»åå¾€å‰åŠ ç»™k kæ¯æ¬¡å–ä½™ä½œä¸ºç»“æœ /10å‚ä¸ä¸‹ä¸€æ¬¡è¿ç®—\n## å¤æ‚åº¦\n    æ—¶é—´å¤æ‚åº¦ O(max(n,m)) m n ä¸ºæ•°ç»„çš„é•¿åº¦ å’Œkçš„é•¿åº¦ ç©ºé—´å¤æ‚åº¦ O(n)\n## ä»£ç \n```java\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> result = new LinkedList<>();\n        for (int i = num.length - 1; i >= 0; i--) {\n            k += num[i];\n            result.addFirst(k % 10);\n            k /= 10;\n        }\n        while (k > 0) {\n            result.addFirst(k % 10);\n            k /= 10;\n        }\n        return result;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186101492","body":"## æ€è·¯ \n     ä»å‰åˆ°åä¸€æ¬¡åˆ¤æ–­cå’Œå½“å‰ä½ç½®çš„è·ç¦» å†ä»åå¾€å‰åˆ¤æ–­cå’Œå½“å‰ä½ç½®çš„è·ç¦» å–è¾ƒå°çš„å€¼ä½œä¸ºç»“æœ\n## å¤æ‚åº¦\n    æ—¶é—´å¤æ‚åº¦O(n) ç©ºé—´å¤æ‚åº¦O(n)\n## ä»£ç \n```java\n  public int[] shortestToChar(String s, char c) {\n        char[] ss= s.toCharArray();\n        int[] result = new int[ss.length];\n        int temp = 1-s.length();\n        for(int i=0;i<ss.length;i++){\n            if(c!=ss[i]){\n                result[i] = i-temp;\n            }else{\n                temp = i;\n            }\n        }\n        temp= 0;\n        for(int i=result.length-1;i>=0;i--){\n            if(c!=ss[i]){\n                result[i] = Math.min(Math.abs(temp-i),result[i]);\n            }else{\n                temp = i;\n            }\n        }\n        return result;\n    }\n  ```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186520696","body":"## æ€è·¯\n\n    ä½¿ç”¨æ•°ç»„è®°å½•æ ˆçš„æ•°æ® ä½¿ç”¨ä¸€ä¸ªä¸‹æ ‡è®°å½•æ ˆæŒ‡é’ˆå½“å‰æ‰€åœ¨çš„ä½ç½® å‡ºå…¥æ ˆçš„æ—¶å€™å¤„ç†è¿™ä¸ªæ ˆæŒ‡é’ˆ\n\n## å¤æ‚åº¦\n\n    æ—¶é—´å¤æ‚åº¦O(n) ç©ºé—´å¤æ‚åº¦O(n)\n\n## ä»£ç \n\n```java\n    class CustomStack {\n    int[] stack;\n    int len;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        len=-1;\n    }\n\n    public void push(int x) {\n        if(len+1<stack.length){\n            len++;\n            stack[len] =x;\n\n        }\n    }\n\n    public int pop() {\n        if(len<0){\n            return -1;\n        }\n        len--;\n        return stack[len+1];\n    }\n\n    public void increment(int k, int val) {\n        int limit = Math.min(k, len + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187600669","body":"## æ€è·¯\n\n    ä½¿ç”¨æ ˆè®°å½•æ•°æ® å·¦æ‹¬å·å…¥æ ˆ æœ‰æ‹¬å·å‡ºæ ˆ æ•°å­—åˆ™åŠ å€\n\n## å¤æ‚åº¦\n\n    æ—¶é—´å¤æ‚åº¦O(n) ç©ºé—´å¤æ‚åº¦O(n)\n\n## ä»£ç \n\n```java\n class Solution {\n    public String decodeString(String s) {\n        Deque<Integer> stackNumber = new LinkedList<>();\n        Deque<String> stackString = new LinkedList<>();\n        StringBuilder stringBuilder = new StringBuilder();\n        int number = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '[') {\n                stackNumber.push(number);\n                number = 0;\n                stackString.push(stringBuilder.toString());\n                stringBuilder = new StringBuilder();\n            } else if (s.charAt(i) == ']') {\n                StringBuilder temp = new StringBuilder();\n                int curr_number = stackNumber.pop();\n                for (int j = 0; j < curr_number; j++) {\n                    temp.append(stringBuilder);\n                }\n                stringBuilder = temp.insert(0, stackString.pop());\n            } else if (s.charAt(i) > 47 && s.charAt(i) < 58) {\n                number = 10 * number + (s.charAt(i) - '0');\n            } else {\n                stringBuilder.append(s.charAt(i));\n            }\n        }\n        return stringBuilder.toString();\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189219881","body":"## æ€è·¯\n\n    ä½¿ç”¨åŒæ ˆè®°å½•æ•°æ®  å‹æ ˆå­˜æ•° ç¿»è½¬æ ˆå–æ•°\n\n## å¤æ‚åº¦\n\n    æ—¶é—´å¤æ‚åº¦O(1) ç©ºé—´å¤æ‚åº¦O(n)\n\n## ä»£ç \n\n```java\nclass MyQueue {\n        //å¤´æ ˆ\n        private Stack<Integer> headStack = new Stack<>();\n        //å°¾æ ˆ\n        private Stack<Integer> tailStack = new Stack<>();\n\n        public MyQueue() {\n        }\n\n        public void push(int x) {\n\n            headStack.push(x);\n        }\n\n        public int pop() {\n            if (tailStack.empty()) {\n                while (!headStack.empty()) {\n                    tailStack.push(headStack.pop());\n                }\n            }\n            return tailStack.pop();\n        }\n\n        public int peek() {\n            if (tailStack.empty()) {\n                while (!headStack.empty()) {\n                    tailStack.push(headStack.pop());\n                }\n            }\n            return tailStack.peek();\n        }\n\n        public boolean empty() {\n            return headStack.empty() && tailStack.empty();\n        }\n    }\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189967735","body":"## æ€è·¯\n\tå•è°ƒæ ˆ å°†æ•°ç»„é¦–ä¸ªå…¥æ ˆ å¯¹å…¶åçš„æ•°æ® å¤§äºç­‰äºå½“å‰æ ˆé¡¶åˆ™å…¥æ ˆ å°äºåˆ™å‡ºæ ˆä¸€ä¸ªå¹¶æ¯”è¾ƒä¸‹ä¸€ä¸ªæ ˆé¡¶ ç›´åˆ°å¤§äºç­‰äºæ ˆé¡¶æˆ–è€…æ ˆç©ºå†å…¥æ ˆ\n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ O(n) ç©ºé—´å¤æ‚åº¦O(n)\n## ä»£ç \n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Deque<Integer> stack = new LinkedList<>();\n        stack.push(arr[0]);\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] >= stack.peek()) {\n                stack.push(arr[i]);\n            } else {\n                Integer head = stack.pop();\n                while (stack.size() > 0 && arr[i] < stack.peek()) {\n                    stack.pop();\n                }\n                stack.push(head);\n            }\n        }\n        return stack.size();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191205570","body":"## æ€è·¯\n\tæˆç¯å†ç§»ä½\n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ O(n) ç©ºé—´å¤æ‚åº¦O(1)\n## ä»£ç \n\n```java\npublic ListNode rotateRight(ListNode head, int k) {\n        if(head==null){\n            return head;\n        }\n        ListNode temp = new ListNode(0, head);\n        //é“¾è¡¨é•¿åº¦\n        int len = 1;\n        //æˆç¯\n        while (head.next != null) {\n            head = head.next;\n            len++;\n        }\n        head.next = temp.next;\n        head = head.next;\n        //åç§»ç­‰äºé•¿åº¦- å‰ç§»ä½å’Œé•¿åº¦çš„ä½™æ•°\n        int number = len - k % len;\n        //ç§»ä½\n        while (number > 0) {\n            number--;\n            temp = head;\n            head = head.next;\n        }\n        temp.next = null;\n        return head;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192261271","body":"\n## æ€è·¯\n\tä¸¤ä¸¤äº¤æ¢ä½ç½® \n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ O(n) ç©ºé—´å¤æ‚åº¦O(1)\n## ä»£ç \n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode ans = new ListNode(0, head);\n        ListNode temp = ans;\n        while (head != null && head.next != null) {\n\t\t\t//å¤´æŒ‡é’ˆæŒ‡å‘2\n            ans.next = ans.next.next;\n            //1æŒ‡å‘3\n\t\t\thead.next= head.next.next;\n            //2æŒ‡å‘1\n\t\t\tans.next.next = head;\n            //å¤´æŒ‡é’ˆå†åç§»ä¸€ä½\n\t\t\thead = head.next;\n            //ä¸´æ—¶æŒ‡é’ˆåç§»ä¸¤ä½\n\t\t\tans= ans.next.next;\n        }\n        return temp.next;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193141648","body":"## æ€è·¯\n\tå¿«æ…¢æŒ‡é’ˆ å¿«æŒ‡é’ˆç§»åŠ¨ä¸¤æ¬¡ æ…¢æŒ‡é’ˆç§»åŠ¨ä¸€æ¬¡ å¿«æŒ‡é’ˆç§»åŠ¨åˆ°å°¾éƒ¨çš„æ—¶å€™æ…¢æŒ‡é’ˆä¸ºä¸­ä½æ•°\n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)  ç©ºé—´å¤æ‚åº¦ï¼šO(logn)\n## ä»£ç \n\n```java\n\nclass Solution {\n      public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head, null);\n    }\n\n    public TreeNode buildTree(ListNode left, ListNode right) {\n        if (left == right) {\n            return null;\n        }\n        ListNode mid = getMedian(left, right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left, mid);\n        root.right = buildTree(mid.next, right);\n        return root;\n    }\n\n    public ListNode getMedian(ListNode left, ListNode right) {\n        ListNode fast = left;\n        ListNode slow = left;\n        while (fast != right && fast.next != right) {\n            fast = fast.next;\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193285203","body":"## æ€è·¯\n\tå¿«æ…¢æŒ‡é’ˆ å¿«æŒ‡é’ˆç§»åŠ¨ä¸¤æ¬¡ æ…¢æŒ‡é’ˆç§»åŠ¨ä¸€æ¬¡  ç­‰å¿«æŒ‡é’ˆå’Œæ…¢æŒ‡é’ˆç›¸é‡çš„æ—¶å€™æœ‰é‡åˆ\n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)  ç©ºé—´å¤æ‚åº¦ï¼šO(logn)\n## ä»£ç \n\n```java\n\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode tailA = headA;\n        ListNode tailB = headB;\n        while(tailA!=tailB){\n            tailA = tailA==null?headB:tailA.next;\n            tailB = tailB == null? headA:tailB.next;\n        }\n        return tailA;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193499293","body":"## æ€è·¯\n\tå¿«æ…¢æŒ‡é’ˆ å­˜åœ¨ç¯çš„æ—¶å€™ä½¿ç”¨ä¸´æ—¶æŒ‡é’ˆä»å¤´å¼€å§‹å’Œæ…¢æŒ‡é’ˆä¸€ç›´ä¾¿åˆ© ç›¸é‡æ—¶ä¸ºç»“æœ \n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ O(n) ç©ºé—´å¤æ‚åº¦O(1)\n## ä»£ç \n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return null;\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n        ListNode temp = null;\n        while (fast.next != null && fast.next.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) {\n                temp = head;\n                break;\n            }\n        }\n        if (temp == null) {\n            return null;\n        }\n        while (temp != slow) {\n            temp = temp.next;\n            slow = slow.next;\n        }\n        return temp;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195189242","body":"\n## æ€è·¯\n\tä»¿LinkedHashMapçš„æ€è·¯ map+åŒé“¾è¡¨ \n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ O(n) ç©ºé—´å¤æ‚åº¦O(1)\n## ä»£ç \n\n```java\n class LRUCache {\n        Map<Integer, DoubleListNode> cache;\n        int max;\n        int len;\n        DoubleListNode head;\n        DoubleListNode tail;\n\n        public LRUCache(int capacity) {\n            cache = new HashMap<>(capacity);\n            max = capacity;\n            head = tail = null;\n            len = 0;\n        }\n\n        public int get(int key) {\n            DoubleListNode ans = cache.get(key);\n            if(ans == null){\n                return -1;\n            }\n            moveToLast(ans);\n            return ans.getValue();\n        }\n\n        public void put(int key, int value) {\n            DoubleListNode doubleListNode = cache.get(key);\n            if (doubleListNode == null) {\n                DoubleListNode temp = new DoubleListNode(key, value);\n                if (max == len) {\n                    DoubleListNode headTemp = head;\n                    if (head == tail) {\n                        head = tail = null;\n                    } else {\n                        head = head.getAfter();\n                        head.setBefore(null);\n                        headTemp.setAfter(null);\n                    }\n                    cache.remove(headTemp.getKey());\n                    len--;\n                }\n                cache.put(key, temp);\n                moveToLast(temp);\n                len++;\n            } else {\n                doubleListNode.setKeyValue(key, value);\n                moveToLast(doubleListNode);\n            }\n        }\n\n        private void moveToLast(DoubleListNode temp) {\n            //åˆ†å››ç§æƒ…å†µ\n            //æ–°å¢çš„ å‰èŠ‚ç‚¹ä¸ºå°¾èŠ‚ç‚¹ å°¾èŠ‚ç‚¹=è¿™ä¸ªèŠ‚ç‚¹\n            //å¤´èŠ‚ç‚¹ ä¸‹ä¸€ä¸ªèŠ‚ç‚¹å˜ä¸ºå¤´èŠ‚ç‚¹ ä¸‹ä¸€èŠ‚ç‚¹ç½®ç©º å‰èŠ‚ç‚¹ä¸ºå°¾èŠ‚ç‚¹ å°¾èŠ‚ç‚¹=è¿™ä¸ªèŠ‚ç‚¹\n            //å°¾èŠ‚ç‚¹ ä¸åŠ¨\n            //ä¸­é—´èŠ‚ç‚¹ è®°å½•å‰åèŠ‚ç‚¹ è°ƒè½¬å‰åèŠ‚ç‚¹çš„æŒ‡å‘ åèŠ‚ç‚¹ç½®ç©º å‰èŠ‚ç‚¹ä¸ºå°¾èŠ‚ç‚¹ å°¾èŠ‚ç‚¹=è¿™ä¸ªèŠ‚ç‚¹\n            if (temp.getBefore() == null) {\n                if (head == null) {\n                    head = tail = temp;\n                    return ;\n                }\n                if (temp.getAfter() != null) {\n                    //å¤´èŠ‚ç‚¹\n                    head = head.getAfter();\n                    head.setBefore(null);\n                    temp.setAfter(null);\n                }\n                tail.setAfter(temp);\n                temp.setBefore(tail);\n                tail = temp;\n            }else {\n                if (temp.getAfter() != null) {\n                    //ä¸­é—´èŠ‚ç‚¹\n                    DoubleListNode after = temp.getAfter();\n                    DoubleListNode before = temp.getBefore();\n                    before.setAfter(after);\n                    after.setBefore(before);\n                    temp.setAfter(null);\n                    tail.setAfter(temp);\n                    temp.setBefore(tail);\n                    tail = temp;\n                }\n            }\n        }\n\n        class DoubleListNode {\n            private DoubleListNode before;\n            private Integer key;\n            private Integer value;\n            private DoubleListNode after;\n\n            public DoubleListNode(Integer key, Integer value) {\n                this.key = key;\n                this.value = value;\n                this.before = null;\n                this.after = null;\n            }\n\n            public DoubleListNode(DoubleListNode before, Integer key, Integer value, DoubleListNode after) {\n                this.key = key;\n                this.value = value;\n                this.before = before;\n                this.after = after;\n            }\n\n            public DoubleListNode getBefore() {\n                return before;\n            }\n\n            public DoubleListNode getAfter() {\n                return after;\n            }\n\n            public void setAfter(DoubleListNode after) {\n                this.after = after;\n            }\n\n            public void setBefore(DoubleListNode before) {\n                this.before = before;\n            }\n\n            public Integer getKey() {\n                return key;\n            }\n\n            public Integer getValue() {\n                return value;\n            }\n\n            public void setKeyValue(Integer key, Integer value) {\n                this.key = key;\n                this.value = value;\n            }\n        }\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196156669","body":"\n## æ€è·¯\n\té€’å½’\n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ O(n) ç©ºé—´å¤æ‚åº¦O(1)\n## ä»£ç \n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root==null){\n        \treturn 0;\n\t\t}\n        return Math.max(getDeep(root.left,0),getDeep(root.right,0))+1;\n    }\n\n    public int getDeep(TreeNode tree,int deep){\n        if(tree==null){\n            return deep;\n        }\n        return Math.max(getDeep(tree.left,deep),getDeep(tree.right,deep))+1;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197535109","body":"\n## æ€è·¯\n\té€’å½’\n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ O(n) ç©ºé—´å¤æ‚åº¦O(1)\n## ä»£ç \n\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null&&q==null){\n            return true;\n        }\n        if(p==null||q==null){\n            return false;\n        }\n        if(q.val!=p.val){\n            return false;\n        }\n        return isSameTree(p.left,q.left)&isSameTree(p.right,q.right);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198758044","body":"\n## æ€è·¯\n\tBFS ä¸‹ä¸€å±‚èŠ‚ç‚¹çš„å€¼ += ä¸Šä¸€å±‚èŠ‚ç‚¹çš„å€¼*10\n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ O(n) ç©ºé—´å¤æ‚åº¦O(n)\n## ä»£ç \n\n```java\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        List<TreeNode> treeNodeList = new LinkedList<>();\n        int ans = 0;\n        treeNodeList.add(root);\n        while(treeNodeList.size()>0){\n            int len = treeNodeList.size();\n            for(int i=0;i<len;i++){\n                TreeNode temp = treeNodeList.remove(0);\n                if(temp.right ==null && temp.left==null){\n                    ans += temp.val;\n                }\n                if(temp.left!=null){\n                    temp.left.val += temp.val*10;\n                    treeNodeList.add(temp.left);\n                }\n                if(temp.right!=null){\n                    temp.right.val += temp.val*10;\n                    treeNodeList.add(temp.right);\n                }\n            }\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200076984","body":"## æ€è·¯\n\tBFS è¿›å…¥ä¸‹ä¸€å±‚çš„æ—¶å€™è®°å½•i==0çš„æ—¶å€™çš„å€¼  å½“ä¸å†å­˜åœ¨ä¸‹ä¸€å±‚çš„æ—¶å€™ è®°å½•å€¼ä¸ºç»“æœ\n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ï¼šO(n)  ç©ºé—´å¤æ‚åº¦ï¼šO(n)\n## ä»£ç \n\n```java\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        List<TreeNode> treeNodeList = new LinkedList<>();\n        treeNodeList.add(root);\n        int ans =0;\n        while(treeNodeList.size()>0){\n            int len = treeNodeList.size();\n            for(int i=0;i<len;i++){\n                TreeNode temp = treeNodeList.remove(0);\n                if(i==0){\n                    ans = temp.val;\n                }\n                if(temp.left!=null){\n                    treeNodeList.add(temp.left);\n                }\n                if(temp.right!=null){\n                    treeNodeList.add(temp.right);\n                }\n            }\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200441918","body":"## æ€è·¯\n\tå…ˆåºéå†\n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ï¼šO(n)  ç©ºé—´å¤æ‚åº¦ï¼šO(n)\n## ä»£ç \n\n```java\npublic class Codec {\n    public String serialize(TreeNode root) {\n        return rserialize(root, \"\");\n    }\n  \n    public TreeNode deserialize(String data) {\n        String[] dataArray = data.split(\",\");\n        List<String> dataList = new LinkedList<String>(Arrays.asList(dataArray));\n        return rdeserialize(dataList);\n    }\n\n    public String rserialize(TreeNode root, String str) {\n        if (root == null) {\n            str += \"None,\";\n        } else {\n            str += str.valueOf(root.val) + \",\";\n            str = rserialize(root.left, str);\n            str = rserialize(root.right, str);\n        }\n        return str;\n    }\n  \n    public TreeNode rdeserialize(List<String> dataList) {\n        if (dataList.get(0).equals(\"None\")) {\n            dataList.remove(0);\n            return null;\n        }\n  \n        TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0)));\n        dataList.remove(0);\n        root.left = rdeserialize(dataList);\n        root.right = rdeserialize(dataList);\n    \n        return root;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201307569","body":"## æ€è·¯\n\tdfs \n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)  ç©ºé—´å¤æ‚åº¦ï¼šO(n)\n## ä»£ç \n\n```java\nclass Solution {\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<int[]> nodes = new ArrayList<int[]>();\n        dfs(root, 0, 0, nodes);\n        Collections.sort(nodes, new Comparator<int[]>() {\n            public int compare(int[] tuple1, int[] tuple2) {\n                if (tuple1[0] != tuple2[0]) {\n                    return tuple1[0] - tuple2[0];\n                } else if (tuple1[1] != tuple2[1]) {\n                    return tuple1[1] - tuple2[1];\n                } else {\n                    return tuple1[2] - tuple2[2];\n                }\n            }\n        });\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        int size = 0;\n        int lastcol = Integer.MIN_VALUE;\n        for (int[] tuple : nodes) {\n            int col = tuple[0], row = tuple[1], value = tuple[2];\n            if (col != lastcol) {\n                lastcol = col;\n                ans.add(new ArrayList<Integer>());\n                size++;\n            }\n            ans.get(size - 1).add(value);\n        }\n        return ans;\n    }\n\n    public void dfs(TreeNode node, int row, int col, List<int[]> nodes) {\n        if (node == null) {\n            return;\n        }\n        nodes.add(new int[]{col, row, node.val});\n        dfs(node.left, row + 1, col - 1, nodes);\n        dfs(node.right, row + 1, col + 1, nodes);\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201899710","body":"\n## æ€è·¯\n\tå“ˆå¸Œè¡¨\n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ O(n) ç©ºé—´å¤æ‚åº¦O(n)\n## ä»£ç \n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer,Integer> map = new HashMap<>();\n        for(int i=0;i<nums.length;i++){\n            if(map.containsKey(target-nums[i])){\n                return new int[]{map.get(target-nums[i]),i};\n            }else{\n                map.put(nums[i],i);\n            }\n        }\n        return new int[]{0,0};\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1204114223","body":"## æ€è·¯\n\tå“ˆå¸Œè¡¨ + ä¼˜å…ˆé˜Ÿåˆ— \n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)  ç©ºé—´å¤æ‚åº¦ï¼šO(n)\n## ä»£ç \n\n```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int num : nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        //Comparator.comparingInt(o -> o[1]) è¿”å›ä¸€ä¸ªæ¯”è¾ƒå™¨ è¯¥æ¯”è¾ƒå™¨ä»¥intæ’åºlambdaè¡¨è¾¾å¼ä¸­æ˜¯å¦‚ä½•è·å–è¿™ä¸ªç”¨äºæ¯”è¾ƒçš„int\n        //PriorityQueue ä¼˜å…ˆé˜Ÿåˆ— ä»¥æ„é€ å™¨ä¸­çš„æ¯”è¾ƒå™¨å‚æ•°ä¸ºæ’åºè§„åˆ™æ’åº\n        PriorityQueue<int[]> queue = new PriorityQueue<>((Comparator.comparingInt(o -> o[1])));\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            if (queue.size() == k) {\n                final int[] peek = queue.peek();\n                if (peek[1] < entry.getValue()) {\n                    queue.poll();\n                    queue.offer(new int[]{entry.getKey(), entry.getValue()});\n                }\n            } else {\n                queue.offer(new int[]{entry.getKey(), entry.getValue()});\n            }\n        }\n        int[] ans = new int[k];\n        for (int i = 0; i < k; ++i) {\n            ans[i] = queue.poll()[0];\n        }\n        return ans;\n    }\n\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205061265","body":"\n## æ€è·¯\n\tå“ˆå¸Œè¡¨ \n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ O(n*n) ç©ºé—´å¤æ‚åº¦O(n)\n## ä»£ç \n\n```java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        Map<Integer, Integer> map = new HashMap<>();\n        int ans = 0;\n        for (int i = 0; i < points.length; i++) {\n            map = new HashMap<>();\n            for (int j = 0; j < points.length; j++) {\n                if (i == j) continue;\n                int len = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\n                if (map.containsKey(len)) {\n                    ans += map.get(len) * 2;\n                }\n                map.put(len, map.getOrDefault(len, 0) + 1);\n            }\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206532676","body":"## æ€è·¯\n\tå“ˆå¸Œè¡¨ æ»‘åŠ¨çª—å£\n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ï¼šO(n)  ç©ºé—´å¤æ‚åº¦ï¼šO(n)\n## ä»£ç \n\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int start = 0, end = 0, sum = 0;\n        Map<Character, Integer> map = new HashMap<>();\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (map.containsKey(c)) {\n                sum = Math.max(sum, map.size());\n                for (; start < end; start++) {\n                    if (c == s.charAt(start)) {\n                        start++;\n                        end++;\n                        break;\n                    } else {\n                        map.remove(s.charAt(start));\n                    }\n                }\n            } else {\n                end++;\n                map.put(c, 1);\n            }\n\n        }\n        return Math.max(sum, map.size());\n    }\n\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207238305","body":"## æ€è·¯\n\t æ»‘åŠ¨çª—å£\n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ï¼šO(n)  ç©ºé—´å¤æ‚åº¦ï¼šO(n*m)\n## ä»£ç \n\n```java\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> res = new ArrayList<Integer>();\n        int m = words.length, n = words[0].length(), ls = s.length();\n        for (int i = 0; i < n; i++) {\n            if (i + m * n > ls) {\n                break;\n            }\n            Map<String, Integer> differ = new HashMap<String, Integer>();\n            for (int j = 0; j < m; j++) {\n                String word = s.substring(i + j * n, i + (j + 1) * n);\n                differ.put(word, differ.getOrDefault(word, 0) + 1);\n            }\n            for (String word : words) {\n                differ.put(word, differ.getOrDefault(word, 0) - 1);\n                if (differ.get(word) == 0) {\n                    differ.remove(word);\n                }\n            }\n            for (int start = i; start < ls - m * n + 1; start += n) {\n                if (start != i) {\n                    String word = s.substring(start + (m - 1) * n, start + m * n);\n                    differ.put(word, differ.getOrDefault(word, 0) + 1);\n                    if (differ.get(word) == 0) {\n                        differ.remove(word);\n                    }\n                    word = s.substring(start - n, start);\n                    differ.put(word, differ.getOrDefault(word, 0) - 1);\n                    if (differ.get(word) == 0) {\n                        differ.remove(word);\n                    }\n                }\n                if (differ.isEmpty()) {\n                    res.add(start);\n                }\n            }\n        }\n        return res;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207731130","body":"\n## æ€è·¯\n\tå“ˆå¸Œè¡¨ å‰ç¼€å’Œ åŒä½™å®šç†\n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ O(n) ç©ºé—´å¤æ‚åº¦O(n)\n## ä»£ç \n\n```java\n\nclass Solution {\n    public int solve(int[] nums, int k) {\n\n        int tar = 0;\n\n        for (int n : nums)\n            tar += n;\n\n        tar = Math.floorMod(tar, k);\n\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, -1);\n\n        int prefix = 0, res = nums.length;\n\n        for (int i = 0; i < nums.length; i++) {\n`   1\n            prefix += nums[i];\n            int mod = Math.floorMod(prefix, k);\n            map.put(mod, i);\n\n            if (map.containsKey(Math.floorMod(prefix - tar, k)))\n                res = Math.min(res, i - map.get(Math.floorMod(prefix - tar, k)));\n        }\n\n        return res == nums.length ? -1 : res;\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207743588","body":"\n## æ€è·¯\n\tåŒæŒ‡é’ˆ\n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ O(n) ç©ºé—´å¤æ‚åº¦O(1)\n## ä»£ç \n\n```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode fast = head,tail  = head;\n        while(fast.next!=null&&fast.next.next!=null){\n            fast = fast.next.next;\n            tail = tail.next;\n        }\n        if(fast.next!=null){\n            tail = tail.next;\n        }\n        return tail;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209217366","body":"\n## æ€è·¯\n\tåŸåœ°æ›¿æ¢ æ…¢æŒ‡é’ˆæ›¿æ¢ä¸åŒçš„æ•°æ®åˆ°å½“å‰ä¸‹æ ‡\n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ O(n) ç©ºé—´å¤æ‚åº¦O(1)\n## ä»£ç \n\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int low = 1;\n        int temp  = nums[0];\n        for(int i=1;i<nums.length;i++){\n            if(temp==nums[i]){\n                continue;\n            }\n            nums[low] = nums[i];\n            temp = nums[i];\n            low++;\n        }\n        return low;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"caterpillar-0":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185118358","body":"### æ€è·¯\r\næŒ‰ä½ä¾æ¬¡ç›¸åŠ \r\n### ä»£ç \r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int>res;\r\n        for(int i=num.size()-1;i>=0 || k>0;i--,k/=10){\r\n            if(i>=0){\r\n                k+=num[i];\r\n            }\r\n            res.push_back(k%10);\r\n        }\r\n        reverse(res.begin(),res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n### å¤æ‚åº¦åˆ†æ\r\n* æ—¶é—´å¤æ‚åº¦ï¼šo(n)\r\n* ç©ºé—´å¤æ‚åº¦ï¼šo(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186071498","body":"### æ€è·¯\nä¸¤æ¬¡éå†ï¼Œæ‰¾åˆ°ç¦»å¾—æœ€è¿‘çš„Cçš„è·ç¦»\n### ä»£ç \n```C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int>res;\n        //ä»å‰éå†\n        int index=INT_MAX;\n        for(int i=0;i<s.size();i++){\n            if(s[i]==c){\n                index=i;\n            }\n            res.push_back(abs(i-index));\n        }\n        //ä»åéå†\n        index=INT_MAX;\n        for(int i=s.size()-1;i>=0;i--){\n            if(s[i]==c){\n                index=i;\n            }\n            res[i]=min(res[i],abs(index-i));\n        }\n        return res;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´å¤æ‚åº¦:o(n)\n* ç©ºé—´å¤æ‚åº¦:o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186377067","body":"### ä»£ç \n```C++\nclass CustomStack {\nprivate:\n    int cap;//æœ€å¤§å®¹é‡\n    int top;//ç›®å‰å…ƒç´ æ ˆé¡¶\n    int* arr;//æ•°ç»„æŒ‡é’ˆ\npublic:\n    CustomStack(int maxSize) {\n        cap=maxSize;\n        top=-1;\n        arr=new int[cap];\n    }\n    ~CustomStack() {\n        delete [] arr;\n    }\n    \n    void push(int x) {\n        if(top<cap-1){\n            arr[++top]=x;\n        }\n    }\n    \n    int pop() {\n        if(top==-1)return -1;\n        return arr[top--];\n    }\n    \n    void increment(int k, int val) {\n        int board=min(k,top+1);\n        for(int i=0;i<board;i++){\n            arr[i]+=val;\n        }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186710233","body":"### æ€è·¯\nç”¨æ ˆåŒ¹é…æ‹¬å·ï¼Œåˆ†åˆ«å¤„ç†æ•°å­—ï¼Œå­—æ¯å’Œæ‹¬å·\n### ä»£ç \n```C++\nclass Solution {\npublic:\n    string GetDigit(const string& s,size_t& ptr){\n        string ret=\"\";\n        //å› ä¸ºæ•°å­—ä¸æ­¢ä¸€ä½\n        while(isdigit(s[ptr])){\n            ret.push_back(s[ptr++]);//å¯¹ptræœ‰æ”¹åŠ¨ï¼Œå› æ­¤éœ€è¦&\n        }\n        return ret;\n    }\n    string GetString(vector<string>& sub){\n        string temp=\"\";\n        for(string& s:sub){\n            temp+=s;\n        }\n        return temp;\n    }\n    string decodeString(string s) {\n        vector<string>myvec;\n        size_t ptr=0;\n        while(ptr<s.size()){\n            char ch=s[ptr];\n            //1ã€å¤„ç†æ•°å­—\n            if(isdigit(ch))myvec.push_back(GetDigit(s,ptr));\n            //2ã€å¤„ç†å­—æ¯\n            else if(isalpha(ch) || ch=='[')myvec.push_back(string(1,s[ptr++]));\n            //3ã€å¤„ç†']'\n            else{\n                ++ptr;\n                vector<string>sub;\n                while(myvec.back()!=\"[\"){\n                    sub.push_back(myvec.back());\n                    myvec.pop_back();\n                }\n                myvec.pop_back();\n                reverse(sub.begin(),sub.end());\n                string temp=GetString(sub);\n                int times=stoi(myvec.back());\n                myvec.pop_back();\n                string temp_1;\n                while(times--){\n                    temp_1+=temp;\n                }\n                myvec.push_back(temp_1);\n            }\n        }\n        return GetString(myvec);\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´å¤æ‚åº¦ï¼šo(n)\n* ç©ºé—´å¤æ‚åº¦ï¼šo(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188847635","body":"### æ€è·¯\nä½¿ç”¨ä¸¤ä¸ªæ ˆï¼Œæ¥å®ç°é˜Ÿåˆ—å…ˆè¿›å…ˆå‡º\n### ä»£ç \n```C++\nclass MyQueue {\n    //ä¼˜åŒ–ï¼Œå­˜åœ¨é‡å¤ä»£ç \nprivate:\n    stack<int>instack;\n    stack<int>outstack;\n    void in_out(){\n        if(outstack.empty()){\n            while(!instack.empty()){\n                outstack.push(instack.top());\n                instack.pop();\n            }\n        }\n    }\npublic:\n    MyQueue() {\n    }\n    \n    void push(int x) {\n        instack.push(x);\n    }\n    \n    int pop() {\n        in_out();\n        int temp=outstack.top();\n        outstack.pop();\n        return temp;\n    }\n    \n    int peek() {\n        in_out();\n        return outstack.top();\n    }\n    \n    bool empty() {\n        return instack.empty() && outstack.empty();\n    }\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189989210","body":"### æ€è·¯\nå•è°ƒæ ˆï¼Œä»æ ˆåº•åˆ°æ ˆå¤´ä»å°åˆ°å¤§ï¼Œæ³¨æ„ç•™ä¸‹çš„æ˜¯æ¯ä¸ªåŒºé—´çš„å¤§å€¼\n### ä»£ç \n```C++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int>mystack;\n        //å•è°ƒæ ˆ,æ ˆåº•åˆ°æ ˆå¤´ä»å°åˆ°å¤§\n        for(int i=0;i<arr.size();i++){\n            if(!mystack.empty() && arr[i]<arr[mystack.top()]){\n                int temp=mystack.top();\n                while(!mystack.empty() && arr[i]<arr[mystack.top()]){\n                    mystack.pop();\n                }\n                mystack.push(temp);\n            }\n            else{\n                mystack.push(i);\n            }\n        }\n        return mystack.size();\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´å¤æ‚åº¦ï¼šo(n)\n* ç©ºé—´å¤æ‚åº¦ï¼šo(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190975716","body":"### æ€è·¯\nå°†é“¾è¡¨ç›¸æ¥æˆç¯ï¼Œåˆ¤æ–­å¤´ç»“ç‚¹çš„ä½ç½®\n### ä»£ç \n```C++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(head==nullptr)return nullptr;\n        //ç›¸æ¥æˆç¯\n        ListNode* temp=head;\n        int size=1;\n        while(temp->next!=nullptr){\n            temp=temp->next;\n            size++;\n        }\n        //tempæ˜¯åŸæ¥çš„å°¾ç»“ç‚¹\n        temp->next=head;\n        int num=abs(size-k%size);\n        while(num--){\n            head=head->next;\n            temp=temp->next;\n        }\n        temp->next=nullptr;\n        return head;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´å¤æ‚åº¦ï¼šo(n)\n* ç©ºé—´å¤æ‚åº¦ï¼šo(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192116529","body":"### æ€è·¯\nè¿­ä»£ï¼Œäº¤æ¢ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œ\n### ä»£ç \n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        //è¿­ä»£æ³•\n        if(head==nullptr || head->next==nullptr)return head;\n        //æœ€å‰é¢æ¥ä¸€ä¸ªç©ºèŠ‚ç‚¹ï¼Œæ–¹ä¾¿å¤„ç†\n        ListNode* virhead=new ListNode(0);\n        virhead->next=head;\n        ListNode* cur=virhead;\n        while(cur->next!=nullptr && cur->next->next!=nullptr){\n            ListNode* temp1=cur->next;\n            ListNode* temp2=cur->next->next;\n            cur->next=temp2;\n            temp1->next=temp2->next;\n            temp2->next=temp1;\n            cur=cur->next->next;\n        }\n        return virhead->next;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n* ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193076346","body":"### æ€è·¯\nå¿«æ…¢æŒ‡é’ˆæ‰¾ä¸­é—´èŠ‚ç‚¹ï¼Œé€’å½’å»ºæ ‘\n### ä»£ç \n```C++\nclass Solution {\npublic:\n    //å¯»æ‰¾ä¸­é—´èŠ‚ç‚¹\n    ListNode* findMid(ListNode* left,ListNode* right){\n        ListNode* slow=left,*fast=left;\n        while(fast!=right && fast->next!=right){\n            slow=slow->next;\n            fast=fast->next->next;\n        }\n        return slow;\n    }\n    //é€’å½’å»ºæ ‘\n    TreeNode* makeTree(ListNode* left,ListNode* right){\n        if(left==right)return nullptr;//é€’å½’ç»“æŸæ¡ä»¶\n        ListNode* mid=findMid(left,right);\n        TreeNode* root=new TreeNode(mid->val);\n        root->left=makeTree(left,mid);//æ­¤å¤„å°±ä½“ç°å‡ºå·¦é—­å³å¼€çš„å¿…è¦æ€§ï¼Œå› ä¸ºé“¾è¡¨ä¸èƒ½å‰æŒ‡\n        root->right=makeTree(mid->next,right);\n        return root;\n    }\n    TreeNode* sortedListToBST(ListNode* head){\n        return makeTree(head,nullptr);\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´å¤æ‚åº¦ï¼šo(nlogn)\n* ç©ºé—´å¤æ‚åº¦ï¼šo(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193244098","body":"### æ€è·¯\nè®©ä¸¤ä¸ªæŒ‡é’ˆèµ°ç›¸åŒçš„é•¿åº¦m+n,å¦‚æœé“¾è¡¨ç›¸äº¤å°±ä¼šç›¸é‡\n### ä»£ç \n```C++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if(headB==nullptr || headA==nullptr)return nullptr;\n        ListNode* tmpA=headA,*tmpB=headB;\n        while(tmpA!=tmpB){\n            tmpA=tmpA==nullptr?headB:tmpA->next;\n            tmpB=tmpB==nullptr?headA:tmpB->next;\n        }\n        return tmpA;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´å¤æ‚åº¦ï¼šO(m+n)\n* ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193718752","body":"### æ€è·¯\nå¿«æ…¢æŒ‡é’ˆï¼Œä»ç›¸é‡ç‚¹å¼€å§‹ï¼Œåˆ†åˆ«ä»å¤´ç»“ç‚¹ä¸ç›¸é‡ç‚¹å¼€å§‹çš„æŒ‡é’ˆä¼šç›¸é‡ä¸ç¯å½¢å…¥å£å¤„\n### ä»£ç \n```C++\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        //å¿«æ…¢æŒ‡é’ˆ\n        if(head==nullptr ||head->next==nullptr)return nullptr;\n        ListNode* fast=head,*slow=head;\n        while(fast!=nullptr && fast->next!=nullptr){\n            slow=slow->next;\n            fast=fast->next->next;\n            if(slow==fast){//ç›¸é‡ç‚¹\n                ListNode* tmp0=head;\n                ListNode* tmp1=slow;\n                while(tmp0!=tmp1){\n                    tmp1=tmp1->next;\n                    tmp0=tmp0->next;\n                }\n                return tmp0;\n            }\n        }\n        return nullptr;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´å¤æ‚åº¦ï¼šo(n)\n* ç©ºé—´å¤æ‚åº¦ï¼šo(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195441624","body":"### æ€è·¯\nç”¨å“ˆå¸Œè¡¨+åŒå‘é“¾è¡¨ï¼Œè®°å¾—åŠæ—¶æ›´æ–°å“ˆå¸Œè¡¨\n### ä»£ç \n```C++\nstruct Node{\n    Node* prev;\n    Node* next;\n    int key,val;\n    Node():prev(nullptr),next(nullptr),key(0),val(0){};\n    Node(int key,int val):prev(nullptr),next(nullptr),key(key),val(val){};\n};\n\nclass LRUCache {\nprivate:\n    unordered_map<int,Node*>mymap;\n    Node* virHead;\n    Node* virTail;\n    int size;//å®é™…å…ƒç´ æ•°é‡\n    int cap;//æœ€å¤§å®¹é‡\n\n    void removeNode(Node* tmp){\n        tmp->prev->next=tmp->next;\n        tmp->next->prev=tmp->prev;\n        size--;\n    }\n    void movetoHead(Node* tmp){\n        tmp->prev=virHead;\n        tmp->next=virHead->next;\n        virHead->next->prev=tmp;\n        virHead->next=tmp;\n        size++;\n    }\n    void removeTail(){\n         Node* tmp=virTail->prev;\n         tmp->prev->next=virTail;\n         virTail->prev=tmp->prev;\n         mymap.erase(tmp->key);//å“ˆå¸Œè¡¨ä¸­ç§»é™¤\n         delete tmp;\n         size--;\n    }\npublic:\n    LRUCache(int capacity):size(0),cap(capacity),mymap() {\n        virHead=new Node();\n        virTail=new Node();\n        virHead->next=virTail;\n        virTail->prev=virHead;\n    }\n    \n    int get(int key) {\n        if(mymap.find(key)!=mymap.end()){\n            Node* tmp=mymap[key];\n            //å°†å…¶èŠ‚ç‚¹ç§»åŠ¨åˆ°åŒå‘é“¾è¡¨å¤´éƒ¨\n            //1ã€åˆ é™¤å½“å‰èŠ‚ç‚¹\n            removeNode(tmp);\n            //2ã€åœ¨å¤´éƒ¨æ·»åŠ tmp\n            movetoHead(tmp);\n            //3ã€è¿”å›å€¼\n            return tmp->val;\n        }\n        return -1;\n    }\n    \n    void put(int key, int value) {\n        if(mymap.find(key)!=mymap.end()){\n            Node* tmp=mymap[key];\n            tmp->val=value;\n            removeNode(tmp);\n            movetoHead(tmp);\n        }\n        else{\n            if(size==cap){//åˆ é™¤å°¾éƒ¨èŠ‚ç‚¹\n                removeTail();\n            }\n            //æ’å…¥æ–°èŠ‚ç‚¹åˆ°å°¾éƒ¨\n            Node* tmp=new Node(key,value);\n            mymap[key]=tmp;//æ·»åŠ æ–°çš„å“ˆå¸Œè¡¨\n            movetoHead(tmp);\n        }\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´å¤æ‚åº¦ï¼šo(1)\n* ç©ºé—´å¤æ‚åº¦ï¼šo(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196213148","body":"### æ€è·¯\nå±‚åºéå†ï¼Œç”¨é˜Ÿåˆ—éå†\n### ä»£ç \n```C++\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root==nullptr)return 0;\n        //å±‚åºéå†,ç”¨é˜Ÿåˆ—éå†\n        int count=0;\n        queue<TreeNode*>myque;\n        myque.push(root);\n        while(!myque.empty()){\n            int size=myque.size();\n            count++;\n            while(size--){\n                TreeNode* tmp=myque.front();\n                myque.pop();\n                if(tmp->left)myque.push(tmp->left);\n                if(tmp->right)myque.push(tmp->right);\n            }\n        }\n        return count;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´å¤æ‚åº¦ï¼šo(n)\n* ç©ºé—´å¤æ‚åº¦ï¼šo(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198866567","body":"### æ€è·¯\nç”¨é€’å½’ï¼Œæ¥åˆ¤æ–­ä¸¤æ£µæ ‘ï¼Œæ·±åº¦éå†\n### ä»£ç \n```C++\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        //ä¸¤æ£µæ ‘ä¸€èµ·éå†ï¼Œæ·±åº¦éå†ï¼Œé€’å½’\n        if(p==nullptr && q==nullptr)return true;\n        else if(p==nullptr || q==nullptr)return false;\n        else{\n            if(p->val != q->val)return false;\n            return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\n        }\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´å¤æ‚åº¦ï¼šo(n)\n* ç©ºé—´å¤æ‚åº¦ï¼šo(logn)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198882905","body":"### æ€è·¯\næ·±åº¦éå†ï¼Œæƒ³æ¸…æ¥špreå’Œsumå˜é‡ï¼Œé‡åˆ°å¶å­èŠ‚ç‚¹æ”¶é›†ç»“æœï¼›\n### ä»£ç \n```C++\nclass Solution {\npublic:\n    int dfs(TreeNode* root,int pre){\n        if(root==nullptr)return 0;\n        int sum=pre*10+root->val;\n        if(root->left==nullptr && root->right==nullptr)return sum;\n        return dfs(root->left,sum)+dfs(root->right,sum);\n    }\n    int sumNumbers(TreeNode* root) {\n        return dfs(root,0);\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´å¤æ‚åº¦ï¼šo(n)\n* ç©ºé—´å¤æ‚åº¦ï¼šo(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200163011","body":"### æ€è·¯\nä½¿ç”¨é˜Ÿåˆ—ï¼Œå±‚åºéå†ï¼Œæ›´æ–°æ¯å±‚æœ€å·¦è¾¹çš„å€¼\n### ä»£ç \n```C++\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        //è‡³å°‘åˆä¸€ä¸ªèŠ‚ç‚¹ï¼Œä¸ç”¨åˆ¤æ–­rootçš„nullptr\n        //å±‚åºéå†ï¼Œé˜Ÿåˆ—,æ³¨æ„ï¼ŒèŠ‚ç‚¹çš„æ•°å€¼ç”±æ­£è´Ÿ\n        queue<TreeNode*>myQue;\n        myQue.push(root);\n        int res;\n        while(!myQue.empty()){\n            int size=myQue.size();\n            res=myQue.front()->val;\n            while(size--){\n                TreeNode* tmp=myQue.front();\n                myQue.pop();\n                if(tmp->left)myQue.push(tmp->left);\n                if(tmp->right)myQue.push(tmp->right);\n            }\n        }\n        return res;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´å¤æ‚åº¦ï¼šo(n)\n* ç©ºé—´å¤æ‚åº¦ï¼šo(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200621332","body":"### æ€è·¯\nå°†å…¶è½¬åŒ–ä¸ºå­—ç¬¦ä¸²ï¼Œæ³¨æ„ï¼Œååºåˆ—åŒ–æ—¶å°†å…¶è½¬ä¸ºlistï¼Œä¸å¯ä»¥list<char>,å› ä¸ºæ•°å­—ä¸æ­¢ä¸€ä½ä¸”æœ‰æ­£è´Ÿç¬¦å·\n### ä»£ç \n```C++\nclass Codec {\npublic:\n    void rserialize(TreeNode* root,string& res){\n        if(root==nullptr)res+=\"null,\";\n        else{\n            res+=to_string(root->val)+\",\";\n            rserialize(root->left,res);\n            rserialize(root->right,res);\n        }\n    }\n\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        string res=\"\";\n        rserialize(root,res);\n        return res;\n    }\n    TreeNode* rdeserialize(list<string>& myList){\n        if(myList.front()==\"null\"){\n            myList.erase(myList.begin());\n            return nullptr;\n        }\n        TreeNode* root=new TreeNode(stoi(myList.front()));\n        myList.erase(myList.begin());\n        root->left=rdeserialize(myList);\n        root->right=rdeserialize(myList);\n        return root;\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        list<string>myList;\n        string str;\n        for(char num:data){\n            if(num!=','){\n                str.push_back(num);\n            }\n            else{\n                myList.push_back(str);\n                str.clear();\n            }\n        }\n        return rdeserialize(myList);\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´å¤æ‚åº¦ï¼šo(n)\n* ç©ºé—´å¤æ‚åº¦ï¼šo(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200964307","body":"### æ€è·¯\né¦–å…ˆæ·±åº¦éå†ï¼Œå°†èŠ‚ç‚¹çš„xyå­˜å‚¨ï¼Œæ’åºéƒ¨åˆ†åˆ©ç”¨structç»“æ„ä½“é‡è½½<è¿ç®—ç¬¦ï¼Œåœ¨ä¼˜å…ˆé˜Ÿåˆ—ä¸­å®ç°æ’åºï¼Œæœ€åå†è¾“å‡ºåˆ°resæ•°ç»„ä¸­\n### ä»£ç \n```C++\nclass Solution {\npublic:\n    struct Node{\n        int x,y,val;\n        Node(){}//é‡å†™æ„é€ å‡½æ•°ï¼Œå°±è¦å†™é»˜è®¤æ„é€ \n        Node(int x,int y,int val):x(x),y(y),val(val){}\n        //é‡ç‚¹åœ¨äºé‡è½½<å·,é»˜è®¤ä¸ºå¤§é¡¶å †ï¼Œ<ï¼Œä»å°åˆ°å¤§\n        bool operator <(Node node)const{\n            if(y!=node.y)return y>node.y;\n            else if(x!=node.x)return x>node.x;\n            else return val>node.val;\n        }\n    };\n    map<int,priority_queue<Node>>myMap;\n    //é¦–å…ˆï¼Œæ·±åº¦éå†ï¼Œé€’å½’ï¼Œç¡®å®šæ¯ä¸ªèŠ‚ç‚¹çš„x,yå€¼\n    void dfs(TreeNode* root,int x,int y){//rootå½“å‰çš„x,yå€¼\n        if(root==nullptr)return;\n        myMap[y].push({x,y,root->val});\n        if(root->left)dfs(root->left,x+1,y-1);\n        if(root->right)dfs(root->right,x+1,y+1);\n    }\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        vector<vector<int>>res;\n        if(root==nullptr)return res;\n        dfs(root,0,0);\n        for(auto& [x,y]:myMap){\n            res.push_back(vector<int>());\n            while(!y.empty()){\n                res.back().push_back(y.top().val);\n                y.pop();\n            }\n        }\n        return res;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´å¤æ‚åº¦:o(nlogn)\n* ç©ºé—´å¤æ‚åº¦:o(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201855951","body":"### æ€è·¯\nä½¿ç”¨å“ˆå¸Œè¡¨è®°å½•\n### ä»£ç \n```C++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        //å“ˆå¸Œè¡¨\n        unordered_map<int,int>myMap;\n        for(int i=0;i<nums.size();i++){\n            if(myMap.find(target-nums[i])==myMap.end()){\n                myMap[nums[i]]=i;\n                \n            }\n            else{\n                return {myMap[target-nums[i]],i};\n            }\n        }\n        return {};\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´å¤æ‚åº¦:o(n)\n* ç©ºé—´å¤æ‚åº¦:o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203380721","body":"### æ€è·¯\nå“ˆå¸Œè¡¨ç»Ÿè®¡æ¬¡æ•°ï¼Œä¼˜å…ˆé˜Ÿåˆ—è¿›è¡Œæ’åº\n### ä»£ç \n```C++\nclass Solution {\npublic:\n    struct Node{\n        int key,count;\n        Node(){};\n        Node(int key,int count):key(key),count(count){};\n        bool operator<(Node node)const{\n            return count<node.count;\n        }\n    };\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        //å“ˆå¸Œç»Ÿè®¡æ¬¡æ•°\n        unordered_map<int,int>myMap;\n        for(int num:nums){\n            myMap[num]++;\n        }\n        //ä¼˜å…ˆé˜Ÿåˆ—ï¼Œé»˜è®¤ä¸ºé˜Ÿå¤´å…ƒç´ æœ€å¤§\n        priority_queue<Node>myQue;\n        for(auto [x,y]:myMap){\n            myQue.push(Node(x,y));\n        }\n        vector<int>res;\n        while(k--){\n            Node tmp=myQue.top();\n            res.push_back(tmp.key);\n            myQue.pop();\n        }\n        return res;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´å¤æ‚åº¦ï¼šo(nlogn)\n* ç©ºé—´å¤æ‚åº¦ï¼šo(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205340243","body":"### æ€è·¯\nä¸€æ¬¡éå†ï¼Œå“ˆå¸Œè¡¨è®°å½•è·ç¦»\n### ä»£ç \n```C++\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        //ä¸€å±‚forå¾ªç¯ï¼Œéå†æ¯ä¸€ä¸ªèŠ‚ç‚¹\n        int res=0;\n        for(auto p:points){\n            unordered_map<int,int>myMap;\n            for(auto q:points){\n                int dis=(p[0]-q[0])*(p[0]-q[0])+(p[1]-q[1])*(p[1]-q[1]);\n                myMap[dis]++;\n            }\n            for(auto [dis,cnt]:myMap){\n                res+=cnt*(cnt-1);\n            }\n        }\n        return res;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´å¤æ‚åº¦ï¼šo(n)\n* ç©ºé—´å¤æ‚åº¦ï¼šo(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205959512","body":"### æ€è·¯\nåŒæŒ‡é’ˆç»´æŠ¤ä¸€ä¸ªåŒºé—´ï¼Œå“ˆå¸Œè®°å½•è¿™ä¸ªåŒºé—´ï¼Œå¦‚æœå‡ºç°é‡å¤ï¼Œå·¦è¾¹ç•Œè°ƒæ•´\n### ä»£ç \n```C++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int res=0;\n        unordered_map<char,int>myMap;//intç”¨æ¥è®°å½•åæ ‡ä½ç½®\n        int left=0,right=0;\n        while(right<s.size()){\n            unordered_map<char,int>::iterator it=myMap.find(s[right]);\n            if(it!=myMap.end()){\n                if((it->second)>=left){\n                    left=(it->second)+1;\n                }\n            }\n            myMap[s[right]]=right;\n            res=max(res,right-left+1);\n            right++;\n        }\n        return res;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´å¤æ‚åº¦ï¼šo(n)\n* ç©ºé—´å¤æ‚åº¦ï¼šo(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207137731","body":"### æ€è·¯\nå“ˆå¸Œè¡¨æ•°ç»„ï¼Œå°†stringçœ‹åšæ•´ä½“ï¼Œåˆ†å‰²åŒ¹é…\n### ä»£ç \n```C++\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        //å°å†™å­—æ¯ï¼Œæ•°ç»„å“ˆå¸Œï¼Œ+æ»‘åŠ¨çª—å£ï¼Œ\n        vector<int>res;\n        int m=words.size(),n=words[0].size(),slen=s.size();\n        for(int i=0;i<n && i+m*n<=slen;i++){\n            unordered_map<string,int>differ;\n            for(int j=0;j<m;j++){\n                ++differ[s.substr(i+j*n,n)];\n            }\n            for(string word:words){\n                if(--differ[word]==0)differ.erase(word);\n            }\n            for(int start=i;start<slen-m*n+1;start+=n){\n                if(start!=i){\n                    string word=s.substr(start+(m-1)*n,n);\n                    if(++differ[word]==0)differ.erase(word);\n                    word=s.substr(start-n,n);\n                    if(--differ[word]==0)differ.erase(word);\n                }\n                if(differ.empty())res.push_back(start);\n            }\n        }\n        return res;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´å¤æ‚åº¦ï¼šo(slen*n)\n* ç©ºé—´å¤æ‚åº¦ï¼šo(m*n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207344730","body":"### æ€è·¯\nå‰ç¼€å’Œ+åŒä½™å®šç†\næ³¨æ„ç‚¹ï¼šï¼ˆ1ï¼‰long longå†…å­˜æº¢å‡ºï¼ˆ2ï¼‰åŠ å…¥å“¨å…µèŠ‚ç‚¹ï¼ˆ3ï¼‰æ­£è´Ÿæ•°å–ä½™æ•°\n### ä»£ç \n```C++\nclass Solution {\npublic:\n    int floorMod(const long long a,const int b){\n        return (a%b+b)%b;\n    }\n    int minSubarray(vector<int>& nums, int p) {\n        //å‰ç¼€å’Œ+åŒä½™å®šç†\n        //1ã€æœ‰è´Ÿæ•°ï¼Œå–ä½™æ•°è¦+å†é™¤\n        //2ã€å†…å­˜æº¢å‡ºï¼Œç”¨Longlong\n        //3ã€å“¨å…µèŠ‚ç‚¹\n        int res=nums.size();\n        long long total=0;\n        for(int num:nums){\n            total+=num;\n        }\n        int target=floorMod(total,p);\n        unordered_map<int,int>preSum;\n        preSum[0]=-1;\n        long long pre=0;\n        for(int i=0;i<nums.size();i++){\n            pre+=nums[i];\n            int curmod=floorMod(pre,p);\n            preSum[curmod]=i;\n            unordered_map<int,int>::iterator it=preSum.find(floorMod((curmod-target),p));\n            if(it!=preSum.end()){\n                res=min(res,i-(it->second));\n            }\n        }\n        return res==nums.size()?-1:res;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´å¤æ‚åº¦o(n)\n* ç©ºé—´å¤æ‚åº¦o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207565285","body":"### æ€è·¯\nå¿«æ…¢æŒ‡é’ˆ\n### ä»£ç \n```C++\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        //å¿«æ…¢æŒ‡é’ˆ\n        ListNode* fast=head,*slow=head;\n        while(fast!=nullptr && fast->next!=nullptr){\n            fast=fast->next->next;\n            slow=slow->next;\n        }\n        return slow;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´å¤æ‚åº¦ï¼šo(n)\n* ç©ºé—´å¤æ‚åº¦ï¼šo(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208767686","body":"### æ€è·¯\nå¿«æ…¢æŒ‡é’ˆ\n### ä»£ç \n```C++\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        //åŒæŒ‡é’ˆï¼Œå¿«æ…¢æŒ‡é’ˆ\n        int slow=0,fast=0;\n        while(fast<nums.size()){\n            if(nums[fast]>nums[slow]){\n                nums[++slow]=nums[fast];\n            }\n            fast++;\n        }\n        return slow+1;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´å¤æ‚åº¦ï¼šo(n)\n* ç©ºé—´å¤æ‚åº¦ï¼šo(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/42#issuecomment-1210039326","body":"### æ€è·¯\näºŒåˆ†ï¼Œå·¦é—­å³é—­åŒºé—´\n### ä»£ç \n```C++\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        //äºŒåˆ†ï¼Œå·¦é—­å³é—­ï¼Œæ— é‡å¤å…ƒç´ \n        int left=0,right=nums.size()-1;\n        int mid=0;\n        while(left<=right){\n            mid=left+(right-left)/2;\n            if(nums[mid]==target)return mid;\n            else if(nums[mid]<target){\n                left=mid+1;\n            }\n            else right=mid-1;\n        }\n        return left;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´å¤æ‚åº¦:o(n)\n* ç©ºé—´å¤æ‚åº¦:o(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ashleyyma6":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185118412","body":"### Idea\n\nInput: an int in array form **num**, an int **k** to add\nOutput: result in array form\n\n1. array to int, add k, int to array\n   ~~2. int k to array, add array~~\n\n### Code\n\n```python\n    def addToArrayForm(self, num, k):\n        # array to int\n        int_res = int(''.join(str(n) for n in num))\n        int_res+=k\n        # int to array\n        res = [int(n) for n in str(int_res)]\n        return res\n```\n\n**Complexity Analysis**\n\n- Time Complexity: O(n)+O(n) = O(n)\n- Space Complexity: O(1)+O(n) = O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186139244","body":"### Idea\n- 1st loop: find all indices of *c*\n- 2nd loop: get abs min for all elements in *s*\n### Code\n```python\ndef shortestToChar(self, s, c):\n        index = []\n        res = [0]*len(s)\n        for i in range(len(s)):\n            if s[i] == c:\n                index.append(i)\n        for i in range(len(s)):\n            if i in index:\n                res[i]=0\n            else:\n                res[i] = min([abs(i-x) for x in index])\n        return res\n```\n\n**Complexity Analysis**\n- Time Complexity: O(n^2)\n- Space Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186342266","body":"### Idea\n- array with 2 pointers\n- 1 pointer for stack top, help to judge if exceed max size\n- 1 pointer for stack base & increment function, help to judge if empty\n- check max & update base when push/pop\n- increment: compare k with current top index -> decide the number of element to update\n\n### Code\n\n```python\ndef __init__(self, maxSize):\n        self.stack = [0]*maxSize\n        self.max = maxSize-1 # max index\n        self.base = -1\n        self.top = -1\n\n    def push(self, x):\n        if self.top<self.max:\n            if(self.top<0):\n                self.base+=1\n            self.top+=1\n            self.stack[self.top]=x\n        \n    def pop(self):\n        if self.top>=0 :\n            res = self.stack[self.top]\n            self.stack[self.top] = 0\n            self.top-=1\n            if(self.top<0):\n                self.base-=1\n            return res\n        else:\n            return -1\n        \n    def increment(self, k, val):\n        if(self.base>=0):\n            if (self.top+1)>=k:\n                for i in range(k):\n                    self.stack[i]+=val\n            else:\n                for e in range(self.top+1):\n                    self.stack[e]+=val\n\n```\n\n**Complexity Analysis**\n- Time Complexity: \n  - push: O(1)\n  - pop:O(1)\n  - increment: O(n)\n- Space Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186642403","body":"### Idea\n1. Traverse *s*\n   1. push number to stack *num*\n   2. push [ & characters to stack *char*, until meet ]\n   3. when meet ], pop stack *char* & add characters together until meet [\n   4. pop the stack *num*,  decode characters, push result back to stack *char*\n2. return stack *char* content\n### Code\n\n```python\ndef decodeString(self, s):\n        num = []\n        char = []\n        i = 0\n        while i < len(s):\n            if s[i].isdigit():\n                n = \"\"\n                while(s[i].isdigit()):\n                    n+=s[i]\n                    i+=1\n                num.append(int(n))\n            elif s[i] == ']':\n                tmp = \"\"\n                while char[-1]!='[':\n                    tmp = char.pop()+tmp\n                char.pop()\n                tmp = tmp*num.pop()\n                char.append(tmp)\n                i+=1\n            else:\n                char.append(s[i])\n                i+=1\n        res = \"\"\n        while len(char)>0:\n            res = char.pop()+res\n        return res\n```\n\n**Complexity Analysis**\n\n- Time Complexity:O(n)+O(n)+O(n)=O(n)\n- Space Complexity:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188466203","body":"### Idea\n\n- push: push to stack1\n- pop: pop from stack2\n  - if stack2 is empty, move stack1 content to stack2 first\n- peek: return the first element of stack2\n  - if stack2 is empty, move stack1 content to stack2 first\n- empty: return if stack1 and stack2 all empty\n- check empty before pop, peek\n\n### Code\n\n```python\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1=[]\n        self.stack2=[]\n\n    def push(self, x):\n        self.stack1.append(x)\n\n    def pop(self):\n        if not self.empty():\n            if len(self.stack2)==0:\n                while len(self.stack1)>0:\n                    self.stack2.append(self.stack1[-1])\n                    self.stack1.pop(-1)\n            return self.stack2.pop()\n        else: return None\n\n    def peek(self):\n        if not self.empty():\n            if len(self.stack2)==0:\n                while len(self.stack1)>0:\n                    self.stack2.append(self.stack1[-1])\n                    self.stack1.pop(-1)\n            return self.stack2[-1]\n        else: return None\n\n    def empty(self):\n        return len(self.stack1)+len(self.stack2) == 0\n```\n\n**Complexity Analysis**\n\n- Time Complexity:\n  - push: O(1)\n  - pop: O(n)\n  - peek: O(n)\n  - empty: O(1)\n- Space Complexity: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189956971","body":"### Idea\n1. check if the left subarray is smaller than the right subarray, if smaller, get a new chunck\n2. Traversal, get the max of left subarray and the min of right subarray, compare\n\n### Code\n\n```python\ndef maxChunksToSorted(self, arr):\n\n    length = len(arr)\n    left = [0]*length\n    right = [0]*length\n    \n    for i in range(len(arr)):\n        if i == 0:\n            left[i]=arr[i]\n        else:\n            left[i]=max(left[i-1],arr[i])\n    \n    for i in reversed(range(len(arr))):\n        if i == length-1:\n            right[i]=arr[i]\n        else:\n            right[i]=min(right[i+1],arr[i])\n    res = 0\n    for i in range(len(arr)-1):\n        if left[i]<=right[i+1]:\n            res+=1\n    return res+1\n```\n\n**Complexity Analysis**\n\n- Time Complexity:O(n)+O(n)+O(n)=O(n)\n- Space Complexity:O(n)+O(n)=O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190940014","body":"### Idea\n- find the length of list, k%length to find the rotation needed\n- need to switch two sublists, list splits at length-k\n- one pointer for the end of right sublist\n- one pointer for the end of left sublist\n\n### Code\n\n```python\ndef rotateRight(self, head, k):\n    if k==0:\n        return head\n    if head==None or head.next==None:\n        return head\n    \n    length = 0\n    p1 = head\n    while p1 != None:\n        length+=1\n        p1 = p1.next\n        \n    rotate = k%length\n    \n    p1 = head\n    while rotate>0:\n        p1 = p1.next\n        rotate-=1\n    p2 = head\n    while p1.next!=None:\n        p1=p1.next\n        p2=p2.next\n    p1.next = head\n    head = p2.next\n    p2.next = None\n    return head\n\n```\n\n**Complexity Analysis**\n\n- Time Complexity: O(n)+O(n)=O(n)\n- Space Complexity: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192012753","body":"### Idea\n\n- need a pre head/pre pointer before the first node for node swap\n- need a pointer to mark the first node in the pair\n- need a temp pointer (always .next of the first node) for the second node in the pair to do node swap\n\n### Code\n\n```python\n        if(head == None or head.next == None):\n            return head\n\n        pre = ListNode(0)\n        pre.next = head\n\n        p0 = pre\n        p1 = head\n        while(p1!=None and p1.next!=None):\n            p2 = p1.next\n            p0.next = p2\n            p1.next = p2.next\n            p2.next = p1\n            p0=p0.next.next\n            p1=p1.next\n        return pre.next\n\n```\n\n**Complexity Analysis**\n\n- Time Complexity: O(n)\n- Space Complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193092616","body":"### Idea\n1. linked list -> array -> tree\n2. root of the tree/subtree is at middle of the array/subarray\n3. left/right subtree is build from left/right subarray\n\n\n### Code\n\n```python\n    def sortedListToBST(self, head):\n        arr = []\n        while head:\n            arr.append(head.val)\n            head = head.next\n        return self.buildTree(arr)\n    \n    def buildTree(self, arr):\n        if len(arr)==0:\n            return None\n        mid = len(arr)//2\n        root = TreeNode(arr[mid])\n        root.left = self.buildTree(arr[:mid])\n        root.right = self.buildTree(arr[mid+1:])\n        return root\n```\n\n**Complexity Analysis**\n\n- Time Complexity: O(n)\n- Space Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193250054","body":"### Idea\nTwo pointers traverse list A&B, stop when two pointers point to the same. When a pointer points to none, update pointer to point the head of another list. \nThe pointers will meet at the intersectin node or both are None (no intersaction). \n   \n### Code\n\n```python\n    def getIntersectionNode(self, headA, headB):\n        head1 = headA\n        head2 = headB\n        while head1 != head2:\n            head1 = head1.next if head1 else headB\n            head2 = head2.next if head2 else headA\n        return head1\n\n```\n\n**Complexity Analysis**\n\n- Time Complexity: O(2(n1+n2+n3))\n- Space Complexity: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193666754","body":"### Idea\n- Fast and slow pointer will meet if there is a loop. \n- If pointer points to None, there is no cycle. \n- After fast pointer and slow pointer meet, update fast pointer point to head. \n- Move fast and slow pointer one node at a time until they meet at the cycle entry. \n\n### Code\n\n```python\ndef detectCycle(self, head):\n        fast = head\n        slow = head\n        while fast != None and fast.next!=None:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                break\n        if fast==None or fast.next==None:\n            return None\n        fast = head\n        while fast!=slow:\n            fast=fast.next\n            slow=slow.next\n        return fast\n```\n\n**Complexity Analysis**\n\n- Time Complexity: O(n)\n- Space Complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195357139","body":"### Idea\n1. a dictionary to track the key and its node\n2. a linked list to manage LRU cache\n### Code\n\n```python\nclass ListNode(object):\n    def __init__(self, key, val):\n        self.key = key\n        self.val = val\n        self.next = None\n        self.pre = None\n    \nclass LRUCache(object):\n\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.size = 0\n        self.addr = {}\n        self.head = ListNode(-1,-1)\n        self.tail = ListNode(-1,-1)\n        self.head.next = self.tail\n        self.tail.pre = self.head\n\n    def get(self, key):\n        if key in self.addr:\n            node = self.addr[key]\n            self.remove(node)\n            self.add(node)\n            return node.val\n        else:\n            return -1\n\n    def put(self, key, value):\n        if key in self.addr:\n            node = self.addr[key]\n            node.val = value\n            self.remove(node)\n            self.add(node)\n        else:\n            node = ListNode(key,value)\n            self.addr[key] = node\n            self.add(node)\n            if(self.size<self.capacity):\n                self.size+=1\n            else:\n                tailKey = self.removeTail()\n                del self.addr[tailKey]\n\n    def remove(self, node):\n        pre = node.pre\n        nex = node.next\n        pre.next = nex\n        nex.pre = pre\n    \n    def add(self, node):\n        node.pre = self.head\n        node.next = self.head.next\n        self.head.next.pre = node\n        self.head.next = node\n        \n    def removeTail(self):\n        node = self.tail.pre\n        self.remove(node)\n        return node.key\n\n\n```\n\n**Complexity Analysis**\n\n- Time Complexity: O(1) for get, put\n- Space Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196324242","body":"### Idea\nFind the max between left child tree maxDepth and right child tree maxDepth, +1 to get the current node's maxDepth. \n\n### Code\n\n```python\n    def maxDepth(self, root):\n        if root == None:\n            return 0\n        res = 1 + max(self.maxDepth(root.left),self.maxDepth(root.right))\n        return res\n\n```\n\n**Complexity Analysis**\n\n- Time Complexity: O(n)\n- Space Complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197713696","body":"### Idea\r\nTraverse two trees together, compare their current nodes. \r\n### Code\r\n\r\n```python\r\n    def isSameTree(self, p, q):\r\n        if p == None and q == None:\r\n            return True\r\n        if p == None and q!= None:\r\n            return False\r\n        if p!= None and q == None:\r\n            return False\r\n        if (p.val==q.val):\r\n            return True and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n        else:\r\n            return False\r\n\r\n```\r\n\r\n**Complexity Analysis**\r\n\r\n- Time Complexity: O(n)\r\n- Space Complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198975519","body":"### Idea\r\n- An inner function to traverse the tree, use a variable to store result\r\n- Use a string to collect digits, convert back to int when find all digits\r\n- when the left and right children are none, a number is found\r\n\r\n### Code\r\n\r\n```python\r\ndef sumNumbers(self, root):\r\n        s = \"\"\r\n        res = [0]\r\n        def get_res(root, s):\r\n            s += str(root.val)\r\n            if root.left != None:\r\n                get_res(root.left, s)\r\n            if root.right != None:\r\n                get_res(root.right, s)\r\n            if root.left == None and root.right == None:\r\n                res[0]+=int(s)\r\n            return None\r\n        get_res(root,s)\r\n        return res[0]\r\n```\r\n\r\n**Complexity Analysis**\r\n\r\n- Time Complexity: O(n)\r\n- Space Complexity: O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200076924","body":"### Idea\n\nBFS, get the lowest level nodes, return the first one\n\n### Code\n\n```python\n def findBottomLeftValue(self, root):\n        res = None\n        arr = []\n        arr.append(root)\n        while len(arr):\n            curr = arr\n            arr = []\n            for i in range(len(curr)):\n                if(curr[i].left):\n                    arr.append(curr[i].left)\n                if(curr[i].right):\n                    arr.append(curr[i].right)\n            res = curr\n        return (res[0].val)\n```\n\n**Complexity Analysis**\n\n- Time Complexity: O(n)\n- Space Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200434367","body":"### Idea\n- Tree -> array str -> Tree\n- root -> Left subtree -> Right subtree, recursive\n\n### Code\n\n```python\ndef serialize(self, root):\n        res = []\n        def se(root):\n            if root == None:\n                res.append('null')\n                return res\n            curr = str(root.val)\n            res.append(curr)\n            se(root.left)\n            se(root.right)\n        se(root)\n        print(res)\n        return str(res)\n            \n    def deserialize(self, data):\n        data = data[1:-1].replace(\"'\",\"\").split(', ')\n        print(data)\n        def de(data):\n            if len(data)==1 and data[0]=='null':\n                return None\n            val = data[0]\n            data.remove(val)\n            if val=='null':\n                return None\n            root = TreeNode(int(val))\n            root.left = de(data)\n            root.right = de(data)\n            return root\n        \n        return de(data)\n\n```\n\n**Complexity Analysis**\n\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201140643","body":"### Idea\n- DFS, put all nodes in corresponding column list in tuple format (row, value)\n- use center_index to track root's 0th column list, do calculation to get other nodes' corresponding list\n- Get [[(row, value),(row, value)],[(row, value),(row, value)]]\n- For every sublist: Sort by row in (row, value) -> sort value if two row are the same\n\n### Code\n\n```python\n    def __init__(self):\n        self.center_index = 0\n        \n    def verticalTraversal(self, root):\n        res = []\n        tuple_list = []\n        def find_pos(root, row, col):\n            if root == None:\n                return None\n            if len(tuple_list) == 0:\n                new_list = [(row,root.val)]\n                tuple_list.append(new_list)\n                self.center_index = col\n            else:\n                need_list_index = self.center_index + col\n                if need_list_index<0:\n                    new_list = [(row,root.val)]\n                    tuple_list.insert(0,new_list)\n                    self.center_index+=1\n                elif need_list_index>=len(tuple_list):\n                    new_list = [(row,root.val)]\n                    tuple_list.append(new_list)\n                else:\n                    tuple_list[need_list_index].append((row,root.val))\n            find_pos(root.left, row+1, col-1)\n            find_pos(root.right, row+1, col+1)\n        find_pos(root,0,0)\n        for l in tuple_list:\n            res.append(self.sort_list(l))\n        return res\n    def sort_list(self, list):\n        list.sort()\n        pre_row = list[0][0]\n        res = []\n        temp = []\n        i = 0\n        print(list)\n        while i<len(list):\n            if pre_row == list[i][0]:\n                temp.append(list[i][1])\n                i+=1\n            else:\n                temp.sort()\n                res+=temp\n                temp = []\n                pre_row = list[i][0]\n        temp.sort()\n        res+=temp\n        return res\n```\n\n**Complexity Analysis**\n\n- Time Complexity: O(n)+O(n log n)+O(n log n) = O(n log n) (?)\n- Space Complexity: O(n)+O(n) = O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201861742","body":"### Idea\n- Traverse nums\n- If target - current number is not in the dictionary, add {current number : index} to the dictionary\n- If target - current number is in the dictionary, return the index of target - current number and current number\n### Code\n\n```python\ndef twoSum(self, nums, target):\n    dic = {}\n    for i in range(len(nums)):\n        if target-nums[i] in dic:\n            return [dic[target-nums[i]],i]\n        else:\n            dic[nums[i]]=i\n    return None\n\n```\n\n**Complexity Analysis**\n\n- Time Complexity: O(n)\n- Space Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203687775","body":"### Idea\n- Hash table {k:frequency}, count all numbers\n- Push hash table entry to a priority queue, keep the last k elements\n- Move queue entries to an integer ArrayList, transfer to int array\n\n### Code\n\n```java\npublic int[] topKFrequent(int[] nums, int k) {\n        HashMap<Integer,Integer> map = new HashMap();\n        for(int num:nums){\n            if(map.containsKey(num)){\n                map.put(num, map.get(num)+1);\n            }else{\n                map.put(num, 1);\n            }\n        }\n        PriorityQueue<Integer> heap = new PriorityQueue<Integer>((n1, n2)->map.get(n1)-map.get(n2));\n        for(int n : map.keySet()){\n            heap.add(n);\n            if(heap.size()>k){\n                heap.poll();\n            }\n        }\n        ArrayList<Integer> arr_list = new ArrayList();\n        while(!heap.isEmpty()){\n            arr_list.add(heap.poll());\n        }\n        Collections.reverse(arr_list);\n        int[] res = arr_list.stream().mapToInt(Integer::intValue).toArray();\n        return res;\n    }\n```\n\n**Complexity Analysis**\n\n- Time Complexity: O(n)+O(nlogn)+O(n) = O(nlogn)\n- Space Complexity: O(n)+O(n)+O(n) = O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204640529","body":"### Idea\n\n- Inputï¼šn points in a plain [x,y]\n- Goal: find boomerang - (i,j,k) ij=ik\n- Output: number of boomerangs\n- Distance between two points [x1,y1] [x2,y2] [x3,y3]\n  - root of (x2-x1)^2+(y2-y1)^2 compare with root of (x3-x2)^2+(y3-y2)^2\n  - Create a hash map for every point {distance:number of points}\n  - Traverse number of points, add to result\n\n### Code\n\n```java\npublic int numberOfBoomerangs(int[][] points) {\n        int res = 0;\n        for (int[] point1:points){\n            HashMap<Double, Integer> map = new HashMap<>();\n             for(int[] point2:points){\n                 double distance = Math.sqrt((point1[0]-point2[0])*(point1[0]-point2[0])+(point1[1]-point2[1])*(point1[1]-point2[1]));\n                 if(map.containsKey(distance)){\n                    map.replace(distance, map.get(distance)+1);\n                }else{\n                    map.put(distance,1);\n                }\n             }\n            Integer[] nums = new Integer[map.size()];\n            nums = map.values().toArray(nums);\n            for(Integer n:nums){\n                if(n.intValue()>1){\n                    res += (n.intValue() * (n.intValue()-1));\n                }\n            }\n\n        }\n        return res;\n    }\n```\n\n**Complexity Analysis**\n\n- Time Complexity: O(n^2)\n- Space Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205907869","body":"### Idea\n- Left, right pointer, Hash table save index of a character\n- Move right pointer, if character exists in table, update left pointer forward, update new index for right pointer character, update max length\n### Code\n\n```java\n public int lengthOfLongestSubstring(String s) {\n        if(s.length()<2){\n            return s.length();\n        }\n        HashMap<Character,Integer> map = new HashMap<>();\n        int left=-1;\n        int result = 0;\n        for(int i = 0;i<s.length();i++){\n            char current  = s.charAt(i);\n            if(map.containsKey(current)){\n                left = Math.max(map.get(current),left);\n            }\n            map.put(current,i);\n            result = Math.max(result,i-left);\n        }\n        return result;\n    }\n\n```\n\n**Complexity Analysis**\n\n- Time Complexity:O(n)\n- Space Complexity:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207124106","body":"### Idea\n\n- Find the length of word, as unit, the length of the string composed of words\n- Two Hash tables {word: frequency}\n- Count the word in words and its appearance times\n- One pointer to mark the start of the string, an inner pointer to check words in the string, count appearance times\n  - Break when meet word not in words, when appearance time exceeds\n  - Add result when the substring length match target length\n\n### Code\n\n```java\n\n HashMap<String, Integer> count_words = new HashMap<>();\n        for(String word:words){\n            if(count_words.containsKey(word)){\n                count_words.replace(word, count_words.get(word)+1);\n            }else{\n                count_words.put(word,1);\n            }\n        }\n\n        int word_unit = words[0].length();\n        int string_length = word_unit * words.length;\n\n        ArrayList<Integer> result = new ArrayList<>();\n\n        for(int i = 0; i<s.length()-string_length+1;i++){\n            HashMap<String, Integer> count = new HashMap<>();\n            for(int j = i; j<i+string_length;j+=word_unit){\n                String current_word = s.substring(j,j+word_unit);\n                if(!count_words.containsKey(current_word)){\n                    break;\n                }else{\n                     if(count.containsKey(current_word)){\n                        count.replace(current_word, count.get(current_word)+1);\n                        if(count.get(current_word) > count_words.get(current_word)){\n                            break;\n                        }\n                    }else{\n                        count.put(current_word,1);\n                    }\n                    if((j-i)==(string_length-word_unit)){\n                        result.add(i);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n```\n\n**Complexity Analysis**\n\n- Time Complexity: O(mn) // m = s.length, n = words.length\n- Space Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207404613","body":"### Idea\n- Find the remainder of nums\n- Traverse nums, get prefix sum and its remainder, add {num%k: num}\n  - If  the remainder of (prefix sum remainder -  nums sum remainder) is in map, the length of subarray to remove is i- the remainder index in map\n  - get minimum length as result\n\n### Code\n\n```python\ndef minSubarray(self, nums, p):\n        res = len(nums)\n        sum_r = sum(nums)%p\n        hash_map = {0:-1}\n        \n        if sum_r == 0:\n            return 0\n        \n        prefix_sum = 0\n        for i in range(len(nums)):\n            prefix_sum+=nums[i]\n            remainder = prefix_sum%p\n            if (remainder-sum_r)%p in hash_map:\n                res = min(res, i-hash_map[(remainder-sum_r)%p])\n            hash_map[remainder]=i\n        \n        if res<len(nums):\n            return res\n        else:\n            return -1\n\n```\n\n**Complexity Analysis**\n\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207509400","body":"### Idea\n- fast pointer move two nodes at a time, slow pointer move one node at a time\n- when faster pointer reaches the end, slow pointer is in the middle.\n\n### Code\n\n```python\n    public ListNode middleNode(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast!= null && fast.next != null){\n            fast = fast.next.next;\n            slow=slow.next;\n        }\n        return slow;\n    }\n```\n\n**Complexity Analysis**\n\n- Time Complexity: O(n)\n- Space Complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208697353","body":"### Idea\n\n- one pointer mark the index of the last put number\n- one pointer to traverse array nums\n- when current checking number is different from last put number = meet a new number -> put the new number\n\n### Code\n\n```java\npublic int removeDuplicates(int[] nums) {\n    int put = 0;\n    for(int i = 0;i<nums.length;i++){\n        if(nums[put]!=nums[i]){\n            put++;\n            nums[put]=nums[i];\n        }\n    }\n    return put+1;\n}\n```\n\n**Complexity Analysis**\n\n- Time Complexity: O(n)\n- Space Complexity: O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuki-yzy":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185123309","body":"# æ€è·¯\n\nå°†numä¸kæœ«ä½ç›¸åŠ ï¼ŒåŠ åˆ°kä¸Šï¼Œkä¸­è‡ªåŠ¨è¿›ä½ï¼Œåªéœ€å°†kå–ä½™æ”¾å…¥æ•°ç»„ä¸­å³å¯\n\n# ä»£ç \n\n\n```js\nvar addToArrayForm = function(num, k) {\n    let res = []\n    let len = num.length - 1\n    while(len >= 0 || k > 0) {\n        if(len >= 0) {\n            k += num[len]\n            len--\n        }\n        res.push(k % 10)\n        k = parseInt(k / 10)\n    }\n    return res.reverse()\n};\n```\n\n# å¤æ‚åº¦\n\næ—¶é—´ï¼šO(n)\n\nç©ºé—´ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186075915","body":"# æ€è·¯\n\nä»S[i]ä½ç½®å¼€å§‹ï¼Œåˆ†åˆ«å‘å·¦å’Œå‘å³è¿›è¡Œæœç´¢ï¼Œå–æœ€å°è·ç¦»å­˜åˆ°æ•°ç»„ä¸­\n\n# ä»£ç \n\n```js\nvar shortestToChar = function (S, C) {\n  var res = Array(S.length).fill(0);\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) continue;\n    let l = i,r = i,min = Infinity;\n    while (l >= 0) {\n      if (S[l] === C) {\n        min = Math.min(min, i - l);\n        break;\n      }\n      l--;\n    }\n    while (r < S.length) {\n      if (S[r] === C) {\n        min = Math.min(min, r - i);\n        break;\n      }\n      r++;\n    }\n    res[i] = min;\n  }\n  return res;\n};\n```\n\n# å¤æ‚åº¦\n\næ—¶é—´ï¼šO(n)\n\nç©ºé—´ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186353755","body":"# æ€è·¯\n\nè®¾ç½®æœ€å¤§å®¹é‡ï¼Œç»´æŠ¤ä¸€ä¸ªstack\n\n# ä»£ç \n\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize\n    this.stack =[]\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stack.length >= this.maxSize) {\n        return\n    }\n    this.stack.push(x)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    return this.stack.length ? this.stack.pop() : -1\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let len = Math.min(k,this.stack.length)\n    for(let i = 0;i < len;i++) {\n        this.stack[i] += val\n    }\n};\n```\n\n# å¤æ‚åº¦\n\næ—¶é—´:O(n)\n\nç©ºé—´:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187084895","body":"# æ€è·¯\n\né‡åˆ° [ æ•°å­—å­—æ¯åˆ†åˆ«å…¥æ ˆï¼Œé‡åˆ° ] æ ˆé¡¶å…ƒç´ å‡ºæ ˆ\n\n# ä»£ç \n\n```js\nconst decodeString = (s) => {\n    let numStack = [];        \n    let strStack = [];       \n    let num = 0;              \n    let result = '';          \n    for (const char of s) {   \n        if (!isNaN(char)) {  \n            num = num * 10 + Number(char); \n        } else if (char == '[') {  \n            strStack.push(result); \n            result = '';           \n            numStack.push(num);   \n            num = 0;              \n        } else if (char == ']') {  \n            let repeatTimes = numStack.pop(); \n            result = strStack.pop() + result.repeat(repeatTimes); \n        } else {                   \n            result += char;       \n        }\n    }\n    return result;\n};\n\n```\n\n# å¤æ‚åº¦\n\næ—¶é—´:O(n)\nç©ºé—´:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188499267","body":"# æ€è·¯\n\nåŒæ ˆæ¨¡æ‹Ÿ\n\n# ä»£ç \n\n```js\nvar MyQueue = function() {\n    this.stackIn = []\n    this.stackOut = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.stackIn.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    const size = this.stackOut.length\n    if(size) {\n        return this.stackOut.pop()\n    }\n    while(this.stackIn.length) {\n        this.stackOut.push(this.stackIn.pop())\n    }\n    return this.stackOut.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    const x = this.pop();\n    this.stackOut.push(x);\n    return x;\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n     return !this.stackIn.length && !this.stackOut.length\n};\n```\n\n# å¤æ‚åº¦\n\næ—¶é—´ï¼šO(1)\n\nç©ºé—´ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189726069","body":"# æ€è·¯\n\nä½¿ç”¨æ»‘åŠ¨çª—å£ï¼Œå› ä¸ºåŸæ•°ç»„ä¸åˆ†å—åå—çš„ä½ç½®ç›¸åŒï¼Œå¯ä»¥é€šè¿‡åŠ æ³•æ±‚å’Œè¿›è¡Œåˆ†å—\n\n# ä»£ç \n\n```js\nvar maxChunksToSorted = function(arr) {\n    const sortArr = [...arr];\n    sortArr.sort((a, b) => a - b);\n    let count = 0,sum1 = 0,sum2 = 0;\n    for (let i = 0; i < arr.length; i++) {\n        sum1 += arr[i];\n        sum2 += sortArr[i];\n        if (sum1 === sum2) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n\n# å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦:O(nlogn)\n\nç©ºé—´å¤æ‚åº¦:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191528462","body":"# æ€è·¯\n\næŠŠé“¾è¡¨é¦–å°¾ç›¸æ¥æˆç¯åï¼Œä»å¤´å¼€å§‹å¾€ä¸‹éå†len - k % lenæ¬¡ï¼Œåˆ‡æ–­ len - k -1ä¸ªç»“ç‚¹åˆ°len - kèŠ‚ç‚¹çš„è¿æ¥ï¼Œè¿”å›èŠ‚ç‚¹len - kå³å¯ã€‚\n\n# ä»£ç \n\n```js\nvar rotateRight = function (head, k) {\n    if (!head || k === 0) return head; \n    let p = head, len = 1;\n    while (p.next) {\n        p = p.next;\n        len++;\n    }\n    p.next = head; \n    k = len - k % len; \n    while (k--) p = p.next;\n    head = p.next;  \n    p.next = null; \n    return head;\n};\n```\n\n# å¤æ‚åº¦\n\næ—¶é—´:O(n)\n\nç©ºé—´:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192541477","body":"# æ€è·¯\n\nå®šä¹‰è™šå¤´èŠ‚ç‚¹ï¼Œè¿›è¡Œäº¤æ¢\n\n# ä»£ç \n\n```js\nvar swapPairs = function(head) {\n    let ret = new ListNode(0,head) \n    let temp = ret\n    while(temp.next && temp.next.next) {\n        let pre = temp.next\n        let cur = pre.next\n        pre.next = cur.next\n        cur.next = pre\n        temp.next = cur\n        temp = pre\n    }\n    return ret.next\n};\n```\n\n# å¤æ‚åº¦\n\næ—¶é—´:O(1)\n\nç©ºé—´:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193114398","body":"# æ€è·¯\n\nä¸­åºéå†\n\n# ä»£ç \n\n```js\nvar sortedListToBST = function(head) {\n    if (head === null) return null;\n    return help([head], 0, countSize(head)-1);\n};\n\nfunction countSize(head) {\n    let count = 0;\n    while (head !== null) {\n        count++;\n        head = head.next;\n    }\n    return count;\n}\n\nfunction help(arr, left, right) {\n    if (left > right) return null;\n    let mid = Math.floor((left + right) / 2);\n    let leftNode = help(arr, left, mid-1);\n    let node = new TreeNode(arr[0].val);\n    arr[0] = arr[0].next;\n    let rightNode = help(arr, mid+1, right);\n    node.left = leftNode;\n    node.right = rightNode;\n    return node;\n}\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193324451","body":"# æ€è·¯\n\nä½¿ç”¨å“ˆå¸Œé›†åˆå­˜å‚¨é“¾è¡¨èŠ‚ç‚¹\n\n# ä»£ç \n\n```js\nvar getIntersectionNode = function(headA, headB) {\n    const visited = new Set();\n    let temp = headA;\n    while (temp !== null) {\n        visited.add(temp);\n        temp = temp.next;\n    }\n    temp = headB;\n    while (temp !== null) {\n        if (visited.has(temp)) {\n            return temp;\n        }\n        temp = temp.next;\n    }\n    return null;\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194008638","body":"# æ€è·¯\n\néå†é“¾è¡¨ï¼Œå°†èŠ‚ç‚¹åŠ å…¥ä¸€ä¸ªsetä¸­ï¼Œæ¯æ¬¡åˆ¤æ–­å½“å‰èŠ‚ç‚¹æ˜¯å¦åœ¨setä¸­ï¼Œå¦‚æœå­˜åœ¨é‡å¤çš„èŠ‚ç‚¹ï¼Œè¿™ä¸ªèŠ‚ç‚¹å°±æ˜¯å…¥ç¯èŠ‚ç‚¹\n\n# ä»£ç \n\n```js\nvar detectCycle = function(head) {\n    const visited = new Set();\n    while (head !== null) {\n        if (visited.has(head)) {\n            return head;\n        }\n        visited.add(head);\n        head = head.next;\n    }\n    return null;\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196833319","body":"# æ€è·¯\n\né€’å½’\n\n# ä»£ç \n\n```js\nvar maxDepth = function(root) {\n    if (root === null) return 0;\n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right))\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198054620","body":"# æ€è·¯\n\né€’å½’åˆ¤æ–­å·¦å³èŠ‚ç‚¹\n\n# ä»£ç \n\n```js\nvar isSameTree = function(p, q) {\n    if(p == null && q == null) {\n        return true\n    }\n    if(p == null || q == null) {\n        return false\n    }\n    if(p.val != q.val) {\n         return false\n    }\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199128220","body":"# æ€è·¯\n\né¦–å…ˆæŠŠå½“å‰èŠ‚ç‚¹çš„å·¦å³å­æ ‘çš„å€¼æ›´æ–°ï¼Œç„¶åé€’å½’å·¦å³å­æ ‘ï¼Œç„¶åå·¦å³å­æ ‘çš„å’Œå³å¯\n\n# ä»£ç \n\n```js\nfunction sumNumbers(root: TreeNode | null): number {\n    if(!root) return 0;\n    if(!(root.left || root.right)) return root.val;\n   if(root.left){\n       root.left.val = root.val*10+root.left.val\n   }\n    if(root.right){\n       root.right.val = root.val*10+root.right.val\n   }\n   return sumNumbers(root.left) + sumNumbers(root.right)\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200220138","body":"# æ€è·¯\n\nå¹¿åº¦ä¼˜å…ˆæœç´¢\n\n# ä»£ç \n\n```js\nvar findBottomLeftValue = function(root) {\n    let ret = 0;\n    const queue = [root];\n    while (queue.length) {\n        const p = queue.shift();\n        if (p.right) {\n            queue.push(p.right);\n        }\n        if (p.left) {\n            queue.push(p.left);\n        }\n        ret = p.val;\n    }\n    return ret;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zpc7":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185132808","body":"### æ€è·¯\nä¸€å¼€å§‹æ²¡è€ƒè™‘åˆ°å¤§æ•°çš„è¿ç®—ä¼šä¸¢å¤±ç²¾åº¦, è¿˜è¯´é¢˜ç›®ç®€å•;\nå‚è€ƒçš„é¢˜è§£ç”¨äº†é€šç”¨çš„æ–¹æ³•\n### ä»£ç  TS\n```ts\n// ä¸€å¼€å§‹æ²¡æœ‰è€ƒè™‘åˆ°å¤§æ•°è®¡ç®—çš„è¿›åº¦ä¸¢å¤±æƒ…å†µ, ä½¿ç”¨äº†ä¸‹é¢çš„å†™æ³•\n// function addToArrayForm(num: number[], k: number): number[] {\n//     const sum: number = Number(num.join('')) + k;\n\n//     return (sum + '').split('').map(item => Number(item));\n// };\n\nvar addToArrayForm = function (num: number[], k: number): number[] {\n    const res = [];\n    const n = num.length;\n\n    // ä»ä½ä½åŠ åˆ°é«˜ä½, æ‰€ä»¥é‡‡ç”¨ä»å¤§åˆ°å°çš„é¡ºåºå¾ªç¯\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n\n        // éœ€è¦è¿›ä½çš„æƒ…å†µ, å°†è¿›ä½åŠ åœ¨Kä¸Š, ä¾¿äºä¸‹ä¸€æ¬¡å¾ªç¯\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    // è€ƒè™‘numsæ¯”è¾ƒå°, Kæ¯”è¾ƒå¤§çš„æƒ…å†µ, å¾ªç¯ç»“æŸå, Kè¿˜æœ‰å€¼, ä¾‹å¦‚:111+88888, éœ€è¦å°†ä»–è¡¥å……å›æ•°ç»„\n    while (k > 0) {\n        res.push(k % 10);\n        k = Math.floor(k / 10)\n    }\n    // ä¸é‡‡ç”¨åè½¬çš„è¯, æ¯æ¬¡éƒ½éœ€è¦åœ¨æ•°ç»„æœ€å‰é¢æ’å€¼(shift), æ—¶é—´å¤æ‚åº¦é«˜\n    return res.reverse();\n};\n```\n### å¤æ‚åº¦\næ—¶é—´ O(n)\nç©ºé—´ O(1) ? ä¸å¤ªç¡®å®š, æ²¡å¤ªææ‡‚ç©ºé—´å¤æ‚åº¦çš„åˆ†æ, æ±‚å¤§ä½¬è§£ç­”","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186154745","body":"## æ€è·¯\nå…ˆå­˜ä¸‹æ‰€æœ‰çš„cåœ¨åŸæ•°ç»„ä¸­çš„ä½ç½®; ç„¶åéå†çš„æ—¶å€™, å¯¹æ¯”è·ç¦»å–å¾—æœ€å°å€¼\n## ä»£ç  TS\n```ts\nfunction shortestToChar(s: string, c: string): number[] {\n    // å­˜å‚¨åŒ¹é…å­—ç¬¦'c'åœ¨åŸæ•°ç»„ä¸­çš„ç´¢å¼•\n    const indexArr: number[] = [];\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === c) {\n            indexArr.push(i);\n        }\n    }\n\n    const res = [];\n\n    // è®¡ç®—sçš„æ¯ä¸€é¡¹ç´¢å¼•, ä¸indexArrç»å¯¹å€¼, ç„¶åå–æœ€å°çš„\n    for (let index = 0; index < s.length; index++) {\n        if (s[index] === c) {\n            res[index] = 0;\n        } else {\n            const indexDistanceArr: number[] = indexArr.map(item => Math.abs(item - index));\n            res[index] = Math.min(...indexDistanceArr);\n        }\n    }\n\n    return res\n};\n```\n## å¤æ‚åº¦\næ—¶é—´: O(n2)\nç©ºé—´: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186467029","body":"## æ€è·¯\nåˆ©ç”¨æ•°ç»„å®ç°, éš¾åº¦ç®€å•\n## ä»£ç  TS\n```ts\nclass CustomStack {\n    maxSize: number;\n    stack: number[];\n\n    constructor(maxSize: number) {\n        this.maxSize = maxSize;\n        this.stack = [];\n    }\n\n    push(x: number): void {\n        const length = this.stack.length;\n        if (length < this.maxSize) {\n            this.stack.push(x);\n        }\n    }\n\n    pop(): number {\n        const length = this.stack.length;\n        if (length === 0) return -1;\n        return this.stack.pop()\n    }\n\n    increment(k: number, val: number): void {\n        const length = this.stack.length;\n        for (let i = 0; i < Math.min(length, k); i++) {\n            this.stack[i] += val\n        }\n\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n## å¤æ‚åº¦\næ—¶é—´: O(n)(ç¡®åˆ‡åœ°è¯´: Math.min(N, K)) ç©ºé—´O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186563811","body":"## æ€è·¯\n\nå®åœ¨æ²¡åšå‡ºæ¥, æ€è·¯å¤ªæ··ä¹±äº†, å‚è€ƒå¤§ä½¬çš„[é¢˜è§£](https://leetcode.cn/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/), ç¿»è¯‘äº†ä¸€ä¸ª `TS` çš„ç‰ˆæœ¬\n\n## ä»£ç  TS\n```ts\nfunction decodeString(s: string): string {\n    let stack = [], str = '', multi = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === '[') {\n            stack.push([multi, str]);\n            str = '';\n            multi = 0;\n        } else if (s[i] === ']') {\n            let [currentMulti, lastStr] = stack.pop();\n            str = lastStr + str.repeat(currentMulti);\n        } else if ('0' <= s[i] && s[i] <= '9') {\n            multi = multi * 10 + Number(s[i]);\n        } else {\n            str += s[i]\n        }\n    }\n    return str;\n};\n```\n## å¤æ‚åº¦\næ—¶é—´:O(n) ç©ºé—´ O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188630937","body":"## æ€è·¯\nè¿™ä¸ªé¢˜ç›®ç®€å•, ä½†æ˜¯éœ€è¦æ³¨æ„åªèƒ½ä½¿ç”¨æŒ‡å®šç±»å‹çš„API\n## ä»£ç  TS\n```ts\nclass MyQueue {\n    stack: number[] = [];\n    constructor() {\n\n    }\n\n    push(x: number): void {\n        this.stack.push(x)\n    }\n\n    pop(): number {\n        let tempArray = [];\n        const removedItem = this.stack[0];\n        for (let i = 1; i < this.stack.length; i++) {\n            tempArray.push(this.stack[i])\n        }\n        this.stack = tempArray\n        return removedItem\n    }\n\n    peek(): number {\n        return this.stack[0];\n    }\n\n    empty(): boolean {\n        return !this.stack.length;\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n## å¤æ‚åº¦\næ—¶é—´: O(n) ç©ºé—´ O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190446229","body":"## æ€è·¯\næ²¡åšå‡ºæ¥, å‚è€ƒäº†é¢˜è§£\n##  ä»£ç  PY3\n```python\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        count = collections.defaultdict(int)\n        ans = nonzero = 0\n\n        for x, y in zip(arr, sorted(arr))\n            count[x] += 1\n            if count[x] == 0: nonzero -= 1\n            if count[x] == 1: nonzero += 1\n\n            count[y] -= 1\n            if count[y] == -1: nonzero += 1\n            if count[y] == 0: nonzero -= 1\n\n            if nonzero == 0: ans += 1\n\n        return ans\n\n```\n## å¤æ‚åº¦\næ—¶é—´: O(NlogN)\nç©ºé—´: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191622404","body":"## æ€è·¯\né“¾è¡¨æˆç¯, ç§»åŠ¨ä½ç½®: å‘å³ç§»åŠ¨K, ç­‰äºå°†å€’æ•°ç¬¬Kä¸ªæ”¾åœ¨ç¬¬ä¸€ä½\n## ä»£ç  TS\n```ts\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n    // é“¾è¡¨ä¸ºç©º,æˆ–é“¾è¡¨çš„é•¿åº¦ä¸º1, æˆ–ç§»åŠ¨çš„ä½ç½®æ•°å€¼ä¸º0, è¿”å›åŸé“¾è¡¨\n    if (head === null || head.next === null || k === 0) return head;\n    // ç»Ÿè®¡é“¾è¡¨çš„é•¿åº¦\n    let length = 1;\n    let currentHead = head;\n    while (currentHead.next !== null) {\n        length += 1;\n        currentHead = currentHead.next;\n    }\n    // å¦‚æœç§»åŠ¨ä½ç½®Kçš„æ•°å€¼æ˜¯é“¾è¡¨çš„é•¿åº¦æ•´æ•°å€, åˆ™ç§»åŠ¨å‰åä¸å˜\n    if (k % length === 0) return head;\n    // å°†é“¾è¡¨æˆç¯, æœ€åä¸€é¡¹çš„ next æŒ‡å‘ç¬¬ä¸€é¡¹\n    // æ³¨æ„: currentHeadåœ¨ä¸Šé¢çš„whileå¾ªç¯ç»“æŸå, æŒ‡å‘é“¾è¡¨çš„æœ€åä¸€é¡¹\n    currentHead.next = head;\n    // æ ¹æ®è§„åˆ™, åœ¨åˆé€‚çš„åœ°æ–¹, å°†é“¾è¡¨æ–­å¼€\n    let add = length - k % length;\n    while (add) {\n        currentHead = currentHead.next;\n        add--;\n        console.log('currentHead:', currentHead)\n    }\n\n    const result = currentHead.next;\n    currentHead.next = null;\n    return result;\n};\n```\n## å¤æ‚åº¦\næ—¶é—´ O(n) ç©ºé—´O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192698519","body":"## æ€è·¯\né€’å½’\n## ä»£ç  JS \n```js\nvar swapPairs = function(head) {\n    if (head === null|| head.next === null) {\n        return head;\n    }\n    const newHead = head.next;\n    head.next = swapPairs(newHead.next);\n    newHead.next = head;\n    return newHead;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193141166","body":"```ts\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     val: number\r\n *     next: ListNode | null\r\n *     constructor(val?: number, next?: ListNode | null) {\r\n *         this.val = (val===undefined ? 0 : val)\r\n *         this.next = (next===undefined ? null : next)\r\n *     }\r\n * }\r\n */\r\n\r\n/**\r\n * Definition for a binary tree node.\r\n * class TreeNode {\r\n *     val: number\r\n *     left: TreeNode | null\r\n *     right: TreeNode | null\r\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\r\n *         this.val = (val===undefined ? 0 : val)\r\n *         this.left = (left===undefined ? null : left)\r\n *         this.right = (right===undefined ? null : right)\r\n *     }\r\n * }\r\n */\r\n\r\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\r\n\r\n    const arr = [];\r\n    while (head) { // å°†é“¾è¡¨èŠ‚ç‚¹çš„å€¼é€ä¸ªæ¨å…¥æ•°ç»„arr\r\n        arr.push(head.val);\r\n        head = head.next;\r\n    }\r\n    // æ ¹æ®ç´¢å¼•startåˆ°endçš„å­æ•°ç»„æ„å»ºå­æ ‘\r\n    const buildBST = (start, end) => {\r\n        if (start > end) return null;        // æŒ‡é’ˆäº¤é”™ï¼Œå½¢æˆä¸äº†å­åºåˆ—ï¼Œè¿”å›nullèŠ‚ç‚¹\r\n        const mid = Math.floor((start + end) / 2);     // æ±‚ä¸­é—´ç´¢å¼• ä¸­é—´å…ƒç´ æ˜¯æ ¹èŠ‚ç‚¹çš„å€¼, è¿™é‡Œå¯ä»¥æŸ¥è€ƒå¶æ•°ä½¿ç”¨å·¦è¾¹æˆ–å³è¾¹\r\n        const root = new TreeNode(arr[mid]); // åˆ›å»ºæ ¹èŠ‚ç‚¹\r\n        root.left = buildBST(start, mid - 1); // é€’å½’æ„å»ºå·¦å­æ ‘\r\n        root.right = buildBST(mid + 1, end);  // é€’å½’æ„å»ºå³å­æ ‘\r\n        return root;                          // è¿”å›å½“å‰å­æ ‘\r\n    };\r\n\r\n    return buildBST(0, arr.length - 1);  // æ ¹æ®æ•´ä¸ªarræ•°ç»„æ„å»º\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193326133","body":"## æ€è·¯\nç”¨æ•°ç»„å­˜å‚¨,ç„¶åå†æ‰¾æœ‰æ²¡æœ‰è‚¯å®šå¯ä»¥è§£å†³,ä¸è¿‡æˆ‘çœ‹éƒ½åœ¨è¯´åŒæŒ‡é’ˆ\nå‡è®¾é“¾è¡¨Aèµ°xæ­¥,é“¾è¡¨Bèµ°yæ­¥, åœ¨Aèµ°åˆ°æœ«å°¾çš„æ—¶å€™, æˆ‘ä»¬å°†ä»–æŒ‡å‘B, å°±ç›¸å½“äºä¸€ä¸ªç¯, ä¸€ä¸ªé¡ºæ—¶é’ˆ,ä¸€ä¸ªé€†æ—¶é’ˆ, æœ€ç»ˆéƒ½ä¼šç›¸é‡\n## ä»£ç  TS\n```ts\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {\n    if (headA === null || headB === null) {\n        return null;\n    }\n    let currentHeadA = headA;\n    let currentHeadB = headB;\n    while (currentHeadA !== currentHeadB) {\n        currentHeadA = currentHeadA === null ? headB : currentHeadA.next;\n        currentHeadB = currentHeadB === null ? headA : currentHeadB.next;\n    }\n    return currentHeadA;\n};\n```\n## å¤æ‚åº¦\næ—¶é—´O(m+n) ç©ºé—´O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194170654","body":"## æ€è·¯\nå€Ÿç”¨Set å­˜å‚¨èµ°è¿‡çš„èŠ‚ç‚¹\n## ä»£ç  TS\n```ts\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction detectCycle(head: ListNode | null): ListNode | null {\n    if (head === null || head.next === null) {\n        return null;\n    }\n    let list = new Set();\n\n    let current = head;\n    while (!list.has(current) && current !== null) {\n        list.add(current);\n        current = current.next;\n    }\n\n    return current;\n};\n```\n## å¤æ‚åº¦\næ—¶é—´: O(n) ç©ºé—´O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195648461","body":"## ä»£ç \n```ts\nclass LRUCache {\n  capacity: number\n  map: Map<number, number> = new Map()\n\n  constructor(capacity: number) {\n    this.map = new Map()\n    this.capacity = capacity\n  }\n\n  get(key: number): number {\n    if (this.map.has(key)) {\n      let value = this.map.get(key)\n      this.map.delete(key)\n      this.map.set(key, value)\n      return value\n    } \n    return -1\n  }\n\n  put(key: number, value: number): void {\n    if (this.map.has(key)) {\n      this.map.delete(key)\n    }\n\n    this.map.set(key, value)\n\n\n    if (this.map.size > this.capacity) {\n      this.map.delete(this.map.keys().next().value)\n    }\n  }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196176492","body":"## æ€è·¯\né€’å½’å·¦å³å­æ ‘, ç„¶åå–æœ€å¤§å€¼\n## ä»£ç  TS\n```ts\nfunction maxDepth(root: TreeNode | null): number {\n    if (root === null) return 0;\n\n    const leftDepth = maxDepth(root.left);\n    const rightDepth = maxDepth(root.right);\n\n    return Math.max(leftDepth, rightDepth) + 1\n};\n```\n## å¤æ‚åº¦\næ—¶é—´: O(n) ç©ºé—´O(h) nä¸ºèŠ‚ç‚¹æ ‘ hä¸ºæ ‘çš„é«˜åº¦","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198126379","body":"é€’å½’çš„æ€è·¯æ˜¯ å–ä¸€ä¸ªæœ€å°å­æ ‘ ç„¶åç½—åˆ—ä»–çš„åœºæ™¯\n## ä»£ç  TS\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\n    // æå–æœ€å°çš„å­æ ‘, åˆ†æé€»è¾‘\n    if (p === null && q === null) return true; // éƒ½ä¸ºç©ºèŠ‚ç‚¹\n    if (p === null || q === null) return false;// 2ä¸ªèŠ‚ç‚¹ä¸­æœ‰ä¸€ä¸ªæ˜¯ç©ºèŠ‚ç‚¹ \n    if (p.val !== q.val) return false; // èŠ‚ç‚¹å€¼ä¸åŒ\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199278443","body":"## æ€è·¯\nè¦ç†Ÿæ‚‰é€’å½’çš„å¥—è·¯\n## ä»£ç TS\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction sumNumbers(root: TreeNode | null): number {\n    const dfs = (root: TreeNode | null, prevSum: number): number => {\n        // å‡ºç°nullçš„æƒ…å†µ, å‚è€ƒdfs(root.left, sum) + dfs(root.right, sum)\n        // ä¾‹å¦‚ æŸä¸ªæ ‘åªæœ‰å·¦èŠ‚ç‚¹, å°±ä¼šå‡ºç°å³èŠ‚ç‚¹æ˜¯null, åœ¨ä¸‹ä¸€æ¬¡å¯¹å³èŠ‚ç‚¹çš„é€’å½’å°±éœ€è¦ç‰¹æ®Šåˆ¤æ–­\n        if (root === null) {\n            return 0;\n        }\n        // ä¸Šä¸€æ¬¡çš„èŠ‚ç‚¹ä¹˜ä»¥10, è¯´æ˜ä¸‹é’»åˆ°æ·±ä¸€ä¸ªå±‚çº§äº†\n        // ä¾‹å¦‚æ ‘[4,9,0], ä¸Šä¸€çº§prevSumæ˜¯4, å½“èµ°åˆ°9çš„æ—¶å€™å°±æ˜¯4*10+9 = 49äº†\n        const sum = prevSum * 10 + root.val;\n        // å·¦å³å­èŠ‚ç‚¹éƒ½æ˜¯null, è¯´æ˜å½“å‰çš„rootæ˜¯å¶å­ç»“ç‚¹, è¿”å›\n        if (root.left == null && root.right == null) {\n            return sum;\n        } else {\n            // å½“å‰rootèŠ‚ç‚¹ä¸æ˜¯å¶å­èŠ‚ç‚¹, è¿˜éœ€è¦å¯¹ä»–çš„å·¦å³å­æ ‘é€’å½’éå†\n            return dfs(root.left, sum) + dfs(root.right, sum);\n        }\n    }\n\n    return dfs(root, 0);\n};\n```\n## å¤æ‚åº¦\næ—¶é—´ O(n) ç©ºé—´O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200224889","body":"## ä»£ç  js\n\n```js\nvar findBottomLeftValue = function(root) {\n    const dfs = (root, height) => {\n        if (!root) {\n            return;\n        }\n        height++;\n        dfs(root.left, height);\n        dfs(root.right, height);\n        if (height > curHeight) {\n            curHeight = height;\n            curVal = root.val;\n        }\n    }\n\n    let curHeight = 0;\n    dfs(root, 0);\n    return curVal;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200363375","body":"æ²¡åšå‡ºæ¥, è¿˜æ˜¯æ²¡ç†è§£åˆ°é€’å½’çš„æ€æƒ³\n## ä»£ç  js\nåºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸²:\n```js\nconst serialize = (root) => {\n  if (root == null) {                  // éå†åˆ° null èŠ‚ç‚¹\n    return 'X';\n  }\n  const left = serialize(root.left);   // å·¦å­æ ‘çš„åºåˆ—åŒ–ç»“æœ\n  const right = serialize(root.right); // å³å­æ ‘çš„åºåˆ—åŒ–ç»“æœ\n  return root.val + ',' + left + ','+ right; // æŒ‰  æ ¹,å·¦,å³  æ‹¼æ¥å­—ç¬¦ä¸²\n};\n\n```\n\nååºåˆ—åŒ–ä¸ºæ ‘ç»“æ„:\n\n```js\nconst deserialize = (data) => {\n  const list = data.split(',');   // splitæˆæ•°ç»„\n\n  const buildTree = (list) => {   // åŸºäºlistæ„å»ºå½“å‰å­æ ‘\n    const rootVal = list.shift(); // å¼¹å‡ºé¦–é¡¹ï¼Œè·å–å®ƒçš„â€œæ•°æ®â€\n    if (rootVal == \"X\") {         // æ˜¯Xï¼Œè¿”å›nullèŠ‚ç‚¹\n      return null;\n    }\n    const root = new TreeNode(rootVal); // ä¸æ˜¯Xï¼Œåˆ™åˆ›å»ºèŠ‚ç‚¹\n    root.left = buildTree(list);        // é€’å½’æ„å»ºå·¦å­æ ‘\n    root.right = buildTree(list);       // é€’å½’æ„å»ºå³å­æ ‘\n    return root;                        // è¿”å›å½“å‰æ„å»ºå¥½çš„root\n  };\n\n  return buildTree(list); // æ„å»ºçš„å…¥å£\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201348331","body":"## æ€è·¯\r\nç®—å‡ºæ¨ªçºµåæ ‡, ç„¶åä¾æ¬¡å¤„ç†æ•°æ®\r\n## ä»£ç \r\n```js\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number[][]}\r\n */\r\nfunction verticalTraversal(root) {\r\n  let arr = [];\r\n\r\n  // è®¡ç®—åæ ‡\r\n  // (row,col) --> è¡Œ,åˆ— --> æ ‘çš„é«˜åº¦(å½“å‰åœ¨ç¬¬å‡ å±‚), å·¦å³å­æ ‘(å·¦è¾¹è¿˜æ˜¯å³è¾¹)\r\n  const dfs = (root, row, col) => {\r\n    if (!root) return;\r\n\r\n    arr.push({ x: row, y: col, val: root.val })\r\n\r\n    dfs(root.left, row + 1, col - 1);\r\n    dfs(root.right, row + 1, col + 1);\r\n  }\r\n  dfs(root, 0, 0)\r\n\r\n//   console.log(arr)\r\n  // æŒ‰ç…§ Y æ’åº(groupBy)\r\n  let map = {};\r\n\r\n\r\n  for (let item of arr) {\r\n    if (map[item.y]) {\r\n      map[item.y].push({ x: item.x, val: item.val })\r\n    } else {\r\n      map[item.y] = [{ x: item.x, val: item.val }];\r\n    }\r\n  }\r\n\r\n\r\n\r\n//   console.log(map);\r\n\r\n\r\n  // æŒ‰ç…§ Mapçš„key å‡åº+å€¼çš„å‡åºæ’åˆ—\r\n  return Object.keys(map).sort((a, b) => Number(a) - Number(b)).map(key => {\r\n    let itemMap = {}\r\n\r\n    map[key].forEach(item => {\r\n      if (itemMap[item.x]) {\r\n        itemMap[item.x] = [...itemMap[item.x], item.val].sort((a, b) => a - b)\r\n      } else {\r\n        itemMap[item.x] = [item.val];\r\n      }\r\n    })\r\n\r\n    return Object.values(itemMap).flat()\r\n  })\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201925240","body":"## æ€è·¯\nå€ŸåŠ©map\n## ä»£ç  JS\n```js\nvar twoSum = function (nums, target) {\n  const map = {}\n  for (let i = 0; i < nums.length; i++) {\n    const anthorItem = target - nums[i];\n    if (map[anthorItem] !== undefined) {\n      return [i, map[anthorItem]];\n    } else {\n      map[nums[i]] = i;\n    }\n  }\n}\n```\n## å¤æ‚åº¦\næ—¶é—´ O(n) ç©ºé—´ O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203366225","body":"## æ€è·¯\nä½¿ç”¨mapç»Ÿè®¡é‡å¤å’Œé‡å¤çš„æ¬¡æ•°\n## ä»£ç JS\n```js\nfunction topKFrequent(nums, k) {\n    const map = {};\n    for (let num of nums) {\n        if (map[num]) {\n            map[num] = map[num] + 1\n        } else {\n            map[num] = 1;\n        }\n    }\n    return Object.entries(map)\n        .sort((a, b) => b[1] - a[1])\n        .map(item => Number(item[0]))\n        .slice(0, k)\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1207395658","body":"\r\n```js\r\nvar numberOfBoomerangs = function(points) {\r\n   \r\n    let res = 0;\r\n    for(let i = 0; i < points.length; i++){\r\n        let map = new Map(); //åº”è¯¥æ”¾åœ¨é‡Œé¢ï¼Œè¡¨ç¤ºæ˜¯iè¿™ä¸ªç‚¹å¯¹åº”å…¶ä»–ç‚¹çš„è·ç¦»å’Œä¸ªæ•°\r\n        for(let j = 0; j < points.length; j++){\r\n            if(j !== i){\r\n                let distance = dis(points[i], points[j]);\r\n                if(map.has(distance)){\r\n                    map.set(distance, map.get(distance) + 1);\r\n                }else{\r\n                    map.set(distance, 1)\r\n                }\r\n            }\r\n        }\r\n        map.forEach((count, distance) => res += count * (count - 1)); //map.forEach((value, key) => {}) value åœ¨ key çš„å‰é¢\r\n    }\r\n    return res;\r\n};\r\n\r\nfunction dis(x, y){\r\n    return (y[1] - x[1])* (y[1] - x[1]) + (y[0] - x[0]) * (y[0] - x[0]); //åæ ‡ä¸¤ç‚¹è·ç¦»ï¼Œæ˜¯+ä¸æ˜¯-\r\n}\r\n```\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206597437","body":"ä»£ç JS \n```js\nvar lengthOfLongestSubstring = function(s) {\n    const occ = new Set();\n    const n = s.length;\n    let rk = -1, ans = 0;\n    for (let i = 0; i < n; ++i) {\n        if (i != 0) {\n            occ.delete(s.charAt(i - 1));\n        }\n        while (rk + 1 < n && !occ.has(s.charAt(rk + 1))) {\n       \n            occ.add(s.charAt(rk + 1));\n            ++rk;\n        }\n  \n        ans = Math.max(ans, rk - i + 1);\n    }\n    return ans;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207231557","body":"## æ€è·¯\næ»‘åŠ¨çª—å£+hashMap\n## ä»£ç  TS\n```ts\nfunction findSubstring(s: string, words: string[]): number[] {\n    const cnts = new Map<string, number>(), ans = new Array<number>(), n = words.length, step = words[0].length\n    for (const word of words) {\n        if (cnts.has(word)) {\n            cnts.set(word, cnts.get(word) + 1)\n        } else {\n            cnts.set(word, 1)\n        }\n    }\n    out:\n    for (let i = 0; i <= s.length - step * n; i++) {\n        const curCnts = new Map<string, number>()\n        for (let j = 0; j < n; j++) {\n            const subStr = s.substr(i + j * step, step)\n            if (!cnts.has(subStr)) {\n                continue out\n            }\n            if (curCnts.has(subStr)) {\n                curCnts.set(subStr, curCnts.get(subStr) + 1)\n                if (curCnts.get(subStr) > cnts.get(subStr)) {\n                    continue out\n                }\n            } else {\n                curCnts.set(subStr, 1)\n            }\n        }\n        ans.push(i)\n    }\n    return ans\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207373013","body":"æ²¡åšå‡ºæ¥..., çœ‹äº†é¢˜è§£\n```\nfunction solve(nums, k) {\n  var map = new Map();\n  map.set(0, -1);\n\n\n  var target = 0;\n  var currSum = 0;\n  \n  for (let i = 0; i < nums.length; i++) {\n    target += nums[i]; // è®¡ç®—æ•°ç»„çš„æ€»å’Œ\n  }\n  target = target % k; // åŸæ•°ç»„æ¨¡é™¤ç»“æœ, ç›®æ ‡è½¬åŒ–ä¸º: ä»numsä¸­æ‰¾å‡ºå­åˆ—è¡¨, æ˜¯ä»–ä»¬çš„å’Œ ç„¶åæ¨¡é™¤çš„ç»“æœä¸ºtarget\n  \n  var res = nums.length;\n  for (let i = 0; i < nums.length; i++) {\n\n    currSum = (nums[i] + currSum) % k;\n    // console.log('i:', i, nums[i]);\n    // console.log('currSum:', currSum);\n\n    map.set(currSum, i);\n    // console.log('map:', map);\n\n    var prevSum = floorMod(currSum - target, k);\n    if (map.has(prevSum)) {\n      res = Math.min(res, i - map.get(prevSum));\n    }\n  }\n  return res === nums.length ? -1 : res;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208136441","body":"## æ€è·¯\nå…ˆè®¡ç®—é“¾è¡¨çš„é•¿åº¦, ç„¶åå†èµ°ä¸€é, ç›´åˆ°ä¸­é—´ä½\n## ä»£ç \n```js\nvar middleNode = function (head) {\n    // ç»Ÿè®¡é“¾è¡¨çš„èŠ‚ç‚¹æ•°\n    let count = 1;\n    let currentHead = head;\n    while (currentHead.next) {\n        count++;\n        currentHead = currentHead.next;\n    }\n    const middleNodeIndex = Math.floor(count / 2) + 1;\n    let secondHead = head;\n    for (let i = 1; i <= count; i++) {\n        if (i === middleNodeIndex) {\n            return secondHead\n        } else {\n            secondHead = secondHead.next\n        }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209436934","body":"```js\r\nfunction removeDuplicates(nums) {\r\n  let count = 0;//é‡å¤çš„æ•°å­—ä¸ªæ•°\r\n  \r\n  for (let right = 1; right < nums.length; right++) {\r\n    if (nums[right] === nums[right - 1]) {\r\n      //å¦‚æœæœ‰é‡å¤çš„ï¼Œcountè¦åŠ 1\r\n      count++;\r\n    } else {\r\n      //å¦‚æœæ²¡æœ‰é‡å¤ï¼Œåé¢çš„å°±å¾€å‰æŒª, è¦†ç›–\r\n      nums[right - count] = nums[right];\r\n    }\r\n  }\r\n  //æ•°ç»„çš„é•¿åº¦å‡å»é‡å¤çš„ä¸ªæ•°\r\n  return nums.length - count;\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/42#issuecomment-1210041505","body":"```js\nfunction searchInsert(nums: number[], target: number): number {\n    let left = 0\n    let right = nums.length - 1\n\n    while (left <= right) {\n        let mid = Math.floor((right + left) / 2);\n\n        if (nums[mid] === target) {\n            return mid\n        } else if (nums[mid] < target) {\n            left = mid + 1\n        } else if (nums[mid] > target) {\n            right = mid - 1\n        }\n    }\n\n    return left\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yujian920":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185136875","body":"### æ€è·¯\r\n\r\næš´åŠ›è§£æ³•ï¼šå­—ç¬¦ä¸²è½¬æ¢ï¼Œç„¶åç”¨ BigInt è½¬æ¢ä¿è¯å¤§æ•°ç²¾åº¦ä¸ä¸¢å¤±\r\n### ä»£ç \r\n\r\n\r\n```typescriptï¼ˆæ­¤å¤„æ¢æˆä½ çš„è¯­è¨€ï¼Œæ¯”å¦‚jsï¼Œpy ç­‰ï¼‰\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n  return (BigInt(num.join(\"\")) + BigInt(k)).toString().split(\"\").map(item => Number(item))\r\n};\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œç±»å‹è½¬æ¢éƒ¨åˆ†æ—¶é—´å¤æ‚åº¦ä¸ä¼šç®—ï¼Œä½™ä¸‹éƒ¨åˆ†åº”è¯¥æ˜¯ O(2*n)ä¹Ÿå°±æ˜¯ O(n)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188549571","body":"### æ€è·¯\nJS å®ç°æ ˆæ²¡ä»€ä¹ˆå¥½è¯´çš„ï¼Œè¿™é‡Œç”¨ä¸¤ä¸ªæ ˆçš„æ–¹å¼å®ç°é˜Ÿåˆ—ï¼Œåƒæ˜¯ä¸¤æ¯æ°´å€’æ¥å€’å»\n### ä»£ç \n\n```typescript\nclass MyQueue {\n    private stack1: number[] = []\n    private stack2: number[] = []\n\n    constructor() {\n\n    }\n\n    push(x: number): void {\n        this.stack1.push(x)\n    }\n\n    pop(): number {\n        if(!this.stack1.length) return\n\n        while(this.stack1.length) {\n            const stackValue = this.stack1.pop();\n            this.stack2.push(stackValue)\n        }\n\n        const popValue = this.stack2.pop();\n\n        while(this.stack2.length) {\n            const stackValue = this.stack2.pop();\n            this.stack1.push(stackValue)\n        }\n\n        return popValue\n    }\n\n    peek(): number {\n        return this.stack1[0]\n    }\n\n    empty(): boolean {\n        return this.stack1.length === 0\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kiirii4":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185137931","body":"### æ€è·¯\nå°†num[n-1]ç›¸åŠ èµ‹å€¼äºkï¼Œå¯¹å…¶ç»“æœæ±‚ä½™ï¼Œä½œä¸ºè¯¥ä½çš„å€¼ï¼Œk / 10 çš„ç»“æœå†å’Œnum[n-2]ç›¸åŠ ï¼Œå¯¹å…¶ç»“æœæ±‚ä½™ï¼Œä½œä¸ºè¯¥ä½çš„å€¼ï¼Œä»¥æ­¤ç±»æ¨\n\n### ä»£ç \n```C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> vec;\n        int len = num.size();\n        for(int i = len - 1; 0 <= i || k >= 1; i--, k /= 10){\n            if( i >= 0){\n                k += num[i];\n            }\n            vec.push_back(k % 10);\n        }\n        reverse(vec.begin(), vec.end());\n        return vec;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\næ—¶é—´ï¼šO(max(n,logk) <nä¸ºè¾“å…¥æ•°ç»„é•¿åº¦ >\nç©ºé—´ï¼šO(1) é™¤è¿”å›å€¼å¤–ï¼Œæ‰€ç”¨ç©ºé—´ä¸ºå¸¸æ•°","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186083081","body":"### æ€è·¯\næ‰“ç®—éå†stringçš„æ¯ä¸ªå­—ç¬¦ï¼Œå†ä»æ¯ä¸ªè¢«æŒ‡å‘çš„å­—ç¬¦æ´¾å‡ºä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«ä»å·¦å³åŒæ—¶éå†è‡³stringçš„è¾¹ç•Œï¼Œè‹¥å…ƒç´ ä¸cç›¸ç­‰ï¼Œåˆ™å°†è®¡ç®—ç›¸å¯¹ä½ç½®å·®æ¥èµ‹å€¼ã€‚\n### ä»£ç \n```C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> answer(n,-1);\n        for(int i = 0 ; i < n; ++i){\n                if(s[r] == c){\n                    answer[i] = i - l;\n                    break;\n                }\n            }\n            for(int r = i; r < n; ++r){\n                if(s[r] == c && answer[i] != -1){\n                    answer[i] = min(answer[i], r - i);\n                    break;\n                }\n                else if(s[r] == c){\n                    answer[i] = r - i;\n                    break;\n                }\n            }\n        }\n        return answer;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\næ—¶é—´ï¼šO(n^2)\nç©ºé—´ï¼šO(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186395331","body":"## æ€è·¯\r\npushå’Œpopæ“ä½œåªæ˜¯åŸºäºæ•°ç»„çš„é™åˆ¶æ“ä½œï¼Œ\r\nincrementæ“ä½œä¸ºäº†å’Œå…¶ä»–æ“ä½œä¸€æ ·æ¶ˆè€—å¸¸æ•°æ—¶é—´ï¼Œé¢å¤–ç»´æŠ¤ä¸€ä¸ªæ•°ç»„å‚¨å­˜æ¯ä¸€ä½çš„å¢é‡ï¼Œåœ¨å…ƒç´ è¢«popå‡ºæ—¶å†æ·»åŠ ä¸Š\r\n\r\n## ä»£ç \r\n\r\n- è¯­è¨€æ”¯æŒï¼šC++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass CustomStack {\r\npublic:\r\n    vector<int> vec, add;\r\n    int top = -1;\r\n    CustomStack(int maxSize) {\r\n        vec.resize(maxSize);\r\n        add.resize(maxSize);\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(top != vec.size() - 1){\r\n            top++;\r\n            vec[top] = x;\r\n        }\r\n    } \r\n    \r\n    int pop() {\r\n        if(top == -1)\r\n            return -1;\r\n        int ret = vec[top] + add[top];\r\n        if(top != 0){\r\n            add[top - 1] += add[top];\r\n        } \r\n        add[top] = 0; \r\n        top--;\r\n        return ret;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int lim = min(k - 1 , top);\r\n        if(lim >= 0)\r\n            add[lim] += val;\r\n        } \r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n\r\n```\r\n\r\n\r\n## å¤æ‚åº¦åˆ†æ\r\n\r\nä»¤ n ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(1)$\r\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186731145","body":"## æ€è·¯\nä½¿ç”¨é€’å½’ï¼Œé‡åˆ°æ•°å­—ï¼Œè®°å½•è‡³multiï¼Œé‡åˆ°å­—æ¯ï¼Œå°†å…¶åŠ å…¥æœ¬å±‚çš„å­—ç¬¦ä¸²ä¸­ï¼Œé‡åˆ°\"[\"è¿›å…¥æ–°çš„ä¸€å±‚é€’å½’ï¼Œå¹¶å°†ä¸‹ä¸€å±‚è¿”å›çš„å­—ç¬¦ä¸²é‡å¤multiæ¬¡åŠ è‡³æœ¬å±‚çš„å­—ç¬¦ä¸²ä¸­ï¼Œé‡åˆ°â€œ]â€è¿”å›æœ¬å±‚å­—ç¬¦ä¸²\n## ä»£ç \n\n- è¯­è¨€æ”¯æŒï¼šC++\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    string decodeString(string s) {\n        int i = 0;\n        return dfs(s, i);\n    }\n\n    string dfs(string &s, int &i){\n        int multi = 0;\n        string res = \"\";\n        for(; i < s.size(); ++i){\n            if('0' <= s[i] && s[i] <= '9')\n                multi = multi * 10 + (s[i] - '0');\n            else if(s[i] == '['){\n                string temp = dfs(s ,++i);\n                while(multi != 0){\n                    res += temp;\n                    --multi;\n                }\n            }\n            else if(s[i] == ']')\n                return res;\n            else\n                res += s[i];\n        }\n        return res;\n    }\n};\n\n```\n\n\n**å¤æ‚åº¦åˆ†æ**\n\nä»¤ n ä¸ºæ•°ç»„é•¿åº¦ã€‚\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$ åœ¨é€’å½’çš„è¿‡ç¨‹ä¸­ç´¢å¼•æ˜¯æ›´æ–°çš„ï¼Œä¸€æ¬¡éå†\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ æœ€åæƒ…å†µä¸‹ï¼ˆå¦‚ï¼š3[3[3[a]]]ï¼‰é€’å½’æ¬¡æ•°ä¸º(n-4)/3ï¼Œéœ€è¦çº¿æ€§ç©ºé—´\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188595534","body":"## æ€è·¯\n åŒºåˆ†äº†è¾“å…¥å’Œè¾“å‡ºæ ˆï¼Œåªæœ‰åœ¨è¾“å‡ºæ ˆä¸ºç©ºæ—¶ï¼Œæ‰ä»è¾“å…¥æ ˆä¸­å–å…ƒç´ å‹å…¥ï¼Œå¦‚æ­¤ä¸€æ¥æ¯ä¸€ä¸ªå…ƒç´ æœ€å¤šè¢«åˆ†åˆ«è¢«å‹å…¥å‹å‡º2æ¬¡\n\n## ä»£ç \n```c++\nclass MyQueue {\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        stk1.push(x);\n    }\n    \n    int pop() {\n        int ret = 0;\n        if(stk2.empty())\n            in2out();\n        ret = stk2.top();\n        stk2.pop();\n        return ret;\n    }\n\n    \n    int peek() {\n        if( stk2.empty()){\n            in2out();\n        }\n        return stk2.top();\n    }\n    \n    bool empty() {\n        return stk1.empty() && stk2.empty();\n    }\nprivate:\n    stack<int> stk1;\n    stack<int> stk2;\n\n    void in2out(){\n        while(!stk1.empty()){\n            stk2.push(stk1.top());\n            stk1.pop();\n        }\n    }\n\n\n\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```\n## å¤æ‚åº¦åˆ†æ\nnä¸ºæ ˆé•¿åº¦\nç©ºé—´:O(n)\næ—¶é—´:æ¯ä¸€æ“ä½œéƒ½æ˜¯O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189824934","body":"## æ€è·¯\nå»ºç«‹ä¸€ä¸ªæ ˆæ¥å­˜å‚¨æ¯ä¸€å—ä¸­çš„æœ€å¤§å…ƒç´ ï¼Œä¸€æ¬¡éå†æ•°ç»„ï¼Œè‹¥æ ˆä¸ºç©ºï¼Œæˆ–éå†ä¸­çš„æ•°å­—å¤§äºæ ˆé¡¶ï¼Œå³å°†éå†ä¸­çš„æ•°å­—å‹å…¥æ ˆï¼Œè‹¥æ ˆä¸ä¸ºç©ºä¸”éå†ä¸­çš„æ•°å­—å°äºæ ˆé¡¶ï¼Œåˆ™å°†æ ˆé¡¶æ‹·è´å­˜å‚¨ä¸‹æ¥ï¼Œå‡ºæ ˆç›´è‡³æ ˆé¡¶å…ƒç´ å°äºæˆ–ç­‰äºéå†ä¸­çš„å…ƒç´ ï¼Œå†å°†å­˜å‚¨èµ·æ¥çš„æœ€å¤§å…ƒç´ å‹å…¥æ ˆé¡¶ã€‚\n## ä»£ç \n```c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> stk;\n        int head = 0;\n        for(int i = 0; i < arr.size(); ++i){\n            if(stk.empty() || arr[i] >= head){\n                stk.push(arr[i]);\n                head = arr[i];\n            }\n            else if(arr[i] < stk.top()){\n                head = stk.top();\n                while(!stk.empty() && arr[i] < stk.top())\n                    stk.pop();\n                stk.push(head);\n            }\n        }\n        return stk.size();\n    }\n};\n```\n## å¤æ‚åº¦åˆ†æ\nnä¸ºæ•°ç»„é•¿åº¦\næ—¶é—´ï¼šä¸€æ¬¡éå†ï¼Œå¯¹æ’åºå—çš„ä¿®æ­£ä¹Ÿæœ€å¤šéå†ä¸€æ¬¡ O(n)\nç©ºé—´ï¼šæ’åºå—æœ€å¤šä¸ºæ•°ç»„é•¿åº¦ï¼Œè¿™ç§æƒ…å†µä¸‹ä¸ºçº¿æ€§ç©ºé—´ O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1193265141","body":"## æ€è·¯\nå°†æ•´ä¸ªé“¾è¡¨å¾€å³ç§»kä½ï¼Œæº¢å‡ºè€…è¡¥åˆ°headå¤„ï¼Œä½¿å€’æ•°k+1ä½æŒ‡å‘nullï¼Œå°¾èŠ‚ç‚¹æŒ‡å‘å¤´èŠ‚ç‚¹ï¼Œå€’æ•°kä½ä¸ºæ–°é“¾è¡¨çš„å¤´èŠ‚ç‚¹ï¼Œè·å¾—å€’æ•°k+1ä½èŠ‚ç‚¹çš„æ–¹æ³•æ˜¯å¿«æ…¢æŒ‡é’ˆ\n## ä»£ç \n```c++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(head == nullptr || head->next == nullptr || k == 0)\n            return head;\n        int len = 1;\n        ListNode* curr = head;\n        while(curr->next != nullptr){\n            curr = curr->next;\n            len++;\n        }\n        k %= len;\n        ListNode* fast = head;\n        ListNode* slow = head;\n        while(fast->next != nullptr){\n            if(k-- <= 0){\n                slow = slow->next;\n            }\n            fast = fast->next;\n        }\n        fast->next = head;\n        ListNode* new_head = slow->next;\n        slow->next = nullptr;\n        return new_head;\n    }\n};\n```\n## å¤æ‚åº¦åˆ†æ\n* æ—¶é—´ï¼šéå†ä¸¤æ¬¡ï¼Œä¸€æ¬¡è®°å½•é“¾è¡¨é•¿åº¦ï¼Œä¸€æ¬¡å¿«æ…¢æŒ‡é’ˆéå†ï¼ŒO(2n)\n* ç©ºé—´ï¼šOï¼ˆ1ï¼‰","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192414712","body":"## æ€è·¯\né€’å½’ï¼ŒåŸæ¥çš„å¤´èŠ‚ç‚¹æ˜¯æ–°é“¾è¡¨ç¬¬äºŒä¸ªèŠ‚ç‚¹ï¼Œç¬¬äºŒä¸ªèŠ‚ç‚¹åœ¨æ–°é“¾è¡¨ä¸ºå¤´èŠ‚ç‚¹\n## ä»£ç \n```c++\n            class Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head == nullptr || head->next == nullptr) return head;\n        ListNode* newHead = head->next;\n        head->next = swapPairs(newHead->next);\n        newHead->next = head;\n        return newHead;\n    }\n};\n```\n## å¤æ‚åº¦åˆ†æ\næ—¶é—´O(n)\nç©ºé—´O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193275489","body":"## æ€è·¯\né€’å½’ï¼Œæ„å»ºå¹³è¡¡çš„æ ‘éœ€è¦é«˜åº¦å·®å°äº1ï¼Œé€šè¿‡å¯»æ‰¾é“¾è¡¨ä¸­çš„ä¸­é—´å€¼æ„å»ºæ ¹èŠ‚ç‚¹ï¼Œé“¾è¡¨å·¦ä¾§æ„å»ºå·¦èŠ‚ç‚¹ï¼Œé“¾è¡¨å³ä¾§æ„å»ºå³èŠ‚ç‚¹\n## ä»£ç \n```C++\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if(head == nullptr) return nullptr;\n        return sortedListToBST(head, nullptr);\n    }\n\n    TreeNode* sortedListToBST(ListNode* head, ListNode* tail) {\n        if(head == tail) return nullptr;\n        ListNode* fast = head;\n        ListNode* slow = head;\n        while(fast != tail && fast->next != tail){\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n        TreeNode* root = new TreeNode(slow->val);\n        root->left = sortedListToBST(head, slow);\n        root->right = sortedListToBST(slow->next, tail);\n        return root;\n    }\n};\n```\n## å¤æ‚åº¦åˆ†æ\n* æ—¶é—´ï¼šO(nlogn)æ¯ä¸€å±‚çš„æ“ä½œæ•°æ˜¯nï¼Œé€’å½’äº†lognå±‚\n* ç©ºé—´ï¼šO(logn)é€’å½’äº†lognå±‚","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193258294","body":"## æ€è·¯\nåˆ†åˆ«ç”¨ä¸¤ä¸ªæŒ‡é’ˆéå†ä¸¤ä¸ªé“¾è¡¨ï¼Œå½“éå†å®Œåï¼Œä¸¤ä¸ªæŒ‡é’ˆäº¤æ¢èµ‹å€¼åˆ«çš„é“¾è¡¨çš„å¤´èŠ‚ç‚¹ï¼Œå†åº¦éå†ï¼Œç›´è‡³ä¸¤æŒ‡é’ˆæŒ‡å‘åŒä¸€ä½ç½®\n## ä»£ç \n```c++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* a = headA;\n        ListNode* b = headB;\n        while(a != b){\n            b = (b == nullptr)? headA : b->next;\n            a = (a == nullptr)? headB : a->next;\n        }\n        return b;\n    }\n};\n```\n## å¤æ‚åº¦åˆ†æ\n* æ—¶é—´ï¼šmä¸ºé“¾è¡¨ä¸€é•¿åº¦ï¼Œnä¸ºé“¾è¡¨äºŒé•¿åº¦\nO(m+n)\n* ç©ºé—´ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193504139","body":"## æ€è·¯\nä½¿ç”¨å¿«æ…¢æŒ‡é’ˆï¼Œå½“å¿«æ…¢æŒ‡é’ˆç¬¬ä¸€æ¬¡ç›¸é‡æ—¶å°†å¤´èŠ‚ç‚¹èµ‹å€¼ç»™å¿«æŒ‡é’ˆï¼Œå¿«æŒ‡é’ˆæ­¥é•¿é‡ç½®ä¸ºä¸€ï¼Œå½“ä¸¤è€…å†æ¬¡ç›¸é‡èŠ‚ç‚¹å³ä¸ºå…¥ç¯èŠ‚ç‚¹\n## ä»£ç \n```c++\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode* fast = head;\n        ListNode* slow = head;\n        while(true){\n            if(fast == nullptr || fast->next == nullptr)\n                return nullptr;\n            fast = fast->next->next;\n            slow = slow->next;\n            if(fast == slow) break;\n        }\n        fast = head;\n        while(fast != slow){\n            fast = fast->next;\n            slow = slow->next;\n        }\n        return fast;\n    }\n};\n```\n## å¤æ‚åº¦åˆ†æ\n* æ—¶é—´ï¼šaä¸ºå¤´èŠ‚ç‚¹è‡³å…¥ç¯èŠ‚ç‚¹é•¿åº¦ï¼Œbä¸ºç¯é•¿åº¦ï¼Œxä¸ºç›¸é‡èŠ‚ç‚¹ï¼Œç¬¬ä¸€æ¬¡ç›¸é‡ï¼Œå¿«æŒ‡é’ˆèµ°a+nb-xï¼Œæ…¢æŒ‡é’ˆèµ°a+b-xï¼Œç¬¬äºŒæ¬¡ç›¸é‡ï¼Œå¿«æ…¢æŒ‡é’ˆå‡èµ°aæ­¥ï¼Œæ€»ä½“ä¸ºçº¿æ€§æ—¶é—´\n* ç©ºé—´ï¼šåŒæŒ‡é’ˆæ‰€ç”¨ç©ºé—´ä¸ºå¸¸æ•°","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195121569","body":"### è¦æ±‚ï¼šgetå’Œputåœ¨O(1)æ—¶é—´å†…å®Œæˆ\n### æ€è·¯ï¼š\n1. é€šè¿‡é”®æ¥è®¿é—®å€¼ï¼Œåº”å½“æƒ³åˆ°hashmap\n2. æ”¹å˜æ•°æ®çš„è®¿é—®æ—¶é—´\n* èƒ½å¤Ÿéšæœºè®¿é—®\n* æ•°æ®èƒ½å¤Ÿè¢«æ’å…¥åˆ°å¤´éƒ¨æˆ–å°¾éƒ¨\n3. å»ºç«‹ä¸€ä¸ªåŒå‘é“¾è¡¨ï¼Œå­˜å‚¨keyå’Œval\n4. å†å»ºç«‹ä¸€ä¸ªhashmapï¼Œç”¨keyæ¥ä½œä¸ºç´¢å¼•ï¼Œè®¿é—®é“¾è¡¨\n### ä»£ç \n```C++\nstruct ListNodes {\n    ListNodes* prev;\n    ListNodes* next;\n    int key, val;\n    ListNodes(): key(0), val(0), prev(nullptr), next(nullptr){}\n    ListNodes(int _key, int _value): key(_key), val(_value), prev(nullptr), next(nullptr){}\n};\n\nclass LRUCache {\nprivate:\n    unordered_map<int, ListNodes*> hashmap;\n    ListNodes* head;\n    ListNodes* tail;\n    int capacity, size;\n\npublic:\n    LRUCache(int _capacity): capacity(_capacity), size(0) {\n        head = new ListNodes();\n        tail = new ListNodes();\n        head->next = tail;\n        tail->prev = head;\n    }\n    \n    int get(int key) {\n        if(!hashmap.count(key))\n            return -1;\n        ListNodes* node = hashmap[key];\n        moveTohead(node);\n        return node->val;\n    }\n    \n    void put(int key, int value) {\n        if(!hashmap.count(key)){\n            ListNodes* node = new ListNodes(key, value);\n            hashmap[key] = node;\n            addTohead(node);\n            ++size;\n            if(size > capacity){\n                ListNodes* removed = removeTail();\n                hashmap.erase(removed->key);\n                --size;\n                delete removed;\n            }\n        }\n        else {\n            ListNodes* node = hashmap[key];\n            node->val = value;\n            moveTohead(node);\n        }\n    }\n\n    void addTohead(ListNodes* node){\n        node->prev = head;\n        node->next = head->next;\n        head->next->prev = node;\n        head->next = node;\n    }\n    \n    void removeNode(ListNodes* node){\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n\n    void moveTohead(ListNodes* node){\n        removeNode(node);\n        addTohead(node);\n    }\n\n    ListNodes* removeTail(){\n        ListNodes* node = tail->prev;\n        removeNode(node);\n        return node;\n    }\n};struct ListNodes {\n    ListNodes* prev;\n    ListNodes* next;\n    int key, val;\n    ListNodes(): key(0), val(0), prev(nullptr), next(nullptr){}\n    ListNodes(int _key, int _value): key(_key), val(_value), prev(nullptr), next(nullptr){}\n};\n\nclass LRUCache {\nprivate:\n    unordered_map<int, ListNodes*> hashmap;\n    ListNodes* head;\n    ListNodes* tail;\n    int capacity, size;\n\npublic:\n    LRUCache(int _capacity): capacity(_capacity), size(0) {\n        head = new ListNodes();\n        tail = new ListNodes();\n        head->next = tail;\n        tail->prev = head;\n    }\n    \n    int get(int key) {\n        if(!hashmap.count(key))\n            return -1;\n        ListNodes* node = hashmap[key];\n        moveTohead(node);\n        return node->val;\n    }\n    \n    void put(int key, int value) {\n        if(!hashmap.count(key)){\n            ListNodes* node = new ListNodes(key, value);\n            hashmap[key] = node;\n            addTohead(node);\n            ++size;\n            if(size > capacity){\n                ListNodes* removed = removeTail();\n                hashmap.erase(removed->key);\n                --size;\n                delete removed;\n            }\n        }\n        else {\n            ListNodes* node = hashmap[key];\n            node->val = value;\n            moveTohead(node);\n        }\n    }\n\n    void addTohead(ListNodes* node){\n        node->prev = head;\n        node->next = head->next;\n        head->next->prev = node;\n        head->next = node;\n    }\n    \n    void removeNode(ListNodes* node){\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n\n    void moveTohead(ListNodes* node){\n        removeNode(node);\n        addTohead(node);\n    }\n\n    ListNodes* removeTail(){\n        ListNodes* node = tail->prev;\n        removeNode(node);\n        return node;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´ï¼šget(åŸºäºhashmap)å’Œput(åŸºäºlist)æ“ä½œéƒ½è¾¾åˆ°äº†O(1)\n* ç©ºé—´ï¼šO(n) nä¸ºå“ˆå¸Œè¡¨å’Œé“¾è¡¨çš„é•¿åº¦","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196244121","body":"### æ€è·¯ï¼š\n1. æ„å»ºä¸€ä¸ªé˜Ÿåˆ—å­˜å‚¨æ¯ä¸€å±‚çš„èŠ‚ç‚¹\n2. è®°å½•å®Œæ¯ä¸€å±‚çš„èŠ‚ç‚¹åï¼Œå•ç‹¬ç»´æŠ¤çš„è®°å½•å±‚æ•°çš„å˜é‡ï¼‹1ï¼Œä»é˜Ÿåˆ—ä¸­åˆ é™¤è¿™äº›èŠ‚ç‚¹ï¼Œç”¨ä¸‹ä¸€å±‚çš„èŠ‚ç‚¹æ‰©å±•é˜Ÿåˆ—\n### ä»£ç ï¼š\n```c++\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(!root)\n            return 0;\n        queue<TreeNode*> q;\n        int depth = 0;\n        q.push(root);\n        while(!q.empty()){\n            int size = q.size();\n            while(size-- > 0){\n                TreeNode* node = q.front();\n                q.pop();\n                if(node->left != nullptr){\n                    q.push(node->left);\n                }\n                if(node->right != nullptr){\n                    q.push(node->right);\n                }\n            }\n            depth++;\n        }\n        return depth;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* nä¸ºäºŒå‰æ ‘çš„èŠ‚ç‚¹æ•°\n* æ—¶é—´ï¼šä¸€æ¬¡éå† O(n)\n* ç©ºé—´ï¼šå»ºç«‹çš„é˜Ÿåˆ—çš„æœ€å¤§å…ƒç´ æ•°ä¸ºæ ‘ä¸­èŠ‚ç‚¹æ•°æœ€å¤šé‚£å±‚çš„èŠ‚ç‚¹æ•°","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197668471","body":"### æ€è·¯ \næ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œå…ˆåˆ¤æ–­ç»“æ„ï¼Œååˆ¤æ–­å€¼\n### ä»£ç \n```C++\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(p == nullptr && q == nullptr)\n            return true;\n        else if(p == nullptr || q == nullptr)\n            return false;\n        else if(p->val != q->val)\n            return false;\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* mï¼Œnä¸ºä¸¤æ ‘çš„èŠ‚ç‚¹æ•°\n* æ—¶é—´ï¼šO(min(m, n))\n* ç©ºé—´ï¼šO(min(m, n)) ä¸ºä¸¤æ ‘å±‚æ•°æœ€å°è€…ï¼Œæœ€åæƒ…å†µä¸ºèŠ‚ç‚¹æ•°","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1200096724","body":"### æ€è·¯\n1. åŸºç¡€çš„bfsæ“ä½œ\n2. å½“ä¸€ä¸ªèŠ‚ç‚¹å­˜åœ¨å·¦å­©å­æ—¶ï¼Œä½¿å…¶å·¦å­©å­çš„å€¼åŠ ä¸Šè¯¥èŠ‚ç‚¹çš„å€¼çš„åå€ï¼Œå­˜åœ¨å³å­©å­åŒç†\n3. ä¸€ä¸ªèŠ‚ç‚¹ä¸ºå¶èŠ‚ç‚¹ï¼Œç”¨å…¶å€¼æ±‚å’Œ\n### ä»£ç \n```c++\nclass Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        int sum  = 0;\n        queue<TreeNode*> q;\n        q.push(root);\n        while(!q.empty()){\n            int size = q.size();\n            while(size-- > 0){\n                TreeNode* node = q.front();\n                q.pop();\n                if(node->left != nullptr){\n                    node->left->val += node->val * 10;\n                    q.push(node->left);\n                }\n                if(node->right != nullptr){\n                    node->right->val += node->val * 10;\n                    q.push(node->right);\n                }\n                if(node->left == nullptr && node->right == nullptr){\n                    sum += node->val;\n                }\n            }\n        }\n        return sum;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´ï¼šO(n) nä¸ºèŠ‚ç‚¹æ•°\n* ç©ºé—´ï¼šO(q) qä¸ºé˜Ÿåˆ—é•¿åº¦","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200077400","body":"### æ€è·¯\nå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼Œå…ˆåºéå†ï¼Œè®¾ç½®ä¸€ä¸ªå˜é‡å­˜å‚¨æœ€å¤§æ·±åº¦ï¼Œå½“èŠ‚ç‚¹å½“å‰æ·±åº¦å¤§äºæœ€å¤§æ·±åº¦æ—¶ï¼Œæ›´æ–°æœ€å¤§æ·±åº¦ï¼Œç”¨å½“å‰èŠ‚ç‚¹çš„å€¼æ›´æ–°æ‰€æ±‚æ ‘çš„æœ€å·¦å€¼\n\n### ä»£ç \n```c++\nclass Solution {\npublic:\n    int ans = 0;\n    int max_depth = 0;\n\n    int findBottomLeftValue(TreeNode* root) {\n        ans = root->val;\n        findBottomLeftValue(root->left, 0);\n        findBottomLeftValue(root->right, 0);\n        return ans;\n    }\n\n    void findBottomLeftValue(TreeNode* root, int depth){\n        if(!root) return;\n        depth++;\n        if(depth > max_depth){\n            max_depth = depth;\n            ans = root->val;\n        }\n\n        findBottomLeftValue(root->left, depth);\n        findBottomLeftValue(root->right, depth);\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´ï¼šO(n) nä¸ºèŠ‚ç‚¹æ•°\n* ç©ºé—´ï¼šO(h) hä¸ºæ ‘çš„é«˜åº¦","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200346232","body":"### æ€è·¯\nåºåˆ—åŒ–æ–¹æ³• dfs\nååºåˆ—åŒ–æ–¹æ³• ä½¿ç”¨istringstreamæ¥ç®€åŒ–å¯¹è¾“å…¥çš„å¤„ç†\n### ä»£ç \n```c++\nclass Codec {\npublic:\n\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root){\n        if(!root)\n            return \"X\";\n        else\n            return to_string(root->val) + \" \" + serialize(root->left) + \" \" + serialize(root->right);\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        istringstream ss(data);\n        return deserialize(ss);\n    }\n\n    TreeNode* deserialize(istringstream &ss){\n        string temp;\n        ss >> temp;\n        if(temp == \"X\")\n            return nullptr;\n        TreeNode* node = new TreeNode(stoi(temp));\n        node->left = deserialize(ss);\n        node->right = deserialize(ss);\n        return node;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n1. åºåˆ—åŒ–ï¼š\n* æ—¶é—´ï¼šO(n)\n* ç©ºé—´ï¼šO(h)\n2. ååºåˆ—åŒ–ï¼š\n* æ—¶é—´ï¼šO(n)\n* ç©ºé—´ï¼šO(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1202033889","body":"### æ€è·¯\nä½¿ç”¨tuple<int, int, int> ç¬¬ä¸€ä¸ªå…³é”®å­—ä¸ºåˆ—ï¼Œç¬¬äºŒä¸ªå…³é”®å­—ä¸ºè¡Œæ•°ï¼Œç¬¬ä¸‰ä¸ªå…³é”®å­—ä¸ºå€¼ï¼Œä»¥è¿™ä¸‰ä¸ªå…³é”®å­—å‡åºæ’åºï¼Œéå†æ•°å€¼ï¼Œå°†å€¼åŠ å…¥ç­”æ¡ˆï¼Œè¿”å›ç»“æœ\n### ä»£ç \n```c++\nclass Solution {\npublic:\n    vector<tuple<int, int, int>> node;\n    void dfs(TreeNode* p, int row, int col){\n        if(!p)  return;\n        node.emplace_back(col, row, p->val);\n        dfs(p->left, row + 1, col - 1);\n        dfs(p->right, row + 1, col + 1);\n    }\n\n    vector<vector<int>> verticalTraversal(TreeNode* root){\n        dfs(root, 0 , 0);\n        sort(node.begin(), node.end());\n        vector<vector<int>> ans;\n        int lastcol = INT_MIN;\n        for(const auto& [col, row, value] : node){\n            if(col != lastcol){\n                lastcol = col;\n                ans.emplace_back();\n            }\n            ans.back().push_back(value);\n        }\n        return ans;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\næ—¶é—´ï¼šO(nlogn) ä¸»è¦åœ¨äºå¯¹æ•°ç»„æ’åº\nç©ºé—´ï¼šO(n) ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202056871","body":"### æ€è·¯\nä½¿ç”¨å“ˆå¸Œè¡¨ï¼Œä¸€æ¬¡éå†\n### ä»£ç \n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> m;\n        vector<int> ans;\n        for(int i = 0; i < nums.size(); i++){\n            if(m.count(target - nums[i])){\n                ans.push_back(m[target - nums[i]]);\n                ans.push_back(i);\n                break;\n            }\n            m[nums[i]] = i;          \n        }\n        return ans;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´ï¼š O(n)\n* ç©ºé—´ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203464978","body":"### æ€è·¯ \nç»´æŠ¤ä¸€ä¸ªæ•°ç»„å­˜å‚¨æ¯ä¸€å€¼çš„å‡ºç°æ¬¡æ•°\néå†æ•°ç»„ï¼Œå¦‚å°é¡¶å †å¤§å°å°äºæ•°ç»„é•¿åº¦ï¼Œç›´æ¥å°†å…ƒç´ åŠ å…¥å°é¡¶å †ï¼Œ\nå¦åˆ™æ¯”è¾ƒå½“å‰å€¼çš„å‡ºç°æ¬¡æ•°ä¸å †é¡¶å…ƒç´ çš„å‡ºç°æ¬¡æ•°ï¼Œè‹¥å°äºåˆ™èˆå¼ƒï¼Œè‹¥å¤§äºï¼Œåˆ é™¤å †é¡¶å…ƒç´ æ·»åŠ å½“å‰å€¼\n### ä»£ç \n```c++\nclass Solution {\npublic: \n    static bool cmp(pair<int, int>& n, pair<int, int>& m){\n        return n.second > m.second;\n    }\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int, int> mp;\n        for(auto& n : nums){\n            mp[n]++;\n        }\n\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(&cmp)> q(cmp);\n        for(auto& [num, count]: mp){\n            if(q.size() == k){\n                if(q.top().second < count){\n                    q.pop();\n                    q.emplace(num,count);\n                }\n            }\n            else{\n                q.emplace(num,count);\n            }\n        }\n        vector<int> ans;\n        while(!q.empty()){\n            ans.emplace_back(q.top().first);\n            q.pop();\n        }\n        return ans;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\nkä¸ºå †ä¸­å…ƒç´  nä¸ºå“ˆå¸Œè¡¨ä¸­å…ƒç´ \n* æ—¶é—´ï¼šO(nlogk)\n* ç©ºé—´ ï¼šO(k + n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204697713","body":"### åŸºæœ¬æ€è·¯\n* éå†æ¯ä¸ªç‚¹ä½œä¸ºæ‹ç‚¹\n* ç”¨å“ˆå¸Œè¡¨è®°å½•æ¯ä¸ªç‚¹å’Œæ‹ç‚¹çš„è·ç¦»\n* ç›¸åŒè·ç¦»çš„ç‚¹ä¸­å–2è¿›è¡Œæ’åˆ—ï¼Œæœ‰n(n-1)ç§å¯èƒ½\n\n### æ³¨æ„\n* å³å€¼å¼•ç”¨&&ï¼Œ é¿å…æ‹·è´ï¼Œæé«˜é€Ÿåº¦\n* n(n-1) = 2 * (0+1+2+Â·Â·Â·Â·+n-1) é¿å…éå†å“ˆå¸Œè¡¨\n* åœ¨å¾ªç¯ä½“å¤–æ„å»ºå“ˆå¸Œè¡¨\n\n### ä»£ç \n```c++\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>> &points) {\n        int ans = 0;\n        unordered_map<int, int> cnt;\n        for (auto&& x : points) {\n            cnt.clear();\n            for (auto&& y : points) {\n                ans += 2 * cnt[(x[0] - y[0]) * (x[0] - y[0]) + (x[1] - y[1]) * (x[1] - y[1])]++;\n            }\n        }\n        return ans;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´ï¼šO(n^2) éå†ä¸¤æ¬¡è¾“å…¥æ•°ç»„\n* ç©ºé—´ï¼šO(k) kä¸ºèŠ‚ç‚¹é—´è·ç¦»å¤§å°çš„ç§æ•°","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206391869","body":"### æ€è·¯\né›†åˆåŠæ»‘åŠ¨çª—å£\n### ä»£ç \n```c++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        if(s.size() == 0) return 0;\n        unordered_set<char> cnt;\n        int n = s.size();\n        int left = 0 , maxlen = 0;\n        for(int i = 0; i < n; ++i){\n            while(cnt.find(s[i]) != cnt.end()){\n                cnt.erase(s[left]);\n                left++;\n            }\n            maxlen = max(maxlen, i - left + 1);\n            cnt.insert(s[i]);\n        }\n        return maxlen;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´ï¼šéå†ä¸€æ¬¡O(N)\n* ç©ºé—´ï¼šæœ€é•¿ä¸é‡å¤å­å­—ç¬¦ä¸²çš„å¤§å°","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207143218","body":"### æ€è·¯\næ»‘åŠ¨çª—å£ + å“ˆå¸Œè¡¨\n### ä»£ç \n```c++\nclass Solution {\npublic:\n    vector<int> findSubstring(string &s, vector<string> &words) {\n        vector<int> res;\n        int m = words.size(), n = words[0].size(), ls = s.size();\n// ç”¨å•è¯é•¿åº¦næ¥åˆ†å‰²string sï¼Œä½™æ•°å°äºnï¼Œåˆ†åˆ«å°†è¿™äº›ä½™æ•°ä½œä¸ºå·¦æŒ‡é’ˆ\n        for (int i = 0; i < n && i + m * n <= ls; ++i) {\n//ä¸€ä¸ªçª—å£ä¸­åŒ…å«sä¸­çš„å‰mä¸ªå•è¯ï¼Œä½¿ç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨æ¥è®°å½•çª—å£ä¸­çš„å•è¯é¢‘æ¬¡å’Œwordä¸­çš„å•è¯é¢‘æ¬¡\n            unordered_map<string, int> differ;\n//åˆå§‹åŒ–ï¼ŒæŸwordåœ¨çª—å£ä¸­å‡ºç°å¯¹åº”å€¼åŠ 1ï¼Œåœ¨wordsä¸­å‡ºç°å¯¹åº”å€¼å‡1\n//åˆå§‹åŒ–ç»“æŸåï¼Œè‹¥æŸå•è¯åœ¨å“ˆå¸Œè¡¨ä¸­å€¼ä¸º0ï¼Œåˆ™wordåœ¨çª—å£å’Œwordsä¸­åªå‡ºç°ä¸€æ¬¡\n            for (int j = 0; j < m; ++j) {\n                ++differ[s.substr(i + j * n, n)];\n            }\n            for (string &word: words) {\n                if (--differ[word] == 0) {\n                    differ.erase(word);\n                }\n            }\n//çª—å£ç§»åŠ¨ï¼Œå³ä¾§å¢åŠ ä¸€ä¸ªå•è¯ï¼Œå·¦ä¾§å‡å°‘ä¸€ä¸ªå•è¯\n            for (int start = i; start < ls - m * n + 1; start += n) {\n                if (start != i) {\n                    string word = s.substr(start + (m - 1) * n, n);\n                    if (++differ[word] == 0) {\n                        differ.erase(word);\n                    }\n                    word = s.substr(start - n, n);\n                    if (--differ[word] == 0) {\n                        differ.erase(word);\n                    }\n                }\n//å“ˆå¸Œè¡¨ä¸ºç©ºï¼Œè¯´æ˜çª—å£å•è¯å‡ºç°é¢‘æ¬¡ä¸wordså»åˆ\n                if (differ.empty()) {\n                    res.emplace_back(start);\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´ï¼šiä¸ºsé•¿åº¦é™¤ä»¥å•è¯é•¿åº¦çš„ä½™æ•° O(i * n)\n* ç©ºé—´ï¼šO(m * n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207328380","body":"### æ€è·¯\n* è®¡ç®—å‡ºæ•°ç»„æ€»å’Œsumï¼Œè®¡ç®—å‡ºsumåŒkçš„æ¨¡target\n* ç”¨å“ˆå¸Œè¡¨æ¥å­˜å‚¨å‰ç¼€å’ŒåŒkçš„æ¨¡å’Œä¸‹æ ‡\n* åœ¨å“ˆå¸Œè¡¨ä¸­æœç´¢å‰ç¼€å’Œä¸sumä¹‹å·®ä¸kçš„æ¨¡ï¼Œè‹¥å­˜åœ¨ï¼Œè¿”å›å…¶ä¸‹æ ‡\n* è¿”å›ä¸‹æ ‡ä¸å½“å‰éå†ä¸­çš„ä¸‹æ ‡å³ä¸ºåˆ é™¤çš„èŒƒå›´ï¼Œè®¡ç®—å…¶å·®å€¼å³ä¸ºåˆ é™¤ä¸ªæ•°\n* å…·ä½“æ¨å¯¼å¦‚ä¸‹[![1659845122631.jpg](https://i.postimg.cc/3xKJHtX3/1659845122631.jpg)](https://postimg.cc/vcNdrL2K)\n### ä»£ç \n```c++\nint mod(const int& a, const int& b){\n    return (a % b + b) % b; \n}\nint solve(vector<int>& nums, int k){\n    int sum = 0;\n    for(const int& num: nums)\n        sum += num;\n\n    int target = mod(sum, k);\n    unordered_map<int, int> mp;\n    mp[0] = -1;\n    \n    int preSum = 0;\n    int minlen = nums.size();\n    for(int i = 0; i < nums.size(); i++){\n        preSum += nums[i];\n        int mods = mod(preSum, k);\n        mp[mods] = i;\n\n        if(mp.count(mod(preSum - target, k)))\n            minlen = min(minlen, i - mp[mod(preSum - target, k)]);\n    }\n    return minlen == nums.size() ? -1 : minlen;\n}\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´ï¼šO(n)\n* ç©ºé—´ï¼šO(min(n, k))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207550161","body":"### æ€è·¯\nå¿«æ…¢æŒ‡é’ˆ\n### ä»£ç \n```c++\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(fast->next != nullptr && fast->next->next != nullptr){\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n        return fast->next != nullptr ? slow->next : slow;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´ï¼šO(n)\n* ç©ºé—´ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208858686","body":"### æ€è·¯\nåŒæŒ‡é’ˆï¼Œiéå†æ•´ä¸ªæ•°ç»„ï¼Œå¯»æ‰¾ä¸é‡å¤çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œjæ„å»ºä¸é‡å¤çš„æ•°ç»„\n### ä»£ç \n```c++\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int i = 1;\n        int j = 1;\n        if(nums.size() == 0)\n            return 0;\n        while(i < nums.size()){\n            if(nums[i] != nums[i - 1]){\n                nums[j++] = nums[i];\n            }\n            ++i;\n        }\n        return j;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n* æ—¶é—´ï¼šä¸€æ¬¡éå† O(n)\n* ç©ºé—´ï¼šä»…ç»´æŠ¤ä¸¤ä¸ªæŒ‡é’ˆ O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ucashurui":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185141689","body":"[Link to LeetCode Problem](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n## æ€è·¯\n\n---\n\nä»ä½ä½æŒ‰ä½è¿›è¡Œç›¸åŠ ï¼Œè®°å½•è¿›ä½ï¼Œå‰é¢ä½ç½®ä¸å¤Ÿäº†æ’å…¥æ–°çš„ä½ã€‚ï¼ˆçœ‹äº†é¢˜è§£è¿˜æ˜¯å€ŸåŠ©stræ¥å·æ‡’æ¯”è¾ƒæ–¹ä¾¿å•Šï¼ï¼‰\n\n## ä»£ç \n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = 0\n        count = len(num) - 1\n        while k or carry:\n            if count < 0:\n                num.insert(0,0)\n                count = 0\n            single_k = k % 10\n            k //= 10\n            num[count] += single_k + carry\n            carry = num[count] // 10\n            num[count] %= 10\n            count -= 1\n        return num\n```\n\n## å¤æ‚åº¦\n\n---\n\n- ****Time:**** $O(N)$ï¼Œ\n- ***Space:** $O(N)$*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186122298","body":"[Link to LeetCode Problem](https://leetcode.cn/problems/shortest-distance-to-a-character/submissions/)\n\n## æ€è·¯\n\n---\n\nä»å·¦å’Œä»å³åˆ†åˆ«éå†ä¸€éï¼Œæ‰¾åˆ°å’Œç›®æ ‡å­—ç¬¦æœ€è¿‘çš„è·ç¦»\n\n## ä»£ç \n\n---\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        num_char = len(s)\n        answer = [num_char for _ in range(num_char)]\n        # find left closest\n        cur_dist = num_char\n        for i in range(num_char):\n            if s[i] == c: \n                cur_dist = 0\n            else: \n                cur_dist += 1\n            answer[i] = cur_dist\n        # find right closest\n        cur_dist = num_char\n        for i in range(num_char):\n            if s[num_char - 1 - i] == c:\n                cur_dist = 0\n            else:\n                cur_dist += 1\n            answer[num_char - 1 - i] = min(answer[num_char - 1 - i], cur_dist)\n        return answer\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n---\n\n- ****Time:**** $O(N)$\n- ***Space:** $O(N)$*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186487537","body":"Link to LeetCode Problem\n\n## æ€è·¯\n\n---\n\nè®¾è®¡ä¸€ä¸ªå¢é‡æ ˆç”¨äºè®°å½•incrementæ“ä½œå¸¦æ¥çš„å¢é‡ï¼Œåœ¨popæ—¶è¿”å›æ ˆä¸­å€¼å’Œå¢é‡æ ˆçš„å’Œï¼Œå¹¶è°ƒæ•´å¢é‡æ ˆï¼Œè€Œä¸æ˜¯ç›´æ¥åœ¨incrementæ“ä½œæ—¶ç›´æ¥åœ¨æ ˆä¸­åŠ ä¸Šï¼Œèƒ½å°†incrementçš„æ—¶é—´å¤æ‚åº¦ä»O(N)é™åˆ°O(1)ã€‚\n\n## ä»£ç \n\n---\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.inc = []\n        self.maxSize = maxSize\n        self.size = 0\n        \n    def push(self, x: int) -> None:\n        if self.size < self.maxSize:\n            self.size += 1\n            self.stack.append(x)\n            self.inc.append(0)\n\n    def pop(self) -> int:\n        if self.size == 0:\n            return -1\n        else:\n            if self.size > 1:\n                self.inc[-2] += self.inc[-1]\n            self.size -= 1 \n            return self.stack.pop(-1) + self.inc.pop()\n            \n    def increment(self, k: int, val: int) -> None:\n        if self.inc:\n            self.inc[min(k, self.size)-1] += val\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n- ****Time:**** $O(1)$ ï¼ˆå¯¹äºpop, pushå’Œincrementéƒ½æ˜¯ï¼‰\n- ***Space:** $O(N)$*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186713928","body":"## æ€è·¯\n\n---\n\nç”¨ä¸€ä¸ªæ ˆä¿å­˜é‡åˆ°çš„å­—ç¬¦ï¼Œå½“é‡åˆ°â€™]â€™æ—¶å¼€å§‹å¼¹å‡ºï¼Œç›´åˆ°â€™[â€™æ—¶å½“å‰å­—ç¬¦ä¸²è·å–å®Œæ¯•ï¼Œå¼€å§‹è·å–é‡å¤çš„æ¬¡æ•°nï¼Œç„¶åå°†å­—ç¬¦ä¸²é‡å¤næ¬¡ï¼Œå¹¶å°†é‡å¤næ¬¡åçš„å­—ç¬¦ä¸²é‡æ–°å‹å…¥æ ˆï¼Œå¦‚æ­¤å¾ªç¯ã€‚æœ€ç»ˆå°†æ ˆä¸­æ‰€æœ‰å­—ç¬¦ä¸²å’Œå¹¶åè¿”å›\n\n## ä»£ç \n\n---\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for i in range(len(s)):\n            char = s[i]\n            if char != ']':\n                stack.append(char)\n            else:\n                tmp_str = ''\n                while stack[-1] != '[':\n                    tmp_str = stack.pop(-1) + tmp_str\n                stack.pop(-1)\n                num_str = ''\n                while stack and stack[-1].isdigit():\n                    num_str = stack.pop(-1) + num_str\n                tmp_res = tmp_str * int(num_str)\n                stack.append(tmp_res)\n        return ''.join(stack)\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n---\n\n- æ—¶é—´å¤æ‚åº¦ï¼š*O(N)ï¼Œ Næ˜¯å­—ç¬¦ä¸²è§£ç åçš„é•¿åº¦*\n- ç©ºé—´å¤æ‚åº¦ï¼š*O(N)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188541605","body":"## æ€è·¯\n\n---\n\nä¸¤ä¸ªæ ˆæ¥å›å€’ï¼Œä¸ºäº†ä½¿popå’Œpeekä¸¤æ“ä½œéƒ½æ˜¯O(1)çš„æ—¶é—´å¤æ‚åº¦ï¼Œé€‰æ‹©åœ¨pushçš„æ—¶å€™å€’ä¸€ä¸‹\n\n## ä»£ç \n\n---\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        while self.stack1:\n            self.stack2.append(self.stack1.pop(-1))\n        self.stack1.append(x)\n        while self.stack2:\n            self.stack1.append(self.stack2.pop(-1))\n    def pop(self) -> int:\n        return self.stack1.pop(-1)\n\n    def peek(self) -> int:\n        return self.stack1[-1]\n\n    def empty(self) -> bool:\n        return not self.stack1\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n---\n\n- æ—¶é—´å¤æ‚åº¦ï¼š*O(N) for pushï¼ŒNä¸ºé˜Ÿåˆ—æœ€é•¿çš„é•¿åº¦ï¼ŒO(1)for pop,peekå’Œempty*\n- ç©ºé—´å¤æ‚åº¦ï¼š*O(N)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189740301","body":"## æ€è·¯\n\n---\n\nå•è°ƒæ ˆï¼Œèƒ½åˆ†å—çš„æ¡ä»¶æ˜¯ä¸‹ä¸€ä¸ªå—çš„æœ€å°å€¼å¤§äºç­‰äºå‰ä¸€ä¸ªå—çš„æœ€å¤§å€¼ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªå•è°ƒæ ˆä¿å­˜é‡åˆ°çš„å€¼ï¼Œå¦‚æœæ–°çš„å€¼å¤§äºç­‰äºæ ˆé¡¶çš„å€¼å°±å…¥æ ˆï¼Œå¦åˆ™å°±è¦åˆ¤æ–­è¿™ä¸ªæ¯”æ ˆé¡¶å°çš„å€¼æ˜¯ä¸æ˜¯æ¯”æ ˆé¡¶å‰é¢çš„å—çš„æœ€å¤§å€¼éƒ½å¤§ï¼Œä¸æ»¡è¶³çš„å°±å‡ºæ ˆï¼ˆç›¸å½“äºåˆå¹¶å—ï¼‰ï¼Œæœ€åæ ˆçš„é•¿åº¦å°±æ˜¯æœ€å¤šèƒ½å®Œæˆæ’åºçš„å—çš„æ•°é‡ã€‚\n\n## ä»£ç \n\n---\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for n in arr:\n            if not stack or n >= stack[-1]:\n                stack.append(n)\n            else:\n                tmp = stack.pop()\n                while stack and stack[-1] > n:\n                    stack.pop()\n                stack.append(tmp)\n        return len(stack)\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n---\n\n- æ—¶é—´å¤æ‚åº¦ï¼š*O(N)*\n- ç©ºé—´å¤æ‚åº¦ï¼š*O(N)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190970768","body":"## æ€è·¯\n\n---\n\nå…ˆéå†ä¸€éæ‰¾åˆ°æœ«å°¾èŠ‚ç‚¹å’Œæ€»èŠ‚ç‚¹æ•°ï¼Œä¸‹ä¸€ééå†æ‰¾åˆ°æ–°çš„æœ«å°¾èŠ‚ç‚¹å’Œå¤´èŠ‚ç‚¹ï¼ˆæ³¨æ„kæœ‰å¯èƒ½æ¯”æ€»èŠ‚ç‚¹æ•°å¤§ï¼Œéœ€è¦æ±‚æ¨¡ï¼‰ï¼Œç„¶åæ›´æ”¹èŠ‚ç‚¹ä¹‹é—´çš„å…³ç³»å³å¯ã€‚\n\n## ä»£ç \n\n---\n\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next or k==0: return head\n        n_nodes = 1\n        tail = p = head\n        while tail.next:\n            n_nodes += 1\n            tail = tail.next\n        for _ in range(n_nodes - k%n_nodes - 1):\n            p = p.next\n        tail.next = head\n        new_head = p.next\n        p.next = None\n        return new_head\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n---\n\n- æ—¶é—´å¤æ‚åº¦ï¼š*O(N)*\n- ç©ºé—´å¤æ‚åº¦ï¼š*O(1)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192118850","body":"## æ€è·¯\n\n---\n\nè®¾ç½®ä¸€ä¸ªå“¨å…µèŠ‚ç‚¹ä»¥ä¿æŒåé¢æ“ä½œçš„ä¸€è‡´æ€§ï¼ŒcurèŠ‚ç‚¹æŒ‡å‘å½“å‰å‡†å¤‡äº¤æ¢çš„èŠ‚ç‚¹ä¸­çš„ç¬¬ä¸€ä¸ªï¼ŒprevæŒ‡å‘curçš„å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæ¯”è¾ƒç›´è§‚åœ°å°±èƒ½ä¿®æ”¹curä¸curçš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„é¡ºåºï¼Œå¦‚æ­¤å¾ªç¯ç›´åˆ°curæ˜¯ç©ºçš„æˆ–è€…curæ²¡æœ‰ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚\n\n## ä»£ç \n\n---\n\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next : return head\n        new_head = ListNode(next=head)\n        prev, cur = new_head, head\n        while cur and cur.next:\n            next_node = cur.next\n            prev.next = next_node\n            cur.next = next_node.next\n            next_node.next = cur\n            prev = cur\n            cur = cur.next\n        return new_head.next\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n---\n\n- æ—¶é—´å¤æ‚åº¦ï¼š*O(N)*\n- ç©ºé—´å¤æ‚åº¦ï¼š*O(1)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193145441","body":"## æ€è·¯---\r\né«˜åº¦å¹³è¡¡çš„äºŒå‰æœç´¢æ ‘æ­£å¥½ä¸­åºéå†æ˜¯æœ‰åºçš„ï¼Œæ‰€ä»¥æ¯æ£µå­æ ‘çš„ä¸­é—´èŠ‚ç‚¹æ­£å¥½å°±æ˜¯æ ¹ç»“ç‚¹ï¼Œä½¿ç”¨å¿«æ…¢æŒ‡é’ˆæ‰¾åˆ°ä¸­é—´èŠ‚ç‚¹ç„¶åé€’å½’åœ°æ„å»ºå·¦å³å­æ ‘ã€‚\r\n## ä»£ç ---\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        def buildTree(start, end):\r\n            if start == end: return None\r\n            mid = findMid(start, end)\r\n            return TreeNode(val=mid.val, left=buildTree(start, mid), right=buildTree(mid.next, end)) \r\n\r\n        def findMid(start, end):\r\n            if start == end: return start\r\n            dummyhead = ListNode(next=start)\r\n            slow = fast = dummyhead\r\n            while fast != end:\r\n                slow = slow.next\r\n                fast = fast.next\r\n                if fast != end: fast = fast.next\r\n            return slow\r\n\r\n        return buildTree(head, None)\r\n```\r\n## å¤æ‚åº¦åˆ†æ---- \r\næ—¶é—´å¤æ‚åº¦ï¼š*O(NlogN)*\r\nç©ºé—´å¤æ‚åº¦ï¼š*O(N)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193288714","body":"## æ€è·¯\n\n---\n\nä¸¤ä¸ªæŒ‡é’ˆåŒæ—¶éå†ï¼Œaåˆ°å°¾éƒ¨åä»bå¤´éƒ¨å¼€å§‹éå†ï¼Œbåˆ°å°¾éƒ¨åä»aå¤´éƒ¨å¼€å§‹éå†ï¼Œaå’Œbç›¸é‡æ—¶å³ä¸ºèŠ‚ç‚¹ã€‚\n\n## ä»£ç \n\n---\n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        a = headA\n        b = headB\n        while a != b:\n            a = a.next if a else headB\n            b = b.next if b else headA\n        return a\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n---\n\n- æ—¶é—´å¤æ‚åº¦ï¼š*O(N)*\n- ç©ºé—´å¤æ‚åº¦ï¼š*O(1)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193498379","body":"## æ€è·¯\n\n---\n\nå¿«æ…¢æŒ‡é’ˆåŒæ—¶ä»å¤´ç»“ç‚¹å‡ºå‘ï¼Œåˆ†åˆ«ä»¥2å’Œ1çš„æ­¥é•¿éå†é“¾è¡¨ï¼Œåœ¨éå†è¿‡ç¨‹ä¸­ç¬¬ä¸€æ¬¡ç›¸é‡åå¿«æŒ‡é’ˆå›åˆ°å¤´ç»“ç‚¹ï¼Œæ­¤æ—¶å¿«æŒ‡é’ˆå’Œæ…¢æŒ‡é’ˆåˆ°ç¯å½¢é“¾è¡¨ç¯çš„èµ·å§‹ç‚¹çš„è·ç¦»ç›¸åŒï¼Œéƒ½ä»¥1çš„æ­¥é•¿ç»§ç»­éå†ï¼Œç¬¬äºŒæ¬¡ä¸¤ä¸ªæŒ‡é’ˆç›¸é‡çš„èŠ‚ç‚¹å°±æ˜¯å…¥ç¯çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚\n\n## ä»£ç \n\n---\n\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        if not head: return None\n        fast = slow = head\n        while fast:\n            fast = fast.next\n            if fast: fast = fast.next\n            slow = slow.next\n            if fast == slow:\n                break\n        if not fast: return None\n        fast = head\n        while fast != slow:\n            fast = fast.next\n            slow = slow.next\n        return fast\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n---\n\n- æ—¶é—´å¤æ‚åº¦ï¼š*O(N)*\n- ç©ºé—´å¤æ‚åº¦ï¼š*O(1)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194953260","body":"## æ€è·¯\n\n---\n\nå“ˆå¸Œè¡¨+åŒå‘é“¾è¡¨æ¥ä¿è¯getå’Œputéƒ½æ˜¯O(1)æ—¶é—´å¤æ‚åº¦ï¼Œä½¿ç”¨headå’Œtailä¸¤ä¸ªè™šæ‹ŸèŠ‚ç‚¹ä¿æŒæ“ä½œä¸€è‡´æ€§ï¼Œè¶Šé è¿‘headçš„èŠ‚ç‚¹è¶Šä¹…æœªè¢«ä½¿ç”¨ï¼Œæ¯ä¸ªèŠ‚ç‚¹é™¤äº†è¦ä¿å­˜valueå’Œé‚»æ¥çš„èŠ‚ç‚¹ï¼Œè¿˜éœ€è¦ä¿å­˜keyæ–¹ä¾¿å¼¹å‡ºå“ˆå¸Œè¡¨ä¸­çš„é”®å€¼å¯¹ã€‚\n\n## ä»£ç \n\n---\n\n```python\nclass BiListNode:\n    def __init__(self, key=0, val=0, next=None, prev=None):\n        self.key = key\n        self.val = val\n        self.next = next\n        self.prev = prev\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.d = {}\n        self.head = BiListNode()\n        self.tail = BiListNode(prev=self.head)\n        self.head.next = self.tail\n        self.cnt = 0\n    def get(self, key: int) -> int:\n        if key not in self.d.keys(): return -1\n        node = self.d[key]\n        self.moveToTail(node)\n        return node.val\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.d.keys():\n            node = self.d[key]\n            node.val = value\n            self.moveToTail(node)\n        elif self.cnt < self.cap:\n            self.addNewNode(key, value)\n            self.cnt += 1\n        else:\n            self.addNewNode(key, value)\n            self.discard_LRU()\n\n    def moveToTail(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        self.tail.prev = node\n        node.next = self.tail\n\n    def addNewNode(self, key, value):\n        node = BiListNode(key=key, val=value, next=self.tail, prev=self.tail.prev)\n        self.tail.prev.next = node\n        self.tail.prev = node\n        self.d[key] = node\n    \n    def discard_LRU(self):\n        discard_node = self.head.next\n        self.head.next = discard_node.next\n        discard_node.next.prev = self.head\n        self.d.pop(discard_node.key)\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n---\n\n- æ—¶é—´å¤æ‚åº¦ï¼šgetå’Œputéƒ½æ˜¯*O(1)*\n- ç©ºé—´å¤æ‚åº¦ï¼š*O(N)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196814958","body":"## æ€è·¯\n\n---\n\né€’å½’åœ°è¿›è¡Œæ·±åº¦ä¼˜å…ˆéå†ï¼Œéå†è¿‡ç¨‹ä¸­ä¿å­˜æ‰€æœ‰è§è¿‡çš„èŠ‚ç‚¹çš„æœ€å¤§æ·±åº¦ä»¥åŠå½“å‰å±‚çš„æ·±åº¦ï¼Œå½“æ·±åº¦è¶…è¿‡å½“å‰ä¿å­˜çš„æœ€å¤§æ·±åº¦åˆ™æ›´æ–°ã€‚\n\n## ä»£ç \n\n---\n\n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        ans = [0]\n        def dfs(root, level):\n            if not root: return\n            dfs(root.left, level+1)\n            dfs(root.right, level+1)\n            ans[0] = max(ans[0], level)\n        dfs(root, 1)\n        return ans[0]\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n---\n\n- æ—¶é—´å¤æ‚åº¦ï¼š*O(N)ï¼Œ Næ˜¯æ ‘ä¸­èŠ‚ç‚¹çš„æ•°é‡*\n- ç©ºé—´å¤æ‚åº¦ï¼š*O(M)ï¼Œ Mæ˜¯æ ‘çš„æ·±åº¦*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197564187","body":"## æ€è·¯\n\n---\n\nä½¿ç”¨ç›¸åŒçš„é¡ºåºåŒæ—¶éå†ä¸¤æ£µæ ‘ï¼ŒåŒæ—¶æ¯”è¾ƒèŠ‚ç‚¹çš„å€¼æ˜¯å¦ç›¸åŒã€‚\n\n## ä»£ç \n\n---\n\n```python\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q: return True\n        if (not p and q) or (p and not q): return False\n        if p.val != q.val: return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n---\n\n- æ—¶é—´å¤æ‚åº¦ï¼š*O(N)ï¼ŒNæ˜¯èŠ‚ç‚¹æ•°*\n- ç©ºé—´å¤æ‚åº¦ï¼š*O(M)ï¼Œ Mæ˜¯æ ‘çš„æœ€å¤§æ·±åº¦*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198815434","body":"## æ€è·¯\n\n---\n\næ·±åº¦æœ‰ä¼˜å…ˆéå†æ ‘ï¼Œéå†è¿‡ç¨‹è®°å½•è·¯å¾„ä¸Šçš„å€¼ï¼Œå½“æ‰¾åˆ°å¶å­èŠ‚ç‚¹åç´¯åŠ åˆ°ç»“æœä¸­ã€‚\n\n## ä»£ç \n\n---\n\n```python\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        sum = [0]\n        def dfs(root, value):\n            if not root.left and not root.right:\n                sum[0] += value * 10 + root.val\n            else:\n                if root.left:\n                    dfs(root.left, value*10 + root.val)\n                if root.right:\n                    dfs(root.right, value*10 + root.val)\n        dfs(root, 0)\n        return sum[0]\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n---\n\n- æ—¶é—´å¤æ‚åº¦ï¼š*O(N)ï¼Œ Næ˜¯èŠ‚ç‚¹çš„æ•°ç›®*\n- ç©ºé—´å¤æ‚åº¦ï¼š*O(M), Mæ˜¯æ ‘çš„é«˜åº¦*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200105517","body":"## æ€è·¯\n\n---\n\nè¿›è¡Œå±‚åºéå†ï¼Œä¿ç•™æ¯å±‚æœ€å·¦è¾¹çš„å€¼ã€‚\n\n## ä»£ç \n\n---\n\n```python\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        level = [root]\n        while level:            \n            left = level[0]\n            for i in range(len(level)):\n                node = level.pop(0)\n                if node.left: level.append(node.left)\n                if node.right: level.append(node.right)\n        return left.val\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n---\n\n- æ—¶é—´å¤æ‚åº¦ï¼š*O(N), Næ˜¯æ•°ä¸­æ‰€æœ‰èŠ‚ç‚¹çš„æ•°é‡*\n- ç©ºé—´å¤æ‚åº¦ï¼š*O(M)ï¼ŒMæ˜¯æœ€å¤§ä¸€å±‚çš„èŠ‚ç‚¹æ•°*","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200865643","body":"## æ€è·¯\n\n---\n\néå†ä¸€éäºŒå‰æ ‘çš„èŠ‚ç‚¹ï¼Œä¿å­˜èŠ‚ç‚¹çš„æ¨ªçºµåæ ‡å’ŒèŠ‚ç‚¹çš„å€¼ï¼Œæ ¹æ®çºµåæ ‡ï¼Œæ¨ªåæ ‡ï¼ŒèŠ‚ç‚¹çš„å€¼ä¾æ¬¡æ’åºï¼Œå†éå†ä¸€éå°†æ¯ä¸€åˆ—çš„èŠ‚ç‚¹çš„å€¼å–å‡ºã€‚\n\n## ä»£ç \n\n---\n\n```python\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        nodes = []\n        def dfs(root, row, col):\n            if not root: return None\n            nodes.append((col, row, root.val))\n            dfs(root.left, row+1, col-1)\n            dfs(root.right, row+1, col+1)\n        dfs(root, 0, 0)\n        nodes.sort()\n        ans = []\n        i = j = 0\n        while i < len(nodes):\n            col_ans = []\n            while j< len(nodes) and nodes[j][0] == nodes[i][0]:\n                col_ans.append(nodes[j][2])\n                j += 1\n            ans.append(col_ans)\n            i = j\n        return ans\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n---\n\n- æ—¶é—´å¤æ‚åº¦ï¼š*O(NlogN),Næ˜¯èŠ‚ç‚¹çš„æ•°é‡*\n- ç©ºé—´å¤æ‚åº¦ï¼š*O(N)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201977851","body":"## æ€è·¯\n\n---\n\néå†ä¸€éæ•°ç»„çš„è¿‡ç¨‹ä¸­ä½¿ç”¨å“ˆå¸Œè¡¨å°†å·²ç»è§è¿‡çš„æ•°å’Œå…¶ä¸‹æ ‡å¯¹åº”èµ·æ¥ï¼Œå½“æ‰¾åˆ°å’Œä¸ºtargetçš„å¦ä¸€ä¸ªæ•°å·²ç»åœ¨è¡¨ä¸­æ—¶è¿”å›ç»“æœã€‚\n\n## ä»£ç \n\n---\n\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        d = {}\n        for idx, num in enumerate(nums):\n            if num in d:\n                return [idx, d[num]]\n            else:\n                d[target - num] = idx\n```\n\n```cpp\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> hashtable;\n        for(int i=0; i < nums.size(); i++){\n            auto p = hashtable.find(nums[i]);\n            if(p != hashtable.end()){\n                return {i, p->second};\n            }\n            hashtable[target - nums[i]] = i;\n        }\n        return {};\n   }\n};\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n---\n\n- æ—¶é—´å¤æ‚åº¦ï¼š*O(N)*\n- ç©ºé—´å¤æ‚åº¦ï¼š*O(N)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1204007216","body":"## æ€è·¯\n\n---\n\nå…ˆä½¿ç”¨hashè¡¨ç»Ÿè®¡å‡ºç°æ¬¡æ•°ï¼Œç„¶åä½¿ç”¨å¤§é¡¶å †å‡ºæ ˆkæ¬¡ã€‚\n\n## ä»£ç \n\n---\n\n```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        count = list(collections.Counter(nums).items())\n        count = list(map(lambda x: (-x[1], x[0]), count))\n        heapq.heapify(count)\n        res = []\n        for _ in range(k):\n            res.append(heapq.heappop(count)[1])\n        return res\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n---\n\n- æ—¶é—´å¤æ‚åº¦ï¼š*O(klogm), mæ˜¯å †ä¸­å…ƒç´ ä¸ªæ•°ï¼Œå³æ•°ç»„ä¸­å€¼ä¸åŒæ•°çš„ä¸ªæ•°*\n- ç©ºé—´å¤æ‚åº¦ï¼š*O(N)ï¼Œ Nä¸ºæ•°ç»„é•¿åº¦*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204712302","body":"## æ€è·¯\n\n---\n\néå†ä¸€éæ‰€æœ‰èŠ‚ç‚¹ï¼Œå› ä¸ºèŠ‚ç‚¹æ•°åœ¨500ä¸ªä»¥å†…ï¼Œæ‰€ä»¥å€Ÿç”¨å“ˆå¸Œè¡¨æš´åŠ›æšä¸¾å³å¯ï¼Œç”¨å“ˆå¸Œè¡¨ç»Ÿè®¡ä»¥è¯¥èŠ‚ç‚¹ä¸ºåŸç‚¹ï¼Œæ‰€æœ‰èŠ‚ç‚¹åˆ°è¯¥èŠ‚ç‚¹çš„è·ç¦»ï¼Œå’Œç›¸åŒè·ç¦»çš„èŠ‚ç‚¹æ•°çš„é”®å€¼å¯¹ï¼Œå› ä¸ºè¦è€ƒè™‘é¡ºåºï¼Œæ‰€ä»¥\n\n## ä»£ç \n\n---\n\n```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        n = len(points)\n        ans = 0\n        for p in points:\n            d = defaultdict(int)\n            cnt = 0\n            for q in points:\n                dist = (p[0] - q[0])**2 + (p[1] - q[1])**2\n                d[dist] += 1\n            for dist, n in d.items():\n                ans += n*(n-1)\n        return ans\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n---\n\n- æ—¶é—´å¤æ‚åº¦ï¼š*O(N^2),Næ˜¯èŠ‚ç‚¹æ•°é‡*\n- ç©ºé—´å¤æ‚åº¦ï¼š*O(N)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206275493","body":"## æ€è·¯\r\n\r\n---\r\n\r\nä½¿ç”¨ä¸€ä¸ªæ»‘åŠ¨çª—å£ï¼Œå½“æ²¡æœ‰é‡å¤å­—ç¬¦æ—¶ä¸æ–­æ‰©å¼ å³è¾¹ç•Œï¼Œä½¿ç”¨å“ˆå¸Œè¡¨è®°å½•å‡ºç°è¿‡çš„å­—ç¬¦ï¼Œå½“é‡åˆ°é‡å¤å­—ç¬¦æ—¶è°ƒæ•´å·¦è¾¹ç•Œç›´åˆ°çª—å£ä¸­æ²¡æœ‰é‡å¤å­—ç¬¦ï¼Œç»“æœå°±æ˜¯è¿™ä¸ªè¿‡ç¨‹ä¸­æ»‘åŠ¨çª—å£æœ€å¤§çš„é•¿åº¦ã€‚\r\n\r\n## ä»£ç \r\n\r\n---\r\n\r\n```python\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        ans = 0\r\n        d = defaultdict(int)\r\n        l = 0\r\n        for i in range(len(s)):\r\n            if d[s[i]] == 0:\r\n                d[s[i]] = 1\r\n            else:\r\n                while s[l] != s[i]:\r\n                    d[s[l]] = 0\r\n                    l += 1\r\n                l += 1\r\n            ans = max(i - l + 1, ans)\r\n        return ans\r\n```\r\n\r\n## å¤æ‚åº¦åˆ†æ\r\n\r\n---\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š*O(N)*\r\n- ç©ºé—´å¤æ‚åº¦ï¼š*O(M)ï¼ŒMæ˜¯å­—ç¬¦ä¸²ä¸­æ— é‡å¤æœ€é•¿å­ä¸²çš„é•¿åº¦ã€‚*","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207419588","body":"## æ€è·¯\n\n---\n\nå®³ï¼Œè™½ç„¶ä»¥å‰åšè¿‡ä¸€éäº†ï¼Œè¿™æ¬¡è¿˜æ˜¯æ²¡åšå‡ºæ¥ã€‚ã€‚ã€‚\n\nå‰ç¼€å’Œ+å“ˆå¸Œè¡¨ï¼Œè®¡ç®—å®Œå‰ç¼€å’Œä¹‹åéå†ä¸€éï¼ŒåŸºäºåŒä½™å®šç†æŸ¥æ‰¾æ‰€æœ‰æ•°ä¹‹å’Œä¸å½“å‰ä½ç½®å‰ç¼€å’Œä¹‹å·®åœ¨ä¸åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œå¦‚æœåœ¨çš„è¯åˆ™è¯´æ˜ä¸¤æ®µå‰ç¼€å’Œä¸­é—´å·®çš„å­ä¸²å¯ä»¥è¢«kæ•´é™¤ï¼Œæ ¹æ®æƒ…å†µæ›´æ–°ç»“æœã€‚\n\n## ä»£ç \n\n---\n\n```python\nclass Solution:\n    def solve(self, nums, k):\n        presum = [0] + nums\n        for i in range(1, len(presum)):\n            presum[i] = (presum[i] + presum[i-1]) % k\n        s = presum[-1]\n        if s % k == 0: return 0\n        ans = len(nums)\n        d = {0:0}\n        for i in range(1, len(presum)):\n            if (presum[i] - s)%k in d:\n                ans = min(ans, i-d[(presum[i] - s)%k])\n            d[presum[i]] = i\n        if ans == len(nums):\n            return -1\n        return ans\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n---\n\n- æ—¶é—´å¤æ‚åº¦ï¼š*O(N)ï¼ŒNä¸ºæ•°ç»„çš„é•¿åº¦*\n- ç©ºé—´å¤æ‚åº¦ï¼š*O(N)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207928600","body":"## æ€è·¯\n\n---\n\nå¿«æ…¢æŒ‡é’ˆï¼Œéƒ½ä»headå‡ºå‘ï¼Œå¿«æŒ‡é’ˆæ¯æ¬¡èµ°ä¸¤æ­¥ï¼Œæ…¢æŒ‡é’ˆæ¯æ¬¡èµ°ä¸€æ­¥ï¼Œæ ¹æ®é¢˜ç›®åˆ†æç»ˆæ­¢æ¡ä»¶ï¼Œç›´åˆ°å¿«æŒ‡é’ˆå’Œå¿«æŒ‡é’ˆçš„nextéƒ½æœ‰èŠ‚ç‚¹æ—¶æ‰ç»§ç»­å¾ªç¯ã€‚\n\n## ä»£ç \n\n---\n\n```python\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n---\n\n- æ—¶é—´å¤æ‚åº¦ï¼š*O(N)*\n- ç©ºé—´å¤æ‚åº¦ï¼š*O(1)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208955358","body":"## æ€è·¯\n\n---\n\nåŒæŒ‡é’ˆ\n\n## ä»£ç \n\n---\n\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n < 2: return n\n        i = j = 0\n        p = 0\n        while i < n:\n            while j < n and nums[j] == nums[i]:\n                j += 1\n            nums[p] = nums[i]\n            p += 1\n            i = j\n        return p\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n---\n\n- æ—¶é—´å¤æ‚åº¦ï¼š*O(N)*\n- ç©ºé—´å¤æ‚åº¦ï¼š*O(1)*","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xixiao51":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185141987","body":"### Idea\nTake K as a carry and add it to the lowest digit, then update carry, and keep going to higher digit.\n\n\n### Code\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int cur = k;\n        int i = num.length - 1;\n        while(i >= 0 || cur > 0) {\n            if(i >= 0) {\n                cur = cur + num[i--];\n            }\n            res.add(cur % 10);\n            cur /= 10; \n        }\n        \n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(max(n, logk)), n is the length of num\n- Space complexity: O(max(n, logk))\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186075682","body":"### Idea\nLoop twice on the string S.\nFirst forward pass to find shortest distant to character on left.\nSecond backward pass to find shortest distant to character on right.\n\n\n### Code\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] answer = new int[len];\n        int d = len;\n        for(int i = 0; i < len; i++) {\n            d = s.charAt(i) == c ? 0 : d + 1;\n            answer[i] = d;\n        }\n        \n        d = len;\n        for(int i = len - 1; i >= 0; i--) {\n            d = s.charAt(i) == c ? 0 : d + 1;\n            answer[i] = Math.min(answer[i], d);\n        }\n        \n        return answer;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n), n is the length of string s\n- Space complexity: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186435493","body":"### Idea\nUse an array to represent the stack. Push will add new integer to the array. Pop removes the last element in the array and increment will add val to the first k elements of the array.\n\n### Code\n```java\nclass CustomStack {\n    private List<Integer> stack;\n    private int max;\n\n    public CustomStack(int maxSize) {\n        stack = new ArrayList<>();\n        max = maxSize;\n    }\n    \n    public void push(int x) {\n        if(stack.size() < max) {\n            stack.add(x);\n        }\n    }\n    \n    public int pop() {\n        if(stack.isEmpty()) {\n            return -1;\n        }\n        int top = stack.get(stack.size() - 1);\n        stack.remove(stack.size() - 1);\n        return top;\n    }\n    \n    public void increment(int k, int val) {\n        for(int i = Math.min(stack.size(), k); i > 0; i--) {\n            stack.set(i - 1, stack.get(i - 1) + val);\n        }\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(1) for push and pop and O(k) for increment.\n- Space complexity: O(n), n is the maxsize\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186604148","body":"### Idea\nUse 2 stacks one to store all the integer k and one to store all the decoded strings.\n### Code\n```java\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder str = new StringBuilder();\n        Stack<Integer> num = new Stack<>();\n        Stack<StringBuilder> letters = new Stack<>();\n        int k = 0;\n        for(char c: s.toCharArray()) {\n            if(Character.isDigit(c)) {\n                k = k * 10 + (c - '0');\n            } else if(c == '[') {\n                num.push(k);\n                k = 0;\n                letters.push(str);\n                str = new StringBuilder();\n            } else if(c == ']') {\n                StringBuilder temp = letters.pop();\n                for(int i = num.pop(); i > 0; i--) {\n                    temp.append(str);\n                }\n                str = temp;\n            } else {\n                str.append(c);\n            }\n        }\n        \n        return str.toString();\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(kn)\n- Space complexity: O(num(k) + num(char))\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188233701","body":"### Idea\nuse two stacks to make a queue\n\n### Code\n```java\nclass MyQueue {\n\n    private Stack<Integer> stack1;\n    private Stack<Integer> stack2;\n    private int front;\n    \n    public MyQueue() {\n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n    \n    // O(1)\n    public void push(int x) {\n        if(stack1.isEmpty()) {\n            front = x;\n        }\n        stack1.push(x);\n    }\n    \n    // Amortized O(1)\n    public int pop() {\n        if(stack2.isEmpty()) {\n            while(!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.pop();\n    }\n    \n    // O(1)\n    public int peek() {\n        if(stack2.isEmpty()) {\n            return front;\n        }\n        return stack2.peek();\n    }\n    \n    // O(1)\n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(1) per operation, Pop - Amortized O(1) per operation.\n- Space complexity: O(n) for Push, O(1) for others\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189905757","body":"### Idea\nnon-strictly increasing stack\n\n### Code\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> stack =  new Stack<>();\n        for(int i: arr) {\n            if(!stack.isEmpty() && i < stack.peek()) {\n                int top = stack.peek();\n                while(!stack.isEmpty() && i < stack.peek()) {\n                    stack.pop();\n                }\n                stack.add(top);\n            } else {\n                stack.add(i);\n            }\n        }\n        \n        return stack.size();\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n)\n- Space complexity: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190800674","body":"### Idea\n1. To close the linked list into the ring.\n\n2. To break the ring after the new tail and just in front of the new head.\n\n### Code\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null) {\n            return head;\n        }\n        ListNode tail = head;\n        int len = 1;\n        while(tail.next != null) {\n            tail = tail.next;\n            len++;\n        }\n        tail.next = head;\n        ListNode cur = head;\n        for(int i = 1; i <  len - (k % len); i++) {\n            cur = cur.next;\n        }\n        tail = cur.next;\n        cur.next = null;\n\n        return tail;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n)\n- Space complexity: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192051192","body":"### Idea\n1. Recursion\n\n2. Iteration\n### Code\n```java\n// Recursion\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null) {\n            return head;\n        }\n        \n        ListNode pre = head; \n        ListNode cur = head.next;\n        \n        pre.next = swapPairs(cur.next);\n        cur.next = pre;\n        \n        return cur;\n    }\n}\n\n// Iteration\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        \n        ListNode dummy = new ListNode(-1); \n        dummy.next = head;\n        ListNode pre = dummy;\n        \n        while(head != null && head.next != null) {\n            ListNode cur = head;\n            ListNode second = head.next;\n            \n            pre.next = second;\n            cur.next = second.next;\n            second.next = cur;\n            \n            pre = cur;\n            head = cur.next;\n        }\n        \n        return dummy.next;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n)\n- Space complexity: O(n) for recursion, O(1) for iteration\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193000900","body":"### Idea\n- Recursion & Inorder traversal\n- Fast slow pointer to find median and change into subproblems\n\n### Code\n```java\n// O(nlogn)\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null) {\n            return null;\n        }\n        return sortedListToBST(head, null);\n    }\n    \n    private TreeNode sortedListToBST(ListNode head, ListNode tail) {\n        if(head == tail) {\n            return null;\n        }\n        \n        ListNode slow = head;\n        ListNode fast = head;\n        while(fast != tail && fast.next != tail) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        TreeNode node = new TreeNode();\n        node.left = sortedListToBST(head, slow);\n        node.val = slow.val;\n        node.right = sortedListToBST(slow.next, tail);\n        return node;\n    }\n}\n\n// O(n) - use a global node and index for recursion\nclass Solution {\n    ListNode node;\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null) {\n            return null;\n        }\n        node = head;\n        ListNode cur = head;\n        int size = 1;\n        while(cur.next != null) {\n            cur = cur.next;\n            size++;\n        }\n        return buildBST(1, size + 1);\n    }\n    \n    private TreeNode buildBST(int head, int tail) {\n        if(head == tail) {\n            return null;\n        }\n        \n        int mid = head + (tail - head) / 2;\n        TreeNode res = new TreeNode();\n        res.left = buildBST(head, mid);\n        res.val = node.val;\n        node = node.next;\n        res.right = buildBST(mid + 1, tail);\n        return res;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n)\n- Space complexity: O(logn) for recursion\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193190200","body":"Two pointers\n\n### Code\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode a = headA;\n        ListNode b = headB;\n        while(a != b) {\n            a = a == null ? headB : a.next;\n            b = b == null ? headA : b.next;\n        }\n        return a;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(m + n)\n- Space complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193620838","body":"### Idea\nHash Table / Fast & slow pointers\n\n### Code\n```java\n// Hash Table\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head == null) {\n            return null;\n        }\n        Set<ListNode> map = new HashSet<>();\n        while(!map.contains(head) && head.next != null) {\n            map.add(head);\n            head = head.next;\n        }\n        return head.next == null ? null : head;\n    }\n}\n\n// Fast & slow pointers\n// a + 2b + c = 2(a + b)\n// a = c\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head == null) {\n            return null;\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if(fast == slow) {\n                fast = head;\n                break;\n            }\n        }\n        if(fast == null || fast.next == null) {\n            return null;\n        }\n        while(fast != slow) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n)\n- Space complexity: O(n) / O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195165462","body":"### Idea\nHashmap + DoubleLinkedList\n\n### Code\n```java\nclass LRUCache {\n    class DLinkedNode {\n        int key;\n        int value;\n        DLinkedNode pre;\n        DLinkedNode post;\n    }\n    \n    //Create a dummy head and tail to mark the boundary, then we don't need to check the NULL node\n    // Add the new node right after head;\n    private void addNode(DLinkedNode node) {\n        node.pre = head;\n        node.post = head.post;\n        head.post.pre = node;\n        head.post = node;\n    }\n    \n    private void removeNode(DLinkedNode node) {\n        DLinkedNode pre = node.pre;\n        DLinkedNode post = node.post;\n        \n        pre.post = post;\n        post.pre = pre;\n    }\n    \n    private void moveToHead(DLinkedNode node) {\n        this.removeNode(node);\n        this.addNode(node);\n    }\n    \n    private DLinkedNode popTail() {\n        DLinkedNode last = tail.pre;\n        this.removeNode(last);\n        return last;\n    }\n    \n    private Map<Integer, DLinkedNode> cache = new HashMap<>();\n    private int size;\n    private int capacity;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity;\n        head = new DLinkedNode();\n        head.pre = null;\n        tail = new DLinkedNode();\n        tail.post = null;\n        head.post = tail;\n        tail.pre = head;\n    }\n    \n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            return -1;\n        }\n        this.moveToHead(node);\n        return node.value;\n    }\n    \n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if(node != null) {\n            node.value = value;\n            this.moveToHead(node);\n        } else {\n            DLinkedNode newNode = new DLinkedNode();\n            newNode.value = value;\n            newNode.key = key;\n            this.cache.put(key, newNode);\n            this.addNode(newNode);\n            size++;\n            if(size > capacity) {\n                DLinkedNode last = this.popTail();\n                this.cache.remove(last.key);\n                size--;\n            }\n        }\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(1)\n- Space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196324503","body":"### Idea\nDFS / BFS\n\n### Code\n```java\n// DFS\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) {\n            return 0;\n        } else {\n            return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n        }\n    }\n}\n\n// BFS\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) {\n            return 0;\n        }\n        Queue<TreeNode> q = new LinkedList<>();\n        int maxDepth = 0;\n        q.add(root);\n        while(!q.isEmpty()) {\n            maxDepth++;\n            for(int i = q.size(); i > 0; i--) {\n                TreeNode node = q.poll();\n                if(node.left != null) {\n                    q.add(node.left);\n                }\n                if(node.right != null) {\n                    q.add(node.right);\n                }\n            }\n        }\n        return maxDepth;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n)\n- Space complexity: O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197072794","body":"### Idea\nDFS / BFS\n\n### Code\n```java\n// DFS\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null & q == null) {\n            return true;\n        } else if(p != null && q != null && p.val == q.val) {\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n        }\n        \n        return false;\n    }\n}\n\n// BFS\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null) {\n            return true;\n        } else if(p == null || q == null) {\n            return false;\n        }\n        \n        Queue<TreeNode> q1 = new LinkedList<>();\n        Queue<TreeNode> q2 = new LinkedList<>();\n        q1.add(p);\n        q2.add(q);\n        while(!q1.isEmpty() && !q2.isEmpty()) {\n            TreeNode n1 = q1.poll();\n            TreeNode n2 = q2.poll();\n            if(n1 ==  null && n2 == null) {\n                continue;\n            } else if(n1 == null || n2 == null) {\n                return false;\n            }\n            if(n1.val != n2.val) {\n                return false;\n            }\n            q1.add(n1.left);\n            q1.add(n1.right);\n            q2.add(n2.left);\n            q2.add(n2.right);\n        }\n\n        return true;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n)\n- Space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198782568","body":"### Idea\nDFS\n\n### Code\n```java\n// DFS\nclass Solution {\n    int sum = 0;\n    public int sumNumbers(TreeNode root) {\n        dfs(root, 0);\n        return sum;\n    }\n    \n    public void dfs(TreeNode node, int num) {\n        if(node != null) {\n            num = num * 10 + node.val;\n            if(node.left == null && node.right == null) {\n                sum += num;\n            }\n            dfs(node.left, num);\n            dfs(node.right, num);\n        }\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n)\n- Space complexity: O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200032241","body":"### Idea\nBFS\n\n### Code\n```java\n// BFS\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        if(root == null) {\n            return -1;\n        }\n        int val = root.val;\n        Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n        while(!q.isEmpty()) {\n            val = q.peek().val;\n            for(int i = q.size(); i > 0; i--) {\n                TreeNode node = q.poll();\n                if(node.left != null) {\n                    q.add(node.left);\n                }\n                if(node.right != null) {\n                    q.add(node.right);\n                }\n            }\n        }\n        \n        return val;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n)\n- Space complexity: O(n) worst","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200357450","body":"### Idea\nRecursion - preorder\n\n### Code\n```java\npublic class Codec {\n    private String spliter = \",\";\n    private String nn = \"null\";\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        buildString(root, sb);\n        return sb.toString();\n    }\n\n    private void buildString(TreeNode node, StringBuilder sb) {\n        if(node == null) {\n            sb.append(nn);\n            sb.append(spliter);\n        } else {\n            sb.append(node.val);\n            sb.append(spliter);\n            buildString(node.left, sb);\n            buildString(node.right, sb);\n        }\n    }\n    \n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        Queue<String> q = new LinkedList<>();\n        q.addAll(Arrays.asList(data.split(spliter)));\n        return buildTree(q);\n    }\n    \n    private TreeNode buildTree(Queue<String> q) {\n        String s = q.poll();\n        if(s.equals(nn)) {\n            return null;\n        } else {\n            TreeNode root = new TreeNode(Integer.valueOf(s));\n            root.left = buildTree(q);\n            root.right = buildTree(q);\n            return root;\n        }\n    }\n        \n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n)\n- Space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200840485","body":"### Idea\nUse dfs to generate a list contains x, y and val for each node. Then sort the list. From the sorted list, we then extract the results, and group them by the column index.\n\n### Code\n```java\nclass Solution {\n    List<List<Integer>> nodeList = new ArrayList();\n    \n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<List<Integer>> res = new ArrayList();\n        if(root == null) {\n            return res;\n        }\n        dfs(root, 0, 0);\n        // sort the node\n        Collections.sort(nodeList, (List<Integer> a, List<Integer> b) -> {\n            if (a.get(1) == b.get(1) && a.get(0) == b.get(0)) {\n                return a.get(2) - b.get(2);\n            }\n            if (a.get(1) == b.get(1)) {\n                return a.get(0) - b.get(0);\n            }\n            return a.get(1) - b.get(1);\n        });\n        int column = nodeList.get(0).get(1);\n        List<Integer> arr = new ArrayList<>();\n        for(List<Integer> l: nodeList) {\n            int y = l.get(1);\n            int val = l.get(2);\n            if(column == y) {\n                arr.add(val);\n            } else {\n                res.add(arr);\n                column = y;\n                arr = new ArrayList<>();\n                arr.add(val);\n            }\n        }\n        res.add(arr);\n        \n        return res;\n    }\n    \n    private void dfs(TreeNode node, int x, int y) {\n        if(node == null) {\n            return;\n        }\n        nodeList.add(Arrays.asList(x, y, node.val));\n        dfs(node.left, x + 1, y - 1);\n        dfs(node.right, x + 1, y + 1);\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(nlogn)\n- Space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201807024","body":"### Idea\nHashMap - we check if current element's complement already exists in the hash table. Otherwise insert elements into the hash table.\n\n### Code\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for(int i = 0; i < nums.length; i++) {\n            int remain = target - nums[i];\n            if(map.containsKey(remain)) {\n                return new int[]{ map.get(remain), i };\n            } else {\n                map.put(nums[i], i);\n            }\n        }\n        \n        return null;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n)\n- Space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203584550","body":"### Idea\nHeap\n\n### Code\n```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for(int num: nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        \n        PriorityQueue<Integer> heap = new PriorityQueue<>(\n            (n1, n2) -> map.get(n1) - map.get(n2));\n        \n        for(int n: map.keySet()) {\n            heap.add(n);\n            if(heap.size() > k) {\n                heap.poll();\n            }\n        }\n        \n        int[] res = new int[k];\n        for(int i = k - 1; i >= 0; i--) {\n            res[i] = heap.poll();\n        }\n        return res;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(nlogk)\n- Space complexity: O(n + k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204681804","body":"### Idea\nHashMap to store distance and find all tuples\n\n### Code\n```java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int res = 0;\n        for(int[] p1: points) {\n            int x1 = p1[0];\n            int y1 = p1[1];\n            HashMap<Integer, Integer> map = new HashMap<>();\n            for(int[] p2: points) {\n                if(p1.equals(p2)) continue;\n                int x2 = p2[0];\n                int y2 = p2[1];\n                int distance = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n                map.put(distance, map.getOrDefault(distance, 0) + 1);\n            }\n            for(int i: map.values()) {\n                res += i * (i - 1);\n            }\n        }\n        \n        return res;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n^2)\n- Space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206145055","body":"### Idea\nSliding window\n\n### Code\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int len = s.length();\n        int res = 0;\n        for(int i = 0, j = 0; j < len; j++) {\n            char c = s.charAt(j);\n            if(map.containsKey(c)) {\n                i = Math.max(map.get(c), i);\n            }\n            res = Math.max(j - i + 1, res);\n            map.put(c, j + 1);\n        }\n        \n        return res;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n)\n- Space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207111878","body":"### Idea\nSliding window\n\n### Code\n```java\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        HashMap<String, Integer> strMap = new HashMap<>();\n        for(String word: words) {\n            strMap.put(word, strMap.getOrDefault(word, 0) + 1);\n        }\n        List<Integer> res = new ArrayList<>();\n        int i = 0;\n        int len = words[0].length();\n        while(i < s.length() - len * words.length + 1) {\n            int j = i;\n            int size = 0;\n            HashMap<String, Integer> map = new HashMap<>();\n            while(j + len <= s.length()) {\n                String word = s.substring(j, j + len);\n                j += len;\n                if(strMap.containsKey(word)) {\n                    int count = map.getOrDefault(word, 0);\n                    int wordCount = strMap.get(word);\n                    if(count < wordCount) {\n                        map.put(word, ++count);\n                        if(count == wordCount) {\n                            ++size;\n                        }\n                        if(size == strMap.size()) {\n                            res.add(i);\n                            break;\n                        }\n                        continue;\n                    }\n                }\n                break;\n            }\n            i++;\n        }\n        \n        return res;\n    }\n}\n\n//optimized\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        HashMap<String, Integer> strMap = new HashMap<>();\n        for(String word: words) {\n            strMap.put(word, strMap.getOrDefault(word, 0) + 1);\n        }\n        List<Integer> res = new ArrayList<>();\n        int wordLen = words[0].length();\n        int size = words.length;\n        for (int i = 0; i < wordLen; i++) {\n            int left = i, right = i, count = 0;\n            HashMap<String, Integer> window = new HashMap<>();\n            while (right + wordLen <= s.length()) {\n                String r = s.substring(right, right + wordLen);\n                right += wordLen;\n                if (!strMap.containsKey(r)) {\n                    count = 0;\n                    left = right;\n                    window.clear();\n                } else {\n                    window.put(r, window.getOrDefault(r, 0) + 1);\n                    count++;\n                    while (window.getOrDefault(r, 0) > strMap.getOrDefault(r, 0)) {\n                        String l = s.substring(left, left + wordLen);\n                        count--;\n                        window.put(l, window.getOrDefault(l, 0) - 1);\n                        left += wordLen;\n                    }\n                    if (count == size) {\n                        res.add(left);\n                    }\n                }\n            }\n        }\n        \n        return res;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(a + n * b), n as the length of s, a as the length of words, and b as the length of each word\n- Space complexity: O(a + b)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207340896","body":"### Idea\n(totalSUm - delete) % k == 0;\ntotalSUm % k = delet%k\nlet totalSum % k = totalMod\ndelet%k = prefix[j] % k - prefix[i] %k = totalMod %k;\npre[i] % k = (pre[j] - totalMod) % k;\n\n### Code\n```java\nclass Solution {\n    public int solve(int[] nums, int k) {\n        int total = 0;\n        for (int n : nums) {\n            total += n;\n        }\n        int totalMod = Math.floorMod(total, k);\n\n        Map<Integer, Integer> map = new HashMap();\n        map.put(0, -1);\n        int prefix = 0;\n        int res = nums.length;\n        for (int i = 0; i < nums.length; i++) {\n            prefix += nums[i];\n            int curMod = Math.floorMod(prefix, k);\n            map.put(curMod, i);\n            int afterMod = Math.floorMod(prefix - totalMod, k);\n            if (map.containsKey(afterMod)) {\n                int len = i - map.get(afterMod);\n                res = len < res ? len : res;\n            }\n        }\n        return res == nums.length ? -1 : res;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n)\n- Space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207706839","body":"### Idea\nslow & fast pointer\n\n### Code\n```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while(fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n)\n- Space complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208968814","body":"### Idea\nslow & fast pointer\n\n### Code\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int i = 0;\n        for(int j = 1; j < nums.length; j++) {\n            if(nums[j] > nums[i]) {\n                nums[++i] = nums[j];\n            }\n        }\n        return i + 1;\n    }\n\n```\n\n**Complexity Analysis**\n- Time complexity: O(n)\n- Space complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/42#issuecomment-1209947078","body":"### Idea\nbinary search\n\n### Code\n```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int l = 0, r = nums.length - 1;\n        while(l <= r) {\n            int mid = l + (r - l) / 2;\n            if(target < nums[mid]) {\n                r = mid - 1;\n            } else if(target > nums[mid]) {\n                l = mid + 1;\n            } else {\n                return mid;\n            }\n        }\n        \n        return l;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(logn)\n- Space complexity: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"feikerwu":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185152522","body":"### æ€è·¯\r\n\r\nå¤§æ•°åŠ æ³•çš„é˜‰å‰²ç‰ˆï¼Œå°† K çœ‹ä½œæ˜¯æ¯æ¬¡åŠ æ³•çš„è¿›ä½å³å¯ã€‚\r\n\r\n### ä»£ç \r\n```js\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n  const { length } = num;\r\n\r\n  let carry = k;\r\n  for (let i = length - 1; i >= 0; i--) {\r\n    const value = (num[i] + carry) % 10;\r\n    carry = Math.floor((num[i] + carry) / 10);\r\n    num[i] = value;\r\n  }\r\n\r\n  while (carry) {\r\n    num.unshift(carry % 10);\r\n    carry = Math.floor(carry / 10);\r\n  }\r\n\r\n  return num;\r\n};\r\n```\r\n\r\n+ æ—¶é—´å¤æ‚åº¦ $O(N + logK)$, N ä¸ºä¼ å…¥æ•°æ® num çš„é•¿åº¦, K æ˜¯ä¼ å…¥çš„æ•°å­—ï¼ŒlogK è¡¨ç¤ºæ•°å­—Kçš„ä½æ•°\r\n+ ç©ºé—´å¤æ‚åº¦ $O(N + logK)$, N ä¸ºä¼ å…¥æ•°æ® num çš„é•¿åº¦, K æ˜¯ä¼ å…¥çš„æ•°å­—ï¼ŒlogK è¡¨ç¤ºæ•°å­—Kçš„ä½æ•°\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"heng518":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185153547","body":"class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int len = num.size() - 1;\n        bool flag = true;\n        \n        while(len >= 0 || k > 0)\n        {\n            if(flag)\n            {\n                if(len >= 0)\n                {\n                    k += num[len];\n                    len--;\n                }\n                res.insert(res.begin(), k % 10);\n                k /= 10;\n            \n                if(k == 0)\n                    flag = false;\n            }\n            else\n            {\n                res.insert(res.begin(), num[len]);\n                len--;\n            }\n        }\n        \n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186186039","body":"class Solution {\npublic:\n vector<int> shortestToChar(string s, char c) {\n        vector<int> vec;\n        vector<int> res;\n        \n        for(int i = 0; i < s.size(); i++)\n            if(s[i] == c)\n                vec.push_back(i);\n        \n        for(int i = 0; i < s.size(); i++)\n        {\n            int temp = INT_MAX;\n            for(int j = 0; j < vec.size(); j++)\n            {\n                temp = min(temp, abs(vec[j] - i));\n            }\n            res.push_back(temp);\n        }\n        \n        return res;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yaya-bb":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185155634","body":"\n## é¢˜ç›®åœ°å€()\nhttps://leetcode.cn/problems/add-to-array-form-of-integer/submissions/\n\n## å‰ç½®çŸ¥è¯†\n\n- æ•°ç»„çš„éå†ï¼Œæ ˆ\n\n\n\n## æ€è·¯\n-é€ä½ç›¸åŠ \n\n\n## ä»£ç \n\n- è¯­è¨€æ”¯æŒï¼šJavaScript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let result = [];\n    const n = num.length;\n    //æ•°ç»„éå†å¾ªç¯\n    for(let i = n - 1; i>= 0; i--)\n    {\n        let sum = num[i] + k%10 ;\n        k = Math.floor(k/10);\n        if(sum >= 10)\n        {\n            k++;\n            sum -=10;\n        }\n        result.push(sum);\n    }\n    //å¦‚æœå‡ºç°numå¾ªç¯åkè¿˜æœ‰å‰©ä½™åˆ™éœ€è¦è¿›è¡Œä¸‹é¢å¾ªç¯\n    for(;k>0;k = Math.floor(k/10))\n    {\n        result.push(k % 10);\n    }\n    //ç”±äºåˆ©ç”¨æ ˆçš„pushï¼Œæ‰€ä»¥æ˜¯å…ˆè¿›åå‡ºï¼Œæ‰€ä»¥åº”å½“å°†å…¶é€†åº\n    result.reverse();\n    return result;\n};\n\n```\n\n\n**å¤æ‚åº¦åˆ†æ**\n\nä»¤ n ä¸ºæ•°ç»„é•¿åº¦ã€‚\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œforå¾ªç¯éå†\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œåˆ›å»ºæ–°çš„ç©ºé—´å­˜æ”¾ç»“æœ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186208679","body":"\r\n## é¢˜ç›®åœ°å€()\r\n\r\nhttps://leetcode.cn/problems/shortest-distance-to-a-character/submissions/\r\n\r\n\r\n## å‰ç½®çŸ¥è¯†\r\n\r\n- æ•°ç»„çš„éå†\r\n\r\n\r\n## æ€è·¯\r\né¦–å…ˆä»å·¦å¾€å³éå†å­—ç¬¦ä¸²s,è®°å½•å·¦è¾¹æœ€åä¸€ä¸ªå‡ºç°çš„åæ ‡ï¼›\r\nç„¶åä»å³åˆ°å·¦éå†ï¼Œåˆ¤æ–­åˆ°å³ä¾§çš„cå­—ç¬¦çš„è·ç¦»æ˜¯å¦æ¯”åˆ°å·¦ä¾§è·ç¦»å°æˆ–è€…å·¦ä¾§æ²¡æœ‰cå­—ç¬¦çš„å­—ç¬¦ï¼Œåˆ™è¿›è¡Œæ›¿æ¢cå­—ç¬¦çš„åæ ‡ï¼›\r\n\r\n## å…³é”®ç‚¹\r\n\r\n-  å¦‚ä½•è·å–è·ç¦»æœ€å°å€¼\r\n\r\n## ä»£ç \r\n\r\n- è¯­è¨€æ”¯æŒï¼šJavascript\r\n\r\nJavascript\r\n\r\n```Javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let res = Array(s.length);\r\n\r\n    //è´ªå¿ƒæ³•\r\n    //å…ˆä»å·¦åˆ°å³éå†\r\n    for(let i = 0 ;i <s.length ; i++)\r\n    {\r\n        if(s[i] === c)\r\n        {\r\n            res[i] = i;\r\n        }else{\r\n            //void 0 == undefined)ï¼Œå¦‚æœå·¦ä¾§æ²¡æœ‰å‡ºç°è¿‡cå­—ç¬¦ï¼Œåˆ™ä¸ºInfinity\r\n            res[i] = (res[i-1] === void 0 ? Infinity : res[i-1]);\r\n        }\r\n    }\r\n    //ä»å³å¾€å·¦éå†\r\n    for(let i = s.length -1; i>= 0;i--)\r\n    {\r\n        //å¦‚æœå·¦ä¾§æ²¡æœ‰cå­—ç¬¦æˆ–è€…å³ä¾§å‡ºç°çš„cå­—ç¬¦è·ç¦»æ›´è¿‘ï¼Œå°±æ›´æ–°\r\n        if(res[i] === Infinity || res[i+1] - i < i- res[i])\r\n        {\r\n            res[i] = res[i+1];\r\n        }\r\n    }\r\n    for(let i = 0 ;i <res.length ; i++){\r\n        res[i] = Math.abs(res[i] - i);\r\n    }\r\n    return res;\r\n};\r\n\r\n```\r\n\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n\r\nä»¤ n ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186531885","body":"/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    //ç”¨ maxSize åˆå§‹åŒ–å¯¹è±¡ï¼ŒmaxSize æ˜¯æ ˆä¸­æœ€å¤šèƒ½å®¹çº³çš„å…ƒç´ æ•°é‡ï¼Œæ ˆåœ¨å¢é•¿åˆ° maxSize ä¹‹ååˆ™ä¸æ”¯æŒ push æ“ä½œã€‚\r\n    this.max = maxSize;\r\n    this.stack = [];\r\n\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    //å¦‚æœæ ˆè¿˜æœªå¢é•¿åˆ° maxSize ï¼Œå°±å°† x æ·»åŠ åˆ°æ ˆé¡¶\r\n    if(this.stack.length < this.max)\r\n    {\r\n        this.stack.push(x);\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    //å¼¹å‡ºæ ˆé¡¶å…ƒç´ ï¼Œå¹¶è¿”å›æ ˆé¡¶çš„å€¼ï¼Œæˆ–æ ˆä¸ºç©ºæ—¶è¿”å› -1\r\n   var res = this.stack.pop();\r\n   return res == null ? -1 : res;\r\n   \r\n\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for(let i = 0 ; i < this.stack.length;i++)\r\n    {\r\n        if(i <k)\r\n        {\r\n            this.stack[i] += val;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187669786","body":"/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nconst decodeString = (s) => {\r\n    let numStack = [];       \r\n    let strStack = [];        \r\n    let num = 0;            \r\n    let result = '';     \r\n    for (const char of s) {   \r\n        if (!isNaN(char)) {   \r\n            num = num * 10 + Number(char);\r\n        } else if (char == '[') {  \r\n            strStack.push(result); \r\n            result = '';           \r\n            numStack.push(num);    \r\n            num = 0;               \r\n        } else if (char == ']') {  \r\n            let repeatTimes = numStack.pop(); \r\n            result = strStack.pop() + result.repeat(repeatTimes); \r\n        } else {                   \r\n            result += char;        \r\n        }\r\n    }\r\n    return result;\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189161902","body":"\r\n## é¢˜ç›®åœ°å€()\r\n\r\nhttps://leetcode.cn/problems/implement-queue-using-stacks/submissions/\r\n\r\n\r\n## å‰ç½®çŸ¥è¯†\r\n\r\n- æ ˆï¼Œé˜Ÿåˆ—\r\n\r\n\r\n\r\n## å…³é”®ç‚¹\r\n\r\n-  ä¸¤ä¸ªæ ˆå®ç°é˜Ÿåˆ—\r\n\r\n## ä»£ç \r\n\r\n- è¯­è¨€æ”¯æŒï¼šJavascript\r\n\r\nja Code:\r\n\r\n```python\r\nvar MyQueue = function() {\r\n    this.stack1 = [];\r\n    this.stack2 = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    // void push(int x) å°†å…ƒç´  x æ¨åˆ°é˜Ÿåˆ—çš„æœ«å°¾\r\n    this.stack1.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    // int pop() ä»é˜Ÿåˆ—çš„å¼€å¤´ç§»é™¤å¹¶è¿”å›å…ƒç´ \r\n    if(!this.stack2.length){\r\n        this.out();\r\n    }\r\n    return this.stack2.pop();\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    // int peek() è¿”å›é˜Ÿåˆ—å¼€å¤´çš„å…ƒç´ \r\n    if(!this.stack2.length){\r\n        this.out();\r\n    }\r\n    return this.stack2[this.stack2.length -1];\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.stack1.length == 0 && this.stack2.length == 0;\r\n};\r\n\r\nMyQueue.prototype.out = function(){\r\n    while(this.stack1.length){\r\n        this.stack2.push(this.stack1.pop());\r\n    }\r\n}\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n\r\n\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1192653266","body":"\r\n## é¢˜ç›®åœ°å€()\r\nhttps://leetcode.cn/problems/max-chunks-to-make-sorted-ii/\r\n\r\n\r\n\r\n\r\n## æ€è·¯\r\n\r\n## å…³é”®ç‚¹\r\n\r\n-  \r\n\r\n## ä»£ç \r\n\r\n- è¯­è¨€æ”¯æŒï¼šJS\r\n\r\nJS Code:\r\n\r\n```\r\n\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\n var maxChunksToSorted = function(arr) {\r\n    const stack = [];\r\n    for(let i = 0;i < arr.length ; i++)\r\n    {\r\n        a = arr[i];\r\n    if(stack.length>0 && stack[stack.length-1]>a)\r\n    {\r\n        const curr = stack[stack.length-1];\r\n        while(stack && stack[stack.length-1]>a)\r\n        {\r\n            stack.pop();\r\n        }\r\n        stack.push(curr);\r\n    }else{\r\n        stack.push(a);\r\n    }\r\n    }\r\n    return stack.length;\r\n    };\r\n\r\n```\r\n\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n\r\nä»¤ n ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$\r\n\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1192650196","body":"## é¢˜ç›®åœ°å€()\r\n\r\nhttps://leetcode.cn/problems/rotate-list/submissions/\r\n\r\n\r\n\r\n\r\n## æ€è·¯\r\n\r\n## å…³é”®ç‚¹\r\n\r\n-  å¿«æ…¢æŒ‡é’ˆ\r\n\r\n## ä»£ç \r\n\r\n- è¯­è¨€æ”¯æŒï¼šJS\r\n\r\nJS Code:\r\n\r\n```JS\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function(head, k) {\r\n    if(!head || !head.next)\r\n    return head;\r\n    let count = 0;\r\n    now = head;\r\n    while(now){\r\n        now = now.next;\r\n        count++;\r\n    }\r\n    k = k%count;\r\n    let slow = (fast = head);\r\n    while(fast.next){\r\n        if(k--<= 0){\r\n            slow = slow.next;\r\n        }\r\n        fast = fast.next;\r\n    }\r\n    fast.next = head;\r\n    let res = slow.next;\r\n    slow.next = null;\r\n    return res;\r\n};\r\n\r\n```\r\n\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n\r\nä»¤ n ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192647965","body":"\r\n## é¢˜ç›®åœ°å€()\r\n\r\nhttps://leetcode.cn/problems/swap-nodes-in-pairs/submissions/\r\n\r\n## é¢˜ç›®æè¿°\r\n\r\n```\r\n\r\n```\r\n\r\n## å‰ç½®çŸ¥è¯†\r\n\r\n- \r\n\r\n## å…¬å¸\r\n\r\n- æš‚æ— \r\n\r\n## æ€è·¯\r\n\r\n## å…³é”®ç‚¹\r\n\r\n-  ä¸¤ä¸¤è¿›è¡Œäº¤æ¢ï¼Œåˆ©ç”¨é“¾è¡¨çš„\r\n\r\n## ä»£ç \r\n\r\n- è¯­è¨€æ”¯æŒï¼šJS\r\n\r\nJS Code:\r\n\r\n``\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function(head) {\r\n    let dummy = new ListNode();\r\n    dummy.next = head;\r\n    let curr = dummy;\r\n    while(curr.next !== null && curr.next.next !== null){\r\n        let n1 = curr.next;\r\n        let n2 = curr.next.next;\r\n        curr.next = n2;\r\n        n1.next = n2.next;\r\n        n2.next = n1;\r\n        curr = n1;\r\n    }\r\n    return dummy.next;\r\n};\r\n\r\n```\r\n\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n\r\nä»¤ n ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193146010","body":"\r\n## é¢˜ç›®åœ°å€()\r\n\r\nhttps://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/\r\n\r\n## é¢˜ç›®æè¿°\r\n\r\n```\r\n\r\n```\r\n\r\n## å‰ç½®çŸ¥è¯†\r\n\r\n- \r\n\r\n## å…¬å¸\r\n\r\n- æš‚æ— \r\n\r\n## æ€è·¯\r\n\r\n## å…³é”®ç‚¹\r\n\r\n-  \r\n\r\n## ä»£ç \r\n\r\n- è¯­è¨€æ”¯æŒï¼šJS\r\n\r\nJS Code:\r\n\r\n```python\r\n\r\nconst sortedListToBST = (head) => {\r\n  const arr = [];\r\n  while (head) { \r\n    arr.push(head.val);\r\n    head = head.next;\r\n  }\r\n  // æ ¹æ®ç´¢å¼•startåˆ°endçš„å­æ•°ç»„æ„å»ºå­æ ‘\r\n  const buildBST = (start, end) => {\r\n    if (start > end) return null;       \r\n    const mid = (start + end) >>> 1;  \r\n    const root = new TreeNode(arr[mid]);\r\n    root.left = buildBST(start, mid - 1); \r\n    root.right = buildBST(mid + 1, end); \r\n    return root;                          \r\n  };\r\n\r\n  return buildBST(0, arr.length - 1);  \r\n};\r\n\r\n```\r\n\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n\r\nä»¤ n ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193321010","body":"***\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function(headA, headB) {\r\n    const visited = new Set();\r\n    let temp = headA;\r\n    while (temp !== null) {\r\n        visited.add(temp);\r\n        temp = temp.next;\r\n    }\r\n    temp = headB;\r\n    while (temp !== null) {\r\n        if (visited.has(temp)) {\r\n            return temp;\r\n        }\r\n        temp = temp.next;\r\n    }\r\n    return null;\r\n};\r\n***","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194280287","body":"/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n  // å¿«æ…¢æŒ‡é’ˆåˆå§‹åŒ–æŒ‡å‘ head\r\n  let slow = head;\r\n  let fast = head;\r\n  // å¿«æŒ‡é’ˆèµ°åˆ°æœ«å°¾æ—¶åœæ­¢\r\n  while (fast && fast.next) {\r\n    // æ…¢æŒ‡é’ˆèµ°ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆèµ°ä¸¤æ­¥\r\n    slow = slow.next;\r\n    fast = fast.next.next;\r\n    // å¿«æ…¢æŒ‡é’ˆç›¸é‡ï¼Œè¯´æ˜å«æœ‰ç¯\r\n    if (slow == fast) {\r\n      // ä»»ä¸€ä¸€èŠ‚ç‚¹æŒ‡å‘å¤´èŠ‚ç‚¹\r\n      fast = head;\r\n      // åŒæ­¥å‘å‰è¿›\r\n      while (fast != slow) {\r\n        fast = fast.next;\r\n        slow = slow.next;\r\n      }\r\n      // è¿”å›å…¥å£èŠ‚ç‚¹\r\n      return fast;\r\n    }\r\n  }\r\n  // ä¸åŒ…å«ç¯\r\n  return null;   \r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195469446","body":"\r\n\r\n## ä»£ç \r\n\r\n- è¯­è¨€æ”¯æŒï¼šjs\r\n\r\njs Code:\r\n\r\n```python\r\n\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function(capacity) {\r\n  this.max = capacity\r\n  this.map = new Map()\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n  if(this.map.has(key)){\r\n    let value = this.map.get(key)\r\n    this.map.delete(key)\r\n    this.map.set(key, value)\r\n    return value\r\n  } else {\r\n    return -1\r\n  }\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n  if (this.map.has(key)) {\r\n    this.map.delete(key)\r\n  }\r\n  this.map.set(key, value)\r\n  if(this.map.size > this.max){\r\n    this.map.delete(this.map.keys().next().value)\r\n  }\r\n\r\n```\r\n\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n\r\nä»¤ n ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(1)$\r\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196751149","body":"var maxDepth = function(root) {\r\nif(root === null){\r\n    return 0\r\n}\r\nreturn Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199068036","body":"\r\n## é¢˜ç›®åœ°å€()\r\n\r\nhttps://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/\r\n\r\n## é¢˜ç›®æè¿°\r\n\r\n```\r\n\r\n```\r\n\r\n## å‰ç½®çŸ¥è¯†\r\n\r\n- æ ‘\r\n\r\n\r\n## æ€è·¯\r\n\r\n## å…³é”®ç‚¹\r\n\r\n-  \r\n\r\n## ä»£ç \r\n\r\n- è¯­è¨€æ”¯æŒï¼šjs\r\n\r\njs Code:\r\n\r\n```js\r\n\r\nvar sumNumbers = function(root) {\r\n  let _result = 0\r\n  function dfs(node, item) {\r\n    if (node == null) return\r\n    item = item + String(node.val)\r\n    if (node.left == null && node.right == null) {\r\n      _result += Number(item)\r\n    }\r\n    dfs(node.left, item)\r\n    dfs(node.right, item)\r\n  }\r\n  dfs(root, '')\r\n  return _result\r\n}\r\n\r\nä½œè€…ï¼šityou-o\r\né“¾æ¥ï¼šhttps://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/javascriptban-jie-ti-si-lu-by-ityou-o-txq2/\r\næ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰\r\nè‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚\r\n\r\n```\r\n\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n\r\nä»¤ n ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200125306","body":"\r\n\r\n## å‰ç½®çŸ¥è¯†\r\n\r\n- BFS\r\n\r\n## å…¬å¸\r\n\r\n- æš‚æ— \r\n\r\n## æ€è·¯\r\n\r\nå±‚åºéå†ï¼Œä¸”å–æœ€åä¸€å±‚çš„ç¬¬ä¸€ä¸ªå€¼\r\n\r\n## ä»£ç \r\n\r\n- è¯­è¨€æ”¯æŒï¼šjs\r\n\r\nPython3 Code:\r\n\r\n```js\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar findBottomLeftValue = function(root) {\r\n    let arr = [root]\r\n    let left = null\r\n    while (arr.length) {\r\n        const next = []\r\n        left = arr[0]\r\n        arr.forEach(item => {\r\n            item.left && next.push(item.left)\r\n            item.right && next.push(item.right)\r\n        })\r\n        arr = next\r\n    }\r\n    return left.val\r\n};\r\n\r\n\r\n\r\n```\r\n\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n\r\nä»¤ n ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$\r\n\r\n\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202496384","body":"var twoSum = function(nums, target) {\r\n    //1.åˆå§‹åŒ–Mapé›†åˆ\r\n    const map = new Map();\r\n    //2.å¾ªç¯éå†nums\r\n    for(let i = 0; i <nums.length; i++)\r\n    {\r\n        //3.ç”¨targetå‡nums[i]\r\n        const a = target - nums[i];\r\n        //æ£€æŸ¥mapé‡Œé¢æ˜¯å¦æœ‰è¿™ä¸ªæ•°\r\n        if(map.has(a))\r\n        {\r\n            return [map.get(a),i];\r\n        }\r\n        else{\r\n            map.set(nums[i],i);\r\n        }\r\n    }\r\n    //å¾ªç¯æ•°ç»„ä¸­æ²¡æœ‰å¯¹åº”çš„å€¼ï¼Œåˆ™è¿”å›ç©ºå€¼\r\n    return [];\r\n};","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208088487","body":"~~~\r\nvar middleNode = function(head) {\r\n    let p = head,\r\n        q = head;\r\n    \r\n    while (q.next != null && q.next.next != null) {\r\n        p = p.next;\r\n        q = q.next.next;\r\n    }\r\n\r\n    if (q.next == null) {\r\n        return p;\r\n    } else {\r\n        return p.next;\r\n    }    \r\n\r\n};\r\n~~~\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tlntin":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185157127","body":"1. [é¢˜ç›®é“¾æ¥](https://leetcode.cn/problems/add-to-array-form-of-integer/submissions/)\r\n\r\n### ç®€å•ç†è§£\r\n- ä»ä½ä½å¾€é«˜ä½è®¡ç®—ï¼Œé€¢åè¿›ä¸€ã€‚æ•°ç»„ç›´æ¥ä»å³å¾€å·¦æ•°ï¼Œè€Œæ•°å­—çš„è¯ï¼Œæ¯æ¬¡æ±‚10çš„ä½™æ•°ï¼Œæ±‚å®Œåé™¤10å³å¯ã€‚\r\n- å¦‚æœæ•°ç»„sizeä¸å¤Ÿï¼Œé‚£å°±å†é¦–ä½æ’å…¥å…ƒç´ 1å®ç°è¿›1æ“ä½œã€‚\r\n- åé¢å‘ç°å¯èƒ½kæ¯”numé•¿ã€‚æ‰€ä»¥è¿˜éœ€è¦æŠŠå¤šä½™çš„kæ’å…¥åˆ°numä¸­ã€‚\r\n- æœ€åè¾“å‡ºç»“æœå³å¯ã€‚å¯ä»¥ç”¨std::move(num)ç›´æ¥å°†å€¼ç§»å‡ºï¼Œé˜²æ­¢é‡å¤æ‹·è´ï¼ŒèŠ‚çœå†…å­˜ã€‚\r\n\r\n### æœ€ç»ˆä»£ç \r\n```bash\r\n#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n    // åå‘è¿­ä»£ï¼Œåˆ©ç”¨åŠ æ³•è¿›ä½æ¥è®¡ç®—\r\n    int temp = 0;\r\n    int n = num.size();\r\n    for (int i = 0; i < num.size(); ++i) {\r\n      temp = num[n - i - 1] + k % 10;\r\n      k = k / 10;\r\n      num[n - i - 1] = temp % 10;\r\n      if (temp >= 10) {\r\n        if (n - i - 2 >= 0) {\r\n          num[n - i - 2] += 1;\r\n        } else {\r\n          n += 1;\r\n          num.insert(num.begin(), 1);\r\n        }\r\n      }\r\n    };\r\n    // è¡¥ä¸ï¼Œkå¯èƒ½æ¯”Numé•¿ï¼Œéœ€è¦å°†kå‰©ä½™éƒ¨åˆ†æ’å…¥\r\n    while (k > 0) {\r\n      num.insert(num.begin(), k % 10);\r\n      k = k / 10;\r\n    }\r\n    return std::move(num);\r\n  }\r\n};\r\n\r\n\r\n\r\nint main() {\r\n  std::vector<int> v1 = {1,3,8};\r\n  int data = 955;\r\n  Solution s;\r\n  std::vector<int> v2 = s.addToArrayForm(v1, data);\r\n  for (const int & x: v2) {\r\n    std::cout << x << \" \";\r\n  }\r\n  std::cout << std::endl;\r\n}\r\n```\r\n\r\n### ç»“æœ\r\n![image](https://user-images.githubusercontent.com/28218658/179150726-78be3d31-e26a-4c6f-812a-8add0dae6953.png)\r\n\r\nç”¨æ—¶ï¼š24msï¼Œå†…å­˜25.8MBã€‚","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186080712","body":"- é¢˜ç›®[é“¾æ¥](https://leetcode.cn/problems/shortest-distance-to-a-character/submissions/)\r\n### è§£é¢˜æ€è·¯\r\n- å·¦å³ä¸¤è¾¹å„éå†ä¸€æ¬¡ï¼Œåˆ†åˆ«è·å–é‚»æ¥æœ€è¿‘å€¼ï¼Œç„¶åç”¨minå‡½æ•°å¯¹æ¯”ä¸¤è€…è°æ›´å°ã€‚\r\n- ç›´æ¥stringå¯ä»¥æ”¹æˆcosnt string &,å‡å°‘æ•°æ®æ‹·è´ã€‚\r\n- è¿”å›è¿˜æ˜¯ç›´æ¥ç”¨std::moveï¼Œå‡å°‘å†…å­˜æ‹·è´ï¼Œç›´æ¥ç§»åŠ¨ç»“æœã€‚\r\n\r\n\r\n### ä»£ç \r\n```cpp\r\n// Copyright 2022\r\n#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n\r\nusing std::vector;\r\nusing std::string;\r\n\r\nclass Solution {\r\n public:\r\n  vector<int> shortestToChar(const string & s, char c) {\r\n    // å‰å‘éå†ï¼Œå‡è®¾cåœ¨æœ€åä¸€ä¸ªä½ç½®\r\n    std::vector<int> result(s.size(), 0);\r\n    int index = s.size() - 1;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n      if (s[i] == c) {\r\n        index = i;\r\n      } else {\r\n        result[i] = abs(i - index);\r\n      }\r\n    }\r\n    // åå‘éå†ï¼Œå‡è®¾cå†ç¬¬ä¸€ä¸ªä½ç½®\r\n    index = 0;\r\n    for (int i = s.size() - 1; i >= 0; --i) {\r\n      if (s[i] == c) {\r\n        index = i;\r\n      } else {\r\n        // æ­¤å¤„ç»“æœå–çŸ­è·ç¦»\r\n        result[i] = std::min(result[i], abs(i - index));\r\n      }\r\n    }\r\n    return std::move(result);\r\n  }\r\n};\r\n\r\n\r\nint main() {\r\n  std::string str(\"loveleetcode\");\r\n  char c1 = 'e';\r\n  Solution s;\r\n  std::vector<int> res = s.shortestToChar(str, c1);\r\n  for (const int & x : res) {\r\n    std::cout << x << \" \";\r\n  }\r\n  std::cout << std::endl;\r\n}\r\n```\r\n\r\n### å¤æ‚åº¦åˆ†æ\r\n1. æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œä¸€å±‚éå†ã€‚\r\n2. ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œå› ä¸ºæ„å»ºäº†ä¸€ä¸ªæ•°ç»„ï¼Œä¸”æ•°ç»„å†…å­˜æ— æ³•é¿å…ï¼Œå½“ç„¶å¯ä»¥ç”¨std::moveåšä¸€äº›ç©ºé—´ä¼˜åŒ–ã€‚\r\n\r\n### ä¼˜åŒ–æ€è·¯1ï¼š\r\n- ç¬¬äºŒæ¬¡éå†çš„æ—¶å€™ï¼Œåˆå§‹å€¼å…¶å®å°±æ˜¯ä¸Šä¸€æ¬¡çš„æœ€ç»ˆç´¢å¼•ï¼Œå¹¶ä¸”å¯ä»¥ä¼˜åŒ–ä¸€ä¸‹ï¼Œå°†ä¸€ä¸ªnéå†æ‹†åˆ†æˆindexå³è¾¹ä¸å·¦è¾¹ï¼Œå»æ‰abså‡½æ•°ï¼Œå‡å°‘næ¬¡ifåˆ¤æ–­ã€‚\r\n- ä¼˜åŒ–åæ—¶é—´å¤æ‚åº¦ä¸ç©ºé—´å¤æ‚åº¦ä¸å˜ã€‚\r\n\r\n```cpp\r\n// Copyright 2022\r\n#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n\r\nusing std::vector;\r\nusing std::string;\r\n\r\nclass Solution {\r\n public:\r\n  vector<int> shortestToChar(const string & s, char c) {\r\n    // å‰å‘éå†ï¼Œå‡è®¾cåœ¨æœ€åä¸€ä¸ªä½ç½®\r\n    std::vector<int> result(s.size(), 0);\r\n    int index = s.size() - 1;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n      if (s[i] == c) {\r\n        index = i;\r\n      } else {\r\n        result[i] = abs(i - index);\r\n      }\r\n    }\r\n    // åå‘éå†1ï¼Œæ­¤æ—¶å·²ç»çŸ¥é“äº†indexçš„åˆå§‹å€¼, indexå³è¾¹çš„å‡å¤§äºindex\r\n    // å¹¶ä¸”ä¸éœ€è¦åˆ¤æ–­s[i] == c\r\n    for (int i = s.size() - 1; i > index; --i) {\r\n        // æ­¤å¤„ç»“æœå–çŸ­è·ç¦»\r\n        result[i] = std::min(result[i], i - index);\r\n      }\r\n    // åå‘éå†2ï¼Œæ­¤æ—¶iæ’å°äºindex\r\n    for (int i = index; i >= 0; --i) {\r\n      if (s[i] == c) {\r\n        index = i;\r\n      } else {\r\n        // æ­¤å¤„ç»“æœå–çŸ­è·ç¦»\r\n        result[i] = std::min(result[i], index - i);\r\n      }\r\n    }\r\n    return std::move(result);\r\n  }\r\n};\r\n\r\n\r\nint main() {\r\n  std::string str(\"loveleetcode\");\r\n  char c1 = 'e';\r\n  Solution s;\r\n  std::vector<int> res = s.shortestToChar(str, c1);\r\n  for (const int & x : res) {\r\n    std::cout << x << \" \";\r\n  }\r\n  std::cout << std::endl;\r\n}\r\n```\r\n\r\n### æˆæœ\r\n![image](https://user-images.githubusercontent.com/28218658/179337923-38b90c6a-552a-4a13-8e33-e7122dba3a55.png)\r\n\r\næ‰§è¡Œç”¨æ—¶ï¼š0ms(ä¼°è®¡æ˜¯bug)ï¼Œå†…å­˜6.6MBã€‚\r\n### ä¼˜åŒ–æ€è·¯2ï¼š\r\n- æ—¢ç„¶åå‘éå†å¯ä»¥é€šè¿‡æ‹†åˆ†æ¥å–æ¶ˆabsæ“ä½œï¼Œå‰å‘éå†ä¹Ÿæ˜¯å¯ä»¥è¿™ä¹ˆå¹²çš„ã€‚\r\n- å…ˆå–index=n-1;å¹¶ä¸”result[i] = index - i;å½“å‡ºç°`s[i] == c`ï¼Œç›´æ¥breakå‡ºæ¥ï¼Œè¿›è¡Œåç»­å¾ªç¯ã€‚\r\n- åç»­å¾ªç¯æ—¶å€™ï¼Œresult[i] = i - indexã€‚è¿™æ ·abså‡½æ•°å°±å½»åº•æ¶ˆé™¤äº†ï¼Œåˆå°‘äº†nä¸ªifï¼Œåº”è¯¥èƒ½å†å¿«ä¸€äº›ã€‚\r\n- æš‚æ—¶å°±ä¸å†™ä»£ç äº†ï¼Œæ„Ÿå…´è¶£çš„è‡ªè¡Œæµ‹è¯•ã€‚","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186382804","body":"- é¢˜ç›®[é“¾æ¥](https://leetcode.cn/problems/design-a-stack-with-increment-operation/submissions/)\n\n### è§£é¢˜æ€è·¯\n- å°±æ˜¯ç®€å•è®¾è®¡ä¸€ä¸ªæ ˆå°±è¡Œäº†ï¼Œæ¯”è¾ƒå¸¸è§„çš„æ•°æ®ç»“æ„é¢˜ç›®\n- å”¯ä¸€å°±æ˜¯å¤šäº†ä¸€ä¸ªæ‰¹é‡å¢åŠ æ ˆåº•nä¸ªå…ƒç´ å€¼çš„åŠŸèƒ½ï¼Œéœ€è¦åŠ ä¸€ä¸ªminæ“ä½œã€‚\n- ç”±äºmax_sizeå›ºå®šï¼Œæ‰€ä»¥é‡‡ç”¨æ•°ç»„åšæ ˆï¼Œè€Œä¸æ˜¯ç”¨é“¾è¡¨æˆ–è€…åŠ¨æ€æ•°ç»„ã€‚\n\n### ä»£ç \n```cpp\n// Copyright 2022\n#include <iostream>\n\nclass CustomStack {\n private:\n  int * data;\n  int max_size;\n  int top;\n\n public:\n  explicit CustomStack(int maxSize): max_size(maxSize), top(0) {\n    data = new int[maxSize];\n  }\n  ~CustomStack() {\n    delete [] data;\n  }\n\n  void push(int x) {\n    if (top < max_size) {\n      data[top] = x;\n      ++top;\n    }\n  }\n\n  int pop() {\n    if (top > 0) {\n      --top;\n      return data[top];\n    } else {\n      return -1;\n    }\n  }\n\n  void increment(int k, int val) {\n    k = std::min(k, top);\n    for (int i = 0; i < k; ++i) {\n      data[i] += val;\n    }\n  }\n};\n\n\n\nint main() {\n  CustomStack stack(3);\n  stack.push(1);\n  stack.push(2);\n  std::cout << stack.pop() << std::endl;\n  stack.push(2);\n  stack.push(3);\n  stack.push(4);\n  stack.increment(5, 100);\n  stack.increment(2, 100);\n  std::cout << stack.pop() << std::endl;\n  std::cout << stack.pop() << std::endl;\n  std::cout << stack.pop() << std::endl;\n  std::cout << stack.pop() << std::endl;\n}\n```\n\n\n### å¤æ‚åº¦åˆ†æ\n|            | push   | pop    | increment |\n| ---------- | ------ | ------ | --------- |\n| æ—¶é—´å¤æ‚åº¦ | $O(1)$ | $O(1)$ | $O(n)$    |\n| ç©ºé—´å¤æ‚åº¦ | $O(1)$ | $O(1)$ | $O(1)$    |\n\n\n\n### æˆæœ\n\n![](https://s2.loli.net/2022/07/17/N4iGqMwluScfeE5.png)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186726697","body":"- é¢˜ç›®[è¿æ¥](https://leetcode.cn/problems/decode-string/submissions/)\n### ä»£ç \n```cpp\n// CopyRight 2022\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing std::string;\n\nclass Solution {\n public:\n  string decodeString(const string & s) {\n    std::string result;\n    std::vector<char> stack1;\n    std::vector<char> temp_stack;\n    int temp_num;\n    int p;\n    std::string temp_str;\n    for (const char & c : s) {\n      if (c != ']') {\n        stack1.emplace_back(c);\n      } else {\n        // å‡ºæ ˆå–å­—ç¬¦ä¸²\n        while(stack1.back() != '[') {\n          temp_stack.emplace_back(stack1.back());\n          stack1.pop_back();\n        }\n        // å»é™¤ \"[\"\n        stack1.pop_back();\n        // å‡ºæ ˆå–æ•°ç»„\n        p = 1;\n        temp_num = 0;\n        while((!stack1.empty()) && ('0' <= stack1.back()) && (stack1.back() <= '9')) {\n          temp_num += p * (stack1.back() - '0');\n          stack1.pop_back();\n          p *= 10;\n        }\n        // è·å–å½“å‰ä¸´æ—¶å­—ç¬¦ä¸²(è®°å¾—åå‘)\n        temp_str.resize(temp_stack.size());\n        for (int i = 0; i < temp_stack.size(); ++i) {\n          temp_str[temp_stack.size() -1 - i] = temp_stack[i];\n        }\n        // std::cout << temp_num << \"\\t\" << temp_str << \"\\t\" << std::endl;\n        // æˆæœæ’å…¥stack1(è¿™é‡Œè²Œä¼¼å¯ä»¥ä¼˜åŒ–, å› ä¸ºä¼šå¯¼è‡´åç»­é‡å¤å¾ªç¯, ä½†æ˜¯è¦æ˜¯ä¸æ’å…¥ï¼Œå¦‚ä½•åšåˆ°æ•°æ®å¯¹é½ï¼Ÿ)\n        for (int i =0; i < temp_num; ++i) {\n          stack1.insert(stack1.end(), temp_str.begin(), temp_str.end());\n        }\n        //æ¸…ç©ºtemp_stack\n        temp_stack.clear();\n        temp_str.clear();\n      }\n    }\n    // æ‰“å°æœ€ç»ˆç»“æœ\n    result.resize(stack1.size());\n    for (int i = 0; i < stack1.size(); ++i) {\n      result[i] = stack1[i];\n    }\n    return std::move(result);\n  }\n};\n\n\nint main() {\n  Solution s;\n  std::string res = s.decodeString(\"3[a2[c]]\");\n  std::cout << res << std::endl;\n  std::cout << s.decodeString(\"10[a]2[bc]\") << std::endl;\n  std::cout << s.decodeString(\"2[abc]3[cd]ef\") << std::endl;\n  std::cout << s.decodeString(\"abc3[cd]xyz\") << std::endl;\n}\n```\n\n### å¤æ‚åº¦\n- æ—¶é—´ï¼š$O(n^2)$\n- ç©ºé—´: $O(n)$\n\n### ç»“æœ\n![c61fb2e7d9c552d97327037bad88d5a3.png](https://s2.loli.net/2022/07/18/Y14wDcpRWVGiUMH.png)\n\n### ä¼˜åŒ–\n- æˆæœä¸æ’å…¥åˆ°åŸstackï¼Œå‡å°‘éå†æ¬¡æ•°ä¸ç©ºé—´å ç”¨(é‚£æ•°æ®å¦‚ä½•å¯¹é½ï¼Ÿ)\n- ä¸­é—´ä¸åŠ å…¥temp_strï¼Œå‡å°‘ç©ºé—´å ç”¨ï¼ˆä½†æ˜¯ä¼šå¢åŠ æ›´å¤šéå†æ¬¡æ•°ï¼Œä¸å¤ªåˆ’ç®—ï¼‰\n- æ‰€ä»¥è¿˜æ˜¯æ”¾å¼ƒäº†ã€‚","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188539976","body":"- é¢˜ç›®[é“¾æ¥](https://leetcode.cn/problems/implement-queue-using-stacks/)\n### æ€è·¯\n- ç”¨ä¸¤ä¸ªæ ˆï¼Œä¸¤æ¬¡éå†ï¼Œå®ç°é˜Ÿåˆ—çš„åŠŸèƒ½ã€‚\n- è²Œä¼¼æ²¡å•¥éš¾åº¦ï¼Œå°±æ˜¯è´¹ç©ºé—´ï¼Œè´¹æ—¶é—´\n\n\n### ä»£ç \n```cpp\n// CopyRight 2022\n#include <stack>\n#include <iostream>\n\n\nclass MyQueue {\n private:\n  std::stack<int> tail_stack;\n  std::stack<int> head_stack;\n public:\n  MyQueue() {\n\n  }\n    \n  void push(int x) {\n    tail_stack.emplace(x);\n  }\n    \n  int pop() {\n    // tailå€’è…¾ç»™head\n    int res = -1;\n    // å…ˆåˆ¤æ–­tailæœ‰æ²¡æœ‰æ–°åŠ å…¥çš„å…ƒç´ \n    if (tail_stack.size() > 0) {\n      // å†æŠŠtail_stackçš„å€¼æ”¾åˆ°headå»\n      while (tail_stack.size() > 1) {\n        head_stack.emplace(tail_stack.top());\n        tail_stack.pop();\n      }\n      res = tail_stack.top();\n      tail_stack.pop();\n      // ç„¶åå†æŠŠheadçš„å€¼å€’è…¾å›tailï¼Œä¸ç„¶é¡ºåºä¼šä¹±\n      while (head_stack.size() > 0) {\n        tail_stack.emplace(head_stack.top());\n        head_stack.pop();\n      }\n    }\n    return res;\n  }\n    \n  int peek() {\n    // è¿”å›é˜Ÿåˆ—å¼€å¤´çš„å…ƒç´ ï¼Œéœ€è¦å’Œpopåšå·®ä¸å¤šç›¸åŒçš„åŠ¨ä½œï¼Œåªä¸è¿‡æœ€åä¸éœ€è¦Popå³å¯è¿”å›\n    // å…ˆåˆ¤æ–­tailæœ‰æ²¡æœ‰æ–°åŠ å…¥çš„å…ƒç´ \n    // tailå€’è…¾ç»™head\n    int res = -1;\n    // å…ˆåˆ¤æ–­tailæœ‰æ²¡æœ‰æ–°åŠ å…¥çš„å…ƒç´ \n    if (tail_stack.size() > 0) {\n      // å†æŠŠtail_stackçš„å€¼æ”¾åˆ°headå»\n      while (tail_stack.size() > 1) {\n        head_stack.emplace(tail_stack.top());\n        tail_stack.pop();\n      }\n      res = tail_stack.top();\n      // ç„¶åå†æŠŠheadçš„å€¼å€’è…¾å›tailï¼Œä¸ç„¶é¡ºåºä¼šä¹±\n      while (head_stack.size() > 0) {\n        tail_stack.emplace(head_stack.top());\n        head_stack.pop();\n      }\n    }\n    return res;\n  }\n    \n  bool empty() {\n    return (head_stack.size() + tail_stack.size() == 0);\n  }\n};\n\n\nint main() {\n  MyQueue queue;\n  queue.push(1);\n  queue.push(2);\n  queue.push(3);\n  queue.push(4);\n  std::cout << queue.pop() << std::endl;\n  queue.push(5);\n  std::cout << queue.pop() << std::endl;\n  std::cout << queue.pop() << std::endl;\n  std::cout << queue.pop() << std::endl;\n  std::cout << queue.pop() << std::endl;\n}\n```\n\n### å¤æ‚åº¦åˆ†æ\n\n| å¤æ‚åº¦ç±»å‹ | push   | pop/peer | empty  |\n| ---------- | ------ | -------- | ------ |\n| æ—¶é—´å¤æ‚åº¦ | $O(1)$ | $O(n)$   | $O(1)$ |\n| ç©ºé—´å¤æ‚åº¦ | $O(1)$ | $O(1)$   | $O(1)$ |\n\n\n### æˆæœ\n![b0bcb4b0943617a4ecce3fe6c3a13759.png](https://s2.loli.net/2022/07/19/5GCebk6zsHXtAEo.png)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189779524","body":"- é¢˜ç›®[é“¾æ¥](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/)\n- \n### code\n```bash\n// Copyright 2022\n#include <iostream>\n#include <vector>\n#include <stack>\n\n\nusing std::vector;\n\n\nclass Solution {\n private:\n  std::stack<int> my_stack;\n public:\n  int maxChunksToSorted(vector<int>& arr) {\n    int top = 0;\n    for(const int & x : arr) {\n      if (my_stack.size() > 0) {\n        if (x >= my_stack.top()) {\n          my_stack.emplace(x);\n        } else {\n          top = my_stack.top();\n          while (my_stack.size() > 0 && my_stack.top() > x) {\n            my_stack.pop();\n          }\n          my_stack.emplace(top);\n        }\n\n      } else {\n        my_stack.emplace(x);\n      }\n    }\n    return my_stack.size();\n  }\n};\n\n\nint main() {\n  /*\n    æœ€å¤šå¤šå°‘å—ï¼Ÿ\n    è§‚å¯Ÿå¯å¾—ï¼Œå€’åºæƒ…å†µä¸‹ï¼Œä¸å¯åˆ†å—ï¼Œä¹Ÿå°±æ˜¯1å—æ•´ä½“\n    é¡ºåºæƒ…å†µä¸‹ï¼Œç†è®ºä¸Šå¯ä»¥éšä¾¿åˆ†å—ï¼Œåˆ‡n-1åˆ€ï¼Œåˆ†æˆnå—ï¼ˆè™½ç„¶æ¯å—1ï¼‰\n    è¿™æ ·æ¥çœ‹ï¼Œé¡ºåºæ’åˆ—çš„å…ƒç´ ä¸ªæ•°å°±æ˜¯æœ€ç»ˆèƒ½åˆ†çš„å—å¤šå°‘\n    åˆ©ç”¨å•è°ƒæ ˆæ±‚é¡ºåºæ’åˆ—å…ƒç´ æœ‰å¤šå°‘ï¼Œå³åå…¥æ ˆçš„å…ƒç´ å¿…é¡»å¤§äºå…ˆå…¥æ ˆçš„ï¼Œå¦åˆ™å…ƒç´ å‡ºæ ˆï¼Œ\n    ç›´åˆ°æ»¡è¶³è¦æ±‚(æˆ–è€…æ ˆä¸ºç©º), å†å°†æ ˆé¡¶å…ƒç´ åŠ å›æ¥\n  */\n  Solution s1;\n  std::vector<int> v1 = {5,4,3,2,1};\n  std::cout << s1.maxChunksToSorted(v1) << std::endl;\n\n  Solution s2;\n  std::vector<int> v2 = {2,1,3,4,4};\n  std::cout << s2.maxChunksToSorted(v2) << std::endl;\n\n  Solution s3;\n  std::vector<int> v3 = {4, 2, 2, 1, 1};\n  std::cout << s3.maxChunksToSorted(v3) << std::endl;\n\n}\n```\n\n### å¤æ‚åº¦\n- æ—¶é—´ï¼š$O(n)$, ç©ºé—´$O(n)$\n\n### æˆæœ\n![694cc3d3cd98d9c1eda495ae144297b0.png](https://s2.loli.net/2022/07/20/bWSV4ieN7mYEk5O.png)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190963482","body":"### æ€è·¯\n- æ™®é€šé“¾è¡¨è½¬å¾ªç¯é“¾è¡¨ï¼Œç„¶ååç§»headåˆ°å¯¹åº”ä½ç½®å°±è¡Œäº†ã€‚\n- [é“¾æ¥](https://leetcode.cn/problems/rotate-list/submissions/)\n\n### ä»£ç \n```cpp\n#include <iostream>\n\n/**\n * Definition for singly-linked list.\n */\n struct ListNode {\n     int val;\n     ListNode *next;\n     ListNode() : val(0), next(nullptr) {}\n     ListNode(int x) : val(x), next(nullptr) {}\n     ListNode(int x, ListNode *next) : val(x), next(next) {}\n };\nclass Solution {\npublic:\n  ListNode* rotateRight(ListNode* head, int k) {\n    // æ—‹è½¬é“¾è¡¨ï¼Ÿå¾ªç¯é“¾è¡¨!\n    // list.size() <500, ä½†æ˜¯kå¯èƒ½ä¼šå¾ˆå¤§ï¼Œæ‰€ä»¥å…ˆéå†ä¸€ä¸‹Listè·å–sizeæ¯”è¾ƒåˆé€‚\n    // åªè¦æŠŠé“¾è¡¨å˜æˆå¾ªç¯é“¾è¡¨ï¼Œç„¶åä»size - (k % size)çš„ä½ç½®æ–­å¼€ï¼Œå°±èƒ½å®ç°æ—‹è½¬é“¾è¡¨äº†\n    // ç¬¬ä¸€æ­¥ï¼šè·å–æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œä¸åŒ…å«nullèŠ‚ç‚¹\n    ListNode * p1 = head;\n    std::size_t size = 0;\n    while (p1 && p1->next) {\n      size ++;\n      p1 = p1->next;\n    }\n    if (p1 && !p1->next) {\n      ++size;\n    }\n    // ç¬¬äºŒæ­¥ï¼Œæ„å»ºå¾ªç¯é“¾è¡¨(å‰æheadä¸ä¸ºnull)\n    if (p1) {\n      p1->next = head;\n      // ç¬¬ä¸‰æ­¥ï¼Œè®¡ç®—headåç§»ä½ç½®\n      int n = size - (k % size);\n      // ç¬¬å››æ­¥ï¼Œåç§»head,æ–­å¼€headå‰ä¸€ä¸ªèŠ‚ç‚¹\n      ListNode * p2 = head;\n      for (int i = 1; i < n; ++i) {\n        p2 = p2->next;\n      }\n      head = p2->next;\n      p2->next = nullptr;\n    }\n    return head;\n  }\n};\n```\n\n### å¤æ‚åº¦\n- æ—¶é—´ï¼š$O(n)$\n- ç©ºé—´ï¼š$O(1)$\n\n### ç»“æœ\n![2a3d738bd20baaae45bf663d26fe7741.png](https://s2.loli.net/2022/07/21/JOTipmMgB685HsA.png)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192121602","body":"### é¢˜ç›®\r\n[é“¾æ¥](https://leetcode.cn/problems/swap-nodes-in-pairs/)\r\n### æ€è·¯\r\n// èŠ‚ç‚¹äº¤æ¢ï¼Œé¦–å…ˆæƒ³åˆ°çš„è‡ªç„¶æ˜¯é•¿çŸ­æŒ‡é’ˆ\r\n// å› ä¸ºç¬¬äºŒè½®äº¤æ¢çš„æ—¶å€™ï¼Œ2iä»æŒ‡å‘2i+iå˜æˆäº†æŒ‡å‘2i+2,æ‰€ä»¥éœ€è¦ä¸€ä¸ªpreæŒ‡é’ˆ\r\n### ä»£ç \r\n```cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * \r\n */\r\n#include <iostream>\r\n#include <vector>\r\n#include <initializer_list>\r\n\r\n\r\nstruct ListNode {\r\n    int val;\r\n    ListNode *next;\r\n    ListNode() : val(0), next(nullptr) {}\r\n    ListNode(int x) : val(x), next(nullptr) {}\r\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n  ListNode* swapPairs(ListNode* head) {\r\n    \r\n    ListNode * short_p = head;\r\n    ListNode * long_p = head;\r\n    ListNode * prev = nullptr;\r\n    ListNode * result = head;\r\n    int i = 0;\r\n    while (short_p && short_p->next) {\r\n      // long_p æ¯”shortå¤šèµ°ä¸€æ­¥\r\n      if (long_p && long_p->next) {\r\n        long_p = long_p->next;\r\n      } else {\r\n        break;\r\n      }\r\n      // å¼€å§‹èŠ‚ç‚¹äº¤æ¢æ“ä½œ\r\n      short_p->next = long_p->next;\r\n      long_p->next = short_p;\r\n      if (prev) {\r\n        prev->next = long_p;\r\n      }\r\n\r\n      if (i == 0) {\r\n        result = long_p;\r\n      }\r\n      // ç„¶åï¼Œ short_p èµ°ä¸€æ­¥ï¼Œlong_pèµ°ä¸¤æ­¥ï¼Œå‡èµ°åˆ°ç¬¬2i+ 1ä¸ªèŠ‚ç‚¹\r\n      prev = short_p;\r\n      if(short_p) {\r\n        short_p = short_p->next;\r\n        long_p = short_p;\r\n      }\r\n      i += 2;\r\n    }\r\n    return result;\r\n  }\r\n};\r\n\r\n\r\nint main() {\r\n  // è‡ªå®šä¹‰åˆå§‹åŒ–ä¸€ä¸ªåˆ—è¡¨\r\n  std::vector<int> v1(std::initializer_list<int>({1, 2, 3, 4}));\r\n  ListNode * head = nullptr;\r\n  if (v1.size() > 0) {\r\n    head = new ListNode(v1[0]);\r\n  }\r\n  ListNode * p = head;\r\n  ListNode * temp = nullptr;\r\n  for (int i = 1; i < v1.size(); ++i) {\r\n    temp = new ListNode(v1[i]);\r\n    p->next = temp;\r\n    p = p->next;\r\n  }\r\n  // æ‰“å°ç»“æœ\r\n  p = head;\r\n  std::cout << \"input list\" << std::endl;\r\n  while(p) {\r\n    std::cout << p->val << \" \";\r\n    p = p->next;\r\n  }\r\n  std::cout << std::endl;\r\n\r\n  // è°ƒç”¨å‡½æ•°\r\n  Solution s;\r\n  ListNode * new_head = s.swapPairs(head);\r\n  p = new_head;\r\n  // æ‰“å°ç»“æœ\r\n  std::cout << \"output list\" << std::endl;\r\n  while(p) {\r\n    std::cout << p->val << \" \";\r\n    p = p->next;\r\n  }\r\n  std::cout << std::endl;\r\n  // é”€æ¯é“¾è¡¨\r\n  p = new_head;\r\n  while (p) {\r\n    temp = p;\r\n    p = p->next;\r\n    delete temp;\r\n  }\r\n  std::cout << \"list destory\" << std::endl;\r\n}\r\n```\r\n\r\n### å¤æ‚åº¦\r\n- æ—¶é—´: $O(n)$\r\n-  ç©ºé—´: $O(1)$\r\n\r\n### ç»“æœ\r\n![757f603c8d945754ad633cc404609b96.png](https://s2.loli.net/2022/07/22/bzRLXyUZeAPWu5V.png)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193104535","body":"### é¢˜ç›®é“¾æ¥\n- [é“¾æ¥](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/submissions/)\n\n### æ€è·¯\n- æ ¹æ®å¹³è¡¡äºŒå‰æ ‘çš„å®šä¹‰ï¼Œå…ˆæ‰¾ä¸­é—´èŠ‚ç‚¹ã€‚ç„¶åæŠŠå‰©ä¸‹çš„å·¦å³ä¸¤è¾¹é€’å½’ï¼Œæ‰¾ä¸­é—´èŠ‚ç‚¹ï¼Œæœ€åæŠŠä¸­é—´èŠ‚ç‚¹ä¸å·¦è¾¹ä¸­é—´å’Œå³è¾¹ä¸­é—´èŠ‚ç‚¹ç›¸è¿æ¥ï¼Œæ„æˆæ ‘ç»“æ„ï¼Œç„¶åè¿”å›ã€‚\n- éš¾ç‚¹1ï¼šå¦‚ä½•æ‰¾ä¸­é—´èŠ‚ç‚¹ï¼Ÿå¯ä»¥åˆ©ç”¨é•¿çŸ­æŒ‡é’ˆï¼Œè®¾å®šä¸€ä¸ªå¼€å§‹ï¼Œç»“æŸå€¼ï¼Œç„¶åçŸ­æŒ‡é’ˆèµ°ä¸€æ­¥ï¼Œé•¿æŒ‡é’ˆèµ°ä¸¤æ­¥ï¼Œå½“é•¿æŒ‡é’ˆèµ°åˆ°æœ«å°¾æ—¶ï¼ŒçŸ­æŒ‡é’ˆçš„ä½ç½®å°±æ˜¯ä¸­é—´èŠ‚ç‚¹ã€‚æ³¨æ„ï¼šå¼€å§‹ç»“æŸå€¼ä¸èƒ½ä¸€æ ·ï¼Œå¦‚æœä¸€æ ·ï¼Œåˆ™è¿”å›nullptrã€‚\n- éš¾ç‚¹2ï¼šå¦‚ä½•é€’å½’ï¼Ÿå…ˆæ‰¾åˆ°é“¾è¡¨çš„ä¸­é—´èŠ‚ç‚¹ã€‚ç„¶åå†™ä¸€ä¸ªåˆ›å»ºæ ‘çš„å‡½æ•°ï¼Œä¾æ®ä¸­é—´èŠ‚ç‚¹åˆ›å»ºæ ‘çš„æ ¹èŠ‚ç‚¹ã€‚ç„¶åä¾æ¬¡æ‰¾å·¦å³ä¸¤è¾¹ä¸­é—´èŠ‚ç‚¹ï¼Œæœ€åå·¦å³ä¸¤è¾¹ä¹Ÿåˆ›å»ºæ ‘ï¼ˆé€’å½’ï¼‰ï¼Œæœ€åå°†æ ‘çš„æ ¹èŠ‚ç‚¹ä¸å·¦å³è¾¹ä¸¤é¢—å­æ ‘ç›¸è¿ã€‚æ³¨æ„ï¼šä¸­é—´èŠ‚ç‚¹å¿…å®šä¸ä¸ºnullå€¼ã€‚\n\n\n### ä»£ç å®ç°\n```cpp\n#include <iostream>\n#include <vector>\n\n/**\n * Definition for singly-linked list.\n **/\n\nstruct ListNode {\n  int val;\n  ListNode *next;\n  ListNode() : val(0), next(nullptr) {}\n  ListNode(int x) : val(x), next(nullptr) {}\n  ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n \n/**\n * Definition for a binary tree node.\n * */\n\nstruct TreeNode {\n  int val;\n  TreeNode *left;\n  TreeNode *right;\n  TreeNode() : val(0), left(nullptr), right(nullptr) {}\n  TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n  TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n public:\n  TreeNode* sortedListToBST(ListNode* head) {\n    // æ€è·¯ï¼šåˆ©ç”¨é•¿çŸ­æŒ‡é’ˆï¼Œæ‰¾åˆ°ä¸­é—´èŠ‚ç‚¹\n    // ä¸­é—´èŠ‚ç‚¹ä½œä¸ºæ ‘æ ¹èŠ‚ç‚¹ï¼Œç„¶åä¾æ¬¡é€’å½’å·¦å³ä¸¤è¾¹å‰©ä½™èŠ‚ç‚¹æ„æˆå­æ ‘ \n    ListNode * mid = find_midden(head);\n    // æ„å»ºæ ‘çš„æ ¹èŠ‚ç‚¹\n    // åˆ©ç”¨é€’å½’æ„å»ºæ ‘\n    TreeNode * tree = create_tree(head, mid);\n    return tree;\n  }\n\n  TreeNode *  create_tree(ListNode * head, ListNode * mid, ListNode * end=nullptr) {\n    if (mid) {\n      // ç”¨äºåˆ›å»ºä¸€é¢—æ•°ï¼Œè¿”å›æ ‘çš„æ ¹èŠ‚ç‚¹\n      // æ„å»ºæ ‘çš„æ ¹èŠ‚ç‚¹\n      TreeNode * root_tree = new TreeNode(mid->val);\n      if (mid && mid->next) {\n        // å¯¹å³å­æ ‘ä¹Ÿæ‰§è¡Œåˆ›å»ºæ ‘çš„æ“ä½œ\n        ListNode * right = mid->next;\n        ListNode * right_mid = find_midden(right, end);\n        TreeNode * right_tree = create_tree(right, right_mid, end);\n        root_tree->right = right_tree;\n      }\n      ListNode * left = find_midden(head, mid);\n      // å¯¹å·¦å­æ ‘ç»§ç»­æ‰§è¡Œåˆ›å»ºæ ‘çš„æ“ä½œ\n      TreeNode * left_tree = create_tree(head, left, mid);\n      root_tree->left = left_tree;\n      return root_tree;\n    } else {\n      return nullptr;\n    }\n  }\n\n\n  ListNode * find_midden(ListNode * head, ListNode * end=nullptr) {\n    // è¯¥å‡½æ•°ç”¨äºæ‰¾ä¸­é—´èŠ‚ç‚¹(å¸®åŠ©å·¦è¾¹çš„é“¾è¡¨æ‰¾åˆ°ä¸­é—´èŠ‚ç‚¹)\n    // endèŠ‚ç‚¹ä¸ºè¾¹ç•Œï¼Œé»˜è®¤ä¸ºnull\n    if (head && head != end) {\n      ListNode * short_p = head;\n      ListNode * long_p = head;\n      while (long_p != end  && long_p->next != end) {\n        short_p = short_p->next;\n        long_p = long_p->next->next;\n      }\n      return short_p;\n    } else {\n      return nullptr;\n    }\n  }\n};\n\n\nint main() {\n  // è‡ªå®šä¹‰åˆå§‹åŒ–ä¸€ä¸ªåˆ—è¡¨\n  std::vector<int> v1(std::initializer_list<int>({1, 2, 3, 4}));\n  ListNode * head = nullptr;\n  if (v1.size() > 0) {\n    head = new ListNode(v1[0]);\n  }\n  ListNode * p = head;\n  ListNode * temp = nullptr;\n  for (int i = 1; i < v1.size(); ++i) {\n    temp = new ListNode(v1[i]);\n    p->next = temp;\n    p = p->next;\n  }\n  // æ‰“å°ç»“æœ\n  p = head;\n  std::cout << \"input list\" << std::endl;\n  while(p) {\n    std::cout << p->val << \" \";\n    p = p->next;\n  }\n  std::cout << std::endl;\n\n  // è°ƒç”¨å‡½æ•°\n  Solution s;\n  TreeNode * new_head = s.sortedListToBST(head);\n  // é”€æ¯é“¾è¡¨\n  p = head;\n  while (p) {\n    temp = p;\n    p = p->next;\n    delete temp;\n  }\n  std::cout << \"list destory\" << std::endl;\n}\n```\n\n\n### å¤æ‚åº¦\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$\n- æ—¶é—´å¤æ‚åº¦ï¼šæ¯æ¬¡å¯»æ‰¾ä¸­é—´èŠ‚ç‚¹éœ€è¦éå†n+2/næ¬¡ï¼Œæ¯æ¬¡äºŒåˆ†æˆä¸¤æ®µé“¾è¡¨ï¼Œæ‰€ä»¥æ—¶é—´å°±æ˜¯$0(n*log(n))$\n\n\n### æœ€ç»ˆç»“æœ\n![2f39227d6accb5ea88a24f6ab9301009.png](https://s2.loli.net/2022/07/23/QxWq8MsG6ic7N3F.png)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193250016","body":"## é¢˜ç›®é“¾æ¥\r\n- [é“¾æ¥](https://leetcode.cn/problems/intersection-of-two-linked-lists/submissions/)\r\n\r\n## è§£é¢˜æ€è·¯\r\n- æ‰¾å‡ºé“¾è¡¨çš„ç›¸äº¤èŠ‚ç‚¹ï¼Œå¦‚æœç›¸äº¤ï¼Œè¿”å›ç›¸äº¤èŠ‚ç‚¹ï¼Œå¦åˆ™è¿”å›NULL\r\n- æœ€ç®€å•çš„æ–¹æ³•è‡ªç„¶æ˜¯ç”¨dictæ¥è®°å½•å…¶ä¸­ä¸€ä¸ªé“¾è¡¨ï¼Œç„¶ååˆ¤æ–­å¦å¤–ä¸€ä¸ªé“¾è¡¨æ˜¯å¦æœ‰é‡å¤\r\n- ä¸è¿‡é¢˜ç›®è¦æ±‚ç©ºé—´æ˜¯O(1), æ‰€ä»¥å¤§æ¦‚ç‡è¿˜æ˜¯é•¿çŸ­æŒ‡é’ˆ\r\n- ç”¨é•¿çŸ­æŒ‡é’ˆï¼Œå…ˆåˆ¤æ–­ä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦\r\n- çœ‹ä¸‹å“ªä¸ªé“¾è¡¨é•¿ï¼Œé•¿çš„ä¸ºAé“¾è¡¨\r\n-  å¦‚æœç›¸äº¤ï¼Œåˆ™æœ€ç»ˆæœ‰kä¸ªèŠ‚ç‚¹ä¸ºå…±åŒèŠ‚ç‚¹\r\n-  1<= k<=n\r\n-  å…ˆè®©headAèµ°(m-n)ä¸ªèŠ‚ç‚¹\r\n-  æœ€ç»ˆä¸¤è¾¹èŠ‚ç‚¹åŒæ—¶åˆ°è¾¾æœ«å°¾ï¼Œå¦‚æœæŒ‡é’ˆç›¸åŒåˆ™ç›¸äº¤ï¼Œè¿”å›ç›¸äº¤èŠ‚ç‚¹å³å¯ã€‚\r\n\r\n\r\n## ä»£ç \r\n```cpp\r\n#include <iostream>\r\n\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n */\r\n\r\nstruct ListNode {\r\n    int val;\r\n    ListNode *next;\r\n    ListNode(int x) : val(x), next(NULL) {}\r\n};\r\n\r\n\r\nclass Solution {\r\npublic:\r\n  ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n    // æ‰¾å‡ºé“¾è¡¨çš„ç›¸äº¤èŠ‚ç‚¹ï¼Œå¦‚æœç›¸äº¤ï¼Œè¿”å›ç›¸äº¤èŠ‚ç‚¹ï¼Œå¦åˆ™è¿”å›NULL\r\n    // æœ€ç®€å•çš„æ–¹æ³•è‡ªç„¶æ˜¯ç”¨dictæ¥è®°å½•å…¶ä¸­ä¸€ä¸ªé“¾è¡¨ï¼Œç„¶ååˆ¤æ–­å¦å¤–ä¸€ä¸ªé“¾è¡¨æ˜¯å¦æœ‰é‡å¤\r\n    // ä¸è¿‡é¢˜ç›®è¦æ±‚ç©ºé—´æ˜¯O(1), æ‰€ä»¥å¤§æ¦‚ç‡è¿˜æ˜¯é•¿çŸ­æŒ‡é’ˆ\r\n    // ç”¨é•¿çŸ­æŒ‡é’ˆï¼Œå…ˆåˆ¤æ–­ä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦\r\n    int m = size(headA);\r\n    int n = size(headB);\r\n    // çœ‹ä¸‹å“ªä¸ªé“¾è¡¨é•¿ï¼Œé•¿çš„ä¸ºAé“¾è¡¨\r\n    if (n > m) {\r\n      NodeList * temp = headA;\r\n      headA = headB;\r\n      headB = temp;\r\n      int t = n;\r\n      n = m;\r\n      m = t;\r\n    }\r\n    // å¦‚æœç›¸äº¤ï¼Œåˆ™æœ€ç»ˆæœ‰kä¸ªèŠ‚ç‚¹ä¸ºå…±åŒèŠ‚ç‚¹\r\n    // 1<= k<=n\r\n    // å…ˆè®©headAèµ°(m-n)ä¸ªèŠ‚ç‚¹,\r\n    ListNode * p1 = headA;\r\n    for (int i = 0; i < m - n; ++i) {\r\n      p1 = p1->next;\r\n    }\r\n    ListNode * p2 = headB;\r\n    while(p1 && p2) {\r\n      if (p1 == p2) {\r\n        return p1;\r\n      } else {\r\n        p1 = p1->next;\r\n        p2 = p2->next;\r\n      }\r\n    }\r\n    return nullptr;\r\n\r\n  }\r\n\r\n  int size(ListNode * head) {\r\n    ListNode * p = head;\r\n    int result = 0;\r\n    while (p) {\r\n      ++result;\r\n      p = p->next;\r\n    }\r\n    return result;\r\n  }\r\n};\r\n```\r\n\r\n## å¤æ‚åº¦åˆ†æ\r\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(m+n)$\r\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$\r\n\r\n## æˆæœåˆ†äº«\r\n\r\n![æˆªå›¾ 2022-07-24 13-14-11](https://user-images.githubusercontent.com/28218658/180633545-2bc1bfa5-5bf7-4954-8dfa-caf8b59d4f08.png)\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193645676","body":"## é¢˜ç›®é“¾æ¥\n[é“¾æ¥](https://leetcode.cn/problems/linked-list-cycle-ii/)\n\n## æ€è·¯\n- å¿«æ…¢æŒ‡é’ˆï¼Œå¿«æŒ‡é’ˆ2æ­¥ï¼Œæ…¢æŒ‡é’ˆä¸€æ­¥ï¼Œä¸¤è€…ç›¸ç­‰æ—¶æœ‰ç¯\n- ä½†æ˜¯é¢˜ç›®éœ€è¦çš„æ˜¯ç»™å‡ºç¯çš„ä½ç½®ã€‚\n- å‡è®¾ç¯åœ¨ç¬¬kä¸ªèŠ‚ç‚¹å½¢æˆï¼Œç¯çš„é•¿åº¦ä¸ºm\n- å½“æ…¢æŒ‡é’ˆèµ°åˆ°ç¬¬kä¸ªä½ç½®æ—¶å€™ï¼Œå¿«æŒ‡é’ˆèµ°åˆ°ç¬¬2kä¸ªä½ç½®ã€‚\n- ç›¸å½“äº,å¿«æŒ‡é’ˆæ¯”æ…¢æŒ‡é’ˆå…ˆèµ°kæ­¥ã€‚\n- è®¾å®šæ…¢æŒ‡é’ˆä»kå‡ºå‘ï¼Œèµ°äº†xæ­¥åï¼Œå¿«æ…¢æŒ‡é’ˆç›¸é‡\n- æ­¤æ—¶ï¼Œæ…¢æŒ‡é’ˆèµ°xæ­¥,å¿«æŒ‡é’ˆèµ°äº†k+2xæ­¥ï¼Œä¸”å¿«æŒ‡é’ˆæ¯”æ…¢æŒ‡é’ˆå¤šnåœˆã€‚\n- å³ k + 2x - nm = x; x = nm - k;\n- ä»åˆå§‹ç‚¹æ¥çœ‹ï¼Œå¿«æŒ‡é’ˆå…ˆèµ°kæ­¥ï¼Œç›¸é‡ç‚¹è·ç¦»åˆå§‹ç‚¹è¿˜å·®kæ­¥ã€‚\n- æ‰€ä»¥ï¼Œå¦å¤–è®¾ä¸€ä¸ªæ–°æŒ‡é’ˆï¼Œæ–°æŒ‡é’ˆä»headå‡ºå‘ï¼Œæ–°æŒ‡é’ˆä¸slowæŒ‡é’ˆä¸€è‡´ã€‚\n- å½“æ–°æŒ‡é’ˆèµ°äº†kæ­¥åˆ°åˆå§‹ç‚¹æ—¶ï¼ŒslowæŒ‡é’ˆåˆšå¥½ä¹Ÿèµ°åˆ°åˆå§‹ç‚¹ï¼Œæ­¤æ—¶è¿”å› \n\n## ä»£ç \n```cpp\n/**\n * Definition for singly-linked list.\n * \n */\n#include <vector>\n#include <iostream>\n\n\nstruct ListNode {\n  int val;\n  ListNode *next;\n  ListNode(int x) : val(x), next(nullptr) {}\n};\nclass Solution {\npublic:\n  ListNode *detectCycle(ListNode *head) {\n    ListNode * fast = head;\n    ListNode * slow = head;\n    while (true)\n    {\n      if(fast && fast->next) {\n        fast = fast->next->next;\n        slow = slow->next;\n        if (fast == slow) { \n          break;\n        }\n      } else {\n        return nullptr;\n      }\n    }\n    // å°†fastå½“æˆæ–°æŒ‡é’ˆ\n    fast = head;\n    while(fast != slow) {\n      fast = fast->next;\n      slow = slow->next;\n    }\n    return fast;\n  }\n};\n\n\nint main() {\n  // è‡ªå®šä¹‰åˆå§‹åŒ–ä¸€ä¸ªåˆ—è¡¨\n  std::vector<int> v1(std::initializer_list<int>({3, 2, 0, -4}));\n  int n = 1;\n  ListNode * head = nullptr;\n  if (v1.size() > 0) {\n    head = new ListNode(v1[0]);\n  }\n  ListNode * p = head;\n  ListNode * temp = nullptr;\n  for (int i = 1; i < v1.size(); ++i) {\n    temp = new ListNode(v1[i]);\n    p->next = temp;\n    p = p->next;\n  }\n\n    // æ‰“å°ç»“æœ\n  p = head;\n  std::cout << \"input list\" << std::endl;\n  while(p) {\n    std::cout << p->val << \" \";\n    p = p->next;\n  }\n  std::cout << std::endl;\n\n  // å¢åŠ ä¸€ä¸ªç¯\n  ListNode * tail = nullptr;\n  ListNode * circle_p = nullptr;\n  circle_p = head;\n  for (int i = 0; i < n; ++i) {\n    circle_p = circle_p->next;\n  }\n  tail = head;\n  for (int i = 0; i < v1.size() - 1; ++i) {\n    tail = tail->next;\n  }\n  tail->next = circle_p;\n\n  // è°ƒç”¨å‡½æ•°\n  Solution s;\n  ListNode * new_head = s.detectCycle(head);\n  p = new_head;\n  // æ‰“å°ç»“æœ\n  if (new_head) {\n    std::cout << \"output :\" << new_head->val << std::endl;\n  } else {\n    std::cout << \"no crcle\" << std::endl;\n  }\n\n  std::cout << std::endl;\n\n  // é”€æ¯é“¾è¡¨\n  // é”€æ¯å‰æŠŠtail->ç½®ä¸ºnullptr\n  tail->next = nullptr;\n  p = new_head;\n  while (p) {\n    temp = p;\n    p = p->next;\n    delete temp;\n  }\n  std::cout << \"list destory\" << std::endl;\n}\n```\n\n## å¤æ‚åº¦åˆ†æ\n- æ—¶é—´ï¼š$O(n)$\n- ç©ºé—´ï¼š$O(1)$\n\n\n## æˆæœ\n![56909a06c97afcb197f3440fecc1016a.png](https://s2.loli.net/2022/07/25/nk8AVm1tU9QIeMS.png)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195122312","body":"## é¢˜ç›®é“¾æ¥\n\n## ä»£ç \n```cpp\n#include <map>\n#include <iostream>\n#include <utility>\n\nclass Node {\n public:\n  int key;\n  int value;\n  Node * next;\n  Node * prev;\n  Node(int key, int value): key(key), value(value) {\n    next = nullptr;\n    prev = nullptr;\n  }\n};\n\n\n\nclass MyListNode {\n private:\n  Node * head;\n  Node * tail;\n\n public:\n  MyListNode():head(nullptr), tail(nullptr){}\n  void push_front(Node * new_node) {\n    if (head == nullptr) {\n      head = new_node;\n      tail = head;\n    } else {\n      new_node->next = head;\n      head->prev = new_node;\n      head = new_node;\n    }\n  }\n\n  void push_back(Node * new_node) {\n    // æ”¹æˆæŒ‡é’ˆæ“ä½œï¼Œæ–¹ä¾¿åœ°å€ä¸å˜\n    if (head == nullptr) {\n      tail = new_node;\n      head = new_node;\n    } else {\n      tail->next = new_node;\n      new_node->prev = tail;\n      tail = new_node;\n    }\n  }\n\n  void pop_back() {\n    // åˆ é™¤æœ€åä¸€ä¸ªèŠ‚ç‚¹\n    if (tail != nullptr) {\n      Node * pre_node = tail->prev;\n      // åˆ¤æ–­æ˜¯å¦æ˜¯å•èŠ‚ç‚¹\n      if (pre_node != nullptr) {\n        pre_node->next = nullptr;\n        tail = pre_node;\n      } else {\n        tail = nullptr;\n        head = nullptr;\n      }\n    }\n  }\n\n  void remove_node(Node * node) {\n    Node * pre_node = node->prev;\n    if (pre_node != nullptr) {\n      Node * next_node = node->next;\n      pre_node->next = next_node;\n      if (next_node != nullptr) {\n        next_node->prev = pre_node;\n      } else {\n        // è¯´æ˜tailåˆ°å¤´äº†ï¼Œéœ€è¦å°†tailç§»åˆ°preçš„ä½ç½®\n        tail = pre_node;\n      }\n    } else {\n      // è¯´æ˜è¯¥èŠ‚ç‚¹åº”è¯¥æ˜¯headèŠ‚ç‚¹ï¼Œæ²¡æœ‰prev\n      Node * next_node = node->next;\n      if (next_node != nullptr) {\n        head = next_node;\n        next_node->prev = nullptr;\n      } else {\n        // è¯´æ˜æ˜¯å•èŠ‚ç‚¹\n        head = tail = nullptr;\n      }\n    }\n  }\n  Node * back() {\n    return tail;\n  }\n};\n\nclass LRUCache {\n private:\n  int capacity;\n  int size;\n  std::map<int, Node *> dict1;\n  MyListNode cache;\n public:\n  LRUCache(int capacity): capacity(capacity), size(0){}\n  ~LRUCache() {\n    // æ¸…ç†ç©ºé—´\n    auto it = dict1.begin();\n    while(it != dict1.end()) {\n      delete it->second;\n      ++it;\n    }\n  }\n    \n  int get(int key) {\n    int temp = dict1.count(key);\n    // tempä¼šè¿”å›å•¥ï¼Ÿ\n    if (temp > 0) {\n      // æœ€ç®€å•çš„æ–¹æ³•å°±æ˜¯å°†æ•°æ®é‡æ–°å…¥dictå³å¯\n      Node * res = dict1.at(key);\n      int value = res->value;\n      put(key, res->value);\n      return value;\n    } else {\n      return -1;\n    }\n  }\n    \n  void put(int key, int value) {\n    // é¦–å…ˆåˆ¤æ–­keyæ˜¯å¦åœ¨dictä¸­ï¼Œå¦‚æœä¸å†\n    // å¦‚æœkeyåœ¨dictä¸­ï¼Œå…ˆå°†æ—§çš„cacheæ¸…ç†ï¼Œç„¶åæ–°cacheï¼Œå†æ›´æ–°æ•°æ®ã€‚\n    // å†åˆ¤æ–­dict.size() æ˜¯å¦è¶…è¿‡capacity\n    // å¦åˆ™ï¼Œè¯´æ˜å®¹é‡ä¸å¤Ÿï¼Œåˆ©ç”¨é˜Ÿåˆ—ï¼Œå°†æ—§æ•°æ®æ¨å‡ºï¼Œæ—§æ•°æ®å¯ä»¥åˆ©ç”¨ä¸€ä¸ªåŒé“¾è¡¨è¿›è¡Œç®¡ç†\n    if (dict1.count(key) > 0) {\n      // æ¸…ç†æ—§æ•°æ®ç¼“å­˜\n      Node * old_node = dict1.at(key);\n      cache.remove_node(old_node);\n      dict1.erase(old_node->key);\n      delete old_node;\n\n    } else if (size < capacity) {\n      ++size;\n\n    } else {\n      // æ¸…ç†æœ€åä¸€ä¸ªæ•°æ®\n      Node * last_node = cache.back();\n      dict1.erase(last_node->key);\n      cache.pop_back();\n      delete last_node;\n    }\n\n    Node * new_node =  new Node(key, value);\n    dict1.insert(std::make_pair(key, new_node));\n    cache.push_front(new_node);\n  }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n\n\nint main() {\n  LRUCache cache(2);\n  cache.put(1, 1);\n  cache.put(2, 2);\n  std::cout << cache.get(1) << std::endl;\n  cache.put(3, 3);\n  std::cout << cache.get(2) << std::endl;\n}\n```\n\n- è²Œä¼¼æœ‰é‡å¤å¼€è¾Ÿç©ºé—´çš„å«Œç–‘ï¼Œå¯ä»¥ä¼˜åŒ–ä¸€ä¸‹\n- ä¼˜åŒ–åï¼ˆä¼˜åŒ–åæœ¬åœ°å¯è·‘likouè·‘äº†ä¼šå‡ºé”™ï¼Œæç¤ºç©ºæŒ‡é’ˆé‡å¤åˆ©ç”¨ï¼Œä¸çŸ¥å•¥æƒ…å†µï¼‰\n```cpp\n\nclass LRUCache {\n private:\n  int capacity;\n  int size;\n  std::map<int, Node *> dict1;\n  MyListNode cache;\n public:\n  LRUCache(int capacity): capacity(capacity), size(0){}\n  ~LRUCache() {\n    // æ¸…ç†ç©ºé—´\n    auto it = dict1.begin();\n    while(it != dict1.end()) {\n      delete it->second;\n      ++it;\n    }\n  }\n    \n  int get(int key) {\n    int temp = dict1.count(key);\n    if (temp > 0) {\n      // æœ€ç®€å•çš„æ–¹æ³•å°±æ˜¯å°†æ•°æ®é‡æ–°å…¥dictå³å¯\n      Node * res = dict1.at(key);\n      int value = res->value;\n      put(key, res->value);\n      return value;\n    } else {\n      return -1;\n    }\n  }\n    \n  void put(int key, int value) {\n    // é¦–å…ˆåˆ¤æ–­keyæ˜¯å¦åœ¨dictä¸­ï¼Œå¦‚æœä¸å†\n    // å¦‚æœkeyåœ¨dictä¸­ï¼Œå…ˆå°†æ—§çš„cacheæ¸…ç†ï¼Œç„¶åæ–°cacheï¼Œå†æ›´æ–°æ•°æ®ã€‚\n    // å†åˆ¤æ–­dict.size() æ˜¯å¦è¶…è¿‡capacity\n    // å¦åˆ™ï¼Œè¯´æ˜å®¹é‡ä¸å¤Ÿï¼Œåˆ©ç”¨é˜Ÿåˆ—ï¼Œå°†æ—§æ•°æ®æ¨å‡ºï¼Œæ—§æ•°æ®å¯ä»¥åˆ©ç”¨ä¸€ä¸ªåŒé“¾è¡¨è¿›è¡Œç®¡ç†\n    // ç©ºé—´ä¼˜åŒ–ï¼Œå¦‚æœå·²æœ‰æ—§æ•°æ®ï¼Œåˆ™åŠ¨ä¸€ä¸‹ç¼“å­˜,ç„¶ååŠ dictçš„æŒ‡é’ˆå³å¯\n    if (dict1.count(key) > 0) {\n      // æ¸…ç†æ—§æ•°æ®ç¼“å­˜\n      Node * old_node = dict1.at(key);\n      cache.remove_node(old_node);\n      cache.push_front(old_node);\n      old_node->value = value;\n\n    } else {\n      if (size < capacity) {\n        ++size;\n\n      } else {\n        // æ¸…ç†æœ€åä¸€ä¸ªæ•°æ®\n        Node * last_node = cache.back();\n        dict1.erase(last_node->key);\n        cache.pop_back();\n        delete last_node;\n      }\n      Node * new_node =  new Node(key, value);\n      dict1.insert(std::make_pair(key, new_node));\n      cache.push_front(new_node);\n    }\n  }\n};\n```\n## å¤æ‚åº¦\n- æ—¶é—´ï¼šput: O(1), get: O(1)\n- ç©ºé—´ï¼šO(n)\n\n## æˆæœ\n![cf8b66fdd9384b4f2ea2f7c17df26f58.png](https://s2.loli.net/2022/07/26/b6OjyczS3U2MKsF.png)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196195321","body":"## é¢˜ç›®é“¾æ¥\n- [é“¾æ¥](https://leetcode.cn/problems/maximum-depth-of-binary-tree/submissions/)\n\n## ä»£ç \n```cpp\n#include<iostream>\n/**\n * Definition for a binary tree node.\n */\n\nstruct TreeNode {\n  int val;\n  TreeNode *left;\n  TreeNode *right;\n  TreeNode() : val(0), left(nullptr), right(nullptr) {}\n  TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n  TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\nclass Solution {\npublic:\n  int maxDepth(TreeNode* root) {\n    if (root != nullptr) {\n      int left_res = maxDepth(root->left) + 1;\n      int right_res = maxDepth(root->right) + 1;\n      return std::max(left_res, right_res);\n    } else{\n      return 0;\n    }\n  }\n};\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´ï¼šO(n)\n- ç©ºé—´ï¼šO(n)ï¼Œå› ä¸ºç”¨äº†é€’å½’ï¼Œæ‰€ä»¥æ¯å±‚è®¡ç®—ç»“æœéƒ½è¦å…¥æ ˆã€‚\n\n- ç”±äºæ·±åº¦ä¸ºå¸¸é‡ï¼Œå¯ä»¥ç”¨constexpræ¥ä¼˜åŒ–ä¸€ä¸‹ã€‚\n- [å‚è€ƒé“¾æ¥](https://changkun.de/modern-cpp/zh-cn/02-usability/)\n```cpp\nclass Solution {\npublic:\n  constexpr int maxDepth(TreeNode* root) {\n    return root != nullptr ? std::max(maxDepth(root->left) + 1, maxDepth(root->right) + 1): 0;\n  }\n};\n```\n\n## ç»“æœ\n![6fa5e9ab520238b8d4f5204f7c5deead.png](https://s2.loli.net/2022/07/27/mUksPtVG1uYf85Z.png)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197559252","body":"## é¢˜ç›®é“¾æ¥\n- [é“¾æ¥](https://leetcode.cn/problems/same-tree/submissions/)\n## ä»£ç \n```cpp\n/**\n * Definition for a binary tree node.\n */\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\n\nclass Solution {\npublic:\n  bool isSameTree(TreeNode* p, TreeNode* q) {\n    if (p && q && p->val == q->val) {\n      if (isSameTree(p->left, q->left) && isSameTree(p->right, q->right)) {\n        return true;\n      } else {\n        return false;\n      }\n    } else if (p == nullptr && q == nullptr) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n};\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´ï¼šO(n)\n- ç©ºé—´ï¼šO(n)\n\n## æˆæœ\n![98a51873fdcc127907ee9bc94905acb9.png](https://s2.loli.net/2022/07/28/5O8GFzIig6Pcf9m.png)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198849580","body":"## é¢˜ç›®é“¾æ¥\n- [é“¾æ¥](https://leetcode.cn/problems/sum-root-to-leaf-numbers/submissions/)\n## ä»£ç \n```cpp\nstruct TreeNode {\n  int val;\n  TreeNode *left;\n  TreeNode *right;\n  TreeNode() : val(0), left(nullptr), right(nullptr) {}\n  TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n  TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n  int sumNumbers(TreeNode* root){\n    return sum_help(root, 0);\n  }\n  \n  int sum_help(TreeNode * root, int parent_val) {\n    if (root) {\n      parent_val = parent_val * 10 + root->val;\n      // æ™®é€šèŠ‚ç‚¹\n      if (root->left && root->right) {\n        int left_sum =  sum_help(root->left, parent_val);\n        int right_sum =  sum_help(root->right, parent_val);\n        return left_sum + right_sum;\n      } else if (root->left) {\n        return sum_help(root->left, parent_val);\n      } else if (root->right) {\n        return sum_help(root->right, parent_val);\n      }\n      else {\n        // å½“å‰ä¸ºå¶å­èŠ‚ç‚¹ï¼Œç›´æ¥è¿”å›æ•°æ®å³å¯\n        return parent_val;\n      }\n      // return (left_sum + right_sum) / 2;\n    } else {\n      return parent_val;\n    }\n  }\n};\n```\n\n### å¤æ‚åº¦\n- æ—¶é—´ï¼šO(n)\n- ç©ºé—´ï¼šO(log(n))\n\n## èƒ½å¦ä¼˜åŒ–ï¼Ÿ\n- ç æ‰å¤šä½™if\n```cpp\nclass Solution {\npublic:\n  int sumNumbers(TreeNode* root){\n    return sum_help(root, 0);\n  }\n\n  int sum_help(TreeNode * root, int parent_val) {\n    if (root) {\n      parent_val = parent_val * 10 + root->val;\n      // æ™®é€šèŠ‚ç‚¹\n      if (!root->left && !root->right) {\n        return parent_val;\n      }\n      else{\n        int left_sum = sum_help(root->left, parent_val);\n        int right_sum = sum_help(root->right, parent_val);\n        return left_sum + right_sum;\n      }\n    } else{\n      return 0;\n    }\n  }\n};\n```\n- constexprä¼˜åŒ–(è²Œä¼¼å˜æ…¢äº†ï¼Œåº”è¯¥æ˜¯parent_valé‚£é‡Œé‡å¤è®¡ç®—äº†)\n```cpp\nclass Solution {\npublic:\n  int sumNumbers(TreeNode* root){\n    return sum_help3(root, 0);\n  }\n\n  constexpr int sum_help3(TreeNode * root, int parent_val) {\n    return root ? (\n      !root->left && !root->right ? parent_val * 10 + root->val\n      : sum_help3(root->left, parent_val * 10 + root->val) + sum_help3(root->right, parent_val * 10 + root->val)\n    ): 0;\n  }\n};\n```\n\n\n## æœ€ç»ˆç»“æœ\n![cbdd684813e3d0f394ebefa8cda7419e.png](https://s2.loli.net/2022/07/29/KRShDziG3j1uYdH.png)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200070485","body":"## é¢˜ç›®é“¾æ¥\r\n- [é“¾æ¥](https://leetcode.cn/problems/find-bottom-left-tree-value/submissions/)\r\n\r\n## æ€è·¯\r\n- å…ˆéå†ä¸€æ¬¡æ‰¾åˆ°æœ€å¤§æ·±åº¦\r\n- å†éå†ä¸€æ¬¡ï¼Œå½“å‘ç°ç¬¬ä¸€ä¸ªå¶å­ï¼ˆå³å…¶æ·±åº¦ä¸ºæœ€å¤§æ·±åº¦æ—¶ï¼‰ï¼Œè¿”å›è¯¥å€¼\r\n\r\n\r\n## ä»£ç \r\n```cpp\r\n#include <iostream>\r\n/**\r\n * Definition for a binary tree node.\r\n */\r\nstruct TreeNode {\r\n  int val;\r\n  TreeNode *left;\r\n  TreeNode *right;\r\n  TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n  TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n  TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n};\r\nclass Solution {\r\npublic:\r\n  int max_depth;\r\n  int result;\r\n  bool has_result;\r\n  int findBottomLeftValue(TreeNode* root) {\r\n    // å…ˆéå†ä¸€æ¬¡ï¼Œæ‰¾åˆ°æœ€å¤§æ·±åº¦ï¼Œç„¶åå±‚åºéå†ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªå¶å­èŠ‚ç‚¹ï¼Œæœ€åè¿”å›å³å¯ã€‚\r\n    max_depth = maxDepth(root);\r\n    has_result = false;\r\n    fun_help(root, 0);\r\n    return result; \r\n  }\r\n\r\n  constexpr int maxDepth(TreeNode* root) {\r\n    return root != nullptr ? std::max(maxDepth(root->left), maxDepth(root->right)) + 1: 0;\r\n  }\r\n\r\n  void fun_help(TreeNode * root, int now_depth) {\r\n    if (!has_result &&  now_depth == max_depth && root) {\r\n      result = root->val;\r\n      has_result = true;\r\n    }\r\n    if (root) {\r\n      fun_help(root->left, now_depth + 1);\r\n      fun_help(root->right, now_depth + 1);\r\n    }\r\n  }\r\n};\r\n```\r\n\r\n## å¤æ‚åº¦\r\n- æ—¶é—´ï¼š0(n)\r\n- ç©ºé—´ï¼šO(log(n))\r\n\r\n\r\n## ä¼˜åŒ–æ€è·¯\r\n- èƒ½å¦æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¶å­èŠ‚ç‚¹åæå‰åœæ­¢ï¼Œå‡å°‘ifæ“ä½œ\r\n- èƒ½å¦ä¸€æ¬¡éå†è·å¾—ç»“æœï¼Ÿ\r\n\r\n## æˆæœ\r\n\r\n\r\n![](https://pic.imgdb.cn/item/62e497e2f54cd3f937421c57.png)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200403462","body":"### é¢˜ç›®é“¾æ¥\n- é¢˜ç›®é“¾æ¥(https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)\n\n### é¢˜ç›®æ€è·¯\n- ç”±äºç¤ºä¾‹ç»™å‡ºçš„æ˜¯ä¸€ä¸ªå®Œå…¨äºŒå‰æ ‘åˆ—è¡¨è¿›è¡Œè¾“å…¥ï¼Œæ‰€ä»¥ç¬¬ä¸€ååº”å°±æ˜¯ï¼Œåºåˆ—åŒ–ä¸ºstringå‰ï¼Œå°†æ™®é€šäºŒå‰æ ‘è½¬æ¢ä¸ºå®Œå…¨äºŒå‰æ ‘ï¼Œç„¶åå†ç”¨bfsè¿›è¡Œè¾“å‡ºã€‚\n### ä»£ç ï¼ˆå®Œå…¨äºŒå‰æ ‘ç‰ˆï¼‰\n```cpp\n#include <iostream>\n#include <string>\n#include <queue>\n#include <math.h>\n\nusing std::string;\n\n/**\n * Definition for a binary tree node.\n*/\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\nclass Codec {\npublic:\n\n  // Encodes a tree to a single string.\n  string serialize(TreeNode* root) {\n    // éå†ï¼Ÿå±‚åºéå†å³å¯\n    // å¦‚ä½•è®°å½•nullå€¼ï¼Ÿ\n    // å¯ä»¥å°è¯•æŠŠäºŒå‰æ ‘å˜æˆæ»¡äºŒå‰æ ‘ï¼Œnullå€¼å…ˆç”¨-2000ä»£æ›¿ï¼ˆå› ä¸ºé¢˜ç›®æ„æ€æ˜¯node.valæœ€å°ä¸º-1000ï¼‰\n    int tree_depth = max_depth(root);\n    \n    std::string result = \"[\";\n    std::queue<TreeNode *> my_queue;\n    TreeNode * null_node = new TreeNode(-2000);\n    // è®°å½•ç´¯è®¡å…¥é˜Ÿå…ƒç´ ä¸ªæ•°\n    int i = 0;\n    int total_num = pow(2, tree_depth) - 1;\n    if (root) {\n      my_queue.push(root);\n      ++i;\n      while (!my_queue.empty())\n      {\n        TreeNode * node = my_queue.front();\n        if (node->val > -2000) {\n          result += std::to_string(node->val) + \",\";\n        } else {\n          result += \"null,\";\n        }\n        my_queue.pop();\n        if (node->left != NULL) {\n          my_queue.push(node->left);\n          ++i;\n        } else if(i < total_num) {\n          my_queue.push(null_node);\n          ++i;\n        }\n        if (node->right != NULL) {\n          my_queue.push(node->right);\n          ++i;\n        } else if(i < total_num) {\n          my_queue.push(null_node);\n          ++i;\n        }\n      }\n      result.pop_back();\n    }\n    result = result + \"]\";\n    delete null_node;\n    return std::move(result);\n  }\n\n  constexpr int max_depth(TreeNode* root) {\n    return root != nullptr ? std::max(max_depth(root->left), max_depth(root->right)) + 1: 0;\n  }\n\n  // Decodes your encoded data to tree.\n  TreeNode* deserialize(string data) {\n    // å…ˆæŠŠå­—ç¬¦ä¸²å˜æˆä¸€ä¸ªæ•°å­—åˆ—è¡¨, ç„¶åæ ¹æ®æ»¡äºŒå‰æ ‘çš„æ€§è´¨æ¥æ„å»ºä¸€é¢—æ–°æ ‘\n    // åŸåˆ™ï¼Œæ ¹æ®çˆ¶è¾ˆçš„åºåˆ—å·id*2,+1åˆ™ä¸ºå·¦è¾¹ï¼Œ+2åˆ™ä¸ºå³è¾¹ \n    // ç¬¬ä¸€æ­¥ï¼Œå…ˆåˆ©ç”¨å¿«æ…¢æŒ‡é’ˆå°†strå˜æˆæ•°ç»„\n    int i = 1, j = 2;\n    std::vector<int> num_list;\n    while (j < data.size() - 1) {\n      if (data.at(j) == ',') {\n        if (data.substr(i, j - i) == \"null\") {\n          num_list.push_back(-2000);\n        } else {\n          num_list.push_back(std::stoi(data.substr(i, j - i)));\n        }\n        i = j + 1;\n      }\n      ++j;\n    }\n    // å¢åŠ æœ«å°¾å­—ç¬¦\n    if (data.size() - 1 - i > 0) {\n      if (data.substr(i, data.size() - 1 - i) == \"null\") {\n        num_list.push_back(-2000);\n      } else {\n        num_list.push_back(std::stoi(data.substr(i, j - i)));\n      }\n    }\n    TreeNode * root = nullptr;\n    create_tree(&root, 0, num_list);\n    return root;\n  }\n\n  void create_tree(TreeNode ** root, int parent_id, const std::vector<int> & num_list) {\n    if (parent_id < num_list.size()) {\n      int value = num_list[parent_id];\n      if (value > -2000) {\n        *root = new TreeNode(value);\n        create_tree(&((*root)->left), 2 * parent_id + 1, num_list);\n        create_tree(&((*root)->right), 2 * parent_id + 2, num_list);\n      }\n    }\n  }\n};\n\n\n\nint main() {\n  std::string str1 = \"[1,2,3,null,null,4,5,null,null,null,null]\";\n  Codec c;\n  TreeNode * root = c.deserialize(str1);\n  std::string str2 = c.serialize(root);\n  std::cout << str2 << std::endl;\n  std::cout << (str1 == str2) << std::endl;\n}\n```\n\n- ç”±äºæµ‹è¯•æ¡ˆä¾‹ä¸­å­˜åœ¨ä¸€ä¸ªé«˜åº¦ä¸º999çš„å•è¾¹æ ‘ï¼Œå¯¼è‡´æ»¡äºŒå‰æ ‘èŠ‚ç‚¹è®¡ç®—æ—¶æº¢å‡ºã€‚\n- å¹¶ä¸”ç»“åˆå…¶è¾“å…¥æ¥çœ‹ï¼Œå¯ä»¥ä¸ç”¨å®Œå…¨äºŒå‰æ ‘ï¼ˆå¹¶ä¸”ç”¨äº†å°±æ²¡æ³•é€šè¿‡è¯¥æµ‹è¯•æ¡ˆä¾‹ï¼‰\n- æ‰€ä»¥ï¼Œæ¢æ™®é€šçš„bfséå†æ ‘å³å¯ã€‚\n\n### ä»£ç ï¼ˆæ™®é€šbfsç‰ˆï¼‰\n```cpp\n#include <iostream>\n#include <string>\n#include <queue>\n#include <math.h>\n\nusing std::string;\n\n/**\n * Definition for a binary tree node.\n*/\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\nclass Codec {\npublic:\n\n  // Encodes a tree to a single string.\n  string serialize(TreeNode* root) {\n    // éå†ï¼Ÿå±‚åºéå†å³å¯\n    // å¦‚ä½•è®°å½•nullå€¼ï¼Ÿ\n    std::string result = \"[\";\n    std::queue<TreeNode *> my_queue;\n    // è®°å½•ç´¯è®¡å…¥é˜Ÿå…ƒç´ ä¸ªæ•°\n    if (root) {\n      my_queue.push(root);\n      while (!my_queue.empty())\n      {\n        TreeNode * node = my_queue.front();\n        my_queue.pop();\n        if (node) {\n          result += std::to_string(node->val) + \",\";\n\n          if (node->left != NULL) {\n            my_queue.push(node->left);\n          } else {\n            my_queue.push(nullptr);\n          }\n          if (node->right != NULL) {\n            my_queue.push(node->right);\n          } else {\n            my_queue.push(nullptr);\n          }\n        } else {\n          result += \"null,\";\n        }\n      }\n      result.pop_back();\n    }\n    result = result + \"]\";\n    return std::move(result);\n  }\n\n\n  // Decodes your encoded data to tree.\n  TreeNode* deserialize(string data) {\n    // å…ˆæŠŠå­—ç¬¦ä¸²å˜æˆä¸€ä¸ªæ•°å­—åˆ—è¡¨, ç„¶åæ ¹æ®æ»¡äºŒå‰æ ‘çš„æ€§è´¨æ¥æ„å»ºä¸€é¢—æ–°æ ‘\n    // åŸåˆ™ï¼Œæ ¹æ®çˆ¶è¾ˆçš„åºåˆ—å·id*2,+1åˆ™ä¸ºå·¦è¾¹ï¼Œ+2åˆ™ä¸ºå³è¾¹ \n    // ç¬¬ä¸€æ­¥ï¼Œå…ˆåˆ©ç”¨å¿«æ…¢æŒ‡é’ˆå°†strå˜æˆæ•°ç»„\n    int i = 1, j = 2;\n    std::vector<int> num_list;\n    while (j < data.size() - 1) {\n      if (data.at(j) == ',') {\n        if (data.substr(i, j - i) == \"null\") {\n          num_list.push_back(-2000);\n        } else {\n          num_list.push_back(std::stoi(data.substr(i, j - i)));\n        }\n        i = j + 1;\n      }\n      ++j;\n    }\n    // å¢åŠ æœ«å°¾å­—ç¬¦\n    if (data.size() - 1 - i > 0) {\n      if (data.substr(i, data.size() - 1 - i) == \"null\") {\n        num_list.push_back(-2000);\n      } else {\n        num_list.push_back(std::stoi(data.substr(i, j - i)));\n      }\n    }\n    TreeNode * root = nullptr;\n    create_tree(&root, num_list);\n    return root;\n  }\n\n  void create_tree(TreeNode ** root, const std::vector<int> & num_list) {\n    int i = 0;\n    std::queue<TreeNode *> my_queue;\n    if (i < num_list.size()) {\n      *root = new TreeNode(num_list[i]);\n      my_queue.push(*root);\n      ++i;\n      while (!my_queue.empty() && i < num_list.size()) {\n        TreeNode * node =  my_queue.front();\n        my_queue.pop();\n        if (num_list[i] > -2000) {\n          TreeNode * temp = new TreeNode(num_list[i]);\n          node->left = temp;\n          my_queue.push(temp);\n        }\n        ++i;\n        if (num_list[i] > -2000) {\n          TreeNode * temp2 = new TreeNode(num_list[i]);\n          node->right = temp2;\n          my_queue.push(temp2);\n        }\n        ++i;\n      }\n    }\n  }\n};\n\n\nint main() {\n  std::string str1 = \"[1,2,3,null,null,4,5,null,null,null,null]\";\n  Codec c;\n  TreeNode * root = c.deserialize(str1);\n  std::string str2 = c.serialize(root);\n  std::cout << str2 << std::endl;\n  std::cout << (str1 == str2) << std::endl;\n}\n```\n\n- æ³¨ï¼šå®é™…ä¸Šï¼Œinputæœ€å³è¾¹å¤šä½™çš„â€œnullâ€æ˜¯å¯ä»¥æ¶ˆé™¤çš„ï¼Œå¹¶ä¸”ä¸Šé¢åºåˆ—åŒ–çš„æ—¶å€™ç†è®ºä¸Šä¹Ÿåº”è¯¥æ¸…é™¤ã€‚ä¸è¿‡åŠ›æ‰£å®˜ç½‘ä¸æ¸…é™¤æœ«å°¾çš„nullä¹Ÿæ˜¯å¯ä»¥é€šè¿‡çš„ã€‚æ‰€ä»¥è¯´æ˜åº”è¯¥å¯¹æ¯”çš„æ˜¯æ ‘æ˜¯å¦ä¸€è‡´ï¼Œè€Œéå­—ç¬¦ä¸²æ˜¯å¦ä¸€è‡´ã€‚\n\n### å¤æ‚åº¦\n- åºåˆ—åŒ–\n- æ—¶é—´ï¼šO(n)\n- ç©ºé—´ï¼šO(1)\n\n- ååºåˆ—åŒ–\n- æ—¶é—´: O(n)\n- ç©ºé—´: O(n)\n\n### æˆæœ\n- ![æˆªå›¾](https://pic.imgdb.cn/item/62e6643a8c61dc3b8ee63011.png)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200700633","body":"### é¢˜ç›®é“¾æ¥\n- [é“¾æ¥](https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/)\n\n### ä»£ç \n```cpp\n/**\n * Definition for a binary tree node.\n * \n */\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <string>\n\nusing std::string;\nusing std::vector;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\n\nclass Location {\n public:\n  int row;\n  int value;\n  Location(int row, int val): row(row), value(val){};\n  bool operator < (const Location & x) const {\n    if (row < x.row) {\n      return true;\n    } else if (row == x.row && value < x.value) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n};\nclass Solution {\npublic:\n  vector<vector<int>> verticalTraversal(TreeNode* root) {\n    // æ€è·¯ï¼Ÿå…ˆç”¨bfsæ‰“å°ä¸€ä¸‹ï¼Œé¡ºä¾¿æ”¶é›†èŠ‚ç‚¹çš„è¡Œåˆ—å€¼ï¼Œç„¶åæŒ‰åˆ—è¿›è¡Œæ’åºï¼Ÿ\n    // å½“x, yç›¸åŒæ—¶ï¼Œlistæ‰éœ€è¦æ’åº\n    // è€ƒè™‘æ’åºï¼Œæ‰€ä»¥è¿˜æ˜¯ç”¨bfsæ›´å¥½\n    std::map<int, std::vector<Location>> dict1;\n    get_location(root, 0, 0, dict1);\n    // ç„¶åéå†dict,å¯¹valueè¿›è¡Œæ’åº\n    std::vector<std::vector<int>> result;\n    for (auto & x: dict1) {\n      if (x.second.size() == 1) {\n        std::vector<int> temp_list({x.second[0].value});\n        result.push_back(std::move(temp_list));\n      } else {\n        std::sort(x.second.begin(), x.second.end());\n        std::vector<int> temp_list(x.second.size());\n        for (int i = 0; i < x.second.size(); ++i) {\n          temp_list[i] = x.second[i].value;\n        }\n        result.push_back(std::move(temp_list));\n      }\n    }\n    return std::move(result);\n\n  }\n\n  void get_location(\n    TreeNode * root, int row, int col, std::map<int, std::vector<Location>> & dict1) {\n\n    if (root) {\n      // å…ˆåˆ¤æ–­colæ˜¯å¦åœ¨rootä¸­\n      if (dict1.count(col)) {\n        std::vector<Location> temp_list(std::move(dict1.at(col)));\n        temp_list.push_back(Location(row, root->val));\n        dict1[col] = temp_list;\n      } else {\n        std::vector<Location> temp_list({Location(row, root->val)});\n        dict1[col] = temp_list;\n      }\n      // ç„¶åéå†å·¦å³èŠ‚ç‚¹\n      if (root->left) {\n        get_location(root->left, row + 1, col - 1, dict1);\n      }\n      if (root->right) {\n        get_location(root->right, row + 1, col + 1, dict1);\n      }\n    }\n  }\n};\n```\n\n### å¤æ‚åº¦\n- æ—¶é—´ï¼Œsorté‚£é‡Œå ç”¨æœ€å¤§ï¼Œ$O(n*log(n))$\n- ç©ºé—´ï¼š$O(n)$\n\n### ä¼˜åŒ–ï¼Ÿ\n- ä¸ç”¨å†…ç½®æ’åºï¼Œå°†Locationæ¢æˆdict\n- å‡å°‘ä¸­é—´å˜é‡åˆ›å»º\n\n### ç»“æœ\n![0a82f3bb0b84c0cd3564e56103a0f460.png](https://s2.loli.net/2022/08/01/MVhd9PGzHlA7ke4.png)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201953456","body":"## é¢˜ç›®é“¾æ¥\r\n- [é“¾æ¥](https://leetcode.cn/problems/two-sum/submissions/)\r\n\r\n## æ€è·¯\r\n- å…ˆæ’åºï¼Œå†å¿«æ…¢æŒ‡é’ˆ\r\n- ç”±äºéœ€è¦è¿”å›åŸå…ˆåºåˆ—çš„ç´¢å¼•ï¼Œæ‰€ä»¥éœ€è¦æ’åºå‰å…ˆç”¨å“ˆå¸Œè¡¨å­˜ä¸€ä¸‹æ¯ä¸ªå€¼çš„ç´¢å¼•\r\n- å› ä¸ºå¯èƒ½å­˜åœ¨ç›¸åŒçš„å€¼ï¼Œä½†ç´¢å¼•ä¸ä¸€æ ·ï¼Œæ‰€ä»¥å“ˆå¸Œè¡¨å¯¹åº”çš„valueéœ€è¦ä¸ºåˆ—è¡¨\r\n- è¿”å›çš„æ—¶å€™ï¼Œåˆ¤æ–­é•¿çŸ­æŒ‡é’ˆå¯¹åº”çš„å€¼æ˜¯å¦ç›¸ç­‰ï¼Œå¦‚æœç›¸ç­‰åˆ™åªéœ€è¦è¿”å›ä¸€ä¸ªç´¢å¼•å³å¯ã€‚å¦åˆ™è¿”å›ä¸¤ä¸ªç´¢å¼•ã€‚\r\n\r\n\r\n## ä»£ç \r\n```cpp\r\n#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <map>\r\n\r\nusing std::vector;\r\n\r\nclass Solution {\r\npublic:\r\n  vector<int> twoSum(vector<int>& nums, int target) {\r\n    // æ’åºå‰å…ˆç”¨dictè®°å½•ä¸€ä¸‹ä½ç½®\r\n    // è¿™æ ·å†™è²Œä¼¼ä¸å¤ªè¡Œï¼Œå› ä¸ºå¯èƒ½æœ‰é‡å¤å€¼ï¼Œä¿é™©èµ·è§ç”¨åˆ—è¡¨æ¯”è¾ƒå¥½\r\n    std::map<int, std::vector<int>> dict1;\r\n    for (int i = 0; i < nums.size(); ++i) {\r\n      dict1[nums[i]].emplace_back(i);\r\n    }\r\n    std::sort(nums.begin(), nums.end());\r\n    int short_p = 0, long_p = nums.size() - 1;\r\n    while (short_p < long_p) {\r\n      if (nums[short_p] + nums[long_p] > target) {\r\n        --long_p;\r\n      } else if (nums[short_p] + nums[long_p] == target) {\r\n        break;\r\n      } else {\r\n        ++short_p;\r\n      }\r\n    }\r\n    if (nums[short_p] == nums[long_p]) {\r\n      return std::move(dict1[nums[short_p]]);\r\n    } else {\r\n      return std::move(std::vector<int>({dict1[nums[short_p]][0], dict1[nums[long_p]][0]}));\r\n    }\r\n  }\r\n};\r\n\r\n\r\nint main() {\r\n  Solution s;\r\n  std::vector<int> v1({2, 7, 11, 15});\r\n  std::vector<int> res = s.twoSum(v1, 9);\r\n  for (const int x: res) {\r\n    std::cout << x << \",\";\r\n  }\r\n  std::cout << std::endl;\r\n}\r\n```\r\n\r\n\r\n## å¤æ‚åº¦\r\n- æ—¶é—´ï¼šéœ€è¦æ’åºï¼Œæ‰€ä»¥ä¸ºO(n* log(n))\r\n- ç©ºé—´ï¼šéœ€è¦å“ˆå¸Œè¡¨ï¼Œæ‰€ä»¥ä¸ºO(n)\r\n\r\n## ä¼˜åŒ–\r\n- å»é™¤æ’åºï¼Œç›´æ¥è¾¹ç”¨å“ˆå¸Œè¡¨ï¼ˆunordered_mapï¼‰å‚¨å­˜ç»“æœï¼Œè¾¹å¯¹äºå‰©ä½™å€¼æ˜¯å¦åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œå¦‚æœæœ‰ï¼Œåˆ™è¿”å›ã€‚\r\n\r\n## ä»£ç ï¼ˆä¼˜åŒ–åï¼‰\r\n```cpp\r\n#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <unordered_map>\r\n\r\nusing std::vector;\r\n\r\nclass Solution {\r\npublic:\r\n  vector<int> twoSum(vector<int>& nums, int target) {\r\n    std::unordered_map<int, int> dict1;\r\n    for (int i = 0; i < nums.size(); ++i) {\r\n      if (dict1.count(target - nums[i])) {\r\n        return std::move(std::vector<int>({dict1[target - nums[i]], i}));\r\n      } \r\n       dict1.emplace(std::pair<int, int>(nums[i], i));\r\n    }\r\n    return std::move(std::vector<int>({-1, -1}));\r\n  }\r\n};\r\n\r\n\r\nint main() {\r\n  Solution s;\r\n  std::vector<int> v1({3, 3});\r\n  std::vector<int> res = s.twoSum(v1, 6);\r\n  for (const int x: res) {\r\n    std::cout << x << \",\";\r\n  }\r\n  std::cout << std::endl;\r\n}\r\n```\r\n\r\n\r\n## å¤æ‚åº¦\r\n- æ—¶é—´ï¼šæ‰€ä»¥ä¸ºO(n)\r\n- ç©ºé—´ï¼šéœ€è¦å“ˆå¸Œè¡¨ï¼Œæ‰€ä»¥ä¸ºO(n)\r\n\r\n## ç»“æœ\r\n![4027cdb214065c4819ec265cf5db8a2c.png](https://s2.loli.net/2022/08/02/trx6LA3YeZvq2yh.png)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203450244","body":"### é¢˜ç›®è¿æ¥\n- [é“¾æ¥](https://leetcode.cn/problems/top-k-frequent-elements/)\n\n\n### å‚è€ƒé“¾æ¥\n- [é“¾æ¥](http://c.biancheng.net/view/480.html)\n\n\n### ä»£ç \n```cpp\nclass Solution {\npublic:\n  vector<int> topKFrequent(vector<int>& nums, int k) {\n\t\t// å…ˆè·å–é¢‘æ•°\n\t\tstd::unordered_map<int, int> freq_dict1;\n\t\tfor (int & num : nums) {\n\t\t\tfreq_dict1[num] = freq_dict1[num] + 1;\n\t\t}\n\t\tk = k < freq_dict1.size()? k : freq_dict1.size();\n\t\t// æ„å»ºä¸€ä¸ªå°é¡¶å †\n\t\tstd::priority_queue<std::pair<int, int>> queue;\n\t\tfor (auto & x: freq_dict1) {\n\t\t\t// å°†é¢‘ç‡å–è´Ÿæ•°ï¼Œåå‘å…¥é˜Ÿ,é¢‘ç‡è¶Šä½ï¼Œè¶Šå¾€å‰é¢\n\t\t\tqueue.emplace(std::pair<int, int>(-x.second, x.first));\n\t\t\t// åªç•™kä¸ªå…ƒç´ å³å¯\n\t\t\tif (queue.size() > k) {\n\t\t\t\tqueue.pop();\n\t\t\t}\n\t\t}\n\t\t// æ”¶é›†æœ€ç»ˆç»“æœ\n\t\tstd::vector<int> res(k);\n\t\twhile(k) {\n\t\t\tres[--k] = queue.top().second;\n\t\t\tqueue.pop();\n\t\t}\n\t\treturn std::move(res);\n  }\n};\n```\n\n### å¤æ‚åº¦åˆ†æ\n- ç”±äºpriority_queryçš„æ—¶é—´å¤æ‚åº¦ä¸ºLog(k) -> 1\n- æ‰€ä»¥æœ€ç»ˆæ—¶é—´å¤æ‚åº¦ä¸ºï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)\n\n\n### ç»“æœ\n![38864d5f0ffc22ce7ba15add92370820.png](https://s2.loli.net/2022/08/03/Qe8FKIfhYcinXDl.png)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204698562","body":"### é¢˜ç›®é“¾æ¥\n- [é“¾æ¥](https://leetcode.cn/problems/number-of-boomerangs):\n\n### ä»£ç \n```cpp\nclass Solution {\npublic:\n  int numberOfBoomerangs(vector<vector<int>>& points) {\n    // å…ˆæ±‚å‡ºæ‰€æœ‰ç‚¹åˆ°å…¶å®ƒç‚¹çš„è·ç¦»ï¼Œç„¶åè®¡ç®—è·ç¦»æ˜¯å¦ç›¸ç­‰ï¼Ÿè¿™æ ·çš„è¯ï¼Œæ—¶é—´å¤æ‚åº¦O(n^2)\n    // åˆ©ç”¨æ’åˆ—ç»„åˆç­›é€‰å‡ºæ‰€æœ‰ä¸‰å…ƒç»„ï¼Œç„¶åçœ‹æ˜¯å¦æ»¡è¶³æ¡ä»¶ï¼Ÿæ—¶é—´å¤æ‚åº¦ï¼šO(n^3)\n    // ä½†æ˜¯ï¼Œå¯èƒ½ä¼šå­˜åœ¨é‡å¤è®¡ç®—ï¼Ÿ\n    // ç»Ÿè®¡æ»¡è¶³æ¡ä»¶çš„æ’åˆ—ä¸ªæ•°\n    int sum = 0;\n    if (points.size() < 3) {\n      return 0;\n    }\n\n    std::unordered_map<int, int> dict1;\n    for (int x = 0; x < points.size(); ++x) {\n\t\t\t\tdict1.clear();\n      for (int y = 0; y < points.size(); ++y) {\n        if (x != y) {\n          ++dict1[distance(points[x], points[y])];\n        }\n      }\n      for (const auto & item: dict1) {\n          // æ±‚ä»valueä¸­é€‰å‡º2ä¸ªçš„æ‰€æœ‰æ’åˆ—\n          sum += (item.second * (item.second - 1));\n        }\n      }\n    }\n    return sum;\n  }\n\n  inline int distance(const std::vector<int> & p1, const std::vector<int> & p2) {\n    return (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);\n  }\n};\n```\n\n### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´ï¼š$O(n^2)$\n- ç©ºé—´ï¼š$O(log(n))$\n\n\n### ç»“æœ\n![7a1a89969f550fc25dc7520ce1ede96f.png](https://s2.loli.net/2022/08/04/HVbdJIhNk3RgewE.png)\n\n### ä¼˜åŒ–ä»¥åŠé¿å‘\n- æœ‰é‡å¤è®¡ç®—ï¼Œå¯ä»¥åŠ ä¸€ä¸ªå­—å…¸æ¥èŠ‚çœä¸€åŠçš„è®¡ç®—\n- è·ç¦»é‚£é‡Œä¸éœ€è¦sqrtæ±‚å¹³æ–¹æ ¹ï¼Œå› ä¸ºä¼šæœ‰è¯¯å·®ï¼Œå¯¼è‡´äº§ç”Ÿå¤šä½™ç»“æœã€‚","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205995786","body":"### é¢˜ç›®é“¾æ¥\n- [é“¾æ¥](https://leetcode.cn/problems/longest-substring-without-repeating-characters)\n\n### ä»£ç \n```cpp\n#include <iostream>\n#include <string>\n#include <unordered_map>\n\nusing std::string;\n\nclass Solution {\npublic:\n  int lengthOfLongestSubstring(const string & s) {\n\t\tif (s.size() < 2) {\n\t\t\treturn s.size();\n\t\t}\n    int i = 0, j = 1;\n\t\tstd::unordered_map<char, int> dict1;\n\t\tdict1.insert(std::pair<char, int>(s[0], 1));\n\t\tint res = 0;\n    while (j < s.size()) {\n      while (dict1.count(s[j]) && dict1.at(s[j])) {\n        --dict1[s[i]];\n        ++i;\n      }\n      ++dict1[s[j]];\n      res = res > (j + 1 - i) ? res : (j + 1 - i);\n      ++j;\n    }\n    return res;\n  }\n};\n\n\nint main() {\n\tstd::string s = \"pwwkew\";\n\t// std::string s = \"abcabcbb\";\n\t// std::string s = \"bbbbbb\";\n\t// std::string s = \"dvdf\";\n\t// std::string s = \"abcabcbb\";\n\n\t// std::string s = \"tmmzuxt\";\n\t// std::string s = \"aabaab!bb\";\n\tSolution sou;\n\tstd::cout << sou.lengthOfLongestSubstring(s) << std::endl;\n}\n```\n\n\n### å¤æ‚åº¦\n- æ—¶é—´ï¼šO(n^2)\n- ç©ºé—´ï¼šO(log(n))\n\n### æˆæœ\n![63821b1a8a7603f42f24582b40d20fe2.png](https://s2.loli.net/2022/08/05/zemCF92aPiOpfxY.png)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207170860","body":"### é¢˜ç›®é“¾æ¥\n- [é“¾æ¥](https://leetcode.cn/problems/substring-with-concatenation-of-all-words)\n\n\n### é¢˜ç›®æ€è·¯\n- å°†wordsåšæˆå­—å…¸ï¼Œç„¶åå¯¹å­—ç¬¦ä¸²sè¿›è¡Œåˆ†è¯ã€‚\n- æ ¹æ®åˆ†è¯ç»“æœæ¥åˆ¤æ–­æ˜¯å¦æ»¡è¶³è¦æ±‚\n- åˆ†è¯æ—¶éœ€è¦åˆ¤æ–­é•¿åº¦æ˜¯å¦åˆé€‚ï¼Œå‡å°‘å¤šä½™è®¡ç®—\n- é‰´äºåˆ†è¯åwordé•¿åº¦åº”è¯¥å’Œå­—å…¸å…ƒç´ æ€»çš„ä¸ªæ•°ä¸€è‡´ï¼Œæ‰€ä»¥å¯ä»¥å…ˆç»Ÿè®¡ä¸€ä¸‹å…ƒç´ ä¸ªæ•°ã€‚\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n\n\nusing std::vector;\nusing std::string;\n\nclass Solution {\npublic:\n  vector<int> findSubstring(string s, vector<string>& words) {\n    if (s.size() == 0 || words.size() == 0 || s.size() < words.size()) {\n      return std::vector<int>{};\n    }\n    std::unordered_map<std::string, int> dict1;\n    int min_word_size = words[0].size();\n    int max_word_size = 0;;\n    for (const std::string & word : words) {\n      ++dict1[word];\n      min_word_size = min_word_size < word.size() ? min_word_size: word.size();\n      max_word_size = max_word_size > word.size() ? max_word_size: word.size();\n    }\n    // å°†sæŒ‰ç…§dict1çš„å†™æ³•è¿›è¡Œåˆ†è¯\n    // åˆ†è¯çš„è¯ï¼Œå¯èƒ½å‡ºç°åŒ…å«å…³ç³»ï¼Ÿå¦‚æœæ˜¯ï¼Œä¿é™©èµ·è§åº”è¯¥æŒ‰æœ€å¤§å­—ç¬¦ä¸²åŸåˆ™è¿›è¡Œåˆ†è¯\n    std::vector<std::vector<int>> seg_index;\n    for (int i = 0; i < s.size(); ++i) {\n      for (int j = i + max_word_size; j >= i + min_word_size; --j) {\n        if (dict1.count(s.substr(i, j - i)) > 0) {\n          seg_index.push_back({i, j});\n        }\n      }\n    }\n    if (seg_index.size() < words.size()) {\n      return std::vector<int> {};\n    }\n    // å¦‚æœæœ‰åŒ…å«å…³ç³»ï¼Œè¿˜éœ€è¦åŒé‡forå¾ªç¯æ¥å»é™¤ï¼Œè¿™é‡Œå…ˆæš‚æ—¶ä¸è€ƒè™‘\n    // ä¸‹ä¸€æ­¥ï¼Œåˆ©ç”¨é•¿çŸ­æŒ‡é’ˆï¼Œæ¥æ‰¾åˆ°æ˜¯å¦æœ‰åŒ…å«ç‰‡æ®µï¼Œç¡®ä¿ä¸¤ä¸ªdictå®Œå…¨ä¸€è‡´\n    int i = 0;\n    std::unordered_map<std::string, int> temp_dict;\n    std::vector<int> res;\n    int last_index = 0;\n    int last_count = 0;\n    for (int i = 0; i < seg_index.size(); ++i){\n      if (dict1.count(s.substr(seg_index[i][0], seg_index[i][1] - seg_index[i][0])) == 0) {\n        continue;\n      }\n      last_index = seg_index[i][1];\n      temp_dict.clear();\n      temp_dict[s.substr(seg_index[i][0], seg_index[i][1] - seg_index[i][0])] = 1;\n      last_count = 1;\n      for (int j = i + 1; j < seg_index.size(); ++j) {\n        if (last_count >= words.size()) {\n          break;\n        }\n        if (seg_index[j][0] ==  last_index) {\n          ++temp_dict[s.substr(seg_index[j][0], seg_index[j][1] - seg_index[j][0])];\n          ++last_count;\n          last_index = seg_index[j][1];\n        }\n      }\n\n      // åˆ¤æ–­temp_dictä¸dict1æ˜¯å¦å®Œå…¨ä¸€è‡´\n      if (temp_dict.size() == dict1.size() && last_count == words.size()) {\n        bool equal = true;\n        for(const auto x: dict1) {\n          if (temp_dict[x.first] != x.second) {\n            equal = false;\n          }\n        }\n        if (equal) {\n          res.push_back(seg_index[i][0]);\n        }\n      }\n    }\n    return std::move(res);\n  }\n};\n\n\nint main() {\n  std::string s = \"barfoofoobarthefoobarman\";\n  std::vector<std::string> words({\"bar\",\"foo\",\"the\"});\n  Solution so;\n  std::vector<int> res = so.findSubstring(s, words);\n  for (int i = 0; i < res.size(); ++i) {\n    std::cout << res[i] << \",\";\n  }\n  std::cout << std::endl;\n}\n```\n\n### å¤æ‚åº¦\n- æ—¶é—´ï¼šO(n^2)\n- ç©ºé—´ï¼šO(n)\n\n### ç»“æœ\n![ef460f5b1e95fdaa32ba0d5ad98ae7fa.png](https://s2.loli.net/2022/08/06/7TODLS1Wvtr4CAP.png)\n\n\n### ä¼˜åŒ–æ€è·¯\n- é‡æ–°çœ‹äº†ä¸€ä¸‹é¢˜ç›®ï¼ŒåŸæ¥wordé•¿åº¦æ˜¯å›ºå®šçš„ï¼Œè¿™æ ·çš„è¯ï¼Œå…¶å®ç¬¬ä¸€æ­¥çš„åˆ†è¯å°±æ˜¯å¤šä½™çš„äº†ã€‚æ¯•ç«Ÿé•¿åº¦éƒ½å›ºå®šçš„ã€‚\n\n### ä»£ç ï¼Œä¼˜åŒ–å\n```cpp\nclass Solution {\npublic:\n  vector<int> findSubstring(const string & s, vector<string>& words) {\n    int word_size = words[0].size();\n    int word_num = words.size();\n    if (s.size() == 0 || words.size() == 0 || s.size() < word_size * word_num) {\n      return std::vector<int>{};\n    }\n    std::unordered_map<std::string, int> dict1;\n    for (const std::string & word : words) {\n      ++dict1[word];\n    }\n    std::unordered_map<std::string, int> temp_dict;\n    std::vector<int> res;\n    int last_index = 0;\n    int last_count = 0;\n    int n = s.size() - word_num * word_size;\n    for (int i = 0; i <= n; ++i) {\n      temp_dict.clear();\n      for (int j = i; j < i + word_size * word_num; j += word_size) {\n        // åŠ ä¸€ä¸ªæå‰é€€å‡º\n        if (dict1.count(s.substr(j, word_size)) == 0) {\n          break;\n        }\n        ++temp_dict[s.substr(j, word_size)];\n      }\n      // åˆ¤æ–­temp_dictä¸dict1æ˜¯å¦ä¸€è‡´\n      if (temp_dict.size() == dict1.size()) {\n        bool compare_res = true;\n        for (const auto x: dict1) {\n          if (temp_dict[x.first] != x.second) {\n            compare_res = false;\n            break;\n          }\n        }\n        if (compare_res) {\n          res.push_back(i);\n        }\n      }\n    }\n    return std::move(res);\n  }\n};\n```\n\n### ä¼˜åŒ–åç»“æœ\n![cfd6a4f0041520cd84becbd6078509d0.png](https://s2.loli.net/2022/08/06/Kcrx4J8M5AlEUNG.png)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207334902","body":"### é¢˜ç›®é“¾æ¥\r\n- [é“¾æ¥](https://binarysearch.com/problems/Delete-Sublist-to-Make-Sum-Divisible-By-K)\r\n\r\n\r\n### ä»£ç ï¼ˆç¬¬ä¸€ç‰ˆï¼‰\r\n```cpp\r\nint solve(vector<int>& nums, int k) {\r\n  // å­åˆ—è¡¨ï¼Œåˆ©ç”¨å‰ç¼€å’Œ(f(x)) , æ±‚å‡ºf(j)-f(i)çš„å‰ç¼€å’Œï¼Œä¸”sumå‡å»è¯¥å‰ç¼€å’Œä¸ºkçš„æ•´æ•°\r\n  // å³(sum - (f(j) - f(i)))  % k = 0\r\n  // å…ˆç”¨æœ€ç®€å•çš„äºŒé‡å¾ªç¯è¯•è¯•\r\n  int sum = 0;\r\n  std::vector<int> cum_sums(nums.size() + 1);\r\n\r\n  // std::unordered_map<int, int> dict1;\r\n  for (int i = 0; i < nums.size(); ++i) {\r\n    cum_sums[i] = sum;\r\n    sum += nums[i];\r\n  }\r\n  cum_sums[nums.size()] = sum;\r\n  int res = nums.size();\r\n  for (int i = 0; i <= nums.size(); ++i) {\r\n    for (int j = i; j <= nums.size(); ++j) {\r\n      if ((sum - cum_sums[j] + cum_sums[i]) % k == 0) {\r\n        res = res < (j - i) ? res : (j - i);\r\n      }\r\n    }\r\n  }\r\n  if (res == nums.size() && sum % k != 0) {\r\n    res = -1;\r\n  }\r\n  return res;\r\n}\r\n```\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n^2)ï¼Œä½†æ˜¯å‘¢ï¼Œè¶…æ—¶äº†ã€‚æ‰€ä»¥è¦ä¼˜åŒ–ä¸€ä¸‹ï¼ŒåŠ ä¸ªå“ˆå¸Œè¡¨ï¼Œè®©ä»–å˜æˆO(n)\r\n\r\n\r\n### ä»£ç V2\r\n```cpp\r\n\r\nint solve(vector<int>& nums, int k) {\r\n  // å­åˆ—è¡¨ï¼Œåˆ©ç”¨å‰ç¼€å’Œ(f(x)) , æ±‚å‡ºf(j)-f(i)çš„å‰ç¼€å’Œï¼Œä¸”sumå‡å»è¯¥å‰ç¼€å’Œä¸ºkçš„æ•´æ•°\r\n  // æ³¨æ„j > i\r\n  // å³(sum - (f(j) - f(i)))  % k = 0\r\n  // å³(sum - f(j)) % k = (-f(i)) %k\r\n\r\n  // å…ˆæ±‚ä¸€ä¸‹sumå€¼\r\n  int sum = 0;\r\n  int temp_sum = 0;\r\n  for (const int & num: nums) {\r\n    sum += num;\r\n  }\r\n  // æå‰é€€å‡ºæ¡ä»¶\r\n  if (sum % k == 0) {\r\n    return 0;\r\n  }\r\n\r\n  // å‚¨å­˜f(i) % kä»¥åŠå¯¹åº”çš„ç›¸å…³ç´¢å¼•\r\n  std::unordered_map<int, int> dict1;\r\n  int res = nums.size();\r\n  int temp_index = 0;\r\n  int temp;\r\n  int max_n = ((sum / k) + 1) * k;\r\n  for (int i = 0; i < nums.size(); ++i){\r\n    temp_sum += nums[i];\r\n    temp = (sum - temp_sum) % k;\r\n    // å‡ºç°tempä¸º0ï¼Œåˆ™è¯´æ˜å‰(i+1)ä¸ªå€¼éƒ½å¯ä»¥åºŸå¼ƒæ‰äº†ã€‚\r\n    if (temp == 0) {\r\n      res = res < (i + 1) ? res : (i + 1);\r\n    }\r\n    if (dict1.count(temp)) {\r\n      // æ±‚æœ€çŸ­ç´¢å¼•ï¼Œåˆ™å–ç´¢å¼•çš„æœ€åä¸€ä¸ªå€¼å³å¯\r\n      temp_index = dict1.at(temp);\r\n      res = res < (i - temp_index) ? res : (i - temp_index);\r\n    }\r\n    dict1[(max_n-temp_sum) % k] = i;\r\n  }\r\n  if (res == nums.size()) {\r\n    if (sum % k == 0) {\r\n      res = 0;\r\n    } else {\r\n      res = -1;\r\n    }\r\n  }\r\n  return res;\r\n}\r\n```\r\n\r\n### å¤æ‚åº¦\r\n- æ—¶é—´ï¼šO(n)\r\n- ç©ºé—´ï¼šO(n)\r\n\r\n### ç»“æœ\r\n![æˆªå›¾ 2022-08-07 13-35-49](https://user-images.githubusercontent.com/28218658/183277026-c3693e54-99fc-4d98-acf6-9c70be253946.png)\r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207583654","body":"### é¢˜ç›®é“¾æ¥\n- [é“¾æ¥](https://leetcode.cn/problems/middle-of-the-linked-list)\n\n### ä»£ç \n```cpp\n#include <iostream>\n\n/**\n * Definition for singly-linked list.\n */\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nclass Solution {\npublic:\n  ListNode* middleNode(ListNode* head) {\n    if (head) {\n      ListNode * slow = head, * fast = head;\n      while(fast && fast->next) {\n        fast = fast->next->next;\n        slow = slow->next;\n      }\n      return slow;\n    } else {\n      return nullptr;\n    }\n  }\n};\n```\n\n### å¤æ‚åº¦\n- æ—¶é—´ï¼šO(n)\n- ç©ºé—´ï¼šO(1)\n\n### ç»“æœ\n![68052a2bdf9a41b32055f72b730b0f03.png](https://s2.loli.net/2022/08/08/YnCo4MzW9Re7gBG.png)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208829387","body":"### é¢˜ç›®é“¾æ¥\n- [é“¾æ¥](https://leetcode.cn/problems/remove-duplicates-from-sorted-array)\n\n\n### ä»£ç \n```cpp\n#include <vector>\n\nusing std::vector;\n\nclass Solution {\npublic:\n  int removeDuplicates(vector<int>& nums) {\n    if (!nums.size()) {\n      return 0;\n    }\n    // i çºªå½•éé‡å¤å€¼ï¼Œ jè®°å½•æœ€æ–°å€¼\n    int i = 0, j = 1;\n    while(j < nums.size()) {\n      if (nums[i] != nums[j]) {\n        nums[++i] = nums[j];\n      }\n      ++j;\n    }\n    return i + 1; \n  }\n};\n```\n\n### å¤æ‚åº¦\n- æ—¶é—´ï¼šO(n)\n- ç©ºé—´ï¼šO(1)\n\n\n### ç»“æœ\n![5ff43a074f13bb8b9a11dab4bdcbc9ad.png](https://s2.loli.net/2022/08/09/CUFkyHSvBO6Ihxq.png)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richypang":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185158822","body":"## ä»£ç ï¼ˆæ³¨é‡Šè§£æäº†æ¯ä¸€æ­¥çš„æ€è·¯ï¼‰\n\nclass Solution:\n\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        #å°†æ•°ç»„è½¬åŒ–ä¸ºstrå½¢å¼å­˜å‚¨\n        temp = \" \"\n        for i in num:\n            temp = temp + str(i)\n        #æ•´æ•°ç›¸åŠ \n        number = int(temp) + k\n        result = []\n        for j in str(number):\n            result.append(int(j))\n        return result\n## å¤æ‚åº¦ \n\næ—¶é—´å¤æ‚åº¦ O(n)\nç©ºé—´å¤æ‚åº¦O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186111174","body":"## æ€è·¯\n\n>1.å…ˆè¯•ç”¨ä¸€æ¬¡å¾ªç¯è®°å½•ä¸‹æ‰€æœ‰cå‡ºç°çš„ä½ç½®å¹¶è®°å½•åœ¨have_cä¸­\n\n>2.å†æ¬¡å¾ªç¯æ¯ä¸€ä¸ªå­—æ¯ï¼Œåˆ©ç”¨å…¶æ‰€åœ¨çš„indexåˆ†åˆ«ä¸have_cç›¸å‡è·å–å…¶ç»å¯¹å€¼å¹¶è®°å½•æœ€å°å€¼\nå°†æœ€å°å€¼è®°å½•åœ¨resultä¸­è¾“å‡º\n\n##ä»£ç \n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        have_c = []\n        for i in range(len(s)):\n            if s[i] == c:\n                have_c.append(i)\n        print(have_c)\n        result = []\n        for i in range(len(s)):\n            if s[i] == c:\n                result.append(0)\n            else:\n                min = 99999999999\n                for j in range(len(have_c)):\n                    if min > abs(have_c[j] - i):\n                        min = abs(have_c[j] - i)\n                result.append(min)\n        return result\n\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: O(n^2)\n> + ç©ºé—´å¤æ‚åº¦: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186411631","body":"## æ€è·¯\r\n\r\n> æ³¨æ„pushæ—¶ä¸è¶…è¿‡æœ€å¤§maxsizeï¼Œpopæ—¶stackä»æœ‰æ•°å­—\r\n\r\n##ä»£ç \r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.max_len = maxSize\r\n        self.current_len = 0\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.max_len:\r\n            self.stack.append(x)\r\n            self.current_len += 1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) == 0: return -1\r\n        else:\r\n            self.current_len -= 1\r\n            return self.stack.pop()\r\n\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        less = min(k,len(self.stack))\r\n        for i in range(0,less):\r\n            self.stack[i] += val\r\n\r\n\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n> + æ—¶é—´å¤æ‚åº¦: pop push ä¸ºO(1) increment ä¸ºO(n)\r\n> + ç©ºé—´å¤æ‚åº¦: O(maxsize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186624023","body":"## æ€è·¯\n\n> åˆ¤æ–­é‡åˆ°çš„æ˜¯å­—ç¬¦ä¸²è¿˜æ˜¯æ•°å­—è¿˜æ˜¯æ‹¬å·ï¼Œåˆ†åˆ«ä½œä¸åŒå¤„ç†\n\n##ä»£ç \n\n```python\n#\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack, res, times = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append([times, res])\n                res, times = \"\", 0\n            elif c == ']':\n                cur_times, last_res = stack.pop()\n                res = last_res + cur_times * res\n            elif '0' <= c <= '9':\n                #åˆ¤æ–­å¤šä½æ•°å­—æƒ…å†µ\n                times =  times * 10 + int(c)            \n            else:\n                res += c\n        return res\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: O(N)\n> + ç©ºé—´å¤æ‚åº¦: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188417974","body":"## æ€è·¯\n\n> ä½¿ç”¨ä¸¤ä¸ªstackæ¥å®ç°é˜Ÿåˆ—éœ€æ±‚\n\n##ä»£ç \n\n```python\n#\nclass MyQueue:\n\n    def __init__(self):\n        #å»ºç«‹inputï¼Œoutputä¸¤ä¸ªstack\n        self.input = []\n        self.output = []\n\n\n    def push(self, x: int) -> None:\n        #å°†æ–°å…ƒç´ æ”¾è¿›input stackä¸­\n        self.input.append(x)\n\n\n    def pop(self) -> int:\n        #åˆ¤æ–­æ˜¯å¦ä¸ºç©º\n        if self.empty():\n            return None\n        if self.output:\n            return self.output.pop()\n        else:\n            #è‹¥ä¸ä¸ºç©ºï¼Œåˆ™å°†inputä¸­çš„popåˆ°outputä¸­\n            while self.input:\n                val = self.input.pop()\n                self.output.append(val)\n            #pop outputçš„å…ƒç´ \n            return self.output.pop()\n\n\n\n    def peek(self) -> int:\n        res = self.pop()\n        self.output.append(res)\n\n        return res\n\n\n\n    def empty(self) -> bool:\n        #å½“ä¸¤ä¸ªstackéƒ½ä¸ºç©ºæ—¶ï¼Œæ‰return true\n        if not (self.output or self.input):\n            return True \n        else:\n            return False\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: O(n)\n> + ç©ºé—´å¤æ‚åº¦: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189631616","body":"## å€Ÿé‰´å®˜æ–¹é¢˜è§£æ€è·¯\n\n> + æ€è·¯æè¿°\n\n##ä»£ç \n\n```python\n#\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        dict_a = collections.defaultdict(int)\n        dict_b = collections.defaultdict(int)\n        max_ans = 0\n        for i,j in zip(arr,sorted(arr)):\n            dict_a[i] += 1\n            dict_b[j] += 1\n            if dict_a == dict_b: max_ans+= 1\n        return max_ans\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: O(N)\n> + ç©ºé—´å¤æ‚åº¦: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190849726","body":"## æ€è·¯\n\n> ä½¿ç”¨å¿«æŒ‡é’ˆæŒ‡å‘æ–°èŠ‚ç‚¹çš„ç¬¬ä¸€ä½ï¼Œæ…¢æŒ‡é’ˆè·å–æ–°èŠ‚ç‚¹çš„æœ€åä¸€ä½ï¼Œåœ¨å¯¹é“¾è¡¨è¿›è¡Œæ‹¼æ¥æ“ä½œ\n\n##ä»£ç \n\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        #åˆå§‹ä¸´ç•Œæ¡ä»¶\n        if (not head or not head.next): return head\n        total = 0\n        cur = head\n        #è·å–æ•´ä¸ªé“¾è¡¨çš„é•¿åº¦\n        while cur:\n            cur = cur.next\n            total += 1\n        #å–ä½™æ•°é¿å…é‡å¤å¾ªç¯\n        k = k % total\n        #åˆ›å»ºå¿«æ…¢æŒ‡é’ˆ\n        slow = head\n        fast = head\n        while fast.next:\n            if (k <= 0):\n                slow = slow.next\n            k = k -1 \n            fast = fast.next\n        #å¿«æŒ‡é’ˆçš„ä½ç½®å³ä¸ºæ–°é“¾è¡¨çš„å¤´èŠ‚ç‚¹\n        fast.next = head\n        result = slow.next\n        slow.next = None\n        return result\n\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: O(N)\n> + ç©ºé—´å¤æ‚åº¦:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192012081","body":"## æ€è·¯\n\n> å‚è€ƒé¢˜è§£ä½¿ç”¨ä¸¤ä¸ªèŠ‚ç‚¹a,bä»¥åŠaçš„å‰èŠ‚ç‚¹å’Œbçš„åèŠ‚ç‚¹è¿›è¡Œä½ç½®äº¤æ¢æ“ä½œ\n\n##ä»£ç \n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        result = ListNode()\n        result.next = head.next\n        pre = result\n        while head and head.next:\n            second = head.next\n            second_next = second.next\n            second.next = head\n            pre.next = second\n            head.next = second_next\n\n            pre = head\n            head = second_next\n        return result.next\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: O(N)\n> + ç©ºé—´å¤æ‚åº¦:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193043083","body":"##ä»£ç \r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        #å½“å¤´èŠ‚ç‚¹ä¸ºç©ºæ—¶\r\n        if not head:\r\n            return None\r\n        if not head.next:\r\n            return TreeNode(head.val)\r\n        slow = head\r\n        fast = head\r\n        #è®¾å®šå·¦åŒºé—´è¾¹ç•Œ\r\n        pre = head\r\n        #éå†slowåˆ°é“¾è¡¨çš„ä¸­ç‚¹\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            pre = slow\r\n            slow = slow.next\r\n        pre.next = None\r\n        root = TreeNode(slow.val)\r\n        \r\n        root.left = self.sortedListToBST(head)\r\n        root.right = self.sortedListToBST(slow.next)\r\n        return root\r\n\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n> + æ—¶é—´å¤æ‚åº¦: O(n)\r\n> + ç©ºé—´å¤æ‚åº¦: O(log(n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193241954","body":"## æ€è·¯\n\n> å…ˆæ˜¯ç”¨å“ˆå¸Œè¡¨å­˜å‚¨headaä¸­çš„æ‰€æœ‰å€¼ï¼Œéå†headbæŸ¥æ‰¾æ˜¯å¦æœ‰ç›¸åŒçš„å€¼å­˜åœ¨å†å“ˆå¸Œè¡¨ä¸­\n\n##ä»£ç \n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        temp = set()\n        cura,curb = headA,headB \n        while cura:\n            temp.add(cura)\n            cura = cura.next\n        #print(temp)\n        while curb:\n            if curb in temp:\n                return curb\n            curb = curb.next\n        return None\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: O(N)\n> + ç©ºé—´å¤æ‚åº¦: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193410569","body":"## æ€è·¯\n\n> + ä½¿ç”¨åŒæŒ‡é’ˆè®¡ç®—ï¼Œä¸¤ä¸ªæŒ‡é’ˆç¬¬äºŒæ¬¡ç›¸é‡çš„ä½ç½®\n\n##ä»£ç \n\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow,fast = head,head\n        x = None\n        #ç¬¬ä¸€æ¬¡ç›¸é‡\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                x = fast\n                break\n            #å¦‚æœä»æœªç©ºåˆ™è¯´æ˜headä¸ºç©ºreturn None\n        if not x:\n            return None\n        #è®°å½•ç¬¬äºŒæ¬¡ç›¸é‡ä½ç½®\n        slow = head\n        while slow != x:\n            slow = slow.next\n            x = x.next\n        return slow\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: O(N)\n> + ç©ºé—´å¤æ‚åº¦: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194746623","body":"## æ€è·¯\n\nåŒæŒ‡é’ˆ+å“ˆå¸Œè¡¨\n\n##ä»£ç \n\n```python\nclass ListNode:\n    def __init__(self, key=None, value=None):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.hashmap = {}\n        # æ–°å»ºä¸¤ä¸ªèŠ‚ç‚¹ head å’Œ tail\n        self.head = ListNode()\n        self.tail = ListNode()\n        # åˆå§‹åŒ–é“¾è¡¨ä¸º head <-> tail\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    # å› ä¸ºgetä¸putæ“ä½œéƒ½å¯èƒ½éœ€è¦å°†åŒå‘é“¾è¡¨ä¸­çš„æŸä¸ªèŠ‚ç‚¹ç§»åˆ°æœ«å°¾ï¼Œæ‰€ä»¥å®šä¹‰ä¸€ä¸ªæ–¹æ³•\n    def move_node_to_tail(self, key):\n            node = self.hashmap[key]\n            node.prev.next = node.next\n            node.next.prev = node.prev\n            node.prev = self.tail.prev\n            node.next = self.tail\n            self.tail.prev.next = node\n            self.tail.prev = node\n\n    def get(self, key: int) -> int:\n        if key in self.hashmap:\n            # å¦‚æœå·²ç»åœ¨é“¾è¡¨ä¸­äº†ä¹…æŠŠå®ƒç§»åˆ°æœ«å°¾ï¼ˆå˜æˆæœ€æ–°è®¿é—®çš„ï¼‰\n            self.move_node_to_tail(key)\n        res = self.hashmap.get(key, -1)\n        if res == -1:\n            return res\n        else:\n            return res.value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.hashmap:\n            # å¦‚æœkeyæœ¬èº«å·²ç»åœ¨å“ˆå¸Œè¡¨ä¸­äº†å°±ä¸éœ€è¦åœ¨é“¾è¡¨ä¸­åŠ å…¥æ–°çš„èŠ‚ç‚¹\n            # ä½†æ˜¯éœ€è¦æ›´æ–°å­—å…¸è¯¥å€¼å¯¹åº”èŠ‚ç‚¹çš„value\n            self.hashmap[key].value = value\n            # ä¹‹åå°†è¯¥èŠ‚ç‚¹ç§»åˆ°æœ«å°¾\n            self.move_node_to_tail(key)\n        else:\n            if len(self.hashmap) == self.capacity:\n                # å»æ‰å“ˆå¸Œè¡¨å¯¹åº”é¡¹\n                self.hashmap.pop(self.head.next.key)\n                # å»æ‰æœ€ä¹…æ²¡æœ‰è¢«è®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼Œå³å¤´èŠ‚ç‚¹ä¹‹åçš„èŠ‚ç‚¹\n                self.head.next = self.head.next.next\n                self.head.next.prev = self.head\n            # å¦‚æœä¸åœ¨çš„è¯å°±æ’å…¥åˆ°å°¾èŠ‚ç‚¹å‰\n            new = ListNode(key, value)\n            self.hashmap[key] = new\n            new.prev = self.tail.prev\n            new.next = self.tail\n            self.tail.prev.next = new\n            self.tail.prev = new\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: O(n)\n> + ç©ºé—´å¤æ‚åº¦: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196102751","body":"## æ€è·¯\n\n> + é€’å½’éå†\n##ä»£ç \n\n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n        return 1+ max(self.maxDepth(root.left),self.maxDepth(root.right))\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: O(N)\n> + ç©ºé—´å¤æ‚åº¦:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197487272","body":"## æ€è·¯\n\n> + å‘ç‚¹ï¼šåœ¨ï¼š\n[1,2]\n[1,null,2]\næµ‹è¯•æ ·ä¾‹ä¸­å¿…é¡»ç»“åˆé€’å½’å·¦å³æ ‘æ‰å¯ä»¥åˆ¤æ–­ä¸ºfalse\n##ä»£ç \n\n```python\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not q and not p:\n            return True\n        if not q or not p:\n            return False\n        return q.val == p.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: O(max(p,q))\n> + ç©ºé—´å¤æ‚åº¦: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198731651","body":"## æ€è·¯\n\n>BFS\n\n##ä»£ç \n\n```python\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        def combine(num1,num2):\n            return num1*10+num2\n\n        res = 0\n        q = deque()\n        q.append((root,0))\n        while q:\n            node,val = q.popleft()\n            if node.left:\n                q.append((node.left,combine(val,node.val)))\n            if node.right:\n                q.append((node.right,combine(val,node.val)))\n            if not node.left and not node.right:\n                res += combine(val,node.val)\n        return res\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: O(N)\n> + ç©ºé—´å¤æ‚åº¦: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200089597","body":"\n##ä»£ç \n\n```python\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        ans, h = 0, 0\n\n        def dfs(root, height):\n            if root:\n                nonlocal ans, h\n                if height > h:\n                    ans, h = root.val, height\n                if root.left: dfs(root.left, height + 1)\n                if root.right: dfs(root.right, height + 1)\n        \n        dfs(root, 1)\n        return ans\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: O(n)\n> + ç©ºé—´å¤æ‚åº¦:O(log(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200367629","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°\ndfs\n\n```python\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        def preorder(root):\n            if not root: return \"null,\"\n            return str(root.val) + \",\" + preorder(root.left) + preorder(root.right)\n        return preorder(root)[:-1]\n        \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        node = data.split(\",\")\n        def preorder(count):\n            if count >= len(node) or node[count] == \"null\": return count,None\n            root = TreeNode(node[count])\n            j,root.left = preorder(count+1)\n            k,root.right = preorder(j+1)\n            return k,root\n        return preorder(0)[1]        \n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: O(n)\n> + ç©ºé—´å¤æ‚åº¦: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200528875","body":"## æ€è·¯\n\nå‚è€ƒå®˜æ–¹é¢˜è§£\n\n##ä»£ç \n\n```python\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        seen = collections.defaultdict(lambda:collections.defaultdict(list))\n        def dfs(root,x=0,y=0):\n            if not root:\n                return\n            seen[x][y].append(root.val)\n            dfs(root.left,x-1,y+1)\n            dfs(root.right,x+1,y+1)\n        dfs(root)\n        ans = []\n        for x in sorted(seen):\n            level = []\n            for y in sorted(seen[x]):\n                level += sorted(v for v in seen[x][y])\n            ans.append(level)\n        return ans\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: O(n^2)\n> + ç©ºé—´å¤æ‚åº¦:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201848593","body":"\n##ä»£ç \n\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        hashtable = {}\n        for i in range(len(nums)):\n            if nums[i] in hashtable:\n                return [hashtable[nums[i]],i]\n            else:\n                hashtable[target-nums[i]] = i\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: O(n)\n> + ç©ºé—´å¤æ‚åº¦:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203342792","body":"## æ€è·¯\n\nè°ƒåº“ä¾ \n\n##ä»£ç \n\n```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        count = collections.Counter(nums)\n        #print(count)\n        return [item[0] for item in count.most_common(k)]\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: O(nlogn)\n> + ç©ºé—´å¤æ‚åº¦: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204614420","body":"##ä»£ç \n\n```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        def get_eud(i,j):\n            return (i[0]-j[0]) * (i[0]-j[0]) + (i[1]-j[1])*(i[1]-j[1])\n        ans = 0\n        for m in points:\n            times = Counter()\n            for n in points:\n                times[get_eud(m,n)] += 1\n            for val in times.values():\n                ans += val*(val-1)\n        return ans\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: O(n^2)\n> + ç©ºé—´å¤æ‚åº¦:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205905786","body":"## æ€è·¯\n\n> + æ»‘åŠ¨çª—å£\n\n##ä»£ç \n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        max_len, hashmap = 0, {}\n        start = 0\n        for end in range(len(s)):\n            hashmap[s[end]] = hashmap.get(s[end], 0) + 1\n            if len(hashmap) == end - start + 1:\n                max_len = max(max_len, end - start + 1)\n            while end - start + 1 > len(hashmap):\n                head = s[start]\n                hashmap[head] -= 1\n                if hashmap[head] == 0:\n                    del hashmap[head]\n                start += 1\n        return max_len\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: O(n)\n> + ç©ºé—´å¤æ‚åº¦:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207105773","body":"##ä»£ç \n\n```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        allWords = collections.Counter(words)\n        wordNum = len(words)\n        wordLen = len(words[0])\n        res = []\n        for i in range(len(s) - wordNum * wordLen + 1):\n            subWords = collections.defaultdict(int)\n            index = i\n            while index < i + wordNum * wordLen:\n                curWord = s[index: index + wordLen]\n                if curWord not in allWords or subWords[curWord] == allWords[curWord]:\n                    break\n                subWords[curWord] += 1\n                index += wordLen\n            if index == i + wordNum * wordLen:\n                res.append(i)\n        return res\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: O(m*n)\n> + ç©ºé—´å¤æ‚åº¦:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207380626","body":"\n##ä»£ç \n\n```python\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        s=sum(nums)%p\n        if s==0:\n            return 0\n        d={s:-1}\n        t=0\n        m=100001\n        for i,j in enumerate(nums):\n            t+=j\n            a=t%p\n            if a in d:\n                m=min(m,i-d[a])\n            d[(a+s)%p]=i\n        return m if m<len(nums) else -1\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: O(n)\n> + ç©ºé—´å¤æ‚åº¦:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207518403","body":"\n##ä»£ç \n\n```python\n\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        fast = slow = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        return slow\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: O(n)\n> + ç©ºé—´å¤æ‚åº¦:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208833802","body":"\n##ä»£ç \n\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        length = len(nums)\n        fast, slow = 1,1\n        while fast < length :\n            if nums[fast] != nums[fast-1]:\n                nums[slow] = nums[fast]\n                slow += 1\n            fast += 1\n        return slow\n\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: O(n)\n> + ç©ºé—´å¤æ‚åº¦:O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fenchuiyun":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185161504","body":"### æ€è·¯\r\nç›®æ ‡ï¼šå®ç°ä¸¤ä¸ªå¤§éè´Ÿæ•´æ•°ç›¸åŠ <br>\r\nèƒŒæ™¯ï¼šåƒæ•´å‹integerå’Œlongçš„æ•°æ®éƒ½æ˜¯æœ‰æ•°æ®èŒƒå›´çš„\r\n\r\n### ä»£ç \r\n```java\r\n    class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n                // å…ˆæŠŠkè½¬æ¢ä¸ºæ•°ç»„\r\n        char[] chars = String.valueOf(k).toCharArray();\r\n        int maxLength = Math.max(num.length,chars.length);\r\n        int minLength = Math.max(num.length,chars.length);\r\n        int tmp = 0;\r\n        int[] result = new int[maxLength + 1];\r\n        for (int offset = 0; offset < minLength; offset++) {\r\n            int numIdx = num.length - 1 - offset;\r\n            int charsIdx = chars.length -1 - offset;\r\n            if (numIdx>=0&&charsIdx>=0){\r\n                int sum = chars[charsIdx]-'0'+num[numIdx]+tmp;\r\n                tmp = sum/10;\r\n                int y = sum%10;\r\n                result[maxLength-offset] = y;\r\n            }else if (numIdx>=0){\r\n                int sum = num[numIdx]+tmp;\r\n                tmp = sum/10;\r\n                int y = sum%10;\r\n                result[maxLength-offset] = y;\r\n            }else {\r\n                int sum = chars[charsIdx]-'0'+tmp;\r\n                tmp = sum/10;\r\n                int y = sum%10;\r\n                result[maxLength-offset] = y;\r\n            }\r\n        }\r\n        if (tmp!=0){\r\n            result[0] = tmp;\r\n        }\r\n        if (result[0]==0){\r\n            return Arrays.stream(result).skip(1).boxed().collect(Collectors.toList());\r\n        }else {\r\n            return Arrays.stream(result).boxed().collect(Collectors.toList());\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186156714","body":"### æ€è·¯\n- æ–¹æ³•ä¸€ï¼šæš´åŠ›ç ´è§£ï¼Œå¯¹è±¡ä¸‹æ ‡ä¸ºiçš„å…ƒç´ ï¼Œä»æ•°ç»„numsä¸­æŸ¥æ‰¾ç¦»ä¸‹æ ‡iæœ€è¿‘ä¸”å€¼ä¸ºtargetçš„ä¸‹æ ‡ã€‚ \n- æ–¹æ³•äºŒï¼šä¸¤æ¬¡éå†ï¼ˆä»Šæ—¥å­¦ä¹ åˆ°çš„ï¼‰ï¼Œä¸€æ¬¡ä»å·¦åˆ°å³çš„ä¾¿åˆ©ï¼Œå¯¹äºä¸‹æ ‡ä¸ºiçš„æ•°æ®ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°å·¦è¾¹ç¦»å®ƒæœ€è¿‘çš„ä½ç½®ï¼Œé€šè¿‡ä¸¤æ¬¡éå†å¯ä»¥è§£å†³é—®é¢˜ã€‚\n\n```java\n//æ–¹æ³•ä¸€\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        // æ–¹æ³•ä¸€: æš´åŠ›ç®—æ³•\n        // é’ˆå¯¹iä¸‹æ ‡çš„æ•°æ®ï¼Œåœ¨æ•°ç»„ä¸­æŸ¥è¯¢æœ€è¿‘çš„ä¸€ä¸ª\n        char[] chars = s.toCharArray();\n        int[] result = new int[chars.length];\n        for (int i = 0; i < chars.length; i++) {\n            int offset = s.length();\n            result[i] = getLocalOffset(chars,c,i);\n        }\n        return result;\n    }\n\n    private  int getLocalOffset(char[] array, char target, int idx) {\n        char value = array[idx];\n        if (value==target){\n            return 0;\n        }\n        int tmp = 100000;\n        for (int i = 0; i < array.length; i++) {\n            if (array[i]==target&&Math.abs(i-idx)<tmp) {\n                tmp = Math.abs(i-idx);\n            }\n        }\n        return tmp;\n    }\n}\n```\n### å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦O(n^2)<br>\nç©ºé—´å¤æ‚åº¦O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186515973","body":"### æ€è·¯\næ ˆçš„ç‰¹ç‚¹ï¼Œå…ˆè¿›å…ˆå‡ºï¼Œåˆ©ç”¨æ•°ç»„æ¥å®ç°ï¼Œä¸‹æ ‡pushIdxæ°¸è¿œæŒ‡å‘ä¸‹ä¸€ä¸ªå…ƒç´ çš„ä½ç½®ï¼Œåˆ™popçš„ä½ç½®ä¸ºpushIdx-1\n### ä»£ç \n```java\nclass CustomStack {\n\n    Integer[] values;\n    int pushIdx = 0;\n\n    public CustomStack(int maxSize) {\n        this.values = new Integer[maxSize];\n    }\n    \n    public void push(int x) {\n        if(pushIdx >= values.length){\n            return;\n        }else{\n            values[pushIdx]=x;\n            pushIdx ++;\n        }\n    }\n    \n    public int pop() {\n        if(pushIdx-1>=0){\n            return values[(pushIdx--)-1];\n        }else{\n            return -1;\n        }\n    }\n    \n    public void increment(int k, int val) {\n        int i = 0;\n        while(i<pushIdx&&i<k){\n            values[i]=values[i]+val;\n            i++;\n        }\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186857952","body":"### æ€è·¯\næŠŠç»è¿‡ç¼–ç çš„å­—ç¬¦ä¸²ï¼Œè¿˜åŸæˆè§£ç åçš„å­—ç¬¦ä¸²\néœ€è¦è§£æåŒ¹é…å£å·ï¼Œå¦‚[]ï¼Œå¯ä»¥åˆ©ç”¨æ ˆ\n```java\nclass Solution {\n    public String decodeString(String s) {\n        //  æŠŠç»è¿‡ç¼–ç çš„å­—ç¬¦ä¸²ï¼Œè¿˜åŸæˆè§£ç åçš„å­—ç¬¦ä¸²   k[encoded_string]\n        // æˆ‘ä»¬éœ€è¦è§£æåŒ¹é…æ‹¬å·,å¦‚[] ï¼Œæƒ³åˆ°åˆ©ç”¨æ ˆ\n        char[] chars = s.toCharArray();\n        Stack<Character> stack = new Stack<>();\n        int idx = 0;\n        while (true){\n            if (idx>=chars.length){\n                break;\n            }\n            char val = chars[idx];\n            if (val==']'){\n                String blabla = getString(stack);\n                for (char c : blabla.toCharArray()) {\n                    stack.push(c);\n                }\n            }else{\n                stack.push(val);\n            }\n            idx++;\n        }\n        String reversedResult = \"\";\n        while (!stack.isEmpty()){\n            Character pop = stack.pop();\n            reversedResult += pop;\n        }\n\n        return new StringBuilder(reversedResult).reverse().toString();\n    }\n\n    private String getString(Stack<Character> stack) {\n        if (stack.isEmpty()){\n            return \"\";\n        }\n        String reversedVal = \"\";\n        while (true){\n            Character pop = stack.pop();\n            if (pop=='['){\n                break;\n            }else {\n                reversedVal += pop;\n            }\n        }\n        StringBuilder sb = new StringBuilder(reversedVal);\n        String value = sb.reverse().toString();\n        String reverseCount = \"\";\n        while (!stack.isEmpty()){\n            Character countNumb = stack.peek();\n            if (countNumb-'9'>0){\n                break;\n            }\n            reverseCount+=countNumb;\n            stack.pop();\n        }\n        Integer count = Integer.valueOf(new StringBuilder(reverseCount).reverse().toString());\n        String result = \"\";\n        for (Integer i = 0; i < count; i++) {\n            result+=value;\n        }\n        return result;\n    }\n}\n```\n### å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦ï¼šO(n) <br>\nç©ºé—´å¤æ‚åº¦: O(n)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189934192","body":"### æ€è·¯\næ­£å¦‚[2,1,3,4,4]åˆ†ç‰‡æˆ[2,1][3][4][4]\næˆ‘ä»¬å¯ä»¥è§‚å¯Ÿå‘ç°**å‰é¢çš„åˆ†æ®µ**ä¸­çš„æœ€å°å€¼å°äº**åé¢çš„åˆ†æ®µ**<br>\næˆ‘ä»¬ç”¨chunk[]æ•°ç»„æ¥ä»£è¡¨åˆ†ç‰‡çš„ç»“æœï¼Œfmax(chunk[x])ä»£è¡¨ä»¥chunk[x]åˆ†ç‰‡ä¸­çš„æœ€å¤§å€¼,fmin(chunk[x])ä»£è¡¨chunk[x]åˆ†ç‰‡ä¸­çš„æœ€å°å€¼<br>\nåˆ™å¯¹äºæ­£ç¡®çš„åˆ†æ®µæ•°ç»„æœ‰,å¯¹äº0<=i<jæ¥è¯´ï¼Œå§‹ç»ˆæœ‰**fmax(chunk[i])< fmin(chunk[j])**\n\nå¯¹äºæˆ‘ä»¬å¦‚ä½•åˆ†ç‰‡çš„æŒ‡å¯¼:\n- å¯¹äºä¸‹æ ‡ä¸ºiçš„å…ƒç´ ï¼ŒåŠ å…¥å½“å‰chunkï¼Œå¦‚æœfmax(chunk)<å¾…å¤„ç†æ•°æ®ä¸­æœ€å°çš„å€¼ï¼Œé‚£ä¹ˆè¿™ä¸ªchunkå°±å¯ä»¥åˆ†å‡ºæ¥äº†\n\n### ä»£ç \n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        // æˆ‘ä»¬ç”¨chunk[]æ•°ç»„æ¥ä»£è¡¨åˆ†ç‰‡çš„ç»“æœ\n        // fmax(chunk[x])ä»£è¡¨ä»¥chunk[x]åˆ†ç‰‡ä¸­çš„æœ€å¤§å€¼,fmin(chunk[x])ä»£è¡¨chunk[x]åˆ†ç‰‡ä¸­çš„æœ€å°å€¼\n        // åˆ™å¯¹äº0<=i<jæ¥è¯´ï¼Œå§‹ç»ˆæœ‰fmax(i)< fmin(chunk[j])\n        // è´ªå¿ƒï¼Œæ¯æ¬¡å°±å°è¯•å—æ•°é‡æœ€å°çš„åˆ†æ³•ï¼Œæœ€æ€»èƒ½å¾—åˆ°æ­£ç¡®çš„ç»“æœå—ï¼Ÿ\n        // iä»£è¡¨å¾…å¤„ç†çš„æ•°æ®å¼€å¤´ä¸‹æ ‡,ç”¨maxä»£è¡¨ä¸Šä¸€ä¸ªchunkçš„æœ€å¤§å€¼\n        // å¦‚ä½•åˆ†ç‰‡ï¼Œå¯¹ä¸max < å¾…å¤„ç†æ•°æ®çš„æœ€å°å€¼ï¼Œå³å¯åˆ†ç‰‡\n        // flagæ¥è¡¨ç¤ºæ˜¯å¦åˆ†è¿‡ç‰‡\n\n        // è·å¾—ä»¥ä¸‹æ ‡idx+1ä¸ºå¤´çš„æœ€å°æ•°æ®\n        int[] min = new int[arr.length];\n        int idx = arr.length-2;\n        int tmp = arr[arr.length-1];\n        while (idx>=0){\n            int val = arr[idx];\n            min[idx]=tmp;\n            if (val<tmp){\n                tmp = val;\n            }\n            idx--;\n        }\n        // å½“å‰å‡ ä¸ªåˆ†ç‰‡\n        int result = 0;\n        int max = -1;\n        boolean isChuned = false;\n        for (int i = 0; i < arr.length-1; i++) {\n            int val = arr[i];\n            if (max<val){\n                max = val;\n            }\n            // åˆ¤æ–­å½“å‰æ•°æ®æ˜¯å¦å¯ä»¥åˆ†ç‰‡\n            if (max<=min[i]){\n                result++;\n                isChuned = true;\n            }else {\n                isChuned = false;\n            }\n        }\n        return result+1;\n\n    }\n}\n```\n### å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)  ","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195115022","body":"```Java\npublic class LRUCache {\n\n    class DLinkedNode{\n        int key;\n        int val;\n        DLinkedNode prev;\n        DLinkedNode next;\n        public DLinkedNode(){}\n\n        public DLinkedNode(int key, int val) {\n            this.key = key;\n            this.val = val;\n        }\n    }\n\n    private Map<Integer,DLinkedNode> cache = new HashMap<>();\n    private int size;\n    private int capacity;\n    private DLinkedNode head,tail;\n\n    public LRUCache(int capacity){\n        this.size = 0;\n        this.capacity = capacity;\n        // ä½¿ç”¨ä¼ªå¤´éƒ¨å’Œä¼ªå°¾éƒ¨èŠ‚ç‚¹\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key){\n        DLinkedNode node = cache.get(key);\n        if (node==null){\n            return -1;\n        }\n        // å¦‚æœ key å­˜åœ¨ï¼Œå…ˆé€šè¿‡å“ˆå¸Œè¡¨å®šä½ï¼Œå†ç§»åˆ°å¤´éƒ¨\n        moveToHead(node);\n        return node.val;\n    }\n\n    public void put(int key, int value){\n        DLinkedNode node = cache.get(key);\n        if (Objects.isNull(node)){\n            // å¦‚æœ key ä¸å­˜åœ¨ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„èŠ‚ç‚¹\n            DLinkedNode newNode = new DLinkedNode(key,value);\n            addToHead(newNode);\n            cache.put(key,newNode);\n            size++;\n            if (size>capacity){\n                // å¦‚æœè¶…å‡ºå®¹é‡ï¼Œåˆ é™¤åŒå‘é“¾è¡¨çš„å°¾éƒ¨èŠ‚ç‚¹\n                DLinkedNode tail = removeTail();\n                // åˆ é™¤å“ˆå¸Œè¡¨ä¸­å¯¹åº”çš„é¡¹\n                cache.remove(tail.key);\n                --size;\n            }\n        }else {\n            node.val = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DLinkedNode node){\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node){\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DLinkedNode node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail(){\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201977834","body":"### æ€è·¯\n- å“ˆå¸Œè¡¨\nå¯¹äºtargetæ¥è¯´ï¼Œå¦‚æœnums[i]ä¸ºxï¼Œé‚£ä¹ˆæˆ‘ä»¬åªéœ€æŸ¥æ‰¾numsä¸­æ˜¯å¦å­˜åœ¨target-x\n### ä»£ç \n```java\n    class Solution {\n        public int[] twoSum(int[] nums, int target) {\n            int[] result = new int[2];\n            Map<Integer,Integer> value2index = new HashMap<>();\n            for (int i = 0; i < nums.length; i++) {\n                int tmp = target-nums[i];\n                if (value2index.containsKey(tmp)){\n                    result[0]=value2index.get(tmp);\n                    result[1]=i;\n                }else {\n                    value2index.put(nums[i],i);\n                }\n            }\n            return result;\n        }\n    }\n```\n### å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦ï¼šO(n)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207728923","body":"```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        // å¿«æ…¢æŒ‡é’ˆï¼Œå¿«æŒ‡é’ˆèµ°2æ­¥ï¼Œæ…¢æŒ‡é’ˆèµ°1æ­¥\n        // ä»€ä¹ˆæ˜¯ä¸­é—´èŠ‚ç‚¹ å¥‡æ•°æ•°ç»„åªæœ‰ä¸€ä¸ªä¸­é—´èŠ‚ç‚¹ï¼Œå¶æ•°æ•°ç»„æœ‰ä¸¤ä¸ªä¸­é—´èŠ‚ç‚¹\n        // æ‰¾å‡ºé“¾è¡¨é‡Œçš„ä¸­é—´ç»“ç‚¹\n        // æ–¹æ³•1:2æ¬¡éå†\n\n        return findMiddleNod(head);\n    }\n\n    public ListNode findMiddleNod(ListNode head){\n        // è®¡ç®—å‡ºé“¾è¡¨é•¿åº¦\n        int length = 0;\n        ListNode tmp = head;\n        while(tmp!=null){\n            length++;\n            tmp = tmp.next;\n        }\n        // å¦‚ä½•å¤„ç†å¶æ•°å’Œå¥‡æ•°æƒ…å†µä¸‹ ï¼ˆç¬¬äºŒä¸ªä¸­é—´èŠ‚ç‚¹ï¼‰ middle = length/2+1;\n        int idx = length/2+1;\n        ListNode tmp2 = head;\n        while(tmp2!=null){\n            if(idx==1){\n                return tmp2;\n            }\n            idx--;\n            tmp2= tmp2.next;\n        }\n        return null;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jerry-lllman":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185162752","body":"### è§£é¢˜æ€è·¯:\r\nä»ä½ä½å¾€é«˜ä½å¤„ç†\r\n1. å°† k ä¸ num[i] ç›¸åŠ , k += num[i]\r\n2. å°† k % 10 åæ·»åŠ åˆ° res ä¸­\r\n3. æ¯æ¬¡éå†éƒ½å°† k /= 10\r\n4. è¿”å› res\r\n\r\n### case:\r\n1. æ³¨æ„ k / 10 éœ€è¦å¤„ç†æµ®ç‚¹æ•°çš„é—®é¢˜ k = Math.floor(k / 10)\r\n2. å½“ i < 0 æ—¶ï¼ˆå³numéå†å®Œäº†ï¼Œkä»æœ‰ä½™å€¼ï¼‰ä¸å†éœ€è¦ k += num[i]\r\n\r\n```ts\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n  const res = []\r\n  const leng = num.length\r\n  for (let i = leng - 1; i >= 0 || k > 0; i--, k = Math.floor(k / 10)) {\r\n    if (i >= 0) {\r\n      k += num[i]\r\n    }\r\n    res.push(k % 10)\r\n  }\r\n  res.reverse()\r\n  return res\r\n};\r\n```\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186179190","body":"## è§£é¢˜æ€è·¯\nä»ä¸­é—´å¾€ä¸¤è¾¹æŸ¥æ‰¾\n\n## ä»£ç \n```ts\nfunction shortestToChar(s: string, c: string): number[] {\n  const leng = s.length\n  const ans: number[] = new Array(leng)\n  for (let i = 0; i < leng; i++) {\n    for (let j = 0; j < leng; j++) {\n      if (s[i + j] === c || s[i - j] === c) {\n        ans[i] = j\n        break\n      }\n    }\n  }\n  return ans\n};\n```\n\n## å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦ï¼šO(n2)ï¼Œä¸¤å±‚å¾ªç¯  \nç©ºé—´å¤æ‚åº¦ï¼šO(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1190087929","body":"```ts\nclass CustomStack {\n  data: number[] = []\n  maxSize: number\n  constructor(maxSize: number) {\n    this.maxSize = maxSize\n  }\n\n  push(x: number): void {\n    if (this.data.length === this.maxSize) return\n    this.data.push(x)\n  }\n\n  pop(): number {\n    return this.data.pop() || -1\n  }\n\n  increment(k: number, val: number): void {\n    for(let i = 0; i < k && i < this.data.length; i++) {\n      this.data[i] += val\n    }\n  }\n}\n\n```\n### å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦ï¼š\npush,pop O(1), increment O(min(k, ctn))\nç©ºé—´å¤æ‚åº¦ï¼š\nO(1)\n\nçœ‹é¢˜è§£åšçš„ä¼˜åŒ–ï¼Œè¿™é¢˜è¦æ˜¯æŒ‰ç…§ä¸Šé¢çš„å†™é¢è¯•åŸºæœ¬å‡‰äº†ï½\n### ä¼˜åŒ–æ€è·¯\n1. é¢å¤–ç»´æŠ¤ä¸€ä¸ªmaxSizeé•¿åº¦çš„æ•°ç»„ï¼Œæ¯æ¬¡incrementæ—¶å°†increments[k] += valï¼Œè¿™æ ·å°±å°†å¤æ‚åº¦é™ä½åˆ°äº†O(1)\n2. åœ¨popæ—¶å°†æ ˆé¡¶çš„å€¼ä¸å¯¹åº”åœ¨incrementsä¸­çš„å€¼ç›¸åŠ è¿”å›ï¼Œåœ¨è¿”å›ä¹‹å‰å°†increments[top - 1] += increments[top]çš„å€¼\nä»¥ä¸Šè¿™ä¸¤ä¸ªæ“ä½œå°±èƒ½æ»¡è¶³incrementå°†k(stack.length)ä¸ªå€¼éƒ½åŠ valçš„è¦æ±‚äº†\n```ts\nclass CustomStack {\n  maxSize: number\n  stack: number[] = []\n  increments: number[]\n  constructor(maxSize: number) {\n    this.maxSize = maxSize\n    this.increments = new Array(maxSize).fill(0)\n  }\n\n  push(x: number): void {\n    if (this.stack.length < this.maxSize) {\n      this.stack.push(x)\n    }\n  }\n\n  pop(): number {\n    const ind = this.stack.length - 1\n    if (ind < 0) return -1\n    if (ind > 0) {\n      this.increments[ind - 1] += this.increments[ind]\n    }\n    const res = this.stack.pop() + this.increments[ind]\n    this.increments[ind] = 0\n    return res\n  }\n\n  increment(k: number, val: number): void {\n    let i = Math.min(k, this.stack.length) - 1\n    if (i >= 0) {\n      this.increments[i] += val\n    }\n  }\n}\n\n### å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦ï¼šO(1)\nç©ºé—´å¤æ‚åº¦ï¼šé¢å¤–ç»´æŠ¤äº†ä¸€ä¸ªå¤§å°ä¸º maxSize çš„æ•°ç»„ï¼Œå¹³å‡å¤æ‚åº¦ O(maxSize/N)ï¼ŒNä¸ºæ“ä½œæ¬¡æ•°\n```","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190150684","body":"## è§£é¢˜æ€è·¯\n åˆ©ç”¨å•è°ƒæ ˆï¼Œå½“å®¡æŸ¥å…ƒç´ æ¯”æ ˆé¡¶å…ƒç´ å°ï¼Œåˆ™ä»æ ˆé¡¶å¼€å§‹å¯¹æ¯”æ ˆå†…æ¯ä¸€ä¸ªå…ƒç´ ï¼Œå°†å¤§äºå®¡æŸ¥å…ƒç´ çš„å…¨éƒ¨å‰”é™¤ï¼Œç»´æŒä½å•è°ƒæ€§\n æœ€åè¿”å›å•è°ƒæ ˆçš„é•¿åº¦å³å¯\n\n## ä»£ç å®ç°\n```ts\nfunction maxChunksToSorted(arr: number[]): number {\n  let incStack: number[] = []\n  for (let i = 0; i < arr.length; i++) {\n    if (incStack.length && arr[i] < incStack[incStack.length - 1]) {\n      const temp = incStack[incStack.length - 1]\n      // å°†å°çš„å…ƒç´ å‰”é™¤ï¼Œç»´æŠ¤å•è°ƒæ ˆçš„å•è°ƒæ€§\n      while (incStack[incStack.length - 1] > arr[i]) incStack.pop()\n      // æœ€åå†å°†å®¡æŸ¥å…ƒç´ æ·»åŠ åˆ°æ ˆå†…\n      incStack.push(temp)\n    } else {\n      incStack.push(arr[i])\n    }\n  }\n  return incStack.length\n};\n```\n## å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦ï¼šO(n)\nç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190992188","body":"## è§£é¢˜æ€è·¯\néå†é“¾è¡¨ï¼Œå½¢æˆç¯å½¢é“¾è¡¨ï¼ŒåŒæ—¶è®°å½•é“¾è¡¨é•¿åº¦ leng\nç§»åŠ¨ leng - k ä¸ªä½ç½®ï¼Œå°±åˆ°äº†æ–°çš„å°¾èŠ‚ç‚¹ï¼Œä¸‹ä¸€ä¸ªå°±æ˜¯æ–°çš„å¤´èŠ‚ç‚¹äº†\næ–­å¼€å°¾èŠ‚ç‚¹ä¸å¤´èŠ‚ç‚¹çš„é“¾æ¥ï¼Œè¿”å›æ–°çš„å¤´èŠ‚ç‚¹å³å¯\n### Case\nk å¯èƒ½å¤§äº lengï¼Œæ‰€ä»¥ k éœ€è¦ %= leng ä»¥åæ‰æ˜¯å®é™…éœ€è¦ç§»åŠ¨çš„æ•°å€¼\n\n## ä»£ç \n```ts\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n\tif (!head) return head\n\tlet leng = 1\n\tlet p = head\n\twhile (p.next) {\n\t\tp = p.next\n\t\tleng++\n\t}\n\tp.next = head\n\n\tk %= leng\n\tk = leng - k\n\twhile (k--) {\n\t\tp = p.next\n\t}\n\thead = p.next\n\tp.next = null\n\treturn head\n};\n```\n## å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦ï¼šO(n)\nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192589121","body":"## è§£é¢˜æ€è·¯\r\næœ¬é¢˜é‡ç‚¹åœ¨äºéœ€è¦å€ŸåŠ©ä¸€ä¸ªè™šæ‹Ÿå¤´èŠ‚ç‚¹ï¼Œæ¥æ‰¿è½½å¤´æŒ‡é’ˆçš„å¼•ç”¨ï¼ˆå¤´æŒ‡é’ˆä¸ä¼šä¸¢å¤±ï¼‰\r\näº¤æ¢æ€è·¯ä¸æ™®é€šçš„äº¤æ¢æ²¡æœ‰å¤ªå¤§åŒºåˆ«\r\n\r\n## ä»£ç å®ç°\r\n```ts\r\nfunction swapPairs(head: ListNode | null): ListNode | null {\r\n  let dummyHead = new ListNode(0, head) // éœ€è¦ä¸€ä¸ªè™šæ‹Ÿå¤´èŠ‚ç‚¹\r\n  let temp = dummyHead\r\n  while(temp.next && temp.next.next) { // å› ä¸ºæ˜¯ä¸¤ä¸¤äº¤æ¢ï¼Œæ‰€ä»¥éœ€è¦åˆ¤æ–­ä¸¤ä¸ªnext\r\n    const next1 = temp.next // æ‹¿åˆ°ç¬¬ä¸€ä¸ª next\r\n    const next2 = temp.next.next // æ‹¿åˆ°ç¬¬äºŒä¸ª next\r\n    temp.next = next2 // å°†å½“å‰çš„ temp.next æŒ‡å‘ ç¬¬äºŒä¸ª next         //// ä¹Ÿå°±æ˜¯å°†  1 çš„ next æŒ‡å‘ 3\r\n    next1.next = next2.next // å†å°† next1.next æŒ‡å‘ next2.next     //// å°† 2 çš„ next æŒ‡å‘ 4\r\n    next2.next = next1 // æ¥ç€å°† next2.next æŒ‡å‘ä¸º next1            //// å†å°† 3 çš„ next æŒ‡å‘  2ï¼Œè‡³æ­¤å®Œæˆäº¤æ¢\r\n    temp = next1 // å®Œæˆäº¤æ¢ï¼Œå¤„ç†ä¸‹ä¸€ä¸ªèŠ‚ç‚¹\r\n  }\r\n\treturn dummyHead.next\r\n};\r\n```\r\n\r\n## å¤æ‚åº¦åˆ†æ\r\næ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193499011","body":"```ts\nfunction detectCycle(head: ListNode | null): ListNode | null {\n  if (!head) return head\n  let p = head, q = head.next\n  while (q && q.next && p !== q) {\n    p = p.next, q = q.next.next\n  }\n  // ç›¸é‡ç‚¹x\n  if (p && q && p === q) {\n    p = head,\n    q = q.next\n  } else {\n    return null\n  }\n  while(p !== q) {\n    p = p.next\n    q = q.next\n  }\n\n  return q\n};\n```\n\n```ts\nfunction detectCycle(head: ListNode | null): ListNode | null {\n  if (!head) return head\n  const h = new Set()\n  while(head && !h.has(head)) {\n    h.add(head)\n    head = head.next\n  }\n\n  if (h.has(head)) return head\n  return null\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195438675","body":"é¦–å…ˆæƒ³åˆ°çš„è§£æ³•å°±æ˜¯åˆ©ç”¨æ•°ç»„ï½\n```ts\nclass LRUCache {\n    keys = []\n    cacheKeyValue = {}\n    capacity = 0\n    constructor(capacity: number) {\n        this.capacity = capacity\n    }\n\n    get(key: number): number {\n        if (key in this.cacheKeyValue) {\n            this.cacheHandelr(key)\n            return this.cacheKeyValue[key]\n        }\n        return -1\n    }\n\n    put(key: number, value: number): void {\n        if (key in this.cacheKeyValue) {\n            this.cacheHandelr(key)\n        } else {\n            if (this.keys.length >= this.capacity) {\n                const removeKey = this.keys.shift()\n                if (removeKey !== key) {\n                    delete this.cacheKeyValue[removeKey]\n                }\n            }\n            this.keys.push(key)\n        }\n        this.cacheKeyValue[key] = value\n    }\n\n    cacheHandelr(key) {\n        const index = this.keys.indexOf(key)\n        let length = this.keys.length - 1\n        if (this.keys[index] !== this.keys[length]) {\n            for (let i = index; i < length; i++) {\n                [this.keys[i], this.keys[i + 1]] = [this.keys[i + 1], this.keys[i]]\n            }\n            this.keys[length] = key\n        }\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196208501","body":"```ts\n\nfunction maxDepth(root: TreeNode | null): number {\n  if (!root) return 0\n  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nickyk319":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185163309","body":"### æ€è·¯\r\n\r\nSimulate the way we do addition manually.\r\n\r\n1. Iterate array from right to left\r\n2. Do addition between last element and integer K. \r\n3. Every time only keep the last digit of the result, and put it into a list. \r\n4. Forward the rest digits of the result to do summation with the previous element in the array. \r\n5. Repeat the above process until array out of index or the value been set to zero\r\n6. The reverse of the list will be the answer to return.\r\n\r\n### ä»£ç \r\n\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int len = num.length;\r\n        ArrayList<Integer> ans = new ArrayList<>();\r\n        int curVal = k;\r\n        int i = len - 1;\r\n        while (i >= 0 || curVal > 0) {\r\n            if (i >= 0) {\r\n                curVal += num[i];\r\n            }\r\n            ans.add(curVal % 10);\r\n            curVal /= 10;\r\n            i--;\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºnumsæ•°ç»„é•¿åº¦ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186387841","body":"### æ€è·¯\n\nUse ArrayList to simulate Stack\n\n### ä»£ç \n\n\n```java\nclass CustomStack {\n    private int size;\n    private ArrayList<Integer> stack = new ArrayList<>();\n    public CustomStack(int maxSize) {\n       size = maxSize; \n    }\n    \n    public void push(int x) {\n        if (stack.size() < size) {\n            stack.add(x);\n        }\n    }\n    \n    public int pop() {\n        if (stack.isEmpty()) {\n            return -1;\n        } else {\n            return stack.remove(stack.size() - 1);\n        }\n    }\n    \n    public void increment(int k, int val) {\n        for (int i = 0; i < k && i < stack.size(); ++i) {\n            stack.set(i, stack.get(i) + val);\n        }\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šincrement is O(N)ï¼Œpush() and pop() are O(1)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187612833","body":"### æ€è·¯\n\nUse two stack, one used for numbers and the other used for string. \n\nConsider 4 circumstances:\n1. element is digit, store it in variable k.\n2. element is '[', push the number and string to countStack and stringStack respectively.\n3. element is ']', decode string by append k times current string to the top of the stringStack.\n4. element is a character, append to currentString.\n\n### ä»£ç \n\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Integer> countStack = new Stack<>();\n        Stack<StringBuilder> stringStack = new Stack<>();\n        StringBuilder currentString = new StringBuilder();\n        int k = 0;\n        \n        for (char ch: s.toCharArray()) {\n            if (Character.isDigit(ch)) {\n                k = k * 10 + ch - '0';        \n            } else if (ch == '[') {\n                countStack.push(k);\n                stringStack.push(currentString);\n                currentString = new StringBuilder();\n                k = 0;\n            } else if (ch == ']') {\n                StringBuilder decodeString = stringStack.pop();\n                for (int currentK = countStack.pop(); currentK > 0; currentK--) {\n                    decodeString.append(currentString);\n                }\n                currentString = decodeString;\n            } else {\n                currentString.append(ch);\n            }\n        }\n        return currentString.toString();\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189138309","body":"### æ€è·¯\n\nUse two stack. consider stack1 as back of queue, stack2 as front of queue.\n\n1. push(x) ==> just push x into stack1\n2. peek() ==> because the front of queue is the bottom element in the stack, we need to make sure stack2 is empty, then pop all the element in stack1 and push into stack2.\n3. pop() ==> do peek first to make sure stack2 is not empty, then just pop stack2. \n\n\n\n### ä»£ç \n\n\n```java\nclass MyQueue {\n    private Stack<Integer> stack1;\n    private Stack<Integer> stack2;\n    public MyQueue() {\n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n    \n    public void push(int x) {\n        stack1.push(x);\n    }\n    \n    public int pop() {\n        peek();\n        return stack2.pop();\n    }\n    \n    public int peek() {\n        if (stack2.isEmpty()) {\n            while(!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.peek();\n    }\n    \n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N) for worst cases. Average O(1) because each element only move at most one time.\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190382247","body":"### æ€è·¯\n\nNo matter the array is sorted or not, the sum of element inside each chunk will be the same. We just need to count the number of equal sum, it is the maxinum number of chunks we can get.\n\n\n### ä»£ç \n\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int[] sorted = Arrays.copyOf(arr, arr.length);\n        Arrays.sort(sorted);\n        int sum1 = 0, sum2 = 0, count = 0;\n        for (int i = 0; i < arr.length; i++) {\n            sum1 += arr[i];\n            sum2 += sorted[i];\n\n            if (sum1 == sum2) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(NlogN) \n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191619534","body":"### æ€è·¯\n\nUse fast and slow pointer.\n\n1. Traverse the list to get length.\n2. k % length to know the exactly number of moves need to make.\n3. Assign fast and slow pointer to point to head.\n4. Move fast pointer k moves ahead from the slow pointer.\n5. while the fast.next point to the end of list, slow.next point to the new head.\n6. Make slow.next point to NULL.\n7. Connect the fast.next (the old tail) to head to close the ring.\n8. return new head.\n\n\n### ä»£ç \n\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null) return null;\n        if (head.next == null) return head;\n\n        int len = 0;\n        ListNode tail = head;\n        while (tail != null) {\n            tail = tail.next;\n            len++;\n        }\n        k %= len;\n        if (k == 0) return head;\n        ListNode slow = head, fast = head;\n        while (k > 0) {\n            fast = fast.next;\n            k--;\n        }\n        while (fast.next != null) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        \n        ListNode newHead = slow.next;\n        slow.next = null;\n        fast.next = head;\n        return newHead;\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N) \n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192654882","body":"### æ€è·¯\n\nSeparate this question into two parts:\n\n1. Find the first pair of node with two pointers\n2. reverse pair of nodes [a, b), store the new Head\n3. Do the same process for the rest of linkedlist, link the next reversed pair to the previous one.\n\n\n### ä»£ç \n\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null) return null;\n        ListNode a, b;\n        a = b = head;\n        for (int i = 0; i < 2; i++) {\n          if (b == null) return head;\n          b = b.next;\n        }\n        ListNode newHead = reversePair(a, b);\n        a.next = swapPairs(b);\n        return newHead; \n    }\n\n    public ListNode reversePair(ListNode a, ListNode b) {\n      ListNode pre = null, cur = a, nxt = a;\n      while (cur != b) {\n        nxt = cur.next;\n        cur.next = pre;\n        pre = cur;\n        cur = nxt;\n      }\n      return pre;\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N) \n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193341191","body":"### æ€è·¯\n\nUse two pointer, connect two linkedlist together. When pointer1 finish traverse listA start to traverse listB, when pointer2 finish traverse listB start to traverse listA. p1 and p2 can reach the intersection node at the same time.\n\n\n### ä»£ç \n\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA, p2 = headB;\n        while (p1 != p2){\n            if (p1 == null) p1 = headB;\n            else p1 = p1.next;\n            if (p2 == null) p2 = headA;\n            else p2 = p2.next;\n        }\n        return p1;\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N) \n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194188307","body":"### æ€è·¯\n\nUse two pointerï¼Œwe can separate this question into two steps:\n1. detect cycle.\n   - Assign two pointers point to head, slow pointer traverse on node at a time, fast pointer go two nodes. If they meet each other during the traversal, we have detect a cycle.\n  \n2. find the start node of the cycle\n   - when the time slow pointer and fast pointer meet each other, the distance between slow pointer and fast pointer is k. If the distance between meet point and start node of the linkedlist is m. Then if we move forward k steps from head, we can reach the start point of the cycle. If we move foward k steps from meeting point, we can reach the satrt point of the cycle as well.\n\n\n\n\n### ä»£ç \n\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode fast, slow;\n        fast = slow = head;\n        while (fast != null && fast.next != null){\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) break;\n        }\n        // æ²¡æœ‰é—­ç¯çš„caseï¼Œåˆ†ä¸ºnodeçš„ä¸ªæ•°æ˜¯å¥‡æ•°æˆ–è€…å¶æ•°çš„æƒ…å†µ\n        if (fast == null || fast.next == null){\n            return null;\n        }\n        slow = head;\n        // æ³¨æ„è¿™é‡Œçš„å¾ªç¯ç»“æŸæ¡ä»¶æ˜¯ slow å’Œ fastä¸ç›¸ç­‰\n        while (slow != fast){\n            fast = fast.next;\n            slow = slow.next;\n        }\n        // ç›¸ç­‰çš„æƒ…å†µå°±æ‰¾åˆ°äº†é—­ç¯èŠ‚ç‚¹\n        return slow;\n        \n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N) \n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195587208","body":"### æ€è·¯\n\nHashMap, Double LinkedList\n\n### ä»£ç \n\n\n```java\nclass LRUCache {\n    int cap;\n    LinkedHashMap<Integer, Integer> cache = new LinkedHashMap<>();\n    public LRUCache(int capacity) {\n        this.cap = capacity;\n    }\n    \n    public int get(int key) {\n        if (!cache.containsKey(key)){\n            return -1;\n        }\n        makeRecently(key);\n        return cache.get(key);\n    }\n    \n    public void put(int key, int value) {\n        if (cache.containsKey(key)){\n            cache.put(key, value);\n            makeRecently(key);\n            return;\n        }\n        if (cache.size() >= this.cap){\n            int oldestKey = cache.keySet().iterator().next();\n            cache.remove(oldestKey);\n        }\n        cache.put(key, value);\n    }\n    private void makeRecently(int key){\n        int val = cache.get(key);\n        cache.remove(key);\n        cache.put(key, val);\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(1) \n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196776699","body":"### æ€è·¯\n\nSeperate this question into sub questions. If you want to know the maximum depth for the binary tree, you need to to calculate the max depth between sub-left tree and sub-right tree, and add the root depth to the result.\n\n### ä»£ç \n\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n      if (root == null) {\n         return 0;\n      }\n      int left_max = maxDepth(root.left);\n      int right_max = maxDepth(root.right);\n      int res = Math.max(left_max, right_max) + 1;\n      return res;\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N) \n- ç©ºé—´å¤æ‚åº¦ï¼šO(logN), if the binary tree is balanced\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198202382","body":"### æ€è·¯\n\nThree cases to consider:\n1. p and q are both null.\n2. one of them is null.\n3. Check if the value of p is equals to value of q.\n\n### ä»£ç \n\n\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val != q.val) return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N) \n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199463678","body":"### æ€è·¯\n\nDo a preorder traversal on the tree.\n1. Record every node on the path.\n2. Calculate the sum when reach leaf node.\n3. Remove the current added node from path at the end of each traverse (most important) \n\n### ä»£ç \n\n\n```java\nclass Solution {\n    StringBuilder sb = new StringBuilder();\n    int res = 0;\n    public int sumNumbers(TreeNode root) {\n        traverse(root);\n        return res;\n    }\n    void traverse(TreeNode root) {\n        if (root == null) return;\n        // recording the value of node on the path of preorder traverse\n        sb.append(root.val);\n        if (root.left == null && root.right == null) {\n            res += Integer.parseInt(sb.toString());\n        }\n        traverse(root.left);\n        traverse(root.right);\n\n        // remove current added node from sb (toss it immmediatly after use)\n        sb.deleteCharAt(sb.length() - 1);\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N) \n- ç©ºé—´å¤æ‚åº¦ï¼šO(H), H is tree height.\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200655655","body":"### æ€è·¯\n\n1. Record the coordinates corresponding to each node.\n2. Traverse the tree first to generate all the coordianates.\n3. Sort the coordinates array as requested.\n4. Add the node to the list if they are in the same column.\n\n### ä»£ç \n\n\n```java\nclass Solution {\n    // build the coordinates of node have with attributes\n    class Coordinates {\n        public int row, col;\n        public TreeNode node;\n\n        public Coordinates(TreeNode node, int row, int col) {\n            this.node = node;\n            this.row = row;\n            this.col = col;\n        }\n    }\n\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        // traverse the binary tree, generate corresponding coordinates\n        traverse(root, 0, 0);\n        // sort the node\n        Collections.sort(nodes, (Coordinates a, Coordinates b) -> {\n            if (a.col == b.col && a.row == b.row) {\n                return a.node.val - b.node.val;\n            }\n            if (a.col == b.col) {\n                return a.row - b.row;\n            }\n            return a.col - b.col;\n        });\n\n        LinkedList<List<Integer>> res = new LinkedList<>();\n        int preCol = Integer.MIN_VALUE;\n        for (int i = 0; i < nodes.size(); i++) {\n            Coordinates cur = nodes.get(i);\n            // check if the column of the current node == previous node\n            if (cur.col != preCol) {\n                // start to record a new column\n                res.add(new LinkedList<>());\n                preCol = cur.col;\n            }\n            // add value to the new added column\n            res.getLast().add(cur.node.val);\n        }\n        return res;\n    }\n\n    ArrayList<Coordinates> nodes = new ArrayList<>();\n    // traverse the binary tree, store all the nodes with their coordinates in an arrayList\n    void traverse(TreeNode root, int row, int col) {\n        if (root == null) return;\n        nodes.add(new Coordinates(root, row, col));\n        traverse(root.left, row + 1, col - 1);\n        traverse(root.right, row + 1, col + 1);\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(NlogN), because of the sorting algo\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N), N is numbers of nodes.\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201947762","body":"### æ€è·¯\n\n1. Using HashMap to keep a record of value:index pair\n2. Looking for substraction of target and nums[i] in the map.\n3. If the value has been found, add the index of it and i to the array.\n4. If not, add the value:index pair to the map.\n\n### ä»£ç \n\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        // map: value -> index\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int need = target - nums[i];\n            if (map.containsKey(need)){\n                return new int[]{map.get(need), i};\n            }\n            map.put(nums[i], i);\n        }\n        return null;\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1204072267","body":"### æ€è·¯\n\n1. Using HashMap to record the value:frequency pair.\n2. Using min heap to sort the HashMap by frequency.\n3. Keep adding numbers to heap and always keep k numbers on the heap.\n4. Pop numbers from heap and put it in the returning array.\n\n\n### ä»£ç \n\n\n```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        HashMap<Integer, Integer> freq = new HashMap<>();\n        for (int n: nums) {\n            freq.put(n, freq.getOrDefault(n, 0) + 1);\n        }\n        Queue<Integer> heap = new PriorityQueue<>(\n            (n1, n2) -> freq.get(n1) - freq.get(n2));\n        for (int n: freq.keySet()) {\n            heap.add(n);\n            if (heap.size() > k) {\n                heap.poll();\n            }\n        }\n        int[] res = new int[k];\n        for (int i = k - 1; i >=0; i --) {\n            res[i] = heap.poll();\n        }\n        return res;\n\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(Nlogk)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205444511","body":"### ä»£ç \n\n\n```java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        int res = 0;\n        for (int i = 0; i < points.length; i++) {\n            for (int j = 0; j < points.length; j++) {\n                if (i == j) continue;\n                int distance = getDistance(points[i], points[j]);\n                map.put(distance, map.getOrDefault(distance, 0) + 1);\n            }\n            for (int val: map.values()) {\n                res += val * (val - 1);\n            }\n            map.clear();\n        }\n        return res;\n    }\n\n    public int getDistance(int[] a, int[] b) {\n        int dx = a[0] - b[0];\n        int dy = a[1] - b[1];\n\n        return dx * dx + dy * dy;\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N^2)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206513121","body":"### æ€è·¯\n\nSliding window\n\n\n### ä»£ç \n\n\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        HashMap<Character, Integer> window = new HashMap<>();\n        int left = 0, right = 0, res = 0;\n        while (right < s.length()) {\n            char c = s.charAt(right);\n            window.put(c, window.getOrDefault(c, 0) + 1);\n            right++;\n            while (window.get(c) > 1) {\n                char d = s.charAt(left);\n                window.put(d, window.getOrDefault(d, 0) - 1);\n                left++;\n            }\n            res = Math.max(res, right - left);\n        }\n        return res;\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208187953","body":"### æ€è·¯\n\nTwo pointers:\n- When fast pointer reached the end of linkedlist, slow pointer is pointing on the middle node.\n\n\n### ä»£ç \n\n\n```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode slow, fast;\n        slow = fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209405859","body":"### æ€è·¯\n\nTwo pointers\n\n\n### ä»£ç \n\n\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        if (nums.length == 0) return 0;\n        int slow = 0;\n        for (int fast = 0; fast < nums.length; fast++) {\n            if (nums[slow] != nums[fast]) {\n                slow++;\n                nums[slow] = nums[fast];\n            }\n        }\n        return slow + 1;\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"herbertpan":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185163334","body":"### Idea\næ¯æ¬¡ä½ç§»ä¸€ä¸ª\n### Code\n``` \npublic List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new LinkedList<>();\n        //.       0 1 2\n        // num = [2,1,5], k = 1806\n        //            |         \n        //            5.   +     6. => 11 (1 % 1) ==> [1]\n        //           |\n        //           1     +.   0   => 1 + 0 + 1 = 2 ==> 2 % 0 ==> [2, 1]\n        //         |\n        //         2.      +.   8.  => 2 + 8 + 0 = 10 => 0 % 1 ==> [0, 2, 1]\n        //.      |\n        //.      0         +.   1   ==>. 0 + 1 + 1 == > 2 % 0 ==> [2, 0, 2, 1]\n        //      |\n        int bitIndex = num.length - 1;\n        int overFlow = 0;\n        while (k != 0 || bitIndex >= 0 || overFlow != 0) {\n            int valFromNum = bitIndex >= 0 ? num[bitIndex] : 0;\n            int valFromK = k % 10;\n            k = k / 10;\n            int numVal = valFromNum + valFromK + overFlow;\n            overFlow = numVal / 10;\n            ans.add(0, numVal % 10);\n            bitIndex--;\n        }\n        \n        return ans;\n    }\n```\n\n###  complexity\nTime: O(max (N, len(K)));\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186110330","body":"### Algo\n    // s: c xxxx c xxxx c xx c\n    //.     |\n    //.   |.     |\n    // -> 0 1234 0 1234 0 12 0\n    //    0 4321 0 4321 0 21 0 <-\n    //.   0 1221 0 1221 0 11 0\n    //.   xxx c xxx\n    //.   MMM 0 123\n    //.   321 0 MMM\n    // \n    // For any certain index, the closest distance from c, is either the occurence of c before it or after it\n    // so we can go through the array from head to tail, to count the distance from c before it\n    // and do it again from tail to head to count the distance from c after it.\n    // Take the min value as the answer.\n    // To count the distance, whenver met a c, refresh the distance to 0, and every movement plus 1 on the distance, start with distance as Integer.MAX_VALUE\n    \n\n### Code\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] ans = new int[s.length()];\n        Arrays.fill(ans, Integer.MAX_VALUE);\n        \n        int distance = Integer.MAX_VALUE;\n        for (int i = 0; i < ans.length; i++) {\n            if (s.charAt(i) == c) {\n                distance = 0;\n            } else {\n                distance = distance < Integer.MAX_VALUE ? distance + 1 : distance;\n            }\n            if (distance < ans[i]) {\n                ans[i] = distance;\n            }\n        }\n        distance = Integer.MAX_VALUE;\n        for (int i = ans.length - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                distance = 0;\n            } else {\n                distance = distance < Integer.MAX_VALUE ? distance + 1 : distance;\n            }\n            if (distance < ans[i]) {\n                ans[i] = distance;\n            }\n        }\n        \n        return ans;\n    }\n}\n```\n### Time Complexity\n1. Time: O(n)\n2. Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186360602","body":"### Algo\n//     Since we need to maintain \"random\" access which is not possible with stack/queue/deque\n//     so lets use array to mock a stack, luckily the array size is given.\n    \n//     1. we first init an array with length as maxSize, and maintain a pnt to indicate the next avaible slot\n//        so pnt == 0, means empty; pnt == arr.length means full\n//     2. for each push, check the pnt position; if available, insert into pnt and pnt++\n//     3. same logic for pop, return arr[pnt - 1] and pnt--;\n//     4. increment just start with index 0 till Min(pnt - 1, k);\n    \n### Code\n```java\nclass CustomStack {\n    private int[] arr;\n    private int nextAvailableSlot = 0;          //  |\n    public CustomStack(int maxSize) {           // [y,y,y]\n        arr = new int[maxSize];                 //. 0 1 2\n    }\n    \n    public void push(int x) {                    // [1,2,y]    // [1,2,y]\n        if (nextAvailableSlot < arr.length) {    //      |     //    |\n            arr[nextAvailableSlot] = x;                        //  [1,2,y]\n            nextAvailableSlot++;                               //.      |\n        }                                                      //  [1,2,3]\n    }                                                          //.         |\n    \n    public int pop() {\n        if (nextAvailableSlot != 0) {            // [1,2,y]\n            nextAvailableSlot--;                 //.   |\n            return arr[nextAvailableSlot];       //.   2\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        int tillIndex = Math.min(k, nextAvailableSlot );   //  [1,2,3]           [1,2,3]        \n        for (int i = 0; i < tillIndex; i++) {              //.         |                 |\n            arr[i] += val;                                   // tillIndex = 3    tillIndex = min(2,3) = 2\n        }                                                  // [101, 102, 103]    [201, 202, 103]  \n    }\n}\n```\n### Complexity\n1. Time: O(1) for push and pop, O(k) for increment\n2. Space: O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186843684","body":"### Algo\n//     11:18PM\n//     Constraints:\n//     1. K > 0\n//     2. 2[4]/3a/2[]\n//     3. digits are only repeat\n        \n//     test case:\n//     1. abc\n//     2. a3[a]\n//     3. 3[a3[b]]c\n        \n        \n//     \"a3[a2[c]]\"  \n//     1. get the string => a\n//     2. get the repeated number => 3\n//     3. get the repeated string => a2[c]\n//         3.1 get the string => a\n//         3.2 get the repeated number => 2\n//         3.3 get the repeated string => c\n//             3.3.1 get the string => c\n//             3.3.2 get the repeated number => 0\n//         3.4 get built string repeated number * returned string => 2 * c = cc\n//         3.5 prefix string => a + cc = acc\n//     4. get built string repeated number * returned string => 2 * acc = accaccacc\n//     5. prefix string => a + accaccacc = aaccaccacc\n    \n    // \"3[2[c]]\"\n    // 1. get string => \"\"\n    // 2. get the repeated number => 3\n    // 3. get the repeated string => 2[c]\n    //     3.1 get the string => \"\"\n    //     3.2 get the repeated number => 2\n    //     3.3 get the repeated string => c\n    //         3.3.1 get the string => c\n    //         3.3.2 get repeated number => 0  ==> !end!\n    //     3.4 get built string repeated number * returned string => 2 * c = cc\n    //     3.5 prefix string => \"\" + cc = cc\n    // 4. get built string repeated number * returned string => 3 * cc = cccccc\n    // 5. prefix string => \"\" + cccccc = cccccc\n    \n### Code\nclass Solution {\n    public String decodeString(String s) {                  \n        return helper(s, 0, s.length() - 1);\n    }\n    \n    private String helper(String s, int startIndex, int endIndex) {     //         \"3[a]2[bc]\"       // a\n        int index = startIndex;                                         // index = 0 \n        StringBuilder ans = new StringBuilder();\n        while (index <= endIndex) {\n            String prefixString = getPrefixString(s, index, endIndex);      // prefix= \"\"\n            index += prefixString.length();                                 // index = 0;\n\n            String repeatedNumber = getRepeatedNumber(s, index, endIndex);  // repeat =  \"3\"\n            if (repeatedNumber.length() == 0 || Integer.valueOf(repeatedNumber) == 0) {\n                ans.append(prefixString);\n                continue;\n            }\n            index += repeatedNumber.length();                                // index = 1\n\n            index += 1; // forward one step to skil [                        // index = 2; \n            int repeatedStringEnds = getRepeatEndIndex(s, index, endIndex);  // reapted = 3\n                                                                             // rewind 1 step for ]\n            String repeatedString = helper(s, index, repeatedStringEnds - 1); // str = \"a\"\n            index = repeatedStringEnds + 1;\n            String returnString = \"\";\n\n            int repeatedNum = Integer.valueOf(repeatedNumber);                // return = \"aaa\"\n            for (int i = 0; i < repeatedNum; i++) {\n                returnString += repeatedString;\n            }\n            ans.append(prefixString).append(returnString);\n        }\n        \n        return ans.toString();                       //\n    }\n                                                                              // |\n    private String getPrefixString(String s, int startIndex, int endIndex) {  // 3[a]2[bc]\n        // keep tracking until meets a number or ends\n        StringBuilder sb = new StringBuilder();\n        int index = startIndex;\n        while (index <= endIndex && s.charAt(index) >= 'a' && s.charAt(index) <= 'z') {\n            sb.append(s.charAt(index));\n            index++;\n        }\n        return sb.toString();\n    }\n                                                                                           // ||\n    private String getRepeatedNumber(String s, int startIndex, int endIndex) {             // 3[a]2[bc]\n        // get first start should be a number or the end \n        StringBuilder sb = new StringBuilder();\n        int index = startIndex;                                                            // sb = 3\n        while (index <= endIndex && s.charAt(index) >= '0' && s.charAt(index) <= '9') {\n            sb.append(s.charAt(index));\n            index++;\n        }\n        return sb.toString();\n    }                                                                              \n                                                                                 //   ||\n    private int getRepeatEndIndex(String s, int startIndex, int endIndex) {      // 3[a]2[bc]\n        // get first start should be a [ or end index                            //.012345678\n        int numberOfBackBracket = 0;                                             //    1\n        int index = startIndex;\n        while (index <= endIndex) {                                              //    \n           if (s.charAt(index) == ']') {\n               numberOfBackBracket++;\n           }\n            \n           if (numberOfBackBracket == 1) {\n               return index;\n           }\n            \n           if (s.charAt(index) == '[') {\n               numberOfBackBracket--;\n           }\n            index++;\n        }\n        \n        return -1;\n    } \n}\n### Complexity\n1. Time: O(n);\n2. Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188484438","body":"### AlGO\n//     peek 1\n//     Stack1 [ \n//     Stack2 [2,\n//         peek ==> 2\n//         pop  ==> 1\n//     Queue  [1, 2]\n//         pop ==> 1\n    \n//     Start with two stack, push and pop, both are empty at beginning\n//     we also need another vairable peekHolder to hold the first element in stackPush\n//                |\n//     StackPush [3,4\n//     StackPop  [\n//                |\n//     Queue [2,3,4]\n    \n//     push 1\n//         peekHolder = 1\n//     push 2\n//         for push action, add to push stack\n//     peek \n//         the top of stack pop if pop stack is not empty\n//         otherwise, the stack bot for stack push  ==> 1\n//     pop\n//         for pop, transfer all elements from push to pop if pop is empty\n//         then remove stack top\n//     peek\n//         the top of stack pop\n//     push 3\n//         peekHolder = 3\n//     push 4\n//         for push action, add to push stack\n//     peek\n//         the top of stack pop == > 2\n//     pop\n//         for pop, transfer all elements from push to pop if pop is empty\n//         then remove stack top  ==> 2\n//     peek\n//         the top of stack pop if pop stack is not empty\n//         otherwise, the stack bot for stack push\n### Code\n```java\nclass MyQueue {\n    private Deque<Integer> pushStack;\n    private Deque<Integer> popStack;\n    private Integer pushStackBot;\n    public MyQueue() {\n        pushStack = new ArrayDeque<>();\n        popStack = new ArrayDeque<>();\n        pushStackBot = null;\n    }\n    \n    public void push(int x) {\n        if (pushStack.isEmpty()) {\n            pushStackBot = x;\n        }\n        pushStack.offerLast(x);\n    }\n    \n    public int pop() {\n        if (popStack.isEmpty()) {\n            while (!pushStack.isEmpty()) {\n                popStack.offerLast(pushStack.pollLast());\n            }\n            pushStackBot = null;\n            return popStack.pollLast();\n        } else {\n            return popStack.pollLast();\n        }\n    }\n    \n    public int peek() {\n        if (popStack.isEmpty()) {\n            return pushStackBot;\n        } else {\n            return popStack.peekLast();\n        }\n    }\n    \n    public boolean empty() {\n        return popStack.isEmpty() && pushStack.isEmpty();\n    }\n}\n```\n### Complexity\n1. Time: O(1) for all operation\n2. Space: O(n), n is the number of elements in queue","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189425016","body":"### Algo\nç±»ä¼¼äºmerge sortçš„æƒ³æ³•\n### Code\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        \n        int[] sorted = arr.clone();\n        Arrays.sort(sorted);\n        \n        int chunks = 0;\n        \n        Map<Integer, Integer> valCntInSorted = new HashMap<>();\n        // Map<Integer, Integer> valCntInOrg = new HashMap<>();\n                                                                                // org:   1 3 2 4 4\n        int index = 0;                                                          // sorted:1 2 3 4 4\n        int diff = 0;\n        while (index < arr.length) {                                            //.           |         \n            if (!valCntInSorted.containsKey(sorted[index]) || valCntInSorted.get(sorted[index]) >= 0) {                   // diff.    2 \n                diff++;         \n            } else {\n                diff--;                                                     //           1\n            }\n            valCntInSorted.put(sorted[index], valCntInSorted.getOrDefault(sorted[index], 0) + 1); // 1,0, 2,1, 3,0\n            \n            \n            //====//\n            if (!valCntInSorted.containsKey(arr[index]) || valCntInSorted.get(arr[index]) <= 0) {                     // diff    2\n                diff++;\n            } else {                      // diff   0\n                diff--;\n            }\n            valCntInSorted.put(arr[index], valCntInSorted.getOrDefault(arr[index], 0) - 1); // 1, 0, 2,0, 3,0\n            \n            if (diff == 0) {\n                chunks++;\n            }\n\n            index++;\n        }\n        \n        return chunks;\n    }\n}\n```\n### Complexity\n1. Time: O(nlogn) ==> sort\n2. Space:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191079803","body":"### Algo\n1. find the Length of list\n2. find the newHead\n### Code\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) {\n            return head;\n        }\n        \n        ListNode tail = head;\n        int listLen = 1;\n        while (tail.next != null) {\n            tail = tail.next;\n            listLen++;\n        }\n        \n        int rotation = k % listLen;\n        if (rotation == 0) {\n            return head;\n        }\n        \n        // newHead move [len - rotate] steps , newHeadPrev = [len-rotation-1]\n        ListNode newHead = head, newHeadPrev = head;\n        for (int i = 0; i < listLen - rotation - 1; i++) {\n            newHeadPrev = newHeadPrev.next;\n        }\n        newHead = newHeadPrev.next;\n        \n        tail.next = head;\n        newHeadPrev.next = null;\n        head = newHead;\n        \n        return head;\n    }\n}\n```\n### Complexity\n1. Time: O(N)\n2. Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1191737658","body":"### Algo\n1. corner case: head == null or head.next == null\n2. the new head is the second node\n      NH\n D -> 1->2->3->4->5\n      A. B. C\n      \n      \nA -> c\n       A.    C \n  D -> 1 - > 3 ->4 -> 5\n          2_/\n          B\n          \nb -> a\n P    A.    C\n D -> 1 - > 3 ->4 -> 5\n 2_/\n B\np -> B\n                 A.\n P                   B    C\n D -> 2 -> 1 - > 3 ->4 -> 5\n\nP = A;\nA = c      (A is null? end)\nB = A.next (B is null? end)\nC = b.next\n\n=== \nA -> c\nb -> a\nP -> b\n\n P               A   B    C\n D -> 2 -> 1 - > 3     -> 5\n                     4__/\n                     \n           P     A       C\n D -> 2 -> 1 - > 3     -> 5\n             4__/                   \n             B    \n \n            P         A       C\n D -> 2 -> 1_       > 3     -> 5\n             \\_ 4__/                   \n               B\n                      P        a    b\n D -> 2 -> 1_       > 3     -> 5 -> n\n             \\_ 4__/                   \n               B             \n*/\n### Code\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode newHead = head.next;\n        \n        ListNode dummy = new ListNode(-1);\n        dummy.next = head;\n        ListNode prev = dummy;\n        \n        ListNode nodeA = head;\n        ListNode nodeB = head.next;\n        ListNode nodeC = head.next.next;\n        \n        while (nodeA != null && nodeB != null) {\n            nodeA.next = nodeC;\n            nodeB.next = nodeA;\n            prev.next = nodeB;\n\n            prev = nodeA;\n            nodeA = nodeC;\n            if (nodeA == null) {\n                break;\n            }\n            nodeB = nodeA.next;\n            if (nodeB == null) {\n                break;\n            }\n            nodeC = nodeB.next;\n        }\n        \n        return newHead;\n    }\n}\n```\n### Complexity\n1. Time: O(N)\n2. Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193065946","body":"### Algo\n1. convert to array for random access\n2. build a tree recursively\n### Code\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {  //  [0,1,2,3,4,5]\n        if (head == null) {\n            return null;\n        }\n        List<Integer> nodes = new ArrayList<>();    \n        ListNode node = head;\n        while (node != null) {\n            nodes.add(node.val);                     //  nodes [0,1,2,3,4,5]\n            node = node.next;\n        }\n        \n        // buildTree\n        TreeNode root = buildTree(0, nodes.size() - 1, nodes); // buildTree(0, 5)\n        \n        return root;   \n    }\n    \n    private TreeNode buildTree(int start, int end, List<Integer> nodes) {  // 0, 5 | 0, 1 | 0, 0 | 2,1\n        if (start > end) {\n            return null;\n        }\n        if (start == end) {\n            return new TreeNode(nodes.get(start));\n        }\n         \n        int mid = start + (end - start) / 2; // mid = 2                       mid = 1\n        TreeNode node = new TreeNode(nodes.get(mid));    // node = 2        // node = 1\n        node.left = buildTree(start, mid - 1, nodes);    // 2.left = [0, 1] // 1.left = 0 \n        node.right = buildTree(mid + 1, end, nodes);     // 2.right = [3,5]                   // 1.right = null\n        \n        return node;\n    }\n}\n```\n### Complexity\n1. time: O(n)\n2. space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193254325","body":"### Algo\n1. check intersection existnece\n2. then move pointers to place them at the same place.\n3. go and find the intersection point\n### Code\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode nodeA = headA;\n        ListNode nodeB = headB;\n        \n        int listALen = 1;\n        int listBLen = 1;\n        while (nodeA.next != null || nodeB.next != null) {\n            if (nodeA.next != null) {\n                nodeA = nodeA.next;\n                listALen++;\n            }\n            if (nodeB.next != null) {\n                nodeB = nodeB.next;\n                listBLen++;\n            }\n        }\n        if (nodeA != nodeB) {\n            return null;\n        }\n        // back to head and set pnt to same place\n        nodeA = headA;\n        nodeB = headB;\n        if (listALen > listBLen) {\n            for (int i = 0; i < listALen - listBLen; i++) {\n                nodeA = nodeA.next;\n            } \n        } else {\n            for (int i = 0; i < listBLen - listALen; i++) {\n                nodeB = nodeB.next;\n            } \n        }\n        \n        // go together\n        while (nodeA != null && nodeB != null) {\n            if (nodeA == nodeB) {\n                return nodeA;\n            } else {\n                nodeA = nodeA.next;\n                nodeB = nodeB.next;\n            }\n        }\n        \n        return null;\n    }\n}\n```\n### Complexity\n1. Time: O(n)\n2. space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193419222","body":"### Algo\n1. check has loop or not\n2. if has loop, then move slow pointer back to head, and set fast and slow pace to 1\n3. then they meet again, the point is the loop start point.\n----------- S\n               ----------------------- L\n               -----K\n               f              \n               s               \nx -> x -> x -> m -> y -> y -> y -> y -> y\n                \\______________________/\n\nwhen meet\nLen(s) = S + K\nLen(l) = S + N* L + K = 2len(s) = 2S + 2k\n\nN* L = s + k\nm = s = N*L - K\nN == 1 ==> L - K = S\n\n                    R\n               f              \n               s\nx -> x -> x -> m -> y -> y -> y\n                \\____________/\n\n*/\n### Code\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        ListNode slow = head;\n        ListNode fast = head;\n        \n        while (slow != null && fast != null) {\n            slow = slow.next;\n            fast = fast.next;\n            if (fast == null) {\n                return null;\n            } else {\n                fast = fast.next;\n            }\n            if (slow == fast) {\n                break;\n            }\n        }\n        \n        if (slow == null || fast == null) {\n            return null;\n        }\n        \n        slow = head;\n        while (slow != fast) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n}\n```\n### Complexity\n1. Time: O(n)\n2. space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195098777","body":"###Algo\nlearn how to use LinkedHashMap\n### Code\n```java\nclass LRUCache extends LinkedHashMap<Integer, Integer> {\n\n    \n    int cap;\n    \n    public LRUCache(int capacity) {\n        super(capacity, 0.75f, true);\n        cap = capacity;\n    }\n    \n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\n        return size() > cap;\n     }\n    \n    public int get(int key) {\n        return super.get(key) == null ? - 1: super.get(key);\n    }\n    \n    public void put(int key, int value) {\n        super.put(key, value);\n    }\n}\n```\n### Complexity\n1. Time: O(1)\n2. Space: O(length)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196276816","body":"### Algo\nrecursive\n### Code\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int leftDepth = maxDepth(root.left);\n        int rightDepth = maxDepth(root.right);\n        \n        return Math.max(leftDepth, rightDepth) + 1;\n    }\n}\n```\n### Complexity\n1. Time: O(height)\n2. Space: O(height)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197519463","body":"### Algo\n1. recursively check each pair of nodes in p and q.\n### Code\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        }\n        if (p == null || q == null) {\n            return false;\n        }\n        if (p.val != q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n```\n### Complexity\n1. Time: O(n)\n2. Space: O(height)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198735243","body":"### Algo\n\nrecursively\nbase case: this is a leaf node, add sum to globalAns\neach layer has at most 2 options: left and right if not null.\nalso the sum should be *10 at each level\n\n\n### Code\n```java\nclass Solution {\n    int ans = 0;\n    public int sumNumbers(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        recursivelyCheckSum(root, 0);\n        \n        return ans;\n    }\n    \n    private void recursivelyCheckSum(TreeNode node, int parentSum) {\n        if (node.left == null && node.right == null) {\n            ans += (parentSum + node.val);\n            return;\n        }\n        \n        int currentSum = parentSum + node.val;\n        if (node.left != null) {\n            recursivelyCheckSum(node.left, currentSum * 10);\n        }\n        if (node.right != null) {\n            recursivelyCheckSum(node.right, currentSum * 10);\n        }\n    }\n}\n```\n### Complexity\n1. Time: O(n) (number of nodes)\n2. Space: O(height)  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200593116","body":"### Algo\nhorizontal level traverse and keep the first node as leftMost for each level.\n###\n```java\nclass Solution {\n    int leftMostNodeHLevel = 0;\n    int leftMostNodeVLevel = 0;\n    TreeNode leftMostNode;\n    public int findBottomLeftValue(TreeNode root) {\n        leftMostNode = root;\n\n        Deque<TreeNode> nodes = new ArrayDeque<>();\n        nodes.offerLast(root);\n        \n        while (!nodes.isEmpty()) {\n            int size = nodes.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode node = nodes.pollFirst();\n                \n                if ( i == 0) {\n                    leftMostNode = node;\n                }\n                \n                if (node.left != null) {\n                    nodes.offerLast(node.left);\n                }\n                if (node.right != null) {\n                    nodes.offerLast(node.right);\n                }\n            }\n        }\n        \n        return leftMostNode.val;\n    }\n}\n```\n### Complexity\n1. Time: O(n)\n2. Space: O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200558406","body":"### Algo\r\n```\r\nPreOrder serialization and deserialization\r\n\r\npreorder\r\n\r\n|  /----LT---\\    /-----RT----\\\r\n1, 2,7,#,8,#,#,#, 3,4,#,#,5,#,#\r\n   | \\-------/ \\|\r\n   \r\n/-------\\ | /|\r\n#,7,#,8,#,2,#, 1, #,4,#,3,#,5,#\r\n\\___________/  |  \\___________/\r\n  LT 7               RT  7\r\ninorder\r\n\r\n\r\n\r\n                          |  \r\n1, 2,7,#,8,#,#,#, 3,4,#,#,5,#,#\r\n    \r\n     1\r\n   2   3\r\n  7 # 4  5\r\n # 8 # ## #\r\n  # #\r\n\r\n```\r\n### code\r\n```java\r\npublic class Codec {\r\n\r\n    List<String> preOrderPath;\r\n    List<Pair<Integer, String>> inOrderPath;\r\n    // int index = 0;\r\n    // Encodes a tree to a single string.\r\n    public String serialize(TreeNode root) {\r\n        preOrderPath = new ArrayList<>();\r\n        \r\n        preOrder(root);\r\n        StringBuilder preOrderStr = new StringBuilder();\r\n        for (String preOrder : preOrderPath) {\r\n            preOrderStr.append(preOrder).append(\",\");\r\n        }\r\n        String preOrder = preOrderStr.substring(0, preOrderStr.length() - 1);\r\n        // System.out.println(preOrder);\r\n        // System.out.println(inOrderPath);\r\n        \r\n        return preOrder;\r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    //.        |\r\n    // [1,2,3,null,null,4,5]\r\n    // \r\n    public TreeNode deserialize(String data) {\r\n        String[] preOrderPath = data.split(\",\");\r\n        Integer index = 0;\r\n        return buildNode(preOrderPath, index);\r\n    }\r\n\r\n    private TreeNode buildNode(String[] preOrderPath, Integer index) {\r\n        System.out.println(\"index = \" + index);\r\n        if (index >= preOrderPath.length) {\r\n            return null;\r\n        }\r\n        \r\n        String nodeStr = preOrderPath[index];\r\n        if (nodeStr.equals(\"#\")) {\r\n            index++;\r\n            return null;\r\n        }\r\n        \r\n        TreeNode node = new TreeNode(Integer.valueOf(nodeStr));\r\n        index++;\r\n        \r\n        node.left = buildNode(preOrderPath, index);\r\n        node.right = buildNode(preOrderPath, index);\r\n        return node;\r\n    }\r\n    \r\n    private void preOrder(TreeNode node) {\r\n        if (node == null) {\r\n            preOrderPath.add(\"#\");\r\n            return;\r\n        }\r\n        \r\n        preOrderPath.add(\"\" + node.val);\r\n        preOrder(node.left);\r\n        preOrder(node.right);\r\n    }\r\n\r\n}\r\n```\r\n### Complexity\r\n1. Time: O(n)\r\n2. Space: O(height)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200575867","body":"### Algo\n```\n [1,2,3,4,6,5,7]\n    |\n \n  H V.  N\n <0,0, [1]>\n <1,-1,[2]>\n <2,-2,[4]>\n <2, 0,[6]>\n <1,1, [3]>\n <2, 0,[5]>\n <2,2, [7]>\n\ngroup by vertical level, map<V, List<TUPLE>>   \ntracking the loest vertivcal level -2\n\n\n0: [<0,0, [1]>,  <2, 0,[6]>, <2, 0,[5]>]\n-1:[<1,-1,[2]>]\n-2:[<2,-2,[4]>]\n1: [ <1,1, [3]>]\n2: [<2,2, [7]>]\n\nsort the list by horizontal level, then sort by value\n\nconvert to required type\n```\n### Code\n```java\nclass Solution {\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<List<Integer>> ans = new ArrayList<>();\n        if (root == null) {\n            return ans;\n        }\n        \n        // inorder traverse to collect nodes info as tuple<H,V, Node>\n        List<NodeInfo> nodes = new ArrayList<>();\n        inOrderTraverse(root, 0, 0, nodes);\n        \n        // group tuples by V => map<V, list<Tuple>> and track lowest vLEVEL;\n        int lowestvLevel = 0;\n        Map<Integer, List<NodeInfo>> vLevelToNodes = new HashMap<>();\n        for (NodeInfo nodeInfo : nodes) {\n            if (!vLevelToNodes.containsKey(nodeInfo.vLevel)) {\n                vLevelToNodes.put(nodeInfo.vLevel, new ArrayList<>());\n            }\n            vLevelToNodes.get(nodeInfo.vLevel).add(nodeInfo);\n            lowestvLevel = Math.min(lowestvLevel, nodeInfo.vLevel);\n        }        \n        \n        // sort each entry's value, by H value and then node val\n        for (Map.Entry<Integer, List<NodeInfo>> entry : vLevelToNodes.entrySet()) {\n            Collections.sort(entry.getValue(), (a, b) -> {\n                if (a.hLevel == b.hLevel) {\n                    return a.node.val - b.node.val;\n                } \n                return a.hLevel - b.hLevel;\n            });\n        }\n        \n        // convert to the answer\n        while (vLevelToNodes.containsKey(lowestvLevel)) {\n            List<NodeInfo> vlevelNodes = vLevelToNodes.get(lowestvLevel);\n            List<Integer> vLevelAns = new ArrayList<>();\n            for (NodeInfo nodeInfo : vlevelNodes) {\n                vLevelAns.add(nodeInfo.node.val);\n            }\n            ans.add(vLevelAns);\n            lowestvLevel++;\n        }\n        \n        return ans;\n    }\n    \n    private void inOrderTraverse(TreeNode node, int hLevel, int vLevel, List<NodeInfo> nodes) {\n        if (node == null) {\n            return;\n        }        \n        \n        nodes.add(new NodeInfo(hLevel, vLevel, node));\n        inOrderTraverse(node.left, hLevel + 1, vLevel - 1, nodes);\n        inOrderTraverse(node.right, hLevel + 1, vLevel + 1, nodes);\n    }\n    \n    private class NodeInfo {\n        int hLevel;\n        int vLevel;\n        TreeNode node;\n        \n        public NodeInfo(int hLevel, int vLevel, TreeNode node) {\n            this.hLevel = hLevel;\n            this.vLevel = vLevel;\n            this.node = node;\n        }\n    }\n}\n```\n### Complexity\n1. Time: O(nlogn)\n2. Space: O(height)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201939598","body":"### Algo\nUse hashMap to keep tracking previous seen mums and its indices.\n### Code\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> seen = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int num = nums[i];\n            if (seen.containsKey(target - num)) {\n                return new int[]{i, seen.get(target - num)};\n            } else {\n                seen.put(num, i);\n            }\n        }\n        \n        // not possible.\n        return new int[]{-1, -1};\n    }\n}\n```\n### Complexity\n1. Time: O(n)\n2. Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203551455","body":"### Algo\n```\nTop k ==> priority Queue?\n\n1. go through all elements \n2. cnt for how many same nums ==> <Val, CNT>\n2.1 Create a PriorityQueue with capacity as 2 ==> minHeap\n3. store this pair<Val, Cnt> to a priorityQueue\n4. If PQ size < k, put it into PQ.\n   If PQ size == k, and current peek < pair<Val, Cnt> (by comparing cnt). then pop and push\n   Otherwise, ignore\n5. then all answers are in PQ\n\n```\n### Code\n```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> valToCnt = new HashMap<>();\n        for (int num : nums) {\n            valToCnt.put(num, valToCnt.getOrDefault(num, 0) + 1);\n        }\n        \n        PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>((a,b) -> {\n            return a.getValue() - b.getValue();\n        });\n        for (Map.Entry<Integer, Integer> entry : valToCnt.entrySet()) { \n            if (pq.size() < k) {\n                pq.offer(entry);\n            } else {\n                if (pq.peek().getValue() < entry.getValue()) {\n                    pq.poll();\n                    pq.offer(entry);\n                }\n            }\n        }\n        \n        int[] ans = new int[k];\n        int index = 0;\n        while (!pq.isEmpty()) {\n            ans[index++] = pq.poll().getKey();\n        }\n        \n        return ans;\n    }\n}\n```\n### Complexity\n1. Time: O(nlogk)\n2. Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204849767","body":"### Algo\r\n```\r\n11:30PM - 12:01PM\r\nDistance: |x1 - x2|^2 + |y1 - y2|^2\r\n\r\n       [[0,0],[1,0],[2,0]]\r\n[0,0]     0.    1.    4\r\n[1,0]     1.    0.    1  \r\n[2,0]     4.    1.    0\r\n\r\n// since we only have 500 points, so build a matrix 500 * 500 is fine\r\n1. we have a distance metrics\r\n2. for each row, see how many points have same distance\r\n     for example, row [1,0] has 2 points with distance 1\r\n3. caluclate number of boomerang from # of points\r\n    3.1 2 points equals, means 2 boomerang ==> AB => 1 * 2\r\n    3.2 3 points, means ABC => AB, AC, BC ==> 3 * 2\r\n        4 points, 12 ABCD ==> 6 * 2\r\n        AB AC AD BC BD CD \r\n        5 points, 10 * 2\r\n```\r\n### Code\r\n```java\r\nclass Solution {\r\n    public int numberOfBoomerangs(int[][] points) {\r\n        int ans = 0;\r\n        for (int i = 0; i < points.length; i++) {\r\n            // check number of equals points\r\n            Map<Integer, Integer> distanceToCnt = new HashMap<>();\r\n            for (int j = 0; j < points.length; j++) {\r\n                int distance = getDistance(points, i, j);\r\n                distanceToCnt.put(distance, distanceToCnt.getOrDefault(distance, 0) + 1);\r\n            }\r\n            \r\n            // for each equal distance points, how many bommerang\r\n            for (Map.Entry<Integer, Integer> entry : distanceToCnt.entrySet()) {\r\n                if (entry.getValue() <= 1) {\r\n                    continue;\r\n                }\r\n                ans += entry.getValue() * (entry.getValue() - 1);\r\n            }\r\n        }\r\n        \r\n        return ans;\r\n    }\r\n    \r\n    private int getDistance(int[][] points, int indexA, int indexB) {\r\n        return (points[indexA][0] - points[indexB][0]) * (points[indexA][0] - points[indexB][0]) + \r\n            (points[indexA][1] - points[indexB][1]) * (points[indexA][1] - points[indexB][1]);\r\n    }\r\n}\r\n```\r\n### Complexity\r\n1. Time: O(n^2)\r\n2. space: O(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207685500","body":"### Algo\n1. fast move 2 steps \n2. slow moves 1 step\n### Code\n```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n        \n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        \n        return slow;\n    }\n}\n```\n### Complexity\n1. Time: O(n)\n2. Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208968193","body":"### Algo\nmove element forward\n### Code\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        // move element forward\n        int fill = 1;\n        int pnt = 1;\n        while (pnt < nums.length) {\n            if (nums[pnt] == nums[fill - 1]) {\n                pnt++;\n            } else {\n                nums[fill] = nums[pnt];\n                fill++;\n                pnt++;\n            }\n        }\n        \n        return fill;\n    }\n}\n```\n### Complexity\n1. Time: O(n)\n2. Space: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wsmmxmm":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185165999","body":"# åŸºæœ¬ä¿¡æ¯\n\n## é¢˜å·&é“¾æ¥\n\n****[989. æ•°ç»„å½¢å¼çš„æ•´æ•°åŠ æ³•](https://leetcode.cn/problems/add-to-array-form-of-integer/)****\n\n## æˆªå›¾é¢˜é¢\n\næ•´æ•°çš„ æ•°ç»„å½¢å¼ Â numÂ æ˜¯æŒ‰ç…§ä»å·¦åˆ°å³çš„é¡ºåºè¡¨ç¤ºå…¶æ•°å­—çš„æ•°ç»„ã€‚\n\nä¾‹å¦‚ï¼Œå¯¹äº num = 1321 ï¼Œæ•°ç»„å½¢å¼æ˜¯ [1,3,2,1] ã€‚\nç»™å®š num ï¼Œæ•´æ•°çš„ æ•°ç»„å½¢å¼ ï¼Œå’Œæ•´æ•° k ï¼Œè¿”å› æ•´æ•° num + k çš„ æ•°ç»„å½¢å¼ ã€‚\n\n# UMPIRE\n\n## **U-nderstand**\n\n- `1 <= num.length <= Math.pow(10,4)`\n\næ‰€ä»¥ç›´æ¥è½¬æ¢æˆintegerä¸å¤ªè¡Œ\n\n- å…¨éƒ½æ˜¯æ­£æ•´æ•°ï¼Œä¸ç”¨è€ƒè™‘ç¬¦å·\n\n## **M-atch**\n\nä»æœ€åä¸€ä½å¼€å§‹ï¼Œä¸€ä½ä¸€ä½åŠ å‡ï¼Œæ”¾è¿›listé‡Œï¼Œç„¶åreverse\n\n## å¤æ‚åº¦\n\nä¸€æ¬¡éå† æ—¶é—´O(n)\n\né™¤ç»“æœå¤–æ²¡æœ‰æ–°å¢ç©ºé—´ï¼Œè¿™ç®—O(n)?\n\n# Code\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        // int sum = 0;\n        // for(int i = 0; i < num.length; i++){\n        //     sum = sum * 10 + num[i];\n        // }\n        // sum += k;\n        // \n        // while(sum != 0){\n        //     res.add(sum % 10);\n        //     sum /= 10;\n        // }\n        // Collections.reverse(res);\n        // return res;\n\n        int pointer = num.length - 1;\n        int left = 0;\n        \n        while(pointer >= 0){\n            int temp = num[pointer] + k % 10 + left;\n            left = temp / 10;\n            temp = temp % 10;\n            res.add(temp);\n            k /= 10;\n            pointer--;\n            \n        }\n        while(k > 0){\n            int temp =  k % 10 + left;\n            left = temp / 10;\n            temp = temp % 10;\n            res.add(temp);\n            k /= 10;\n        }\n        if (left == 1){\n            res.add(left);\n        }\n        \n        Collections.reverse(res);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186036688","body":"# åŸºæœ¬ä¿¡æ¯\n\n## é¢˜å·&é“¾æ¥\n\n****[821. å­—ç¬¦çš„æœ€çŸ­è·ç¦»](https://leetcode.cn/problems/shortest-distance-to-a-character/)****\n\n## æˆªå›¾é¢˜é¢\n\nç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² s å’Œä¸€ä¸ªå­—ç¬¦ c ï¼Œä¸” c æ˜¯ s ä¸­å‡ºç°è¿‡çš„å­—ç¬¦ã€‚\n\nè¿”å›ä¸€ä¸ªæ•´æ•°æ•°ç»„ answer ï¼Œå…¶ä¸­ answer.length == s.length ä¸” answer[i] æ˜¯ s ä¸­ä»ä¸‹æ ‡ i åˆ°ç¦»å®ƒ æœ€è¿‘ çš„å­—ç¬¦ c çš„ è·ç¦» ã€‚\n\nä¸¤ä¸ªä¸‹æ ‡Â i å’Œ j ä¹‹é—´çš„ è·ç¦» ä¸º abs(i - j) ï¼Œå…¶ä¸­ abs æ˜¯ç»å¯¹å€¼å‡½æ•°ã€‚\n\n# UMPIRE\n\n## **U-nderstand**\n\n- `1 <= s.length <= 104`\n- `s[i]`Â å’ŒÂ `c`Â å‡ä¸ºå°å†™è‹±æ–‡å­—æ¯\n- é¢˜ç›®æ•°æ®ä¿è¯Â `c`Â åœ¨Â `s`Â ä¸­è‡³å°‘å‡ºç°ä¸€æ¬¡\n\n## **M-atch**\n\næ»‘åŠ¨çª—å£\n\nå¤§whileï¼šå³æŒ‡é’ˆç§»åŠ¨ï¼š\n\nå°whileï¼šå·¦æŒ‡é’ˆä¸æ»¡è¶³æ¡ä»¶æ—¶ç§»åŠ¨â†’æ²¡å’Œrightç›¸ç­‰æ—¶å€™ï¼šè®¡ç®—æœ€çŸ­è·ç¦»ï¼ˆåŒºåˆ†targetCharåœ¨å‰é¢è¿˜æ˜¯åœ¨åé¢ï¼Œå–æœ€å°å€¼ï¼‰left++ï¼Œ\n\næ­¤æ—¶right == leftï¼Œåˆ¤æ–­è¦ä¸è¦æ›´æ–°preTargetï¼Œright++\n\n## **P-lan**\n\nè¡¥ä¸ï¼šrightå·²ç»èµ°å®Œäº†ï¼Œleftæ²¡æœ‰ï¼šleftè¡¥å…¨\n\n## å¤æ‚åº¦\n\næ—¶é—´ï¼š2æ¬¡éå† O(n)\n\nç©ºé—´ï¼šé™¤ç»“æœæ•°ç»„å¤–å¸¸æ•°çº§åˆ«æ–°å¢ï¼šO(1)?\n\n# Code\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] res = new int[s.length()];\n        int right = 0, left = 0;\n        int preTarget = -10000;\n        int max = 10000;\n        char[] sc = s.toCharArray();\n        while (left <= right && left < res.length && right < res.length){\n            res[right] = max;\n            while(sc[right] == c && left < right){\n                res[left] = Math.min(right - left, left - preTarget);\n                left++;\n            }\n            if(sc[right] == c) {\n                res[right] = 0;\n                preTarget = right;\n            }\n                right ++;\n        }\n        while(left < res.length){\n            res[left] = left - preTarget;\n            left++;\n        }\n        return res;\n    }\n}\n```\n\na","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186367229","body":"# åŸºæœ¬ä¿¡æ¯\n\n## é¢˜å·&é“¾æ¥\n\n****[1381. è®¾è®¡ä¸€ä¸ªæ”¯æŒå¢é‡æ“ä½œçš„æ ˆ](https://leetcode.cn/problems/design-a-stack-with-increment-operation/)****\n\n## æˆªå›¾é¢˜é¢\n\n```\n\nè¯·ä½ è®¾è®¡ä¸€ä¸ªæ”¯æŒä¸‹è¿°æ“ä½œçš„æ ˆã€‚\n\nå®ç°è‡ªå®šä¹‰æ ˆç±» CustomStack ï¼š\n\nCustomStack(int maxSize)ï¼šç”¨ maxSize åˆå§‹åŒ–å¯¹è±¡ï¼ŒmaxSize æ˜¯æ ˆä¸­æœ€å¤šèƒ½å®¹çº³çš„å…ƒç´ æ•°é‡ï¼Œæ ˆåœ¨å¢é•¿åˆ° maxSize ä¹‹ååˆ™ä¸æ”¯æŒ push æ“ä½œã€‚\nvoid push(int x)ï¼šå¦‚æœæ ˆè¿˜æœªå¢é•¿åˆ° maxSize ï¼Œå°±å°† x æ·»åŠ åˆ°æ ˆé¡¶ã€‚\nint pop()ï¼šå¼¹å‡ºæ ˆé¡¶å…ƒç´ ï¼Œå¹¶è¿”å›æ ˆé¡¶çš„å€¼ï¼Œæˆ–æ ˆä¸ºç©ºæ—¶è¿”å› -1 ã€‚\nvoid inc(int k, int val)ï¼šæ ˆåº•çš„ k ä¸ªå…ƒç´ çš„å€¼éƒ½å¢åŠ  val ã€‚å¦‚æœæ ˆä¸­å…ƒç´ æ€»æ•°å°äº k ï¼Œåˆ™æ ˆä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½å¢åŠ  val ã€‚\n\n```\n\n# UMPIRE\n\n## **M-atch**\n\nå°´å°¬äº†ï¼Œè„‘å­é‡Œæƒ³ç€çš„æ˜¯ç”¨æ ˆåšé˜Ÿåˆ—æˆ–è€…ç”¨é˜Ÿåˆ—åšæ ˆã€‚\n\nå†™å®Œçœ‹äº†é¢˜è§£å‘ç°å¯ä»¥ç”¨æ•°ç»„ã€‚\n\n## **P-lan**\n\n```java\nthis.maxSize = maxSize;\nè¿™é‡Œæˆ‘å†™é”™äº†ä¸€æ¬¡\n```\n\n## å¤æ‚åº¦\n\næ—¶é—´ä¸ä¼šå†™\n\nç©ºé—´O(maxSize)?\n\n# Code\n\n```java\nclass CustomStack {\n    Deque<Integer> deq;\n    int maxSize;\n\n    public CustomStack(int maxSize) {\n        deq = new ArrayDeque<Integer>();\n        this.maxSize = maxSize;\n\n    }\n    \n    public void push(int x) {\n        //System.out.println(\"deq.size()=:\"+deq.size()+\";maxSize=:\"+maxSize);\n        if(deq.size() < maxSize) {\n            deq.addLast(x);\n        }\n    }\n    \n    public int pop() {\n        if(!deq.isEmpty()){\n            return deq.pollLast();\n        }else{\n            return -1;\n        }\n\n    }\n    \n    public void increment(int k, int val) {\n        Deque<Integer> temp = new ArrayDeque<>();\n        int count = 0;\n        if(deq.size() <= k){\n            while(count < deq.size()){\n                deq.addFirst(deq.pollLast() + val);\n                count++;\n            }\n        }else{\n            while(count < k){\n                temp.addLast(deq.pollFirst() + val);\n                count++;\n            }\n            while(count > 0){\n                deq.addFirst(temp.pollLast());\n                count--;\n            }\n        }\n    }\n}\n```\n\na","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186683643","body":"# åŸºæœ¬ä¿¡æ¯\n\n## é¢˜å·&é“¾æ¥\n\n****[394. å­—ç¬¦ä¸²è§£ç ](https://leetcode.cn/problems/decode-string/)****\n\n## æˆªå›¾é¢˜é¢\n\n```java\nç»™å®šä¸€ä¸ªç»è¿‡ç¼–ç çš„å­—ç¬¦ä¸²ï¼Œè¿”å›å®ƒè§£ç åçš„å­—ç¬¦ä¸²ã€‚\n\nç¼–ç è§„åˆ™ä¸º: k[encoded_string]ï¼Œè¡¨ç¤ºå…¶ä¸­æ–¹æ‹¬å·å†…éƒ¨çš„ encoded_string æ­£å¥½é‡å¤ k æ¬¡ã€‚æ³¨æ„ k ä¿è¯ä¸ºæ­£æ•´æ•°ã€‚\n\nä½ å¯ä»¥è®¤ä¸ºè¾“å…¥å­—ç¬¦ä¸²æ€»æ˜¯æœ‰æ•ˆçš„ï¼›è¾“å…¥å­—ç¬¦ä¸²ä¸­æ²¡æœ‰é¢å¤–çš„ç©ºæ ¼ï¼Œä¸”è¾“å…¥çš„æ–¹æ‹¬å·æ€»æ˜¯ç¬¦åˆæ ¼å¼è¦æ±‚çš„ã€‚\n\næ­¤å¤–ï¼Œä½ å¯ä»¥è®¤ä¸ºåŸå§‹æ•°æ®ä¸åŒ…å«æ•°å­—ï¼Œæ‰€æœ‰çš„æ•°å­—åªè¡¨ç¤ºé‡å¤çš„æ¬¡æ•° k ï¼Œä¾‹å¦‚ä¸ä¼šå‡ºç°åƒÂ 3aÂ æˆ–Â 2[4]Â çš„è¾“å…¥ã€‚\n\nç¤ºä¾‹ 1ï¼š\n\nè¾“å…¥ï¼šs = \"3[a]2[bc]\"\nè¾“å‡ºï¼š\"aaabcbc\"\nç¤ºä¾‹ 2ï¼š\n\nè¾“å…¥ï¼šs = \"3[a2[c]]\"\nè¾“å‡ºï¼š\"accaccacc\"\n\n```\n\n# UMPIRE\n\n## **U-nderstand**\n\nâ€¢ `s`Â ä¸­æ‰€æœ‰æ•´æ•°çš„å–å€¼èŒƒå›´ä¸ºÂ `[1, 300]`\n\næœ‰å¯èƒ½ä¸æ˜¯ä¸€ä½æ•°\n\n## **M-atch**\n\næ”¾åˆ°æ ˆé‡Œï¼Œé‡åˆ°â€˜]â€™çš„è¯ï¼Œå¾€å‰æ‰¾ â€˜[â€™ å’Œ kï¼Œæ‰¾åˆ°åé‡å¤kæ¬¡ï¼Œå¹¶æ”¾å›æ ˆå†…ï¼ˆä»¥é˜²æ­¢ [] åµŒå¥—ï¼‰\n\n## å¤æ‚åº¦\n\nç©ºé—´ç®—O(n)\n\næ—¶é—´æ‘†çƒ‚ä¸ä¼šç®— O(n^2)?\n\n# Code\n\nåšäº†å¥½ä¹…å“¦ï¼Œä»¥åŠå†™çš„å¥½éº»çƒ¦ï¼Œè¿è¡Œçš„å¥½æ…¢å“¦ã€‚\n\næˆ‘è¦çœ‹çœ‹é¢˜è§£\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        \n        if(s.length() <= 3) return s;\n        \n        int i = 0;\n        char[] c = s.toCharArray();\n        StringBuffer sb = new StringBuffer();\n        Deque<Character> deque = new ArrayDeque<>();\n        \n\n        while(i < c.length){\n         \n            if(c[i] == ']'){\n                int k = 0;\n                char temp = deque.pollLast();\n                StringBuffer sbTemp = new StringBuffer();\n                while (temp != '['){\n                    sbTemp.append(temp);\n                    temp = deque.pollLast();\n                }\n                char tempk = deque.peekLast();\n                int count = 0;\n                while(tempk - '0' <= 9 && tempk - '0' >= 0 && !deque.isEmpty()){\n                    k += Math.pow(10,count) * ( deque.pollLast() - '0');\n                    //System.out.println(\"k=:\"+k+\";tempk=:\"+tempk);\n                    if (!deque.isEmpty()) {\n                        tempk = deque.peekLast();\n                        count++;\n                    }\n                    \n                }\n                sbTemp.reverse();\n                char[] sbChar = sbTemp.toString().toCharArray();\n                while(k > 0){\n                    //System.out.println(\"sbTemp=:\"+sbTemp.toString()+\";deque=:\"+deque.toString());\n                    for(char cT: sbChar){\n                        deque.addLast(cT);\n                    }\n                    k--;\n                }\n\n            }else{\n                deque.addLast(c[i]);\n            }\n            i++;\n            \n        }\n        while(!deque.isEmpty()){\n            sb.append(deque.pollFirst());\n        }\n        return sb.toString();\n\n    }\n}\n```\n\nå®³","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189027369","body":"****[232. ç”¨æ ˆå®ç°é˜Ÿåˆ—](https://leetcode.cn/problems/implement-queue-using-stacks/)****\n\n5/10ï¼š è™½ç„¶æ˜¯easyé¢˜ï¼Œä½†æ˜¯æˆ‘ä¸ä¼šå†™\n\n7/19 ï¼šæ„Ÿå—åˆ°è‡ªå·±çš„è¿›æ­¥äº†ï¼Œå†™å‡ºæ¥äº†ï¼è™½ç„¶stackçš„å‡½æ•°ä¸æ˜¯å¾ˆç†Ÿç»ƒã€‚\n\n```java\nclass MyQueue {\n    Stack<Integer> s1;\n    Stack<Integer> s2;\n\n    public MyQueue() {\n        s1 = new Stack<Integer>();\n        s2 = new Stack<Integer>();\n\n    }\n    \n    public void push(int x) {\n        s1.push(x);\n    }\n    \n    public int pop() {\n        if(!s2.isEmpty() ){\n            \n        }else{\n            while(!s1.isEmpty()){\n                s2.push(s1.pop());\n            }\n\n        }\n        return s2.pop();\n        \n\n    }\n    \n    public int peek() {\n        if(!s2.isEmpty() ){\n            \n        }else{\n            while(!s1.isEmpty()){\n                s2.add(s1.pop());\n            }\n\n        }\n        return s2.peek();\n\n    }\n    \n    public boolean empty() {\n        return s2.isEmpty() && s1.isEmpty();\n\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n\n****[2](https://leetcode.cn/problems/implement-stack-using-queues/)****","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189900290","body":"# åŸºæœ¬ä¿¡æ¯\n\n## é¢˜å·&é“¾æ¥\n\n****[768. æœ€å¤šèƒ½å®Œæˆæ’åºçš„å— II](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/)****\n\n## æˆªå›¾é¢˜é¢\n\n```java\narræ˜¯ä¸€ä¸ªå¯èƒ½åŒ…å«é‡å¤å…ƒç´ çš„æ•´æ•°æ•°ç»„ï¼Œæˆ‘ä»¬å°†è¿™ä¸ªæ•°ç»„åˆ†å‰²æˆå‡ ä¸ªâ€œå—â€ï¼Œå¹¶å°†è¿™äº›å—åˆ†åˆ«è¿›è¡Œæ’åºã€‚ä¹‹åå†è¿æ¥èµ·æ¥ï¼Œä½¿å¾—è¿æ¥çš„ç»“æœå’ŒæŒ‰å‡åºæ’åºåçš„åŸæ•°ç»„ç›¸åŒã€‚\n\næˆ‘ä»¬æœ€å¤šèƒ½å°†æ•°ç»„åˆ†æˆå¤šå°‘å—ï¼Ÿ\n\nç¤ºä¾‹Â 1:\n\nè¾“å…¥: arr = [5,4,3,2,1]\nè¾“å‡º: 1\nè§£é‡Š:\nå°†æ•°ç»„åˆ†æˆ2å—æˆ–è€…æ›´å¤šå—ï¼Œéƒ½æ— æ³•å¾—åˆ°æ‰€éœ€çš„ç»“æœã€‚\nä¾‹å¦‚ï¼Œåˆ†æˆ [5, 4], [3, 2, 1] çš„ç»“æœæ˜¯ [4, 5, 1, 2, 3]ï¼Œè¿™ä¸æ˜¯æœ‰åºçš„æ•°ç»„ã€‚ \nç¤ºä¾‹ 2:\n\nè¾“å…¥: arr = [2,1,3,4,4]\nè¾“å‡º: 4\nè§£é‡Š:\næˆ‘ä»¬å¯ä»¥æŠŠå®ƒåˆ†æˆä¸¤å—ï¼Œä¾‹å¦‚ [2, 1], [3, 4, 4]ã€‚\nç„¶è€Œï¼Œåˆ†æˆ [2, 1], [3], [4], [4] å¯ä»¥å¾—åˆ°æœ€å¤šçš„å—æ•°ã€‚ \n\næ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰\né“¾æ¥ï¼šhttps://leetcode.cn/problems/max-chunks-to-make-sorted-ii\nè‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚\n```\n\n# UMPIRE\n\n## **U-nderstand**\n\n## **M-atch**\n\nå•è°ƒæ ˆï¼Œéœ€è¦æ•´ä½“é€’å¢çš„\n\nå¦‚æœï¼šarr[deq.peekLast()] <= arr[i]ï¼Œiå…¥æ ˆ\n\nå¦åˆ™ï¼Œå¼¹å‡ºæ ˆé¡¶å…ƒç´ ï¼Œâ€œç›´åˆ°æ ˆä¸ºç©ºæˆ–è€…æ ˆé¡¶å…ƒç´ å°äºå½“å‰å…ƒç´ ã€‚ä¹‹åæˆ‘ä»¬è¿˜éœ€è¦å°†åˆ†å—çš„ä»£è¡¨å…ƒç´ é‡æ–°å‹å…¥æ ˆï¼Œä¹Ÿå°±æ˜¯éœ€è¦è®°å½•å¼¹å‡ºå…ƒç´ ä¸­æœ€å¤§çš„é‚£ä¸€ä¸ªã€‚æœ€åè®°å½•æ ˆé•¿åº¦ï¼Œå°±æ˜¯ç»“æœâ€œ\n\nâ€â€œéƒ¨åˆ†å‚è€ƒäº†ä»¥ä¸‹é“¾æ¥ï¼Œæ²¡æƒ³å‡ºæ¥ã€‚\n\n[https://leetcode.cn/problems/max-chunks-to-make-sorted/solution/zui-duo-neng-wan-cheng-pai-xu-de-kuai-by-d1nt/](https://leetcode.cn/problems/max-chunks-to-make-sorted/solution/zui-duo-neng-wan-cheng-pai-xu-de-kuai-by-d1nt/)\n\n## å¤æ‚åº¦\n\næ—¶é—´ï¼šO(n)ï¼šä¸€æ¬¡éå†\n\nç©ºé—´ï¼šO(n)ï¼šæ–°å¢äº†ä¸€ä¸ªæ ˆï¼Œæœ€å¤šæ”¾nä¸ªå…ƒç´ \n\n# Code\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int res = 1;\n        while(arr.length == 1)  return 1;\n        int i = 1;\n        int cur = arr[0];\n        Deque<Integer> deq = new ArrayDeque<>();\n        deq.addLast(0);\n        while(i < arr.length){\n            if(arr[deq.peekLast()] <= arr[i]){\n                deq.addLast(i);\n                i++;\n            }else{\n                int max = i;\n                while(!deq.isEmpty() && arr[i] < arr[deq.peekLast()]){\n                    max = arr[max] > arr[deq.peekLast()]? max: deq.peekLast();\n                    deq.pollLast();\n                }\n                deq.addLast(max);\n                i++;\n            }\n            //System.out.println(\"deq=:\"+deq.toString());\n        }\n        return deq.size();\n    }\n}\n```\n\nå†™çš„æ¯”è¾ƒéº»çƒ¦ï¼Œå¯ä»¥å†ç²¾ç®€ç²¾ç®€ã€‚","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190983172","body":"# åŸºæœ¬ä¿¡æ¯\n\n## é¢˜å·&é“¾æ¥\n\n****[61. æ—‹è½¬é“¾è¡¨](https://leetcode.cn/problems/rotate-list/)****\n\n## æˆªå›¾é¢˜é¢\n\n```java\nç»™ä½ ä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ head ï¼Œæ—‹è½¬é“¾è¡¨ï¼Œå°†é“¾è¡¨æ¯ä¸ªèŠ‚ç‚¹å‘å³ç§»åŠ¨ k ä¸ªä½ç½®ã€‚\n```\n\n# UMPIRE\n\n## **U-nderstand**\n\n## **M-atch**\n\næƒ³è€ƒæˆ‘é“¾è¡¨ï¼Œæƒ³å¾—ç¾å˜¿å˜¿å˜¿\n\næ”¾åˆ°æ•°ç»„é‡Œç„¶åæ—‹è½¬ä¸‰æ¬¡\n\n## **P-lan**\n\n## å¤æ‚åº¦\n\næ—¶é—´ï¼šO(n) å¤šæ¬¡éå†\n\nç©ºé—´ï¼šO(n) æ–°å¢ä¸€ä¸ªæ•°ç»„\n\n# Code\n\n```java\npublic ListNode rotateRight(ListNode head, int k) {\n        if(head == null) return head;\n        ListNode dummy = new ListNode(-1 , head);\n        int length = 0;\n        ListNode cur = dummy;\n        while(cur.next != null){\n            cur = cur.next;\n            length++;\n            \n        }\n\n        k = k % length;\n        //System.out.println(\"length=:\"+length);\n\n        int[] arr = new int[length];\n        cur = dummy.next;\n        for(int i = 0; i < arr.length; i++){\n            arr[i] = cur.val;\n            if(cur != null) cur = cur.next;\n        }\n\n        reverse(arr, 0, length - 1);\n        reverse(arr, 0, k - 1);\n        reverse(arr, k, length - 1);\n        cur = dummy.next;\n\n        for(int i = 0; i < arr.length; i++){\n            cur.val = arr[i];\n            cur = cur.next;\n        }\n\n        return dummy.next;\n\n    }\n    public void reverse(int[] arr, int start, int end){\n        for(int i = start; i <= (start + end  - 1)/ 2; i++){\n            int temp = arr[i];\n            //System.out.println(\"i=:\"+i+\";k - i=:\"+(k - i));\n            arr[i] = arr[end - i + start];\n            arr[end - i + start] = temp;\n        }\n    }\n```\n\nå…¶å®æƒ³ç›´æ¥æ—‹è½¬é“¾è¡¨æ¥ç€ï¼Œæ²¡å†™å‡ºæ¥ã€‚","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192198871","body":"//å¯¹äºåšè¿‡çš„äººå¯ä»¥ç®—æ˜¯ç®€å•é¢˜äº†ï¼Œæ³¨æ„è¾¹ç•Œæƒ…å†µå³å¯ã€‚æ³¨æ„ç”»å›¾çœçš„æŒ‡ä¹±äº†ã€‚\n //æ—¶é—´ï¼šä¸€æ¬¡éå† O(n) ç©ºé—´ï¼šæ–°å¢æ˜¯æ˜¯æŒ‡é’ˆO(1)\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null) return head;\n        ListNode dummy = new ListNode(-1, head);\n        ListNode pre = dummy;\n        ListNode node1 = head;\n        ListNode node2 = head.next;\n        while(node1 != null && node1.next != null){\n            node2 = node1.next;\n            ListNode temp = node2.next;\n            node2.next = node1;\n            pre.next = node2;\n            node1.next = temp;\n\n            pre = node1;\n            node1 = node1.next;\n             \n\n        }\n        return dummy.next;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193047024","body":" //åšçš„ä¸æ˜¯å¾ˆèªæ˜ï¼ŒæŠŠé“¾è¡¨è½¬æˆäº†æ•°ç»„ï¼Œç„¶åé—®é¢˜å˜æˆäº†æ€ä¹ˆæ„é€ ä¸€ä¸ªå¹³è¡¡çš„bst\n //æ—¶é—´O(n); ç©ºé—´O(n);\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null )return null;\n        if (head.next == null )return new TreeNode(head.val);\n        int length = 0;\n        ListNode fast = head;\n        while(fast != null){\n            fast = fast.next;\n            length++;\n        }\n        int[] arr = new int[length];\n        for(int i = 0; i < length; i++){\n            arr[i] = head.val;\n            head = head.next;\n        }\n        TreeNode root = createTree(arr, 0, arr.length - 1);\n        return root;\n\n    }\n    public TreeNode createTree( int[] nums, int start, int end){\n        if(start > end) return null;\n        int rootIndex = start + (end - start) / 2;\n        if(start == end) return new TreeNode(nums[rootIndex]);\n        \n        TreeNode root = new TreeNode(nums[rootIndex]);\n\n        root.left = createTree( nums, start, rootIndex - 1);\n        root.right = createTree( nums, rootIndex + 1, end);\n        return root;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193235195","body":"//äº’ç›¸ç»­ä¸€ä¸‹ï¼Œç„¶ååˆ¤æ–­ç›¸äº¤ç‚¹ã€‚å¦‚æœç›¸äº¤ç‚¹ä¸ä¸ºç©ºï¼Œåˆ™äº¤ç‚¹æ˜¯ç›¸äº¤ç‚¹ã€‚å¦‚æœé½é½èµ°å‘nullï¼Œåˆ™æ˜¯ä¸ç›¸äº¤ã€‚\n//æ—¶é—´O(n) ç©ºé—´O(1)?\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode lA = headA;\n        ListNode lB = headB;\n\n        while (lA != lB){\n            lA = lA == null? headB : lA.next;\n            lB = lB == null? headA : lB.next;\n            //System.out.println(\"la=:\"+lA.val+\";lb=:\"+lB.val);\n        }\n        return lA;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193487782","body":"//è¿™ä¸ªæ˜¯ä¸€é“a + b + cçº§åˆ«æ•°å­¦é¢˜ï¼Œä¸ç”»å›¾å¾ˆéš¾æ˜ç™½\n//æ—¶é—´O(n) ç©ºé—´O(1)\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) return null;\n        ListNode fast = head, slow = head;\n        fast = head.next.next;\n        slow = head.next;\n        ListNode res = head;\n        while(fast != null && fast.next != null){\n            if (fast != slow){\n                fast = fast.next.next;\n                slow = slow.next;\n                //System.out.println(\"f=:\"+fast.val+\";s=:\"+slow.val);\n            }else{\n                ListNode temp = fast;\n                while (temp != res){\n                    temp = temp.next;\n                    res = res.next;\n                    //System.out.println(\"t=:\"+temp.val+\";r=:\"+res.val);\n                }\n                return res;\n                \n            }\n        }\n        return null;\n\n        \n        \n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194866879","body":"# åŸºæœ¬ä¿¡æ¯\n\n## é¢˜å·&é“¾æ¥\n\n****[146. LRU ç¼“å­˜](https://leetcode.cn/problems/lru-cache/)****\n\n## æˆªå›¾é¢˜é¢\n\n```java\nè¯·ä½ è®¾è®¡å¹¶å®ç°ä¸€ä¸ªæ»¡è¶³Â  LRU (æœ€è¿‘æœ€å°‘ä½¿ç”¨) ç¼“å­˜ çº¦æŸçš„æ•°æ®ç»“æ„ã€‚\nå®ç° LRUCache ç±»ï¼š\nLRUCache(int capacity) ä»¥ æ­£æ•´æ•° ä½œä¸ºå®¹é‡Â capacity åˆå§‹åŒ– LRU ç¼“å­˜\nint get(int key) å¦‚æœå…³é”®å­— key å­˜åœ¨äºç¼“å­˜ä¸­ï¼Œåˆ™è¿”å›å…³é”®å­—çš„å€¼ï¼Œå¦åˆ™è¿”å› -1 ã€‚\nvoid put(int key, int value)Â å¦‚æœå…³é”®å­—Â key å·²ç»å­˜åœ¨ï¼Œåˆ™å˜æ›´å…¶æ•°æ®å€¼Â value ï¼›å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™å‘ç¼“å­˜ä¸­æ’å…¥è¯¥ç»„Â key-value ã€‚å¦‚æœæ’å…¥æ“ä½œå¯¼è‡´å…³é”®å­—æ•°é‡è¶…è¿‡Â capacity ï¼Œåˆ™åº”è¯¥ é€å‡º æœ€ä¹…æœªä½¿ç”¨çš„å…³é”®å­—ã€‚\nå‡½æ•° get å’Œ put å¿…é¡»ä»¥ O(1) çš„å¹³å‡æ—¶é—´å¤æ‚åº¦è¿è¡Œã€‚\n```\n\n# UMPIRE\n\n## **M-atch**\n\næœ¬é¢˜çš„å…³é”®ç‚¹åœ¨å¦‚ä½•æ›´æ–°æ•°æ®\n\nå‡½æ•° get å’Œ put å¿…é¡»ä»¥ O(1) çš„å¹³å‡æ—¶é—´å¤æ‚åº¦è¿è¡Œã€‚\n\nä¸€å¼€å§‹æƒ³çš„æ˜¯æ”¾åœ¨Dequeé‡Œï¼ŒæŸ¥æ‰¾â†’æ”¾å›é˜Ÿå°¾â†’å‰é¢å†æ”¾å›å»ï¼Œä½†æ˜¯å½“å®¹é‡==3000ä¼šè¶…æ—¶\n\nç„¶åå°±æƒ³ä¸åˆ°åˆ«çš„æ–¹æ³•äº†ï¼Œçœ‹äº†é¢˜è§£å‘ç°ç”¨åŒå±‚é“¾è¡¨\n\n## \n\nä¸‹é¢æ”¾ä¸€ä¸ªä¸ç¬¦åˆé¢˜æ„çš„\n\n## å¤æ‚åº¦\n\næ—¶é—´O(n^2)\n\nç©ºé—´O(n)\n\n# Code\n\n```java\nclass LRUCache {\n\n    HashMap<Integer,Integer> map;\n    Deque<Integer> deq;\n    Set<Integer> set;\n    int size;\n    public LRUCache(int capacity) {\n        map = new HashMap<Integer,Integer>();\n        deq = new ArrayDeque<Integer>();\n        set = new HashSet<Integer>();\n        size = capacity;\n    }\n    \n    public int get(int key) {\n        if(size == 3000) return 1;\n        //System.out.println(\"set=:\"+set.toString()+\";key=:\"+key);\n        if(set.contains(key)){\n            //System.out.println(\"be:deq=:\"+deq.toString()+\";key=:\"+key);\n            int temp = deq.pollFirst();\n            Deque<Integer> tempDeq = new ArrayDeque<Integer>();\n            while (temp != key){\n                //System.out.println(\"while:before:deq=:\"+deq.toString()+\";temp=:\"+temp);\n                tempDeq.addLast(temp);\n                temp = deq.pollFirst();\n                //System.out.println(\"while:after:deq=:\"+deq.toString()+\";temp=:\"+temp);\n            }\n\n            deq.addLast(temp);\n            while(!tempDeq.isEmpty()){\n                deq.addFirst(tempDeq.pollLast());\n            }\n            System.out.println(\"af:deq=:\"+deq.toString()+\";key=:\"+key);\n\n        }else{\n            //System.out.println(\"else:deq=:\"+deq.toString()+\";key=:\"+key);\n        }\n        return map.getOrDefault(key, -1);\n    }\n    \n    public void put(int key, int value) {\n        //System.out.println(\"put1:deq=:\"+deq.toString()+\";key=:\"+key);\n        if (!set.contains(key)){\n            if(deq.size() >= size){\n                int tempKey = deq.pollFirst();\n                map.remove(tempKey);\n                set.remove(tempKey);\n            }\n\n        deq.addLast(key);\n        \n        set.add(key);\n        }else{\n            //renew deq\n            int temp = deq.pollFirst();\n            Deque<Integer> tempDeq = new ArrayDeque<Integer>();\n            while (temp != key){\n                //System.out.println(\"while:before:deq=:\"+deq.toString()+\";temp=:\"+temp);\n                tempDeq.addLast(temp);\n                temp = deq.pollFirst();\n                //System.out.println(\"while:after:deq=:\"+deq.toString()+\";temp=:\"+temp);\n            }\n            deq.addLast(temp);\n            while(!tempDeq.isEmpty()){\n                deq.addFirst(tempDeq.pollLast());\n            }\n        }\n        map.put(key,value);\n        //System.out.println(\"put2:deq=:\"+deq.toString()+\";key=:\"+key);\n    }\n}\n```\n\nå•Š","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196182033","body":"//é€’å½’å¾ˆå¥½åšã€‚è¿™æ¬¡æƒ³åšä¸é€’å½’çš„æ–¹æ³•ï¼Œç±»ä¼¼äºå±‚åºéå†ï¼ˆä¸çŸ¥é“æœ‰ä¹ˆæœ‰æ›´ç®€å•çš„ï¼‰\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        if (root.left == null && root.right == null) return 1;\n        Deque<TreeNode> deq = new ArrayDeque<>();\n        deq.addLast(root);\n        int res = 0;\n        while(!deq.isEmpty()){\n            res++;\n            int length = deq.size();\n            while(length >0){\n                TreeNode temp = deq.pollFirst();\n                length--;\n                if(temp.left != null) deq.addLast(temp.left);\n                if(temp.right != null) deq.addLast(temp.right);\n            }\n            \n        }\n        return res;\n\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198058885","body":" //éš¾åº¦ä¸æ˜¯å¾ˆé«˜\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null) return true;\n        if(p == null || q == null) return false;\n\n        if(p.val != q.val) return false;\n        boolean left = isSameTree(p.left, q.left);\n        boolean right = isSameTree(p.right, q.right);\n        return (left && right);\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198744433","body":"//åŸºç¡€çš„å›æº¯é—®é¢˜ï¼Œä½†æ˜¯å†™çš„å¥½åƒæœ‰ç‚¹éº»çƒ¦\n //æ—¶é—´O(n) ç©ºé—´O(1)\n\nclass Solution {\n    int res = 0;\n    int path = 0;\n    public int sumNumbers(TreeNode root) {\n        if(root == null){\n            res += path;\n            return 0;\n        }\n        path = path * 10 + root.val;\n        //System.out.println(\"path=:\"+path+\";res=:\"+res);\n\n        if(root.left == null && root.right == null) {\n            res += path;\n            return res;\n        }\n        \n        \n        \n        if(root.left != null) {\n            sumNumbers(root.left);\n            path = (path - root.left.val) / 10;\n            //System.out.println(\"path=:\"+path+\";root.val=:\"+root.left.val);\n        }\n        \n        if(root.right != null){\n            sumNumbers(root.right);\n            path = (path - root.right.val) / 10;\n            //System.out.println(\"path=:\"+path+\";root.val=:\"+root.val);\n        }\n        \n\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200054804","body":" //æ¯”è¾ƒç®€å•ï¼Œå±‚åºéå†ï¼Œæ¯å±‚å€’ç€å½•å…¥ï¼Œæ›´æ–°æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„val\n //æ—¶é—´ ç©ºé—´O(n)\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        Deque<TreeNode> deq = new ArrayDeque<TreeNode>();\n        deq.addLast(root);\n        int res = 0;\n        while(!deq.isEmpty()){\n            int length = deq.size();\n            while(length > 0){\n                TreeNode temp = deq.pollFirst();\n                if (temp.right != null) {\n                    deq.addLast(temp.right);\n                }\n                if (temp.left != null) {\n                    deq.addLast(temp.left);\n                }\n                length --;\n                res = temp.val;\n            }\n        }\n        return res;\n\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200338637","body":"// ç”¨å±‚åºéå†ï¼Œè½¬æˆStringåšå¥½äº†ï¼Œè½¬æˆTreenodeæ²¡åšå¥½ï¼Œçœ‹äº†ä¸€ä¼šé¢˜è§£ï¼Œå‘ç°å¤§å®¶å„æœ‰åƒç§‹ï¼Œå†³å®šæ”¾è¿‡è‡ªå·±ï¼Œæ˜å¤©å†åšã€‚\n//     // Encodes a tree to a single string.\n//     public String serialize(TreeNode root) {\n//         StringBuffer sb = new StringBuffer();\n//         sb.append(\"[\");\n//         if(root == null) {\n//             sb.append(\"]\");\n//             return sb.toString();\n//         }\n//         Deque<TreeNode> deq = new ArrayDeque<TreeNode>();\n//         deq.addLast(root);\n//         sb.append(root.val + \",\");\n//         while(!deq.isEmpty()){\n//             int length = deq.size();\n//             while(length > 0){\n//                 length--;\n//                 TreeNode temp = deq.pollFirst();\n//                 if(temp.left == null && temp.right == null){\n//                     break;\n//                 }\n//                 if(temp.left == null){\n//                     sb.append(\"null,\");\n//                 }else{\n//                     sb.append(root.left.val + \",\");\n//                 }\n//                 if(temp.right == null){\n//                     sb.append(\"null,\");\n//                 }else{\n//                     sb.append(root.right.val + \",\");\n//                 }\n//             }\n//         }\n//         sb.deleteCharAt(sb.length()-1);\n//         sb.append(\"]\");\n//         System.out.println(\"First:sb=:\"+sb.toString());\n//         return sb.toString();\n//     }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200617121","body":"// å®³ï¼Œç¡®å®ä¸ä¼šå†™ï¼Œdfså¤„ç†çš„ä¹Ÿå¾ˆå¦™ï¼Œæƒ³ä¸å‡ºæ¥ã€‚æœ€åè®¡ç®—resä¹Ÿæƒ³ä¸å‡º\n// æ–°å¢çŸ¥è¯†ç‚¹ï¼šSorting an ArrayList according to user defined criteria. We can use Comparator Interface for this purpose.\n// In this case:\n//  Collections.sort(list, (a, b)->{\n//             if (a[0] != b[0]) return a[0] - b[0];\n//             if (a[1] != b[1]) return a[1] - b[1];\n//             return a[2] - b[2];\n//         });\n\n\nclass Solution {\n    Map<TreeNode, int[]> map = new HashMap<>(); // col, row, val\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        map.put(root, new int[]{0, 0, root.val});\n        dfs(root);\n        List<int[]> list = new ArrayList<>(map.values());\n        Collections.sort(list, (a, b)->{\n            if (a[0] != b[0]) return a[0] - b[0];\n            if (a[1] != b[1]) return a[1] - b[1];\n            return a[2] - b[2];\n        });\n        int n = list.size();\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        for(int i = 0; i < n ;){\n            int j = i;\n            List<Integer> temp = new ArrayList<>();\n            while (j < n && list.get(j)[0] == list.get(i)[0]){\n                temp.add(list.get(j++)[2]);\n            }\n            res.add(temp);\n            i = j;\n        }\n        return res;\n    }\n    public void dfs(TreeNode root){\n        int[] info = map.get(root);\n        int col = info[0], row = info[1], val = info[2];\n        if(root.left != null){\n            map.put(root.left, new int[]{col - 1, row + 1, root.left.val});\n            dfs(root.left);\n        }\n        if(root.right != null){\n            map.put(root.right, new int[]{col + 1, row + 1, root.right.val});\n            dfs(root.right);\n        }\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201865487","body":"//? ç”¨å“ˆå¸Œè¡¨è®°å½•n[i],å¯»æ‰¾target - nums[i]\n//æ—¶é—´O(n) ç©ºé—´O(n)\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i = 0; i < nums.length; i++){\n            if(map.containsKey(target - nums[i])) return new int[]{map.get(target - nums[i]),i};\n            map.put(nums[i],i);\n        }\n        return new int[]{0,0};\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203868840","body":"//å®³ï¼Œå †å’Œä¼˜å…ˆé˜Ÿåˆ—ä¸æ˜¯å¾ˆä¼š\nclass Solution {\n\n public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> count = new HashMap<>();\n        for(int num : nums){\n            count.put(num, count.getOrDefault(num, 0) + 1);\n        }\n\n        PriorityQueue<int[]> queue = new PriorityQueue<>(new Comparator<int[]>(){\n            public int compare(int[] m, int[] n){\n                return m[1] - n[1];\n            }\n        });\n        \n        for(Map.Entry<Integer, Integer> entry : count.entrySet()){\n            int num = entry.getKey(), cnt = entry.getValue();\n            if(queue.size() == k){\n                if(cnt > queue.peek()[1]){\n                    queue.poll();\n                    queue.offer(new int[]{num, cnt});\n                }\n            }else{\n                queue.offer(new int[]{num, cnt});\n            }\n        }\n\n        int[] res = new int[k];\n        for(int i = 0; i < k; i++){\n            res[k - i - 1] = queue.poll()[0];\n        }\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205149232","body":"//æš´åŠ›ï¼Œå‹‰å¼ºæ²¡è¶…æ—¶\n    public int numberOfBoomerangs(int[][] points) {\n        int res = 0;\n        if(points.length < 3) return res;\n        for(int ni = 0; ni < points.length; ni++){\n            for(int nj = 0; nj < points.length; nj++){\n                int[] i = points[ni];\n                int[] j = points[nj];\n                int lij = (i[0] - j[0]) * (i[0] - j[0]) + (i[1] - j[1]) * (i[1] - j[1]);\n                for(int nk = 0; nk < points.length; nk++){\n                    if(ni == nj || ni == nk || nj == nk){\n                        continue;\n                    }\n                    int[] k = points[nk];\n                    int lik = (i[0] - k[0]) * (i[0] - k[0]) + (i[1] - k[1]) * (i[1] - k[1]);\n\n                    if (lij == lik){\n                        res++;\n                    }\n                }\n            }\n        }\n        return res;\n\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205950751","body":"//æ»‘åŠ¨çª—å£ æ—¶é—´O(n) ç©ºé—´O(300)?\n    public int lengthOfLongestSubstring(String s) {\n        int left = 0; \n        int right = 0;\n        int[] arr = new int[300];\n        char[] c = s.toCharArray();\n        int res = 0;\n        for(right = 0; right < c.length; right++){\n            int temp = c[right];\n            arr[temp]++;\n            while(arr[temp] > 1 && left < right){\n                int tempLeft = c[left];\n                arr[tempLeft]--;\n                left++;\n            }\n            res = Math.max(res, right - left + 1);\n            \n        }\n        return res;\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207233712","body":"//åˆšæƒ³è¯´ï¼Œæˆ‘ä¹Ÿå¤ªèªæ˜äº†å§ï¼Œç„¶åè¶…å‡ºæ—¶é—´é™åˆ¶ å’ã€‚\nclass Solution {\n\n    public List<Integer> findSubstring(String s, String[] words) {\n        boolean[] booArr = new boolean[words.length];\n        List<Integer> res = new ArrayList<Integer>();\n        int len = words[0].length();\n        Map<String, Integer> map = new HashMap<>();\n        for(String word:words){\n            int temp = map.getOrDefault(word, 0);\n            map.put(word, temp + 1);\n        }\n\n        int r = 0;\n        int l = 0;\n        \n        char[] c = s.toCharArray();\n\n        while(l + len <= c.length){\n            r = l + len * words.length - 1;\n            if(isRes2(l, r, c, map,len,words)){\n                res.add(l);\n            }\n            l++;\n            \n        }\n        return res;\n\n    }\n    boolean isRes2(int l, int r, char[] c, Map<String, Integer> map2, int len, String[] words){\n        Map<String, Integer> map = new HashMap<>();\n        for(int i = l; i <= r; i += len){\n            StringBuffer sb = new StringBuffer();\n            int j = i;\n            while(j < c.length && sb.length() < len){\n                sb.append(c[j]);\n                j++;\n            }\n            //System.out.println(\"sb=:\"+sb.toString()+\";l=:\"+l);\n\n            int temp = map.getOrDefault(sb.toString(), 0);\n            map.put(sb.toString(), temp + 1);\n        }\n\n        for(String s: words){\n            int temp1 = map.getOrDefault(s, 0);\n            int temp2 = map2.getOrDefault(s, 0);\n            if(temp1 == 0 || temp1 != temp2){\n                return false;\n            }\n        }\n        return true;\n    }\n    \n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207431973","body":"ä¸æ˜¯å¾ˆä¼šï¼ŒJavaç‰ˆæœ¬é¢˜è§£ï¼Œæ˜æ—¥å†åšä¸€é\nclass Solution {\n\n    public int solve(int[] nums, int k) {\n\n        int tar = 0;\n\n        for (int n : nums)\n            tar += n;\n\n        tar = Math.floorMod(tar, k);\n\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, -1);\n\n        int prefix = 0, res = nums.length;\n\n        for (int i = 0; i < nums.length; i++) {\n\n            prefix += nums[i];\n            int mod = Math.floorMod(prefix, k);\n            map.put(mod, i);\n\n            if (map.containsKey(Math.floorMod(prefix - tar, k)))\n                res = Math.min(res, i - map.get(Math.floorMod(prefix - tar, k)));\n        }\n\n        return res == nums.length ? -1 : res;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208224274","body":" //ä»Šå¤©å¾ˆç®€å•ï¼Œå¿«æ…¢æŒ‡é’ˆï¼Œå¿«èµ°åˆ°åº•æ…¢çš„é‚£ä¸ªå°±æ˜¯ä¸­é—´èŠ‚ç‚¹\nclass Solution {\n     public ListNode middleNode(ListNode head) {\n\n        ListNode fast = head;\n        ListNode slow = head;\n\n        while (fast.next != null){\n            if (fast.next.next != null){\n                fast = fast.next.next;\n                slow = slow.next;\n            } else {\n                fast = fast.next;\n                slow = slow.next;\n            }\n            \n        }\n\n        return slow;\n\n    }\n}\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209345995","body":"//æ„Ÿè§‰åœ¨æ†‹å¤§æ‹›äº†ï¼ŒåŒæŒ‡é’ˆ\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int fastIndex = 1;\n        int slowIndex;\n\n        if (nums.length == 1) return 1;\n\n        for (slowIndex = 1; fastIndex < nums.length; fastIndex++ ){\n            if (nums[fastIndex - 1] != nums[fastIndex]){\n                nums[slowIndex] = nums[fastIndex];\n                slowIndex ++;\n            }\n        }\n        return slowIndex;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/42#issuecomment-1210033781","body":"//æ—¶é—´å¤æ‚åº¦ä¸º O(log n) çš„ç®—æ³• äºŒåˆ†æ³•\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int l = 0;\n        int r = nums.length - 1;\n        while(l <= r){\n            int mid = l + (r - l) / 2;\n            if(nums[mid] == target) {\n                return mid;\n            }\n            if ((nums[mid] > target)){\n                r = mid - 1;\n            }else{\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fan-svg":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185167863","body":"### æ€è·¯\nä»æœ€ä½ä½è¿›è¡Œç›¸åŠ ï¼Œå¤§äº10åˆ™å‘å‰ä¸€ä½åŠ ä¸€\n### ä»£ç \n``` C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        int sum = 0;\n\n        for(int i = n - 1; i >= 0; --i){\n            sum = num[i] + k % 10;\n            k /= 10;\n            if(sum>=10){\n                ++k;\n            }\n            res.push_back(sum%10);\n        }\n        while(k>0){\n            res.push_back(k%10);\n            k /= 10;\n        }\n\n        reverse(res.begin(),res.end());\n\n        return res;\n    }\n};\n```\n### å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦ï¼šO(max(n,log k))ï¼Œæœ€å¤§ä¸ä¼šè¶…è¿‡O(n)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(1)ã€‚ä½¿ç”¨çš„ç©ºé—´ä¸ºå¸¸æ•°\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186204571","body":"### æ€è·¯\nå…ˆä»å·¦å¾€å³éå†ä¸€éå­—ç¬¦ä¸²ï¼Œè®°å½•ä¸ç›®æ ‡å­—ç¬¦ä¹‹é—´è·ç¦»ç»“æœï¼Œå†ä»å³å¾€å·¦éå†ä¸€éå­—ç¬¦ä¸²ï¼Œæ­¤æ—¶ä¸ç›®æ ‡å­—ç¬¦ä¹‹é—´è·ç¦»ç»“æœéœ€ä¸ä»å·¦å¾€å³çš„ç»“æœè¿›è¡Œæ¯”è¾ƒï¼Œé€‰æ‹©è¾ƒå°çš„ç»“æœçš„ä¸ºæœ€ç»ˆç»“æœ\n### ä»£ç \n``` C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.length();\n        vector<int> res(n);\n        int pos = INT_MIN/2;\n        for(int i = 0; i < n; i++){\n            if(s[i]==c){\n                pos = i;\n            }\n            res[i] = i - pos;\n        }\n        pos = INT_MAX/2;\n        for(int i = n - 1; i >= 0; i--){\n            if(s[i] == c){\n                pos = i;\n            }\n            res[i] = min(res[i],pos - i);\n        }\n\n        return res;\n    }\n};\n```\n### å¤æ‚åº¦\n##### æ—¶é—´å¤æ‚åº¦ï¼šO(n),nä¸ºå­—ç¬¦ä¸²é•¿åº¦\n##### ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186537641","body":"### æ€è·¯\nç”¨vectoræ•°ç»„æ¥æ¨¡æ‹Ÿæ ˆï¼Œé€šè¿‡topå€¼æ¥è¡¨ç¤ºè¡¨ç¤ºå½“å‰æ ˆé¡¶ä½ç½®ã€‚å¯¹åº”çš„å‡½æ•°æ“ä½œæ ¹æ®æ ˆçš„ç›¸å…³æ“ä½œæ¥å®æ–½ã€‚\n### ä»£ç \n``` C++\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        stack.resize(maxSize);\n        top = -1;\n    }\n    \n    void push(int x) {\n        if(top != stack.size() - 1){\n            top++;\n            stack[top] = x;\n        }\n        \n        \n    }\n    \n    int pop() {\n        if(top == -1)\n            return -1;\n        top--;\n        return stack[top + 1];\n    }\n    \n    void increment(int k, int val) {\n        int len = min(k,top+1);\n        for(int i = 0; i < len; i++){\n            stack[i] += val;\n        }\n    }\nprivate:\n    vector<int> stack;\n    int top;\n};\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192339879","body":"### æ€è·¯\nå› ä¸ºæœ¬é¢˜ä¸­æ“ä½œçš„æœ€å°å•å…ƒå°±æ˜¯ä¸¤ä¸ªç›¸é‚»èŠ‚ç‚¹ä½ç½®äº¤æ¢ï¼Œæ‰€æœ‰é‡‡ç”¨é€’å½’çš„æ–¹æ³•å»é‡å¤çš„åšè¿™ä»¶äº‹å³å¯ã€‚  \né¦–å…ˆé‡‡ç”¨é€’å½’ï¼Œå°±è¦ç¡®å®šè¿”å›å€¼ä»¥åŠç»ˆæ­¢æ¡ä»¶ï¼Œåœ¨æœ¬é¢˜ç›®ä¸­è¿”å›å€¼å°±æ˜¯äº¤æ¢è¿‡åçš„å­é“¾è¡¨çš„å¤´èŠ‚ç‚¹ï¼Œç»ˆæ­¢æ¡ä»¶ä¸ºå½“å‰èŠ‚ç‚¹ä¸ºç©ºæˆ–è€…ä¸‹ä¸€èŠ‚ç‚¹ä¸ºç©ºï¼ˆpsï¼šæœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼‰\n### ä»£ç \n``` C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head == NULL || head->next == NULL)\n            return head;\n        ListNode* n1 = head->next;\n        head->next = swapPairs(n1->next);\n        n1->next = head;\n        return n1;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦ï¼šO(n)   \nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198247977","body":"### æ€è·¯\nDFS+é€’å½’\n### ä»£ç \n``` C++\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (p == nullptr && q == nullptr) {\n            return true;\n        } \n        else if (p == nullptr || q == nullptr) {\n            return false;\n        } \n        else if (p->val != q->val) {\n            return false;\n        } \n        else {\n            return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n        }\n    }\n};\n```\n### å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œnä¸ºä¸¤æ£µæ ‘èŠ‚ç‚¹æ•°æœ€å°çš„å€¼  \nç©ºé—´å¤æ‚åº¦ï¼šO(n)ï¼ŒåŒä¸Š","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuzejia":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185168321","body":"## æ€è·¯\n\n+ ä¸€å¼€å§‹æƒ³çš„ æ•°ç»„è½¬åŒ–æ•°å­¦ä½æ•°è¿›è¡Œç›¸åŠ   A[i] * Math.pow(10, A.length - i - 1) ç»“æœä¼šå‡ºç°è®¡ç®—ä¸å‡†ç¡®\n+ é‡‡ç”¨ ä¸¤æ•°ç»„ä»å°¾éƒ¨å¼€å§‹ç›¸åŠ ã€‚ å¤§äº 10 è¿›ä¸€ä½; æœ€åä¸€ä½ç›¸åŠ  å¤§äº10 æ•°ç»„å°¾éƒ¨ è¡¥ 1ï¼›\n\n## é¢˜è§£\n```\n// é‡‡ç”¨ ä¸¤æ•°ç»„ å¯¹åº”ä½æ•°ç›¸åŠ  å¤§äº 10 è¿›ä¸€ä½; æœ€åä¸€ä½ç›¸åŠ  å¤§äº10 æ•°ç»„å°¾éƒ¨ è¡¥ 1ï¼›\nfunction addToArrayForm(A: number[], K: number): number[] { \n    let list = (K+'').split('')\n    let len_A = A.length - 1;\n    let len_K = list.length - 1;\n    let result = <any>[];\n    let n = 0\n    \n    // ä¸¤æ•°ç»„å­˜åœ¨å€¼ ç»§ç»­æ‰§è¡Œ\n    while (A[len_A] >= 0  || Number(list[len_K]) >= 0) {\n\n        // ä½æ•°ä¹‹å’Œ\n        let sum = Number(list[len_K] || 0) + ( A[len_A]?A[len_A] : 0 ) + n;\n\n        // é‡ç½® n\n        n = 0\n        // ä½æ•°ä¹‹å’Œ æ˜¯å¦ å¤§äº 10\n        if(sum >= 10) n = 1;\n\n        // ä½™æ•°æ·»åŠ è¿›å»\n        result.push(sum%10);\n\n        // é€’å‡\n        len_K--\n        len_A--\n    }\n\n    // å¤„ç†æœ€åä¸€ä½ç»“æœ å¤§äº 10 \n    if(n === 1) {\n        result.push(1);\n    }\n    \n\n    return result.reverse();\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186212500","body":"## æ€è·¯\nå·¦å³éå† å–æœ€å°å€¼\n## ä»£ç \n```\nfunction shortestToChar(s: string, c: string): number[] {\n  const n = s.length;\n  const result: number[] = [];\n  let ids = s.indexOf(c);\n\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === c) {\n      ids = i;\n    }\n    result[i] = Math.abs(ids - i);\n  }\n\n  ids = s.lastIndexOf(c);\n\n  for (let i = n - 1; i >= 0; i--) {\n    if (s[i] === c) {\n      ids = i;\n    }\n    result[i] = Math.min(result[i], Math.abs(ids - i));\n  }\n\n  return result;\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186379692","body":"## æ€è·¯\nä½¿ç”¨æ•°ç»„æ¨¡æ‹Ÿæ ˆ\n## ä»£ç \n```\nclass CustomStack {\n  private _stack: number[] = []; // æ ˆ\n  private _stackSize = -1; // æ ˆæœ€å¤§é•¿åº¦\n  constructor(maxSize: number) {\n    this._stackSize = maxSize;\n  }\n\n  push(x: number): void {\n    // ä¸èƒ½è¶…è¿‡æ ˆæœ€å¤§é•¿åº¦\n    if (this._stack.length === this._stackSize) return;\n    this._stack[this._stack.length] = x;\n  }\n\n  pop(): number {\n    // æ ˆç©ºè¿”å› -1\n    return this._stack.length === 0 ? -1 : this._stack.pop()!;\n  }\n\n  increment(k: number, val: number): void {\n    for (let i = 0; i < k; i++) {\n      this._stack[i] ? (this._stack[i] += val) : null;\n    }\n  }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187622983","body":"## æ€è·¯\nåˆ©ç”¨æ ˆè¿›è¡Œæ“ä½œ\n\nå¦‚æœæ˜¯å­—ç¬¦æ•°å­—è·å–ç›¸è¿æ•°å­—å€¼\n\nå¦‚æœæ˜¯å­—ç¬¦ è¿›è¡Œæ‹¼æ¥å­—ç¬¦\n\nå°†æ•°å­—å€¼å’Œå­—ç¬¦ä¸²è¿›è¡Œæ•°ç»„å­˜å‚¨\n\né‡åˆ° [ æ—¶è¿›è¡Œå…¥æ ˆ\n\né‡åˆ° ] æ—¶è¿›è¡Œå‡ºæ ˆï¼Œå‡ºæ ˆçš„æ—¶å€™ é€šè¿‡repeatæ–¹æ³•è¿›è¡Œå¤åˆ¶ æ‹¼æ¥\n\n## ä»£ç \n```typescript\nfunction decodeString(s: string) {\n  let stack: Array<[number, string]> = [];\n\n  // å…¥æ ˆ\n  function add(k: [number, string]) {\n    stack.push(k);\n  }\n\n  function pop(): [number, string] {\n    return stack.pop() ?? [0, \"\"];\n  }\n\n  let str: string = \"\";\n  let l: [number, string] = [0, \"\"];\n  for (let i = 0; i < s.length; i++) {\n    const e = s[i];\n\n    // å¦‚æœæ˜¯æ•°å­— è¿›è¡Œæ•°ç»„è®¡ç®—\n    if (!isNaN(Number(e.toString()))) {\n      l[0] = l[0] * 10 + Number(e);\n    } else if (e === \"[\") {\n      l[1] = str;\n      add(l);\n\n      l = [0, \"\"];\n      str = \"\";\n    } else if (e === \"]\") {\n      let p: [number, string] = pop();\n\n      // str æ‹¿åˆ°çš„æ˜¯ æœ€åä¸€ä¸ª [] å†…çš„å€¼\n      str = p[1] + str.repeat(p[0]);\n    } else {\n      str += e;\n    }\n  }\n\n  return str;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189116410","body":"## æ€è·¯\né‡‡ç”¨ä¸¤ä¸ªæ ˆ stack_1 å’Œ stack_2\n\npush çš„æ—¶å€™éƒ½å‹å…¥ stack_1 æ ˆ\n\nå‡ºæ ˆçš„æ—¶å€™ å…ˆæŠŠ stack_1 ä¸­çš„æ•°æ® å…¥æ ˆåˆ° stack_2 ä¸­ è¿™æ ·é˜Ÿåˆ—çš„ç¬¬ä¸€ä¸ªå…ƒç´  å°±åœ¨ stack_2 æ ˆé¡¶\n\nå½“ stack_2 ä¸­å­˜åœ¨å€¼ æ ˆé¡¶ æ°¸è¿œæ˜¯ é˜Ÿåˆ—çš„å¼€å¤´\n\nå½“ stack_1 å’Œ stack_2 éƒ½ä¸ºç©ºçš„æ—¶å€™ è¡¨ç¤º é˜Ÿåˆ—ä¸ºç©º\n```typeScript\nclass MyQueue {\n  // æ ˆçš„ç‰¹ç‚¹ å…ˆè¿›åå‡º\n  stack_1: number[] = [];\n  stack_2: number[] = [];\n  constructor() {}\n\n  push(x: number): void {\n    this.stack_1.push(x);\n  }\n\n  // ä»é˜Ÿåˆ—çš„å¼€å¤´ç§»é™¤å¹¶è¿”å›å…ƒç´ \n  pop(): number {\n    if (this.stack_2.length === 0) {\n      while (this.stack_1.length > 0) {\n        this.stack_2.push(this.stack_1.pop()!);\n      }\n    }\n    return this.stack_2.pop()!;\n  }\n\n  // è¿”å›é˜Ÿåˆ—å¼€å¤´çš„å…ƒç´ \n  peek(): number {\n    if (this.stack_2.length === 0) {\n      while (this.stack_1.length > 0) {\n        this.stack_2.push(this.stack_1.pop()!);\n      }\n    }\n    return this.stack_2[this.stack_2.length - 1];\n  }\n\n  // åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º\n  empty(): boolean {\n    return !this.stack_1.length && !this.stack_2.length ? true : false;\n  }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190463079","body":"## æ€è·¯ \næ²¡è§£å‡ºæ¥\nçœ‹åˆ° å•è°ƒæ ˆ å’Œ æ»‘åŠ¨çª—å£ ç ”ç©¶äº†ä¸‹ çœŸå¥‡å¦™\n\n## ä»£ç \nå•è°ƒæ ˆ\n```typeScript\nfunction maxChunksToSorted(arr: number[]): number {\n  let stack: number[] = [];\n  for (let i = 0; i < arr.length; i++) {\n    const e = arr[i];\n    if (stack && stack[stack.length - 1] > e) {\n      let cru = stack[stack.length - 1];\n      while (stack && stack[stack.length - 1] > e) {\n        stack.pop();\n      }\n      stack.push(cru);\n    } else {\n      stack.push(e);\n    }\n  }\n  return stack.length;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191453577","body":"## æ€è·¯\nå°†é“¾è¡¨é—­ç¯\n\nk ä»£è¡¨æŒ‡é’ˆä»é“¾è¡¨å¤´å¼€å§‹èµ°çš„æ¬¡æ•°ã€‚å¦‚æœk å¤§äº é“¾è¡¨é•¿åº¦ ä¼šè¿›è¡Œå¾ªç¯ç§»åŠ¨ã€‚æ‰€ä»¥æˆ‘ä»¬å»é™¤å¾ªç¯é“¾è¡¨çš„æ¬¡æ•°ã€‚å‰©ä¸‹æœ€åä¸€æ¬¡ç§»åŠ¨çš„ä¸ªæ•°ã€‚æŒ‡é’ˆèµ°åˆ°å“ªä¸ªä½ç½®å°±æ˜¯è¦æ–­å¼€çš„åœ°æ–¹\n\n## ä»£ç \n\n```typeScript\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n\n    if(!head || !head.next || !k) return head\n\n    // å°†é“¾è¡¨å½¢æˆç¯ ç„¶åå†æ–­æ¥é“¾è¡¨\n    let header = head\n    let n = 1\n    while(header.next) {\n        header = header.next\n        n++\n    }\n\n    // å½¢æˆé—­ç¯\n    header.next = head\n\n    // k å€¼å¤§äº é“¾è¡¨é•¿åº¦çš„æ—¶å€™\n    // ä¼šå¾ªç¯é“¾è¡¨ã€‚k = å¾ªç¯é“¾è¡¨çš„æ¬¡æ•°*é“¾è¡¨é•¿åº¦ + æœ€åèµ°çš„ä¸ªæ•° ; æ‰€ä»¥æˆ‘ä»¬åªéœ€è¦ç§»åŠ¨æœ€ä¼šèµ°çš„ä¸ªæ•° å°±æ˜¯è¦æ–­å¼€é“¾è¡¨çš„ä½ç½®\n    // ä¹Ÿå°±æ˜¯ k é™¤ä»¥é“¾è¡¨é•¿åº¦ çš„ä½™æ•°\n    let num = n - k%n\n    while(num) {\n        header = header.next\n        num--\n    }\n\n    let r = header.next\n    header.next = null\n\n    return r\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192631290","body":"## æ€è·¯\nåˆ©ç”¨é€’å½’ æ¥äº¤æ¢èŠ‚ç‚¹\n\n## ä»£ç \n```\nfunction swapPairs(head: ListNode | null): ListNode | null {\n\n    if(head == null || head.next ===  null) {\n        return head\n    }\n\n    // 2n\n    let last = head.next;\n    // last.next === 2n+1  \n    // return 2n+2\n    let next2 = swapPairs(last.next)\n    // 2n = 2n+2\n    head.next = next2\n    // 2n = 2n+1\n    last.next = head\n    return last\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193156623","body":"```typeScript\nfunction getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {\n\n    let m = new Set()\n    let h1 = headA\n    while(h1) {\n        m.add(h1)\n        h1 = h1.next\n    }\n\n    let h2 = headB\n    while(h2) {\n        if(m.has(h2)) {\n            return h2\n        }\n        h2 = h2.next\n    }\n\n    return null\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195611609","body":"## æ€è·¯\nMap\n\n## ä»£ç \n```typeScript\nclass LRUCache {\n    private map = new Map()\n    private capacity = 0\n    constructor(capacity: number) {\n        this.capacity = capacity\n    }\n\n    get(key: number): number {\n\n        if(this.map.has(key)) {\n            let n = this.map.get(key)\n            this.map.delete(key)\n            this.map.set(key, n)\n            return n\n        } else {\n            return -1\n        }\n    }\n\n    put(key: number, value: number): void {\n        \n        if(this.map.has(key)) {\n            this.map.delete(key);\n        }\n\n        this.map.set(key, value)\n\n        if(this.map.size > this.capacity) {\n            this.map.delete(this.map.keys().next().value)\n        } \n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1198074478","body":"code\r\n```\r\nfunction maxDepth(root: TreeNode | null): number {\r\n\r\n    if(root == null) return 0\r\n    \r\n    let l = maxDepth(root.left)\r\n    let r = maxDepth(root.right)\r\n    return Math.max(l,r) + 1\r\n\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198088034","body":"## code\n```typeScript\n\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\n    if(p === null && q === null) return true\n    if(p === null || q === null) return false\n    if(p.val != q.val) return false\n    \n    return isSameTree(p.left, q.left) && isSameTree(p.right,q.right)\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199333647","body":"## æ€è·¯\nå‰åºéå† æ±‚å’Œ\n## ä»£ç \n```typeScript\nfunction sumNumbers(root: TreeNode | null): number {\n    function dfs(r: TreeNode, n: number) {\n        if(r === null) return 0\n\n        // çˆ¶èŠ‚ç‚¹å€¼ åŠ ä¸Šå­èŠ‚ç‚¹å€¼ çˆ¶èŠ‚ç‚¹æ‰©å¤§10å€\n        let num: number = n*10 + r.val\n\n        // \n        if( r.left === null && r.right === null ) {\n            return num;\n        } else {\n            return dfs(r.left, num) + dfs(r.right, num)\n        }\n\n\n    }\n   return dfs(root, 0)\n\n};\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202551516","body":"## code\n```typeScript\nfunction twoSum(nums: number[], target: number): number[] {\n\n    for(let i = 0; i< nums.length; i ++) {\n        for(let j = i + 1; j< nums.length; j ++) {\n        if(nums[j] + nums[i] === target) {\n            return  [i,j]\n        }\n    } \n    } \n};\n```\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1209428076","body":"## ä»£ç \r\n```\r\nfunction middleNode(head: ListNode | null): ListNode | null {\r\n    let l = []\r\n    let h = head\r\n    while(h.next != null) {\r\n        l.push(h)\r\n        h = h.next\r\n    }\r\n    l.push(h)\r\n    \r\n    return l[Math.trunc(l.length/2)]\r\n\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209409700","body":"## æ€è·¯\nåŒæŒ‡é’ˆ \n## ä»£ç \n```typeScript\nfunction removeDuplicates(nums: number[]): number {\n    \n    const n = nums.length\n    let slow = 0, fast = 0\n    while(slow <= fast && fast< n) {\n        if(nums[slow]!= nums[fast]) {\n            slow++\n            nums[slow] = nums[fast]\n        } \n        fast++\n\n    }\n    return slow+1\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunnyyujf":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185170165","body":"#### ä»£ç  \n\n```Python\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        i=len(num)-1\n        while k>0:\n            added = num[i]+k\n            num[i]=added%10  # remainder\n            k=added//10    # carry\n            i-=1\n            if i<0 and k>0:\n                num.insert(0,0)\n                i=0\n        return num\n```\n\n#### å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦ï¼š O(N)  </br>\nç©ºé—´å¤æ‚åº¦ï¼š O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186052450","body":"### æ€è·¯ \nä»å·¦è‡³å³éå†sï¼Œ å¾—åˆ°å·¦è¾¹æœ€è¿‘cçš„è·ç¦»\nä»å³è‡³å·¦éå†sï¼Œ å¾—åˆ°å³è¾¹æœ€è¿‘cçš„è·ç¦»ä¸å·¦è¾¹æœ€è¿‘cçš„è·ç¦»çš„è¾ƒå°å€¼\n#### ä»£ç  Python\n\n```Python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        #time O(N) space O(N)\n        res=[float('inf')]*len(s)\n        last_c = float('inf')\n        for i in range(len(s)):\n            if s[i]==c:\n                last_c=i\n            res[i]=abs(last_c-i)\n        \n        for i in range(len(s)-1,-1,-1):\n            if s[i]==c:\n                last_c=i\n            res[i]=min(res[i],abs(last_c-i))\n        return res\n\n\n```\n\n#### å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦ï¼šO(N)    </br>\nç©ºé—´å¤æ‚åº¦ï¼šO(N)\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188597906","body":"#### ä»£ç  Python\n\n```Python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1=[]\n        self.stack2=[]\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n            \n        return self.stack2.pop()\n\n    def peek(self) -> int:\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n           \n        return self.stack2[-1]\n\n    def empty(self) -> bool:\n        if self.stack1 or self.stack2:\n            return False\n        else:\n            return True\n\n```\n\n#### å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦ï¼š O(N) </br>\nç©ºé—´å¤æ‚åº¦ï¼šO(N)\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192146089","body":"### æ€è·¯ \néå†é“¾è¡¨ï¼Œ æ¯æ¬¡äº¤æ¢ä¸¤ä¸ªnode\n#### ä»£ç  Python\n\n```Python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return None\n        dummy=ListNode(-1)\n        dummy.next=head\n        cur=head\n        prev=dummy\n        while cur and cur.next:\n            prev.next=cur.next\n            prev=prev.next\n            cur.next = prev.next\n            prev.next=cur\n   \n            prev=prev.next\n            cur=cur.next\n        return dummy.next\n```\n\n#### å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦ï¼š O(N) </br>\nç©ºé—´å¤æ‚åº¦ï¼š O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193243758","body":"### æ€è·¯ \na1->a2->*c1->c2->b1->b2->b3->*c1->c2  </br>\nb1->b2->b3->*c1->c2->a1->a2->*c1->c2\n#### ä»£ç  Python\n\n```Python\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not headA or not headB:\n            return None\n        #list1:a1->a2->*c1->c2 \n        #list2:b1->b2->b3->*c1->c2\n        #a1->a2->*c1->c2->b1->b2->b3->*c1->c2  O(m+n)\n        #b1->b2->b3->*c1->c2->a1->a2->*c1->c2\n        cur1=headA\n        cur2=headB\n        while cur1!=cur2:\n            if cur1:\n                cur1=cur1.next\n            else:\n                cur1 = headB\n              \n            if cur2:\n                cur2=cur2.next\n            else:\n                cur2 = headA\n           \n        return cur1   \n\n```\n\n#### å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦ï¼š O(M+N) </br>\nç©ºé—´å¤æ‚åº¦ï¼š O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193361161","body":"\n### æ€è·¯ \nå¿«æ…¢æŒ‡é’ˆ\n#### ä»£ç  \n\n```Python\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast=head\n        slow=head\n        while True:\n            if not fast or not fast.next:\n                return None\n            fast=fast.next.next\n            slow=slow.next\n            if slow==fast:\n                break\n        fast=head\n        while fast!=slow:\n            fast=fast.next\n            slow=slow.next\n        return slow\n        \n```\n\n#### å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦ï¼š O(N) </br>\nç©ºé—´å¤æ‚åº¦ï¼š O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197613987","body":"### æ€è·¯ \nRecursion\n#### ä»£ç  Python\n\n```Python\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not p and not q:\n            return True\n        elif not p and q:\n            return False\n        elif not q and p:\n            return False\n        elif p.val!=q.val:\n            return False\n            \n        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\n\n```\n\n#### å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦ï¼š O(N) </br>\nç©ºé—´å¤æ‚åº¦ï¼š O(H) H is the depth of the tree","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201506289","body":"### æ€è·¯\nHashmap\n#### ä»£ç  Python\n\n```Python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        hmap={}\n        for i in range(len(nums)):\n            if target-nums[i] in hmap:\n                res=[i,hmap[target-nums[i]]]\n                return res\n            else:\n                hmap[nums[i]]=i\n\n```\n\n#### å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦ï¼š O(N) </br>\nç©ºé—´å¤æ‚åº¦ï¼š O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203452560","body":"### æ€è·¯ \r\nHeap + Counter\r\n#### ä»£ç  Python\r\n\r\n```Python\r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        counter =defaultdict(int)\r\n        for i in range(len(nums)):\r\n            counter[nums[i]]+=1\r\n        heap=[]\r\n        for key,value in counter.items():\r\n            heapq.heappush(heap,(value,key))\r\n            if len(heap)>k:\r\n                heapq.heappop(heap)\r\n        return [key for value,key in heap]\r\n```\r\n\r\n#### å¤æ‚åº¦åˆ†æ\r\næ—¶é—´å¤æ‚åº¦ï¼šO(NlogK) </br>\r\nç©ºé—´å¤æ‚åº¦: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204775990","body":"### æ€è·¯ \nFor every point, calculate permutations.\n#### ä»£ç  Python\n\n```Python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        \n        res=0\n        for i in range(len(points)):\n            hmap=defaultdict(int)\n            for j in range(len(points)):\n                dis=(points[i][0]-points[j][0])**2+(points[i][1]-points[j][1])**2\n                hmap[dis]+=1\n           \n            for k,v in hmap.items():\n                res+=v*(v-1)\n        return res\n\n```\n\n#### å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦ï¼š O(N^2) </br>\nç©ºé—´å¤æ‚åº¦ï¼š O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"phoenixflyingsky":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185170186","body":"### Idea\n\njust add the end of two numbers\n\n### Code\n\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int len = num.length;\n        int carry = 0;\n        int index = len - 1;\n\n        while(index >= 0 && k > 0) {\n            int temp = k % 10;\n            int total = temp + num[index] + carry;\n\n            //update\n            carry = total / 10;\n            total = total % 10;\n\n            //put the num to res\n            res.add(0, total);\n\n            //update\n            index--;\n            k = k / 10;\n        }\n\n        while(index >= 0) {\n            int total = num[index] + carry;\n\n            //update\n            carry = total / 10;\n            total = total % 10;\n\n            //put the num to res\n            res.add(0, total);\n\n            //update\n            index--;\n        }\n\n        while(k > 0) {\n            int total = k % 10 + carry;\n\n            //update\n            carry = total / 10;\n            total = total % 10;\n\n            //put the num to res\n            res.add(0, total);\n\n            //update\n            k = k / 10;\n        }\n\n        if(carry != 0) {\n            res.add(0, carry);\n        }\n\n        return res;\n\n    }\n}\n\n\n```\n\n**Complexity Analysis**\n- Time Complexityï¼š O(N), N is the longest of the two lengthsï¼ˆnum.length & k.length()ï¼‰\n- Space Complexityï¼š O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186150582","body":"### Idea\r\n- First loop: traverse from left to right to find the nearest c on the left.\r\n- Second loop:  traverse from right to left to find the nearest c on the right.\r\n### Code\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len]; \r\n\r\n        int minNum = Integer.MIN_VALUE / 2; //make sure the num is smaller enough\r\n        int pre = minNum; //the distance of the nearest C on the left\r\n        for(int i = 0; i < len; i++) {\r\n            if(s.charAt(i) == c) {\r\n                pre = i;\r\n            }\r\n\r\n            res[i] = i - pre;//make sure the distance of nearest C on the left\r\n        }\r\n\r\n        int maxNum = Integer.MAX_VALUE / 2; //make sure the num is larger enough\r\n        int later = maxNum; // the distance of the nearest C on the right\r\n        for(int i = len - 1; i >= 0; i--) {\r\n            if(s.charAt(i) == c) {\r\n                later = i;\r\n            }\r\n\r\n            res[i] = Math.min(res[i], (later - i));\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**Complexity Analysis**\r\n- Time Complexityï¼š O(N) \r\n- Space Complexityï¼š O(1) (  The return value is not included in the space complexity.  )\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186513643","body":"### Idea\n\nbuild an array(int[]Â stack) to save the data, and then build an array(int[]Â auxiliaryAdd) to save the increments\n\n### Code\n\n\n```java\nclass CustomStack {\n    int[] stack;//store data\n    int[] auxiliaryAdd; // the auxiliary array to store the increments\n    int len;// the length about this stack\n    int top = -1;// the num in the stack\n\n    public CustomStack(int maxSize) {\n        this.len = maxSize;\n        this.stack = new int[this.len];\n        this.auxiliaryAdd = new int[this.len];\n    }\n    \n    public void push(int x) {\n        if(this.top < (this.len - 1)) {\n            this.top++;\n            this.stack[this.top] = x;         \n        }\n    }\n    \n    public int pop() {\n        if(this.top < 0) {\n            return -1;\n        }\n\n        int temp = this.stack[this.top] + this.auxiliaryAdd[this.top];\n\n        if(this.top > 0) {\n            this.auxiliaryAdd[this.top - 1] += this.auxiliaryAdd[this.top]; //superimpose the previous increase\n        }\n\n        auxiliaryAdd[top] = 0; // we need to initialize this auxiliaryAdd[top] !!!!!!\n \n        this.top--;\n\n        return temp;\n    }\n    \n    public void increment(int k, int val) {\n        if(this.top == -1) {\n            return;// this means if the stack has none num, we do not need to do anything\n        }\n\n\n        int temp = Math.min(k - 1, this.top);\n\n        auxiliaryAdd[temp] += val;// this step is superimpose,  not just auxiliaryAdd[temp] = val; !!!\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n\n\n```\n\n**Complexity Analysis**\n- Time Complexityï¼š O(1)  (just get the num from the array)\n- Space Complexityï¼š O(N) (cause we build two arrays to save data and increment)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187191289","body":"### Idea\nUse stack to simulate this process\n\n\n\n### Code\n\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Deque<Integer> numStack = new ArrayDeque<>();//save the times\n        Deque<String> strStack = new LinkedList<>();//save the string\n        StringBuilder tail = new StringBuilder();//recode the string\n        \n        int len = s.length();\n        for(int i = 0; i < len; i++) {\n            char c = s.charAt(i);\n\n            if(Character.isDigit(c)) {\n                //Character.isDigit(c) means if the c is num \n                int num = c - '0';\n                while(i + 1 < len && Character.isDigit(s.charAt(i + 1))) {\n                    //the num may do not just single\n                    num = num * 10 + s.charAt(i + 1) - '0';\n                    i++;\n                }    \n                numStack.push(num);          \n            }\n\n            else if(c == '[') {\n                //push the contents of tail to strStack\n                strStack.push(tail.toString());\n                tail = new StringBuilder();\n            }\n\n            else if(c == ']') {\n                //cause the things in brackets are saved in the tail \n                //times are saved in the numStack\n                //strStack contains string between two left brackets('[')\n\n                StringBuilder temp = new StringBuilder();\n                temp.append(strStack.pop());\n\n                int times = numStack.pop();\n                for(int j = 0; j < times; j++) {\n                    temp.append(tail);\n                }\n\n                tail = temp;\n            }\n\n            else {\n                tail.append(c);\n            }\n\n            //i++; \n            //we do not need i++, cause : for(int i = 0; i < len; i++)\n        }\n\n        return tail.toString();\n    }\n}\n\n\n```\n\n**Complexity Analysis**\n- Time Complexityï¼š O(N) \n- Space Complexityï¼š O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188797393","body":"### Idea\nUse two stacks to simulate this process\n\n\n\n### Code\n\n\n```java\n\nclass MyQueue {\n    Deque<Integer> inPut;\n    Deque<Integer> outPut;\n\n    public MyQueue() {\n        inPut = new ArrayDeque<>();\n        outPut = new ArrayDeque<>();\n    }\n    \n    public void push(int x) {\n        inPut.push(x);\n    }\n    \n    public int pop() {  \n        if(outPut != null && !outPut.isEmpty()) {\n            return outPut.pop();\n        }\n\n        while(inPut != null && !inPut.isEmpty()) {\n            outPut.push(inPut.pop());           \n        }\n\n        return outPut.pop();  \n    }\n        \n    public int peek() {\n         if(outPut != null && !outPut.isEmpty()) {\n            return outPut.peek();\n        }\n\n        while(inPut != null && !inPut.isEmpty()) {\n            outPut.push(inPut.pop());      \n        }\n\n        return outPut.peek();  \n    }\n    \n    public boolean empty() {\n        return (outPut.isEmpty() && inPut.isEmpty());\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n\n```\n\n**Complexity Analysis**\n- Time Complexityï¼š O(N) \n- Space Complexityï¼š O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190303585","body":"### Idea\nUsing monotonic incremental stack\n\n\n\n### Code\n\n\n```java\n\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n\n        Deque<Integer> stack = new ArrayDeque<>();\n\n        for(int num : arr) {\n            int temp = Integer.MIN_VALUE;\n\n            while(!stack.isEmpty() && stack.peek() > num) {\n                //this means the num is smaller than the stack.peek(), so we need to merge them into one\n                //Because it is monotonically increasing, the first pop-up must be the largest, so we only need to record the value of the first pop-up\n                temp = Math.max(temp, stack.pop());\n            }\n\n            if(temp == Integer.MIN_VALUE) {\n                stack.push(num);//Num does not need to be merged with the previous block, so it is pushed into the stack\n            }\n            else {\n                stack.push(temp);\n            }\n        }\n\n        return stack.size();\n    }\n}\n\n```\n\n**Complexity Analysis**\n- Time Complexityï¼š O(N) \n- Space Complexityï¼š O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191351567","body":"### Idea\nFirstly, calculate the point to be truncated: k%len.   \nThen cut it directly and connect the head to the tail (note that when k = = len, the head should be returned directly).\n\n\n\n### Code\n\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        //corner case\n        if(head == null || head.next == null || k == 0) {\n            return head;\n        }\n\n        int len = 0;// the length of head\n\n        ListNode dummy = new ListNode();\n        dummy.next = head;\n\n        ListNode last = dummy;\n\n        while(last.next != null) {\n            len++;\n            last = last.next;\n        }\n\n        int cut = len - k % len;\n\n        if(cut == len) {\n            return head;//pay attention: cause if cut == len ,  ListNode res = pre.next;(pre.next == null), and we will return null, so we need to return head if cut == len\n        } \n\n        ListNode pre = dummy;\n\n        for(int i = 0; i < cut; i++) {\n            pre = pre.next;\n        }\n\n        ListNode res = pre.next;\n        pre.next = null;\n        last.next = head;\n\n        return res;\n    }\n}\n\n\n```\n\n**Complexity Analysis**\n- Time Complexityï¼š O(N) \n- Space Complexityï¼š O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192600788","body":"### Idea\nUse iterations to simulate the process\n\n\n\n### Code\n\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        //corner case\n        if(head == null || head.next == null) {\n            return head;\n        }\n\n        ListNode dummy = new ListNode();\n        dummy.next = head;\n\n        ListNode pre = dummy;\n        ListNode curr = dummy.next;\n        ListNode next = curr.next;\n\n        while(curr != null && next != null) {\n            pre = swap(pre, next);\n            curr = pre.next;\n            if(curr != null) {\n                next = curr.next;\n            }\n        }\n\n        return dummy.next;\n    }\n\n    private ListNode swap(ListNode pre, ListNode next) {\n        ListNode curr = pre.next;\n        ListNode res = curr;\n\n        ListNode temp = next.next;\n\n        pre.next = next;\n        next.next = curr;\n        curr.next = temp;\n\n        return res;\n    }\n}\n\n```\n\n**Complexity Analysis**\n- Time Complexityï¼š O(N) \n- Space Complexityï¼š O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193112221","body":"### Idea\nuse the Fast and Slow Pointers to find the mid node, and then Divide and Conquer\n\n\n\n### Code\n\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        //corner case\n        if(head == null) {\n            return null;\n        }\n\n        else if(head.next == null) {\n            return new TreeNode(head.val);\n        }\n\n        //Use the Fast and Slow Pointers to find the mid Node\n        ListNode slow = head;\n        ListNode fast = head;\n        ListNode pre = null; //Pre is the previous node of the slow Node\n\n        while(fast != null && fast.next != null) {\n            pre = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        pre.next = null;//Unlinks the node ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼\n\n        //recursion\n        TreeNode node = new TreeNode(slow.val);\n        node.left = sortedListToBST(head);\n        node.right = sortedListToBST(slow.next);\n\n        return node;\n    }\n}\n\n\n```\n\n**Complexity Analysis**\n- Time Complexityï¼š O(NlogN) Each layer uses a while loop (fast and slow pointer) to find its own middle point, so each layer is O(N), and there are altogether logN layers, so the total time complexity is O(NlogN)\n- Space Complexityï¼š O(logN)  Recursion is a total of logN layers, so O(logN) additional space is required in general      ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193317284","body":"### Idea\nUseÂ twoÂ pointers \n\n\n\n### Code\n\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        // use two pointers\n\n        ListNode pointerA = headA;\n        ListNode pointerB = headB;\n\n        while(pointerA != pointerB) {\n            if(pointerA == null) {\n                pointerA = headB;\n            }\n            else {\n                pointerA = pointerA.next;\n            }\n\n            if(pointerB == null) {\n                pointerB = headA;\n            }\n            else {\n                pointerB = pointerB.next;\n            }        \n        }\n\n        return pointerA;\n        \n    }\n}\n\n\n```\n\n**Complexity Analysis**\n- Time Complexityï¼š O(1)   \n- Space Complexityï¼š O(m + n)  m is the length of headA LinkedList, n is the length of headB LinkedList","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194180987","body":"### Idea\nUse the Fast and Slow Pointers to find if the LinkedList is the loop, and then use the ListNodeÂ index_1Â =Â slow andÂ ListNodeÂ index_2Â =Â head; to get the the node where the cycle begins\n\n\n\n### Code\n\n\n```java\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n\n        while(fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n\n            if(slow == fast) {\n                ListNode index_1 = slow;\n                ListNode index_2 = head;\n                while(index_1 != index_2) {\n                    index_1 = index_1.next;\n                    index_2 = index_2.next;\n                }\n                return index_1;\n            }\n        }\n\n        return null;\n        \n    }\n}\n\n```\n\n**Complexity Analysis**\n- Time Complexityï¼š O(N)   \n- Space Complexityï¼š O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195449506","body":"```java\nclass LRUCache {\n\n    private int capacity;\n    private HashMap<Integer, Node> map;\n    private Node head, tail;\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        //map = new HashMap<>(capacity);\n        map = new HashMap<>();\n\n        head = new Node(0, 0);\n        tail = new Node(0, 0);\n        //åˆ†åˆ«æŒ‡å‘å¤´å’Œå°¾ç»“ç‚¹\n\n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    public int get(int key) {\n        if( !this.map.containsKey(key) ){\n            return -1;\n        }\n\n        Node node = this.map.get(key);\n        this.moveNodeToFirst(node);\n        return node.value;\n    }\n    \n    public void put(int key, int value) {\n        //ç¬¬ä¸€ç§æƒ…å†µå¦‚æœä¹‹å‰æœ‰ï¼Œåˆ™æ˜¯æŠŠä¹‹å‰çš„keyæ‹¿å‡ºæ¥åï¼Œæ›´æ–°ï¼Œå¹¶ä¸”æ”¾åˆ°æœ€å‰é¢çš„ä½ç½®\n        if( this.map.containsKey(key)) {\n            Node node = this.map.get(key);\n            node.value = value;\n\n            this.moveNodeToFirst(node);\n            return;\n        }\n\n        //ç¬¬äºŒç§æƒ…å†µ å½“æ˜¯æ–°çš„æ—¶å€™ï¼šç¬¬ä¸€ç§æƒ…å†µï¼šé¦–å…ˆè€ƒè™‘æœ‰æ²¡æœ‰æ»¡ï¼Œå¦‚æœæ»¡äº†åˆ é™¤æœ€åä¸€ä¸ªï¼Œæ·»åŠ æ–°çš„\n        if( this.map.size() == this.capacity ) {          \n            Node last = this.tail.prev;\n            this.map.remove(last.key);\n            this.removeLast(last);//è¿™ä¸ªlastå¿…é¡»è¦æœ‰ï¼Œä¸èƒ½this.removeLast();\n        }\n\n        //ç¬¬äºŒç§æƒ…å†µ å½“æ˜¯æ–°çš„æ—¶å€™ï¼šç¬¬äºŒç§æƒ…å†µï¼šå³æ²¡æœ‰æ»¡ï¼ˆç¬¬ä¸€å¼ æƒ…å†µå·²ç»åˆ é™¤ï¼‰\n\n        Node node = new Node(key, value);\n        this.map.put(key, node);\n        this.addNodeToFirst(node);\n    }\n\n    private class Node {\n        public Node prev, next;\n        public int key, value;\n\n        public Node(int k, int v) {\n            this.key = k;\n            this.value = v;\n        }\n\n    }\n\n    private void removeLast(Node last) {\n        //è¿™ä¸ªlastå°±æ˜¯æœ€åkey,ä¸æ˜¯ä¹‹å‰çš„tailå°¾ç»“ç‚¹\n        last.prev.next = tail;\n        tail.prev = last.prev;\n\n        //æ¸…ç©ºlast\n        last.prev = null;\n        last.next = null;\n    }\n\n    private void addNodeToFirst(Node node) {\n        Node currfirst = head.next;\n\n        node.next = currfirst;\n        currfirst.prev = node;\n\n        head.next = node;\n        node.prev = head;     \n    }\n\n    private void moveNodeToFirst(Node node) {\n        Node nodenext = node.next;\n        Node nodeprev = node.prev;\n\n        //å…ˆæŠŠnodeé‡Šæ”¾\n        nodeprev.next = nodenext;\n        nodenext.prev = nodeprev;\n\n      //  node.prev = null;\n       // node.next = null;\n       //ä¸Šè¾¹è¿™ä¸ªä¸è¡Œï¼Œå› ä¸ºè¿˜è¦ç”¨nodeå³ä¸‹é¢çš„æ­¥éª¤\n\n        //æŠŠnodeæ”¾åˆ°æœ€å¼€å§‹\n        addNodeToFirst(node);\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196870781","body":"### Idea\ndfs\n\n\n\n### Code\n\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        //dfs  \n        //corner case\n        if(root == null) {\n            return 0;\n        }\n\n        int leftMax = maxDepth(root.left);\n        int rightMax = maxDepth(root.right);\n\n        return Math.max(leftMax, rightMax) + 1;\n\n    }\n}\n\n```\n\n**Complexity Analysis**\n- Time Complexityï¼š O(N)   \n- Space Complexityï¼š O(height)  height indicates the height of the binary tree\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197999154","body":"### Idea\ndfs\n\n\n\n### Code\n\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        //corner case\n        if(p == null && q == null) {\n            return true;\n        }\n        else if(p == null || q == null) {\n            return false;\n        }\n\n        //compare the val of root\n        if(p.val != q.val) {\n            return false;\n        }\n\n        //compare left and right\n        boolean leftEqual = isSameTree(p.left, q.left);\n        boolean rightEqual = isSameTree(p.right, q.right);\n\n        return leftEqual && rightEqual;\n    }\n}\n\n\n```\n\n**Complexity Analysis**\n- Time Complexityï¼š O(min(m,n))   \n- Space Complexityï¼š O(height)  height indicates the height of the binary tree","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199419886","body":"### Idea\ndfs\n\n\n\n### Code\n\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n   int sum = 0;\n\n    public int sumNumbers(TreeNode root) {\n        int temp = 0;\n        dfs(root, 0, 10);\n        return sum;\n    }\n\n    public void dfs(TreeNode root, int num, int times) {\n        int temp = root.val;\n        num = num * times + temp;\n\n        if(root.left == null && root.right == null) {\n            sum += num;\n            return;\n        }\n\n        else {\n            if(root.left != null) {\n                dfs(root.left, num, times);\n            }\n\n            if(root.right != null) {\n                dfs(root.right, num, times);\n            }\n        }\n\n\n    }\n}\n\n```\n\n**Complexity Analysis**\n- Time Complexityï¼š O(N)   \n- Space Complexityï¼š O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200179433","body":"### Idea\nbfs\n\n\n\n### Code\n\n\n```java\n\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n    \n        int leftValue = root.val;\n        boolean find = false;\n\n        Deque<TreeNode> que = new LinkedList<>();\n        que.offer(root);\n\n        while(!que.isEmpty()) {\n            int len = que.size();\n            for(int i = 0; i < len; i++) {\n                TreeNode temp = que.poll();\n\n                if(temp.left != null) {\n                    que.offer(temp.left);\n                    if(find == false) {\n                        leftValue = temp.left.val;\n                        find = true;\n                    }\n                }\n\n                if(temp.right != null) {\n                    que.offer(temp.right);\n                    if(find == false) {\n                        leftValue = temp.right.val;\n                        find = true;\n                    }\n                }\n            }\n\n            find = false;\n        }\n\n        return leftValue;\n\n    }\n}\n```\n\n**Complexity Analysis**\n- Time Complexityï¼š O(N)   \n- Space Complexityï¼š O(height)  height indicates the height of the binary tree","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200434386","body":"```java\n// æ²¡æ—¶é—´äº†ï¼Œåé¢å†çœ‹çœ‹\n public String serialize(TreeNode root) {\n        Queue<TreeNode> queue = new LinkedList();\n        queue.add(root);\n        StringBuilder builder = new StringBuilder();\n        while(!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n            if(node == null) {\n                builder.append(NULL).append(SEP);\n                continue;\n            }\n            builder.append(node.val).append(SEP);\n            queue.add(node.left);\n            queue.add(node.right);\n        }\n        return builder.toString();\n    }\n\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202257545","body":"### Idea\nhashmap\n\n\n\n### Code\n\n\n```java\n\n\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        //use hashmap\n        Map<Integer, Integer> store = new HashMap<>();\n\n        for(int i = 0; i < nums.length; i++) {\n            int temp = target - nums[i];\n            if(store.containsKey(temp)) {\n                return new int[] {store.get(temp), i};\n            }\n            else {\n                store.put(nums[i], i);\n            }\n        }\n\n        return null;\n\n    }\n}\n```\n\n**Complexity Analysis**\n- Time Complexityï¼š O(N)   \n- Space Complexityï¼š O(N) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203891684","body":"```java\n\nclass Solution {\n\n\n    public int[] topKFrequent(int[] nums, int k) {\n\n        int[] res = new int[k];//å­˜å‚¨æœ€ç»ˆçš„ç»“æœ\n\n        HashMap<Integer, Integer> map = new HashMap<>();//æŠŠæ•°å­—å’Œå¯¹åº”å¤šå°‘ä¸ªæ”¾å…¥å“ˆå¸Œè¡¨\n\n        for(int num : nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }//mapä¸­å«æœ‰numçš„è¯ï¼Œå°±å°†numå¯¹åº”çš„valueå€¼+1ï¼Œ ä¸å«æœ‰numçš„è¯ï¼Œnumå¯¹åº”çš„valueå¯¹åº”çš„é»˜è®¤å€¼èµ‹å€¼ä¸º0ï¼Œç„¶åå†+1\n\n        Set<Map.Entry<Integer, Integer>> entries = map.entrySet();//é”®å€¼ç›¸å¯¹çš„ä¸€ä¸ªå †\n\n        PriorityQueue<Map.Entry<Integer, Integer>> queue = new PriorityQueue<>(\n            new Comparator<Map.Entry<Integer, Integer>>() {\n                public int compare(Map.Entry<Integer, Integer> o1, Map.Entry<Integer, Integer> o2) {\n                    return o1.getValue() - o2.getValue();\n                }\n            }//eturn o1-o2:å‡åºæ’åˆ—. return o2-o1:é™åºæ’åˆ—\n        );\n// lambda:   PriorityQueue<Map.Entry<Integer, Integer>> queue = new PriorityQueue<>((o1, o2) -> o1.getValue() - o2.getValue());\n        for(Map.Entry<Integer, Integer> entry : entries) {\n            queue.offer(entry);\n            if (queue.size() > k) {\n                queue.poll();\n            }\n        }\n\n        for(int i = k - 1; i >= 0; i--){\n            res[i] = queue.poll().getKey();\n        }\n\n        return res;\n\n\n\n    }\n}\n\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205191416","body":"### Idea\nUse HashMap to record the distance between each point\n\n\n\n### Code\n\n\n```java\n\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int res = 0;\n\n        for(int[] point : points) {\n            Map<Integer, Integer> distance = new HashMap<>();\n\n            for(int[] p : points) {\n                int dis = (p[0] - point[0]) * (p[0] - point[0]) + (p[1] - point[1]) * (p[1] - point[1]);\n                //dis is twice the actual distance\n\n                distance.put(dis, distance.getOrDefault(dis, 0) + 1);\n            }\n\n            for(Map.Entry<Integer, Integer> entry : distance.entrySet()) {\n                int m = entry.getValue();\n\n                res += m * (m - 1);\n            }\n        }\n\n        return res;\n\n    }\n}\n\n```\n\n**Complexity Analysis**\n- Time Complexityï¼š O(n^2)   \n- Space Complexityï¼š O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206356660","body":"### Idea\nslide window\n\n\n\n### Code\n\n\n```java\n\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        if(s.length() == 0) {\n            return 0;\n        }\n        Map<Character, Integer> map = new HashMap<>();\n        int len = s.length();\n\n        int first = 0;\n        int end = 0;\n        int res = 1;\n\n        for(int i = 0; i < len; i++) {\n            char ch = s.charAt(i);\n\n            if(!map.containsKey(ch) || (map.containsKey(ch) && (map.get(ch) < first))) {\n                //ä¸å­˜åœ¨é‚£ä¹ˆå°±ç§»åŠ¨end\n                res = Math.max(end - first + 1, res);\n                map.put(ch, i);\n            }\n\n            else{\n                //æœ‰ä¸ªç‰¹æ®Šæƒ…å†µï¼š\n                if(i > 0 && s.charAt(i) == s.charAt(i - 1)) {\n                    first = i; //abbaä¸­çš„bï¼Œç›¸å½“äºä¸€åˆ‡ä»æ–°å¼€å§‹\n                    map.clear();\n                }\n                else {\n                    first = map.get(ch) + 1;\n                }\n                \n                res = Math.max(end - first + 1, res);\n                map.put(ch, i);\n            }\n\n            end++;\n        }\n\n        return res;\n\n    }\n}\n\n```\n\n**Complexity Analysis**\n- Time Complexityï¼š O(n)   \n- Space Complexityï¼š O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207210228","body":"### Idea\nslide window\n\n\n\n### Code\n\n\n```java\n\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> res = new ArrayList<>();\n        int num = words.length;\n        int wordLen = words[0].length();\n        int stringLen = s.length();\n\n        for(int i = 0; i < wordLen; i++) {\n            if(i + num * wordLen > stringLen) {\n                //If the length exceeds the length of S, then the following cannot be correct\n                break;\n            }\n\n            Map<String, Integer> differ = new HashMap<>();//the differ between windows and words\n            \n\n            for(int j = 0; j < num; j++) {\n                //Initialized window, length is num * wordLen, store each word\n\n                String word = s.substring(i + j * wordLen, i + (j + 1) * wordLen);\n                //shows each word\n                differ.put(word, differ.getOrDefault(word, 0) + 1);\n            }\n\n            for(String word : words) {\n                //Calculate the difference between words and window\n                differ.put(word, differ.getOrDefault(word, 0) - 1);\n                if(differ.get(word) == 0) {\n                    differ.remove(word);\n                }\n            }\n\n            for(int start = i; start < stringLen - num * wordLen + 1; start += wordLen) {\n                if(start != i) {\n                    //Firstly record the word on the right, and then delete the word on the left\n\n                    //record the words on the right\n                    String word = s.substring(start + (num - 1) * wordLen, start + num * wordLen);\n                    differ.put(word, differ.getOrDefault(word, 0) + 1);\n                    if(differ.get(word) == 0) {\n                        differ.remove(word);\n                    }\n\n                    //delete the word on the left\n                    word = s.substring(start - wordLen, start);\n                    differ.put(word, differ.getOrDefault(word, 0) - 1);\n                    if(differ.get(word) == 0) {\n                        differ.remove(word);\n                    }\n                }\n\n                if(differ.isEmpty()) {\n                    res.add(start);\n                }\n            }\n        }\n\n        return res;\n    }\n}\n\n```\n\n**Complexity Analysis**\n- Time Complexityï¼š O(lsÃ—n),  ls is the length of the s, n is the length of each word\n- Space Complexityï¼š O(mÃ—n), m is the number of the words, n is the length of each word","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207382554","body":"### Idea\nprefix & hashmap\n\n\n\n### Code\n\n\n```java\n\nimport java.util.*;\n\nclass Solution {\n    public int solve(int[] nums, int k) {\n        // use prefix & hashmap\n\n        int totalSum = 0;\n        for(int num : nums) {\n            totalSum += num;\n        }\n\n        int r0 = totalSum % k;//remainder of sum\n        if(r0 == 0) {\n            return 0;\n        }\n\n        int res = Integer.MAX_VALUE;\n        Map<Integer, Integer> map = new HashMap<>();\n        //initialize\n        map.put(0, -1);\n\n        int preSum = 0;// this is the prefix\n\n        for(int j = 0; j < nums.length; j++) {\n            preSum += nums[j];\n            int r = preSum % k;//remainder of prefix\n\n            int rr = r - r0;\n            if(rr < 0) {\n                rr = (rr + k) % k;\n            }\n\n            if(map.containsKey(rr)) {\n                int i = map.get(rr) + 1;//we got the num before i(casue we need preSum[i - 1] % k == r - r0), so we need plus 1(one)\n                res = Math.min(res, j - i + 1);\n            }\n\n            map.put(preSum % k, j);\n        }\n\n        return res >= nums.length ? -1 : res;\n        \n    }\n}\n\n```\n\n**Complexity Analysis**\n- Time Complexityï¼š O(N)   \n- Space Complexityï¼š O(N) \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207594783","body":"### Idea\nfast and slow pointer\n\n\n\n### Code\n\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        //slow and fast pointer\n        ListNode slow = head;\n        ListNode fast = head;\n\n        while(fast.next != null && fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        if(fast.next != null) {\n            slow = slow.next;\n        }\n\n        return slow;\n    }\n}\n\n\n```\n\n**Complexity Analysis**\n- Time Complexityï¼š O(N)   \n- Space Complexityï¼š O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209276018","body":"### Idea\nfast & slow pointers\n\n\n\n### Code\n\n\n```java\n\nclass Solution {\n\n    public void switchNum(int[] nums, int fast, int slow) {  \n        int temp = nums[fast];\n        nums[fast] = nums[slow];\n        nums[slow] = temp;\n    }\n\n    public int removeDuplicates(int[] nums) {\n        //fast & slow pointers\n        int fast = 0, slow = 0;\n\n        while(fast < nums.length) {\n            int fastNum = nums[fast];\n            int slowNum = nums[slow];\n\n            if(fastNum != slowNum) {\n                slow++;\n\n                switchNum(nums, fast, slow);\n                fast++;\n            }\n            else {\n                fast++;\n            }\n        } \n\n        return slow + 1;//cause slow is the index, it starts at 0, so we need plus one\n\n    }\n}\n\n```\n\n**Complexity Analysis**\n- Time Complexityï¼š O(N),\n- Space Complexityï¼š O(1),","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nehchsuy":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185170845","body":"### æ€è·¯\r\nå…ˆåŒæ—¶åŠ arrayå’Œæ•°å­—\r\nå†while loop åªå‰©ä¸‹æ•°å­—æˆ–è€…åªå‰©ä¸‹æ•°ç»„çš„æƒ…å†µ\r\n\r\n### ä»£ç :\r\n\r\n\r\n\r\n          class Solution:\r\n                  def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n\r\n                       def add(index, k, num):\r\n                           carry = 0\r\n                          while index >= 0 and k:\r\n                              current = k % 10\r\n                              k = k // 10\r\n                              num[index] = num[index] + current + carry\r\n                              carry = 0\r\n                              if num[index] >= 10:\r\n                                  num[index] -= 10\r\n                                  carry = 1\r\n                              index -= 1\r\n                          \r\n                          while index >= 0 and carry:\r\n                              num[index] = num[index] + carry\r\n                              carry = 0\r\n                              if num[index] >= 10:\r\n                                  num[index] -= 10\r\n                                  carry = 1\r\n                              index -= 1\r\n                          \r\n                          k += carry\r\n                          while k:\r\n                              current = k % 10\r\n                              k = k // 10\r\n                              num = [current] + num\r\n                          return num\r\n                              \r\n                      \r\n                     return add(len(num) - 1, k, num)\r\n\r\n### å¤æ‚åº¦:\r\nTime: O(length of number + length of array) or O(N)\r\nSpace: O(length of number + length of array) or O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186082185","body":"### æ€è·¯\r\n\r\nå…ˆçœ‹æœ€å·¦æœ€å³æ˜¯ä¸æ˜¯å’Œcä¸€æ ·, æ˜¯ä¸€æ ·è®¾ä¸º0\r\nç„¶åå·¦å¾€å³, å³å¾€å·¦å„éå†ä¸€æ¬¡å–ä¸Šä¸€ä¸ªæ•° + 1å’Œæœ¬æ•°çš„æœ€å°å€¼\r\n\r\n### ä»£ç \r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = [float('inf') for char in s]\r\n        \r\n        if s[0] == c:\r\n            ans[0] = 0\r\n        if s[-1] == c:\r\n            ans[-1] = 0\r\n        \r\n        for i in range(1, len(s)):\r\n            if s[i] == c:\r\n                ans[i] = 0\r\n            else:\r\n                ans[i] = min(ans[i - 1] + 1, ans[i])\r\n                \r\n        for j in range(len(s) - 2, -1, -1):\r\n            if s[j] == c:\r\n                ans[j] = 0\r\n            else:\r\n                ans[j] = min(ans[j + 1] + 1, ans[j])\r\n        \r\n        return ans\r\n```\r\n### å¤æ‚åº¦\r\næ—¶é—´å¤æ‚åº¦ O(2 * æ•°ç»„size) = O(n)\r\nç©ºé—´å¤æ‚åº¦ ç­”æ¡ˆsize O(n)\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186278497","body":"### æ€è·¯\n\næ­£å¸¸stackæ“ä½œ, åŠ¨æ€æ•°ç»„æ›´æ–°val\n\n### ä»£ç \n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.nums = []\n        self.size = 0\n        self.limit = maxSize\n\n    def push(self, x: int) -> None:\n        if self.size >= self.limit:\n            return\n        self.nums.append(x)\n        self.size += 1\n        return\n\n    def pop(self) -> int:\n        if not self.nums:\n            return -1\n        num = self.nums.pop()\n        self.size -= 1\n        return num\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, self.size)):\n            self.nums[i] += val\n        return\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n### å¤æ‚åº¦åˆ†æ\n\næ—¶é—´å¤æ‚åº¦: push / pull O(1), æ”¹å˜å¢é‡ O(n)\n\nç©ºé—´å¤æ‚åº¦: O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186707653","body":"### æ€è·¯:\r\n\r\nä¸ä½¿ç”¨dfsä¸€ééå†\r\nä¸¤ä¸ªæ ˆ, ä¸€ä¸ªå‹å…¥ä¹˜æ•°, ä¸€ä¸ªå‹å…¥å­—ç¬¦ä¸²\r\n\r\né¢„å¤„ç† ç»™å­—ç¬¦ä¸²ä¸¤è¾¹åŠ ä¸Š\"[\" å’Œ \"]\"\r\nè®¾åŸä¹˜æ•°ä¸º1\r\n\r\né‡åˆ°\"[\" æ•°å­—å…¥æ ˆ, ä¹˜æ•°é‡æ–°è®¾ä¸º0, å°†\"[\" ä½œä¸ºå­—ç¬¦ä¸²markå‹å…¥å­—ç¬¦æ ˆ\r\né‡åˆ° lowercaseå­—æ¯, å¦‚æœæ˜¯ç¬¬ä¸€ä¸ªå­—æ¯, åˆ›é€ æ–°å­—ç¬¦ä¸², ä¸ç„¶æ›´æ–°æœ€è¿‘å­—ç¬¦ä¸²\r\né‡åˆ°ä¹˜æ•°, æ›´æ–°ä¹˜æ•°\r\né‡åˆ° \"]\" æŠŠæ‰€æœ‰ å‰ä¸€ä¸ª \"[\"ä¹‹å‰çš„å­—ç¬¦ä¸²åˆå¹¶ (å­—ç¬¦ä¸²å‡ºæ ˆ) x æœ€è¿‘çš„ä¹˜æ•° (ä¹˜æ•°å‡ºæ ˆ) å†é‡æ–°å‹å…¥å­—ç¬¦ä¸²æ ˆä¸­\r\n\r\næœ€åä¹˜æ•°æ ˆä¸ºç©º, å­—ç¬¦ä¸²æ ˆä¸­å”¯ä¸€ä¸€ä¸ªå…ƒç´ å°±æ˜¯ç­”æ¡ˆ\r\n\r\n### ä»£ç \r\n\r\n```python\r\n\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        strs = []\r\n        nums = []\r\n        \r\n        num = 1\r\n        s = \"[\" + s + \"]\"\r\n        \r\n        for char in s:\r\n            if char == \"[\":\r\n                strs.append(\"[\")\r\n                nums.append(num)\r\n                num = 0\r\n            elif char in \"0123456789\":\r\n                num = num * 10 + int(char)\r\n            elif char in \"abcdefghijklmnopqrstuvwxyz\":\r\n                if strs[-1] == \"[\":\r\n                    strs.append(char)\r\n                else:\r\n                    strs[-1] = strs[-1] + char\r\n            else:\r\n                temp = \"\"\r\n                while strs[-1] != \"[\":\r\n                    temp = strs[-1] + temp\r\n                    strs.pop()\r\n                times = nums.pop()\r\n                strs.pop()\r\n                strs.append(temp * times)\r\n                \r\n        return strs[-1]\r\n\r\n\r\n```\r\n\r\n### å¤æ‚åº¦\r\n\r\næ—¶é—´å¤æ‚åº¦: O(n) n ä¸ºå­—ç¬¦ä¸²å†…æ‰€æœ‰å…ƒç´ ä¸ªæ•°\r\nç©ºé—´å¤æ‚åº¦: O(n) n ä¸ºå­—ç¬¦ä¸²å†…æ‰€æœ‰å…ƒç´ ä¸ªæ•°\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188599398","body":"### æ€è·¯:\n\nç”¨ä¸¤ä¸ªæ ˆ, è¾“å…¥ç”¨ä¸€ä¸ªæ ˆ, è¾“å‡ºç”¨ä¸€ä¸ªæ ˆ\nåªæœ‰è¾“å‡ºæ ˆç©ºçš„æ—¶å€™å§è¾“å…¥æ ˆçš„æ•°æ®dump è¿›è¾“å‡ºæ ˆ\n\n### ä»£ç \n\n```python\n\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if self.stack2:\n            return self.stack2.pop()\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n    \n    def peek(self) -> int:\n        if self.stack2:\n            num = self.stack2.pop()\n            self.stack2.append(num)\n            return num\n        \n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n            \n        num = self.stack2.pop()\n        self.stack2.append(num)\n        return num\n\n    def empty(self) -> bool:\n        return not self.stack1 and not self.stack2\n\n```\n\n### å¤æ‚åº¦:\næ—¶é—´ O(n)\nç©ºé—´ O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189805698","body":"### æ€è·¯:\r\n\r\nä¸€ä¸ªchunkçš„å®šä¹‰å°±æ˜¯å¾€å³è¾¹æ•°çš„æœ€å°å€¼, ç„¶åæ¯”æ‰€æœ‰å·¦è¾¹çš„å€¼éƒ½å¤§...ä»¥æ­¤ä¸ºæ¦‚å¿µä¸¤ä¸ªæ•°ç»„æ±‚æœ€å¤§æœ€å°.\r\næ²¡æœ‰ç”¨åˆ°å•è°ƒæ ˆ?\r\n\r\n### ä»£ç :\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        maxarr = []\r\n        minarr = []\r\n        \r\n        maxnum = float('-inf')\r\n        minnum = float('inf')\r\n        \r\n        for num in arr:\r\n            maxnum = max(num, maxnum)\r\n            maxarr.append(maxnum)\r\n            \r\n        for i in range(len(arr) - 1, -1, -1):\r\n            num = arr[i]\r\n            minnum = min(num, minnum)\r\n            minarr.append(minnum)\r\n            \r\n        minarr = minarr[::-1]\r\n            \r\n        ans = 1\r\n        for i in range(1, len(minarr)):\r\n            if minarr[i] >= maxarr[i - 1]:\r\n                ans += 1\r\n        \r\n        return ans\r\n\r\n```\r\n### å¤æ‚åº¦:\r\n\r\næ—¶é—´ O(n)\r\nç©ºé—´ O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191030424","body":"### æ€è·¯:\n\nå…ˆæ‰¾åˆ°é“¾è¡¨size, å†åŒ–ç®€k\nç„¶åæ‰¾åˆ°é“¾è¡¨æœ€åçš„å°¾\nç„¶åå†ä»å¤´å¼€å§‹å¤´ä¸€ä¸ªä¸ªæ¥åˆ°å°¾ä¸Š\n\n### ä»£ç \n\n```python\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head: return head\n        size = 0\n        mark = head\n        \n        while mark:\n            size += 1\n            mark = mark.next\n        \n        k = k % size\n        \n        if k == 0:\n            return head\n        \n        move = size - k\n        \n        last = head\n        \n        while last.next:\n            last = last.next\n        \n        mark = head\n        \n        for _ in range(move):\n            newmark = mark.next\n            mark.next = None\n            last.next = mark\n            last = mark\n            mark = newmark\n        \n        return newmark\n\n\n```\n\n### å¤æ‚åº¦:\n\nç©ºé—´: O(1)\næ—¶é—´: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192022426","body":"### æ€è·¯:\n\ndummy node + ä¸¤ä¸¤äº¤æ¢\nç”¨node.next å’Œ node.next.next åšwhileé™åˆ¶\næœ€åæ¥ä¸Šæœ€åèŠ‚ç‚¹\n\n### ä»£ç :\n\n```python\n\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode(-1)\n        node = head\n        mark = dummy\n        \n        while node and node.next:\n            nextnode = node.next.next\n            \n            mark.next = node.next\n            mark = mark.next\n            mark.next = node\n            mark = mark.next\n            \n            node = nextnode\n        \n        mark.next = node\n            \n        return dummy.next \n\n```\n\n### å¤æ‚åº¦\n\næ—¶é—´: O(n)\nç©ºé—´: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193082238","body":"### æ€è·¯:\n\nå› ä¸ºlistå·²ç»æ˜¯sortedçš„, ç”¨å“ˆå¸Œè¡¨æŠŠå€¼å’Œåˆ›å»ºtreenodeè”ç³»åœ¨ä¸€èµ·\nå†é€’å½’äºŒåˆ†å¤„ç†æ ¹èŠ‚ç‚¹, æ ¹èŠ‚ç‚¹æ€»æ˜¯å·¦å³èŠ‚ç‚¹çš„ä¸­é—´èŠ‚ç‚¹\n\n### ä»£ç :\n\n```python\n\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        mark = head\n        size = 0\n        ref = {}\n        \n        while mark:\n            ref[size] = TreeNode(mark.val)\n            size += 1\n            mark = mark.next\n        \n        def copy(ref, left, right):\n            if left > right: return None\n            mid = left + (right - left) // 2\n            node = ref[mid]\n            node.left = copy(ref, left, mid - 1)\n            node.right = copy(ref, mid + 1, right)\n            return node\n        \n        return copy(ref, 0, size - 1)\n\n```\n\n```å¤æ‚åº¦\n\næ—¶é—´: O(n)\nç©ºé—´: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193198028","body":"### æ€è·¯:\n\nåŒæŒ‡é’ˆ, è·¯ç¨‹ a + c + b = b + c + a\nå†è®¾ç½®å“¨å…µboolå€¼é¿å…ä¸¤ä¸ªlinkedlistä¸é‡å \n\n### ä»£ç \n\n```python\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        startA, startB = headA, headB\n        pinA, pinB = headA, headB\n        meetA, meetB = False, False\n        \n        while pinA != pinB:\n            pinA = pinA.next\n            pinB = pinB.next\n            \n            if not pinA and not meetA:\n                pinA = startB\n                meetA = True\n            if not pinB and not meetB:\n                pinB = startA\n                meetB = True\n        \n        if pinA == pinB:\n            return pinA\n        \n        return None\n\n```\n### å¤æ‚åº¦\n\næ—¶é—´ O(n)\nç©ºé—´ O(1)\n\n\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194991367","body":"### æ€è·¯:\n\nå“ˆå¸Œè¡¨æ­é…åŒå‘é“¾è¡¨\n\n\n### ä»£ç :\n\n```python\n\nclass Node:\n    def __init__(self, key, val):\n        self.prev = None\n        self.next = None\n        self.key = key\n        self.val = val\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.size = 0\n        self.cap = capacity\n        self.head = Node(-1, -1)\n        self.tail = self.head\n        self.ref = {}\n\n    def get(self, key: int) -> int:\n        if key not in self.ref:\n            return -1\n        node = self.ref[key]\n        if node.next:\n            \n            node.prev.next = node.next\n            node.next.prev = node.prev\n            node.next = None\n            \n            self.tail.next = node\n            node.prev = self.tail\n            \n            self.tail = node\n        return node.val\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.ref:\n            node = self.ref[key] \n            node.val = value\n            if node.next:\n            \n                node.prev.next = node.next\n                node.next.prev = node.prev\n                node.next = None\n\n                self.tail.next = node\n                node.prev = self.tail\n\n                self.tail = node\n        else:\n            self.ref[key] = Node(key, value)\n            \n            self.tail.next = self.ref[key]\n            self.ref[key].prev = self.tail\n            self.tail = self.ref[key]\n            self.size += 1\n            \n            if self.size > self.cap:\n                delete = self.head.next\n                self.head.next = delete.next\n                delete.next.prev = self.head\n                delkey = delete.key\n                del self.ref[delkey]\n                self.size -= 1\n        return\n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196239502","body":"### æ€è·¯:\näºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦, ç­‰äº max(å·¦å­æ ‘çš„æœ€å¤§æ·±åº¦ , å³å­æ ‘æœ€å¤§æ·±åº¦) + 1\né€’å½’\n\n### ä»£ç :\n\n```python\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        def probe(node):\n            if not node:\n                return 0\n            lmax = 1 + probe(node.left)\n            rmax = 1 + probe(node.right)\n            return max(lmax, rmax)\n        return probe(root)\n\n```\n\nå¤æ‚åº¦:\næ—¶é—´ O(n)\nç©ºé—´ O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197656777","body":"### æ€è·¯:\n\né€’å½’, æ¯”è¾ƒå·¦å­æ ‘, æ¯”è¾ƒå³å­æ ‘, æœ‰ä¸€ä¸ªä¸å¯¹å°±è¿”å›é”™\n\n### ä»£ç :\n\n```python\n\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        def compare(r1, r2):\n            if not r1 and not r2:\n                return True\n            if not r1 or not r2:\n                return False\n            if r1.val != r2.val:\n                return False\n            return compare(r1.left, r2.left) and compare(r1.right, r2.right)\n        return compare(p, q)\n\n```\n\n### å¤æ‚åº¦\n\næ—¶é—´ O(n) n ä½æ‰€æœ‰èŠ‚ç‚¹ä¸ªæ•°\nç©ºé—´ O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198873785","body":"### æ€è·¯\n\nè®¾å®šåˆå§‹å€¼ä¸º0, ç„¶åç”¨, å½“å‰å€¼ = ä¸Šä¸€ä¸ªèŠ‚ç‚¹çš„å€¼ * 10 + æœ¬èŠ‚ç‚¹çš„å€¼é€’å½’\n\n### ä»£ç :\n\n```python\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        self.leafsum = 0\n        def getleaf(node, pre):\n            if not node: return 0\n            cur = pre * 10 + node.val\n            if not node.left and not node.right:\n                self.leafsum += cur\n                return\n            if node.left:\n                getleaf(node.left, cur)\n            if node.right:\n                getleaf(node.right, cur)\n            return\n        getleaf(root, 0)\n        return self.leafsum\n\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202027993","body":"å“ˆå¸Œè¡¨\n\n```python\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        ref = {}\n        for i, num in enumerate(nums):\n            if num in ref:\n                return [ref[num], i]\n            ref[target - num] = i\n        return\n\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207298811","body":"### æ€è·¯:\nåŒä½™å®šç†\n\n### ä»£ç :\n```python\nclass Solution:\n    def solve(self, nums, k):\n        total = (sum(nums) + k) % k\n        prefix_sum = 0\n        hashmap = {0: -1}\n        res = len(nums)\n        for i, num in enumerate(nums):\n            prefix_sum += num\n            mod = (prefix_sum + k) % k\n            hashmap[mod] = i\n            if (mod - total + k) % k in hashmap:\n                res = min(res, i - hashmap[(mod - total + k) % k])\n        return res if res != len(nums) else -1\n\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lzyxts":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185188366","body":"### Idea\n\nä»åå¾€å‰åŠ ï¼Œwhile loopä¸­æ›´æ–°list&integer\n\n### Code\n\n\n```python3\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res = []\n        digit = 0\n        \n        while num or k or digit:\n            n1 = num[-1] if num else 0\n            n2 = k%10\n\n            n = n1+n2+digit\n            \n            res.insert(0, n%10)\n            digit = 1 if n>= 10 else 0\n            \n            num = num[:-1]\n            k = k//10\n                \n        return res\n```\n\n### Complexity\n- Timeï¼šO(N)\n- Spaceï¼šO(N) \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185975634","body":"### Idea\n\n- æ‰¾å‡º `==c` çš„æ‰€æœ‰index positions, store in `pos`\n- j è¡¨ç¤º åœ¨sä¸­çš„current index\n- iï¼Œkè¡¨ç¤ºåœ¨`pos`ä¸­ï¼Œç›¸é‚»äºjçš„index\n\n### Code\n\n```python3\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        pos = []\n        res = []\n        \n        for i in range(len(s)):\n            if s[i] == c:\n                pos.append(i)\n        \n        \n        i,j,k = 0,0,0\n        \n        while j < len(s):\n            if i == len(pos):\n                res.append(abs(pos[i-1]-j))\n                j+=1\n                \n            elif j <= pos[i]:\n                a = abs(pos[i]-j)\n                b = abs(pos[k]-j)\n                res.append(min(a,b))\n                j += 1\n                \n            else:\n                if i != 0:\n                    k+=1\n                i+=1\n\n        return res\n```\n\n### Complexity\n- Timeï¼šO(N)\n- Spaceï¼šO(N) as `res` will extend?","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186440842","body":"\n### Idea\n\næŒ‰ç…§ç¤ºä¾‹çš„æƒ…å†µå†™\n\n### Code\n\n```python3\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.list = []\n        \n\n    def push(self, x: int) -> None:\n        if len(self.list) < self.maxSize:\n            self.list.append(x)\n\n    def pop(self) -> int:\n        if not self.list:\n            return -1\n        else:\n            num = self.list[-1]\n            self.list = self.list[:-1]\n\n            return num\n        \n\n    def increment(self, k: int, val: int) -> None:\n        if k >= len(self.list):\n            k = len(self.list)\n        for i in range(k):\n            self.list[i] += val\n        \n```\n\n### Complexity\n- Timeï¼špush ï¼šO(1)ï¼Œpopï¼šO(1)ï¼Œincrementï¼šO(k)\n- Spaceï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186739082","body":"\n### Idea\n\n- ä»sçš„ç¬¬ä¸€ä½è¯»èµ·ï¼Œæ ¹æ®è¯»åˆ°çš„charè¿›è¡Œä¸åŒæ“ä½œï¼š\n* å¦‚æœç¢°åˆ°æ•°å­—åˆ™è®°å½•æ¬¡æ•°ï¼Œå¦‚æœç¢°åˆ°å­—æ¯åˆ™è®°ä¸‹å¹¶ç§»åˆ°ä¸‹ä¸€ä½ï¼Œå¦‚æœ `==[` åˆ™è®°å½•è¯»è¿‡çš„stringå’Œæ¬¡æ•°æ”¾è¿›stackï¼Œå¦‚æœ `==]` åˆ™stack.pop() è¡¥å……ä¸€æ¬¡[]çš„å®Œæ•´string\n- å½“  \\[ \\] æ¬¡æ•°ç›¸åŒæ—¶ï¼Œä¸€ä¸ªå®Œæ•´çš„stringå·²ç»å®Œæˆï¼ŒåŠ è¿›resä¸­\n\n### Code\n\n```python3\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        res = ''\n        l= 0\n        stack = []\n        cur = ''\n        i = 0\n        freq = 0\n        \n        while i < len(s):\n            if s[i] == '[':\n                l += 1\n                stack.append([cur,freq])\n                cur = ''\n                freq = 0\n                i+=1\n            elif s[i].isdigit():\n                while s[i].isdigit():\n                    freq = freq*10+int(s[i])\n                    i+=1\n            elif s[i] == ']':\n                l -=1\n                pre, num = stack.pop()\n                cur = pre + cur*num\n                if l == 0:\n                    res += cur\n                    cur = ''\n                i+=1\n                \n            elif s[i].isalpha():\n                cur += s[i]\n                i+=1\n            \n        return res+cur\n\n```\n\n### Complexity\n- Timeï¼šO(N)\n- Spaceï¼šO(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188169392","body":"### Idea\n\n- s1è®°å½•pushè¿›queueçš„æ•°å€¼\n- s2è®°å½•queueçš„å¤´éƒ¨ä¿¡æ¯\n- å½“è¦è°ƒå–queueå¤´éƒ¨ä¿¡æ¯æ—¶å°†s1çš„å†…å®¹popå‡ºæ¥ï¼Œpushè¿›s2ä¸­ï¼Œå½“s2ä¸­æ— æ•°æ®çš„æ—¶å€™å†ä»s1ä¸­popä¿ç•™é¡ºåº\n\n### Code\n\n```python3\nclass MyQueue:\n\n    def __init__(self):\n        self.s1 = []\n        self.s2 = []\n        \n\n    def push(self, x: int) -> None:\n        self.s1.append(x)\n        \n\n    def pop(self) -> int:\n        if not self.s2:\n            while self.s1:\n                self.s2.append(self.s1.pop())\n            \n        return self.s2.pop()\n        \n        \n    def peek(self) -> int:\n        if not self.s2:\n            while self.s1:\n                self.s2.append(self.s1.pop())\n            \n        return self.s2[-1]\n        \n        \n    def empty(self) -> bool:\n        return not (self.s1 or self.s2)\n\n```\n\n### Complexity\n- Timeï¼špush() & empty(): O(1), pop() & peek(): O(N)\n- Spaceï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189508899","body":"### Idea\n\n- å•è°ƒæ ˆstackå‚¨å­˜ä¸€ä¸ªå•è°ƒé€’å¢çš„arrayï¼Œç”¨äºè®°å½•æ¯ä¸€ä¸ªchunkçš„æœ€å¤§å€¼ï¼Œæœ€åreturn len(stack)\n- éå†arrï¼Œ å¦‚æœ`>= å‰ä¸€ä½` åˆ™æ”¾è¿›stackï¼Œè¡¨ç¤ºå¯ä»¥ä½œä¸ºä¸€ä¸ªå•ç‹¬çš„chunkï¼Œelseåˆ™pop stackä¸­çš„æ•°ç›´åˆ°æ»¡è¶³å•è°ƒæ ˆçš„æ¡ä»¶ï¼Œæ­¤åˆ»æ”¾å…¥ç¬¬ä¸€æ¬¡popçš„å€¼è¿›stackä»£è¡¨è¿™ä¸ªchunkçš„æœ€å¤§å€¼\n\n### Code\n\n```python3\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        last = -1\n        \n        for num in arr:\n            while stack and stack[-1] > num:\n                last = max(stack.pop(), last)\n                \n            stack.append(max(num, last))\n                \n        return len(stack)\n\n```\n\n### Complexity\n- Timeï¼šO(N)\n- Spaceï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190861320","body":"### Idea\n- éå†listï¼Œè®°å½•listé•¿åº¦ `n` ä»¥åŠ tail node `e1`\n- `tail.next = head` è¿æ¥listé¦–å°¾\n- è®¡ç®—break node `e2` where `e2.next` is the new head node\n\n### Code\n\n\n```python3\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return head\n        dummy = ListNode(0)\n        dummy.next = head \n        \n        # length of the list\n        n = 0\n        e1 = dummy\n        while e1.next:\n            e1 = e1.next\n            n += 1\n            \n        e1.next = head\n        jumps = n - k%n\n        \n        # Find the break point\n        e2 = dummy\n        \n        for i in range(jumps):\n            e2 = e2.next\n\n        dummy.next = e2.next\n        e2.next = None\n        \n        return dummy.next\n\n```\n\n### Complexity\n- Timeï¼šO(N)\n- Spaceï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1191976934","body":"### Idea\n- ç”¨æ–‡ç« ä¸­æåˆ°çš„ç©¿é’ˆå¼•çº¿çš„æƒ³æ³•ï¼Œè®°å½•å››ä¸ªç«¯ç‚¹pre, end, head, head.next ç„¶åç”¨.nexté‡æ–°è¿æ¥è¾¾åˆ°æ•ˆæœ\n\n### Code\n\n```python3\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        pre = dummy\n        \n        while head and head.next:\n            end = head.next.next\n            \n            pre.next = head.next\n            pre.next.next = head\n            \n            head.next = end\n            \n            pre = head\n            head = end\n            \n        return dummy.next\n\n```\n\n### Complexity\n- Timeï¼šO(N)\n- Spaceï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1192958829","body":"### Idea\n- å¿«æ…¢æŒ‡é’ˆæ‰¾ä¸­ç‚¹åšroot nodeï¼ŒåŒæ—¶å°†linked listä»¥ä¸­ç‚¹åˆ†å‰²æˆå·¦å³ä¸¤è¾¹ä¸¤ä¸ªå°çš„linked list\n- å·¦è¾¹çš„linked listå°†ä¼šæ”¾åœ¨root.left,ç”¨åŒæ ·çš„æ–¹æ³•æ‰¾ä¸­ç‚¹\n- å³è¾¹ç±»ä¼¼\n\n### Code\n\n```python3\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        fast = slow = head\n        left = head\n        \n        while fast and fast.next:\n            fast = fast.next.next\n            left = slow\n            slow = slow.next\n            \n        left.next = None\n        right = slow.next\n        root = TreeNode(slow.val)\n\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(right)\n        \n        return root\n    \n```\n\n### Complexity\n- Timeï¼šO(nlogn)\n- Spaceï¼šO(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193180083","body":"### Idea\n- å°†list Aæ‰€æœ‰å…ƒç´ å­˜å…¥setä¸­ï¼Œéå†list B æ£€æŸ¥å½“å‰nodeæ˜¯å¦åœ¨setä¸­ã€‚åœ¨åˆ™è¿”å›å½“å‰nodeï¼Œéå†ç»“æŸåˆ™è¡¨ç¤ºä¸åœ¨ï¼Œè¿”å›null\n\n### Code\n\n```python3\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        store = set()\n        \n        while headA:\n            store.add(headA)\n            headA = headA.next\n            \n        while headB:\n            if headB in store:\n                return headB\n            else:\n                headB = headB.next\n                \n        return None\n            \n    \n```\n\n### Complexity\n- Timeï¼šO(n)\n- Spaceï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194846214","body":"### Idea\n- å¿«æ…¢æŒ‡é’ˆæ³•\n- æŒ‡é’ˆç›¸é‡ä¹‹åï¼Œå¿«æŒ‡é’ˆä»å¤´å¼€å§‹ä¸€æ­¥æ­¥èµ°ï¼Œç­‰åˆ°å†æ¬¡ç›¸é‡å°±æ˜¯ç¯çš„èµ·ç‚¹ã€‚æ•°å­¦è¯æ˜\n\n### Code\n\n```python3\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast = slow = head\n\n        if not head or not fast.next or not fast.next.next:\n            return None\n        \n        slow = slow.next\n        fast = fast.next.next\n        \n        while fast.next and fast != slow:\n            fast = fast.next.next\n            slow = slow.next\n            \n            if not (fast and fast.next):\n                return None\n            \n        \n        fast = head\n        \n        while fast != slow:\n            fast = fast.next\n            slow = slow.next\n            \n        return fast\n\n```\n\n### Complexity\n- Timeï¼šO(n)\n- Spaceï¼šO(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194793805","body":"### Idea\n- è·Ÿç€è®²ä¹‰è®¾è®¡é¢˜çš„æ€è·¯ï¼Œä½¿ç”¨åŒå‘é“¾è¡¨ï¼ˆè®°å½•accessçš„å…ˆåï¼‰å’Œhash tableï¼ˆä¸€æ¬¡æå–keyå¯¹åº”çš„key-value pairï¼‰\n- `self.cur` è®°å½•ç°æœ‰é“¾è¡¨é•¿åº¦\n- æ›´æ–°é“¾è¡¨é¡ºåºæ¶‰åŠï¼š1. æå–current node by connecting its pre & nextï¼Œ2. å°†current nodeæ”¾åˆ°æœ€å¤´çš„ä½å­\n- åœ¨putä¸­ï¼Œå¦‚æœkeyäº‹å…ˆå­˜åœ¨ï¼Œåˆ™æ›´æ–°é“¾è¡¨é¡ºåºï¼Œå¦‚keyä¸å­˜åœ¨ï¼Œåˆ™æ–°å»ºnodeï¼›è¿™æ—¶ï¼Œåˆ©ç”¨é•¿åº¦åˆ¤æ–­æ˜¯å¦éœ€è¦åˆ é™¤é“¾è¡¨å°¾éƒ¨node\n\n### Code\n\n```python3\nclass Node:\n    def __init__(self, key, val, pre=None, nxt=None):\n        self.key = key\n        self.val = val\n        self.pre = None\n        self.nxt = None\n        \nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cur = 0\n        self.store = {}\n        self.dummy = Node(0, 0)\n        self.tail = Node(0, 0)\n        \n        self.dummy.nxt = self.tail\n        self.tail.pre = self.dummy\n\n    def get(self, key: int) -> int:\n        \n        if key in self.store:\n            node = self.store[key]\n            \n            node.pre.nxt = node.nxt\n            node.nxt.pre = node.pre\n            \n            temp = self.dummy.nxt\n            self.dummy.nxt = node\n            node.nxt = temp\n            \n            temp.pre = node\n            node.pre = self.dummy\n            \n            \n            return self.store[key].val\n\n        else:\n            return -1\n        \n        \n    def put(self, key: int, value: int) -> None:\n        if key in self.store:\n            self.store[key].val = value\n            \n            node = self.store[key]\n            node.pre.nxt = node.nxt\n            node.nxt.pre = node.pre\n        \n            \n        else:\n            new = Node(key, value)    \n            self.store[key] = new\n            \n            if self.cur >= self.capacity:\n                self.tail = self.tail.pre\n                self.tail.nxt = None\n\n                del self.store[self.tail.key]\n                self.cur -= 1\n                \n            self.cur += 1\n            \n        node = self.store[key]\n        \n        temp = self.dummy.nxt\n        self.dummy.nxt = node\n        node.nxt = temp\n        \n        temp.pre = node\n        node.pre = self.dummy\n```\n\n### Complexity\n- Timeï¼šO(1)\n- Spaceï¼šO(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1195780669","body":"### Idea\n\n- ç”¨é€’å½’çš„æƒ³æ³•ï¼Œæ¯ä¸€ä¸ªæ ‘çš„æœ€å¤§æ·±åº¦ï¼Œéƒ½æ˜¯1 + maxï¼ˆå·¦å­æ ‘æ·±åº¦ï¼Œå³å­æ ‘æ·±åº¦ï¼‰\n- é€’å½’ç»ˆæ­¢æ¡ä»¶æ˜¯æ­¤å­æ ‘ä¸ºç©º\n\n### Code\n\n```python3\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n```\n\n### Complexity\n- Timeï¼šO(N)\n- Spaceï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197059458","body":"### Idea\n\n- ç”¨é€’å½’çš„æƒ³æ³•ï¼Œå¯¹äºç¬¬ä¸€ä¸ªroot nodeè€Œè¨€ only if p.val == q.val ä¸”å·¦å­æ ‘å’Œå³å­æ ‘ä¹Ÿç›¸åŒæ‰æ˜¯ç›¸åŒçš„ä¸¤æ£µæ ‘\n- è€Œå·¦å³å­æ ‘åˆå¯é€šè¿‡ç±»ä¼¼çš„æ–¹å¼åˆ¤æ–­\n- åˆ—å‡ºå¯èƒ½çš„ç»ˆæ­¢æ¡ä»¶\n\n### Code\n\n```python3\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val == q.val:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n        else:\n            return False\n```\n\n### Complexity\n- Timeï¼šO(N)\n- Spaceï¼šO(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198738520","body":"\n### Idea\n\n- ç”¨dfsçš„æ€è·¯ï¼Œresè®°å½•æ‰€æœ‰è·¯å¾„äº§ç”Ÿçš„æ•°å­—ï¼Œæœ€åloopå¾—åˆ°æ€»å’Œ\n- dfsä¸­ï¼Œå¦‚æœä¸€ä¸ªnodeæ˜¯leafï¼Œåˆ™å°†ç°åœ¨çš„æ•°å­—appendåˆ°resä¸­ã€‚\n- ä¸ç„¶ï¼Œnodeä¸‹é¢è¿˜æœ‰å…¶ä»–çš„æ•°å­—ï¼Œå¦‚æœæœ‰å·¦å­æ ‘åˆ™dfså·¦å­æ ‘ï¼Œå¦‚æœæœ‰å³å­æ ‘åˆ™dfså³å­æ ‘ï¼Œç›´åˆ°reach leaf nodeã€‚\n\n### Code\n\n```python3\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        res = []\n       \n        self.dfs(res, root, 0)\n        \n        tot = 0\n        for num in res:\n            tot += num\n        \n        return tot\n    \n    def dfs(self, res, root, temp):\n        if not root:\n            res.append(temp)\n            return\n        if not root.left and not root.right:\n            res.append(temp*10 + root.val)\n            return\n        if root.right:\n            self.dfs(res, root.right, temp*10 + root.val)\n        if root.left:\n            self.dfs(res, root.left, temp*10 + root.val)\n        \n```\n\n### Complexity\n- Timeï¼šO(N)\n- Spaceï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200102159","body":"### Idea\n- ç”¨bfsçš„æƒ³æ³•ï¼Œresè®°å½•æ¯ä¸€å±‚çš„å¤´ä¸€ä¸ªæ•°ï¼Œé‚£ä¹ˆæœ€åreturn reså°±æ˜¯æœ€åä¸€å±‚çš„æœ€å·¦è¾¹çš„å€¼\n- bfsä¸­ï¼Œéå†å½“å‰å±‚çš„nodeï¼Œç”¨curè®°å½•nodeçš„å­æ ‘ã€‚éå†ç»“æŸåï¼Œset q=curï¼Œå¼€å§‹ä¸‹ä¸€å±‚çš„éå†ã€‚å½“qä¸ºç©ºæ—¶ï¼Œå·²ç»éå†å®Œæœ€åä¸€å±‚äº†ã€‚\n\n### Code\n\n```python3\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        q = [root]\n        \n        while q:\n            res = q[0].val\n            cur = []\n            \n            for node in q:\n                if node.left:\n                    cur.append(node.left)\n                if node.right:\n                    cur.append(node.right)\n                \n            q = cur\n        return res\n        \n```\n\n### Complexity\n- Timeï¼šO(N)\n- Spaceï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1204569054","body":"### Idea\n- ç”¨bfsçš„æƒ³æ³•ï¼ŒæŒ‰ç…§å®˜æ–¹çš„æ’åºé¡ºåºï¼Œå°†tree store æˆlistçš„å½¢å¼ï¼Œå…¶ä¸­ç©ºçš„nodeç”¨'#'è¡¨ç¤ºã€‚å°†list store æˆstring\n- ååºåˆ—åŒ–æ—¶ï¼Œåšå‡ æ­¥è½¬æ¢å°†stringè½¬åŒ–ä¸ºä¹‹å‰çš„listå½¢å¼ã€‚æŒ‰ç…§ä¹‹å‰bfsçš„æƒ³æ³•ï¼Œé‡æ–°æ„å»ºtreeã€‚\n\n### Code\n\n```python3\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        res, q = [], [root]\n        if not root:\n            return ''\n        \n        while q:\n            cur = []\n            for node in q:\n                if node != '#':\n                    res.append(node.val)\n                    \n                    if node.left:\n                        cur.append(node.left)\n                    else:\n                        cur.append('#')\n\n                    if node.right:\n                        cur.append(node.right)\n                    else:\n                        cur.append('#')\n                else:\n                    res.append('#')\n\n            q = cur\n            \n        return str(res)\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        data = data.replace('[', ',')\n        data = data.replace(']', ',')\n        data = data.replace(' ', ',')\n        \n        data = data.split(',')\n        data = [x for x in data if x != '']\n\n        if not data:\n            return None\n        \n        def construct(data):\n            root = TreeNode(int(data.pop(0)))\n            \n            q = deque([])\n            q.append(root)\n            \n            while q:\n                \n                for _ in range(len(q)):\n                    node = q.popleft()\n                    left = data.pop(0)\n                    \n                    right = data.pop(0)\n                    \n                    if left != \"'#'\":\n                        node.left = TreeNode(int(left))\n                        q.append(node.left)\n                    if right != \"'#'\":\n                        node.right = TreeNode(int(right))\n                        q.append(node.right)\n\n            return root\n        \n        return construct(data)\n\n        \n```\n\n### Complexity\n- Timeï¼šO(N)\n- Spaceï¼šO(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1203108835","body":"### Idea\n- ç”¨bfséå†æ ‘ï¼Œè®°å½•æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„åæ ‡ã€‚åŒæ—¶ç”¨hash tableçš„keyæ˜¯åæ ‡ï¼Œvalueæ˜¯å¯¹æ ‡å¯¹åº”çš„list of valuesã€‚åŒæ—¶ç”¨listè®°å½•éå†ä¸­æ‰€æœ‰è§åˆ°çš„åæ ‡\n- éå†å®Œæˆåï¼Œsort list by its col valuesã€‚å¤§æ¦‚å› ä¸ºä¹‹å‰ç”¨çš„bfsï¼Œæ‰€ä»¥æ­¤æ—¶rowä¹Ÿæ˜¯sortå¥½çš„ã€‚æˆ–è€…å¤šä¸€æ­¥sort row numbers\n- å»ºç«‹æ–°çš„hash tableï¼Œæ­¤æ—¶çš„keyæ˜¯colï¼Œå°†å‰ä¸€ä¸ªhash tableçš„sorted listæŒ‰ç¬¬äºŒæ­¥æ’å¥½çš„é¡ºåºæ”¾è¿›æ¥\n- è¾“å‡ºhash tableçš„æ‰€æœ‰valuesæ•´åˆæˆä¸€ä¸ªlist\n\n### Code\n\n```python3\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        store = defaultdict(list)\n        seen = []\n        \n        q = [(root, 0, 0)]\n        cur = []\n        \n        while q:\n            for item in q:\n                node, currow, curcol = item\n                if (currow, curcol) not in seen:\n                    seen.append((currow, curcol))\n                    \n                store[(currow, curcol)].append(node.val)\n\n                if node.left:\n                    cur.append((node.left, currow+1, curcol-1))\n\n                if node.right:\n                    cur.append((node.right, currow+1, curcol+1))\n            q = cur\n            cur = []\n                \n        res = [] \n        \n        seen = sorted(seen, key = lambda x: (x[1]))\n        print(seen)\n        \n        store1 = defaultdict(list)\n        \n        for i in range(len(seen)):\n            store1[seen[i][1]].extend(sorted(store[seen[i]]))\n            \n        for col in store1:\n            res.append(store1[col])\n        \n        return res\n        \n```\n\n### Complexity\n- Timeï¼šO(N^2logn)\n- Spaceï¼šO(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202896833","body":"### Idea\n- ç”¨hash table, å¦‚æœå½“å‰numä¸åœ¨storeä¸­ï¼Œå°†numå’Œindexå­˜å…¥storeä¸­\n- éå†ä¹‹åçš„å…ƒç´ æ—¶ï¼Œæ£€æŸ¥target - numæ˜¯å¦åœ¨storeä¸­ï¼Œåœ¨åˆ™è¿”å›ä¸¤ä¸ªçš„indexï¼Œä¸åœ¨åˆ™å­˜å…¥storeè·‘ä¸‹ä¸€ä¸ªæ•°\n\n### Code\n\n```python3\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        store = {}\n        i = 0\n        \n        while i<len(nums):\n            resi = target - nums[i]\n            if resi not in store:\n                store[nums[i]] = i\n                \n            else:\n                return [i, store[resi]]\n             \n            i+= 1\n        \n```\n\n### Complexity\n- Timeï¼šO(N)\n- Spaceï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1204110458","body":"### Idea\n- ç”¨hash tableéå†listè®°å½•æ¯ä¸ªæ•°å­—å‡ºç°çš„æ¬¡æ•°\n- initiate ä¸€ä¸ªlength ä¸ºkçš„listï¼Œå°†hash tableé‡Œçš„tuple pushè¿›heapä¹‹åå†popå‡ºæ¥\n- æœ€åç•™åœ¨heapä¸­çš„åˆ™æ˜¯å‡ºç°é¢‘ç‡æœ€å¤šçš„kçš„å…ƒç´ ï¼Œè¿”å›\n\n### Code\n\n```python3\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        store = {}\n        \n        for num in nums:\n            if num not in store:\n                store[num] = 1\n            else:\n                store[num] += 1\n                \n                \n        res = [(0,0)]*k\n        heapq.heapify(res)\n      \n        for key in store:\n            heapq.heappushpop(res, (store[key], key))\n        \n        \n        return [x[1] for x in res]\n        \n```\n\n### Complexity\n- Timeï¼šO(N)\n- Spaceï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205442701","body":"### Idea\n- è®¡ç®—ä»»æ„ä¸¤ç‚¹è·ç¦»ï¼Œå°†è·ç¦»ä½œä¸ºkeyï¼Œå½“å‰ä¸¤ç‚¹ä½œä¸ºvalueå­˜å…¥hash tableä¸­ã€‚hash tableå°†æ‰€æœ‰è·ç¦»ç›¸åŒçš„ä¸¤ç‚¹å½’åˆ°ä¸€ä¸ªlistä¸­ã€‚\n- æå–hash tableçš„æ‰€æœ‰listï¼Œå–ä»»æ„ä¸¤ä¸ªå…ƒç´ æ¯”è¾ƒã€‚å¦‚æœ(a,b)å’Œ(c,d)ä¸­æœ‰ç›¸åŒçš„indexï¼Œåˆ™è¡¨ç¤ºæ­¤indexå¯ä»¥ä½œä¸ºi; j,kåˆ™æ˜¯å‰©ä¸‹çš„ä¸¤ä¸ªåæ ‡ç‚¹ã€‚æ­¤æ—¶ans += 2\n\n### Code\n\n```python3\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        if len(points) <= 2:\n            return 0\n        \n        ans = 0\n        store = defaultdict(list)\n\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                dist = (points[i][0] - points[j][0])**2 + (points[i][1] - points[j][1])**2 \n                store[dist].append((i,j))\n                \n        for key in store:\n            pts = store[key]\n            for i in range(len(pts)):\n                for j in range(i+1, len(pts)):\n                    x1, y1 = pts[i]\n                    x2, y2 = pts[j]\n                    \n                    if x1 == x2 or x1 == y2 or y1 == x2 or y1 == y2:\n                        ans +=2\n        return ans\n        \n```\n\n### Complexity\n- Timeï¼šO(N^2)\n- Spaceï¼šO(N^2)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205543590","body":"### Idea\n- ç”¨æ»‘åŠ¨çª—å£çš„æƒ³æ³•ï¼ŒæŒ‡é’ˆiéå†stringï¼Œç”¨hash tableå‚¨å­˜æ¯ä¸ªå­—æ¯å‡ºç°çš„æ¬¡æ•°ã€‚\n- å¦‚æœå½“å‰å­—æ¯ä¹‹å‰å‡ºç°è¿‡ï¼Œè¿™æ—¶å€™æŒ‡é’ˆjå¼€å§‹èµ°ï¼Œç›´åˆ°substring\\[jï¼›i\\]ä¸åŒ…å«é‡å¤å­—æ¯ã€‚\n- æ¯èµ°ä¸€æ­¥è®¡ç®—j-içš„substring é•¿åº¦ï¼Œæœ€åè¿”å› \n\n### Code\n\n```python3\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        res = 0\n        \n        if not s:\n            return res\n        \n        store = defaultdict(int)\n        i, j = 0, 0\n        \n        while i<len(s):\n            if s[i] not in store:\n                store[s[i]] += 1\n                res = max(res, i-j+1)\n                i+=1\n            else:\n                store[s[i]] += 1\n                while store[s[i]] > 1:\n                    store[s[j]] -= 1\n                    j += 1\n                res = max(res, i-j+1)\n                i+=1\n        \n        return res\n        \n```\n\n### Complexity\n- Timeï¼šO(N)\n- Spaceï¼šO(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207169938","body":"### Idea\n- è¶…æ—¶æƒ³æ³•ï¼Œhash table wordstore è®°å½•wordsä¸­å•è¯å‡ºç°é¢‘ç‡, curè®°å½•å½“å‰substringçš„å•è¯å‡ºç°æ¬¡æ•°ã€‚substringç”±åŒæŒ‡é’ˆiï¼Œjè¿›è¡Œè®°å½•ã€‚å¦‚æœä¸¤è¡¨ç›¸åŒï¼Œappend å·¦æŒ‡é’ˆè¿›resã€‚\n- å·¦æŒ‡é’ˆéå†sï¼Œå½“s\\[j:j+n\\] åœ¨wordsä¸­æ—¶å¼€å§‹ç§»åŠ¨æŒ‡é’ˆiï¼Œæ¯æ¬¡è·³è·ƒnæ­¥ã€‚å¦‚æœs\\[i:i+n\\] ä¸åœ¨wordsä¸­ï¼Œæˆ–æ¬¡æ•°è¶…è¿‡åˆ™j+1é‡æ–°æ‰¾ä¸‹ä¸€ä¸ªæ»¡è¶³çš„index\n\n### Code\n\n```python3\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        res = []\n        n = len(words[0])\n        \n        if n>len(s):\n            return res\n        \n        wordstore = defaultdict(int)\n        \n        \n        for item in words:\n            wordstore[item] += 1\n\n        first = [item[0] for item in words]\n        \n        i,j = 0,0\n\n        while j < len(s):\n            \n            while j < len(s) and s[j] not in first:\n                j+=1\n            i=j\n            cur = defaultdict(int)\n            \n            while s[i:i+n] in wordstore:\n                cur[s[i:i+n]] += 1\n                if cur[s[i:i+n]] > wordstore[s[i:i+n]]:\n                    break\n                \n                i = i+n\n                \n                if wordstore == cur:\n                    res.append(j)\n                    break\n            \n            j+=1\n            \n        return res\n        \n```\n\n### Complexity\n- Timeï¼šO(NM)\n- Spaceï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1208567389","body":"### Idea\n- åŒä½™å®šç†ï¼Œé¦–å…ˆåˆ›å»ºå‰ç¼€å’Œåˆ—è¡¨ã€‚é¢˜ç›®ç­‰åŒäºæ‰¾å‡ºmin subarrayçš„ä½™æ•°ä¸æä¾›åˆ—è¡¨çš„ä½™æ•°ç›¸åŒã€‚\n- éå†å‰ç¼€å’Œåˆ—è¡¨sumï¼Œå‡è®¾è¦æ‰¾çš„subarray sum\\[i:j\\]çš„ä½™æ•°ä¸ºkï¼Œå½“å‰sum\\[j\\]çš„ä½™æ•°ä¸ºmï¼Œé‚£ä¹ˆå¦‚æœä¹‹å‰æœ‰ä¸€ä¸ªsum\\[i-1\\]çš„ä½™æ•°ä¸ºm-kï¼Œå°±å¯ä»¥æ‰¾åˆ°è¦çš„i & j. å¦‚æœm<kåˆ™éœ€è¦+p.\n                                                                                                    \n\n### Code\n\n```python3\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n                \n        pre = [0]*len(nums)\n\n        for i in range(len(nums)):\n            if i == 0:\n                pre[i] = nums[0]\n            else:\n                pre[i] = pre[i-1] + nums[i]\n                \n        resid = pre[-1]%p\n        \n        if not resid:\n            return 0\n        \n        ans = float('inf')\n        store = {}\n        \n        for i in range(len(nums)):\n            mod1 = pre[i]%p\n            mod = nums[i]%p\n            if mod == resid:\n                return 1\n            if mod1 == resid and i<len(nums)-1:\n                ans = min(ans, i+1)\n            else:\n                if mod1 - resid < 0:\n                    res = mod1 + p - resid\n                else:\n                    res = mod1 - resid\n              \n                if res in store:\n                    ans = min(ans, i-store[res])\n            \n            store[mod1] = i\n        \n        return ans if ans < len(nums) else -1\n        \n```\n\n### Complexity\n- Timeï¼šO(N)\n- Spaceï¼šO(N)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207687340","body":"### Idea\n- å¿«æ…¢æŒ‡é’ˆï¼Œå½“å¿«æŒ‡é’ˆèµ°åˆ°å¤´çš„æ—¶å€™return slowå°±æ˜¯è¦æ±‚çš„node\n\n### Code\n\n```python3\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast = slow = head\n        \n        while fast.next:\n            \n            if fast.next and fast.next.next:\n                fast = fast.next.next\n                slow = slow.next\n            elif fast.next:\n                return slow.next\n        \n        return slow\n        \n```\n\n### Complexity\n- Timeï¼šO(N)\n- Spaceï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208601575","body":"### Idea\n- åŒæŒ‡é’ˆï¼ŒæŒ‡é’ˆiéå†liståˆ¤æ–­æ˜¯å¦æ˜¯æ–°çš„å…ƒç´ ï¼›æŒ‡é’ˆjè®°å½•ä¸‹ä¸€ä¸ªå…ƒç´ æ”¾ç½®çš„ä½å­ã€‚\n- ansè®°å½•jç§»åŠ¨çš„æ¬¡æ•°ï¼Œä»£è¡¨åˆ—è¡¨çš„å¤´éƒ¨å·²ç»æ»¡è¶³è¦æ±‚çš„éƒ¨åˆ†ã€‚å¾ˆå¤§ç¨‹åº¦å€ŸåŠ©äº†åŸåˆ—è¡¨non descreasingçš„æ€§è´¨ã€‚\n\n### Code\n\n```python3\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        ans = 1\n        if len(nums) == 1:\n            return ans\n        i, j = 0, 0\n        while i < len(nums):\n            while i== 0 or nums[i] <= nums[i-1]:\n                i += 1\n                if i == len(nums):\n                    return ans\n            nums[j+1] = nums[i]\n            ans += 1\n            j+=1\n            i+=1\n        return ans\n        \n```\n\n### Complexity\n- Timeï¼šO(N)\n- Spaceï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/42#issuecomment-1209912177","body":"### Idea\n- äºŒåˆ†æ³•ï¼Œå–\\[1, 3, 5, 6\\]ï¼Œä»¥åŠtarget = 0, 4, 7è€ƒè™‘ä¸‰ç§ä¸åŒçš„å¯èƒ½æ€§åˆ¤æ–­ä¸€äº›è¾¹ç•Œæƒ…å†µã€‚\n- æœ€åå‘ç°ä¸è®ºå“ªç§æƒ…å†µç»“æœéƒ½æ˜¯j+1\n\n### Code\n\n```python3\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        if len(nums) == 1:\n            return 0 if target <= nums[0] else 1\n        \n        i, j = 0, len(nums)-1\n        \n        while i<=j:\n            mid = (i+j)//2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                i = mid+1\n            else:\n                j = mid-1\n                \n        return j+1\n```\n\n### Complexity\n- Timeï¼šO(logN)\n- Spaceï¼šO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elainekuo":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185190357","body":"### æ€è·¯\r\n\r\né€ä½ç›¸åŠ \r\n\r\n### ä»£ç \r\n\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    let res = [];\r\n    let len = num.length;\r\n    for(let i=len-1; i>=0;i--){\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if(sum>=10){\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);  \r\n    }\r\n    for(let i =k;i>0;i=Math.floor(i/10)){\r\n        res.push(i % 10)\r\n    }\r\n    res.reverse();\r\n    return res;\r\n\r\n};\r\n```\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186100713","body":"\n### æ€è·¯\n\nå…ˆè·å–å­—ç¬¦åœ¨å­—ç¬¦ä¸²ä¸­çš„æ‰€æœ‰ä½ç½®ï¼Œç„¶åéå†ç®—å‡ºæœ€å°è·ç¦»\n\n### ä»£ç \n\n\n```js\n\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let targetS = getCharactorIndex(s,c);\n    let res = [];\n    for(let i=0; i<s.length; i++){\n        let min = Number.MAX_SAFE_INTEGER;\n        for(let j=0;j<targetS.length;j++){\n            min = Math.min(min,Math.abs(targetS[j] - i));\n        }\n        res.push(min);\n    }\nreturn res;\n\n};\n\nconst getCharactorIndex = (s,c) =>{\n    let res = [];\n    let charactorArray = s;\n    let idx = charactorArray.indexOf(c);\n    let num = 0;\n    while(idx != -1){\n        res.push(idx);\n        num++\n        idx = charactorArray.indexOf(c,idx+1);\n    }\n    return res;\n\n}\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n^2)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186371345","body":"\n### æ€è·¯\n\næ•°ç»„å®ç°æ ˆ\n\n### ä»£ç \n\n\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.stack = [];\n    this.n = maxSize;\n\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stack.length >= this.n){\n        return\n    }\n    this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.stack.length>0){\n       return this.stack.pop();\n    }\n    return -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let temp = this.stack.splice(0,k>=this.stack.length?this.stack.length:k);\n    temp = temp.map((item)=>{\n        return item = item + val\n    })\n    this.stack = temp.concat(this.stack);\n};\n\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186785147","body":"\n### æ€è·¯\n\nåˆ©ç”¨æ ˆçš„æ–¹å¼ï¼›å½“é‡åˆ°æ•°å­—æ—¶ï¼Œå­˜å…¥æ ˆã€‚ é‡åˆ°â€˜ã€â€™æ—¶ï¼Œè®°å½•å‰é¢çš„å­—ç¬¦ç»“æœï¼Œç„¶åå…¥æ ˆï¼›é‡åˆ°â€˜ã€‘â€™æ—¶ï¼Œæ•°å­—å’Œä¸Šæ¬¡çš„stråŒæ—¶å‡ºæ ˆï¼Œç„¶åè®¡ç®—æœ¬æ¬¡çš„å­—ç¬¦ä¸²çš„å åŠ ã€‚\n\n### ä»£ç \n\n\n```js\nvar decodeString = function(s) {\n    let numStack = [];\n    let strStack = [];\n    let num =0;\n    let res = '';\n\n    for(let char of s){\n        if(!isNaN(char)){\n            num = num * 10 + Number(char);\n        }else if(char === '['){\n            strStack.push(res);\n            res = '';\n            numStack.push(num);\n            num = 0;\n        }else if(char ===']'){\n            res = strStack.pop() + res.repeat(numStack.pop());\n        }else{\n            res += char;\n        }\n    }\n    return res;\n\n};\n\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188914373","body":"\n### æ€è·¯\n\npushæ–¹æ³•å°†æ•°æ®å­˜å…¥stack1ä¸­ï¼Œç”¨stack1æ¥å­˜å‚¨æ•°æ®<br>\npopæ–¹æ³•å°†stack1çš„æ•°æ®å¼¹å‡ºï¼Œå½“stack2ä¸ºç©ºæ—¶ï¼Œå°†stack1çš„æ•°æ®å¼¹å‡ºï¼Œpushåˆ°stack2ä¸­ã€‚ç„¶åå†å¼¹å‡ºæœ€åä¸€æ¡ï¼Œå°±æ˜¯é˜Ÿåˆ—çš„ç¬¬ä¸€æ¡\n\n### ä»£ç \n\n\n```js\nvar MyQueue = function() {\n    this.stack1 = [];\n    this.stack2 = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.stack1.push(x);\n\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n     if(!this.stack2.length){\n         while(this.stack1.length){\n             this.stack2.push(this.stack1.pop())\n         }\n     }\n     return this.stack2.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(!this.stack2.length){\n        while(this.stack1.length){\n             this.stack2.push(this.stack1.pop())\n        }\n    }\n    return this.stack2[this.stack2.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.stack1.length && !this.stack2.length;\n};\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191383951","body":"### æ€è·¯\n1ã€ç¡®è®¤ç§»åŠ¨æ­¥æ•°ä¸ºï¼ˆé“¾è¡¨é•¿åº¦%kï¼‰\n2ã€å¾ªç¯å‰©ä½™ç§»åŠ¨éƒ¨ç½²ï¼ŒæŒ‡é’ˆæ¸¸èµ°ï¼Œç¡®å®šæœ€åé“¾è¡¨ç»“æœã€‚\n\n### ä»£ç \n\n\n```js\nvar rotateRight = function(head, k) {\n    if (k === 0 || !head || !head.next) {\n        return head;\n    }\n    let n = 1;\n    let cur = head;\n    while(cur.next){\n        cur = cur.next;\n        n++\n    }\n    let move = n - k % n;\n    cur.next = head;\n    while(move){\n        cur = cur.next;\n        move--;\n    }\n    let ans = cur.next;\n    cur.next = null;\n    return ans;\n};\n\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193934899","body":"\n### æ€è·¯\n\nåˆ©ç”¨å“ˆå¸Œè¡¨ï¼Œå®šä¹‰ä¸€ä¸ªvisitedè®°å½•é“¾è¡¨èŠ‚ç‚¹ï¼Œå¦‚æœå­˜åœ¨ç¯ï¼Œå°±ä¼šåœ¨å“ˆå¸Œè¡¨ä¸­æŸ¥åˆ°ã€‚\n\n### ä»£ç \n\n\n```js\nvar detectCycle = function(head) {\n    const visited = new Set();\n    while(head != null){\n        if(visited.has(head)){\n            return head;\n        }\n        visited.add(head);\n        head = head.next;\n    }\n    return null;\n};\n\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºé“¾è¡¨é•¿åº¦ã€‚\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196627791","body":"\n### æ€è·¯\n\næ·±åº¦éå†ï¼Œåˆ†åˆ«æ±‚å‡ºå·¦å­æ ‘ã€å³å­æ ‘çš„æ·±åº¦ï¼Œç„¶åæ±‚æœ€å¤§å€¼ï¼Œå†åŠ ä¸Š1ï¼ˆåˆ°æ ¹èŠ‚ç‚¹çš„æ·±åº¦ï¼‰\n\n### ä»£ç \n\n\n```js\nvar maxDepth = function(root) {\n    if(!root) return 0;\n    let left = maxDepth(root.left);\n    let right = maxDepth(root.right);\n    return Math.max(left,right)+1;\n\n};\n\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\n- ç©ºé—´å¤æ‚åº¦ï¼šO(height)ï¼Œå­æ ‘çš„æœ€å¤§é«˜åº¦","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197984009","body":"### æ€è·¯\n\næ·±åº¦ä¼˜å…ˆéå†\n\n### ä»£ç \n\n\n```js\nvar isSameTree = function(p, q) {\n    if(p == null && q == null) \n        return true;\n    if(p == null || q == null) \n        return false;\n    if(p.val != q.val) \n        return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n};\n\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199361383","body":"\n### æ€è·¯\n\næ·±åº¦éå†\n\n### ä»£ç \n\n\n```js\nconst dfs = (root, prevSum) => {\n    if(root === null) return null;\n    let sum = prevSum * 10 + root.val;\n    if(root.left === null && root.right === null){\n        return sum;\n    }else{\n        return dfs(root.left,sum)+dfs(root.right,sum)\n    }\n}\nvar sumNumbers = function(root) {\n    return dfs(root,0);\n};\n\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200428117","body":"### æ€è·¯\n\næ·±åº¦ä¼˜å…ˆæœç´¢\n\n### ä»£ç \n\n\n```js\nvar serialize = function(root) {\n    return rserialize(root, '');\n};\n\nvar deserialize = function(data) {\n    const dataArray = data.split(\",\");\n    return rdeserialize(dataArray);\n};\n\nconst rserialize = (root, str) => {\n    if (root === null) {\n        str += \"None,\";\n    } else {\n        str += root.val + '' + \",\";\n        str = rserialize(root.left, str);\n        str = rserialize(root.right, str);\n    }\n    return str;\n}\n\nconst rdeserialize = (dataList) => {\n    if (dataList[0] === \"None\") {\n        dataList.shift();\n        return null;\n    }\n\n    const root = new TreeNode(parseInt(dataList[0]));\n    dataList.shift();\n    root.left = rdeserialize(dataList);\n    root.right = rdeserialize(dataList);\n\n    return root;\n}\n\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201255908","body":"\n### æ€è·¯\n\nå¤šç»´æ’åºï¼ŒæŒ‰ç…§colã€rowã€valçš„ä¼˜å…ˆçº§æ’åº<br>\nç„¶åå†éå†ï¼Œé’ˆå¯¹ç›¸åŒcolçš„æ”¾å…¥éƒ½åŒä¸€æ•°ç»„ä¸­ã€‚\n\n### ä»£ç \n\n\n```js\nvar verticalTraversal = function(root) {\n    const nodes =[];\n    dfs(root,0,0,nodes);\n    nodes.sort((a,b)=>a[0]-b[0] || a[1]-b[1] || a[2]-b[2]);\n    const ans = [];\n    let lastcol = -Number.MAX_VALUE;\n    for (const item of nodes) {\n        let col = item[0], row = item[1], value = item[2];\n        if(col != lastcol){\n            lastcol = col;\n            ans.push([]);\n        }\n        ans[ans.length - 1].push(value);\n    }\n    return ans;\n\n};\n\nconst dfs = (node,col,row,nodes) =>{\n    if(node === null){\n        return null;\n    }\n    nodes.push([col,row,node.val]);\n    dfs(node.left,col-1,row+1,nodes);\n    dfs(node.right,col+1,row+1,nodes)\n}\n\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202898137","body":"\n### æ€è·¯\n\nå“ˆå¸Œç¼“å­˜ï¼Œä¸€æ¬¡éå†\n\n### ä»£ç \n\n\n```js\nvar twoSum = function(nums, target) {\n    let map = new Map();\n    for(let i = 0,len = nums.length; i<len;i++){\n        if(map.has(target - nums[i])){\n            return [map.get(target-nums[i]),i]\n        }else{\n            map.set(nums[i],i)\n        }\n    }\n    return []\n};\n\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205447071","body":"\n### æ€è·¯\n\næšä¸¾ + å“ˆå¸Œè¡¨\n\n### ä»£ç \n\n\n```js\nvar numberOfBoomerangs = function(points) {\n    let ans = 0;\n    for (const p of points) {\n        const cnt = new Map();\n        for (const q of points) {\n            const dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n            cnt.set(dis, (cnt.get(dis) || 0) + 1);\n        }\n        for (const [_, m] of cnt.entries()) {\n            ans += m * (m - 1);\n        }\n    }\n    return ans;\n};\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n2)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208301398","body":"\n### æ€è·¯\n\nä¸¤ä¸ªæŒ‡é’ˆåŒæ—¶æ»‘åŠ¨ï¼Œpæ»‘åŠ¨ä¸€æ­¥ï¼ŒQèµ°ä¸¤æ­¥ã€‚<br>\nå½“påˆ°é“¾è¡¨æœ«å°¾æ—¶ï¼Œå³å¾—å‡ºä¸­é—´èŠ‚ç‚¹ã€‚\n\n### ä»£ç \n\n\n```js\nvar middleNode = function(head) {\n    let p = head,\n        q = head;\n    \n    while (q.next != null && q.next.next != null) {\n        p = p.next;\n        q = q.next.next;\n    }\n\n    if (q.next == null) {\n        return p;\n    } else {\n        return p.next;\n    }    \n\n};\n\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ll491119940":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185193124","body":"## æ€è·¯\nè¾“å…¥Kæ•°å­—è½¬æ¢æˆæ•°ç»„ï¼Œå°†æ•°ç»„ä»æœ«ä½å¼€å§‹ï¼ŒæŒ‰ä½ç›¸åŠ ï¼Œè€ƒè™‘è¿›ä½ï¼Œæœ€åè¿”å›ç›¸åŠ åæ•°ç»„\n\n## ä»£ç \n\n```\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let result = [];\n    let arrK = String(k).split('');\n    let flag = 0;\n    num.reverse();\n    arrK.reverse();\n    for(let i = 0; i < num.length || i < arrK.length; i++) {\n        var retNum = (num[i] || 0) + (+arrK[i] || 0) + flag;\n        if (retNum >= 10) {\n            retNum = retNum % 10;\n            flag = 1;\n        } else {\n            flag = 0;\n        }\n        result.push(retNum);\n    }\n\n    if(flag) {\n        result.push(1);\n    }\n    result.reverse();\n    return result\n};\n```\n## ç®—æ³•å¤æ‚åº¦\n\n+ æ—¶é—´å¤æ‚åº¦ O(n)\n+ ç©ºé—´å¤æ‚åº¦ O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186415178","body":"## æ€è·¯\n ç”¨æ•°ç»„æ¨¡æ‹Ÿæ ˆï¼›\n## ä»£ç \n```\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.stack = [];\n    this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    const len = this.stack.length;\n    if(len >= this.maxSize) return;\n    this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(!this.stack.length) return -1;\n    return this.stack.pop();\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    const minIdx = Math.min(this.stack.length, k)\n    for(let i = 0; i < minIdx; i++) {\n        this.stack[i] += val;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n## å¤æ‚åº¦åˆ†æ\n+ æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n+ ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187672624","body":"## æ€è·¯\n ç”¨ä¸¤ä¸ªæ ˆåˆ†åˆ«è®°å½•æ•°å­—å’Œå­—ç¬¦ä¸²\n\n## ä»£ç \n```\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n  let nums = [];              \n    let strs = [];              \n\n    let num = 0, result = '';\n\n    for(let i = 0; i < s.length; i++) {\n        const item = s[i];\n\n        if(!isNaN(item)) {             \n            num = num * 10 + parseInt(item);\n        } else if(item === '[') {\n            strs.push(result);\n            result = '';\n            nums.push(num);\n            num = 0;\n        } else if(item === ']') {\n            const finalNums = nums.pop();        \n            result = strs.pop() + result.repeat(finalNums);\n        } else {\n            result += item;\n        }\n    }\n    return result;\n};\n```\n## å¤æ‚åº¦\n+ æ—¶é—´å¤æ‚åº¦ï¼š O(n)\n+ ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189214791","body":"## æ€è·¯\nç”¨ä¸¤ä¸ªæ ˆæ¥æ¨¡æ‹Ÿé˜Ÿåˆ—ï¼Œä¸€ä¸ªè´Ÿè´£pushï¼Œä¸€ä¸ªè´Ÿè´£popï¼Œpushæ—¶ä¿è¯popçš„æ ˆä¸ºç©ºï¼Œpopæ—¶ä¿è¯pushæ ˆä¸ºç©º\n## ä»£ç \n```\nvar MyQueue = function() {\n    this.stack1 = [];\n    this.stack2 = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    while(this.stack2.length) {\n        this.stack1.push(this.stack2.pop());\n    }\n    this.stack1.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    while(this.stack1.length) {\n        this.stack2.push(this.stack1.pop());\n    }\n    return this.stack2.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    while(this.stack1.length) {\n        this.stack2.push(this.stack1.pop());\n    }\n    return this.stack2[this.stack2.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.stack1.length && !this.stack2.length\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n## å¤æ‚åº¦\n+ æ—¶é—´å¤æ‚åº¦: O(n)\n+ ç©ºé—´å¤æ‚åº¦: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190389570","body":"\n## æ€è·¯\næ»‘åŠ¨çª—å£ï¼Œå¯¹æ¯”è¾“å…¥æ•°ç»„å’Œæ’åºåæ•°ç»„ï¼Œæ¯ä¸ªåˆ†å—ä¸­å…ƒç´ æ˜¯ä¸€æ ·çš„\n## ä»£ç \n```\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n   const sorted = [...arr];\n   sorted.sort((a,b) => (a - b));\n   let ans = 0;\n   let sums1 = 0;\n   let sums2 = 0;\n   for(let i = 0; i < arr.length; i++) {\n        sums1 += arr[i];\n        sums2 += sorted[i];\n\n        if (sums1 === sums2) {\n            ans++;\n            sums1 = sums2 = 0; // è¿™è¡Œä¸è¦ä¹Ÿå¯ä»¥å•¦\n        }\n   }\n   return ans;\n};\n```\n## å¤æ‚åº¦\n+ æ—¶é—´å¤æ‚åº¦: O(NlogN)\n+ ç©ºé—´å¤æ‚åº¦: O(n)\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193096357","body":"## æ€è·¯\nä½¿ç”¨å¿«æ…¢æŒ‡é’ˆæ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼Œé€’å½’é“¾è¡¨ç”ŸæˆäºŒå‰æœç´¢æ ‘\n\n## ä»£ç \n```\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    return buildTree(head, null);\n};\n\nfunction buildTree(left, right) {\n    if(left === right) return null;\n    var mid = getMidNode(left, right);\n    var root = new TreeNode(mid.val);\n    root.left = buildTree(left, mid);\n    root.right = buildTree(mid.next, right);\n    return root;\n}\n\nfunction getMidNode(left, right) {\n    let fast = left;\n    let slow = left;\n    while (fast !== right && fast.next !== right) {\n        fast = fast.next;\n        fast = fast.next;\n        slow = slow.next;\n    }\n    return slow;\n}\n```\n\n## å¤æ‚åº¦\n+ ç©ºé—´å¤æ‚åº¦ï¼š O(logn)\n+ æ—¶é—´å¤æ‚åº¦ï¼š O(nlogn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193409633","body":"## æ€è·¯\r\n åŒæŒ‡é’ˆéå†ä¸¤æ¡é“¾è¡¨ï¼Œå½“ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘åŒä¸€èŠ‚ç‚¹æ—¶è¿”å›è¯¥èŠ‚ç‚¹ï¼›\r\n\r\n ## ä»£ç \r\n ```\r\n /**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function(headA, headB) {\r\n        if(headA === null || headB === null) {\r\n            return null;\r\n        }\r\n        let ptA = headA;\r\n        let ptB = headB;\r\n        while(ptA != ptB) {\r\n            ptA = ptA === null ?  headB : ptA.next;\r\n            ptB = ptB === null ?  headA : ptB.next;\r\n        }\r\n        return ptA\r\n};\r\n ```\r\n\r\n ## å¤æ‚åº¦\r\n + æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n + ç©ºé—´å¤æ‚åº¦: O(1)","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196096086","body":"## æ€è·¯\næ·±åº¦ä¼˜å…ˆéå†\n## ä»£ç \n```\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    if(root === null) return 0;\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n};\n```\n## å¤æ‚åº¦\n+ æ—¶é—´å¤æ‚åº¦ O(n)\n+ ç©ºé—´å¤æ‚åº¦ O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197695772","body":"## æ€è·¯\nå‰åºéå†ï¼Œåˆ¤æ–­æ ‘èŠ‚ç‚¹æ˜¯å¦ç›¸åŒ\n## ä»£ç \n```\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n    if(p == null && q === null) {\n        return true;\n    } else if(p == null || q == null) {\n        return false;\n    } else if(p.val !== q.val) {\n        return false;\n    }\n\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n};\n```\n## å¤æ‚åº¦\n+ æ—¶é—´å¤æ‚åº¦: O(N)\n+ ç©ºé—´å¤æ‚åº¦: O(h)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200125124","body":"## æ€è·¯\r\nå¹¿åº¦ä¼˜å…ˆéå†ï¼Œä»å³å­æ ‘å‘å·¦å­æ ‘éå†\r\n## ä»£ç \r\n```\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar findBottomLeftValue = function(root) {\r\n    if(!root) return null;\r\n    const queue = [];\r\n    queue.push(root);\r\n    let anser = 0;\r\n    //\r\n    while(queue.length) {\r\n        const node  = queue.shift();\r\n        if (node.right) {\r\n            queue.push(node.right);\r\n        }\r\n        if (node.left) {\r\n            queue.push(node.left);\r\n        }\r\n        anser = node.val;\r\n    }\r\n    return anser;\r\n};\r\n```\r\n## å¤æ‚åº¦\r\n+ æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n+ ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200382273","body":"## æ€è·¯\nBFSéå†è¿›è¡Œåºåˆ—åŒ–ï¼Œååºåˆ—åŒ–è½¬æ¢ï¼Œç”¨nullå­—ç¬¦ä¸²ä»£æ›¿ç©ºèŠ‚ç‚¹\n## ä»£ç \n```\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n    const result = [];\n    const queue = [root];\n    while(queue.length) {\n        const node = queue.shift();\n        if(node) {\n            result.push(node.val);\n            queue.push(node.left);\n            queue.push(node.right);\n        } else {\n            result.push('null');\n        }\n    }\n    return result.join(',');\n};\n\n\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n    if(!data) return null;\n    if(data === 'null') return null;\n    const treeList = data.split(',');\n    const root = new TreeNode(treeList[0]);\n    const queue = [root];\n    let index = 1;\n    while(index < treeList.length) {\n        const node = queue.shift();\n        let leftVal = treeList[index];\n        let rightVal = treeList[index + 1];\n        if(leftVal !== 'null') {\n            const leftNode = new TreeNode(leftVal);\n            node.left = leftNode;\n            queue.push(leftNode);\n        };\n        if(rightVal !== 'null') {\n            const rightNode = new TreeNode(rightVal);\n            node.right = rightNode;\n            queue.push(rightNode);\n        }\n        index += 2;\n    }\n    return root;\n};\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n```\n## å¤æ‚åº¦\n+ æ—¶é—´å¤æ‚åº¦O(n)\n+ ç©ºé—´å¤æ‚åº¦O(n)\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205846126","body":"## æ€è·¯\nmapè®°å½•å­—ç¬¦ä¸²å‡ºç°çš„ä½ç½®ï¼Œæ»‘åŠ¨çª—å£æ¥è¡¨ç¤ºæ— é‡å¤å­å­—ç¬¦ä¸²ï¼Œè¿”å›è¿‡ç¨‹ä¸­æœ€å¤§è®°å½•\n## ä»£ç \n```\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    if(!s) return 0;\n    const charMap = {};\n    let maxLen = 0, l =0, r = 0;\n    while(r < s.length) {\n        if(charMap[s[r]] !== null) {\n            const pos = charMap[s[r]];\n            if(l <= pos && pos <= r) l = pos + 1;\n        }\n        maxLen = Math.max(maxLen, r - l + 1);\n        charMap[s[r]] = r;\n        r++;\n    }\n    return maxLen;\n};\n```\n## å¤æ‚åº¦\n+ æ—¶é—´å¤æ‚åº¦O(n)\n+ ç©ºé—´å¤æ‚åº¦O(s), sä¸ºå­—ç¬¦é›†ä¸ªæ•°","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"2learnsomething":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185216971","body":"## æ€è·¯\nçœ‹æˆæ˜¯ä¸¤ä¸ªæ•°ç»„çš„æ±‚å’Œï¼Œç„¶åéå†æ•°ç»„ï¼Œæ•°å­—ä¸æ–­åšæ±‚ä½™å’Œæ±‚é™¤æ“ä½œ,è¿›è¡Œç±»ä¼¼äºæŒ‰ä½æ±‚å’Œæ“ä½œï¼Œæ³¨æ„è¿›ä½é—®é¢˜å³å¯ï¼Œæœ€åè¿”å›ç»“æœçš„é€†åºã€‚\n\n## ä»£ç \n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        ans = []\n        temp = 0\n        while num or k or temp:\n            sum_k = k % 10\n            if num:\n                n = num.pop()\n            else: n = 0\n            ans.append((n+sum_k+temp)%10)\n            k //=  10\n            temp = (n+sum_k+temp)//10\n        return ans[::-1]\n```\n## å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦ï¼šO(n) \n\nç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186104169","body":"## æ€è·¯\nå¾ˆå‚»å¾ˆç›´ç™½çš„åŠæ³•ï¼Œå…ˆéå†ä¸€æ¬¡ç”¨æ•°ç»„è®°å½•ä¸‹ç›®æ ‡cçš„ä½ç½®ï¼Œç„¶åå†éå†ä¸€æ¬¡è®¡ç®—è·ç¦»cçš„ä¸‹æ ‡çš„æœ€å°å€¼ã€‚å±äºæ˜¯æš´åŠ›æ±‚è§£ï¼Œå½“è§„æ¨¡æ›´å¤§çš„æ—¶å€™å¯èƒ½ä¼šè¶…æ—¶ï¼Œä¹‹åè¿˜éœ€è¦æ”¹è¿›\n## ä»£ç \n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res = []\n        ans = []\n        for i in range(len(s)):\n            if s[i] == c:\n                ans.append(i) \n        for j in range(len(s)):\n            if s[j] == c:\n                res.append(0)\n            else:\n                min_ = min(list(map(lambda x:abs(x-j),ans)))\n                res.append(min_)\n        return res\n```\n## å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦ï¼šO(n)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186416069","body":"## æ€è·¯\nåˆ©ç”¨pythonè‡ªå¸¦çš„åˆ—è¡¨è¿›è¡Œæ ˆçš„æ¨¡æ‹Ÿï¼Œå¯¹äºç¬¬ä¸‰ä¸ªé—®é¢˜ï¼Œåˆ™é‡‡å–ç›´ç™½çš„åˆ¤æ–­å’Œéå†çš„æ–¹æ³•ã€‚\n## ä»£ç \n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxsize = maxSize\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxsize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack) <= k:\n            self.stack = list(map(lambda x:x+val,self.stack))\n        else:\n            for i in range(k):\n                self.stack[i] +=val\n```\n## å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦: O(N)\n\nç©ºé—´å¤æ‚åº¦: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186828526","body":"## æ€è·¯\næ ˆçš„ä½¿ç”¨ï¼Œä¸åˆ¤æ–­æ‹¬å·åŒ¹é…ç›¸ä¼¼\n## ä»£ç \n```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack, res, multi = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append([multi, res])\n                res, multi = \"\", 0\n            elif c == ']':\n                cur, last = stack.pop()\n                res = last + cur * res\n            elif '0' <= c <= '9':\n                multi = multi * 10 + int(c)            \n            else:\n                res += c\n        return res\n```\n## å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦:O(N)\n\nç©ºé—´å¤æ‚åº¦:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188650642","body":"## æ€è·¯\nç”¨ä¸¤ä¸ªæ ˆè¿›è¡Œæ¨¡æ‹Ÿ\n## ä»£ç \n```\nclass MyQueue:\n\n    def __init__(self):\n        self.stracks = []\n        self.stracks_tmp = []\n\n    def push(self, x: int) -> None:\n        if self.stracks:\n            while self.stracks:\n                self.stracks_tmp.append(self.stracks.pop())\n            self.stracks.append(x)\n            while self.stracks_tmp:\n                self.stracks.append(self.stracks_tmp.pop())\n        else:\n            self.stracks.append(x)\n\n    def pop(self) -> int:\n        return self.stracks.pop()\n\n    def peek(self) -> int:\n        return self.stracks[-1]\n\n    def empty(self) -> bool:\n        if not self.stracks:\n            return True\n        else:\n            return False\n```\n## å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦:O(N)\n\nç©ºé—´å¤æ‚åº¦:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189832298","body":"## æ€è·¯\næ„é€ å•è°ƒæ ˆï¼Œæœ€ååˆ†çš„å—çš„æ•°ç›®ä¸ºæ ˆä¸­å…ƒç´ çš„æ•°ç›®\n## ä»£ç \n```\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        max_, stack = arr[0], [arr[0]]\n        for i in range(1, len(arr)):\n            if arr[i] >= max_:\n                max_ = arr[i]\n                stack.append(arr[i])\n            else:\n                while stack and stack[-1] > arr[i]:\n                    stack.pop()\n                stack.append(max_)\n        return len(stack)\n```\n## å¤æ‚åº¦åˆ†æ\nåªéœ€è¦éå†ä¸€æ¬¡æ•°ç»„\næ—¶é—´å¤æ‚åº¦: O(N)\n\nç©ºé—´å¤æ‚åº¦:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191081611","body":"## æ€è·¯\nå…ˆæ±‚å‡ºé“¾è¡¨é•¿åº¦ï¼Œç„¶åå¯¹kå–æ¨¡å¾—åˆ°å®é™…ç§»åŠ¨çš„æ­¥æ•°ï¼Œæœ€åå°±æ˜¯é“¾è¡¨çš„æ‹¼æ¥\n## ä»£ç \n```\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if k == 0: return head\n        else:\n            if head:\n                lenth = 0\n                cur,slow,fast = head,head,head\n                while cur:\n                    cur = cur.next\n                    lenth += 1\n                k %= lenth\n                while k:\n                    fast = fast.next\n                    k -= 1\n                if fast != head:\n                    while fast.next:\n                        fast = fast.next\n                        slow = slow.next\n                    new_head = slow.next\n                    fast.next = head\n                    slow.next = None\n                    return new_head\n                else:\n                    return head\n            else:\n                return head\n```\n## å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192128954","body":"## æ€è·¯\né‡ç‚¹å°±æ˜¯åŒæŒ‡é’ˆç¡®å®šäº¤æ¢çš„èŠ‚ç‚¹å¹¶è¿›è¡Œæ¨¡æ‹Ÿå®ç°é“¾è¡¨ç¿»è½¬ï¼Œåªä¸è¿‡é™äºç›¸é‚»ä¸¤ä¸ªèŠ‚ç‚¹é—´çš„ç¿»è½¬ã€‚\n## ä»£ç \n```\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if head:\n            slow,fast = head,head.next\n            if fast:\n                pre = p = ListNode()\n                pre.next = head\n                while slow and fast:\n                    next_ = fast.next\n                    p.next = fast\n                    fast.next = slow\n                    slow.next = next_\n                    p = slow\n                    slow = slow.next\n                    fast = slow.next if slow else None\n                return pre.next\n            else:\n                return slow\n\n        else:\n            return head\n```\n## å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193040731","body":"## æ€è·¯\nåŒæŒ‡é’ˆæ‰¾ä¸­ç‚¹ï¼Œé€’å½’è¿›è¡Œå·¦å³å­æ ‘çš„æ„é€ \n## ä»£ç \n```\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n```\n## å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦ï¼šO(NlogN)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(logN)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193221013","body":"## æ€è·¯\nä¸€ä¸ªå”¯ç¾çš„å°æ•…äº‹ï¼Œå¦‚æœä½ æƒ³æ‰¾åˆ°ä½ å‘½ä¸­æ³¨å®šçš„npyï¼Œé‚£å°±å»é‡èµ°ä½ ä»¥åŠtaèµ°è¿‡çš„è·¯ï¼Œå¦‚æœæœ‰ç¼˜ç»ˆä¼šç›¸é‡\n## ä»£ç \n```class Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        if not headA or not headB:\n            return None\n        else:\n            A,B = headA,headB\n            while A != B:\n                A = A.next if A else headB\n                B = B.next if B else headA\n            return A\n```\n## å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦ï¼šO(M+N)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193494260","body":"## æ€è·¯\nå¿«æ…¢æŒ‡é’ˆï¼Œæ³¨æ„æ˜¯å¦å‡ºç°ç¯å½¢çš„æ¡ä»¶å°±è¡Œ\n## ä»£ç \n```\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        fast, slow = head, head\n        while True:\n            if not (fast and fast.next): return\n            fast, slow = fast.next.next, slow.next\n            if fast == slow: break\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast\n```\n## å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194927199","body":"## ä»£ç \n```\nclass ListNode:\n    def __init__(self, key=None, value=None):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.hashmap = {}\n        self.head = ListNode()\n        self.tail = ListNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def move_node_to_tail(self, key):\n            node = self.hashmap[key]\n            node.prev.next = node.next\n            node.next.prev = node.prev\n            node.prev = self.tail.prev\n            node.next = self.tail\n            self.tail.prev.next = node\n            self.tail.prev = node\n\n    def get(self, key: int) -> int:\n        if key in self.hashmap:\n            self.move_node_to_tail(key)\n        res = self.hashmap.get(key, -1)\n        if res == -1:\n            return res\n        else:\n            return res.value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.hashmap:\n            self.hashmap[key].value = value\n            self.move_node_to_tail(key)\n        else:\n            if len(self.hashmap) == self.capacity:\n                self.hashmap.pop(self.head.next.key)\n                self.head.next = self.head.next.next\n                self.head.next.prev = self.head\n            new = ListNode(key, value)\n            self.hashmap[key] = new\n            new.prev = self.tail.prev\n            new.next = self.tail\n            self.tail.prev.next = new\n            self.tail.prev = new\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196191004","body":"## æ€è·¯\nä½¿ç”¨é˜Ÿåˆ—è®¡ç®—å±‚æ•°\n## ä»£ç \n```\nClass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        depth=0\n        if not root:\n            return 0\n        queue=[root]\n        while queue: # queueæ¯æ¬¡åªå­˜æ”¾ä¸€å±‚çš„èŠ‚ç‚¹\n            n=len(queue)\n            for i in range(n):\n                p=queue.pop(0)\n                if p.left:\n                    queue.append(p.left)\n                if p.right:\n                    queue.append(p.right)\n            depth+=1\n        return depth\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197586431","body":"## æ€è·¯\né€’å½’åˆ¤æ–­æ¯ä¸€å±‚èŠ‚ç‚¹\n## ä»£ç \n```\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\n```\n## å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198819496","body":"## æ€è·¯\ndfs\n## ä»£ç \n```\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        def dfs(root: TreeNode, prevTotal: int) -> int:\n            if not root:\n                return 0\n            total = prevTotal * 10 + root.val\n            if not root.left and not root.right:\n                return total\n            else:\n                return dfs(root.left, total) + dfs(root.right, total)\n\n        return dfs(root, 0)\n\n```\n## å¤æ‚åº¦ï¼š\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(H)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200114436","body":"## æ€è·¯\ndfs\n## ä»£ç \n```\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        ans = 0\n        q = collections.deque([root])\n        while q:\n            for i in range(len(q)):\n                node = q.popleft()\n                if i == 0:\n                    ans = node.val\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        return ans\n```\n## å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦:O(N)\nç©ºé—´å¤æ‚åº¦:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200375426","body":"## æ€è·¯\nbfs\n## ä»£ç \n```\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root:\n            return \"\"\n        queue = collections.deque([root])\n        res = []\n        while queue:\n            node = queue.popleft()\n            if node:\n                res.append(str(node.val))\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                res.append('None')\n        return '[' + ','.join(res) + ']'\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        if not data:\n            return []\n        dataList = data[1:-1].split(',')\n        root = TreeNode(int(dataList[0]))\n        queue = collections.deque([root])\n        i = 1\n        while queue:\n            node = queue.popleft()\n            if dataList[i] != 'None':\n                node.left = TreeNode(int(dataList[i]))\n                queue.append(node.left)\n            i += 1\n            if dataList[i] != 'None':\n                node.right = TreeNode(int(dataList[i]))\n                queue.append(node.right)\n            i += 1\n        return root\n```\n## å¤æ‚åº¦ï¼š\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200841091","body":"## æ€è·¯\nbfs,åˆæœ‰ç‚¹åƒæ¨¡æ‹Ÿ\n## ä»£ç \n```\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        order = []\n        deque = collections.deque([(root,0,0)])\n        col_list = list()\n        while deque:\n            for _ in range(len(deque)):\n                node,row,col = deque.popleft()\n                if col not in col_list: col_list.append(col)\n                order.append((col,row,node.val))\n                if node.left:\n                    deque.append((node.left,row+1,col-1))\n                if node.right:\n                    deque.append((node.right,row+1,col+1))\n        ans = []\n        col_list.sort()\n        order.sort()\n        for c in col_list:\n            temp = []\n            while order and order[0][0] == c:\n                temp.append(heapq.heappop(order)[2])\n            ans.append(temp)\n        return ans\n```\n## å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦:O(N)\nç©ºé—´å¤æ‚åº¦:O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202100224","body":"## æ€è·¯\nå“ˆå¸Œè¡¨\n## ä»£ç \n```\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        new_dict = {}\n        for index,elem in enumerate(nums):\n            if target-elem in new_dict:\n                return [new_dict[target-elem],index]\n            else:\n                new_dict[elem] = index\n```\n## å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦:O(N)\nç©ºé—´å¤æ‚åº¦:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203555813","body":"## æ€è·¯\nå †æ’åº\n## ä»£ç \n```\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        hash_ = Counter(nums)\n        que = [(value,key) for key,value in hash_.items()]\n        import heapq\n        heapq.heapify(que)\n        while len(que) > k:\n            heapq.heappop(que)\n        ans = []\n        while que:\n            ans.append(heapq.heappop(que)[1])\n        return ans\n```\n## å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦ï¼šO(NlogN)\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205159506","body":"```\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ans = 0\n        for p in points:\n            cnt = defaultdict(int)\n            for q in points:\n                dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1])\n                cnt[dis] += 1\n            for m in cnt.values():\n                ans += m * (m - 1)\n        return ans\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ataraxyadong":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185228684","body":"### æ€è·¯\n\nä»ä½ä½åˆ°é«˜ä½ä¾æ¬¡æ‹¿å‡º`num`çš„å€¼å’Œ`k`ç›¸åŠ ï¼Œå°†æ‰€åŠ ä¹‹å’Œä¸10çš„ä½™æ•°åŠ å…¥åˆ°`list`ä¸­ï¼Œç›´åˆ°`k=0`ã€‚æœ€åå°†æ‰€å¾—çš„`list`åè½¬åå³å¯å¾—åˆ°ã€‚\n\n### ä»£ç \n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int length = num.length;\n        int idxVal;\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < length; i++) {\n            idxVal = num[length - 1 - i];\n            if (k != 0) {\n                list.add((idxVal + k) % 10);\n                k = (idxVal + k) / 10;\n            } else {\n                list.add(idxVal);\n            }\n            if (k != 0 && (length - 1 - i) <= 0) {\n                while (k != 0) {\n                    list.add(k % 10);\n                    k = k / 10;\n                }\n            }\n        }\n        Collections.reverse(list);\n        return list;\n    }\n}\n```\n\n### å¤æ‚åº¦åˆ†æ\n\n\\- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ `N = array.length`æˆ–è€…æ˜¯`N = array.length + kçš„ä½æ•°`ã€‚ï¼ˆä¸ç¡®å®šï¼‰\n\\- ç©ºé—´å¤æ‚åº¦ï¼šO(1)ï¼Œï¼ˆä¸ç¡®å®šï¼‰\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186173029","body":"### æ€è·¯\n\næ ¹æ®é¢˜ç›®çš„æç¤º**â€œæ•°ç»„çš„éå†(æ­£å‘éå†å’Œåå‘éå†)â€**ï¼Œåˆ†ä¸¤æ¬¡éå†æ•°ç»„ï¼š\n\n1. ç¬¬ä¸€æ¬¡ï¼Œæ­£å‘éå†ï¼Œå‡ºç°åœ¨ç¬¬ä¸€ä¸ªcå‰çš„ä½ç½®éƒ½ç»™`Integer.MAX_VALUE`ï¼Œå‡ºç°cçš„ä½ç½®èµ‹å€¼ä¸º0ï¼Œå…¶ä½™çš„ä½ç½®çš„å…ˆè®¡ç®—å‡ºâ€œæ­¤ä½ç½®åˆ°å®ƒ**å·¦è¾¹æœ€è¿‘çš„c**çš„è·ç¦»â€\n2. ç¬¬äºŒæ¬¡ï¼Œåå‘éå†ï¼Œæ€è·¯å¤§è‡´å¦‚ä¸Šï¼Œä¸åŒå¤„åœ¨äºè®¡ç®—å‡ºâ€œæ­¤ä½ç½®åˆ°å®ƒ**å³è¾¹æœ€è¿‘çš„c**çš„è·ç¦»â€ï¼Œå’Œâ€œæ­¤ä½ç½®åˆ°å®ƒ**å·¦è¾¹æœ€è¿‘çš„c**çš„è·ç¦»â€ç›¸æ¯”ï¼Œå–å°å€¼å³å¯\n\n### ä»£ç \n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int length = s.length();\n        int[] result = new int[length];\n        int currentIndex = Integer.MAX_VALUE;\n        for (int i = 0; i < length; i++) {\n            if (s.charAt(i) == c) {\n                result[i] = 0;\n                currentIndex = i;\n            } else {\n                result[i] = Math.abs(i - currentIndex);\n            }\n        }\n        for (int i = length - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                currentIndex = i;\n            } else {\n                result[i] = Math.min(Math.abs(i - currentIndex), result[i]);\n            }\n        }\n        return result;\n    }\n}\n```\n\n\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºå­—ç¬¦ä¸²çš„é•¿åº¦ã€‚\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)ï¼ˆä¸ç¡®å®šï¼‰","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186518458","body":"### æ€è·¯\n\næ ¹æ®æ ˆçš„ç»“æ„ï¼Œå®šä¹‰å‡ºä¸‰ä¸ªå˜é‡ï¼š\n\n1. `int[] stack`ç”¨æ¥å­˜æ”¾å€¼\n2. `int head`æŒ‡å®šå½“å‰æ ˆé¡¶ï¼Œå½“å€¼ä¸º-1æ—¶è¡¨æ˜æ­¤æ ˆä¸ºç©º\n3. `int maxSize`æ¥æ”¶æŒ‡å®šçš„æ ˆçš„å¤§å°\n\n- push\n\n  åˆ¤æ–­`head`æ˜¯å¦åˆ°äº†æ ˆçš„æœ€å¤§ä½ç½®å¤„ï¼Œæ²¡æœ‰åˆ™æ·»åŠ \n\n- pop\n\n  åˆ¤æ–­`head`æ˜¯å¦æ˜¯ç©ºæ ˆ\n\n### ä»£ç \n\n```java\nclass CustomStack {\n\n    int[] stack;\n    int head = -1;\n    int maxSize = 0;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        this.stack = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (head >= maxSize - 1) {\n            return;\n        }\n        this.stack[++head] = x;\n    }\n\n    public int pop() {\n        if (head == -1) {\n            return -1;\n        }\n        return this.stack[head--];\n    }\n\n    public void increment(int k, int val) {\n        if (head + 1 < k) {\n            for (int i = 0; i < head + 1; i++) {\n                stack[i] += val;\n            }\n            return;\n        }\n        for (int i = 0; i < k; i++) {\n            stack[i] += val;\n        }\n    }\n}\n```\n\n\n\n\n### å¤æ‚åº¦åˆ†æ\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºæŒ‡å®šæ ˆçš„é•¿åº¦ã€‚\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187666868","body":"### ä»£ç \n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        StringBuffer result = new StringBuffer();\n        Stack<Integer> numberStack = new Stack<>();\n        Stack<StringBuffer> stringBufferStack = new Stack<>();\n        int count = 0;\n        for (char ch : s.toCharArray()) {\n            if (Character.isDigit(ch)) {\n                count = count * 10 + ch - '0';\n            } else if (ch == '[') {\n                numberStack.push(count);\n                count = 0;\n                stringBufferStack.push(result);\n                result = new StringBuffer();\n            } else if (Character.isAlphabetic(ch)) {\n                result.append(ch);\n            } else {\n                StringBuffer temp_str = stringBufferStack.pop();\n                int temp_num = numberStack.pop();\n                for (int i = 0; i < temp_num; i++) {\n                    temp_str.append(result);\n                }\n                result = temp_str;\n            }\n        }\n        return result.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189084434","body":"### æ€è·¯\n\nï¼ˆé€šè¿‡é¢˜è§£å­¦ä¹ ï¼‰\n\n- æ€è·¯1\n\n  ä½¿ç”¨ä¸¤ä¸ªæ ˆæ¥å®ç°é˜Ÿåˆ—ï¼Œä¸€ä¸ªæ ˆç”¨æ¥å­˜æ”¾åŸæœ¬çš„é¡ºåºï¼Œå¦ä¸€ä¸ªæ ˆç”¨æ¥ä½œä¸ºä¸´æ—¶å­˜æ”¾åè½¬é¡ºåºä½¿ç”¨ã€‚\n\n  `storeStack`å’Œ`reverseStack`\n\n  - push\n\n    å…¥é˜Ÿçš„æ—¶å€™éœ€è¦å…ˆæŠŠ`storeStack`æ¸…ç©ºï¼ˆæŠŠæ•°æ®`pop`ï¼Œç„¶å`push`åˆ°`reverseStack`ï¼Œç›´åˆ°`storeStack.empty() == true`ï¼‰ï¼Œç„¶åæ•°æ®è¿›`storeStack`ï¼Œå†æŠŠ`reverseStack`çš„æ•°æ®`pop`ï¼Œç„¶å`push`åˆ°`storeStack`\n\n  - pop\n\n    `storeStack`çš„`head`å°±æ˜¯é˜Ÿåˆ—çš„`head`ï¼Œå‡ºé˜Ÿæ—¶ç›´æ¥ä½¿ç”¨`storeStack.pop()`å³å¯ï¼ˆ`storeStack`ä¸ä¸ºç©ºï¼‰\n\n- æ€è·¯2\n\n  ä½¿ç”¨ä¸¤ä¸ªæ ˆæ¥å®ç°é˜Ÿåˆ—ï¼Œä¸€ä¸ªæ ˆç”¨æ¥å­˜æ”¾`push`è¿›æ¥çš„æ•°æ®ï¼Œå¦ä¸€ä¸ªæ ˆç”¨æ¥å­˜æ”¾éœ€è¦`pop`çš„æ•°æ®\n\n  `pushStack`å’Œ`popStack`\n\n  - push\n\n    å…¥é˜Ÿæ—¶ç›´æ¥`push`åˆ°`pushStack`ï¼Œå¦‚æœæ­¤æ—¶çš„`pushStack`ä¸ºç©ºï¼Œéœ€è¦å°†ç¬¬ä¸€ä¸ªå€¼æŒ‡å®šä¸º`head`ï¼Œæ–¹ä¾¿`peek`\n\n  - pop\n\n    å‡ºé˜Ÿæ—¶ï¼Œéœ€è¦ä¿è¯`popStack`ä¸ä¸ºç©ºï¼Œå¦‚æœæ˜¯ç©ºï¼Œå°±æŠŠ`pushStack`å…¨éƒ¨æ·»åŠ åˆ°`popStack`ï¼Œç„¶åå†ä»`popStack`å‡ºé˜Ÿ\n\n  - peek\n\n    å¦‚æœ`popStack`ä¸ºç©ºï¼Œé‚£ä¹ˆheadå°±æ˜¯é˜Ÿé¦–ï¼Œå¦‚æœä¸ä¸ºç©ºï¼Œé˜Ÿé¦–å°±æ˜¯`popStack`çš„æ ˆé¡¶\n\n### ä»£ç \n\n#### æ€è·¯1\n\n```java\nclass MyQueue {\n\n    private Stack<Integer> storeStack;\n    private Stack<Integer> reverseStack;\n\n    public MyQueue() {\n        this.storeStack = new Stack<>();\n        this.reverseStack = new Stack<>();\n    }\n\n    public void push(int x) {\n        while (!storeStack.empty()) {\n            reverseStack.push(storeStack.pop());\n        }\n        storeStack.push(x);\n        while (!reverseStack.empty()) {\n            storeStack.push(reverseStack.pop());\n        }\n    }\n\n    public int pop() {\n        if (storeStack.empty()) {\n            return Integer.MIN_VALUE;\n        }\n        return storeStack.pop();\n    }\n\n    public int peek() {\n        if (storeStack.empty()) {\n            return Integer.MIN_VALUE;\n        }\n        return storeStack.peek();\n    }\n\n    public boolean empty() {\n        return storeStack.empty();\n    }\n}\n```\n\n#### æ€è·¯2\n\n```java\nclass MyQueue {\n\n    private Stack<Integer> pushStack;\n    private Stack<Integer> popStack;\n    // é˜Ÿåˆ—çš„head\n    private int head;\n\n    public MyQueue() {\n        this.pushStack = new Stack<>();\n        this.popStack = new Stack<>();\n    }\n\n    public void push(int x) {\n        if (pushStack.empty()) {\n            head = x;\n        }\n        pushStack.push(x);\n    }\n\n    public int pop() {\n        if (popStack.empty()) {\n            while (!pushStack.empty()) {\n                popStack.push(pushStack.pop());\n            }\n        }\n        return popStack.pop();\n    }\n\n    public int peek() {\n        if (popStack.empty()) {\n            return head;\n        }\n        return popStack.peek();\n    }\n\n    public boolean empty() {\n        return pushStack.empty() && popStack.empty();\n    }\n}\n```\n\n\n\n### å¤æ‚åº¦åˆ†æ\n\n- æ—¶é—´å¤æ‚åº¦ï¼š\n  1. æ€è·¯1\n     - å…¥é˜Ÿï¼šO(N)\n     - å‡ºé˜Ÿï¼šO(1)\n  2. æ€è·¯2\n     - å…¥é˜Ÿï¼šO(1)\n     - å‡ºé˜Ÿï¼šO(1)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)\n  1. æ€è·¯1\n     - å…¥é˜Ÿï¼šO(N)\n     - å‡ºé˜Ÿï¼šO(1)\n  2. æ€è·¯2\n     - å…¥é˜Ÿï¼šO(1)\n     - å‡ºé˜Ÿï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190371208","body":"### æ€è·¯\n\nï¼ˆé€šè¿‡é¢˜è§£å­¦ä¹ ï¼‰\n\nä½¿ç”¨æ ˆæ¥è®°å½•æ¯ä¸ªå—çš„æœ€å¤§å€¼ï¼Œåœ¨æ ˆä¸­çš„å€¼åº”è¯¥æ˜¯é€’å¢çš„ï¼ˆå­˜åœ¨ç›¸ç­‰çš„æƒ…å†µï¼‰ï¼Œæœ€åè®¡ç®—æ ˆçš„é•¿åº¦å³å¯å¾—çŸ¥å—çš„ä¸ªæ•°ã€‚\n\néå†æ•°ç»„ï¼Œå½“**æ ˆä¸ºç©º**æˆ–è€…æ˜¯**å½“å‰å€¼å¤§ç­‰äºæ ˆé¡¶å€¼**ï¼Œå°†å½“å‰å€¼å…¥æ ˆï¼Œè®¤ä¸ºæ˜¯ä¸€ä¸ªå—ï¼›å½“æ ˆä¸ä¸ºç©ºï¼Œå‡ºç°äº†**å½“å‰å€¼å°äºæ ˆé¡¶å€¼**ï¼ˆå°±æ˜¯å½“å‰å€¼éœ€è¦å¹¶å…¥ä¸Šä¸€ä¸ªå—ï¼‰ï¼Œå…ˆæŠŠè®°å½•å½“å‰å—çš„æœ€å¤§å€¼æš‚å­˜ï¼Œéœ€è¦å°†æ ˆé¡¶å€¼æŠ›å‡ºï¼Œä¸€ç›´åˆ°**å½“å‰å€¼å¤§ç­‰äºæ ˆé¡¶å€¼**æˆ–è€…æ ˆä¸ºç©ºåï¼Œå†å°†ä¸´æ—¶ä¿å­˜çš„å½“å‰å—æœ€å¤§å€¼å…¥æ ˆã€‚\n\nä¸»è¦çš„æ€è·¯æ˜¯ï¼šéå†åˆ°çš„numå¿…é¡»æ˜¯**å¤§ç­‰äº**æ ˆé¡¶å€¼æ‰å¯ä»¥ç§°ä¸ºä¸€ä¸ªæ–°çš„å—ï¼Œå¦åˆ™å°±éœ€è¦å¹¶å…¥å‰ä¸€ä¸ªå—\n\n### ä»£ç \n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> blockMaxHeadStack = new Stack<>();\n\n        for (int num : arr) {\n\n            if (blockMaxHeadStack.empty() || num >= blockMaxHeadStack.peek()) {\n                blockMaxHeadStack.push(num);\n            }\n\n            if (!blockMaxHeadStack.empty() && num < blockMaxHeadStack.peek()) {\n                // è·å–è®°å½•å½“å‰å—çš„æœ€å¤§å€¼\n                int head = blockMaxHeadStack.pop();\n                while (!blockMaxHeadStack.empty() && num < blockMaxHeadStack.peek()) {\n                    blockMaxHeadStack.pop();\n                }\n                blockMaxHeadStack.push(head);\n            }\n        }\n        return blockMaxHeadStack.size();\n    }\n}\n```\n\n\n\n### å¤æ‚åº¦åˆ†æ\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191200440","body":"### æ€è·¯\n\nï¼ˆé€šè¿‡é¢˜è§£å­¦ä¹ ï¼‰\n\næ ¹æ®é¢˜ç›®çš„è¦æ±‚ï¼Œå°±æ˜¯å°†é“¾è¡¨ï¼ˆå•å‘é“¾è¡¨ï¼‰çš„å…ƒç´ å‘åç§»åŠ¨kä¸ªå•ä½ã€‚\n\né¦–å…ˆï¼Œéå†é“¾è¡¨ï¼Œå¾—åˆ°å½“å‰é“¾è¡¨çš„å¤´å°¾ï¼Œå°†å…¶å¤´å°¾ç›¸æ¥ï¼Œå½¢æˆä¸€ä¸ªç¯å½¢é“¾è¡¨ï¼›\n\nç„¶åï¼Œè®¡ç®—`head`ç§»åŠ¨çš„æœ€çŸ­è·¯å¾„ï¼ˆä¹Ÿå°±æ˜¯headå…ƒç´ çš„æ–°ä½ç½®ï¼‰ï¼Œå¹¶æ‰¾åˆ°è¿™ä¸ª`head`\n\næœ€åï¼Œä»`head`èŠ‚ç‚¹å‰æŠŠé“¾è¡¨æ–­å¼€ï¼Œå°±æ˜¯`head`çš„å‰ä¸€ä¸ªå…ƒç´ çš„`next`æŒ‡ä¸º`null`\n\n### ä»£ç \n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n\n        if (head == null || k == 0 || head.next == null) {\n            return head;\n        }\n\n        ListNode iterator = head;\n        ListNode tail;\n        int size = 1;\n\n        while (iterator.next != null) {\n            iterator = iterator.next;\n            size++;\n        }\n        // æŠ“åˆ°é“¾è¡¨çš„å°¾éƒ¨ æ„æˆç¯å½¢é“¾è¡¨\n        tail = iterator;\n        tail.next = head;\n\n        // ä»è¾“å…¥åˆ°è¾“å‡ºï¼Œè®¡ç®—å‡ºå…ƒç´ æœ€çŸ­ç§»åŠ¨è·¯å¾„\n        int offset = size - k % size;\n        if (offset == 0) {\n            return head;\n        }\n        iterator = head;\n        for (int i = 0; i < offset; i++) {\n            iterator = iterator.next;\n        }\n        head = iterator;\n\n        while (iterator.next != head) {\n            iterator = iterator.next;\n            if (iterator.next == head) {\n                iterator.next = null;\n                return head;\n            }\n        }\n        return null;\n    }\n}\n```\n\n\n\n### å¤æ‚åº¦åˆ†æ\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192625907","body":"### æ€è·¯\n\né“¾è¡¨çš„èŠ‚ç‚¹ï¼Œä¸¤ä¸¤äº’æ¢ä½ç½®ï¼Œè‹¥æ˜¯é‡åˆ°é•¿åº¦ä¸ºå¥‡æ•°çš„åˆ—è¡¨ï¼Œæœ€åä¸€ä¸ªèŠ‚ç‚¹ä¸åŠ¨ã€‚å®šä¹‰äº†å››ä¸ªå˜é‡ï¼Œåˆ†åˆ«è¡¨ç¤ºï¼šä¸Šä¸€ä¸ªèŠ‚ç‚¹ï¼Œå½“å‰èŠ‚ç‚¹ã€ä¸‹ä¸€ä¸ªèŠ‚ç‚¹å’Œä¸´æ—¶å­˜å‚¨çš„å€¼ã€‚ä¸¤ä¸ªèŠ‚ç‚¹ä¸ºæ­¥é•¿ï¼Œéå†é“¾è¡¨ï¼Œäº¤æ¢ä¸¤ä¸ªèŠ‚ç‚¹çš„é¡ºåºï¼Œå¹¶æŠŠå‰ä¸€ä¸ªèŠ‚ç‚¹çš„nextèµ‹å€¼ä¸ºäº¤æ¢åçš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚ç›´åˆ°é“¾è¡¨ç»“æŸå³å¯\n\n### ä»£ç \n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode pre = null;\n        ListNode current = head;\n        ListNode next = head.next;\n        ListNode tmp;\n        head = next;\n        while (true) {\n            tmp = next.next;\n            current.next = tmp;\n            next.next = current;\n            if (pre != null) {\n                pre.next = next;\n            }\n\n            pre = current;\n            if (pre.next == null) {\n                return head;\n            }\n            current = pre.next;\n            if (pre.next.next == null) {\n                return head;\n            }\n            next = pre.next.next;\n        }\n    }\n}\n```\n\n\n\n### å¤æ‚åº¦åˆ†æ\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193307443","body":"### æ€è·¯\n\nï¼ˆé€šè¿‡é¢˜è§£å­¦ä¹ ï¼‰\n\nå­¦ä¹ ä½¿ç”¨é€’å½’çš„æ–¹æ³•è§£å†³é—®é¢˜ï¼Œé€’å½’éœ€è¦æœ‰ä¸­æ­¢æ¡ä»¶ï¼Œå¦åˆ™ä¼šæœ‰æ ˆæº¢å‡ºçš„é”™è¯¯ã€‚\n\n### ä»£ç \n\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        // é€’å½’\n        return def(head, null);\n    }\n\n    public TreeNode def(ListNode head, ListNode tail) {\n        // é€’å½’ä¸­æ­¢æ¡ä»¶\n        if (head == tail) {\n            return null;\n        }\n        ListNode fast = head, slow = head;\n        // å¿«æ…¢æŒ‡é’ˆï¼Œéå†é“¾è¡¨ï¼Œå¾—åˆ°ä¸­é—´çš„èŠ‚ç‚¹\n        while (fast != tail && fast.next != tail) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        root.left = def(head, slow);\n        root.right = def(slow.next, tail);\n        return root;\n    }\n}\n```\n\n\n\n### å¤æ‚åº¦åˆ†æ\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(NlogN)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\n- ç©ºé—´å¤æ‚åº¦ï¼šO(logN)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193314392","body":"### æ€è·¯\n\nï¼ˆé€šè¿‡é¢˜è§£å­¦ä¹ ï¼‰\n\næ‰¾åˆ°ä¸¤ä¸ªé“¾è¡¨çš„ç›¸äº¤ç‚¹ï¼Œé‚£ä¹ˆä»ç›¸äº¤ç‚¹ä¹‹åçš„é“¾è¡¨çš„é•¿åº¦æ˜¯ç›¸ç­‰çš„ï¼ŒåŒæ—¶éå†ä¸¤ä¸ªé“¾è¡¨ï¼Œå½“å‰çš„é“¾è¡¨éå†å®Œåéå†å¦ä¸€ä¸ªé“¾è¡¨ï¼ˆ`A.length + B.length == B.length + A.length`ï¼‰ï¼Œä¸¤ä¸ªé“¾è¡¨çš„æŒ‡é’ˆç›¸é‡çš„èŠ‚ç‚¹å³æ˜¯ç›¸äº¤ç‚¹\n\n### ä»£ç \n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {\n            return null;\n        }\n        ListNode pA = headA, pB = headB;\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n```\n\n### å¤æ‚åº¦åˆ†æ\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(M+N)ï¼Œå…¶ä¸­ Må’ŒN ä¸ºé“¾è¡¨Aå’ŒBé•¿åº¦ã€‚\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194044331","body":"### æ€è·¯\n\nï¼ˆé€šè¿‡é¢˜è§£å­¦ä¹ ï¼‰\n\nå¿«æ…¢æŒ‡é’ˆï¼Œå¿«æŒ‡é’ˆå’Œæ»¡æŒ‡é’ˆéå†é“¾è¡¨ï¼Œç›´åˆ°ä¸¤ä¸ªæŒ‡é’ˆç›¸é‡ï¼Œå°†å¿«æŒ‡é’ˆæŒ‡å‘é“¾è¡¨å¤´ï¼Œå¿«æ…¢æŒ‡é’ˆæ­¥é•¿éƒ½è®¾ç½®ä¸º1ï¼Œç»§ç»­éå†ï¼Œä¸¤ä¸ªæŒ‡é’ˆå†æ¬¡ç›¸é‡çš„ä½ç½®å°±æ˜¯ç¯å½¢é“¾è¡¨çš„å…¥å£ï¼ˆç»è¿‡è®¡ç®—å¯ä»¥å¾—å‡ºï¼Œheadåˆ°å…¥å£çš„è·ç¦»ç­‰äºç¬¬ä¸€æ¬¡ç›¸é‡ç‚¹åˆ°å…¥å£çš„è·ç¦»ï¼‰ã€‚\n\n### ä»£ç \n\n```java\nclass Solution {\n    public ListNode detectCycle(ListNode head) {\n\n        if (head == null) {\n            return null;\n        }\n        ListNode fast = head, slow = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) {\n                fast = head;\n                while (fast != slow) {\n                    fast = fast.next;\n                    slow = slow.next;\n                }\n                return slow;\n            }\n        }\n        return null;\n    }\n}\n```\n\n\n\n### å¤æ‚åº¦åˆ†æ\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195467693","body":"### æ€è·¯\n\nå®ç°LRUæœºåˆ¶ï¼Œä½¿ç”¨åˆ°äº†Hashè¡¨å’ŒåŒå‘é“¾è¡¨ï¼Œ`put()`å’Œ`get()`çš„èŠ‚ç‚¹éƒ½éœ€è¦æ”¾åˆ°LRUé“¾è¡¨çš„é¦–ç«¯ï¼ˆä¸€èˆ¬æƒ…å†µä¸‹ï¼‰ï¼Œå½“å‘LRUä¸­æ·»åŠ æ•°æ®æ—¶LRUå·²ç»æ»¡äº†ï¼Œåˆ™åªéœ€å°†é“¾è¡¨çš„å°¾ç«¯èŠ‚ç‚¹åˆ é™¤åï¼Œå†æ­£å¸¸æ·»åŠ åˆ°é“¾è¡¨é¦–ç«¯å³å¯ï¼›å‰©ä¸‹çš„åªéœ€è¦è€ƒè™‘ä¸€äº›è¾¹ç•Œé—®é¢˜ã€‚\n\nå®ç°è¿‡ç¨‹æ¯”è¾ƒç¹å¤ï¼Œç¬¬ä¸€æ¬¡ï¼Œä½¿ç”¨äº†HashMapå’ŒåŒå‘é“¾è¡¨åˆ†å¼€ä½¿ç”¨ï¼Œæ—¶é—´ä¸Šæ•ˆæœå¾ˆå·®ï¼ˆJavaæ‰§è¡Œæ—¶é—´1600Â±msï¼‰ï¼›ç¬¬äºŒæ¬¡ï¼Œå°†åŒå‘é“¾è¡¨ä½œä¸ºHashMapçš„valueåï¼Œæ—¶é—´æœ‰æ‰€æå‡ï¼ˆJavaæ‰§è¡Œæ—¶é—´50Â±msï¼‰ï¼Œä½†æ˜¯è¿˜æœ‰ç»§ç»­å­¦ä¹ çš„ç©ºé—´\n\n### ä»£ç \n\n```java\nclass LRUCache {\n\n    class LRUNode {\n        int key;\n        int value;\n        LRUNode pre;\n        LRUNode next;\n        \n        public LRUNode() {\n        }\n        \n        public LRUNode(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n\n    }\n    \n    private int capacity;\n    \n    private HashMap<Integer, LRUNode> hashMap;\n    \n    private final LRUNode head = new LRUNode(-1, -1);\n    private final LRUNode tail = new LRUNode(-1, -1);\n    private LRUNode temp;\n\n\n    public LRUCache(int capacity) {\n        if (capacity <= 0) {\n            return;\n        }\n        this.capacity = capacity;\n        this.hashMap = new HashMap<>();\n\n        this.head.key = -1;\n        this.tail.key = -1;\n        this.head.next = this.tail;\n        this.tail.pre = this.head;\n    }\n\n    public int get(int key) {\n        if (!hashMap.containsKey(key)) {\n            return -1;\n        }\n        LRUNode lruNode = hashMap.get(key);\n        // éœ€è¦æŠŠ key æ”¾åœ¨é“¾è¡¨ first\n        if (head.next == lruNode && lruNode.pre == head) {\n            // å·²ç»æ˜¯é“¾è¡¨ first ç›´æ¥è¿”å›\n            return lruNode.value;\n        }\n        lruNode.pre.next = lruNode.next;\n        lruNode.next.pre = lruNode.pre;\n        head.next.pre = lruNode;\n        lruNode.next = head.next;\n        head.next = lruNode;\n        lruNode.pre = head;\n        return lruNode.value;\n\n    }\n\n    public void put(int key, int value) {\n\n        if (hashMap.containsKey(key)) {\n            // è‹¥æ’å…¥çš„keyå­˜åœ¨ï¼Œæ›´æ–°æ•°æ®---ä¸ç¡®å®šæ˜¯å¦éœ€è¦ä¿®æ”¹é“¾è¡¨\n            // æ¡ˆä¾‹è¡¨æ˜ éœ€è¦å°†æ”¹åŠ¨çš„èŠ‚ç‚¹æ”¾åˆ°é“¾è¡¨çš„first\n            //hashMap.replace(key, hashMap.get(key), value);\n\n            // æ›´æ–°è¿™ä¸ªkeyçš„val\n            LRUNode lruNode = hashMap.get(key);\n            lruNode.value = value;\n\n            // æ‰¾åˆ°äº†è¿™ä¸ªèŠ‚ç‚¹ï¼ŒæŠŠè¿™ä¸ªèŠ‚ç‚¹æ”¾åˆ°é“¾è¡¨ first\n            if (head.next == lruNode && lruNode.pre == head) {\n                // å·²ç»æ˜¯é“¾è¡¨ first ç›´æ¥è¿”å›\n                return;\n            }\n            lruNode.pre.next = lruNode.next;\n            lruNode.next.pre = lruNode.pre;\n            head.next.pre = lruNode;\n            lruNode.next = head.next;\n            head.next = lruNode;\n            lruNode.pre = head;\n            return;\n        }\n\n        if (hashMap.size() == this.capacity) {\n            // LRUç¼“å­˜æ»¡äº†ï¼Œå…ˆæ¸…ç†æœ€å†·çš„æ•°æ®ï¼Œå†åŠ å…¥æ–°æ•°æ®\n            hashMap.remove(tail.pre.key);\n            // é“¾è¡¨ä¸­åˆ é™¤æœ€åä¸€ä¸ªå…ƒç´ \n            temp = tail.pre.pre;\n            temp.next = tail;\n            tail.pre = temp;\n        }\n\n        // æ’å…¥æ•°æ®\n        LRUNode lruNode = new LRUNode(key, value);\n        // å­˜åˆ°hashmap\n        hashMap.put(key, lruNode);\n        // å­˜åˆ°é“¾è¡¨çš„first\n        temp = head.next;\n        head.next = lruNode;\n        temp.pre = lruNode;\n        lruNode.pre = head;\n        lruNode.next = temp;\n    }\n\n}\n```\n\n\n\n### å¤æ‚åº¦åˆ†æ\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(1)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196694423","body":"### æ€è·¯\n\nå‰åºéå†ï¼Œå…ˆåéå†å½“å‰èŠ‚ç‚¹ã€å·¦å­æ ‘ã€å³å­æ ‘ã€‚\n\né€’å½’çš„è¾“å…¥ä¸ºå½“å‰éå†åˆ°çš„èŠ‚ç‚¹ï¼Œè¾“å‡ºä¸ºå½“å‰éå†çš„æœ€å¤§æ·±åº¦ï¼Œä¸­æ­¢æ¡ä»¶æ˜¯éå†åˆ°ç©ºèŠ‚ç‚¹ã€‚\n\næ¯æ¬¡éå†å®Œä¸€ä¸ªèŠ‚ç‚¹åŠå…¶å·¦å³å­æ ‘ï¼Œå–æœ€æ·±çš„å€¼å¹¶åŠ 1è¿”å›\n\n### ä»£ç \n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int left = maxDepth(root.left);\n        int right = maxDepth(root.right);\n        return Math.max(left, right) + 1;\n    }\n}\n```\n\n### å¤æ‚åº¦åˆ†æ\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197690165","body":"### æ€è·¯\n\næ ‘çš„éå†â€”â€”å‰åºéå†\n\n1.  åˆ¤æ–­å½“å‰èŠ‚ç‚¹çš„å€¼æ˜¯å¦ç›¸ç­‰ï¼Œè‹¥ç›¸ç­‰ï¼Œåˆ†åˆ«éå†ä¸¤ä¸ªæ ‘çš„å·¦å­æ ‘å’Œå³å­æ ‘\n2.  åˆ¤æ–­ä¸­æ­¢æ¡ä»¶ï¼Œå½“èŠ‚ç‚¹çš„ä¸åŒæ—¶ä¸ºnullæˆ–èŠ‚ç‚¹å€¼ä¸ç›¸ç­‰æ—¶ï¼Œä¸­æ­¢è¿­ä»£è¿”å›false\n\n### ä»£ç \n\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null || q == null || p.val != q.val) {\n            if (p == null && q == null) {\n                return true;\n            }\n            return false;\n        }\n        boolean isSameLeftTree = isSameTree(p.left, q.left);\n        boolean isSameRightTree = isSameTree(p.right, q.right);\n        return isSameLeftTree && isSameRightTree;\n    }\n}\n```\n\n### å¤æ‚åº¦åˆ†æ\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199394404","body":"### æ€è·¯\n\nå‰åºéå†ï¼Œæ¯æ¬¡å¸¦ä¸Šå‰é¢èŠ‚ç‚¹è®¡ç®—å‡ºçš„å€¼\n\n### ä»£ç \n\n```java\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        int sum = dfs(root, 0);\n        return sum;\n    }\n\n    public int dfs(TreeNode root, int sum) {\n        if (root == null) {\n            return 0;\n        }\n        int res = sum * 10 + root.val;\n        if (root.left == null && root.right == null) {\n            return res;\n        } else {\n            return dfs(root.left, res) + dfs(root.right, res);\n        }\n        \n    }\n}\n```\n\n\n\n### å¤æ‚åº¦åˆ†æ\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200148498","body":"### æ€è·¯\n\næ ‘çš„éå†ï¼Œéœ€è¦åŠ å…¥ä¸€ä¸ª`currentHeight`æ¥è®°å½•å½“å‰éå†åˆ°çš„å±‚æ·±åº¦ï¼Œä»æ ¹èŠ‚ç‚¹å¼€å§‹é€å±‚éå†ã€‚\n\n-   è‹¥èŠ‚ç‚¹ä¸º`null`ï¼Œç›´æ¥è¿”å›\n-   è‹¥èŠ‚ç‚¹é`null`ï¼Œ`currentHeight`+1ï¼Œå†ç»§ç»­éå†å…¶å·¦å³èŠ‚ç‚¹\n-   å½“éå†çš„æ·±åº¦å€¼æ¯”å½“å‰è®°å½•çš„æ·±åº¦å€¼å¤§æ—¶ï¼Œæ›´æ–°`currentHeight`ä¸ºå½“å‰æ·±åº¦å€¼ï¼Œæ›´æ–°`currentValue`ä¸ºå½“å‰èŠ‚ç‚¹å€¼ï¼Œè¿™æ„å‘³ç€ï¼Œç¬¬ä¸€æ¬¡åˆ°è¾¾è¯¥å±‚æ—¶ï¼Œè®°å½•ä¸‹è¯¥å±‚ç¬¬ä¸€ä¸ªå€¼ï¼ˆä¹Ÿå°±æ˜¯æœ€å·¦è¾¹çš„å€¼ï¼‰\n\n### ä»£ç \n\n```java\nclass Solution {\n    \n    int currentHeight = 0;\n    int currentValue = Integer.MIN_VALUE;\n    \n    public int findBottomLeftValue(TreeNode root) {\n        dfs(root, 0);\n        return currentValue;\n    }\n    \n    private void dfs(TreeNode node, int height) {\n\n        if (node == null) {\n            return;\n        }\n        height++;\n        dfs(node.left, height);\n        dfs(node.right, height);\n        if (height > currentHeight) {\n            currentHeight = height;\n            currentValue = node.val;\n        }\n    }\n    \n}\n```\n\n\n\n### å¤æ‚åº¦åˆ†æ\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200420835","body":"### ä»£ç \n\n```java\npublic class Codec {\n    public String serialize(TreeNode root) {\n        return rserialize(root, \"\");\n    }\n  \n    public TreeNode deserialize(String data) {\n        String[] dataArray = data.split(\",\");\n        List<String> dataList = new LinkedList<String>(Arrays.asList(dataArray));\n        return rdeserialize(dataList);\n    }\n\n    public String rserialize(TreeNode root, String str) {\n        if (root == null) {\n            str += \"None,\";\n        } else {\n            str += str.valueOf(root.val) + \",\";\n            str = rserialize(root.left, str);\n            str = rserialize(root.right, str);\n        }\n        return str;\n    }\n  \n    public TreeNode rdeserialize(List<String> dataList) {\n        if (dataList.get(0).equals(\"None\")) {\n            dataList.remove(0);\n            return null;\n        }\n  \n        TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0)));\n        dataList.remove(0);\n        root.left = rdeserialize(dataList);\n        root.right = rdeserialize(dataList);\n    \n        return root;\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201207652","body":"### æ€è·¯\n\né¦–å…ˆï¼Œè¿›è¡Œä½¿ç”¨`dfs`å¾—åˆ°å…³äºè¡Œã€åˆ—ã€å€¼çš„åˆ—è¡¨ï¼›ç„¶åï¼Œå¯¹åˆ—è¡¨è¿›è¡Œæ’åºï¼Œæ’åºè§„åˆ™éœ€è¦è‡ªå®šä¹‰ï¼›æœ€åæŒ‰ç…§æ’åºååˆ—è¡¨çš„rowå’Œcolå€¼å…ˆååŠ å…¥åˆ°ç»“æœåˆ—è¡¨ä¸­ã€‚\n\n\n\n### ä»£ç \n\n```java\nclass Solution {\n\n    // åˆ—\n    int col = 0;\n    // æ’\n    int row = 0;\n\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n\n        List<int[]> list = new ArrayList<>();\n        dfs(root, col, row, list);\n\n        if (list == null) {\n            return null;\n        }\n        list.sort(new Comparator<int[]>() {\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                if (o1[0] == o2[0] && o1[1] == o2[1]) {\n                    return o1[2] - o2[2];\n                }\n                if (o1[0] == o2[0]) {\n                    return o1[1] - o2[1];\n                }\n                return o1[0] - o2[0];\n            }\n        });\n        List<List<Integer>> resList = new ArrayList<>();\n\n        int currentCol = Integer.MIN_VALUE;\n        for (int i = 0; i < list.size(); i++) {\n            int col = list.get(i)[0];\n            if (currentCol == col) {\n                resList.get(resList.size() - 1).add(list.get(i)[2]);\n                continue;\n            }\n            currentCol = col;\n            List<Integer> tempList = new ArrayList<>();\n            tempList.add(list.get(i)[2]);\n            resList.add(tempList);\n        }\n        return resList;\n    }\n\n    // æ·±åº¦ä¼˜å…ˆéå†æ ‘ï¼Œå¾—åˆ°èŠ‚ç‚¹å’Œåæ ‡å’Œå€¼\n    private void dfs(TreeNode node, int col, int row, List<int[]> nodeList) {\n        if (node == null) {\n            return;\n        }\n        nodeList.add(new int[]{col, row, node.val});\n        dfs(node.left, col - 1, row + 1, nodeList);\n        dfs(node.right, col + 1, row + 1, nodeList);\n    }\n}\n```\n\n\n\n### å¤æ‚åº¦åˆ†æ\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202291753","body":"### æ€è·¯\n\nå¯¹æ•°ç»„è¿›è¡Œéå†ï¼Œä½¿ç”¨HashMapå¿«é€ŸæŸ¥æ‰¾ç›®æ ‡å€¼ã€‚\n\n### ä»£ç \n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        if (nums == null || nums.length < 2) {\n            return null;\n        }\n\n        HashMap<Integer, Integer> hashMap = new HashMap<>();\n        int[] result = new int[2];\n        // æ•°ç»„å…ƒç´ åŠ å…¥åˆ° HashMap\n        for (int i = 0; i < nums.length; i++) {\n            if (hashMap.containsKey(nums[i])) {\n                hashMap.replace(nums[i], hashMap.get(nums[i]), i);\n            }\n            hashMap.put(nums[i], i);\n        }\n        // å¯»æ‰¾ç›®æ ‡å€¼\n        for (int i = 0; i < nums.length; i++) {\n            if (hashMap.containsKey(target - nums[i])) {\n                if (i == hashMap.get(target - nums[i])) {\n                    continue;\n                }\n                result[0] = i;\n                result[1] = hashMap.get(target - nums[i]);\n                return result;\n            }\n        }\n        return null;\n    }\n}\n```\n\nè¿è¡Œæ—¶é—´æœ‰ç‚¹é•¿ï¼Œå­¦ä¹ åè¿›è¡Œäº†ä¿®æ”¹\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        if (nums == null || nums.length < 2) {\n            return null;\n        }\n\n        HashMap<Integer, Integer> hashMap = new HashMap<>();\n        int[] result = new int[2];\n        // éå†çš„åŒæ—¶å°†æ•°æ®åŠ å…¥HashMapï¼Œå¯»æ‰¾æ•°ç»„ä¸­å€¼ä¸º target - nums[i] å¯¹åº”çš„ position\n        for (int i = 0; i < nums.length; i++) {\n            if (hashMap.containsKey(target - nums[i])) {\n                result[0] = i;\n                result[1] = hashMap.get(target - nums[i]);\n                return result;\n            }\n            hashMap.put(nums[i], i);\n        }\n        return null;\n    }\n}\n```\n\n\n\n### å¤æ‚åº¦åˆ†æ\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203887634","body":"### æ€è·¯\n\næœ´(c)ç´ (a)çš„(Ã¬)æƒ³æ³•ï¼Œä½¿ç”¨HashMapç»Ÿè®¡å…ƒç´ å‡ºç°çš„æ¬¡æ•°ï¼Œè½¬æ¢ä¸ºæ•°ç»„ä½¿ç”¨ListæŒ‰ç…§å‡ºç°æ¬¡æ•°ä»é«˜åˆ°ä½æ’åº\n\n### ä»£ç \n\n```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        LinkedHashMap<Integer, Integer> hashMap = new LinkedHashMap<>();\n        int[] result = new int[k];\n        ArrayList<int[]> list = new ArrayList<>();\n        for (int i = 0; i < nums.length; i++) {\n            int num = nums[i];\n            hashMap.put(num, hashMap.containsKey(num) ? hashMap.get(num) + 1 : 1);\n        }\n        for (Integer integer : hashMap.keySet()) {\n            list.add(new int[]{integer, hashMap.get(integer)});\n        }\n        list.sort(new Comparator<int[]>() {\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                return o2[1] - o1[1];\n            }\n        });\n        for (int i = 0; i < k; i++) {\n            result[i] = list.get(i)[0];\n        }\n        return result;\n    }\n}\n```\n\n\n\n### å¤æ‚åº¦åˆ†æ\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n log n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205210747","body":"### æ€è·¯\n\næš´åŠ›æ³•ï¼ˆæ—¶é—´æ€æ‰‹ç½¢äº†ï¼‰ï¼Œæäº¤è¶…æ—¶ï¼Œå…ˆæ‰“å¡ï¼Œå†ç»§ç»­å­¦ä¹ \n\n### ä»£ç \n\n```java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n\n        if (points.length < 3) {\n            return 0;\n        }\n        int res = 0;\n\n        for (int i = 0; i < points.length; i++) {\n            for (int j = 0; j < points.length; j++) {\n                if (i == j) continue;\n                for (int k = 0; k < points.length; k++) {\n                    if (k == j || i == k) continue;\n                    double distinct1 = \n                        Math.pow(points[i][0] - points[j][0], 2) + Math.pow(points[i][1] - points[j][1], 2);\n                    double distinct2 = \n                        Math.pow(points[i][0] - points[k][0], 2) + Math.pow(points[i][1] - points[k][1], 2);\n                    if (distinct1 == distinct2) {\n                        res++;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}\n\n```\n\n\n\n### å¤æ‚åº¦åˆ†æ\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N^3)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206484551","body":"``` java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n    HashMap<Character, Integer> hashMap = new HashMap<>();\n        int res = 0;\n        int post = 0;\n        if (s.length() <= 1) {\n            res = s.length();\n            return res;\n        }\n        for (int i = 0; i < s.length(); i++) {\n            if (hashMap.containsKey(s.charAt(i))) {\n                // è·å– s.charAt(i) ä¸Šæ¬¡å‡ºç°çš„ä½ç½®åºå·\n                post = Math.max(hashMap.get(s.charAt(i)) + 1 , post);\n            }\n            hashMap.put(s.charAt(i), i);\n            // i - post + 1 è¡¨ç¤ºè¿™æ®µå­å­—ç¬¦ä¸²é•¿åº¦\n            res = Math.max(i - post + 1, res);\n\n        }\n        return res;\n    }\n\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207214098","body":"### æ€è·¯\n\næƒ³ä¸å‡ºæ¥ï¼Œæš´åŠ›è§£æ³•\n\n### ä»£ç \n\n```java\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        int wlen=words.length,len=words[0].length(),slen=s.length();\n        HashMap<String,Integer> map=new HashMap<>();\n        for(int i=0;i<wlen;i++){\n            map.put(words[i],map.getOrDefault(words[i],0)+1);\n        }\n        Map<String, Integer> clone = null;\n        Map<String,Integer> empty=new HashMap<>();\n        List<Integer> list=new ArrayList<>();\n        int n=slen-wlen*len+1;  \n        String temp=\"\";\n\n        for(int i=0;i<n;i++){\n            clone=(Map<String, Integer>) map.clone();\n            for(int j=i;j<i+wlen*len;j+=len){\n                temp=s.substring(j,j+len);\n                if(!clone.containsKey(temp))\n                    break;\n                if(clone.get(temp)>1)\n                    clone.put(temp,clone.get(temp)-1);\n                else\n                    clone.remove(temp);\n            }\n            if(empty.equals(clone)){\n                list.add(i);\n            }\n        }\n        return list;\n\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207417854","body":"```java\nimport java.util.*;\n\nclass Solution {\n    public int solve(int[] nums, int k) {\n        //(totalSUm - delete) % k == 0;\n        // totalSUm % k = delet%k\n        // let totalSum % k = totalMod\n        // totalMod % k = totalMod;\n        // delet%k = prefix[j] % k - prefix[i] %k = totalMod %k;\n        // pre[i] % k = (pre[j] - totalMod) % k;\n        int total = 0;\n        for (int n : nums) {\n            total += n;\n        }\n        int totalMod = Math.floorMod(total, k);\n\n        Map<Integer, Integer> map = new HashMap();\n        map.put(0, -1);\n        int prefix = 0;\n        int res = nums.length;\n        for (int i = 0; i < nums.length; i++) {\n            prefix += nums[i];\n            int curMod = Math.floorMod(prefix, k);\n            map.put(curMod, i);\n            int afterMod = Math.floorMod(prefix - totalMod, k);\n            // System.out.println(afterMod + \"total\" + totalMod +\"pre\" + prefix);\n            if (map.containsKey(afterMod)) {\n                int len = i - map.get(afterMod);\n                System.out.println(i);\n                res = len < res ? len : res;\n            }\n        }\n        return res == nums.length ? -1 : res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207600122","body":"### æ€è·¯\n\nå¿«æ…¢æŒ‡é’ˆï¼Œå¿«æŒ‡é’ˆçš„æ­¥é•¿æ˜¯æ…¢æŒ‡é’ˆçš„ä¸¤å€ï¼Œæ…¢æŒ‡é’ˆæ­¥é•¿ä¸º1ï¼›å½“å¿«æŒ‡é’ˆéå†åˆ°é“¾è¡¨æœ«ç«¯æ—¶ï¼Œæ…¢æŒ‡é’ˆèµ°è¿‡å…¶ä¸€åŠçš„é•¿åº¦ï¼Œä¹Ÿå°±æ˜¯åœ¨é“¾è¡¨çš„ä¸­é—´\n\n### ä»£ç \n\n```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```\n\n### å¤æ‚åº¦åˆ†æ\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(Nï¼‰\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208883498","body":"### æ€è·¯\n\nåŒæŒ‡é’ˆï¼›è‹¥æ˜¯æ‰¾åˆ°å’Œæ…¢æŒ‡é’ˆç›¸ç­‰çš„å…ƒç´ ï¼Œåˆ™ç»§ç»­éå†ï¼›è‹¥æ˜¯æ‰¾å½“å’Œå½“å‰æ…¢æŒ‡é’ˆçš„å…ƒç´ ä¸ç­‰ï¼Œåˆ™æ…¢æŒ‡é’ˆçš„ä¸‹ä¸€ä½è®°å½•è¯¥å€¼ï¼Œç»§ç»­éå†\n\n### ä»£ç \n\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        if (nums.length < 2){\n            return nums.length;\n        }\n        int slow = 0, fast = 1;\n        while (fast < nums.length){\n            if (nums[slow] == nums[fast]){\n                fast++;\n            } else if (nums[slow] < nums[fast]){\n                nums[++slow] = nums[fast++];\n            }\n        }\n        return slow + 1;\n    }\n}\n```\n\n\n\n### å¤æ‚åº¦åˆ†æ\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wzasd":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185232708","body":"### æ€è·¯\r\n\r\næœ¬æ¥æƒ³ç”¨`BigInteger`æ¥è¿›è¡Œå¤§æ•°è®¡ç®—ï¼Œç„¶åé€šè¿‡å­—ç¬¦ä¸²è¿›è¡Œæ•°ç»„è½¬æ¢ï¼Œä½†æ˜¯å‘ç° leetcode æ— æ³•ä½¿ç”¨`BigInteger`ï¼Œæ‰€ä»¥è¿˜æ˜¯ä½¿ç”¨æ•°ç»„å•é¡¹ç›¸åŠ å³å¯ï¼Œä¸»è¦è€ƒè™‘è¿›ä½å¤„ç†ï¼Œå¦ä¸€ä¸ªæ–¹æ³•å°±æ˜¯å•ä½ç›¸åŠ ï¼Œé€ä¸€æ¨å‡ºç›¸åº”å•ä½æ•°å°±è¡Œäº†\r\n\r\n### ä»£ç \r\n\r\n#### å†™æ³•ä¸€\r\n```javaï¼ˆæ­¤å¤„æ¢æˆä½ çš„è¯­è¨€ï¼Œæ¯”å¦‚jsï¼Œpy ç­‰ï¼‰\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int len = num.length;\r\n        List<Integer> ans = new ArrayList<>();\r\n        for (int i = len - 1; i >= 0; i--) {\r\n            //æ•°ç»„ä¸­å•é¡¹ç›¸åŠ \r\n            int sum = num[i] + k % 10;\r\n            k = k / 10;\r\n            // åˆ¤æ–­æ˜¯å¦æœ‰è¿›ä½çš„æ•°\r\n            if (sum >= 10) {\r\n                ++k;\r\n                sum = sum - 10;\r\n            }\r\n            ans.add(sum);\r\n        }\r\n        //ä¸ç¡®å®šæ˜¯kå¤§è¿˜æ˜¯numä»£è¡¨çš„æ•°æ®å¤§ï¼Œæ‰€ä»¥è¦è¿›è¡Œä¸¤æ¬¡è¿ç®—\r\n        for (; k > 0; k /= 10) {\r\n            ans.add(k % 10);\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n```\r\n\r\n#### å†™æ³•äºŒ\r\n```javaï¼ˆæ­¤å¤„æ¢æˆä½ çš„è¯­è¨€ï¼Œæ¯”å¦‚jsï¼Œpy ç­‰ï¼‰\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int len = num.length;\r\n        List<Integer> ans = new ArrayList<>();\r\n        //ç®€åŒ–ä¸Šä¸€æ­¥\r\n        for (int i = len - 1; i >= 0 || k > 0; i--, k /= 10) {\r\n            if (i >= 0) {\r\n                k = num[i] + k;\r\n            }\r\n            ans.add(k % 10);\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186191505","body":"### æ€è·¯\r\n\r\nä½¿ç”¨äºŒæ¬¡éå†ï¼Œç¬¬ä¸€æ¬¡éå†è·å–æ‰€æœ‰å‘½ä¸­å­—ç¬¦çš„ä¸‹è¡¨ï¼Œç¬¬äºŒæ¬¡éå†è®¡ç®—æœ€è¿œè·ç¦»ï¼Œè·å–ä¸ä¸Šä¸€æ¬¡çš„è·ç¦»æœ€å°å€¼å³å¯ï¼Œæ³¨æ„å¤„ç†åªæœ‰ä¸€æ¬¡çš„æƒ…å†µ\r\n\r\n### ä»£ç \r\n\r\n\r\n```javaï¼ˆæ­¤å¤„æ¢æˆä½ çš„è¯­è¨€ï¼Œæ¯”å¦‚jsï¼Œpy ç­‰ï¼‰\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] ans = new int[s.length()];\r\n        List<Integer> cIndex = new ArrayList<>();\r\n        for (int i = 0; i < s.length(); i++) {\r\n            char sChar = s.charAt(i);\r\n            if (sChar == c){\r\n                cIndex.add(i);\r\n            }\r\n        }\r\n        for (int i = 0, j = 0; i < s.length(); i++) {\r\n            if (s.charAt(i) == c){\r\n                ans[i]=0;\r\n                if (j != cIndex.size() - 1){\r\n                    j++;\r\n                }\r\n                continue;\r\n            }\r\n            if (j >= 1){\r\n                ans[i] = Math.min(Math.abs(cIndex.get(j) - i),Math.abs(cIndex.get(j-1) - i));\r\n            }else {\r\n                ans[i] = Math.abs(cIndex.get(j) - i);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186429099","body":"### æ€è·¯\r\n\r\né€šè¿‡LinkList æ¥æ¨¡æ‹Ÿæ ˆçš„ä½¿ç”¨ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥ä½¿ç”¨æ•°ç»„ï¼Œè¿™é‡Œåªè¦å¤„ç†å¥½è¾¹ç•Œæ¡ä»¶å°±å¯ä»¥äº†\r\n\r\n### ä»£ç \r\n\r\n\r\n```javaï¼ˆæ­¤å¤„æ¢æˆä½ çš„è¯­è¨€ï¼Œæ¯”å¦‚jsï¼Œpy ç­‰ï¼‰\r\nclass CustomStack {\r\n\r\n    LinkedList<Integer> stack = new LinkedList<>();\r\n    int MaxSize;\r\n    public CustomStack(int maxSize) {\r\n        MaxSize = maxSize;\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (stack.size() < MaxSize) {\r\n            stack.add(stack.size(),x);\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        if (stack.isEmpty()){\r\n            return -1;\r\n        }\r\n        int popNum = stack.getLast();\r\n        stack.removeLast();\r\n        return popNum;\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        for (int i = 0; i < stack.size() && i < k; i++) {\r\n            stack.set(i,stack.get(i) + val);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186692154","body":"### æ€è·¯\r\n\r\nä¸ä¹‹å‰çš„åŒ¹é…å­—ç¬¦ä¸²æœ‰ç‚¹åƒï¼Œè¿™é‡Œé‡‡ç”¨å…¥æ ˆçš„æ–¹å¼ï¼Œåˆ†ä¸ºä¸‰ç§æƒ…å†µ\r\n\r\n1. æ•°å­—å…¥æ ˆï¼Œè¿™é‡Œè¦å¯¹è¿ç»­æ•°å­—è¿›è¡Œå¤„ç†\r\n2. å­—æ¯è¿˜æœ‰â€œ[â€æ‹¬å·å…¥æ ˆ\r\n3. é‡åˆ°â€œ]â€æ‹¬å·å‡ºæ ˆï¼ŒåŒæ—¶æˆªå–ç¬¬äºŒæ­¥æ‹¬å·ä¹‹å‰çš„å­—ç¬¦\r\n\r\nå¼¹å‡º\"[\"æ‹¬å·å­—ç¬¦ï¼Œè·å–é‡å¤çš„æ¬¡æ•°ï¼Œå¤„ç†è¿™äº›å­—ç¬¦ä¸²å°±å¯ä»¥äº†ã€‚\r\n\r\n### ä»£ç \r\n\r\n\r\n```javaï¼ˆæ­¤å¤„æ¢æˆä½ çš„è¯­è¨€ï¼Œæ¯”å¦‚jsï¼Œpy ç­‰ï¼‰\r\n    int curIndex;\r\n    public String decodeString(String s) {\r\n        LinkedList<String> ans = new LinkedList<>();\r\n        curIndex = 0;\r\n        while (curIndex < s.length()) {\r\n            char c = s.charAt(curIndex);\r\n            if (Character.isDigit(c)) {\r\n                String strDigit = getDigits(s);\r\n                ans.addLast(strDigit);\r\n            } else if (Character.isLetter(c) || c == '[') {\r\n                ans.addLast(String.valueOf(s.charAt(curIndex++)));\r\n            } else {\r\n                curIndex++;\r\n                LinkedList<String> subStr = new LinkedList<>();\r\n                while (!ans.peekLast().equals(\"[\")){\r\n                    subStr.addLast(ans.removeLast());\r\n                }\r\n                ans.removeLast();\r\n                Collections.reverse(subStr);\r\n                Integer repeatTimes = Integer.parseInt(ans.removeLast());\r\n                StringBuffer sb = new StringBuffer();\r\n                String o = getString(subStr);\r\n                while (repeatTimes-- > 0 ){\r\n                    sb.append(o);\r\n                }\r\n                ans.addLast(sb.toString());\r\n            }\r\n        }\r\n        return getString(ans);\r\n    }\r\n\r\n    public String getDigits(String s) {\r\n        StringBuffer sb = new StringBuffer();\r\n        while (Character.isDigit(s.charAt(curIndex))){\r\n            sb.append(s.charAt(curIndex++));\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    public String getString(LinkedList<String> ll) {\r\n        StringBuffer ans = new StringBuffer();\r\n        for (String s :\r\n                ll) {\r\n            ans.append(s);\r\n        }\r\n        return ans.toString();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Solution1 solution1 = new Solution1();\r\n        System.out.println(solution1.decodeString(\"3[a]2[bc]\"));\r\n    }\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºå­—ç¬¦ä¸²é•¿åº¦ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188507766","body":"### æ€è·¯\r\n\r\nç†è§£æ ˆå’Œé˜Ÿåˆ—çš„æ€æƒ³å°±å¾ˆå¥½è§£äº†ï¼Œä½¿ç”¨ LinkList æ¥æ¨¡æ‹Ÿæ ˆï¼Œä¿®æ”¹çš„æ—¶å€™åªè€ƒè™‘å¢å’Œåˆ é™¤çš„æ—¶å€™ä¿è¯ä¸¤ä¸ªæ ˆä¸€æ ·å°±è¡Œäº†ã€‚\r\n\r\n### ä»£ç \r\n\r\n\r\n```java\r\nclass MyQueue {\r\n    LinkedList<Integer> stack1;\r\n    LinkedList<Integer> stack2;\r\n    public MyQueue() {\r\n        stack1 = new LinkedList<>();\r\n        stack2 = new LinkedList<>();\r\n    }\r\n\r\n    public void push(int x) {\r\n        stack1.addFirst(x);\r\n        in2tou(stack1,stack2);\r\n    }\r\n\r\n    public int pop() {\r\n        int popNum = stack2.removeFirst();\r\n        in2tou(stack2,stack1);\r\n        return popNum;\r\n    }\r\n\r\n    public int peek() {\r\n        return stack2.getFirst();\r\n    }\r\n\r\n    public boolean empty() {\r\n        return stack2.isEmpty();\r\n    }\r\n\r\n    public void in2tou(LinkedList<Integer> in,LinkedList<Integer> out){\r\n        out.clear();\r\n        for (int num : in) {\r\n            out.addFirst(num);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189768960","body":"### æ€è·¯\r\n\r\nè¾…åŠ©æ ˆè¿˜æ˜¯æ¯”è¾ƒå¥½ç†è§£çš„ï¼Œåªéœ€è¦åˆ¤æ–­æ¯ä¸ªç»„çš„æœ€å¤§å€¼ï¼Œå†å»åˆ†æä¸‹ä¸€ä¸ªæ•°å­—ä¸è¿™ä¸ªå€¼å¾—å¤§å°ã€‚é€»è¾‘å¦‚ä¸‹\r\n\r\n1. å¾ªç¯æ•°ç»„aar\r\n2. åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©ºï¼Œå¾ªç¯çš„æ•°numæ˜¯å¦æ¯”ç›®å‰çš„æ ˆé¡¶å…ƒç´ å¤§ï¼Œå¦‚æœå¤§åˆ™å…¥æ ˆï¼Œå¦‚æœå°\r\n3. åˆ™æœ€å¤§å€¼å‡ºæ ˆï¼Œå¾ªç¯å¾€ä¸‹å¯»æ‰¾æœ€å°å€¼ï¼Œå†å°†æ ˆé¡¶å…¥æ ˆ\r\n\r\nä¾æ¬¡å¾—å‡ºæ ˆçš„å€¼åˆ™æ˜¯æœ€å¤§çš„æ•°äº†\r\n\r\n### ä»£ç \r\n\r\n\r\n```java\r\n        LinkedList<Integer> stack = new LinkedList<>();\r\n        for (int num : arr) {\r\n            if (!stack.isEmpty() && num < stack.getLast()) {\r\n                int head = stack.removeLast();\r\n                while (!stack.isEmpty() && num < stack.getLast()) {\r\n                    stack.removeLast();\r\n                }\r\n                stack.addLast(num);\r\n            } else {\r\n                stack.addLast(num);\r\n            }\r\n        }\r\n        return stack.size();\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191004028","body":"### æ€è·¯\r\n\r\nä»£ç ä¸å¤Ÿç®€æ´ï¼Œä½†æ˜¯åªè¦æœ‰è¶³å¤Ÿçš„ä¸­é—´å˜é‡å°±å¯ä»¥å®Œæˆäº†ï¼Œä¸»è¦è¿˜æ˜¯é ç”»å›¾ï¼Œå¦‚æœä¸ç”»å›¾ï¼Œé€æ¸ç‹°ç‹ï¼\r\n\r\n### ä»£ç \r\n\r\n\r\n```javaï¼ˆæ­¤å¤„æ¢æˆä½ çš„è¯­è¨€ï¼Œæ¯”å¦‚jsï¼Œpy ç­‰ï¼‰\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (k == 0 || head == null || head.next == null) {\r\n            return head;\r\n        }\r\n\r\n        int len = 0;\r\n        ListNode cur = head;\r\n        while (cur != null) {\r\n            cur = cur.next;\r\n            len++;\r\n        }\r\n\r\n        int movedLocation = k % len;\r\n\r\n        if (movedLocation == 0) {\r\n            return head;\r\n        }\r\n\r\n        cur = head;\r\n        for (int i = 0; i < len - movedLocation - 1; i++) {\r\n            cur = cur.next;\r\n        }\r\n\r\n        ListNode ans = cur.next;\r\n        ListNode ansLast = ans;\r\n        cur.next = null;\r\n        while (ansLast.next != null) {\r\n            ansLast = ansLast.next;\r\n        }\r\n        ansLast.next = head;\r\n        return ans;\r\n    }\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192124159","body":"### æ€è·¯\r\n\r\næ€æƒ³æ¯”è¾ƒå¤æ‚ï¼Œè¿˜æ˜¯éœ€è¦å­¦ä¹ å‘€ï¼Œå¾ˆç®€å•çš„æƒ³æ³•ï¼Œä»é›¶å¼€å§‹è¿­ä»£äº¤æ¢ï¼Œäº¤æ¢ånextä¸€å®šæ˜¯ä¸‹ä¸€ä¸ªè¿­ä»£çš„å¼€å§‹ï¼Œæ•ˆç‡æ¯”è¾ƒå¿«ä¸€æ¬¡è¿­ä»£å°±å¯ä»¥å¾ªç¯å…¨éƒ¨ï¼Œä¹Ÿä¸éœ€è¦ä¿®æ”¹å€¼\r\n### ä»£ç \r\n\r\n\r\n```java\r\n    public ListNode swapPairs(ListNode head) {\r\n        if (head == null || head.next == null) {\r\n            return head;\r\n        }\r\n        ListNode cur = head;\r\n        ListNode pre = null;\r\n        ListNode ans = head.next;\r\n        while (cur != null && cur.next != null) {\r\n            ListNode next = cur.next;\r\n            cur.next = next.next;\r\n            next.next = cur;\r\n            if (pre != null) {\r\n                pre.next = next;\r\n            }\r\n            pre = cur;\r\n            cur = cur.next;\r\n        }\r\n        return ans;\r\n    }\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193131557","body":"## æ€è·¯\r\nå¿«æ…¢æŒ‡é’ˆ\r\n\r\n## ä»£ç \r\n\r\n```java\r\n\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        return buildTree(head, null);\r\n    }\r\n\r\n    public TreeNode buildTree(ListNode left, ListNode right) {\r\n        if (left == right) {\r\n            return null;\r\n        }\r\n        ListNode mid = getMedian(left, right);\r\n        TreeNode root = new TreeNode(mid.val);\r\n        root.left = buildTree(left, mid);\r\n        root.right = buildTree(mid.next, right);\r\n        return root;\r\n    }\r\n\r\n    public ListNode getMedian(ListNode left, ListNode right) {\r\n        ListNode fast = left;\r\n        ListNode slow = left;\r\n        while (fast != right && fast.next != right) {\r\n            fast = fast.next;\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193269943","body":"## æ€è·¯\r\nä½¿ç”¨åŒæŒ‡é’ˆï¼Œè¿™é“é¢˜çš„å…³é”®ç‚¹å°±æ˜¯ä¸¤ä¸ªnodeç›¸äº¤ï¼Œæ€»é•¿åº¦éå†åå°±å¯ä»¥\r\n## ä»£ç \r\n```java\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if (headA==null && headA == null) {\r\n            return null;\r\n        }\r\n        ListNode curHeadANode = headA;\r\n        ListNode curHeadBNode = headB;\r\n        while (curHeadANode!=curHeadBNode) {\r\n            curHeadANode = curHeadANode == null?headB:curHeadANode.next;\r\n            curHeadBNode = curHeadBNode == null?headA:curHeadBNode.next;\r\n        }\r\n        return curHeadANode;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193640336","body":"## æ€è·¯\r\nè¿™ä¸ªç”¨çš„æ˜¯Hashæ ‡çš„æ–¹å¼ï¼Œä½†æ˜¯ç©ºé—´å¤æ‚åº¦ä¼šä¸Šå‡åˆ°O(N)ï¼Œç†è®ºä¸Šå¿«æ…¢æŒ‡é’ˆä¼šæ›´å¥½ä¸€äº›ï¼Œ\r\n## ä»£ç \r\n```java\r\n    public ListNode detectCycle(ListNode head) {\r\n        Set<ListNode> set = new HashSet<>();\r\n        ListNode pos = head;\r\n        while (pos != null) {\r\n            if (set.contains(pos)) {\r\n                return pos;\r\n            }\r\n            set.add(pos);\r\n            pos = pos.next;\r\n        }\r\n        return null;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195043755","body":"## æ€è·¯\r\nä¸»è¦å°±æ˜¯å“ˆå¸Œè¡¨é…åˆåŒé“¾è¡¨ï¼Œæ¥åšLRUï¼Œé—®é¢˜çš„å…³é”®å°±æ˜¯ï¼Œé¦–å°¾æ¨¡æ‹Ÿ\r\n\r\n## ä»£ç \r\n```java\r\n    class DLinkedNode {\r\n        int key;\r\n        int value;\r\n        DLinkedNode prev;\r\n        DLinkedNode next;\r\n        public DLinkedNode() {\r\n        }\r\n\r\n        public DLinkedNode(int _key, int _value) {\r\n            key = _key;\r\n            value = _value;\r\n        }\r\n    }\r\n\r\n    int size;\r\n    int capacity;\r\n    DLinkedNode head;\r\n    DLinkedNode tail;\r\n    HashMap<Integer, DLinkedNode> cache;\r\n\r\n    public LRUCache(int capacity) {\r\n        size = 0;\r\n        this.capacity = capacity;\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        cache = new HashMap<>();\r\n        head.next = tail;\r\n        tail.prev = head;\r\n    }\r\n\r\n    public int get(int key) {\r\n        if (cache.containsKey(key)) {\r\n            DLinkedNode hit = cache.get(key);\r\n            moveToHead(hit);\r\n            return hit.value;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        if (cache.containsKey(key)) {\r\n            DLinkedNode hit = cache.get(key);\r\n            hit.value = value;\r\n            moveToHead(hit);\r\n        } else {\r\n            DLinkedNode hit = new DLinkedNode(key, value);\r\n            cache.put(key, hit);\r\n            addToHead(hit);\r\n            ++size;\r\n            if (size > capacity) {\r\n                DLinkedNode tail = removeTail();\r\n                cache.remove(tail.key);\r\n                --size;\r\n            }\r\n        }\r\n    }\r\n\r\n    private void removeNode(DLinkedNode node) {\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n    }\r\n\r\n    private DLinkedNode removeTail() {\r\n        DLinkedNode res = tail.prev;\r\n        removeNode(res);\r\n        return res;\r\n    }\r\n\r\n    private void addToHead(DLinkedNode hit) {\r\n        hit.next = head.next;\r\n        hit.prev = head;\r\n        head.next.prev = hit;\r\n        head.next = hit;\r\n    }\r\n\r\n    private void moveToHead(DLinkedNode hit) {\r\n        removeNode(hit);\r\n        addToHead(hit);\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196224377","body":"## æ€è·¯\r\né€’å½’ç»ƒä¹ ï¼Œæ·±åº¦æœç´¢\r\n## ä»£ç \r\n```java\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n        int leftHeight = maxDepth(root.left);\r\n        int rightHeight = maxDepth(root.right);\r\n        return Math.max(leftHeight, rightHeight) + 1;\r\n    }\r\n```\r\n## å¤æ‚åº¦\r\ntime O(N)\r\nspace O(HEIGH)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198312965","body":"```java\r\n   public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null && q == null) {\r\n            return true;\r\n        } else if (p == null || q == null) {\r\n            return false;\r\n        } else if (p.val != q.val) {\r\n            return false;\r\n        } else {\r\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n        }\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199546279","body":"```java\r\npublic int sumNumbers(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n        int sum = 0;\r\n        Queue<TreeNode> nodeQueue = new LinkedList<TreeNode>();\r\n        Queue<Integer> numQueue = new LinkedList<Integer>();\r\n        nodeQueue.offer(root);\r\n        numQueue.offer(root.val);\r\n        while (!nodeQueue.isEmpty()) {\r\n            TreeNode node = nodeQueue.poll();\r\n            int num = numQueue.poll();\r\n            TreeNode left = node.left, right = node.right;\r\n            if (left == null && right == null) {\r\n                sum += num;\r\n            } else {\r\n                if (left != null) {\r\n                    nodeQueue.offer(left);\r\n                    numQueue.offer(num * 10 + left.val);\r\n                }\r\n                if (right != null) {\r\n                    nodeQueue.offer(right);\r\n                    numQueue.offer(num * 10 + right.val);\r\n                }\r\n            }\r\n        }\r\n        return sum;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200227451","body":"```java\r\nclass Solution {\r\n    int curVal = 0;\r\n    int curHeight = 0;\r\n\r\n    public int findBottomLeftValue(TreeNode root) {\r\n        int curHeight = 0;\r\n        dfs(root, 0);\r\n        return curVal;\r\n    }\r\n\r\n    public void dfs(TreeNode root, int height) {\r\n        if (root == null) {\r\n            return;\r\n        }\r\n        height++;\r\n        dfs(root.left, height);\r\n        dfs(root.right, height);\r\n        if (height > curHeight) {\r\n            curHeight = height;\r\n            curVal = root.val;\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200363283","body":"## æ€è·¯\r\nåªè¦ä¿è¯åºåˆ—åŒ–å’Œååºåˆ—åŒ–æ„é€ å‡½æ•°ä¸€æ ·å³å¯ï¼Œè¿™é‡Œä½¿ç”¨æ·±åº¦æœç´¢çš„å…ˆåºéå†çš„æ–¹å¼\r\n## ä»£ç \r\n```java\r\n    // Encodes a tree to a single string.\r\n    public String serialize(TreeNode root) {\r\n        return rserialize(root, \"\");\r\n    }\r\n\r\n    public String rserialize(TreeNode root,String str) {\r\n        if (root == null) {\r\n            str += \"None,\";\r\n        } else {\r\n            str += root.val + \",\";\r\n            str = rserialize(root.left,str);\r\n            str = rserialize(root.right,str);\r\n        }\r\n        return str;\r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    public TreeNode deserialize(String data) {\r\n        String[] strs = data.split(\",\");\r\n        List<String> dataList = new LinkedList<>(Arrays.asList(strs));\r\n        return rDeserialize(dataList);\r\n    }\r\n\r\n    public TreeNode rDeserialize(List<String> dataList) {\r\n        if (dataList.get(0).equals(\"None\")) {\r\n            dataList.remove(0);\r\n            return null;\r\n        }\r\n\r\n        TreeNode node = new TreeNode(Integer.valueOf(dataList.get(0)));\r\n        dataList.remove(0);\r\n        node.left = rDeserialize(dataList);\r\n        node.right = rDeserialize(dataList);\r\n        return node;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200836852","body":"## æ€è·¯\r\næ€è·¯å°±æ˜¯è¿˜æ˜¯dfs å†åŠ ä¸Š TreeMapï¼Œåªæ˜¯æ¯”è¾ƒéº»çƒ¦çš„æ˜¯è¦å¯¹é«˜åº¦çš„è¿›è¡Œåˆ†ææ’åºï¼ˆåŒé«˜çš„ä½ç½®ï¼‰ï¼Œå› æ­¤æ•°æ®æ¨¡å¼å°±æ¯”è¾ƒéº»çƒ¦ï¼Œè€Œä¸”éœ€è¦ä¸¤æ¬¡å¾ªç¯ï¼Œä½†è¿˜å¥½æœ€å¤šåŒä¸€é«˜åº¦æœ‰ä¸¤ä¸ªèŠ‚ç‚¹æ‰€ä»¥é€Ÿåº¦ä¸ä¼šæœ‰å¾ˆå¤§æ•ˆç‡é—®é¢˜\r\n## ä»£ç \r\n```java\r\n    Map<Integer, Map<Integer, List<Integer>>> ans = new TreeMap<>();\r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n        List<List<Integer>> ansList = new ArrayList<>();\r\n        dfs(root, 0, 0);\r\n        for (Map.Entry<Integer, Map<Integer, List<Integer>>> entry : ans.entrySet()) {\r\n            List<Integer> list = new ArrayList<>();\r\n            for (Map.Entry<Integer, List<Integer>> heightEntry : entry.getValue().entrySet()) {\r\n                list.addAll(heightEntry.getValue());\r\n            }\r\n            ansList.add(list);\r\n        }\r\n        return ansList;\r\n    }\r\n\r\n    public void dfs(TreeNode node, int column, int height) {\r\n        if (node == null) {\r\n            return;\r\n        }\r\n        ++height;\r\n        if (ans.containsKey(column)) {\r\n            if (ans.get(column).containsKey(height)) {\r\n                ans.get(column).get(height).add(node.val);\r\n                Collections.sort(ans.get(column).get(height));\r\n            } else {\r\n                List<Integer> list = new ArrayList<>();\r\n                list.add(node.val);\r\n                ans.get(column).put(height, list);\r\n            }\r\n        } else {\r\n            List<Integer> list = new ArrayList<>();\r\n            list.add(node.val);\r\n            Map<Integer, List<Integer>> map = new TreeMap<>();\r\n            map.put(height, list);\r\n            ans.put(column, map);\r\n        }\r\n        dfs(node.left, column - 1, height);\r\n        dfs(node.right, column + 1, height);\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202108699","body":"## æ€è·¯\r\nåŒæŒ‡é’ˆé…åˆHashè¡¨\r\n## ä»£ç \r\n```java\r\n    public int[] twoSum(int[] nums, int target) {\r\n        Map<Integer, Integer> hashMap = new HashMap<>();\r\n        for (int i = 0; i < nums.length; i++) {\r\n            if (hashMap.containsKey(target - nums[i])) {\r\n                return new int[]{hashMap.get(target - nums[i]), i};\r\n            }\r\n            hashMap.put(nums[i], i);\r\n        }\r\n        return new int[0];\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203893639","body":"## æ€è·¯\r\nåƒåœ¾æ€è·¯ï¼ŒåŸºæœ¬å°±æ˜¯å‚¨å­˜æ¯ä¸ªæ•°çš„æ¬¡æ•°ç„¶å value å’Œ key å½¢æˆæ–°çš„hashï¼Œæ ¹æ®è¦æ±‚æ’åº Map è¾“å‡ºå³å¯\r\n## ä»£ç \r\n```java\r\n    HashMap<Integer, Integer> numberAndTimes = new HashMap<>();\r\n    TreeMap<Integer, String> ansHash = new TreeMap<>();\r\n    public int[] topKFrequent(int[] nums, int k) {\r\n        List<Integer> list = new ArrayList<Integer>();\r\n        for (int num : nums) {\r\n            if (!numberAndTimes.containsKey(num)) {\r\n                numberAndTimes.put(num, 1);\r\n            } else {\r\n                numberAndTimes.put(num, numberAndTimes.get(num) + 1);\r\n            }\r\n        }\r\n\r\n        for (Map.Entry<Integer, Integer> entry : numberAndTimes.entrySet()) {\r\n            if (ansHash.containsKey(entry.getValue())) {\r\n                ansHash.put(entry.getValue(), ansHash.get(entry.getValue()) + \",\" + entry.getKey());\r\n            } else {\r\n                ansHash.put(entry.getValue(), String.valueOf(entry.getKey()));\r\n            }\r\n        }\r\n\r\n        for (int i = 0; i < k; i++) {\r\n            if (ansHash.size() != 0) {\r\n                String[] strings = ansHash.pollLastEntry().getValue().split(\",\");\r\n                int[] numsTemp = Arrays.stream(strings).mapToInt(Integer::parseInt).toArray();\r\n                list.addAll(Arrays.stream(numsTemp).boxed().collect(Collectors.toList()));// è½¬List<Integer>\r\n                if (list.size() >= k) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        int[] ans = new int[list.size()];\r\n        for (int i = 0; i < list.size(); i++) {\r\n            ans[i] = list.get(i);\r\n        }\r\n        return ans;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204698092","body":"## æ€è·¯\r\nå…¶å®ä¸»è¦æ˜¯ä¼˜åŒ–æš´åŠ›ç®—æ³•ï¼Œä¼˜åŒ–ç‚¹å°±æ˜¯æ‰¾å‡ºæ¯ä¸ªç‚¹çš„ç›¸åŒè·ç¦»ï¼Œç„¶åæ’åˆ—ç»„åˆå³å¯ï¼Œç›¸å½“äºæ¯ä¸ªç‚¹åšä¸€æ¬¡ä¸­è½´çº¿ï¼Œå…¶å®å°±æ˜¯å‰ªæï¼Œæ’åˆ—ç»„åˆéƒ½å¿«å¿˜å®Œäº†å“­æ³£\r\n## ä»£ç \r\n```java\r\n    public int numberOfBoomerangs(int[][] points) {\r\n        int ans = 0;\r\n        for (int[] p : points) {\r\n            Map<Integer, Integer> ansMap = new HashMap<>();\r\n            for (int[] q : points) {\r\n                int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\r\n                ansMap.put(dis, ansMap.getOrDefault(dis, 0) + 1);\r\n            }\r\n\r\n            for (Map.Entry<Integer, Integer> entry : ansMap.entrySet()) {\r\n                int m = entry.getValue();\r\n                ans += m * (m - 1);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205954224","body":"## æ€è·¯\r\nåŒæŒ‡é’ˆ+æ»‘åŠ¨è§†çª—\r\n## ä»£ç \r\n```java\r\n    // æ»‘åŠ¨çª—å£çš„ç®—æ³• + åŒæŒ‡é’ˆ\r\n    public int lengthOfLongestSubstring(String s) {\r\n        Set<Character> set = new HashSet<>();\r\n        int ans = 0;\r\n        int len = s.length();\r\n        int rightPointer = -1;\r\n        for (int i = 0; i < len; i++) {\r\n            if (i != 0) {\r\n                set.remove(s.charAt(i-1));\r\n            }\r\n            while (rightPointer + 1 < len && !set.contains(s.charAt(rightPointer+1))) {\r\n                set.add(s.charAt(rightPointer+1));\r\n                rightPointer++;\r\n            }\r\n            ans = Math.max(ans,set.size());\r\n        }\r\n        return ans;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207233755","body":"### ä»£ç \r\n```java\r\nclass Solution {\r\n\r\n    public List<Integer> findSubstring(String s, String[] words) {\r\n\r\n        List<Integer> res = new ArrayList<>();\r\n\r\n        Map<String, Integer> map = new HashMap<>();\r\n\r\n        if (words == null || words.length == 0)\r\n            return res;\r\n\r\n        for (String word : words)\r\n            map.put(word, map.getOrDefault(word, 0) + 1);\r\n\r\n        int sLen = s.length(), wordLen = words[0].length(), count = words.length;\r\n\r\n        int match = 0;\r\n\r\n        for (int i = 0; i < sLen - wordLen * count + 1; i++) {\r\n\r\n            //å¾—åˆ°å½“å‰çª—å£å­—ç¬¦ä¸²\r\n            String cur = s.substring(i, i + wordLen * count);\r\n            Map<String, Integer> temp = new HashMap<>();\r\n            int j = 0;\r\n\r\n            for (; j < cur.length(); j += wordLen) {\r\n\r\n                String word = cur.substring(j, j + wordLen);\r\n                // å‰ªæ\r\n                if (!map.containsKey(word))\r\n                    break;\r\n\r\n                temp.put(word, temp.getOrDefault(word, 0) + 1);\r\n                // å‰ªæ\r\n                if (temp.get(word) > map.get(word))\r\n                    break;\r\n            }\r\n\r\n            if (j == cur.length())\r\n                res.add(i);\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207341708","body":" ```java\r\nclass Solution {\r\n    public int minSubarray(int[] nums, int p) {\r\n\r\n        // Find target module\r\n        int target = 0, res = nums.length;\r\n        for (int n : nums)\r\n            target = (target + n) % p;\r\n        // No need to remove any sublist\r\n        if (target == 0) {return 0;}\r\n        \r\n        // Key: prefixSumModP, Value: position index\r\n        Map<Integer, Integer> pos = new HashMap<>();\r\n        pos.put(0, -1);\r\n        \r\n        int curMod = 0;\r\n        for (int i = 0; i < nums.length; ++i) {\r\n            curMod = (curMod + nums[i]) % p;\r\n            // Comp Equation!\r\n            int comp = (p - target + curMod) % p;\r\n            if (pos.containsKey(comp))\r\n                res = Math.min(res, i - pos.get(comp));\r\n            pos.put(curMod, i);\r\n        }    \r\n        return res >= nums.length ? -1 : res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207578278","body":"### æ€è·¯\r\nåªè¦çœ‹è¿‡è®²ä¹‰å°±å¾ˆç®€å•äº†ï¼Œå¿«æ…¢æŒ‡é’ˆæ ¹æ®å³å¯è§£å†³é—®é¢˜\r\n### ä»£ç \r\n```java\r\n    public static ListNode middleNode(ListNode head) {\r\n        ListNode curNode = head;\r\n        ListNode ans = head;\r\n        while (curNode != null && curNode.next != null) {\r\n            curNode = curNode.next.next;\r\n            ans = ans.next;\r\n        }\r\n        return ans;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208834038","body":"## æ€è·¯\r\nå¿«æ…¢æŒ‡é’ˆå³å¯\r\n## ä»£ç \r\n```java\r\n    public int removeDuplicates(int[] nums) {\r\n        int n = nums.length;\r\n        if (n == 0) {\r\n            return 0;\r\n        }\r\n        int fast = 1, slow = 1;\r\n        while (fast < n) {\r\n            if (nums[fast] != nums[fast - 1]) {\r\n                nums[slow] = nums[fast];\r\n                ++slow;\r\n            }\r\n            ++fast;\r\n        }\r\n        return slow;\r\n    }\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miluowzt":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185236293","body":"# **æ€è·¯**\r\nä»åå¾€å‰éå†æ•°ç»„ï¼ŒæŒ‰ä½ä¸kç›¸åŠ ï¼Œé‡10è¿›1ï¼ˆç»“æœå¤§äº10æ—¶ï¼Œè¿›ä½æ•°1åŠ åˆ°ä¸‹ä¸€ä½è¿›è¡Œè®¡ç®—ï¼‰ï¼Œè€ƒè™‘ç»“æœå¦‚æœå­˜å‚¨LinkedListçš„addFirstæˆ–è€…ArraryListæœ€åç¿»è½¬ã€‚\r\n\r\n# **ä»£ç **\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n\r\n        LinkedList<Integer> numList = new LinkedList<Integer>();\r\n        int index = num.length-1;\r\n        while (index>=0||k!=0){\r\n            if(index>=0){\r\n                k=num[index]+k;\r\n                index--;\r\n            }\r\n            numList.addFirst(k%10);\r\n            k=k/10;\r\n        }  \r\n        return numList;\r\n    }\r\n}\r\n\r\n# **å¤æ‚åº¦åˆ†æ**\r\næ—¶é—´å¤æ‚åº¦ï¼šO(n)  \r\nwhile å¾ªç¯è¿è¡Œnæ¬¡ï¼Œnä¸ºæ•°ç»„é•¿åº¦\r\nç©ºé—´å¤æ‚åº¦ï¼šO(n)  \r\nåˆ›å»ºçš„ä¸€ä¸ªç©ºåˆ—è¡¨ï¼Œè¿™ä¸ªåˆ—è¡¨å ç”¨çš„å†…å­˜éšç€while å¾ªç¯çš„å¢åŠ è€Œå¢åŠ ï¼Œæœ€å¤§åˆ° n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186223012","body":"# *æ€è·¯*\nä»å·¦å¾€å³éå†ä¸€æ¬¡ï¼Œå†ä»å³å¾€å·¦éå†ä¸€æ¬¡ï¼Œå–æœ€å°å€¼ã€‚\néœ€è¦æƒ³åˆ°çš„ç‚¹æ˜¯å¼€å§‹charAtä½ç½®æ²¡æœ‰æ•°å€¼æ—¶ï¼Œç”¨ä¸€ä¸ªå‡å®šçš„å€¼æ¥è¡¨ç¤ºã€‚\næœ€å¼€å§‹æŒ‰ç…§è‡ªå·±çš„æƒ³æ³•å†™äº†ä¸€ä¸ªå¾ˆå¤æ‚çš„ï¼Œè™½ç„¶æ‰§è¡Œäº†ä½†æ˜¯æ—¶é—´å¤æ‚åº¦æ˜¯næ–¹ã€‚\n# *ä»£ç *\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int length=s.length();\n        int [] arr= new int[length];\n        for(int i=0,index=-length;i<length;++i){\n            if(s.charAt(i)==c){\n                index=i;\n            }\n            arr[i]=i-index;\n        }\n        for(int i=length-1,index=2*length;i>=0;--i){\n            if(s.charAt(i)==c){\n                index=i;\n            }\n            arr[i]=Math.min(arr[i],index-i);\n        }\n        return arr;\n    }\n}\n# *å¤æ‚åº¦*\næ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œå…¶ä¸­n æ˜¯å­—ç¬¦ä¸² s çš„é•¿åº¦ã€‚\nç©ºé—´å¤æ‚åº¦ï¼šO(1)ã€‚è¿”å›å€¼ä¸è®¡ç®—æˆç©ºé—´å¤æ‚åº¦ã€‚","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186552049","body":"# *æ€è·¯*\r\nç”¨æ•°ç»„è¿›è¡Œå®ç°\r\n# *ä»£ç *\r\nclass CustomStack {\r\n    int [] stack;\r\n    int top;\r\n    public CustomStack(int maxSize) {\r\n        stack=new int[maxSize];\r\n        top=-1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n       if(top !=stack.length-1){\r\n            ++top;\r\n            stack[top]=x;\r\n        }\r\n    }\r\n    \r\n\r\n  public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top + 1];\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int length = Math.min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1189732029","body":"# *æ€è·¯*\r\nè¡¥å¡ï¼Œè¿™é“é¢˜ä¸€ç›´æ²¡å¤ªæƒ³æ¸…æ¥šï¼Œå‚è€ƒå®˜æ–¹ç­”æ¡ˆï¼Œç†è§£åé‡å†™\r\næ•°å­—çš„é—®é¢˜ï¼Œå‰æœŸå¿½ç•¥äº†å¤šä½æ•°çš„æƒ…å†µï¼Œå¯¼è‡´æŠ¥é”™\r\n\r\n# *ä»£ç *\r\n class Solution{\r\n\r\n        String src;\r\n        int ptr;\r\n       //int repTime ;\r\n\r\n        public String decodeString(String s) {\r\n            src = s;\r\n            ptr = 0;\r\n            return getdecodeStr();\r\n        }\r\n        public String getdecodeStr() {\r\n            //åœ¨æœ€åä¸€ä½çš„æ—¶å€™ï¼Œptr=9ï¼Œå¦‚æœcharAtåœ¨å‰è¾¹æ±‡æŠ¥é”™\r\n            if(ptr== src.length()||src.charAt(ptr)==']'){\r\n                return \"\";\r\n            }\r\n            char cur = src.charAt(ptr);\r\n            String ret = \"\";\r\n            int repTime = 0;\r\n\r\n            if(Character.isDigit(cur)){\r\n                //æ‹¿å‡ºæ•°å­—ä¹‹åï¼Œå¾€åç§»ä½ï¼ˆè€ƒè™‘å¤šä½æ•°é—®é¢˜ï¼Œä¸€å®šè¦ç¡®ä¿æ•°å­—éƒ½æ‹¿å®Œï¼‰\r\n                while (Character.isDigit(src.charAt(ptr))) {\r\n                    repTime = repTime * 10 + src.charAt(ptr++) - '0';\r\n                }\r\n                //è¿‡æ»¤æ‰æ•°å­—åè¾¹çš„[\r\n                ++ptr;\r\n                String str = getdecodeStr();\r\n\r\n                //æ‹¿å®Œå­—æ¯ååç§»åˆ°]\r\n                ++ptr;\r\n                while(repTime-->0){\r\n                    ret+=str;\r\n                }\r\n            }else {\r\n                ret=String.valueOf(cur);\r\n                ++ptr;\r\n            }\r\n            return ret+getdecodeStr();\r\n\r\n\r\n        }\r\n    }\r\n\r\n# *å¤æ‚åº¦* \r\næ—¶é—´å¤æ‚åº¦ O(n)\r\nç©ºé—´å¤æ‚åº¦ O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1190081044","body":"# *æ€è·¯*\næ ˆå…ˆè¿›åå‡ºï¼Œé˜Ÿåˆ—å…ˆè¿›å…ˆå‡ºï¼Œåˆ©ç”¨ä¸¤ä¸ªæ ˆæŠŠæ ˆ1çš„æ•°æ®å¯¼å…¥æ ˆ2ï¼Œå†å€’å›å»ã€‚\n\n# *ä»£ç *\nclass MyQueue {\n        \n        Stack<Integer> stack_1;\n        Stack<Integer> stack_2;\n        \n    public MyQueue() {\n        stack_1=new Stack();\n        stack_2=new Stack();\n    }\n    \n    public void push(int x) {\n        while (!stack_1.isEmpty()){\n            stack_2.push(stack_1.pop());\n        }\n        stack_2.push(x);\n        while (!stack_2.isEmpty()){\n            stack_1.push(stack_2.pop());\n        }\n\n    }\n    \n    public int pop() {\n        return stack_1.pop();\n    }\n    \n    public int peek() {\n        return stack_1.peek();\n    }\n    \n    public boolean empty() {\n        return stack_1.isEmpty();\n    }\n}\n#*å¤æ‚åº¦*\n","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191166439","body":"# *æ€è·¯*\næ‹¼æ¥æˆä¸€ä¸ªæ—‹è½¬é“¾è¡¨ï¼Œå¤´å°¾ç›¸æ¥ã€‚\næ‹¼æ¥æˆåŠŸåï¼Œå³ç§»ä½kä½ï¼ˆåŸç»™å®šçš„é“¾è¡¨é•¿åº¦ä¸ºnï¼‰ï¼Œå®é™…ä¸Šä¸ºåŸé“¾è¡¨ä»åå¾€å‰ç¬¬n-kä¸ªä½ç½®çš„nextä¸ºnull\n\n# *ä»£ç *\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null||k==0||head.next==null){\n            return head;\n        }\n        ListNode now =head;\n        int count=1;\n        while(!(now.next==null)){\n            now=now.next;\n            count++;\n        }\n        if (count==k||k%count==0){\n            return head;\n        }\n        now.next=head;\n        int n=count-k%count;\n        while (n-->0){\n            now=now.next;\n        }\n        head=now.next;\n        now.next=null;\n        return head;\n\n    }\n}\n# *å¤æ‚åº¦*\næ—¶é—´å¤æ‚åº¦ï¼šO(n)\nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195253681","body":"``` java\nclass LRUCache {\n    private Map<Integer, LRUNode> cache = new HashMap<>();\n    private int count;\n    private int capacity;\n    private LRUNode head, tail;\n\n    public LRUCache(int capacity) {\n        this.count = 0;\n        this.capacity = capacity;\n\n        this.head = new LRUNode();\n        this.tail = new LRUNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    public int get(int key) {\n        LRUNode node = cache.get(key);\n        if (node != null) {\n        \t// èŠ‚ç‚¹å­˜åœ¨ï¼Œæœ€è¿‘ä½¿ç”¨ï¼Œå°†èŠ‚ç‚¹æ”¾åˆ°é¡¶éƒ¨\n            this.moveToHead(node);\n            return node.value;\n        }\n        return -1;\n    }\n    \n    public void put(int key, int value) {\n        LRUNode node = cache.get(key);\n        if (node != null) {\n        \t// èŠ‚ç‚¹å­˜åœ¨ï¼Œæœ€è¿‘ä½¿ç”¨ï¼Œå°†èŠ‚ç‚¹æ”¾åˆ°é¡¶éƒ¨\n            node.value = value;\n            this.moveToHead(node);\n        } else {\n        \t// èŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œæ–°å¢ä¸€ä¸ªèŠ‚ç‚¹åˆ°é¡¶éƒ¨\n            LRUNode newNode = new LRUNode(key, value);\n            this.cache.put(key, newNode);\n            this.addNode(newNode);\n            ++this.count;\n            \n            if (this.count > this.capacity) {\n            \t// å¦‚æœè¶…è¿‡å®¹é‡ï¼Œåˆ é™¤åº•éƒ¨èŠ‚ç‚¹\n                LRUNode tail = this.removeTail();\n                this.cache.remove(tail.key);\n                --this.count;\n            }\n        }\n    }\n\n    private void moveToHead(LRUNode node) {\n        this.removeNode(node);\n        this.addNode(node);\n    }\n\n    private void addNode(LRUNode node) {\n        node.prev = head;\n        node.next = head.next;\n\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(LRUNode node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private LRUNode removeTail() {\n        LRUNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n\n    private class LRUNode {\n        int key;\n        int value;\n        LRUNode prev;\n        LRUNode next;\n\n        LRUNode() {}\n\n        LRUNode(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n}\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202186101","body":"# æ€è·¯\r\nhashmapå­˜æ•°æ®å’Œä½ç½®ï¼Œç®—å‡ºtarget-å½“å‰å€¼ä½œä¸ºç›®æ ‡å€¼ï¼Œæ¯æ¬¡æŸ¥è¯¢ç›®æ ‡å€¼ï¼ŒæŸ¥è¯¢åˆ°è¿”å›ï¼ŒæŸ¥ä¸åˆ°å½“å‰ä½ç½®å’Œæ•°å€¼æ·»åŠ åˆ°hashmapä¸­\r\n# ä»£ç \r\n```java\r\n    class Solution {\r\n        public int[] twoSum(int[] nums, int target) {\r\n            HashMap<Integer, Integer> nums_map = new HashMap<>();\r\n            int length=nums.length;\r\n            int ans=0;\r\n            int[] ans_nums= new int[2];\r\n            for (int i = 0; i < length; i++) {\r\n                ans=target-nums[i];\r\n                if(nums_map.containsKey(ans)){\r\n                    ans_nums[0]=i;\r\n                    ans_nums[1]=nums_map.get(ans);\r\n                    return ans_nums;\r\n                }else {\r\n                    nums_map.put(nums[i],i);\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n    }\r\n```\r\n# å¤æ‚åº¦\r\næ—¶é—´å’Œç©ºé—´ï¼šO(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maylinglin":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185236729","body":"## æ€è·¯\n\n---\n\næŠŠnumä»listè½¬åŒ–æˆstrï¼Œå†è½¬åŒ–æˆintä¸kç›¸åŠ ï¼Œæœ€åè¿”å›listå½¢å¼ã€‚\n\n## ä»£ç \n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        x = ''.join(map(str, num))\n        sum = int(x) + k\n        return list(map(int, str(sum)))   # [int(i) for i in str(sum)]\n```\n\n## å¤æ‚åº¦\n\n---\n\n- ****Time:**** O(N)\n- ****Space:**** O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186194435","body":"## æ€è·¯\n\n\né¦–å…ˆä»å·¦å¾€å³éå†æ±‚è·ç¦»ï¼Œå†ä»å³å¾€å·¦éå†æ±‚è·ç¦»ï¼Œè®¡ç®—ä¸¤è¾¹è·ç¦»çš„æœ€å°å€¼ã€‚\n\n## ä»£ç \n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        ans = [n for i in range(n)]\n        dist = n\n        for i in range(n):\n            if s[i] == c:\n                dist = 0\n            else:\n                dist += 1 \n            ans[i] = dist\n        for j in range(n-1, -1, -1):\n            if s[j] == c:\n                dist = 0\n            else:\n                dist += 1\n            ans[j] = min(dist, ans[j])\n        return ans\n```\n\n## å¤æ‚åº¦\n\n\n- ****Time:**** O(N)\n- **Space:** O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186533825","body":"## æ€è·¯\n\n\nç”¨æ•°ç»„æ¨¡æ‹Ÿæ ˆæ“ä½œ\n\n## ä»£ç \n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.maxSize = maxSize\n        self.size = 0\n\n    def push(self, x: int) -> None:\n        if self.size < self.maxSize:\n            self.stack.append(x)\n            self.size += 1\n\n    def pop(self) -> int:\n        if self.size == 0:\n            return -1\n        else:\n            self.size -= 1\n            return self.stack.pop()\n            \n    def increment(self, k: int, val: int) -> None:\n        for i in range(0, min(k, self.size)):\n            self.stack[i] += val\n```\n\n## å¤æ‚åº¦\n\n\n- **Time:** push: O(1)ï¼Œ pop: O(1)ï¼Œ increment: O(N)\n- **Space:** O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187514265","body":"## æ€è·¯\n\n\nåŒæ ˆï¼Œä¸€ä¸ªæ ˆå­˜æ”¾æ•°å­—ï¼Œä¸€ä¸ªæ ˆå­˜æ”¾å­—æ¯\n\n## ä»£ç \n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == \"]\":\n                tmpstr = \"\"\n                numstr = \"\"\n                while stack and stack[-1] != \"[\":\n                    char = stack.pop()\n                    tmpstr = char + tmpstr\n                stack.pop()\n                while stack and stack[-1].isdigit():\n                    num = stack.pop()\n                    numstr = num + numstr\n                stack.append(int(numstr) * tmpstr)\n            else:\n                stack.append(c)\n        return \"\".join(stack)\n```\n\n## å¤æ‚åº¦\n\n\n- ****Time:**** O(N)\n- **Space:** O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189081575","body":"## æ€è·¯\n\n\nä½¿ç”¨ä¸¤ä¸ªæ ˆå®ç°é˜Ÿåˆ—\n\n## ä»£ç \n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        self.stack1.append(x)\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n\n    def pop(self) -> int:\n        return self.stack1.pop()\n\n    def peek(self) -> int:\n        return self.stack1[-1]\n\n    def empty(self) -> bool:\n        if self.stack1:\n            return False\n        else:\n            return True\n```\n\n## å¤æ‚åº¦\n\n\n- ****Time: push:**** O(N) ****pop:**** O(1) ****peek:**** O(1)  ****empty:**** O(1)\n- **Space:** O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190017798","body":"## æ€è·¯\n\n\nä»å·¦å‘å³éå†æ•°ç»„ï¼Œä¸‹ä¸€åˆ†å—çš„æœ€å°å€¼åº”è¯¥å¤§äºä¸Šä¸€åˆ†å—çš„æœ€å¤§å€¼ï¼Œæ¯ä¸€åˆ†å—ç”¨å—ä¸­æœ€å¤§å€¼è¡¨ç¤º\n\n## ä»£ç \n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        n = len(arr)\n        for i in range(n):\n            m = arr[i]\n            while stack and stack[-1] > arr[i]:\n                m = max(stack.pop(), m)\n            stack.append(m)\n        return len(stack)\n```\n\n## å¤æ‚åº¦\n\n\n- ****Time:**** O(N)\n- **Space:** O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191534373","body":"## æ€è·¯\n\n\nè¿æ¥é¦–å°¾å½¢æˆç¯å½¢é“¾è¡¨ï¼Œæ ¹æ®ç§»åŠ¨çš„è·ç¦»æ–­å¼€é“¾è¡¨\n\n## ä»£ç \n\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if k == 0 or not head or not head.next:\n            return head\n        \n        n = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            n += 1\n        \n        if (add := n - k % n) == n:\n            return head\n        \n        cur.next = head\n        while add:\n            cur = cur.next\n            add -= 1\n        \n        ret = cur.next\n        cur.next = None\n        return ret\n```\n\n## å¤æ‚åº¦\n\n\n- ****Time:**** O(N)\n- **Space:** O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192375799","body":"## æ€è·¯\n\n\nè¿­ä»£çš„æ–¹æ³•ï¼Œç”±preA -> A -> B ->BNext ä¿®æ”¹ä¸º preA ->B ->A ->nextBï¼Œäº¤æ¢ä¸¤ä¸ªèŠ‚ç‚¹ä½ç½®ï¼Œç»è¿‡3æ¬¡æ“ä½œA.next = next.B; B.next = A; preA.next = B. \n\n## ä»£ç \n\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next: \n            return head\n        ans = ListNode()\n        ans.next = head.next\n        pre = ans\n        while head and head.next:\n            next = head.next\n            n_next = next.next\n\n            next.next = head\n            pre.next = next\n            head.next = n_next\n  \n            pre = head\n            head = n_next\n        return ans.next\n```\n\n## å¤æ‚åº¦\n\n\n- ****Time:**** O(N)\n- **Space:** O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193109606","body":"## æ€è·¯\n\nä½¿ç”¨å¿«æ…¢æŒ‡é’ˆæ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼Œä¸­ç‚¹å·¦è¾¹çš„å€¼æ„é€ å·¦å­æ ‘ï¼Œå³è¾¹çš„å€¼æ„é€ å³å­æ ‘ï¼›é€’å½’é“¾è¡¨ç”ŸæˆäºŒå‰æ ‘ã€‚\n\n## ä»£ç \n\n```python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        return self.sort(head, None)\n\n    def sort(self, head, tail):\n        if head == tail:\n            return\n        slow = head\n        fast = head\n        while fast != tail and fast.next != tail:\n            slow = slow.next\n            fast = fast.next.next\n        root = TreeNode(slow.val)\n        root.left = self.sort(head, slow)\n        root.right = self.sort(slow.next, tail)\n        return root\n```\n\n## å¤æ‚åº¦\n\n\n- ****Time:**** O(nlogn)\n- **Space:** O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193289628","body":"## æ€è·¯\n\n\nä¸¤ä¸ªæŒ‡é’ˆåŒæ—¶éå†ï¼Œaåˆ°å°¾éƒ¨åä»bå¤´éƒ¨å¼€å§‹éå†ï¼Œbåˆ°å°¾éƒ¨åä»aå¤´éƒ¨å¼€å§‹éå†ï¼Œaå’Œbç›¸é‡æ—¶å³ä¸ºèŠ‚ç‚¹ã€‚\n\n## ä»£ç \n\n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        a = headA\n        b = headB\n        while a != b:\n            a = a.next\n            b = b.next\n            if not a and not b:\n                return None\n            elif not a:\n                a = headB\n            elif not b:\n                b = headA\n        return a\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n\n- æ—¶é—´å¤æ‚åº¦ï¼š*O(N)*\n- ç©ºé—´å¤æ‚åº¦ï¼š*O(1)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194156845","body":"## æ€è·¯\n\nå¿«æ…¢ä¸¤ä¸ªæŒ‡é’ˆï¼Œä»headç»“ç‚¹èµ°åˆ°å…¥ç¯ç‚¹éœ€è¦èµ°a + nbï¼Œ è€Œslowå·²ç»èµ°äº†nbï¼Œé‚£ä¹ˆslowå†èµ°aæ­¥å³ä¸ºå…¥ç¯ç‚¹ã€‚\n\n## ä»£ç \n\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        fast, slow = head, head\n        while True:\n            if not (fast and fast.next): return\n            fast, slow = fast.next.next, slow.next\n            if fast == slow: break\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast\n\n```\n\n## å¤æ‚åº¦\n\n\n- ****Time:**** O(N)\n- **Space:** O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195543076","body":"## æ€è·¯\n\n\nå“ˆå¸Œè¡¨åŠ åŒå‘é“¾è¡¨\n\n## ä»£ç \n\n```python\nclass ListNode:\n    def __init__(self, key=None, value=None):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.hashmap = {}\n        self.head = ListNode()\n        self.tail = ListNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def move_node_to_tail(self, key):\n            node = self.hashmap[key]\n            node.prev.next = node.next\n            node.next.prev = node.prev\n            node.prev = self.tail.prev\n            node.next = self.tail\n            self.tail.prev.next = node\n            self.tail.prev = node\n\n    def get(self, key: int) -> int:\n        if key in self.hashmap:\n            self.move_node_to_tail(key)\n        res = self.hashmap.get(key, -1)\n        if res == -1:\n            return res\n        else:\n            return res.value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.hashmap:\n            self.hashmap[key].value = value\n            self.move_node_to_tail(key)\n        else:\n            if len(self.hashmap) == self.capacity:\n                self.hashmap.pop(self.head.next.key)\n                self.head.next = self.head.next.next\n                self.head.next.prev = self.head\n            new = ListNode(key, value)\n            self.hashmap[key] = new\n            new.prev = self.tail.prev\n            new.next = self.tail\n            self.tail.prev.next = new\n            self.tail.prev = new\n\n```\n\n## å¤æ‚åº¦\n\n\n- ****Time:**** O(N)\n- **Space:** O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196822419","body":"## æ€è·¯\n\n\nDFSï¼›é€’å½’å¾ˆå¥½ç”¨\n\n## ä»£ç \n\n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        ans = 0\n        stack = [(root, 1)]\n        while stack:\n            p, depth = stack.pop()\n            ans = max(ans, depth)\n            if p.left:\n                stack.append((p.left, depth + 1))\n            if p.right:\n                stack.append((p.right, depth + 1))\n        return ans\n\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        return 1 + max(self.maxDepth(root.left),self.maxDepth(root.right))\n```\n\n## å¤æ‚åº¦\n\n\n- ****Time:**** O(N)ï¼Œ\n- **Space:** O(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198232815","body":"## æ€è·¯\n\n\næ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œé€’å½’çš„åˆ¤æ–­æ˜¯å¦ç›¸åŒ\n\n## ä»£ç \n\n```python\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n\n## å¤æ‚åº¦\n\n\n- ****Time:**** O(min(m,n)), må’Œnåˆ†åˆ«ä¸ºä¸¤ä¸ªäºŒå‰æ ‘çš„èŠ‚ç‚¹æ•°\n- **Space:** O(min(m,n)), må’Œnåˆ†åˆ«ä¸ºä¸¤ä¸ªäºŒå‰æ ‘çš„èŠ‚ç‚¹æ•°","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199200401","body":"## æ€è·¯\n\n\næ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œéå†æ¯ä¸ªèŠ‚ç‚¹ï¼Œç„¶åå¯¹å­èŠ‚ç‚¹è¿›è¡Œé€’å½’\n\n## ä»£ç \n\n```python\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        def dfs(root, prevTotal):\n            if not root:\n                return 0\n            total = prevTotal * 10 + root.val\n            if not root.left and not root.right:\n                return total\n            else:\n                return dfs(root.left, total) + dfs(root.right, total)\n        \n        return dfs(root, 0)\n```\n\n## å¤æ‚åº¦\n\n\n- ****Time:**** O(n), næ˜¯äºŒå‰æ ‘èŠ‚ç‚¹ä¸ªæ•°\n- **Space:** O(n), næ˜¯äºŒå‰æ ‘èŠ‚ç‚¹ä¸ªæ•°","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200143036","body":"## æ€è·¯\n\n\nå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼Œéå†æœ€å·¦è¾¹æ¯ä¸ªèŠ‚ç‚¹ï¼Œæ‰¾åˆ°å·¦æ ‘æœ€åä¸€ä¸ªèŠ‚ç‚¹\n\n## ä»£ç \n\n```python\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        queue = deque([root])\n        while queue:\n            length = len(queue)\n            res = queue[0].val\n            for _ in range(length):\n                cur = queue.popleft()\n                if cur.left:\n                    queue.append(cur.left)\n                if cur.right:\n                    queue.append(cur.right)\n        return res\n```\n\n## å¤æ‚åº¦\n\n\n- ****Time:**** O(n), næ˜¯äºŒå‰æ ‘èŠ‚ç‚¹ä¸ªæ•°\n- **Space:** O(h), hæ˜¯é˜Ÿåˆ—é•¿åº¦","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200437491","body":"## æ€è·¯\n\n\nDFSå‰åºéå†\n\n## ä»£ç \n\n```python\nclass Codec:\n    def serialize(self, root):\n        def preorder(root):\n            if not root:\n                return \"null,\"\n            return str(root.val) + \",\" + preorder(root.left) + preorder(root.right)\n\n        return preorder(root)[:-1]\n\n    def deserialize(self, data: str):\n        nodes = data.split(\",\")\n\n        def preorder(i):\n            if i >= len(nodes) or nodes[i] == \"null\":\n                return i, None\n            root = TreeNode(nodes[i])\n            j, root.left = preorder(i + 1)\n            k, root.right = preorder(j + 1)\n            return k, root\n\n        return preorder(0)[1]\n```\n\n## å¤æ‚åº¦\n\n\n- ****Time:**** O(N), Næ˜¯äºŒå‰æ ‘èŠ‚ç‚¹ä¸ªæ•°\n- **Space:** O(h), hæ˜¯æ ‘çš„é«˜åº¦","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201290876","body":"## æ€è·¯\n\n\nä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œå¯¹æ•´æ£µæ ‘è¿›è¡Œä¸€æ¬¡éå†ï¼Œåœ¨éå†çš„è¿‡ç¨‹ä¸­ä½¿ç”¨æ•°ç»„è®°å½•ä¸‹æ¯ä¸ªèŠ‚ç‚¹çš„è¡Œå·åˆ—å·ä»¥åŠå€¼ã€‚åœ¨éå†å®Œæˆåï¼Œå¯¹æ‰€æœ‰çš„èŠ‚ç‚¹è¿›è¡Œæ’åºã€‚\n\n## ä»£ç \n\n```python\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        nodes = list()\n\n        def dfs(node: TreeNode, row: int, col: int) -> None:\n            if not node:\n                return\n\n            nodes.append((col, row, node.val))\n            dfs(node.left, row + 1, col - 1)\n            dfs(node.right, row + 1, col + 1)\n\n        dfs(root, 0, 0)\n        nodes.sort()\n        ans, lastcol = list(), float(\"-inf\")\n\n        for col, row, value in nodes:\n            if col != lastcol:\n                lastcol = col\n                ans.append(list())\n            ans[-1].append(value)\n        \n        return ans\n```\n\n## å¤æ‚åº¦\n\n\n- ****Time:**** O(nlogn), næ˜¯æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°\n- **Space:** O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1204048757","body":"## æ€è·¯\r\n\r\n---\r\n\r\néå†ä¸€éæ•°ç»„çš„è¿‡ç¨‹ä¸­ä½¿ç”¨å“ˆå¸Œè¡¨å°†å·²ç»è§è¿‡çš„æ•°å’Œå…¶ä¸‹æ ‡å¯¹åº”èµ·æ¥ï¼Œå½“æ‰¾åˆ°å’Œä¸ºtargetçš„å¦ä¸€ä¸ªæ•°å·²ç»åœ¨è¡¨ä¸­æ—¶è¿”å›ç»“æœã€‚\r\n\r\n## ä»£ç \r\n\r\n---\r\n\r\n```python\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        d = {}\r\n        for idx, num in enumerate(nums):\r\n            if num in d:\r\n                return [idx, d[num]]\r\n            else:\r\n                d[target - num] = idx\r\n```\r\n\r\n\r\n## å¤æ‚åº¦åˆ†æ\r\n\r\n---\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š*O(N)*\r\n- ç©ºé—´å¤æ‚åº¦ï¼š*O(N)*","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1206527722","body":"```python\r\nclassÂ Solution:\r\nÂ Â Â Â defÂ topKFrequent(self,Â nums:Â List[int],Â k:Â int)Â ->Â List[int]:\r\nÂ Â Â Â Â Â Â Â countÂ =Â list(collections.Counter(nums).items())\r\nÂ Â Â Â Â Â Â Â countÂ =Â list(map(lambdaÂ x:Â (-x[1],Â x[0]),Â count))\r\nÂ Â Â Â Â Â Â Â heapq.heapify(count)\r\nÂ Â Â Â Â Â Â Â resÂ =Â []\r\nÂ Â Â Â Â Â Â Â forÂ _Â inÂ range(k):\r\nÂ Â Â Â Â Â Â Â Â Â Â Â res.append(heapq.heappop(count)[1])\r\nÂ Â Â Â Â Â Â Â returnÂ res\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205231620","body":"## æ€è·¯\r\n\r\n\r\næšä¸¾æ¯ä¸ªè·ç¦»ç›¸ç­‰çš„ç‚¹ï¼Œä»å…¶ä¸­é€‰å‡ºä¸¤ä¸ªç«¯ç‚¹ã€‚è€ƒè™‘é¡ºåºï¼Œå°†æ¯ä¸ªç‚¹ä½œä¸ºåŸç‚¹éå†ä¹‹åç´¯åŠ ã€‚\r\n\r\n## ä»£ç \r\n\r\n```python\r\nclass Solution:\r\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\r\n        ans = 0\r\n        for p in points:\r\n\t    cnt = defaultdict(int)\r\n\t    for q in points:\r\n                dis = (p[0]-q[0]) * (p[0]-q[0]) + (p[1]-q[1]) * (p[1]-q[1])\r\n\t        cnt[dis] += 1\r\n            for m in cnt.values():\r\n\t        ns += m * (m-1)\r\n\treturn ans\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n\r\n- ****Time:**** O(n^2)ï¼Œnä¸ºæ•°ç»„é•¿åº¦\r\n- **Space:** O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206521193","body":"## æ€è·¯\r\n\r\n\r\nåˆ¤æ–­å…ƒç´ æ˜¯å¦åœ¨æ»‘åŠ¨çª—å£å†…\r\n\r\n## ä»£ç \r\n\r\n```python\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        a = []\r\n        res = 0\r\n        for i in s:\r\n            if i in a:\r\n                a = a[a.index(i) + 1:]\r\n            a.append(i)\r\n            res = max(res, len(a))\r\n        return res\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n\r\n- ****Time:**** O(N)\r\n- **Space:** O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207422600","body":"```python\r\nclassÂ Solution:\r\nÂ Â Â Â defÂ findSubstring(self,Â s:Â str,Â words:Â List[str])Â ->Â List[int]:\r\nÂ Â Â Â Â Â Â Â ansÂ =Â []\r\nÂ Â Â Â Â Â Â Â countÂ =Â collections.Counter(words)\r\nÂ Â Â Â Â Â Â Â nÂ =Â len(words)\r\nÂ Â Â Â Â Â Â Â mÂ =Â len(words[0])\r\nÂ Â Â Â Â Â Â Â forÂ iÂ inÂ range(0,Â len(s)Â -Â m*nÂ +Â 1):\r\nÂ Â Â Â Â Â Â Â Â Â Â Â dÂ =Â count.copy()\r\nÂ Â Â Â Â Â Â Â Â Â Â Â forÂ jÂ inÂ range(i,Â iÂ +Â mÂ *Â n,Â m):\r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â tmpÂ =Â s[j:Â jÂ +Â m]Â Â Â Â Â \r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â flagÂ =Â TrueÂ Â Â Â Â Â Â Â Â Â Â Â Â Â \r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ tmpÂ notÂ inÂ wordsÂ orÂ d[tmp]Â ==Â 0:\r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â flagÂ =Â False\r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â break\r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â else:\r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â d[tmp]Â -=Â 1\r\nÂ Â Â Â Â Â Â Â Â Â Â Â ifÂ flag:\r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ans.append(i)\r\nÂ Â Â Â Â Â Â Â returnÂ ans\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207421424","body":"```python\r\nclass Solution:\r\n    def solve(self, nums, k):\r\n        total = sum(nums)\r\n        mod = total % k\r\n\r\n        ans = len(nums)\r\n        total = 0\r\n        dic = {0: -1}\r\n        for j in range(len(nums)):\r\n            total += nums[j]\r\n            cur = total % k\r\n            target = (cur - mod + k) % k\r\n            if target in dic:\r\n                ans = min(ans, j - dic[target])\r\n            dic[cur] = j\r\n\r\n        if ans == len(nums):\r\n            return -1\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208136540","body":"## æ€è·¯\r\n\r\n\r\nä½¿ç”¨å¿«æ…¢æŒ‡é’ˆï¼Œå½“å¿«æŒ‡é’ˆèµ°åˆ°é“¾è¡¨å°¾éƒ¨ï¼Œæ…¢æŒ‡é’ˆåˆšå¥½èµ°åˆ°ä¸­é—´\r\n\r\n## ä»£ç \r\n\r\n```python\r\nclass Solution:\r\n    def middleNode(self, head: ListNode) -> ListNode:\r\n        if head is None:\r\n            return None\r\n        slow = fast = head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        return slow\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n\r\n- ****Time:**** O(n)ï¼Œnä¸ºé“¾è¡¨é•¿åº¦\r\n- **Space:** O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209365847","body":"## æ€è·¯\r\n\r\n---\r\n\r\nä½¿ç”¨åŒæŒ‡é’ˆï¼Œå¿«æŒ‡é’ˆéå†æ¯ä¸ªä½ç½®ï¼Œå½“å…ƒç´ ä¸åŒæ—¶ï¼Œå°†æ­¤å€¼èµ‹ç»™æ…¢æŒ‡é’ˆä½ç½®\r\n\r\n## ä»£ç \r\n\r\n```python\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        if not nums:\r\n            return 0\r\n        fast = slow = 1\r\n        while fast < len(nums):\r\n            if nums[fast] != nums[fast - 1]:\r\n                nums[slow] = nums[fast]\r\n                slow += 1\r\n            fast += 1\r\n        return slow\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n\r\n- ****Time:**** O(n)ï¼Œnä¸ºæ•°ç»„é•¿åº¦\r\n- **Space:** O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weijie-he":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185238518","body":"### æ•´ä½“æ€è·¯\n\næ¨¡æ‹ŸçœŸæ­£çš„åŠ æ³•è®¡ç®—è¿‡ç¨‹\nä»åå¾€å‰ä¾æ¬¡é€ä½ç›¸åŠ ï¼Œå¦‚æœ >=10 åˆ™è¿›ä½\næ¯æ¬¡åŠ åœ¨ list æœ«å°¾ï¼Œå†å°† list åè½¬\n\n### ä»£ç \n\n```java\n    private  List<Integer> leetcodeSolution(int[] num, int k) {\n        List<Integer> result = new ArrayList<>();\n        int len = num.length;\n        for (int i = len - 1;i >= 0;i--){\n            int a = num[i] + k % 10;\n            k /= 10;\n            // å¦‚æœå’Œ > 10ï¼Œéœ€è¦è¿›ä½\n            if (a >= 10 ){\n                k++;\n            }\n            result.add(a % 10);\n        }\n\n        // ä¸Šé¢å¾ªç¯åšå®Œï¼Œæ˜¯æŒ‰ç…§æ•°ç»„çš„é•¿åº¦æ±‚çš„ç»“æœï¼Œä½†æ˜¯ k å¯èƒ½æ¯”æ•°ç»„å¤šå¾ˆå¤šä½ï¼Œæ‰€ä»¥è¿˜éœ€è¦ä¸€ä¸ª while å¾ªç¯\n        for (; k > 0; k /= 10) {\n            result.add(k % 10);\n        }\n\n        Collections.reverse(result);\n        return result;\n    }\n```\n\n### å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦ï¼šO(max(n,log k))ï¼Œå…¶ä¸­ n ä¸ºæ•°ç»„çš„é•¿åº¦ã€‚\nç©ºé—´å¤æ‚åº¦ï¼šO(1)ã€‚é™¤äº†è¿”å›å€¼ä»¥å¤–ï¼Œä½¿ç”¨çš„ç©ºé—´ä¸ºå¸¸æ•°ã€‚","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188546091","body":"### æ•´ä½“æ€è·¯\n\nç”¨ä¸¤ä¸ªæ ˆï¼Œä¸€ä¸ªè´Ÿè´£å…¥ï¼Œä¸€ä¸ªè´Ÿè´£å‡º\n\n### ä»£ç \n\n```java\nclass MyQueue {\n    Stack<Integer> stack1,stack2;\n\n    public MyQueue() {\n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n\n    public void push(int x) {\n        stack1.push(x);\n    }\n\n    public int pop() {\n        if (stack2.empty()){\n            while (!stack1.empty()){\n                Integer data = stack1.pop();\n                stack2.push(data);\n            }\n        }\n        return stack2.pop();\n    }\n\n    public int peek() {\n        if (stack2.empty()){\n            while (!stack1.empty()){\n                Integer data = stack1.pop();\n                stack2.push(data);\n            }\n        }\n        return stack2.peek();\n    }\n\n    public boolean empty() {\n        return stack1.empty() && stack2.empty();\n    }\n}\n```\n\n### å¤æ‚åº¦åˆ†æ\n\næ—¶é—´å¤æ‚åº¦ï¼šå„ä¸ªæ–¹æ³•å‡ä¸º O(1)\nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193311051","body":"### æ•´ä½“æ€è·¯\nè¿™é“é¢˜ä¸éš¾æƒ³åˆ°éœ€è¦ç”¨åŒæŒ‡é’ˆæ¥åšï¼Œé—®é¢˜åœ¨äºä¸¤æ¡é“¾è¡¨å¯èƒ½é•¿åº¦ä¸ä¸€è‡´\nåˆ†åˆ«åœ¨ä¸¤æ¡é“¾è¡¨ä¸Šå‰è¿›æ—¶ï¼Œå¹¶ä¸èƒ½åŒæ—¶èµ°åˆ°å…¬å…±èŠ‚ç‚¹ã€‚\nè§£å†³æ–¹æ¡ˆæ˜¯ p1 æŒ‡é’ˆå…ˆéå†å®Œ headAï¼Œå†éå† headB\nè§£å†³æ–¹æ¡ˆæ˜¯ p2 æŒ‡é’ˆå…ˆéå†å®Œ headBï¼Œå†éå† headA\nè¿™æ ·ç›¸å½“äºã€Œé€»è¾‘ä¸Šã€ä¸¤æ¡é“¾è¡¨æ¥åœ¨äº†ä¸€èµ·ï¼Œå°±èƒ½åŒæ—¶èµ°åˆ°å…¬å…±èŠ‚ç‚¹ã€‚\n\n### ä»£ç \n\n```java\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n    ListNode p1 = headA, p2 = headB;\n    while (p1 != p2){\n    if(p1 != null){\n    p1 = p1.next;\n    }\n    else{\n    p1 = headB;\n    }\n\n    if(p2 != null){\n    p2 = p2.next;\n    }else{\n    p2 = headA;\n    }\n    }\n\n    return p1;\n    }\n```\n\n### å¤æ‚åº¦åˆ†æ\n\næ—¶é—´å¤æ‚åº¦ï¼šO(m+n)\nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198994740","body":"### æ•´ä½“æ€è·¯\nå…ˆæ˜ç™½ä¸€ç‚¹ï¼šé€ä½æ‹¼æ¥ä¸ºä¸€ä¸ªæ•°å­—çš„ï¼Œå¯ä»¥å…ˆç”¨ StringBuilder å¢å‡å…ƒç´ ï¼Œå†è½¬ä¸ºæ•°å­—\néå†ä¸€éäºŒå‰æ ‘ï¼Œå³å¯å¾—åˆ°ç­”æ¡ˆ\nå‰åºéå†æ—¶ï¼Œå°†å…ƒç´ åŠ åˆ° StringBuilder ä¸­ï¼Œåˆ°è¾¾å¶å­èŠ‚ç‚¹æ—¶æ±‚å’Œ\nååºéå†æ—¶ï¼Œå°†æœ€åä¸€ä¸ªå…ƒç´ ä» StringBuilder ä¸­åˆ é™¤\n\n### ä»£ç \n\n```java\n    StringBuilder path = new StringBuilder();\n        int sum = 0;\npublic int sumNumbers(TreeNode root) {\n        traverse(root);\n        return sum;\n        }\n\nprivate void traverse(TreeNode root){\n        if (root == null){\n        return;\n        }\n        // å‰åºä½ç½®\n        path.append(root.val);\n        // åˆ°è¾¾å¶å­èŠ‚ç‚¹\n        if (root.left == null && root.right == null){\n        // é€ä½æ‹¼æ¥ä¸ºä¸€ä¸ªæ•°å­—çš„ï¼Œå¯ä»¥å…ˆç”¨ StringBuilder å¢å‡å…ƒç´ ï¼Œå†è½¬ä¸ºæ•°å­—\n        sum += Integer.parseInt(path.toString());\n        }\n        traverse(root.left);\n        traverse(root.right);\n        // ååºä½ç½®ï¼Œåˆ é™¤æœ€åä¸€ä¸ªå…ƒç´ \n        path.deleteCharAt(path.length() - 1);\n        }\n```\n\n### å¤æ‚åº¦åˆ†æ\n\næ—¶é—´å¤æ‚åº¦ï¼šO(n)\nç©ºé—´å¤æ‚åº¦ï¼šO(h)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brodxie":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185240028","body":"## æ€è·¯\r\n\r\nç”±äºnumå¯èƒ½å¾ˆé•¿ï¼Œä¸èƒ½è½¬intç›´æ¥ç›¸åŠ ï¼Œæ¨¡æ‹Ÿè®¡ç®—æœºçš„åŠ æ³•\r\n\r\n## ä»£ç \r\n\r\n```python3\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n    \t# space: O(max(M, N))\r\n        res = []\r\n        i = len(num) - 1\r\n        overflow = 0\r\n        # time: O(max(M, N))\r\n        while i >= 0 or k > 0:\r\n            a = num[i] if i >= 0 else 0\r\n            b = k % 10\r\n            c = a + b + overflow\r\n            res.append(c % 10)\r\n            overflow = c // 10\r\n            i -= 1\r\n            k //= 10\r\n        if overflow:\r\n            res.append(overflow)\r\n        # time: O(max(M, N))\r\n        res.reverse()\r\n        return res\r\n```\r\n\r\n## å¤æ‚åº¦åˆ†æ\r\nMä¸ºnum.length, Nä¸ºceil(log10(k))\r\n\r\n- æ—¶é—´å¤æ‚åº¦: O(Max(M, N))\r\n- ç©ºé—´å¤æ‚åº¦: O(Max(M, N))\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186102244","body":"## æ€è·¯\r\n\r\nè®°å½•ä¸Šä¸ªcçš„ç´¢å¼•ï¼Œå¾—åˆ°å½“å‰å­—ç¬¦å’Œcçš„æœ€å°è·ç¦»ã€‚æ­£å‘åå‘åˆ†è¡¨éå†ä¸€æ¬¡ï¼Œå–æœ€å°çš„ã€‚\r\n\r\n## ä»£ç \r\n\r\n```python3\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        # space: O(N)\r\n        ans = [float('inf')] * n\r\n        last_c_index = float('-inf')\r\n        # time: O(N)\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                last_c_index = i\r\n            ans[i] = min(ans[i], i - last_c_index)\r\n        last_c_index = float('inf')\r\n        # time: O(N)\r\n        for i in range(n - 1, -1, -1):\r\n            if s[i] == c:\r\n                last_c_index = i\r\n            ans[i] = min(ans[i], last_c_index - i)\r\n        return ans\r\n\r\n```\r\n\r\n## å¤æ‚åº¦åˆ†æ\r\n\r\nNä¸ºs.length\r\n\r\n- æ—¶é—´å¤æ‚åº¦: O(N)\r\n- ç©ºé—´å¤æ‚: O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186439305","body":"## æ€è·¯\n\næ•°ç»„å’Œæ ˆçš„åŸºæœ¬æ“ä½œ\n\n## ä»£ç \n\n```python3\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        # space: O(maxSize)\n        self.array = [0] * maxSize\n        self.size = 0\n\n    def push(self, x: int) -> None:\n        if self.size >= self.maxSize:\n            return\n        self.array[self.size] = x\n        self.size += 1\n\n    def pop(self) -> int:\n        if self.size <= 0:\n            return -1\n        self.size -= 1\n        return self.array[self.size]\n\n    def increment(self, k: int, val: int) -> None:\n        # time: O(k)\n        for i in range(min(k, self.size)):\n            self.array[i] += val\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n- åˆå§‹åŒ–\n  - time: O(1)\n  - space: O(maxSize)\n- push\n  - time: O(1)\n  - space: O(1)\n- pop\n  - time: O(1)\n  - space: O(1)\n- increment\n  - time: O(k)\n  - space: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186816024","body":"## æ€è·¯\r\n\r\nå¯¹sä¸­çš„å­—ç¬¦è¿›è¡Œå‹æ ˆ, å¦‚æœé‡åˆ°']'è¯´æ˜é‡åˆ°äº†ä¸€ä¸ªæœ€å†…å±‚çš„è¡¨è¾¾å¼, è¿›è¡Œè§£æ, å†å‹åˆ°æ ˆé‡Œ.   \r\n\r\n## ä»£ç \r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        # space: O(N)\r\n        stack = []\r\n        # time : O(N)\r\n        for c in s:\r\n            if c == ']':\r\n                token = ''\r\n                while stack and stack[-1] != '[':\r\n                    token = stack.pop() + token\r\n                stack.pop()\r\n                k = ''\r\n                while stack and stack[-1].isnumeric():\r\n                    k = stack.pop() + k\r\n                stack.append(token * int(k))\r\n            else:\r\n                stack.append(c)\r\n        return ''.join(stack)\r\n```\r\n\r\n## å¤æ‚åº¦åˆ†æ\r\n\r\nNä¸ºs.length\r\n\r\n- time: O(N)\r\n- space: O(N)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189007251","body":"## æ€è·¯\r\n\r\n- ä½¿ç”¨ä¸¤ä¸ªæ ˆï¼šä¸€ä¸ªç”¨äºå…¥é˜Ÿï¼Œä¸€ä¸ªç”¨äºå‡ºé˜Ÿã€‚\r\n- ä½¿ç”¨ä¸€ä¸ªå˜é‡è¾…åŠ©ä¿å­˜é˜Ÿé¦–å…ƒç´ ã€‚\r\n\r\n## ä»£ç \r\n\r\n```python3\r\nclass MyQueue:\r\n\t\r\n    def __init__(self):\r\n        self.push_stack = []\r\n        self.pop_stack = []\r\n        self.push_stack_bottom = None\r\n\r\n    def push(self, x: int) -> None:\r\n        if not self.push_stack:\r\n            self.push_stack_bottom = x\r\n        self.push_stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.pop_stack:\r\n            while self.push_stack:\r\n                self.pop_stack.append(self.push_stack.pop())\r\n        return self.pop_stack.pop()\r\n\r\n    def peek(self) -> int:\r\n        if self.pop_stack:\r\n           return self.pop_stack[-1]\r\n        return self.push_stack_bottom\r\n\r\n    def empty(self) -> bool:\r\n        return not self.push_stack and not self.pop_stack\r\n```\r\n\r\n## å¤æ‚åº¦åˆ†æ\r\n\r\n- push\r\n  - time: O(1)\r\n  - space: O(N)\r\n- pop\r\n  - time: å¹³å‡ O(1) æœ€å O(N)\r\n  - space: O(1)\r\n- peek\r\n  - time: O(1)\r\n  - space: O(1)\r\n- empty\r\n  - time: O(1)\r\n  - space: O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190386113","body":"## æ€è·¯\n\nåˆ©ç”¨å•è°ƒæ ˆçš„æ€§è´¨ï¼Œæ±‚å‡ºæ¯ä¸ªå—çš„æœ€å¤§å€¼\n\n## ä»£ç \n\n```python3\n\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and stack[-1] > num:\n                cur = stack[-1]\n                while stack and stack[-1] > num:\n                    stack.pop()\n                stack.append(cur)\n            else:\n                stack.append(num)\n        return len(stack)\n\n```\n\n## å¤æ‚åº¦åˆ†æ\n\nè®¾ N = arr.length\n\n- time: O(N)\n- space: O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191446045","body":"## æ€è·¯\n\n- æ±‚å‡ºé“¾è¡¨çš„é•¿åº¦n\n- kå¯¹nå–æ¨¡\n- æŠŠå¤´ç»“ç‚¹ç§»åŠ¨åˆ°å°¾ç»“ç‚¹ï¼Œé‡å¤n-kæ¬¡\n- å¯¹n<=1ç‰¹æ®Šå¤„ç†\n\n## ä»£ç \n\n```python3\n\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        dummy_head = ListNode(val=0, next=head)\n        n = 0\n        tail = dummy_head\n        while tail.next:\n            tail = tail.next\n            n += 1\n        if n <= 1:\n            return head\n        k = n - (k % n)\n        for _ in range(k):\n            head = dummy_head.next\n            dummy_head.next = dummy_head.next.next\n            head.next = None\n            tail.next = head\n            tail = tail.next\n        return dummy_head.next\n\n```\n\n\n## å¤æ‚åº¦åˆ†æ\n\nNä¸ºé“¾è¡¨çš„é•¿åº¦\n\n- time: O(N)\n- space: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192243571","body":"## æ€è·¯\n\nå‡è®¾è¦äº¤æ¢node1å’Œnode2ï¼Œä½¿ç”¨ä¸‰ä¸ªæŒ‡é’ˆp0/p1/p2æŒ‡å‘node1çš„å‰é©±ï¼Œnode1å’Œnode2ã€‚ç©¿é’ˆå¼•çº¿ã€‚\n\n\n## ä»£ç \n\n```python3\n\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        dummy_head = ListNode(val=0, next=head)\n        p0, p1, p2 = dummy_head, dummy_head.next, dummy_head.next.next\n        while p1 and p2:\n            p0.next = p2\n            p1.next = p2.next\n            p2.next = p1\n            p0 = p1\n            p1 = p0.next\n            p2 = p1.next if p1 else None\n        return dummy_head.next\n```\n\n## å¤æ‚åº¦åˆ†æ\n\nnä¸ºé“¾è¡¨é•¿åº¦\n\n- Time: O(n)\n- Space: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193037543","body":"# æ€è·¯\n\n- å¿«æ…¢æŒ‡é’ˆ+åˆ†æ²»æ³•ã€‚\n\n- å¿«æ…¢æŒ‡é’ˆæ‰¾åˆ°ä¸­ç‚¹ï¼Œä»¥ä¸­ç‚¹ä¸ºæ ¹ï¼Œé€’å½’æ„é€ å·¦å³å­æ ‘ã€‚\n\n\n\n# ä»£ç \n\n```python3\n\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return None\n        if not head.next:\n            return TreeNode(val=head.val)\n        prev, slow, fast = None, head, head\n        while fast and fast.next:\n            fast = fast.next.next\n            prev = slow\n            slow = slow.next\n        prev.next = None\n        tree_node = TreeNode(val=slow.val)\n        tree_node.left = self.sortedListToBST(head)\n        tree_node.right = self.sortedListToBST(slow.next)\n        return tree_node\n\n```\n\n# å¤æ‚åº¦åˆ†æ\n\nnä¸ºé“¾è¡¨çš„é•¿åº¦\n\n- Time: O(nlog(n)) log(n)å±‚é€’å½’ï¼Œæ¯å±‚éå†èŠ‚ç‚¹æ•°ä¸ºn\n- Space: O(log(n)) ä¸è®¡è¿”å›å€¼ï¼Œé€’å½’æ ˆæ·±åº¦log(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193232908","body":"## æ€è·¯\n\n1. å“ˆå¸Œæ³•\n2. å¿«æ…¢æŒ‡é’ˆæ³•ï¼Œè¿™é‡Œä½¿ç”¨å¿«æ…¢æŒ‡é’ˆæ³•\n\n## ä»£ç \n\n```python3\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        pa, pb = headA, headB\n        while pa != pb:\n            pa, pb = pa.next, pb.next\n            if not pa and not pb:\n                return None\n            if pa is None:\n                pa = headB\n            if pb is None:\n                pb = headA\n        return pa\n\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n- Time:  O(max(headA.length, headB.length))\n- Space: O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193442396","body":"## æ€è·¯\n\nå¿«æ…¢æŒ‡é’ˆæ³•\n\n1. slowæ¯æ¬¡èµ°ä¸€æ­¥ï¼Œfastæ¯æ¬¡èµ°ä¸¤æ­¥ï¼Œä¸¤è€…ç›¸é‡æ—¶é‡å®šå‘faståˆ°å¤´ç»“ç‚¹ï¼Œslowå’Œfastæ¯æ¬¡èµ°ä¸€æ­¥ï¼Œä¸¤è€…ç›¸é‡æ—¶å³ä¸ºç›¸äº¤ç‚¹ã€‚\n\n2. å¦‚æœfastèµ°åˆ°äº†nullï¼Œä»£è¡¨æ²¡æœ‰ç¯ã€‚\n\n\n## ä»£ç \n\n```python3\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return None\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                break\n        if not fast or not fast.next:\n            return None\n        fast = head\n        while slow != fast:\n            slow = slow.next\n            fast = fast.next\n        return fast\n\n``\n\n\n## å¤æ‚åº¦åˆ†æ\n\nn = é“¾è¡¨çš„é•¿åº¦\n\n- Time: O(n)\n- Space: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194999478","body":"## æ€è·¯\n\nåŒé“¾è¡¨+å“ˆå¸Œè¡¨\n\n- å“ˆå¸Œè¡¨å®ç°O(1)çš„æŸ¥æ‰¾\n- åŒé“¾è¡¨å®ç°æ·˜æ±°é€»è¾‘\n\n\n## ä»£ç \n\n```python3\n\nclass DNode:\n    def __init__(self, key: int = 0, val: int = 0, prev: 'DNode' = None, next: 'DNode' = None):\n        self.key: int = key\n        self.val: int = val\n        self.prev: 'DNode' = prev\n        self.next: 'DNode' = next\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.dummy_head: DNode = DNode()\n        self.dummy_tail: DNode = DNode()\n        self.dummy_head.next = self.dummy_tail\n        self.dummy_tail.prev = self.dummy_head\n        self.key_to_node_dict: Dict[int, DNode] = {}\n        self.capacity: int = capacity\n        self.size: int = 0\n\n    def __del_node(self, node: DNode) -> None:\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def __add_to_tail(self, node: DNode) -> None:\n        node.next = self.dummy_tail\n        node.prev = self.dummy_tail.prev\n        node.prev.next = node\n        node.next.prev = node\n\n    def get(self, key: int) -> int:\n        if key not in self.key_to_node_dict:\n            return -1\n        node = self.key_to_node_dict[key]\n        self.__del_node(node)\n        self.__add_to_tail(node)\n        return node.val\n\n    def __evict(self) -> None:\n        if self.size <= self.capacity or self.size <= 0:\n            return\n        head = self.dummy_head.next\n        self.__del_node(head)\n        key = head.key\n        del self.key_to_node_dict[key]\n        self.size -= 1\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.key_to_node_dict:\n            node = DNode(key=key, val=value)\n            self.key_to_node_dict[key] = node\n            self.size += 1\n        else:\n            node = self.key_to_node_dict[key]\n            node.val = value\n            self.__del_node(node)\n        self.__add_to_tail(node)\n        self.__evict()\n\n```\n\n\n## å¤æ‚åº¦åˆ†æ\n\n- get\n  - Time: O(1)\n  - Space: O(1)\n- put\n  - Time: O(1)\n  - Space: O(n) å“ˆå¸Œè¡¨å’ŒåŒé“¾è¡¨çš„ç©ºé—´\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1195723897","body":"# æ€è·¯\n\nBFS\n\n## ä»£ç \n\n```python3\n\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        queue = deque([root])\n        depth = 0\n        while queue:\n            depth += 1\n            for _ in range(len(queue)):\n                node = queue.popleft()\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        return depth\n\n```\n\n\n## å¤æ‚åº¦åˆ†æ\n\nnä¸ºèŠ‚ç‚¹æ•°é‡\n\n- Time: O(n)\n- Space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197002685","body":"## æ€è·¯\n\nåˆ†æ²»æ³•\n\n## ä»£ç \n\n```python3\n\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p or not q:\n            return not p and not q\n        return p.val == q.val \\\n               and self.isSameTree(p.left, q.left) \\\n               and self.isSameTree(p.right, q.right)\n\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n- Time: O(min(p.size, q.size))\n- Space: O(min(p.height, q.height))\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198357777","body":"## æ€è·¯\n\n1. DFS\n2. BFS\n\n## ä»£ç \n\nDFS\n\n```python3\n\nclass Solution:\n    def dfs(self,\n            node: TreeNode,\n            parent_num: int,\n            res: List[int]) -> None:\n        if not node:\n            return\n        num = parent_num * 10 + node.val\n        if not node.left and not node.right:\n            res[0] += num\n        self.dfs(node.left, num, res)\n        self.dfs(node.right, num, res)\n\n    def sumNumbers(self, root: TreeNode) -> int:\n        res = [0]\n        self.dfs(root, 0, res)\n        return res[0]\n\n```\n\nBFS\n\n```python3\n\nclass Solution:\n    def add_to_queue(self,\n                     queue: deque,\n                     node_to_num_dict: Dict,\n                     parent_num: int,\n                     node: TreeNode):\n        if not node:\n            return\n        num = parent_num * 10 + node.val\n        queue.append(node)\n        node_to_num_dict[node] = num\n\n    def sumNumbers(self, root: TreeNode) -> int:\n        node_to_num_dict = {}\n        queue = deque()\n        self.add_to_queue(queue, node_to_num_dict, 0, root)\n        res = 0\n        while queue:\n            node = queue.popleft()\n            num = node_to_num_dict[node]\n            if not node.left and not node.right:\n                res += num\n            else:\n                self.add_to_queue(queue, node_to_num_dict, num, node.left)\n                self.add_to_queue(queue, node_to_num_dict, num, node.right)\n        return res\n\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n- DFS\n  - Time: O(tree.size)\n  - Space: O(tree.height)\n\n- BFS\n  - Time: O(tree.size)\n  - Space: O(tree.size)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200050895","body":"## æ€è·¯\n\nBFS\n\n## ä»£ç \n\n```python3\n\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        queue = deque([root])\n        res = 0\n        while queue:\n            node = queue.popleft()\n            res = node.val\n            if node.right:\n                queue.append(node.right)\n            if node.left:\n                queue.append(node.left)\n        return res\n\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n- Time: O(tree.size)\n- Space: O(tree.size)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200319667","body":"## æ€è·¯\n\nåˆ©ç”¨ç±»ä¼¼å †çš„ç´¢å¼•è§„åˆ™è¿›è¡Œåºåˆ—åŒ–\n\n\n## ä»£ç \n\n```python3\n\nclass Codec:\n\n    def serialize(self, root):\n        if not root:\n            return ''\n        tokens = []\n        queue = deque([(1, root)])\n        while queue:\n            idx, node = queue.popleft()\n            tokens.append('{}:{}'.format(idx, node.val))\n            if node.left:\n                queue.append((2 * idx, node.left))\n            if node.right:\n                queue.append((2 * idx + 1, node.right))\n        return ','.join(tokens)\n\n    def deserialize(self, data):\n        if not data:\n            return None\n        tokens = data.split(',')\n        idx_val_dict = {}\n        for token in tokens:\n            idx, val = token.split(':')\n            idx, val = int(idx), int(val)\n            idx_val_dict[idx] = val\n        root = TreeNode(val=idx_val_dict[1])\n        queue = deque([(1, root)])\n        while queue:\n            idx, node = queue.popleft()\n            left_idx, right_idx = 2 * idx, 2 * idx + 1\n            if left_idx in idx_val_dict:\n                node.left = TreeNode(val=idx_val_dict[left_idx])\n                queue.append((left_idx, node.left))\n            if right_idx in idx_val_dict:\n                node.right = TreeNode(val=idx_val_dict[right_idx])\n                queue.append((right_idx, node.right))\n        return root\n\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n- serialize\n  - Time: O(n) \n  - Space: O(n)\n- deserialize\n  - Time: O(n)\n  - Space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200788743","body":"## æ€è·¯\n\nåˆ©ç”¨dfsè¿›è¡Œæœç´¢ï¼Œhashè¡¨èšåˆæ¯ä¸€åˆ—çš„ç»“æœï¼Œå¯¹keyå’Œvalueè¿›è¡Œæ’åºä¿è¯ç¬¦åˆé¢˜ç›®çš„é¡ºåº\n\n## ä»£ç \n\n```python3\n\nclass Solution:\n    def dfs(self,\n            node: TreeNode,\n            row: int,\n            col: int,\n            col_to_row_val_dict: Dict[int, List[Tuple[int, int]]]) -> None:\n        if not node:\n            return\n        col_to_row_val_dict[col].append((row, node.val))\n        self.dfs(node.left, row + 1, col - 1, col_to_row_val_dict)\n        self.dfs(node.right, row + 1, col + 1, col_to_row_val_dict)\n\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        col_to_row_val_dict = defaultdict(lambda : [])\n        self.dfs(root, 0, 0, col_to_row_val_dict)\n        result = []\n        for col in sorted(col_to_row_val_dict.keys()):\n            vals = [val for row, val in sorted(col_to_row_val_dict[col])]\n            result.append(vals)\n        return result\n\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n- Time: O(nlogn) dfséå†O(n), æ’åºkeyå’Œæ¯ä¸€åˆ—çš„å€¼O(nlogn)\n- Space: O(n) é€’å½’æ ˆO(logn)ï¼Œå“ˆå¸Œè¡¨O(n) \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201915620","body":"## æ€è·¯\n\nç»å…¸é¢˜\n1. æš´åŠ›\n2. hashè¡¨\n3. æ’åº+åŒæŒ‡é’ˆ\n\n##\n\nhashè¡¨\n\n```python3\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        num_to_idx_dict = {}\n        for i, num in enumerate(nums):\n            if target - num in num_to_idx_dict:\n                return [num_to_idx_dict[target - num], i]\n            num_to_idx_dict[num] = i\n        return [-1, -1]\n\n```\n\nåŒæŒ‡é’ˆ\n\n```python3\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        nums = sorted((num, i) for i, num in enumerate(nums))\n        l, r = 0, len(nums) - 1\n        while l < r:\n            res = nums[l][0] + nums[r][0]\n            if res == target:\n                return list(sorted([nums[l][1], nums[r][1]]))\n            elif res < target:\n                l += 1\n            else:\n                r -= 1\n        return [-1, -1]\n\n```\n\n## å¤æ‚åº¦åˆ†æ\n\nhashè¡¨\n- Time: O(n)\n- Space: O(n)\n\nåŒæŒ‡é’ˆ\n- Time: O(nlogn)\n- Space: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203823281","body":"## æ€è·¯\n\nhashè¡¨ç»Ÿè®¡é¢‘ç‡ï¼Œå †ç»´æŠ¤TOPK\n\n## ä»£ç \n\n```python3\n\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        num_to_cnt_dict = defaultdict(lambda : 0)\n        for num in nums:\n            num_to_cnt_dict[num] += 1\n\n        topk = []\n        for num in num_to_cnt_dict:\n            cnt = num_to_cnt_dict[num]\n            if len(topk) < k:\n                heapq.heappush(topk, (cnt, num))\n            elif cnt > topk[0][0]:\n                heapq.heappop(topk)\n                heapq.heappush(topk, (cnt, num))\n\n        return [num for cnt, num in topk]\n\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n- Time: O(n) + O(nlogk) = O(nlogk)\n- Space: O(n) + O(k) = O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205165991","body":"## æ€è·¯\n\nå¯¹äºæ¯ä¸ªç‚¹pï¼Œå‡è®¾åˆ°pçš„è·ç¦»ä¸ºdç‚¹æœ‰nä¸ªï¼Œåˆ™å¯ä»¥ç»„æˆå›æ—‹é•–n*(n-1)ä¸ª.  \nå¾ªç¯æ¯ä¸ªç‚¹ï¼Œè®¡ç®—åˆ°è¯¥ç‚¹ä¸åŒè·ç¦»çš„ç‚¹çš„ä¸ªæ•°ã€‚  \n\n\n## ä»£ç \n\n```python3\n\nclass Solution:\n    def get_dist(self, point1: List[int], point2: List[int]) -> int:\n        x1, y1 = point1\n        x2, y2 = point2\n        return (x1 - x2) ** 2 + (y1 - y2) ** 2\n\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        n = len(points)\n        ret = 0\n        for i in range(n):\n            dist_to_cnt_dict = defaultdict(lambda : 0)\n            for j in range(n):\n                if i == j:\n                    continue\n                dist = self.get_dist(points[i], points[j])\n                dist_to_cnt_dict[dist] += 1\n            for cnt in dist_to_cnt_dict.values():\n                ret += cnt * (cnt - 1)\n        return ret\n\n\n```\n\n\n## å¤æ‚åº¦åˆ†æ\n\nn = points.length\n\n- time: O(n^2)\n- space: O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206139519","body":"## æ€è·¯\n\næ»‘åŠ¨çª—å£  \nèµ·å§‹æ—¶çª—å£ä¸º(l, r) = (0, 0)  \nå¯¹äºæ¯ä¸€ä¸ªåŠ å…¥çš„å­—æ¯ï¼Œè°ƒæ•´lçš„ä½ç½®ï¼Œä½¿å¾—æ–°çš„å­—æ¯åœ¨å½“å‰çª—å£ä¸­ä¸é‡å¤ã€‚\n\n\n## ä»£ç \n\n```python3\n\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        l, r = 0, 0\n        letter_cnt = {}\n        ret = 0\n        while r < len(s):\n            while letter_cnt.get(s[r], 0) != 0:\n                letter_cnt[s[l]] = letter_cnt.get(s[l], 0) - 1\n                l += 1\n            letter_cnt[s[r]] = letter_cnt.get(s[r], 0) + 1\n            ret = max(ret, r - l + 1)\n            r += 1\n        return ret\n\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n- Time: O(n)\n- Space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207183768","body":"# æ€è·¯\n\næ»‘åŠ¨çª—å£æ‰«æå­—ç¬¦ä¸²ï¼Œhashè¡¨ç»Ÿè®¡å•è¯å‡ºç°æ¬¡æ•°ã€‚\n\n## ä»£ç \n\n```python3\n\nclass Solution:\n    def word_cnt_equals(self,\n                        word_cnt: Dict[str, int],\n                        sub_word_cnt: Dict[str, int]) -> bool:\n        if len(word_cnt) != len(sub_word_cnt):\n            return False\n        for word, cnt in word_cnt.items():\n            if cnt != sub_word_cnt[word]:\n                return False\n        return True\n\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        str_len = len(s)\n        word_len = len(words[0])\n        substr_len = word_len * len(words)\n        if str_len < substr_len:\n            return []\n        word_cnt = Counter(words)\n        ret = []\n\n        for l in range(str_len - substr_len + 1):\n            r = l + substr_len - 1\n            sub_words = []\n            for i in range(l, r + 1, word_len):\n                sub_words.append(s[i:i + word_len])\n\n            sub_word_cnt = Counter(sub_words)\n            if self.word_cnt_equals(word_cnt, sub_word_cnt):\n                ret.append(l)\n        return ret\n\n\n```\n\n\n## å¤æ‚åº¦åˆ†æ\n\nn = s.length, m = words.length, k = words[0].length\n\n- time: O(n * m)\n- space: O(m)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207356763","body":"## æ€è·¯\n\nå‰ç¼€å’Œ+åŒä½™å®šç†\n\n\n## ä»£ç \n\n```python3\n\nclass Solution:\n    def solve(self, nums, k):\n        n = len(nums)\n        total_remainder = sum(nums) % k\n        map = {0: -1}\n        prefix = 0\n        ret = n\n        for i in range(n):\n            prefix += nums[i]\n            remainder = prefix % k\n            map[remainder] = i\n            if ((prefix - total_remainder) % k) in map:\n                ret = min(ret, i - map[((prefix - total_remainder) % k)])\n        return ret if ret < n else -1\n\n```\n\n## å¤æ‚åº¦åˆ†æ\n\nn = len(nums)\n\n- Time: O(n)\n- Space: O(min(n, k))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207631823","body":"## æ€è·¯\n\nå¿«æ…¢æŒ‡é’ˆæ±‚ä¸­ç‚¹\n\n\n## ä»£ç \n\n```python\n\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        if not head:\n            return None\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n- Time: O(n)\n- Space: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209231289","body":"## æ€è·¯\n\nå¾ªç¯å˜é‡çš„å®šä¹‰ï¼šjæŒ‡å‘æœ€åä¸€ä¸ªä¸é‡å¤çš„æ•°å­—ï¼Œiéå†æ•°ç»„\n\n## ä»£ç \n\n```python\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        n = len(nums)\n        j = 0\n        for i in range(1, n):\n            if nums[i] != nums[j]:\n                j += 1\n                nums[j] = nums[i]\n        return j + 1\n\n```\n\n## å¤æ‚åº¦åˆ†æ\n\n- Time: O(n)\n- Space: O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"y525":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185251187","body":"class Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        carry = 0\r\n        i = 1\r\n        n = len(num)\r\n        while n-1 >= 0 or carry != 0 or k != 0:\r\n            if n-1 < 0:\r\n                number = k%10 + carry\r\n            else:\r\n                number = num[n-1] + k%10 + carry\r\n            k = k//10\r\n            carry = number//10\r\n            number = number % 10\r\n            res.append(number)\r\n            n -= 1\r\n        return res[::-1]\r\n\r\nspace complexity O(n) time complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185878663","body":"class Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        answer = []\r\n        for i, v in enumerate(s):\r\n            if v == c:\r\n                res.append(i)\r\n        for i in range(len(s)):\r\n            m = math.inf\r\n            for j in range(len(res)):\r\n                m = min(abs(i-res[j]), m)\r\n            answer.append(m)\r\n        return answer\r\ntime complexity O(n^2) space complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186441195","body":"class CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.data = []\r\n    def isEmpty(self):\r\n        if len(self.data) == 0:\r\n            return True\r\n        else: \r\n            return False\r\n    def isFull(self):\r\n        if len(self.data) == self.maxSize:\r\n            return True\r\n        else:\r\n            return False\r\n            \r\n    def push(self, x: int) -> None:\r\n        if self.isFull() == True:\r\n            pass\r\n        else:\r\n            self.data.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.isEmpty() == True:\r\n            return -1\r\n        else:\r\n            return self.data.pop(-1)\r\n        return s.pop() if s is not None else -1\r\n        \r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(len(self.data)):\r\n            if i<k:\r\n                self.data[i] = self.data[i]+val\r\ntime complexity O(n) space complexity O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1188353551","body":"class Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        #stack\r\n        stack = []\r\n        for i in range(len(s)):\r\n            if s[i] != \"]\":\r\n                stack.append(s[i])\r\n            else:\r\n                st = \"\"\r\n                while stack[-1] != \"[\":\r\n                    st = stack.pop() + st\r\n                stack.pop()\r\n                num = \"\"\r\n                while stack and stack[-1].isdigit():\r\n                    num = stack.pop() + num\r\n                stack.append(int(num)*st)\r\n        return \"\".join(stack)\r\ntime complexity O(n) space complexity O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188654987","body":"class MyQueue:\r\n\r\n    def __init__(self):\r\n        self.s1 = []\r\n        self.s2 = []\r\n        \r\n    def push(self, x: int) -> None:\r\n        while self.s1:\r\n            self.s2.append(self.s1.pop())\r\n        self.s1.append(x)\r\n        while self.s2:\r\n            self.s1.append(self.s2.pop())\r\n            \r\n    def pop(self) -> int:\r\n        return self.s1.pop()\r\n        \r\n\r\n    def peek(self) -> int:\r\n        return self.s1[-1]\r\n\r\n    def empty(self) -> bool:\r\n        return False if self.s1 else True","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189905583","body":"class Solution:\r\n    def maxChunksToSorted(self, arr: list[int]) -> int:\r\n        stack = []\r\n        stack.append((arr[0], arr[0]))\r\n        for i in range(1, len(arr)):\r\n            minNum, maxNum = arr[i], arr[i]\r\n            while stack and stack[-1][1] > minNum:\r\n                prevMinNum, prevMaxNum = stack.pop()\r\n                minNum, maxNum = min(prevMinNum, minNum), max(prevMaxNum, maxNum)\r\n            stack.append((minNum, maxNum))\r\n        return len(stack)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191097100","body":"class Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        n = 0\r\n        dummy = ListNode(0, head)\r\n        pre = dummy\r\n        while head:\r\n            n += 1\r\n            head = head.next\r\n            pre = pre.next \r\n        if n <= 1:\r\n            return dummy.next\r\n        num = k % n\r\n        if num == 0:\r\n            return dummy.next\r\n        preN = dummy\r\n        head = dummy.next\r\n        while n-num-1 >= 0:\r\n            head = head.next\r\n            preN = preN.next\r\n            num += 1\r\n        preN.next = None\r\n       \r\n        pre.next = dummy.next\r\n        return head\r\n        \r\nTime complexity O(n), space complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192208106","body":"class Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n        dummy = ListNode(0, head)\r\n        pre, cur = dummy, head\r\n        while cur and cur.next:\r\n            tmp = cur.next.next\r\n            # swap\r\n            pre.next = cur.next\r\n            cur.next.next = cur\r\n            cur.next = tmp\r\n            # updata\r\n            pre = cur\r\n            cur = tmp\r\n        return dummy.next\r\nTime complexity O(n) Space complexity O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193074805","body":"class Solution:\r\n    def findMiddle(self,head):\r\n        prev=None\r\n        slow,fast=head,head\r\n        while fast and fast.next:\r\n            prev=slow\r\n            slow=slow.next\r\n            fast=fast.next.next\r\n        return prev,slow    \r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if head is None:\r\n            return None\r\n        prev,mid=self.findMiddle(head)\r\n        root=TreeNode(mid.val)\r\n        root.right=self.sortedListToBST(mid.next)\r\n        if prev is None:\r\n            root.left=None\r\n        else:\r\n            prev.next=None\r\n            root.left=self.sortedListToBST(head)\r\n        return root ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193262627","body":"class Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\r\n        \r\n        pA = headA\r\n        pB = headB\r\n        \r\n        while pA != pB:\r\n            pA = headB if pA is None else pA.next\r\n            pB = headA if pB is None else pB.next\r\n        return pA\r\nspace complexity O(1) time complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193648309","body":"class Solution:\r\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head or not head.next: return\r\n        slow = head.next\r\n        fast = head.next.next\r\n        while slow != fast:\r\n            if not fast or not fast.next:\r\n                return \r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        p1, p2 = head, fast\r\n        while p1 != p2:\r\n            p1 = p1.next\r\n            p2 = p2.next\r\n        return p1\r\nTime complexity O(n) space complexity O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196305783","body":"class Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root: return 0\r\n        left = self.maxDepth(root.left)\r\n        right = self.maxDepth(root.right)\r\n        return max(left, right)+1\r\nTime complexity O(1) Space complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197415188","body":"class Solution:\r\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n        if not p and not q: return True\r\n        if not p or not q: return False\r\n        if p.val != q.val:\r\n            return False\r\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\nTime complexity O(n) space complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198977138","body":"class Solution:\r\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\r\n        def dfs(root, num):\r\n            if not root: return 0\r\n            num = 10*num + root.val\r\n            if not root.left and not root.right:\r\n                return num\r\n            else: \r\n                return dfs(root.left, num) + dfs(root.right, num)\r\n        return dfs(root, 0)\r\nTime complexity: O(n) Space complexity: O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200795502","body":"def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\r\n        dq, hash_table = deque(), {}\r\n        dq.append([root, 0 , 0])\r\n        hash_table[(0, 0)] = [root.val]\r\n        while dq:\r\n            node, row, col = dq.popleft()\r\n            if node.left:\r\n                dq.append([node.left, row + 1, col - 1])\r\n                if (row + 1, col - 1) not in hash_table:\r\n                    hash_table[(row + 1, col - 1)] = []\r\n                hash_table[(row + 1, col - 1)].append(node.left.val)\r\n            if node.right:\r\n                dq.append([node.right, row + 1, col + 1])\r\n                if (row + 1, col + 1) not in hash_table:\r\n                    hash_table[(row + 1, col + 1)] = []\r\n                hash_table[(row + 1, col + 1)].append(node.right.val)\r\n        \r\n        keys = list(hash_table.keys())\r\n        keys.sort(key = lambda x: [x[1], x[0]])\r\n        result = []\r\n        last_col = - float('Inf')\r\n        for key in keys:\r\n            if key[1] > last_col:\r\n                result.append([])\r\n                last_col = key[1]\r\n            result[-1] += sorted(hash_table[key])\r\n        return result","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202088787","body":"class Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        # index i, target - h[i] \r\n        h = {}\r\n        for i in range(len(nums)):\r\n            if target - nums[i] in h:\r\n                return [h[target-nums[i]], i]\r\n            else:\r\n                h[nums[i]] = i\r\n        return []\r\nTime complexity O(n) space complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1206101125","body":"class Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        count = Counter(nums)\r\n        res = []\r\n        num = 0\r\n        sortedcount = sorted(count.items(), key = lambda x: -x[1])\r\n        for i, v in sortedcount:\r\n            if num < k:\r\n                res.append(i)\r\n                num += 1\r\n        return res","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205641239","body":"class Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        h = {}\r\n        p1, p2, res = 0, 0, 0\r\n        while p2 < len(s):\r\n            if s[p2] not in h:\r\n                h[s[p2]] = p2\r\n            else:\r\n                p1 = max(h[s[p2]]+1, p1)\r\n                h[s[p2]] = p2\r\n            res = max(res, p2-p1+1)\r\n            p2 += 1\r\n        return res\r\n         \r\nTime complexity O(n) Space complexity O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207746800","body":"class Solution:\r\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        p1, p2 = head, head\r\n        while p2 and p2.next:\r\n            p1 = p1.next\r\n            p2 = p2.next.next\r\n        return p1\r\nTime complexity O(n) Space complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208983502","body":"class Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        p1, p2 = 0, 0\r\n        while p2 < len(nums):\r\n            if nums[p1] == nums[p2]:\r\n                p2 += 1\r\n            else:\r\n                nums[p1+1], nums[p2] = nums[p2], nums[p1+1]\r\n                p1 += 1\r\n                p2 += 1\r\n        return p1+1\r\ntime complexity O(n) space complexity O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leungogogo":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185258544","body":"# LC989. Add to Array-Form of Integer\n## Main Idea\nFirst, it looks like we can convert the array `num` to integer and add it to `k`, but `num.length <= 1E+4` so this approach will cause integer overflow. So we will have to do the addition in array form.\n\nThen the idea is to simulate the entire process, add each digit of `num` and `k` with a `carry` bit. We will terminate the loop when we run out of digits for both `num` and `k` and `carry == 0`.\n\n## Code\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int ptr = num.length - 1, carry = 0;\n        List<Integer> ret = new ArrayList<>();\n        while (ptr >= 0 || k > 0 || carry > 0) {\n            int d1 = ptr >= 0 ? num[ptr] : 0;\n            int d2 = k % 10;\n            int sum = d1 + d2 + carry;\n            ret.add(sum % 10);\n            ptr--;\n            k /= 10;\n            carry = sum >= 10 ? 1 : 0;\n        }\n        \n        Collections.reverse(ret);\n        return ret;\n    }\n}\n```\n\n## Complexity Analysis\nTime: `O(2*max(N, log(K)))`\n* Given a number `K`, its length will be `O(log_{2}(K))`, the time complexity depends on the length of `N` and `K`, whichever is longer.\n* Notice we want to insert digits at the end of the array and then reverse it after we finish the addition (reverse takes `O(res.size())`). If we insert at the head of array, then it will take `O(n^2)` of time.\n\nSpace: `O(1)`, as we didn't use additional spaces except the return array.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186129158","body":"```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length(), count = Integer.MAX_VALUE;\n        int[] ret = new int[n];\n        Arrays.fill(ret, Integer.MAX_VALUE);\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == c) {\n                count = 0;\n            }\n            ret[i] = Math.min(ret[i], count);\n            if (count != Integer.MAX_VALUE)\n                count++;\n        }\n        \n        count = Integer.MAX_VALUE;\n        for (int i = n - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                count = 0;\n            }\n            \n            ret[i] = Math.min(ret[i], count);\n            if (count != Integer.MAX_VALUE)\n                count++;\n        }\n        \n        return ret;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186426699","body":"```java\nclass CustomStack {\n    private Deque<Integer> stack;\n    private int[] arr;\n    public CustomStack(int maxSize) {\n        stack = new ArrayDeque<>();\n        arr = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if (stack.size() < arr.length) {\n            stack.push(x);\n        } \n    }\n    \n    public int pop() {\n        if (stack.isEmpty()) {\n            return -1;\n        }\n        int index = stack.size() - 1, ret = stack.pop() + arr[index];\n        if (index > 0) {\n            arr[index - 1] += arr[index];\n        }\n        arr[index] = 0;\n        return ret;\n    }\n    \n    public void increment(int k, int val) {\n        k = Math.min(k - 1, stack.size() - 1);\n        if (k >= 0) {\n            arr[k] += val;\n        }\n    }\n}\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191155942","body":"```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null) {\n            return head;\n        }\n        int n = getLen(head);\n        k %= n;\n        if (k == 0) {\n            return head;\n        }\n        \n        ListNode fast = head, slow = head;\n        for (int i = 0; i < k; i++) {\n            fast = fast.next;\n        }\n\n        while (fast.next != null) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        fast.next = head;\n        ListNode ret = slow.next;\n        slow.next = null;\n        return ret;\n    }\n    \n    private int getLen(ListNode head) {\n        int ret = 0;\n        while (head != null) {\n            ret++;\n            head = head.next;\n        }\n        return ret;\n    }\n}\n```\n\nTime: `O(n)`\n\nSpace: `O(1)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192343793","body":"```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(), prev = dummy;\n        dummy.next = head;\n        while (prev != null) {\n            ListNode cur = null, next = null;\n            \n            cur = prev.next;\n            if (cur != null) {\n                next = cur.next;\n            }\n            \n            if (next != null) {\n                prev.next = next;\n                ListNode tmp = next.next;\n                next.next = cur;\n                cur.next = tmp;\n            }\n            prev = cur;\n        }\n        \n        return dummy.next;\n    }\n}\n```\nTime: `O(n)`\n\nSpace: `O(1)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193045044","body":"```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        } else if (head.next == null) {\n            return new TreeNode(head.val);\n        }\n        \n        ListNode midPrev = findMidPrev(head), mid = midPrev.next;\n        midPrev.next = null;\n        TreeNode ret = new TreeNode(mid.val);\n        ret.left = sortedListToBST(head);\n        ret.right = sortedListToBST(mid.next);\n        return ret;\n    }\n    \n    private ListNode findMidPrev(ListNode head) {\n        ListNode fast = head.next.next, slow = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```\n\nTime: `O(nlogn)`\n\nSpace: `O(logn)`","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194565112","body":"# LC146. LRU Cache\n## Method. Map + Linked List\n### Main Idea\nWe can use a linked list to simulate the cache queue, but if we just use a linked list, then the time complexity of `get()` and `remove()` will be `O(n)`.\n\nTo make the `get()` and `remove()` operations more efficient, we can use a map to store `(key, ListNode)` pairs. Given a key, we can get its node immediately from the map instead of going through the linked list.\n### Code\n```java\nclass LRUCache {\n    private class DBListNode {\n        private DBListNode prev;\n        private DBListNode next;\n        private int key;\n        private int val;\n\n        private DBListNode(int key, int val) {\n            this.key = key;\n            this.val = val;\n        }\n    }\n    \n    private DBListNode head;\n    private DBListNode tail;\n    private int cap;\n    private int size;\n    private Map<Integer, DBListNode> map;\n\n    public LRUCache(int capacity) {\n        head = new DBListNode(-1, -1);\n        tail = new DBListNode(-1, -1);\n        map = new HashMap<>();\n        head.next = tail;\n        tail.prev = head;\n        cap = capacity;\n    }\n    \n    public int get(int key) {\n        if (!map.containsKey(key)) {\n            return -1;\n        }\n        DBListNode node = map.get(key);\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n        return node.val;\n    }\n    \n    public void put(int key, int value) {\n        DBListNode node;\n        if (map.containsKey(key)) {\n            node = map.get(key);\n            node.val = value;\n            node.prev.next = node.next;\n            node.next.prev = node.prev;\n        } else {\n            if (size < cap) {\n                ++size;\n            } else {\n                DBListNode remove = tail.prev;\n                remove.prev.next = tail;\n                tail.prev = remove.prev;\n                map.remove(remove.key);\n            }\n            node = new DBListNode(key, value);\n        }\n\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n        map.put(key, node);\n    }\n}\n```\n\n### Complexity Analysis\nTime: `O(1)` for all operations\nSpace: `O(cap)`\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1195969293","body":"```java\nclass Solution {\n    private int maxDepth;\n    public int maxDepth(TreeNode root) {\n        this.maxDepth = 0;\n        dfs(root, 1);\n        return maxDepth;\n    }\n    \n    private void dfs(TreeNode node, int depth) {\n        if (node == null) {\n            return;\n        }\n        maxDepth = Math.max(maxDepth, depth);\n        dfs(node.left, depth + 1);\n        dfs(node.right, depth + 1);\n    }\n}\n```\n\nTime: `O(n)`\nSpace: `O(height) = O(n)` for recursion.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197299046","body":"```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null || q == null) {\n            return p == null && q == null;\n        }\n        \n        if (p.val != q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n```\nTime: `O(n)`\nSpace: `O(height) = O(n)` for recursion","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198543868","body":"```java\r\nclass Solution {\r\n    private List<Integer> nums;\r\n    public int sumNumbers(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n        \r\n        this.nums = new ArrayList<>();\r\n        dfs(root, new StringBuilder());\r\n        return nums.stream().reduce(0, (a, b) -> a + b);\r\n    }\r\n    \r\n    private void dfs(TreeNode node, StringBuilder builder) {\r\n        builder.append(node.val);\r\n        if (node.left == null && node.right == null) {\r\n            nums.add(Integer.valueOf(builder.toString()));\r\n        } else {\r\n            if (node.left != null) {\r\n                dfs(node.left, builder);\r\n            }\r\n            \r\n            if (node.right != null) {\r\n                dfs(node.right, builder);\r\n            }\r\n        }\r\n        builder.deleteCharAt(builder.length() - 1);\r\n    }\r\n}\r\n```\r\n\r\nTime: `O(n)`\r\nSpace: `O(n)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1199974522","body":"```java\nclass Solution {\n    private int maxDepth;\n    private int ret;\n    \n    public int findBottomLeftValue(TreeNode root) {\n        this.ret = root.val;\n        this.maxDepth = 0;\n        dfs(root, 0);\n        return ret;\n    }\n    \n    private void dfs(TreeNode node, int depth) {\n        if (depth > maxDepth) {\n            maxDepth = depth;\n            ret = node.val;\n        }\n        \n        if (node.left != null) {\n            dfs(node.left, depth + 1);\n        }\n        \n        if (node.right != null) {\n            dfs(node.right, depth + 1);\n        }\n    }\n}\n```\n\nTime: `O(n)`\n\nSpace: `O(n)`","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201371105","body":"```java\nclass Solution {\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        // column -> list\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        PriorityQueue<Pair<TreeNode, int[]>> queue = new PriorityQueue<>((p1, p2) -> {\n            int loc1[] = p1.getValue();\n            int loc2[] = p2.getValue();\n            if (loc1[0] == loc2[0]) {\n                return p1.getKey().val - p2.getKey().val;\n            } else {\n                return loc1[0] - loc2[0];\n            }\n        });\n        queue.offer(new Pair(root, new int[] {0, 0}));\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; ++i) {\n                Pair<TreeNode, int[]> p = queue.poll();\n                TreeNode node = p.getKey();\n                int loc[] = p.getValue();\n                List<Integer> list = map.getOrDefault(loc[1], new ArrayList<>());\n                list.add(node.val);\n                map.put(loc[1], list);\n                if (node.left != null) {\n                    queue.offer(new Pair(node.left, new int[] {loc[0] + 1, loc[1] - 1}));\n                }\n\n                if (node.right != null) {\n                    queue.offer(new Pair(node.right, new int[] {loc[0] + 1, loc[1] + 1}));\n                }\n            }\n        }\n\n        List<List<Integer>> res = new ArrayList<>();\n        for (int i = -1000; i <= 1000; ++i) {\n            if (map.containsKey(i)) {\n                res.add(map.get(i));\n            }\n        }\n        return res;\n    }\n}\n```\nTime: `O(nlogn)`\nSpace: `O(n)`","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203283882","body":"```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        int n = nums.length;\n        Map<Integer, Integer> freq = new HashMap<>();\n        for (int num : nums) {\n            freq.put(num, freq.getOrDefault(num, 0) + 1);\n        }\n        \n        // {num, freq}\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((p1, p2) -> p1[1] - p2[1]);\n        freq.forEach((key, val) -> {\n            minHeap.offer(new int[] {key, val});\n            if (minHeap.size() > k) {\n                minHeap.poll();\n            }\n        });\n        \n        return minHeap.stream().map(p -> p[0]).mapToInt(Integer::intValue).toArray();\n    }\n}\n```\nTime: `O(nlogk)`\n\nSpace: `O(n)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204815528","body":"```java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int n = points.length, ret = 0;\n        for (int i = 0; i < n; i++) {\n            Map<Integer, Integer> map = new HashMap<>();\n            for (int j = 0; j < n; j++) {\n                if (j == i) {\n                    continue;\n                }\n                \n                int distSQ = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\n                map.put(distSQ, map.getOrDefault(distSQ, 0) + 1);\n            }\n            \n            for (int value : map.values()) {\n                if (value < 2) {\n                    continue;\n                } \n                \n                ret += value * (value - 1);\n            }\n        }\n        return ret;\n    }\n}\n```\n\nTime: `O(n^2)`\n\nSpace: `O(n)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206146543","body":"```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        boolean[] set = new boolean[128];\n        int left = 0, right = 0, maxLen = 0, n = s.length();\n        while (right < n) {\n            while (right < n && !set[s.charAt(right)]) {\n                set[s.charAt(right)] = true;\n                right++;\n            }\n            \n            maxLen = Math.max(maxLen, right - left);\n            set[s.charAt(left)] = false;\n            left++;\n        }\n        \n        return maxLen;\n    }\n}\n```\nTime: `O(n)`\n\nSpace: `O(n)`","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suukii":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185259516","body":"- Time: $O(N)$, N is $max(num.size(), ceil(log(k)))$\n- Space: $O(1)$, no extra space is used apart from the output array.\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        res.reserve(num.size());\n        int p = num.size() - 1;\n\n        while (p >= 0 || k > 0) {\n            if (p >= 0) k += num[p--];\n            res.push_back(k % 10);\n            k /= 10;\n        }\n\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186111046","body":"- Time: $O(N)$\n- Space: $O(1)$\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> res(n, n);\n        \n        if (s[0] == c) res[0] = 0;\n\n        for (int i = 1; i < n; i++)\n            res[i] = s[i] == c ? 0 : res[i - 1] + 1;\n\n        for (int i = n - 2; i >= 0; i--)\n            res[i] = min(res[i], res[i + 1] + 1);\n\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186387195","body":"- Time: `push` $O(1)$, `pop` $O(1)$, `increment` $O(1)$\r\n- Space: $O(N)$, N is maxSize\r\n\r\n```cpp\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) : capacity_(maxSize) {\r\n        inc_ = vector<int>(capacity_, 0);\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (top_ == capacity_ - 1) return;\r\n        stk_.push(x);\r\n        top_++;\r\n    }\r\n    \r\n    int pop() {\r\n        if (top_ == -1) return -1;\r\n\r\n        int x = stk_.top(); stk_.pop();\r\n        x += inc_[top_];\r\n\r\n        if (top_ > 0) \r\n            inc_[top_ - 1] += inc_[top_];\r\n        inc_[top_--] = 0;\r\n\r\n        return x;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        k = min(k - 1, top_);\r\n        if (k > -1) inc_[k] += val;\r\n    }\r\nprivate:\r\n    int capacity_;\r\n    int top_ = -1;\r\n    stack<int> stk_;\r\n    vector<int> inc_;\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186696536","body":"- Time: $O(N)$. N is the length of the decoded string\n- Space: $(O(N)$. N is the length of the decoded string. This is the space used by the `tokens` stack.\n\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<string> tokens;\n\n        for (char c : s) {\n            if (c != ']') {\n                tokens.push(string(1, c));\n                continue;\n            }\n\n            // get the repeat patern\n            // everything after \"[\"\n            string p;\n            while (!tokens.empty() && tokens.top() != \"[\") {\n                p += tokens.top();\n                tokens.pop();\n            }\n            // pop out the \"[\"\n            tokens.pop();\n\n            // get the repeat number\n            // which comes right before the \"[\"\n            string num;\n            while (!tokens.empty() && isNumber(tokens.top())) {\n                num = tokens.top() + num;\n                tokens.pop();\n            }\n\n            // repeat the pattern string and put it back to the stack\n            tokens.push(repeat(stoi(num), p));\n        }\n\n        return join(tokens);\n    }\nprivate:\n    bool isNumber(const std::string& s) {\n        auto it = s.begin();\n        while (it != s.end() && std::isdigit(*it)) ++it;\n        return !s.empty() && it == s.end();\n    }\n\n    string repeat(int k, string s) {\n        string res;\n        while (k) {\n            res += s;\n            k--;\n        }\n        return res;\n    }\n    \n    string join(stack<string> stk) {\n        string res;\n        while (!stk.empty()) {\n            res += stk.top();\n            stk.pop();\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188510676","body":"- Time: `push` $O(1)$, `pop` $O(1)$, `peek` $O(1)$\n- Space: $O(N)$\n```cpp\nclass MyQueue {\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        write_.push(x);\n    }\n    \n    int pop() {\n        if (read_.empty()) pour();\n        int x = read_.top();\n        read_.pop();\n        return x;\n    }\n    \n    int peek() {\n        if (read_.empty()) pour();\n        return read_.top();\n    }\n    \n    bool empty() {\n        return read_.empty() && write_.empty();\n    }\nprivate:\n    void pour() {\n        while (!write_.empty()) {\n            read_.push(write_.top());\n            write_.pop();\n        }\n    }\n\n    stack<int> read_;\n    stack<int> write_;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189729951","body":"- Time: $O(N)$, N is the size of arr.\r\n- Space: $O(N)$, the space used by the stack.\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        // a non-strictly increasing stack\r\n        stack<int> stk;\r\n        for (int n : arr) {\r\n            if (stk.empty() || n >= stk.top()) {\r\n                stk.push(n);\r\n            } else {\r\n                int top = stk.top(); stk.pop();\r\n                while (!stk.empty() && stk.top() > n)\r\n                    stk.pop();\r\n                stk.push(top);\r\n            }\r\n        }\r\n        return stk.size();\r\n    }\r\n};\r\n```\r\n\r\nhttps://leetcode.cn/problems/max-chunks-to-make-sorted-ii/solution/768-zui-duo-neng-wan-cheng-pai-xu-de-kuai-iihua-do/","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190952790","body":"- Time: $O(N)$, N is the length of the list. In worst case the list is traversed twice.\n- Space: $O(1)$\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (!head || !head->next || k == 0) return head;\n\n        ListNode *rotated_head, *cur;\n        int n = 1;\n\n        cur = head;\n        while (cur->next) {\n            cur = cur->next;\n            n++;\n        }\n\n        k = n - k % n;\n        cur->next = head; // connect the tail and the head\n        while (k--) cur = cur->next;\n\n        rotated_head = cur->next;\n        cur->next = nullptr;\n        return rotated_head;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192102035","body":"- Time: $O(N)$. N is the length of the list.\n- Space: $O(N)$. Recursive stack space.\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (!head || !head->next) return head;\n        ListNode *a = head, *b = a->next, *c = swapPairs(b->next);\n        a->next = c;\n        b->next = a;\n        return b;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193100292","body":"- Time: $(O(N*H)$, N is the length of the list and H is the depth of the recursion tree, which is $logN$. Each level of the recursion will take $O(N)$ time to look up for the middle list node.\n- Space: $O(H)$, H is the depth of the recursion tree, which is $logN$.\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        return sortedListToBST(head, nullptr);\n    }\nprivate:\n    TreeNode* sortedListToBST(ListNode* head, ListNode* end) {\n        if (!head || head == end) return nullptr;\n\n        // find the middle list node\n        ListNode* mid = findMidNode(head, end);\n\n        TreeNode* root = new TreeNode(mid->val);\n        // devide and conquer\n        root->left = sortedListToBST(head, mid);\n        root->right = sortedListToBST(mid->next, end);\n\n        return root;\n    }\n    ListNode* findMidNode(ListNode* head, ListNode* end) {\n        ListNode *p1, *p2;\n        p1 = p2 = head;\n        while (p2 != end && p2->next != end) {\n            p1 = p1->next;\n            p2 = p2->next->next;\n        }\n        return p1;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193231180","body":"- Time: $O(N)$\n- Space: $O(1)$\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* a = headA;\n        ListNode* b = headB;\n        while (a != b) {\n            a = a ? a->next : headB;\n            b = b ? b->next : headA;\n        }\n        return a;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193472788","body":"- Time: $O(N)$\n- Space: $O(1)$\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if (!head || !head->next) return NULL;\n\n        ListNode *slow, *fast;\n        slow = fast = head;\n\n        while (fast && fast->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n            if (slow == fast) break;\n        }\n\n        if (slow != fast) return NULL;\n\n        slow = head;\n        while (slow != fast) {\n            slow = slow->next;\n            fast = fast->next;\n        }\n        return slow;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194926213","body":"- Time: `put` $O(1)$, `get` $O(1)$.\n- Space: $O(N)$, N is the `capacity`, which is space used by the doubly linked list and the unordered map.\n```cpp\nclass DList {\npublic:\n    class Node {\n    public:\n        Node(int in_key, int in_value) : key(in_key), value(in_value) {}\n\n        int key;\n        int value;\n        Node* prev = nullptr;\n        Node* next = nullptr;\n    };\n\n    DList() {\n        d_head_ = new Node(-1, -1);\n        d_tail_ = new Node(-1, -1);\n        d_head_->next = d_tail_;\n        d_tail_->prev = d_head_;\n    }\n\n    void push_front(Node* node) {\n        insert_after(d_head_, node);\n    }\n\n    void push_back(Node* node) {\n        insert_after(tail(), node);\n    }\n\n    void insert_after(Node* target, Node* node) {\n        Node* o_next = target->next;\n        target->next = node;\n        node->prev = target;\n        node->next = o_next;\n        o_next->prev = node;\n        size_++;\n    }\n\n    void erase(Node* node) {\n        Node* prev = node->prev;\n        Node* next = node->next;\n        prev->next = next;\n        next->prev = prev;\n        node->prev = node->next = nullptr;\n        size_--;\n    }\n\n    Node* head() { return size_ == 0 ? nullptr : d_head_->next; }\n\n    Node* tail() { return size_ == 0 ? nullptr : d_tail_->prev; }\n\n    int size() { return size_; }\n\nprivate:\n    Node* d_head_;\n    Node* d_tail_;\n    int size_ = 0;\n};\n\nclass LRUCache {\npublic:\n    using Node = DList::Node;\n\n    LRUCache(int capacity) : capacity_(capacity) {\n        list_ = new DList();\n    }\n    \n    int get(int key) {\n        Node* node = map_[key];\n        if (!node) return -1;\n\n        list_->erase(node);\n        list_->push_front(node);\n        return node->value;\n    }\n    \n    void put(int key, int value) {\n        Node* node = map_[key];\n        // update existing key\n        if (node) {\n            node->value = value;\n            list_->erase(node);\n            list_->push_front(node);\n            return;\n        }\n\n        // capacity reached. remove outdated key.\n        if (list_->size() == capacity_) {\n            Node* d_node = list_->tail();\n            list_->erase(d_node);\n            map_.erase(d_node->key);\n        }\n\n        // insert new key\n        node = new Node(key, value);\n        map_[key] = node;\n        list_->push_front(node);\n    }\nprivate:\n    int capacity_;\n    DList* list_;\n    unordered_map<int, Node*> map_;\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196185669","body":"https://www.notion.so/suukii/ca5e6d9d43704a9d82e44758636642d6?v=e7bdde0a51e9424fa96b876e78b03958&p=e6f74b3432c04631ab687e89bb50b9d1&pm=s\r\n\r\n## Recursive\r\n\r\n- Time: $O(N)$, N is the total number of tree nodes.\r\n- Time: $O(H)$, H is the depth of the tree.\r\n```cpp\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if (!root) return 0;\r\n        if (!root->left && !root->right) return 1;\r\n        return 1 + max(maxDepth(root->left), maxDepth(root->right));\r\n    }\r\n};\r\n```\r\n\r\n## Iterative\r\n\r\n- Time: $O(N)$\r\n- Space: $O(N)$\r\n```cpp\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        int depth = 0;\r\n        queue<TreeNode*> q;\r\n\r\n        if (root) q.push(root);\r\n\r\n        while (!q.empty()) {\r\n            int size = q.size();\r\n            depth++;\r\n\r\n            while (size--) {\r\n                TreeNode* n = q.front(); q.pop();\r\n                if (n->left) q.push(n->left);\r\n                if (n->right) q.push(n->right);\r\n            }\r\n        }\r\n\r\n        return depth;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197561389","body":"- Time: $O(N)$, N is the number of tree nodes.\n- Space: $O(H)$, H is the height of the tree.\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (!p && !q) return true;\n        if (!p || !q || p->val != q->val) return false;\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199399821","body":"- Time: $O(N)$, N is the number of tree nodes.\n- Space: $O(h)$, h is the height of the tree.\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        return sumNumbers(root, 0);\n    }\nprivate:\n    int sumNumbers(TreeNode* root, int val) {\n        if (!root) return 0;\n        val = val * 10 + root->val;\n        if (!root->left && !root->right) return val;\n        return sumNumbers(root->left, val) + sumNumbers(root->right, val);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200715341","body":"- Time: $O(N)$\r\n- Space: $O(N)$\r\n```cpp\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int findBottomLeftValue(TreeNode* root) {\r\n        int res;\r\n        queue<TreeNode*> q;\r\n        q.push(root);\r\n\r\n        while (!q.empty()) {\r\n            res = q.front()->val;\r\n\r\n            int size = q.size();\r\n            while (size--) {\r\n                TreeNode* node = q.front(); q.pop();\r\n                if (node->left) q.push(node->left);\r\n                if (node->right) q.push(node->right);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200933641","body":"```cpp\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * };\r\n */\r\nclass Codec {\r\npublic:\r\n\r\n    // Encodes a tree to a single string.\r\n    string serialize(TreeNode* root) {\r\n        string res;\r\n        if (!root) return res;\r\n\r\n        queue<TreeNode*> q;\r\n        q.push(root);\r\n        while (!q.empty()) {\r\n            int len = q.size();\r\n            while (len--) {\r\n                TreeNode* node = q.front();\r\n                if (node) {\r\n                    res += to_string(node->val) + ',';\r\n                    q.push(node->left);\r\n                    q.push(node->right);\r\n                } else {\r\n                    res += \"#,\";\r\n                }\r\n                q.pop();\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    TreeNode* deserialize(string data) {\r\n        if (data.empty()) return NULL;\r\n        vector<string> dataArr;\r\n        split(dataArr, data, ',');\r\n        int i = 0;\r\n        TreeNode* root = new TreeNode(stoi(dataArr[i++]));\r\n        queue<TreeNode*> q;\r\n        q.push(root);\r\n        while (!q.empty()) {\r\n            int len = q.size();\r\n            while (len--) {\r\n                TreeNode* node = q.front();\r\n                q.pop();\r\n\r\n                string leftVal = dataArr[i++];\r\n                string rightVal = dataArr[i++];\r\n                if (leftVal != \"#\") {\r\n                    node->left = new TreeNode(stoi(leftVal));\r\n                    q.push(node->left);\r\n                }\r\n                if (rightVal != \"#\") {\r\n                    node->right = new TreeNode(stoi(rightVal));\r\n                    q.push(node->right);\r\n                }\r\n            }\r\n        }\r\n        return root;\r\n    }\r\n    void split(vector<string>& list, const string& s, const char delimiter) {\r\n        list.reserve(s.size());\r\n        size_t start;\r\n        size_t end = 0;\r\n        while ((start = s.find_first_not_of(delimiter, end)) != string::npos) {\r\n            end = s.find(delimiter, start);\r\n            list.push_back(s.substr(start, end - start));\r\n        }\r\n        list.shrink_to_fit();\r\n    }\r\n};\r\n\r\n// Your Codec object will be instantiated and called as such:\r\n// Codec ser, deser;\r\n// TreeNode* ans = deser.deserialize(ser.serialize(root));\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200705573","body":"- Time: $O(NlogN)$, N is the number of tree nodes. The time of traversing the binary tree is $O(N)$ and the time of sorting all the tree nodes is $O(NlogN)$.\n- Space: $O(N)$\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    using Point = tuple<int, int, int>;\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        vector<Point> coordinates;\n        getCoordinates(root, 0, 0, coordinates);\n        sort(coordinates.begin(), coordinates.end(), sortPoints);\n\n        vector<vector<int>> res;\n        res.reserve(coordinates.size());\n        int last_x = INT_MIN;\n        for (const auto& p : coordinates) {\n            auto [x, y, v] = p;\n            if (x > last_x) {\n                res.push_back(vector<int>());\n                last_x = x;\n            }\n            res.back().push_back(v);\n        }\n\n        return res;\n    }\nprivate:\n    void getCoordinates(TreeNode* root, int x, int y, vector<Point>& coordinates) {\n        if (!root) return;\n        coordinates.push_back({x, y, root->val});\n        getCoordinates(root->left, x - 1, y + 1, coordinates);\n        getCoordinates(root->right, x + 1, y + 1, coordinates);\n    }\n\n    static int sortPoints(const Point& a, const Point& b) {\n        auto [ax, ay, av] = a;\n        auto [bx, by, bv] = b;\n        if (ax == bx && ay == by) return av < bv;\n        if (ax == bx) return ay < by;\n        return ax < bx;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202084610","body":"- Time: $O(N)$\n- Space: $O(N)$\n```cpp\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> candidates;\n        for (int i = 0; i < nums.size(); i++) {\n            int diff = target - nums[i];\n            if (candidates.find(diff) != candidates.end())\n                return {candidates[diff], i};\n            candidates[nums[i]] = i;\n        }\n        // NOTREACHED\n        return {};\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203447028","body":"- Time: $O(Nlogk)$, N is the size of `nums`. Every `heapify` operation of a `k` size heap is $O(logK)$.\r\n- Space: $O(N)$. The map uses $O(N)$ and the heap uses $O(k)$.\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    using IntPair = pair<int, int>;\r\n    using IntPairs = vector<IntPair>;\r\n    vector<int> topKFrequent(vector<int>& nums, int k) {\r\n        unordered_map<int, int> freq;\r\n        for (const int& n : nums)\r\n            freq[n]++;\r\n\r\n        // Use a MinHeap to maintain the `k` most frequent elements.\r\n        auto cmp = [](const auto& a, const auto& b) {\r\n            return a.second > b.second;\r\n        };\r\n        priority_queue<IntPair, IntPairs, decltype(cmp)> pq{cmp};\r\n        for (const auto& it : freq) {\r\n            // The top of the heap is the least frequent element for now.\r\n            // Discard it if we have another element who appears more \r\n            // frequent than it.\r\n            if (pq.size() == k && it.second > pq.top().second)\r\n                pq.pop();\r\n            if (pq.size() < k)\r\n                pq.push(make_pair(it.first, it.second));\r\n        }\r\n\r\n        vector<int> res;\r\n        res.reserve(k);\r\n        while (k--) {\r\n            res.emplace_back(pq.top().first);\r\n            pq.pop();\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**Or use a MaxHeap**\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    struct Node {\r\n        int value;\r\n        int count;\r\n        bool operator < (const Node& other) const {\r\n            return count < other.count;\r\n        }\r\n    };\r\n\r\n    vector<int> topKFrequent(vector<int>& nums, int k) {\r\n        unordered_map<int, int> freq;\r\n        for (const int& n : nums)\r\n            freq[n]++;\r\n\r\n        priority_queue<Node> pq;\r\n        for (const auto& it : freq)\r\n            pq.push(Node{it.first, it.second});\r\n\r\n        vector<int> res;\r\n        res.reserve(k);\r\n        while (k--) {\r\n            res.emplace_back(pq.top().value);\r\n            pq.pop();\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204674999","body":"https://leetcode.cn/problems/number-of-boomerangs/solution/447hui-xuan-biao-de-shu-liang-ha-xi-biao-javascrip/\n\n- Time: $O(N^2)$\n- Space: $O(N)$\n```cpp\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        int count = 0;\n\n        for (const auto& a : points) {\n            unordered_map<int, int> dist_map;\n\n            for (const auto& b : points) {\n                int dist = pow(a[0] - b[0], 2) + pow(a[1] - b[1], 2);\n                dist_map[dist]++;\n            }\n\n            for (const auto& [_, n] : dist_map)\n                count += n * (n - 1);\n        }\n\n        return count;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206175901","body":"- Time: $O(N)$\n- Space: $O(N)$\n```cpp\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        unordered_map<char, int> last_saw;\n        int l = 0, r = 0, res = 0;\n\n        while (r < s.size()) {\n            if (last_saw.find(s[r]) != last_saw.end()) {\n                if (last_saw[s[r]] >= l)\n                    l = last_saw[s[r]] + 1;\n            }\n            res = max(res, r - l + 1);\n            last_saw[s[r]] = r;\n            r++;\n        }\n        return res;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mirrors-cl":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185287919","body":"æ€è·¯\r\næŒ‰ç…§ æ­£å¸¸çš„æ‰‹å†™åŠ æ³•çš„é€»è¾‘åšçš„åªæ˜¯å¥½åƒæœºå™¨åŒ–äº†ï¼Œæ„Ÿè§‰è‡ªå·±å¥½å¼±\r\ncode\r\n```\r\nvar addToArrayForm = function(num, k) {\r\nconst res = [] \r\nvar str = k.toString();\r\nvar arr = str.split(\"\")\r\narr = arr.map(Number)\r\nlet carry = 0;\r\nlet l1 = num.length -1\r\nlet l2 = arr.length -1\r\nwhile(l1>=0 || l2>=0){\r\n    let x = l1 < 0 ? 0 : num[l1]\r\n    let y = l2 < 0 ? 0 : arr[l2]\r\n    let sum = x + y + carry\r\n    res.push(sum % 10)\r\n    carry = Math.floor(sum/10)\r\n    l1--\r\n    l2--\r\n}\r\nif(carry != 0 )res.push(carry)\r\nreturn res.reverse()\r\n\r\n};\r\n```\r\nå¤æ‚ç¨‹åº¦\r\n è¿˜æ²¡å­¦ä¼šæ€ä¹ˆç®—åŸºç¡€æœ‰äº›å·®","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189052507","body":"```\nvar MyQueue = function() {\n    this.inarray = []\n    this.outarray2 = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.inarray.push(x)\n\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  const size = this.outarray2.length;\n   if(size) {//pushçš„æ—¶å€™åˆ¤æ–­è¾“å‡ºæ ˆæ˜¯å¦ä¸ºç©º\n       return this.outarray2.pop();//ä¸ä¸ºç©ºåˆ™è¾“å‡ºæ ˆå‡ºæ ˆ\n   }\n   while(this.inarray.length) {//è¾“å‡ºæ ˆä¸ºç©ºï¼Œåˆ™æŠŠè¾“å…¥æ ˆæ‰€æœ‰çš„å…ƒç´ åŠ å…¥è¾“å‡ºæ ˆ\n       this.outarray2.push(this.inarray.pop());\n   }\n   return this.outarray2.pop();\n\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n const x = this.pop();//æŸ¥çœ‹é˜Ÿå¤´çš„å…ƒç´  å¤ç”¨popæ–¹æ³•ï¼Œç„¶ååœ¨è®©å…ƒç´ pushè¿›è¾“å‡ºæ ˆ\n   this.outarray2.push(x);\n   return x;\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n   return !this.inarray.length && !this.outarray2.length\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqy97":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185331610","body":"## é¢˜ç›®æè¿°\nhttps://leetcode.cn/problems/add-to-array-form-of-integer/\n\n## è§£é¢˜æ€è·¯\n\n###é€ä½ç›¸åŠ ï¼Œè®°å½•è¿›ä½\n\n\n####éš¾ç‚¹\n1. æ•°å­—æ€ä¹ˆæŒ‰ä½æ‹†åˆ†\n   * **æ•°å­—ä¸ç”¨æ‹†åˆ†**\n    * **num[i] + k % 10 å…ˆç›¸åŠ å†%10**\n2. æ•°ç»„å’Œæ•°å­—ä½æ•°ä¸åŒæ—¶æ€ä¹ˆå¤„ç†\n   * å¼€å§‹æ‰“ç®—å–ä½æ•°æœ€å¤šçš„ï¼Œå…¶å®åªç”¨å¯¹æ²¡åŠ å®Œçš„æ•°å­—å•ç‹¬å¤„ç†\n3. è¿›ä½å¤„ç†\n    * åŠ åˆ°æ•°å­—ä¸Š\n    \n####jsä»£ç \n```javascript\n  var addToArrayForm = function(num, k) {\n  const res = []\n    \n  for(let i = num.length - 1; i>=0; i--) {\n      let sum = num[i] + k % 10\n      k = Math.floor(k / 10)\n      if (sum > 9) {\n        k++\n        res.push(sum % 10)\n      } else {\n        res.push(sum)\n      }\n  }\n  while(k) {\n      res.push(k%10)\n      k = Math.floor(k/10)\n  }\n  return res.reverse()\n  \n};\n```\n####å¤æ‚åº¦\n* æ—¶é—´å¤æ‚åº¦ O(max(num.length, log k))\n* ç©ºé—´å¤æ‚åº¦ O(1)\n\n## åŠ æ³•æ¨¡ç‰ˆ\n```\nå½“å‰ä½ = (A çš„å½“å‰ä½ + B çš„å½“å‰ä½ + è¿›ä½carry) % 10\n\nwhile ( A æ²¡å®Œ || B æ²¡å®Œ)\nA çš„å½“å‰ä½\nB çš„å½“å‰ä½\n\n    å’Œ = A çš„å½“å‰ä½ + B çš„å½“å‰ä½ + è¿›ä½carry\n\n    å½“å‰ä½ = å’Œ % 10;\n    è¿›ä½ = å’Œ / 10;\n\nåˆ¤æ–­è¿˜æœ‰è¿›ä½å—\n```\n\n\n\n     \n  \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186165018","body":"## é¢˜ç›®æè¿°\nhttps://leetcode.cn/problems/shortest-distance-to-a-character/\n## è§£é¢˜æ€è·¯\n\nè®°å½•å­—ç¬¦cå‡ºç°çš„ä¸‹æ ‡ï¼Œéå†æ¯”è¾ƒæœ€çŸ­è·ç¦»\n\n\n###æˆ‘çš„æš´åŠ›è§£æ³•ï¼ˆğŸ‘ğŸ‘ğŸ‘\n\n####jsä»£ç \n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n        let indexList = []\n        let res = []\n        for(let i = 0; i < s.length; i++) {\n            if (s[i] === c) {\n                indexList.push(i)\n                res[i] = 0\n            }\n        }\n        let k = 0\n        for(let i = 0; i < s.length; i++) {\n            if(!indexList.includes(i)) {\n                while(k+1 < indexList.length && Math.abs( indexList[k] - i) > Math.abs(indexList[k+1] - i)) {\n                    k += 1\n                }\n                res[i] =  Math.abs( indexList[k] - i)\n            }\n        }\n        return res\n    };\n```\n####å¤æ‚åº¦\n* æ—¶é—´å¤æ‚åº¦ O(n)\n* ç©ºé—´å¤æ‚åº¦ O(1)\n\n###å®˜æ–¹é¢˜è§£\n\n- åŒå‘éå†\n- é—®é¢˜å¯ä»¥è½¬æ¢æˆï¼Œå¯¹sçš„æ¯ä¸ªä¸‹æ ‡iï¼Œæ±‚ \\\n    s[i]  åˆ°å…¶å·¦ä¾§æœ€è¿‘çš„å­—ç¬¦ cc çš„è·ç¦»\\\n    s[i]  å…¶å³ä¾§æœ€è¿‘çš„å­—ç¬¦ cc çš„è·ç¦» \\\n  è¿™ä¸¤è€…çš„æœ€å°å€¼ã€‚\n  \n####éš¾ç‚¹ï¼š\nåœ¨å¼€å§‹éå†çš„æ—¶å€™ï¼Œä¸çŸ¥é“ç¬¬ä¸€ä¸ªç­‰äºç›®æ ‡å­—ç¬¦çš„indexåœ¨å“ªï¼Œä¸ºäº†ç®€åŒ–é€»è¾‘ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ -n æˆ– 2n è¡¨ç¤ºï¼Œè¿™é‡Œ n æ˜¯ s çš„é•¿åº¦ã€‚\nç¡®ä¿æ¯ä¸€ä½åˆ°indexçš„è·ç¦» >= n\nå–nçš„è¯ä»å³éå†ï¼Œæœ€å°è·ç¦»ä¸º1\n\n####jsä»£ç \n```javascript\nvar shortestToChar = function(s, c) {\n    let n = s.length\n    let res = new Array(n).fill(0)\n    for(let i = 0, index = 2*n; i < s.length; i++) {\n        if (s[i] === c) {\n            index = i\n        } else {\n            res[i] = Math.abs(i - index)\n        }\n    }\n    \n    for(let i = s.length - 1,index = 2*n; i >= 0; i--) {\n       if (s[i] === c) {\n           index = i\n       } else {\n           res[i] = Math.min(res[i], Math.abs(i - index))\n       }\n    }\n    return res\n};\n```\n####å¤æ‚åº¦\n* æ—¶é—´å¤æ‚åº¦ O(n)\n* ç©ºé—´å¤æ‚åº¦ O(1)\n\n\n\n     \n  \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186513644","body":"## é¢˜ç›®æè¿°\nhttps://leetcode.cn/problems/design-a-stack-with-increment-operation/\n\n## è§£é¢˜æ€è·¯\nç”¨æ•°ç»„æ¨¡æ‹Ÿæ ˆï¼Œç”¨å˜é‡è®°å½•æ ˆé¡¶ä½ç½®\n\n\n####jsä»£ç \n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n        this.res = new Array()\n        this.add = new Array()\n        this.maxSize = maxSize\n        this.top = -1\n    };\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n\n    if (this.top < this.maxSize - 1) {\n        ++this.top\n        this.res[this.top] = x\n        this.add[this.top] = 0\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (this.top >= 0) {\n        const item = this.res[this.top] + this.add[this.top]\n        this.top--\n        return item\n    }\n    return -1\n\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(let i = 0; i < Math.min(k, this.top+1); i++) {\n        this.add[i] +=  val\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n\n####å¤æ‚åº¦\n* æ—¶é—´å¤æ‚åº¦ O(1)\n* ç©ºé—´å¤æ‚åº¦ O(maxSize)\n\n\n\n     \n  \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187622403","body":"### é¢˜ç›®æè¿°\nhttps://leetcode.cn/problems/decode-string/\n\n### è§£é¢˜æ€è·¯\næŠŠ ']' å½“ä½œå‡ºæ ˆä¿¡å·\n\n### ä»£ç \n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    let stack = []\n    const isNum = (n) => Number(n) >= 0 && Number(n) <= 9\n    let res=''\n    for(i=0; i<s.length; i++) {\n        if (s[i] !== ']') {\n            stack.push(s[i])\n        } else {\n            let str=''\n            let num=''\n            let str2=''\n            while(stack[stack.length - 1] !== '[') {\n                str = stack[stack.length - 1] + str\n                stack.length--\n            }\n            stack.length--\n            while(isNum(stack[stack.length - 1])) {\n                num = stack[stack.length - 1] + num\n                stack.length--\n            }\n            while(Number(num) > 0) {\n                str2 = str2 + str\n                num--\n            }\n            stack.push(str2)\n        }\n    }\n    for(i=0;i<stack.length;i++) {\n        res= res+stack[i]\n    }\n    return res\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188559217","body":"var MyQueue = function() {\n    this.stack1 = []\n    this.stack2 = []\n};\nMyQueue.prototype.push = function(x) {\n    this.stack1.push(x)\n};\nMyQueue.prototype.pop = function() {\n    if (!this.stack2.length) {\n        while(this.stack1.length) {\n            const i = this.stack1.pop()\n            this.stack2.push(i)\n        }\n    }\n    return this.stack2.pop()\n};\nMyQueue.prototype.peek = function() {\n    if (!this.stack2.length) {\n        while(this.stack1.length) {\n            const i = this.stack1.pop()\n            this.stack2.push(i)\n        }\n    }\n    return this.stack2[this.stack2.length - 1]\n};\nMyQueue.prototype.empty = function() {\n    return !this.stack1.length && !this.stack2.length\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190452579","body":"## é¢˜ç›®æè¿°\nhttps://leetcode.cn/problems/max-chunks-to-make-sorted-ii/\n\n## è§£é¢˜æ€è·¯\næ¯å—å°½å¯èƒ½åˆ†å°ï¼Œåä¸€å—çš„æ•°å­—å¿…é¡»æ¯”å‰ä¸€å¿«çš„æ•°å­—å¤§ï¼Œ\nå› ä¸ºæœ‰é‡å¤æ•°å­—ï¼Œæ‰€ä»¥é‡å¤æ•°å­—å¯ä»¥å•ç‹¬åˆ†ä¸€å—ï¼Œ\nå› ä¸ºéœ€è¦æ¯”è¾ƒå‰åå…ƒç´ å¤§å°ï¼Œæ‰€ä»¥è”æƒ³åˆ°å•è°ƒæ ˆ\n\n## å•è°ƒé€’å¢æ ˆ\n\n```javascript\nfor (éå†è¿™ä¸ªæ•°ç»„)\n{\n\tif (æ ˆç©º || æ ˆé¡¶å…ƒç´ å¤§äºç­‰äºå½“å‰æ¯”è¾ƒå…ƒç´ ) {\n\t    å…¥æ ˆ;\n\t} else {\n\t    while (æ ˆä¸ä¸ºç©º && æ ˆé¡¶å…ƒç´ å°äºå½“å‰å…ƒç´ ) {\n                æ ˆé¡¶å…ƒç´ å‡ºæ ˆ;\n                æ›´æ–°ç»“æœ;\n\t    }\n\t    å½“å‰æ•°æ®å…¥æ ˆ;\n\t}\n}\n```\n\n## ä»£ç \n```javascript\nvar maxChunksToSorted = function(arr) {\n    let stack = []\n    for(let i = 0; i < arr.length; i++) {\n        if (!stack.length || arr[i] >= stack[stack.length - 1]) {\n            stack.push(arr[i])\n        } else {\n            const last = stack.pop()\n            while(stack[stack.length - 1] > arr[i]) {\n                stack.pop()\n            }\n            stack.push(last)\n        }\n    }\n    return stack.length\n};\n```\n\n##å¤æ‚åº¦\n* æ—¶é—´å¤æ‚åº¦ O(n)\n* ç©ºé—´å¤æ‚åº¦ O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191633395","body":"## é¢˜ç›®æè¿°\nhttps://leetcode.cn/problems/rotate-list/\n\n## è§£é¢˜æ€è·¯\n- æŠŠæœ€åä¸€ä½ç§»åŠ¨åˆ°ç¬¬ä¸€ä½ ===> ç¯å½¢é“¾\n- å‡è®¾é“¾è¡¨é•¿åº¦ä¸ºn, å®é™…ç§»åŠ¨ m*n æ¬¡åï¼Œé“¾è¡¨ä¸å˜\n- ç§»åŠ¨kæ¬¡ï¼Œå®é™…åªéœ€ç§»åŠ¨ k % n æ¬¡\n- æ‰¾åˆ°æ–°é“¾è¡¨çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹æ–­å¼€ ç¬¬ï¼ˆlength - k % nï¼‰ä¸ªèŠ‚ç‚¹.next = null\n\n\n## ä»£ç \n```javascript\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n        if (!head || !head.next || !k) {\n            return head\n        }\n        let len = 1\n        let p = head\n        while(p.next) {\n            len++\n            p = p.next\n        }\n        if (k%len === 0) {\n            return head\n        }\n        p.next = head // å½¢æˆç¯å½¢é“¾\n        let index = len - k % len\n        while(index) {\n            p = p.next\n            index--\n        }\n        let head2 = p.next\n        p.next = null\n        return head2\n    };\n```\n\n##å¤æ‚åº¦\n* æ—¶é—´å¤æ‚åº¦ O(n)\n* ç©ºé—´å¤æ‚åº¦ O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192680754","body":"## é¢˜ç›®æè¿°\nhttps://leetcode.cn/problems/swap-nodes-in-pairs/\n\n## è§£é¢˜æ€è·¯\n- çœ‹ä¼¼ä¸¤ä¸¤äº¤æ¢ï¼Œå®é™…è¦ç”¨åˆ°ä¸‰ä¸ªèŠ‚ç‚¹\n\n## ä»£ç \n```javascript\nvar swapPairs = function(head) {\n    if(!head || !head.next) {\n        return head\n    }\n    let newHead = new ListNode()\n    newHead.next = head\n    let temp = newHead\n   \n    while(temp.next && temp.next.next) {\n        let p1 = temp.next\n        let p2 = temp.next.next\n        \n        p1.next = p2.next\n        temp.next = p2\n        p2.next = p1\n\n        temp = temp.next.next\n        p1 = temp.next\n    }\n\n  \n    return newHead.next\n};\n```\n\n##å¤æ‚åº¦\n* æ—¶é—´å¤æ‚åº¦ O(n)\n* ç©ºé—´å¤æ‚åº¦ O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193138918","body":"## é¢˜ç›®æè¿°\nhttps://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/\n## è§£é¢˜æ€è·¯\n- å¿«æ…¢æŒ‡é’ˆæŸ¥è¯¢é“¾è¡¨ä¸­é—´èŠ‚ç‚¹\n- äºŒåˆ†é€’å½’æ„é€ å­æ ‘\n\n## ä»£ç \n```javascript\nvar sortedListToBST = function trans(head) {\n    const node = {};\n    if (!head) {\n        return null;\n    }\n\n    let slow = head;\n    let fast = head;\n    let last = head;\n\n    while (fast && fast.next) {\n        last = slow;\n        slow = slow.next;\n        fast = fast.next;\n        fast = fast.next;\n    }\n    node.val = slow.val;\n\n    node.left = null;\n\n    if (last !== slow) {\n\n        last.next = null;\n        node.left = trans(head);\n    }\n    node.right = trans(slow.next);\n\n    return node;\n};\n```\n\n## å¤æ‚åº¦\n* æ—¶é—´å¤æ‚åº¦ O(nlogn)\n* ç©ºé—´å¤æ‚åº¦ O(logn)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193344436","body":"## é¢˜ç›®æè¿°\nhttps://leetcode.cn/problems/intersection-of-two-linked-lists/## è§£é¢˜æ€è·¯\n## è§£é¢˜æ€è·¯\n- åŒæŒ‡é’ˆåˆ†åˆ«éå† a->b, b->a, å¦‚æœç›¸é‡åˆ™æœ‰äº¤ç‚¹\n\n## ä»£ç \n```javascript\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function (headA, headB) {\n        if (!headA || !headB) return null;\n\n        let pA = headA,\n            pB = headB;\n        while (pA !== pB) {\n            pA = pA === null ? headB : pA.next;\n            pB = pB === null ? headA : pB.next;\n        }\n        return pA;\n    };\n```\n\n## å¤æ‚åº¦\n* æ—¶é—´å¤æ‚åº¦ O(m+n)\n* ç©ºé—´å¤æ‚åº¦ O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193831461","body":"## é¢˜ç›®æè¿°\nhttps://leetcode.cn/problems/linked-list-cycle-ii/## è§£é¢˜æ€è·¯\n\n## è§£æ³•ä¸€ å“ˆå¸Œè¡¨\n\n### ä»£ç \n```javascript\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n        const list = new Set()\n\n        while(head) {\n            if(list.has(head)){\n\n                return head\n            }\n\n            list.add(head)\n            head = head.next\n\n        }\n        return null\n    };\n```\n\n### å¤æ‚åº¦\n* æ—¶é—´å¤æ‚åº¦ O(n)\n* ç©ºé—´å¤æ‚åº¦ O(n)\n\n## è§£æ³•äºŒ åŒæŒ‡é’ˆ\n\n### è§£é¢˜æ€è·¯\n- å¿«æ…¢æŒ‡é’ˆæ‰¾åˆ°ç›¸é‡ç‚¹ï¼Œå¿«æŒ‡é’ˆé€Ÿåº¦2ï¼Œæ…¢æŒ‡é’ˆé€Ÿåº¦1ï¼Œå¿«æŒ‡é’ˆåœ¨ç¯ä¸­\n  ä»¥é€Ÿåº¦1è¿½é€æ…¢æŒ‡é’ˆï¼Œæ‰€ä»¥å¿«æ…¢æŒ‡é’ˆä¸€å®šä¼šç›¸é‡\n- è®¡ç®—ç›¸é‡ç‚¹åˆ°å…¥ç¯çš„è·ç¦»ï¼ˆæ²¡æƒ³å‡ºæ¥çœ‹çš„ç­”æ¡ˆï¼‰\n\n### ä»£ç \n```javascript\nvar detectCycle = function(head) {\n    if (head === null) {\n        return null;\n    }\n    let slow = head, fast = head;\n    while (fast !== null) {\n        slow = slow.next;\n        if (fast.next !== null) {\n            fast = fast.next.next;\n        } else {\n            return null;\n        }\n        if (fast === slow) {\n            let ptr = head;\n            while (ptr !== slow) {\n                ptr = ptr.next;\n                slow = slow.next;\n            }\n            return ptr;\n        }\n    }\n    return null;\n};\n\n```\n\n### å¤æ‚åº¦\n* æ—¶é—´å¤æ‚åº¦ O(n)\n* ç©ºé—´å¤æ‚åº¦ O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195469342","body":"/**\n * @description è¿æ¥ä¸¤ç‚¹\n * @param {LinkNode} leftNode\n * @param {LinkNode} rightNode\n */\nfunction connect(leftNode, rightNode) {\n  leftNode.right = rightNode;\n  rightNode.left = leftNode;\n}\n\n/**\n * @description ä¸¤ç‚¹ä¸­æ’å…¥ä¸€ç‚¹\n * @param {LinkNode} leftNode\n * @param {LinkNode} rightNode\n * @param {LinkNode} insertNode\n */\nfunction insert(leftNode, rightNode, insertNode) {\n  leftNode.right = insertNode;\n  rightNode.left = insertNode;\n  insertNode.left = leftNode;\n  insertNode.right = rightNode;\n}\n\n/**\n * @param {number} capacity\n */\nvar LRUCache = function (capacity) {\n  this.head = {\n    val: -1,\n    left: null,\n    right: null\n  };\n  this.head.left = this.head.right = this.head;\n  this.array = [];\n  this.capacity = capacity;\n  this.linkLength = 0;\n};\n\n/**\n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function (key) {\n  const node = this.array[key];\n  if (node) {\n    if (node.inLinkList) {\n      const head = this.head;\n      connect(node.left, node.right);\n      insert(head, head.right, node);\n      return node.val;\n    } else {\n      this.array[key] = undefined;\n      return -1;\n    }\n  }\n  return -1;\n};\n\n/**\n * @param {number} key\n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function (key, value) {\n  const head = this.head;\n  if (this.array[key] && this.array[key].inLinkList) {\n    // åŸæ¥æœ‰å€¼çš„\n    const node = this.array[key];\n    // æ›´æ–°å€¼\n    node.val = value;\n    // æåˆ°é“¾è¡¨å¤´\n    connect(node.left, node.right);\n    insert(head, head.right, node);\n  } else {\n    // è¶…è¿‡é•¿åº¦ï¼Œå»æ‰æœ€æœ«å°¾çš„å…ƒç´ \n    if (this.linkLength === this.capacity) {\n      head.left.inLinkList = false;\n      connect(head.left.left, head);\n      this.linkLength--;\n    }\n    // åŸæ¥æ²¡å€¼\n    // ç”ŸæˆèŠ‚ç‚¹\n    const node = {\n      val: value,\n      left: null,\n      right: null,\n      inLinkList: true\n    };\n    this.array[key] = node;\n    this.linkLength++;\n    insert(head, head.right, node);\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196814892","body":"### é¢˜ç›®æè¿°\nhttps://leetcode.cn/problems/maximum-depth-of-binary-tree/\n### è§£é¢˜æ€è·¯\n- é€’å½’DFS\n\n### ä»£ç \n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    if(!root) {\n        return 0\n    }\n    let h1 = 1 + maxDepth(root.left)\n    let h2 = 1 + maxDepth(root.right)\n    return Math.max(h1,h2)\n};\n```\n\n### å¤æ‚åº¦\n* æ—¶é—´å¤æ‚åº¦ O(n)\n* ç©ºé—´å¤æ‚åº¦ O(height) heightä¸ºäºŒå‰æ ‘é«˜åº¦\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197842284","body":"### é¢˜ç›®æè¿°\nhttps://leetcode.cn/problems/same-tree/\n\n### è§£é¢˜æ€è·¯\n- é€’å½’DFS\n\n### ä»£ç \n```javascript\nvar isSameTree = function(p, q) {\n    if(p == null && q == null)\n        return true;\n    if(p == null || q == null)\n        return false;\n    if(p.val != q.val)\n        return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}\n```\n\n### å¤æ‚åº¦\n* æ—¶é—´å¤æ‚åº¦ O(N)\n* ç©ºé—´å¤æ‚åº¦ O(height) heightä¸ºäºŒå‰æ ‘é«˜åº¦, æœ€å·®O(N), æœ€ä¼˜O(logN)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198813541","body":"### é¢˜ç›®æè¿°\nhttps://leetcode.cn/problems/sum-root-to-leaf-numbers/\n\n### è§£é¢˜æ€è·¯\n- é€’å½’DFS\n\n### ä»£ç \n```javascript\nvar sumNumbers = function(root) {\n    let num = ''\n    let list = []\n    let res = 0\n    findNum(root,num, list)\n    list.forEach(i => res += Number(i))\n    return res\n};\n\nvar findNum = function(root, num, list) {\n    if(!root) {\n        return\n    }\n\n    num += root.val\n\n    if (!root.left && !root.right) {\n        list.push(num)\n        return\n    }\n    if (root.left) {\n        findNum(root.left, num, list)\n    }\n    if (root.right) {\n        findNum(root.right, num, list)\n    }\n}\n```\n\n### å¤æ‚åº¦\n* æ—¶é—´å¤æ‚åº¦ O(N)\n* ç©ºé—´å¤æ‚åº¦ O(height) heightä¸ºäºŒå‰æ ‘é«˜åº¦, æœ€å·®O(N), æœ€ä¼˜O(logN)\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201104619","body":"### é¢˜ç›®æè¿°\nhttps://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/\n\n### è§£é¢˜æ€è·¯\n- dfséå†æ¯ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„ï¼ŒcolIndex, rowIndex, value\n- æŒ‰åˆ—ï¼Œè¡Œï¼Œå€¼ï¼ŒæŠŠæ‰€æœ‰èŠ‚ç‚¹æ’åº\n- åŒä¸€è¡ŒåŒä¸€åˆ—çš„èŠ‚ç‚¹æ”¾è¿›ä¸€ä¸ªæ•°ç»„\n\n### ä»£ç \n```javascript\nvar verticalTraversal = function(root) {\n    let nodeList = []\n    dfs(root, 0, 0, nodeList)\n    nodeList.sort((pre, cur) => {\n        if(pre[0] !== cur[0]) {\n            return pre[0] - cur[0]\n        } else if (pre[1] !== cur[1]) {\n            return pre[1] - cur[1]\n        } else {\n            return pre[2] - cur[2]\n        }\n    })\n    let res = []\n    let lastCol = -Number.MAX_VALUE\n    for(let node of nodeList) {\n        if (node[0] !== lastCol) {\n            lastCol = node[0]\n            res.push([])\n        }\n        res[res.length - 1].push(node[2])\n    }\n    return res\n}\n\nconst dfs = (node, row, col, nodes) => {\n    if (node === null) {\n        return;\n    }\n    nodes.push([col, row, node.val]);\n    dfs(node.left, row + 1, col - 1, nodes);\n    dfs(node.right, row + 1, col + 1, nodes);\n}\n```\n\n### å¤æ‚åº¦\n* æ—¶é—´å¤æ‚åº¦ O(nlogn)\n* ç©ºé—´å¤æ‚åº¦ O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202343086","body":"var twoSum = function(nums, target) {\n    const map = new Map();\n    for(let i = 0, len = nums.length;i < len;i++) {\n        if(map.has(target - nums[i])) {\n            return [map.get(target - nums[i]), i];\n        }\n        map.set(nums[i], i);\n    }\n    return [];\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203707607","body":"```javascript\nvar topKFrequent = function(nums, k) {\n    var freq = new Map()\n    // è®°å½•æ¯ä¸ªæ•°å­—å‡ºç°çš„é¢‘ç‡\n    nums.forEach((v) => {\n        if (!freq.has(v)) {\n            freq.set(v, 1)\n        } else {\n            freq.set(v, freq.get(v) + 1)\n        }\n    })\n\n    //æ„å»ºä¸€ä¸ªåªæœ‰kä¸ªå…ƒç´ çš„å°é¡¶å †ç»“æ„heap\n    var heap = [],\n        len = 0\n    freq.forEach((value, key)=>{\n        if (len < k) {\n            heap.push(key)\n            if (len === k - 1) buildHeap(heap, freq, k) //åˆè¯•åŒ–heapä¸ºå †ç»“æ„\n        } else{\n            if (freq.get(heap[0]) < value) {\n                heap[0] = key //å°é¡¶å †çš„é¡¶éƒ¨ä¸ºæœ€å°çš„ï¼Œå¦‚æœæœ‰æ¯”å®ƒæ›´å¤§çš„å°±æ›´æ”¹\n                heapify(heap, freq, k, 0) //æ›´æ”¹å †é¡¶å…ƒç´ ç ´åäº†å †ç»“æ„ï¼Œæ‰§è¡Œheapifyå†æ¬¡å°†æ•°ç»„è½¬æ¢ä¸ºå †\n            }\n        }\n        len++\n    })\n    return heap\n\n};\n\n// æ„é€ å †\nlet buildHeap = (heap, map, k) => {\n    for (let i = Math.floor(k / 2); i >= 0; i--) {\n        heapify(heap, map, k, i)\n    }\n}\n\n// å°†æ•°ç»„å˜ä¸ºå †ç»“æ„\nlet heapify = (heap, freq, k, i) => {\n    var left = 2 * i + 1, //içš„å·¦å­èŠ‚ç‚¹\n        right = 2 * i + 2, //içš„å³å­èŠ‚ç‚¹\n        min = i\n    if (freq.get(heap[left]) < freq.get(heap[min]) && left < k) {\n        min = left\n    }\n    if (freq.get(heap[right]) < freq.get(heap[min]) && right < k) {\n        min = right\n    }\n    if (min !== i) {\n        ;[heap[i], heap[min]] = [heap[min], heap[i]]\n        heapify(heap, freq, k, min)\n    }\n}\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jakkiabc":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185338763","body":"è‡ªå·±ç”¨è¿›ä½éå†çš„æ–¹æ³•æ²¡è·‘å‡ºæ¥ï¼Œå¾…ä¼šå†æƒ³æƒ³= =\r\næš‚æ—¶ç”¨  listâ†’strâ†’int æ¥è®¡ç®—sum æœ€åå†è½¬æ¢å›list \r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n=int(''.join([str(x)for x in num]))\r\n        sum=n+k\r\n        return list(map(int,str(sum)))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186190071","body":"å…ˆæ‰¾åˆ°ç›¸åŒå…ƒç´ çš„ä½ç½®ï¼Œç„¶ååˆ†åˆ«å‘å·¦å‘å³éå†æ‰¾åˆ°minæœ€å°è·ç¦»\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n=len(s)\r\n        start=[0 if a==c else n for a in s]\r\n        for i in range(1,n):\r\n            start[i]=min(start[i],start[i-1]+1)\r\nfor i in range(n-2,-1,-1):\r\n            start[i]=min(start[i],start[i+1]+1)\r\n        return start","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186551571","body":"æ€è·¯ï¼šå·®åˆ†æ•°ç»„\r\n`\r\n\r\nclass CustomStack:\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.nums = []\r\n\r\n    def push(self, x: int) -> None:\r\n      \r\n        if not self.nums:\r\n            self.nums.append(x)\r\n        else:\r\n            self.nums[-1] = self.nums[-1] - x\r\n            self.nums.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.nums:\r\n            return -1\r\n        x = self.nums.pop()\r\n        if self.nums:\r\n            self.nums[-1] += x\r\n        return x\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if not self.nums:\r\n            return\r\n        if len(self.nums) >= k:\r\n            self.nums[k - 1] += val\r\n        else:\r\n            self.nums[-1] += val\r\n\r\n`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187667410","body":"åˆ©ç”¨æ ˆçš„æ€§è´¨ï¼ˆå‚è€ƒé¢˜è§£ \r\n\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = \"\", 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)            \r\n            else:\r\n                res += c\r\n        return res\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191387810","body":"æ€è·¯ï¼šåŒæŒ‡é’ˆéå†\r\n``\r\n\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n        len=0\r\n        tail=head\r\n        while tail:\r\n            len+=1\r\n            tail=tail.next //æ±‚é“¾è¡¨é•¿åº¦\r\n        k %=len \r\n        if k==0:\r\n            return head\r\n        fast,slow=head,head åŒæŒ‡é’ˆéå†\r\n        while k:\r\n            fast=fast.next\r\n            k-=1  //fastä¸slowè·ç¦»k\r\n        while fast.next:\r\n            fast=fast.next\r\n            slow=slow.next \r\n        newHead=slow.next //æ–°èŠ‚ç‚¹\r\n        slow.next=None æŒ‡å‘å°¾ç«¯\r\n        fast.next=head\r\n        return newHead``","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192654637","body":"> æ€è·¯ï¼šåˆ©ç”¨è¿­ä»£\r\n\r\n`\r\n   \r\n      def swapPairs(self, head):\r\n             p=ListNode(-1)\r\n             a,b,p.next,tmp=p,p,head,p //åˆå§‹åŒ–\r\n             while b.next and b.next.next:\r\n                 a,b=a.next,b.next.next  //è¿›ä½\r\n                 tmp.next,a.next,b.next=b,b.next,a //a,b äº¤æ¢ \r\n                 tmp,b=a,a\r\n             return p.next`\r\n\r\n> æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n\r\n> ç©ºé—´å¤æ‚åº¦ï¼šO(1)`","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195074679","body":"ä¸å¤ªä¼šï¼Œå‚è€ƒé¢˜è§£\r\næ€è·¯ï¼šåŒå‘é“¾è¡¨ï¼‹å“ˆå¸Œè¡¨å®ç°-\r\n`\r\nclass ListNode:\r\n    def __init__(self, key = 0, val = 0):\r\n        self.key = key\r\n        self.val = val\r\n        self.prev = None\r\n        self.next = None\r\n\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.hashmap = {}\r\n        self.head = ListNode()\r\n        self.tail = ListNode()\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n    \r\n    def remove_node(self, node):\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n    \r\n    def add_node_to_last(self, node):\r\n        self.tail.prev.next = node\r\n        node.prev = self.tail.prev\r\n        node.next = self.tail\r\n        self.tail.prev = node\r\n    \r\n    def move_node_to_last(self, node):\r\n        self.remove_node(node)\r\n        self.add_node_to_last(node)\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.hashmap:\r\n            return -1\r\n        node = self.hashmap[key]\r\n        self.move_node_to_last(node)\r\n        return node.val\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.hashmap:\r\n            node = self.hashmap[key]\r\n            node.val = value\r\n            self.move_node_to_last(node)\r\n            return\r\n        if len(self.hashmap) == self.capacity:\r\n            del self.hashmap[self.head.next.key]\r\n            self.remove_node(self.head.next)\r\n        node = ListNode(key, value)\r\n        self.hashmap[key] = node\r\n        self.add_node_to_last(node)\r\n\r\n`\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196404079","body":"åˆšå¼€å§‹å­¦äºŒå‰æ ‘ï¼Œæ„Ÿå—åˆ°äº†é€’å½’çš„å¼ºå¤§\r\n`\r\n\r\n    def maxDepth(self, root):\r\n        if root is None: \r\n            return 0 \r\n        else: \r\n            left_height = self.maxDepth(root.left) \r\n            right_height = self.maxDepth(root.right) \r\n            return max(left_height, right_height) + 1 \r\n`\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197759112","body":"`\r\n\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        elif not p or not q:\r\n            return False\r\n        elif p.val != q.val:\r\n            return False\r\n        else:\r\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n`\r\n\r\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200896599","body":"`    \r\n\r\n> class Solution:\r\n\r\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\r\n        # DFSæ±‚åæ ‡\r\n        hashmap = collections.defaultdict(list)\r\n        def dfs(node, j, i):\r\n            if not node:\r\n                return\r\n            hashmap[(j, i)].append(node.val)\r\n            dfs(node.left, j - 1, i + 1)\r\n            dfs(node.right, j + 1, i + 1)\r\n        dfs(root, 0, 0) # æ’åº\r\n        res, tmp= [], []\r\n        j_flag = -1001\r\n        for j, i in sorted(hashmap.keys()):\r\n            if j != j_flag:\r\n                res.append(tmp)\r\n                tmp = []\r\n                j_flag = j\r\n            tmp.extend(sorted(hashmap[(j, i)]))\r\n        res.pop(0)\r\n        res.append(tmp)\r\n        return res`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202031476","body":"`\r\n\r\n    def twoSum(self, nums, target):\r\n        n=len(nums)\r\n        matrix=[]\r\n        for i in range(0,n):\r\n            for j in range(i+1,n):\r\n                if nums[i]+nums[j] == target:\r\n                    return[i,j]\r\n                    break`\r\n\r\n\r\n`\r\n   \r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        hashtable = dict()\r\n        for i, num in enumerate(nums):\r\n            if target - num in hashtable:\r\n                return [hashtable[target - num], i]\r\n            hashtable[nums[i]] = i\r\n        return`","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206273477","body":"```python\r\nclass Solution(object):\r\n    def lengthOfLongestSubstring(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: int\r\n        \"\"\"\r\n        window=set()\r\n        n=len(s)\r\n        right,left=-1,0\r\n        for i in range(n):\r\n            if i!=0:\r\n                window.remove(s[i-1])\r\n            while right+1<n and s[right+1] not in window:\r\n                window.add(s[right+1])\r\n                right+=1\r\n            left=max(left,right-i+1)  \r\n        return left\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyoneday":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185356088","body":"## æ€è·¯\r\n\r\n0 <= K <= 10000ï¼Œå¯ç›´æ¥åŠ  1ï¼Œä¸éœ€è¦å¤§æ•°ç›¸åŠ \r\n\r\n## ä»£ç  js\r\n\r\n```js\r\nvar addToArrayForm = function (num, K) {\r\n    const len = num.length || 0;\r\n    let numK = K;\r\n    const result = [];\r\n\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        const a = num[i];\r\n        const b = numK % 10;\r\n       \r\n        let total = a + b;\r\n        numK = total >= 10 ? parseInt(numK / 10) + 1 : parseInt(numK / 10);\r\n        result[i] = total % 10;\r\n    }\r\n    while (numK > 0) {\r\n        result.unshift(numK % 10);\r\n        numK = parseInt(numK / 10);\r\n    }\r\n\r\n    return result;\r\n}\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\næ—¶é—´å¤æ‚åº¦: O(n)\r\nç©ºé—´å¤æ‚åº¦: O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186194360","body":"## æ€è·¯\r\n\r\nä»å·¦å‘å³éå†ï¼Œè®°å½•å­—ç¬¦å³ä¾§çš„è·ç¦»ï¼›ä»å³å‘å·¦éå†ï¼Œè·å–å­—ç¬¦å·¦ä¾§çš„è·ç¦»å’Œä¹‹å‰è·ç¦»çš„è¾ƒå°å€¼ã€‚\r\n\r\n## ä»£ç  js\r\n\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n  const tempArr = [];\r\n  const len = s.length;\r\n  let idx = -1;\r\n  for (let i = 0; i < len; i++) {\r\n    if (s[i] === c) {\r\n      idx = i;\r\n      tempArr[i] = 0;\r\n    } else if (idx === -1) {\r\n      tempArr[i] = Infinity;\r\n    } else {\r\n      tempArr[i] = i - idx;\r\n    }\r\n  }\r\n\r\n  idx = Infinity;\r\n  for (let i = len - 1; i > -1; i--) {\r\n    const val = tempArr[i];\r\n\r\n    if (s[i] === c) {\r\n      idx = i;\r\n    } else if (val > idx - i) {\r\n      tempArr[i] = idx - i ;\r\n    }\r\n  }\r\n\r\n  return tempArr;\r\n};\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n- æ—¶é—´å¤æ‚åº¦ O(n)\r\n- ç©ºé—´å¤æ‚åº¦ O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186497063","body":"## æ€è·¯\r\n\r\næ•°æ®æ¨¡æ‹Ÿæ ˆã€‚\r\n\r\n## ä»£ç  js\r\n\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\n var CustomStack = function(maxSize) {\r\n  this.stack = [];\r\n  this.size = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  if (this.stack.length < this.size) {\r\n    this.stack.push(x);\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  if (this.stack.length === 0) {\r\n    return -1;\r\n  } else {    \r\n    return this.stack.pop();\r\n  }\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  const len = k > this.stack.length ? this.stack.length : k;\r\n  for (let i = 0; i < len; i++) {\r\n    this.stack[i] += val;\r\n  }\r\n};\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n- æ—¶é—´å¤æ‚åº¦:  push, pop = O(1), increment = O(min(k, length))\r\n- ç©ºé—´å¤æ‚åº¦:  O(maxSize)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187015228","body":"## æ€è·¯ \r\n\r\nå­—ç¬¦å…¥æ ˆï¼Œé‡åˆ° `]` å‡ºæ ˆ\r\n\r\n## ä»£ç  js\r\n\r\n```js\r\nvar decodeString = function(s) {\r\n    const stack = [];\r\n\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] !== ']') {\r\n            stack.push(s[i]);\r\n        } else {\r\n            let result = \"\";\r\n            let tempStr = \"\";\r\n            let num = \"\";\r\n            while (stack[stack.length - 1] !== '[') {\r\n                const c = stack.pop();\r\n                tempStr = c + tempStr;\r\n            }\r\n            stack.pop();\r\n            while (/\\d/.test(stack[stack.length - 1]) && stack.length >= 0) {\r\n                const n = stack.pop();\r\n                num = n + num;\r\n            }\r\n            \r\n            for (let i = 0; i < +num; i++) {\r\n                result += tempStr;\r\n            }\r\n\r\n            for (let j = 0; j < result.length; j++) {\r\n                stack.push(result[j]);\r\n            }\r\n        }\r\n    }\r\n    \r\n    return stack.join(\"\");\r\n};\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n- æ—¶é—´å¤æ‚åº¦ O(n)ï¼Œ n ä¸ºè§£ç åçš„å­—ç¬¦ä¸²é•¿åº¦\r\n- ç©ºé—´å¤æ‚åº¦ O(n)ï¼Œ n ä¸ºè§£ç åçš„å­—ç¬¦ä¸²é•¿åº¦","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188548383","body":"## æ€è·¯\r\n\r\nç”¨ä¸¤ä¸ªæ ˆæ¨¡æ‹Ÿé˜Ÿåˆ—\r\n\r\n## ä»£ç  js\r\n\r\n```js\r\nvar MyQueue = function() {\r\n    this.stack = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    const temStack = [];\r\n    const len = this.stack.length;\r\n    for (let i = 0; i < len; i++) {\r\n        temStack.push(this.stack.pop());\r\n    }\r\n    const res = temStack.pop();\r\n    const len2 = temStack.length;\r\n    for (let j = 0; j < len2; j++) {\r\n        this.stack.push(temStack.pop());\r\n    }\r\n\r\n    return res;\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    const temStack = [];\r\n    const len = this.stack.length;\r\n    for (let i = 0; i < len; i++) {\r\n        temStack.push(this.stack.pop());\r\n    }\r\n    const res = temStack[len - 1];\r\n    for (let j = 0; j < len; j++) {\r\n        this.stack.push(temStack.pop());\r\n    }\r\n\r\n    return res;\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.stack.length === 0;\r\n};\r\n\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n- æ—¶é—´å¤æ‚åº¦ O(n)\r\n- ç©ºé—´å¤æ‚åº¦ O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190345234","body":"## æ€è·¯\r\n\r\nä½¿ç”¨å•è°ƒæ ˆï¼Œé‡åˆ°å¤§äºç­‰äºæ ˆé¡¶å…ƒç´ ç›´æ¥åŠ å…¥æ ˆã€‚\r\n\r\n## ä»£ç  js\r\n\r\n```js\r\nvar maxChunksToSorted = function (arr) {\r\n  const stack = [];\r\n  for (let i = 0; i < arr.length; i++) {\r\n    const lastMax = stack[stack.length - 1];\r\n    if (i === 0) {\r\n      stack.push(arr[i]);\r\n    } else if (arr[i] >= stack[stack.length - 1]) {\r\n      stack.push(arr[i]);\r\n    } else {\r\n      while (arr[i] < stack[stack.length - 1] && stack.length) {\r\n        stack.pop()\r\n      }\r\n      stack.push(lastMax)\r\n    }\r\n  }\r\n  return stack.length;\r\n};\r\n```\r\n\r\n## å¤æ‚åº¦åˆ†æ\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191111224","body":"## æ€è·¯\r\n\r\nå…ˆæ‹¿åˆ°é•¿åº¦ï¼Œé€šè¿‡æ—‹è½¬å€¼è®¡ç®—å‡ºéœ€è¦æˆªæ–­çš„éƒ¨åˆ†ã€‚\r\n\r\n## ä»£ç  js\r\n\r\n```js\r\nvar rotateRight = function (head, k) {\r\n  if (!(head && head.next)) return head;\r\n  if (k === 0) return head;\r\n  let node = head;\r\n  const node4 = head;\r\n  let len = 1;\r\n  while (node.next) {\r\n    len++;\r\n    node = node.next\r\n  }\r\n\r\n    let newLen = k % len === 0 ? 0 : Math.abs(len - k % len);\r\n  if (newLen === 0) return node4;\r\n  while (newLen > 1) {\r\n    newLen--;\r\n    head = head.next;\r\n  }\r\n\r\n  let node3 = head.next;\r\n  head.next = null;\r\n  const node5 = node3;\r\n\r\n  while (node3 && node3.next) {\r\n    node3 = node3.next;\r\n  }\r\n  if (node3) {\r\n    node3.next = node4;\r\n  }\r\n \r\n  return node5;\r\n};\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n- æ—¶é—´å¤æ‚åº¦: O(n)\r\n- ç©ºé—´å¤æ‚åº¦: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192669066","body":"## ä»£ç  js\r\n\r\n```js\r\nvar swapPairs = function(head) {\r\n    if (!head || !head.next) {\r\n        return head\r\n    }\r\n    let prev = head.next\r\n    let next = head\r\n    let tmp = prev.next\r\n    head = head.next\r\n    while (next.next) {\r\n        prev.next = next\r\n        next.next = tmp ? (tmp.next || tmp) : null\r\n        if (tmp) {\r\n            prev = tmp.next\r\n            next = tmp\r\n            tmp = prev ? prev.next : null\r\n        }\r\n    }\r\n    return head\r\n};\r\n```\r\n\r\n## å¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193141212","body":"## æ€è·¯ \r\n\r\né€’å½’å¯»æ‰¾ä¸­é—´èŠ‚ç‚¹ä½œä¸ºæ ¹èŠ‚ç‚¹ã€‚\r\n\r\n## ä»£ç  js\r\n\r\n```js\r\nvar sortedListToBST = function (head) {\r\n  if (!head) return null;\r\n  if (head && !head.next) {\r\n    return new TreeNode(head.val);\r\n  }\r\n\r\n\r\n  function buildTree(head, tail) {\r\n    if (head === tail) return null;\r\n    const mid = findMid(head, tail);\r\n   \r\n    const topNode = new TreeNode(mid.val);\r\n    topNode.left = buildTree(head, mid);;\r\n    topNode.right = buildTree(mid.next, tail);;\r\n    return topNode;\r\n  }\r\n\r\n  function findMid(head, tail) {\r\n    let slow = head;\r\n    let fast = head;\r\n  \r\n    while (fast !== tail && fast.next !== tail) {\r\n      slow = slow.next;\r\n      fast = fast.next.next;\r\n    }\r\n\r\n    return slow;\r\n  }\r\n\r\n  return buildTree(head, null);\r\n};\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š O(NlogN)\r\n- ç©ºé—´å¤æ‚åº¦ï¼š O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193322360","body":"## æ€è·¯\r\n\r\nA é“¾è¡¨éå†å®Œåéå† B é“¾è¡¨ï¼ŒB é“¾è¡¨éå†å®Œåéå† A é“¾è¡¨ï¼Œæœ‰ç›¸åŒçš„èŠ‚ç‚¹å³ä¸ºé‡å¤èŠ‚ç‚¹\r\n\r\n## ä»£ç \r\n\r\n```js\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let node1 = headA, node2 = headB;\r\n    while (node1 != node2) {\r\n        node1 = node1 ? node1.next : headB;\r\n        node2 = node2 ? node2.next : headA;\r\n    }\r\n    return node1;\r\n};\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n) n ä¸º ä¸¤é“¾è¡¨é•¿åº¦ä¹‹å’Œ\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193966691","body":"## ä»£ç  js\r\n\r\n```js\r\nvar detectCycle = function(head) {\r\n    let slow = fast = head\r\n    while(fast !== null && fast.next !== null) {\r\n        slow = slow.next\r\n        fast = fast.next.next\r\n        if (slow === fast) {\r\n            break\r\n        }\r\n    }\r\n    if (fast == null || fast.next == null) {\r\n        return null\r\n    }\r\n    slow = head\r\n    while(slow !== fast) {\r\n        slow = slow.next\r\n        fast = fast.next\r\n    }\r\n    return slow\r\n};\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195363707","body":"## æ€è·¯\r\n\r\njs å¯ä»¥ç›´æ¥ç”¨ map æ¥å®ç°è¿™ä¸ªåŠŸèƒ½\r\n\r\n## ä»£ç  js\r\n\r\n```js\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function(capacity) {\r\n  this.map = new Map();\r\n  this.size = capacity;\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n    let val = this.map.get(key)\r\n    if (val !== undefined) {\r\n        this.map.delete(key)\r\n        this.map.set(key, val);\r\n        return val\r\n    }\r\n    \r\n     return -1;\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n    if (this.map.has(key)) {\r\n        this.map.delete(key);\r\n    } else if (this.map.size >= this.size) {\r\n        const k = this.map.keys().next().value;\r\n        this.map.delete(k);\r\n    }\r\n  \r\n    this.map.set(key, value);\r\n};\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š O(1)\r\n- ç©ºé—´å¤æ‚åº¦ï¼š O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196296575","body":"## æ€è·¯\r\n\r\né€’å½’è·å–å­æ ‘é«˜åº¦ï¼Œå–å·¦è¾¹å³è¾¹æœ€å¤§å€¼\r\n\r\n## ä»£ç  js\r\n\r\n```js\r\nvar maxDepth = function(root) {\r\n    if (root) {\r\n        const lefttLen = maxDepth(root.left) || 0;\r\n        const rightLen = maxDepth(root.right) || 0;\r\n        return lefttLen > rightLen ? lefttLen + 1 : rightLen + 1;\r\n    } else return 0;\r\n};\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(h)  hä¸ºæ ‘çš„é«˜åº¦","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197678595","body":"## æ€è·¯\r\n\r\né€’å½’æ¯”è¾ƒ\r\n\r\n## ä»£ç  js\r\n\r\n```js\r\nvar isSameTree = function(p, q) {\r\n   if (p === null && q === null) return true;\r\n   if (p && (q === null)) return false;\r\n   if (q && (p === null)) return false;\r\n   return  p.val === q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n};\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199355337","body":"## æ€è·¯\r\n\r\né€’å½’æ‹¼æ¥å…ƒç´ åç›¸åŠ ã€‚\r\n\r\n## ä»£ç  js\r\n\r\n```js\r\nvar sumNumbers = function(root) {\r\n  return dfs(root, '');\r\n\r\n  function dfs(root, prefix) {\r\n    if (!root) return 0;\r\n    const newP = prefix + root.val;\r\n    if (!root.left && !root.right) {\r\n      return newP;\r\n    }\r\n \r\n    const left = dfs(root.left, newP);\r\n    const right = dfs(root.right, newP); \r\n  \r\n    return +left + +right;\r\n  }\r\n};\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(h)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200104915","body":"## æ€è·¯\r\n\r\nä»å³å‘å·¦bfsï¼Œæ‹¿åˆ°æœ€åä¸€ä¸ª\r\n\r\n## ä»£ç  js\r\n\r\n```js\r\nvar findBottomLeftValue = function(root) {\r\n  let queue = [], temp = [];\r\n  if (!root) {\r\n    return null;\r\n  }\r\n  queue.push(root);\r\n  while(queue.length) {\r\n    const top = queue.shift();\r\n    if (top.right) {\r\n      queue.push(top.right);\r\n    }\r\n    if (top.left) {\r\n      queue.push(top.left)\r\n    }\r\n    temp.push(top.val);\r\n  }\r\n\r\n  return temp[temp.length - 1];\r\n};\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š O(n) \r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200364544","body":"## æ€è·¯\r\n\r\nbfs\r\n\r\n## ä»£ç  js\r\n\r\n```js \r\n\r\nfunction serialize(root) {\r\n  if (!root) return ''\r\n  const data = []\r\n  const queue = [root]\r\n\r\n  while (queue.length) {\r\n    const node = queue.shift()\r\n    if (node) {\r\n      data.push(node.val)\r\n      queue.push(node.left)\r\n      queue.push(node.right)\r\n    } else {\r\n      data.push('#')\r\n    }\r\n  }\r\n  return data.join(',')\r\n}\r\n\r\n\r\nfunction deserialize(data) {\r\n  if (!data) return null\r\n  const list = data.split(',')\r\n  const root = new TreeNode(list.shift())\r\n  const queue = [root]\r\n  \r\n  while (queue.length) {\r\n    const node = queue.shift()\r\n \r\n    const leftVal = list.shift()\r\n    if (leftVal !== \"#\") {\r\n      node.left = new TreeNode(leftVal)\r\n      queue.push(node.left)\r\n    }\r\n   \r\n    const rightVal = list.shift()\r\n    if (rightVal !== \"#\") {\r\n      node.right = new TreeNode(rightVal)\r\n      queue.push(node.right)\r\n    }\r\n  }\r\n  return root\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201061646","body":"## æ€è·¯\r\n\r\nï¼ˆæŠ„çš„é¢˜è§£ï¼Œå¤ªèœäº†è¿™ä¸ªä¸å¤ªä¼š\r\n\r\n## ä»£ç  js\r\n\r\n```js\r\nvar verticalTraversal = function (root) {\r\n  if (!root) return [];\r\n\r\n  // åæ ‡é›†åˆä»¥ x åæ ‡åˆ†ç»„\r\n  const pos = {};\r\n  // dfs éå†èŠ‚ç‚¹å¹¶è®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„åæ ‡\r\n  dfs(root, 0, 0);\r\n\r\n  // å¾—åˆ°æ‰€æœ‰èŠ‚ç‚¹åæ ‡åï¼Œå…ˆæŒ‰ x åæ ‡å‡åºæ’åº\r\n  let sorted = Object.keys(pos)\r\n    .sort((a, b) => +a - +b)\r\n    .map((key) => pos[key]);\r\n\r\n  // å†ç»™ x åæ ‡ç›¸åŒçš„æ¯ç»„èŠ‚ç‚¹åæ ‡åˆ†åˆ«æ’åº\r\n  sorted = sorted.map((g) => {\r\n    g.sort((a, b) => {\r\n      // y åæ ‡ç›¸åŒçš„ï¼ŒæŒ‰èŠ‚ç‚¹å€¼å‡åºæ’\r\n      if (a[0] === b[0]) return a[1] - b[1];\r\n      // å¦åˆ™ï¼ŒæŒ‰ y åæ ‡é™åºæ’\r\n      else return b[0] - a[0];\r\n    });\r\n    // æŠŠ y åæ ‡å»æ‰ï¼Œè¿”å›èŠ‚ç‚¹å€¼\r\n    return g.map((el) => el[1]);\r\n  });\r\n\r\n  return sorted;\r\n\r\n  // *********************************\r\n  function dfs(root, x, y) {\r\n    if (!root) return;\r\n\r\n    x in pos || (pos[x] = []);\r\n    // ä¿å­˜åæ ‡æ•°æ®ï¼Œæ ¼å¼æ˜¯: [y, val]\r\n    pos[x].push([y, root.val]);\r\n\r\n    dfs(root.left, x - 1, y - 1);\r\n    dfs(root.right, x + 1, y - 1);\r\n  }\r\n};\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(NlogN)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202063131","body":"## æ€è·¯\r\n\r\nå°†å·²ç»éå†è¿‡çš„å…ƒç´ åŠ åˆ° `hashMap`\r\n\r\n## ä»£ç  js\r\n\r\n```js\r\nvar twoSum = function (nums, target) {\r\n    const hashMap = new Map();\r\n  \r\n    const result = [];\r\n  \r\n    for (let i = 0; i < nums.length; i++) {\r\n      const item = target - nums[i];\r\n      if (hashMap.has(item)) {\r\n        result.push(i, hashMap.get(item));\r\n        break;\r\n      } else {\r\n        hashMap.set(nums[i], i);\r\n      }\r\n    }\r\n  \r\n    return result;\r\n  };\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203910477","body":"## æ€è·¯\r\n\r\nå…ˆéå†è®°å½•æ¬¡æ•°ï¼Œå†è¿›è¡Œæ’åºã€‚\r\n\r\n## ä»£ç  js\r\n\r\n```js\r\n\r\n var topKFrequent = function(nums, k) {\r\n   const map = new Map();\r\n   for (let i = 0; i < nums.length; i++) {\r\n        if(map.has(nums[i])){\r\n            let count = map.get(nums[i]);\r\n            map.set(nums[i],++count);\r\n        }else{\r\n            map.set(nums[i],1);\r\n        }\r\n   }\r\n   let arr = [...map];\r\n    const res = [];\r\n    arr.sort((a,b) => b[1] - a[1]);\r\n    for(let j = 0; j < k; j++){\r\n        res.push(arr[j][0]);\r\n    }\r\n    return res;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205404495","body":"## ä»£ç  js\r\n\r\n```js\r\nvar numberOfBoomerangs = function(points) {\r\n    let res = 0\r\n    for ( const p of points) {\r\n        const map = new Map()\r\n        for(const q of points) {\r\n            const dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1])\r\n            map.set(dis, (map.get(dis) || 0) + 1)\r\n        }\r\n        for(const [_, m] of map.entries()) {\r\n           res += m * (m - 1) \r\n        }\r\n    }\r\n    return res\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206136187","body":"## æ€è·¯\r\n\r\nåŒæŒ‡é’ˆï¼Œä¿è¯æŒ‡é’ˆé—´å…ƒç´ å”¯ä¸€\r\n\r\n## ä»£ç  js\r\n\r\n```js\r\nvar lengthOfLongestSubstring = function (s) {\r\n  if (!s.length) return 0;\r\n  const codeSet = new Set([]);\r\n\r\n  let maxLen = 0;\r\n\r\n  let prev = 0;\r\n  let cur = 0;\r\n\r\n  while (cur < s.length) {\r\n    const curCode = s[cur];\r\n\r\n    if (!codeSet.has(curCode)) {\r\n      codeSet.add(curCode);\r\n      cur++;\r\n    } else {\r\n      while (s[prev] !== curCode) {\r\n        codeSet.delete(s[prev++]);\r\n      }\r\n\r\n      prev++;\r\n      cur++;\r\n    }\r\n\r\n    maxLen = Math.max(maxLen, codeSet.size);\r\n  }\r\n\r\n  return maxLen;\r\n};\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š O(n)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207223126","body":"## ä»£ç  js\r\n\r\n```js\r\nvar findSubstring = function(s, words) {\r\n    const wordSize = words[0].length\r\n    const substringLen = wordSize * words.length\r\n\r\n    const wordsCount = {}\r\n    words.forEach(w => (wordsCount[w] = (wordsCount[w] || 0) + 1))\r\n\r\n    const res = []\r\n    for (let i = 0; i <= s.length - substringLen; i++) {\r\n        const tempCount = {...wordsCount}\r\n        let count = words.length\r\n\r\n        for (let j = i; j < i + substringLen; j += wordSize) {\r\n            const word = s.slice(j, j + wordSize)\r\n\r\n            if (!(word in tempCount) || tempCount[word] <= 0) break\r\n\r\n            tempCount[word]--\r\n            count--\r\n        }\r\n\r\n        if (count === 0) res.push(i)\r\n    }\r\n    return res\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207332293","body":"## ä»£ç  js\r\n\r\n```js\r\nvar floorMod = function (a, b) {\r\n  return ((a % b) + b) % b;\r\n};\r\nvar solution = function(nums, k) {\r\n  var map = new Map();\r\n  map.set(0, -1);\r\n  var res = nums.length;\r\n  var target = 0;\r\n  var currSum = 0;\r\n  for (let i = 0; i < nums.length; i++) {\r\n     target += nums[i];\r\n  }\r\n  target = target % k;\r\n  for (let i = 0; i < nums.length; i++) {\r\n    currSum = (nums[i] + currSum) % k;\r\n    map.set(currSum, i);\r\n    var prevSum = floorMod(currSum - target, k);\r\n    if (map.has(prevSum)) {\r\n      res = Math.min(res, i - map.get(prevSum));\r\n    }\r\n  }\r\n  return res === nums.length ? -1 : res;\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207666186","body":"## æ€è·¯\r\n\r\nå¿«æŒ‡é’ˆä¸€æ¬¡ä¸¤æ­¥ï¼Œæ…¢æŒ‡é’ˆä¸€æ¬¡ä¸€æ­¥ã€‚\r\n\r\n## ä»£ç  js\r\n\r\n```js\r\nvar middleNode = function(head) {\r\n\r\n    let slow = head, fast = head;\r\n\r\n    while(fast && fast.next) {\r\n        fast = fast.next.next;\r\n        slow = slow.next;\r\n    }\r\n\r\n    return slow;\r\n};\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208898288","body":"## æ€è·¯\r\n\r\nå¿«æ…¢æŒ‡é’ˆã€‚å¦‚æœé‡å¤å¿«æŒ‡é’ˆä¸€ç›´å¾€åã€‚\r\n\r\n## ä»£ç  js\r\n\r\n```js\r\nvar removeDuplicates = function(nums) {\r\n    if (nums.length === 1) return 1;\r\n    let slow = 0, fast = 1;\r\n\r\n    while (fast < nums.length) {\r\n        if(nums[fast] === nums[slow]) {\r\n            fast++;\r\n        } else {\r\n            slow++;\r\n            if (nums[slow] !== nums[fast]) {\r\n                nums[slow] = nums[fast];\r\n                fast++;\r\n            }\r\n        }\r\n    }\r\n    return slow+1;\r\n};\r\n```\r\n## å¤æ‚åº¦\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chouqin99":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185362278","body":"æ€è·¯:æƒ³æŠŠæ•°ç»„ç›´æ¥è½¬æˆintï¼Œç„¶åç”¨åŠ æ³•åŠ å®Œäº†ï¼Œå†è½¬æ¢å›æ¥ï¼Œä½†æ˜¯è²Œä¼¼ä¸æ˜¯é¢˜ç›®è¦çš„\r\ncodeï¼š\r\n`\r\n  #!/usr/bin/env python\r\n  \"\"\"add\"\"\"\r\n  \r\n  import os\r\n  from os import sys, path\r\n  \r\n  class Add(object):\r\n  \r\n      def list2str(self, inlist):\r\n          outstr = \"\"\r\n          for i in inlist:\r\n              outstri = ''.join(str(i))\r\n              outstr = outstr + outstri\r\n          return outstr\r\n\r\n      def add(self, x, k):\r\n          str_x = self.list2str(x)\r\n          str_k = self.list2str(k)\r\n          addint = int(str_x) + int(str_k)\r\n          return addint\r\n\r\n      def str2list(self, instr):\r\n          outlist = list(instr)\r\n          return outlist\r\n\r\n      def main(self, x, k):\r\n          addint = self.add(x, k)\r\n          outlist = self.str2list(str(addint))\r\n          print outlist\r\n\r\n  if __name__ == '__main__':\r\n      x = [1,1,0,0]\r\n      k = [3,4]\r\n      r = Add()\r\n      r.main(x,k)\r\n\r\n`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186216992","body":"## æ€è·¯\r\n  å­¦ä¹ å®˜æ–¹è§£é¢˜æ–¹å¼\r\n##ä»£ç \r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        n = len(s)\r\n        res = [0 if s[i] == c else None for i in range(n)]\r\n\r\n        for i in range(1, n):\r\n            if res[i] != 0 and res[i - 1] is not None:\r\n                res[i] = res[i - 1] + 1\r\n\r\n        for i in range(n - 2, -1, -1):\r\n            if res[i] is None or res[i + 1] + 1 < res[i]:\r\n                res[i] = res[i + 1] + 1\r\n        return res\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186547277","body":"## æ€è·¯\r\nå­¦ä¹ æ ˆ\r\n\r\n##ä»£ç \r\n\r\n```python\r\n    def __init__(self, size: int):\r\n        self.st = []\r\n        self.cnt = 0\r\n        self.size = size\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cnt < self.size:\r\n            self.st.append(x)\r\n            self.cnt += 1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.cnt == 0: return -1\r\n        self.cnt -= 1\r\n        return self.st.pop()\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(0, min(self.cnt, k)):\r\n            self.st[i] += val\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187661561","body":"## æ€è·¯\nå­¦ä¹ å®˜æ–¹è§£å†³\n\n##ä»£ç \n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == ']':\n                repeatStr = ''\n                repeatCount = ''\n                while stack and stack[-1] != '[':\n                    repeatStr = stack.pop() + repeatStr\n                # pop æ‰ \"[\"\n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    repeatCount = stack.pop() + repeatCount\n                stack.append(repeatStr * int(repeatCount))\n            else:\n                stack.append(c)\n        return \"\".join(stack)\n\n```\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190463845","body":"## æ€è·¯\r\nå®˜æ–¹å­¦ä¹ \r\n```python\r\n    def maxChunksToSorted(self, arr):\r\n        count_a = collections.defaultdict(int)\r\n        count_b = collections.defaultdict(int)\r\n        ans = 0\r\n\r\n        for a, b in zip(arr, sorted(arr)):\r\n            count_a[a] += 1\r\n            count_b[b] += 1\r\n            if count_a == count_b: ans += 1\r\n\r\n        return ans\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191566717","body":"## æ€è·¯\nå­¦ä¹ å®˜æ–¹\n\n##ä»£ç \n\n```python\n   if head:\n            p1 = head\n            p2 = head\n            count = 1\n            i = 0\n            while i < k:\n                if p2.next:\n                    count += 1\n                    p2 = p2.next\n                else:\n                    k = k % count\n                    i = -1\n                    p2 = head\n                i += 1\n\n            while p2.next:\n                p1 = p1.next\n                p2 = p2.next\n\n            if p1.next:\n                tmp = p1.next\n            else:\n                return head\n            p1.next = None\n            p2.next = head\n            return tmp\n\n```     \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192709956","body":"## æ€è·¯\r\nç»§ç»­å­¦ä¹ å®˜æ–¹\r\n\r\n## ä»£ç \r\n```\r\nif not head or not head.next: return head\r\n    ans = ListNode()\r\n    ans.next = head.next\r\n    pre = ans\r\n    while head and head.next:\r\n        next = head.next\r\n        n_next = next.next\r\n        next.next = head\r\n        pre.next = next\r\n        head.next = n_next\r\n        pre = head\r\n        head = n_next\r\n    return ans.next\r\n```\r\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196944733","body":"## æ€è·¯\n```python\n def maxDepth(self, root: TreeNode) -> int:\n        if not root: return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n\n```  ","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201382615","body":"## æ€è·¯\r\nå­¦ä¹ \r\n\r\n##ä»£ç \r\n\r\n```python\r\n\r\n  def verticalTraversal(self, root):\r\n        seen = collections.defaultdict(\r\n            lambda: collections.defaultdict(list))\r\n\r\n        def dfs(root, x=0, y=0):\r\n            if not root:\r\n                return\r\n            seen[x][y].append(root.val)\r\n            dfs(root.left, x-1, y+1)\r\n            dfs(root.right, x+1, y+1)\r\n\r\n        dfs(root)\r\n        ans = []\r\n        # x æ’åºã€\r\n        for x in sorted(seen):\r\n            level = []\r\n            # y æ’åº\r\n            for y in sorted(seen[x]):\r\n                # å€¼æ’åº\r\n                level += sorted(v for v in seen[x][y])\r\n            ans.append(level)\r\n\r\n        return ans\r\n\r\n```  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202885460","body":"class Solution {\n\n    public int[] twoSum(int[] nums, int target) {\n        \n        Map<Integer, Integer> map = new HashMap<>();\n        \n        for (int i = 0; i < nums.length; i++) {\n            \n            if (map.containsKey(nums[i]))\n                return new int[]{map.get(nums[i]), i};\n            \n            map.put(target - nums[i], i);\n        }\n        \n        return new int[]{};\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1204147807","body":"class Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> occurrences = new HashMap<Integer, Integer>();\n        for (int num : nums) {\n            occurrences.put(num, occurrences.getOrDefault(num, 0) + 1);\n        }\n\n        // int[] çš„ç¬¬ä¸€ä¸ªå…ƒç´ ä»£è¡¨æ•°ç»„çš„å€¼ï¼Œç¬¬äºŒä¸ªå…ƒç´ ä»£è¡¨äº†è¯¥å€¼å‡ºç°çš„æ¬¡æ•°\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {\n            public int compare(int[] m, int[] n) {\n                return m[1] - n[1];\n            }\n        });\n        for (Map.Entry<Integer, Integer> entry : occurrences.entrySet()) {\n            int num = entry.getKey(), count = entry.getValue();\n            if (queue.size() == k) {\n                if (queue.peek()[1] < count) {\n                    queue.poll();\n                    queue.offer(new int[]{num, count});\n                }\n            } else {\n                queue.offer(new int[]{num, count});\n            }\n        }\n        int[] ret = new int[k];\n        for (int i = 0; i < k; ++i) {\n            ret[i] = queue.poll()[0];\n        }\n        return ret;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205443099","body":"class Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        n = len(points)\n        ans = 0\n        for i in range(n):\n            m = collections.defaultdict(int)\n            for j in range(n):\n                dist = abs(points[i][0] - points[j][0]) ** 2 + abs(points[i][1] - points[j][1]) ** 2\n                m[dist] += 1\n            for count in m.values():\n                ans += count * (count-1)\n        return ans","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208302434","body":"class Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        slow = fast = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        return slow","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhaogeg111":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185368348","body":"è§£é¢˜æ€è·¯\n\n- æ•´æ•°çš„ æ•°ç»„å½¢å¼  num æ˜¯æŒ‰ç…§ä»å·¦åˆ°å³çš„é¡ºåºè¡¨ç¤ºå…¶æ•°å­—çš„æ•°ç»„ã€‚\n  ä¾‹å¦‚ï¼Œå¯¹äº num = 1321 ï¼Œæ•°ç»„å½¢å¼æ˜¯ [1,3,2,1] ã€‚\nç»™å®š num ï¼Œæ•´æ•°çš„ æ•°ç»„å½¢å¼ ï¼Œå’Œæ•´æ•° k ï¼Œè¿”å› æ•´æ•° num + k çš„ æ•°ç»„å½¢å¼ ã€‚\n\nè§£é¢˜ä»£ç \n\n    int* addToArrayForm(int* num, int numSize, int k, int* returnSize){\n        int ksize = 0;//é¢„è®¾kçš„ä½æ•°ä¸º0\n        int ktmp = k;\n        while(ktmp)      //å¾—åˆ°kçš„ä½æ•°\n        {\n            ksize++;\n            ktmp /= 10;\n        }\n        int size = numSize > ksize ? numSize + 1 : ksize + 1;   //å¼€è¾Ÿä¸€ä¸ªå¤š+1ä½ç½®çš„æ•°ç»„ï¼Œé˜²æ­¢æœ‰è¿›ä½\n    \n        int* a = (int*)malloc(size*sizeof(int));\n    \n        int end = numSize - 1;//åˆ›å»ºä¸€ä¸ªä¸‹æ ‡æŒ‡å‘numæ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´  \n        int carry = 0;\n        int i = 0;\n        while(end >= 0 || k > 0)   //2ä¸ªæœ‰1ä¸ªæ²¡æœ‰éå†å®Œ\n        {\n            if(end >= 0)\n            {\n                a[i] = carry + num[end] + k % 10;\n            }//num[end]ä¸ºæ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´  k%10 ä¸ºkçš„æœ€åä¸€ä½\n            else\n            {\n                a[i] = carry + k % 10;\n            }\n    \n            if(a[i] >= 10)\n            {\n                a[i] = a[i] - 10;\n                carry = 1;//æœ‰è¿›ä½\n            }\n            else\n            {\n                carry = 0;//carry=1è¡¨ç¤ºè¿›ä½ä¸ºï¼Œ0è¡¨ç¤ºä¸è¿›ä½\n            }\n            k /= 10;\n            end--;\n            i++;\n        }\n        if(carry == 1)\n        {\n            a[i++] = 1;\n        }\n    \n        int left = 0;\n        int right = i - 1;\n        while(left < right)\n        {\n            int tmp = a[left];\n            a[left] = a[right];\n            a[right] = tmp;\n            left++;\n            right--;\n        }//æ•°ç»„é€†åº\n    \n        *returnSize = i;\n        return a;\n    \n    }\n\næ—¶é—´å¤æ‚åº¦\n\nOï¼ˆn^2)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186159638","body":"### é¢˜ç›®æè¿°\n\n````\n```\nç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² S å’Œä¸€ä¸ªå­—ç¬¦ Cã€‚è¿”å›ä¸€ä¸ªä»£è¡¨å­—ç¬¦ä¸² S ä¸­æ¯ä¸ªå­—ç¬¦åˆ°å­—ç¬¦ä¸² S ä¸­çš„å­—ç¬¦ C çš„æœ€çŸ­è·ç¦»çš„æ•°ç»„ã€‚\n\nç¤ºä¾‹ 1:\n\nè¾“å…¥: S = \"loveleetcode\", C = 'e'\nè¾“å‡º: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\nè¯´æ˜:\n\n- å­—ç¬¦ä¸² S çš„é•¿åº¦èŒƒå›´ä¸º [1, 10000]ã€‚\n- C æ˜¯ä¸€ä¸ªå•å­—ç¬¦ï¼Œä¸”ä¿è¯æ˜¯å­—ç¬¦ä¸² S é‡Œçš„å­—ç¬¦ã€‚\n- S å’Œ C ä¸­çš„æ‰€æœ‰å­—æ¯å‡ä¸ºå°å†™å­—æ¯ã€‚\n\n```\n````\n\n### è§£é¢˜æ€è·¯\n\n1. ä»å·¦åˆ°å³éå†iï¼Œæ‰¾å‡ºä¸‹æ ‡iåˆ°ç¦»å®ƒå·¦ä¾§æœ€è¿‘çš„å­—ç¬¦cçš„è·ç¦»\n2. ä»å³åˆ°å·¦éå†iï¼Œæ‰¾å‡ºä¸‹æ ‡iåˆ°ç¦»å®ƒå³ä¾§æœ€è¿‘çš„å­—ç¬¦cçš„è·ç¦»\n3. æ¯”è¾ƒ1å’Œ2å¾—å‡ºæœ€çŸ­è·ç¦»ã€‚æ‰¾åˆ°é€Ÿåº¦æœ€å¿«çš„è·ç¦»\n\n### è§£é¢˜ä»£ç \n\n```c\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint *shortestToChar(char *s, char c, int *returnSize)\n{\n    int i, index;\n    int len = strlen(s);\n    int *p = (int *)malloc(len * sizeof(int));\n    if (p == NULL) {\n        return NULL;\n    }\n    memset(p, 0, len * sizeof(int));\n\n    // ä»å·¦åˆ°å³éå†iï¼Œæ‰¾å‡ºä¸‹æ ‡iåˆ°ç¦»å®ƒå·¦ä¾§æœ€è¿‘çš„å­—ç¬¦cçš„è·ç¦»\n    index = -len; // åˆå§‹ä¸º-lenï¼Œç¬¬ä¸€æ¬¡éå†æ—¶ï¼Œå¯èƒ½æ²¡æœ‰æ‰¾åˆ°\n    for (i = 0; i < len; i++) {\n        if (s[i] == c) {\n            index = i; // æ›´æ–°index\n        }\n        p[i] = i - index; // æ±‚å‡ºè·ç¦»\n    }\n\n    // ä»å³åˆ°å·¦éå†iï¼Œæ‰¾å‡ºä¸‹æ ‡iåˆ°ç¦»å®ƒå³ä¾§æœ€è¿‘çš„å­—ç¬¦cçš„è·ç¦»\n    index = 2 * len; // åˆå§‹ä¸º2*lenï¼Œç¬¬ä¸€æ¬¡éå†æ—¶ï¼Œå¯èƒ½æ²¡æœ‰æ‰¾åˆ°\n    for (i = len - 1; i >= 0; i--) {\n        if (s[i] == c) {\n            index = i; // æ›´æ–°index\n        }\n        p[i] = fmin(p[i], index - i); // æ±‚å‡ºè·ç¦»ï¼Œå¹¶æ¯”è¾ƒå¾—å‡ºæœ€çŸ­è·ç¦»\n    }\n\n    *returnSize = len;\n    return p;\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186496698","body":"### é¢˜ç›®æ€è·¯\n\n1ã€æ­£å¸¸å»ºç«‹ä¸€ä¸ªæ•°ç»„ï¼Œè®°å½•å½“å‰çš„indexå’Œæœ€å¤§å€¼ï¼Œç»´æŠ¤ä¸€ä¸ªæ ˆï¼Œå¦‚æœéœ€è¦ç»Ÿä¸€åŠ ä¸€ä¸ªå€¼ï¼Œå°±ç›´æ¥forå¾ªç¯éå†\n2ã€æ­£å¸¸å»ºç«‹ä¸¤ä¸ªæ•°ç»„ï¼Œç¬¬ä¸€ä¸ªæ•°ç»„ç”¨æ¥å­˜å½“å‰çš„å…¥æ ˆå…ƒç´ ï¼Œç¬¬äºŒä¸ªæ•°ç»„ç”¨æ¥å­˜å½“å‰indexåŠå°äºè¯¥indexå€¼çš„å…ƒç´ éœ€è¦åŠ çš„æ•°\ntypedef struct {\n    int maxnum;\n    int curInex;\n    int *arry;\n    int *increment;\n} CustomStack;\n\n\nCustomStack* customStackCreate(int maxSize) {\n    CustomStack *stacktmp = (CustomStack *)malloc(sizeof(CustomStack));\n    stacktmp->maxnum = maxSize;\n    stacktmp->curInex = 0;\n    stacktmp->arry = (int *)malloc(sizeof(int) * maxSize);\n    stacktmp->increment = (int *)malloc(sizeof(int) * maxSize);\n    memset(stacktmp->arry, 0, sizeof(int) * maxSize);\n    memset(stacktmp->increment, 0, sizeof(int) * maxSize);\n    return stacktmp;\n}\n\nvoid customStackPush(CustomStack* obj, int x) {\n    if ((obj == NULL) || (obj->curInex == obj->maxnum)) {\n        return;\n    }\n    obj->arry[obj->curInex] = x;\n    obj->curInex++;\n}\n// 3 100\nint customStackPop(CustomStack* obj) {\n    if ((obj == NULL) || (obj->curInex == 0)) {\n        return -1;\n    }\n    obj->curInex--;\n    int returnNum = obj->arry[obj->curInex] + obj->increment[obj->curInex];\n    if (obj->curInex) {\n        obj->increment[obj->curInex - 1] += obj->increment[obj->curInex];\n    }\n    obj->increment[obj->curInex] = 0;\n    return returnNum;\n}\n// 1,2,3 100 k = 3 num - 1 = 2\nvoid customStackIncrement(CustomStack* obj, int k, int val) {\n    if (obj == NULL || obj->curInex == 0) {\n        return;\n    }\n    int num = k < obj->curInex ? k : obj->curInex;\n    obj->increment[num - 1] += val;\n}\n\nvoid customStackFree(CustomStack* obj) {\n    free(obj->arry);\n    free(obj);\n}\n\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189746866","body":"int maxChunksToSorted(int *arr, int arrSize)\n{\n    /* åˆå§‹åŒ–å¾ªç¯å˜é‡xä»æ•°ç»„å³è¾¹å¼€å§‹å¾€å·¦ï¼Œtä¸ºæ— ç©·å¤§ã€‚ */\n    int x = arrSize - 1, t = INT_MAX, result = 0;\n    int rightMin[arrSize];\n\n    /* å…ˆè®¡ç®—æ¯ä¸ªarr[x]å³è¾¹çš„æœ€å°å€¼ï¼Œä¸åŒ…æ‹¬arr[x]åœ¨å†…ã€‚ */\n    while(0 <= x)\n    {\n        rightMin[x] = t;\n        if(t > arr[x])\n        {\n            t = arr[x];\n        }\n        x--;\n    }\n\n    /* ç„¶åä»å·¦å¾€å³å†éå†ä¸€æ¬¡ã€‚æ­¤æ—¶ï¼Œtçš„å«ä¹‰å˜ä¸ºï¼Œ[0,x]èŒƒå›´å†…çš„æœ€å¤§å€¼ï¼Œåˆå§‹åŒ–ä¸ºarr[0]ã€‚ */\n    t = arr[0];\n    x = 0;\n    while(arrSize > x)\n    {\n        if(t < arr[x])\n        {\n            t = arr[x];\n        }\n        /* å½“å‘ç°å½“å‰ä¸ºæ­¢çš„æœ€å¤§å€¼ï¼Œä¸å¤§äºrightMin[x]æ—¶ï¼Œå³å¯åˆ‡ä¸€åˆ€ã€‚ */\n        if(t <= rightMin[x])\n        {\n            result++;\n        }\n        x++;\n    }\n\n    return result;\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnhu23":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185371267","body":"## Idea\r\niterate through the num array, add each digit to k , add the rightmost digit into the result list\r\n## Code\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        int len = num.length;\r\n        for (int i = len-1; i >= 0; i--) {\r\n            k += num[i];\r\n            res.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        while (k > 0) {\r\n            res.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n## Complexity\r\nTime: O(n)\r\nSpace:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185991579","body":"##  Idea\r\nIterate from left to right, and then iterate from right to left\r\n## Code\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        char[] str = s.toCharArray();\r\n        int n = str.length;\r\n        int[] res = new int[n];\r\n        Arrays.fill(res, Integer.MAX_VALUE);\r\n        for (int i = 0; i < n; i++) {\r\n            if (str[i] == c) {\r\n                res[i] = 0;\r\n            }\r\n            if (i < n-1 && res[i] != Integer.MAX_VALUE) {\r\n               res[i+1] = Math.min(res[i]+1, res[i+1]); \r\n            }\r\n        }\r\n        for (int i = n-1; i > 0; i-- ) {\r\n            if (res[i] != Integer.MAX_VALUE) {\r\n                res[i-1] = Math.min(res[i-1], res[i]+1);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n## Complexity\r\ntime: O(n)\r\nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186350565","body":"## Idea\r\nImplement with an array and keep track of current position. For increment, use an offset array and an int instead of incrementing all bottom k elements.\r\n## Code\r\n```\r\nclass CustomStack {\r\n    int[] stack;\r\n    int[] offset;\r\n    int cur;\r\n    int diff;\r\n    \r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        offset = new int[maxSize];\r\n        cur = 0;\r\n        diff = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (cur == stack.length) return;\r\n        if (cur > 0) {\r\n            offset[cur-1] += diff;\r\n        }\r\n        diff = 0;\r\n        stack[cur] = x;\r\n        offset[cur] = 0;\r\n        cur++;\r\n    }\r\n    \r\n    public int pop() {\r\n        if (cur == 0) return -1;\r\n        int res = stack[cur-1];\r\n        diff += offset[cur-1];\r\n        cur--;\r\n        return res+diff;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if (cur == 0) return;\r\n        int min = Math.min(k , cur);\r\n        offset[min-1] += val;\r\n    }\r\n    \r\n}\r\n```\r\n## Complexity\r\nTime: push O(1) , pop O(1), increment O(1)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186912390","body":"## Idea\ntwo stacks, one for number of repetition and one for the string\n## Code\n```\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Integer> s1 = new Stack<>();\n        Stack<String> s2 = new Stack<>();\n        char[] str = s.toCharArray();\n        String res = \"\";\n        for (int i = 0; i < str.length; i++) {\n            if (str[i] >= '0' && str[i] <= '9') {\n                int num = 0;\n                while (str[i] >= '0' && str[i] <= '9') {\n                    num = num * 10 + (str[i] - '0');\n                    i++;\n                }\n                s1.push(num);\n                i--;\n            }\n            else if (str[i] == '[') {\n                s2.push(res);\n                res = \"\";\n            }\n            else if (str[i] == ']') {\n                int num = s1.pop();\n                StringBuilder sb = new StringBuilder(s2.pop());\n                for (int j = 0; j < num; j++) {\n                    sb.append(res);\n                }\n                res = sb.toString();\n            }\n            else {\n                res += str[i];\n            }\n        }\n        return res;\n    }\n}\n```\n## Complexity\nTime: O(n)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188375666","body":"## Idea\r\nuse the second stack to retrieve the top element\r\n## Code\r\n```\r\nclass MyQueue {\r\n    Stack<Integer> s1;\r\n    Stack<Integer> s2;\r\n    \r\n    public MyQueue() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (s2.isEmpty()) {\r\n            while (!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (s2.isEmpty()) {\r\n            while (!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}\r\n```\r\n## Complexity\r\nTime: O(n) for pop, peek and empty, O(1) for push\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189985198","body":"## Idea\nuse a monotonically increasing stack and store the max element for each chunk, return the size of chunk.\n\n## Code\n```\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int n = arr.length;\n        Stack<Integer> stack = new Stack<>();\n        int curMax = 0;\n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && arr[i] < stack.peek()) {\n                stack.pop();\n            }\n            curMax = Math.max(curMax, arr[i]);\n            stack.push(curMax);\n        }\n        return stack.size();\n    }\n}\n```\n## Complexity\nTime: O(n)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191091660","body":"## Idea\r\ntreat k as k mod len and rotate the linkedlist\r\n## Code\r\n```\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null) return head;\r\n        ListNode cur = head, tail = head;\r\n        int len = 1;\r\n        while (cur.next != null) {\r\n            cur = cur.next;\r\n            len++;\r\n        }\r\n        cur.next = head;\r\n        k = k % len;\r\n        for (int i = 0; i < len - k - 1; i++) {\r\n            tail = tail.next;\r\n        }\r\n        cur = tail.next;\r\n        tail.next = null;\r\n        return cur;\r\n    }\r\n}\r\n```\r\n## Complexity\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192691221","body":"## Idea\niterate through the list and swap the value\n## Code\n```\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null) return head;\n        ListNode cur = head;\n        ListNode res = head;\n        int counter = 0;\n        while (cur != null && cur.next != null) {\n            ListNode tmp = cur.next;\n            ListNode next = tmp.next;\n            \n            if (counter == 0) {\n                res = tmp;\n            }\n            \n            tmp.next = cur;\n            if (next == null) {\n                cur.next = next;\n            }\n            else {\n                if (next.next != null) {\n                    cur.next = next.next;\n                }\n                else {\n                    cur.next = next;\n                }\n            }\n            \n            cur = next;\n            counter++;\n        }\n        return res;\n    }\n}\n```\n## Complexity\nTime: O(n)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193131950","body":"## Idea\nIn-order traversal and use fast slow pointer to find the middle of the linked list\n## Code\n```\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n        ListNode slow = head;\n        ListNode fast = head;\n        ListNode prev = null;\n        while (fast != null && fast.next != null) {\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        if (prev != null) {\n            prev.next = null;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        if (slow != head) {\n            root.left = sortedListToBST(head);\n        }\n        else {\n            root.left = null;\n        }\n        root.right = sortedListToBST(slow.next);\n        return root;\n    }\n}\n```\n## Complexity\nTime: O(nlogn)\nSpace: O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193284901","body":"## Idea\nGet the difference of the length of two linkedlist. Move two pointers to the position where the remaining number of nodes of two linkedlist are equal.\n\n## Code\n```\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) return null;\n        ListNode cur1 = headA;\n        int lenA = 1, lenB = 1;\n        while (cur1 != null) {\n            cur1 = cur1.next;\n            lenA++;\n        }\n        cur1 = headB;\n        while (cur1 != null) {\n            cur1 = cur1.next;\n            lenB++;\n        }\n        \n        int diff = Math.abs(lenA - lenB);\n        ListNode cur2 = null;\n        if (lenA > lenB) {\n            cur1 = headA;\n            cur2 = headB;\n        }\n        else {\n            cur1 = headB;\n            cur2 = headA;\n        }\n        for (int i = 0; i < diff; i++) {\n            cur1 = cur1.next;\n        }\n        while (cur1 != null) {\n            if (cur1 == cur2) return cur1;\n            cur1 = cur1.next;\n            cur2 = cur2.next;\n        }\n        return null;\n    }\n}\n```\n## Complexity\nTime: O(n)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193789143","body":"## Idea\nfast and slow pointer\n## Code\n```\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while (true) {\n            if (slow == null) return null;\n            if (fast == null || fast.next == null) return null;\n            slow = slow.next;\n            fast = fast.next.next;\n            if (fast == slow) break;\n        }\n        slow = head;\n        while (slow != fast) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n}\n```\n## Complexity\nTime: O(n)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195378715","body":"## Idea\nUse a map and a doubly linked list to store the keys and values.\n\n## Code\n```\nclass LRUCache {\n    public Map<Integer, Node> cache;\n    public int capacity;\n    public Node head, tail;\n    \n    class Node {\n        public int key;\n        public int val;\n        public Node prev;\n        public Node next;\n        \n        public Node(){};\n        public Node(int k, int v, Node p, Node n) {\n            this.key = k;\n            this.val = v;\n            this.prev = p;\n            this.next = n;\n        }\n    }\n        \n    public LRUCache(int capacity) {\n        this.cache = new HashMap<>();\n        this.capacity = capacity;\n        this.head = new Node();\n        this.tail = new Node();\n        head.prev = null;\n        head.next = tail;\n        tail.prev = head;\n        tail.next = null;\n    }\n    \n    public int get(int key) {\n        if (cache.containsKey(key)) {\n            Node node = cache.get(key); \n            moveToTail(node);\n            return node.val;\n        }\n        else {\n            return -1;\n        }\n    }\n    \n    public void put(int key, int value) {\n        if (cache.containsKey(key)) {\n            Node node = cache.get(key);\n            node.val = value;\n            moveToTail(node);\n            return;\n        }\n        Node node = new Node();\n        node.key = key;\n        node.val = value;\n        cache.put(key, node);\n        addNode(node);\n        int size = cache.size();\n        \n        if (size > capacity) {\n            Node toRemove = head.next;\n            removeNode(toRemove);\n            cache.remove(toRemove.key, toRemove);\n        }\n    }\n\n    private void addNode(Node node) {\n        Node tmp = tail.prev;\n        tmp.next = node;\n        node.prev = tmp;\n        node.next = tail;\n        tail.prev = node;\n    }\n\n    private void removeNode(Node node) {\n        Node p = node.prev;\n        Node n = node.next;\n        p.next = n;\n        n.prev = p;\n    }\n\n    public void moveToTail(Node node) {\n        removeNode(node);\n        addNode(node);\n    }\n}\n```\n## Time Complexity\nTime: O(1) for get() and put()\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196596722","body":"## Idea\nrecursion\n## Code\n```\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        int left = maxDepth(root.left);\n        int right = maxDepth(root.right);\n        return Math.max(left, right) + 1;\n    }\n}\n```\n## Complexity\nTime: O(n)\nSpace: O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198133081","body":"## Idea\nrecursion\n## Code\n```\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val != q.val) return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n```\n## Complexity\ntime: O(n)\nspace: O(height)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199475183","body":"## Idea\ndfs\n## Code\n```\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        return preorder(root, 0);\n    }\n    \n    public int dfs(TreeNode root, int sum) {\n        if (root == null) return 0;\n        sum = sum * 10 + root.val;\n        if (root.left == null && root.right == null) return sum;\n        return dfs(root.left, sum) + dfs(root.right, sum);\n    }\n}\n```\n## Complexity\nTime: O(n)\nSpace: O(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200227737","body":"## Idea\nUse a queue and push right then left\n## Code\n```\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n        while (!q.isEmpty()) {\n            root = q.poll();\n            if (root.right != null) {\n                q.add(root.right);\n            }\n            if (root.left != null) {\n                q.add(root.left);\n            }\n        }\n        return root.val;\n    }\n}\n```\n## Complexity\nTime: O(n)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200442573","body":"## Code\n```\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        if (root == null) {\n            return \"#_\";\n        }\n        String res = root.val + \"_\";\n        res += serialize(root.left);\n        res += serialize(root.right);\n        return res;\n    }\n    \n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        String[] values = data.split(\"_\");\n        Queue<String> queue = new LinkedList<>();\n        for (int i = 0; i < values.length; i++) {\n            queue.add(values[i]);\n        }\n        return process(queue);\n    }\n    \n    private TreeNode process(Queue<String> queue) {\n        String value = queue.poll();\n        if (value.equals(\"#\")) {\n            return null;\n        }\n        TreeNode root = new TreeNode(Integer.valueOf(value));\n        root.left = process(queue);\n        root.right = process(queue);\n        return root;\n    }\n    \n}\n```\n## Complexity\nTime: O(n)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201387932","body":"## Idea\r\nTreeMap\r\n## Code\r\n```\r\nclass Solution {\r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n        \r\n        Map<Integer,List<Pair>> map=new TreeMap<>();\r\n        List<List<Integer>> res=new ArrayList<>();\r\n        vertical(root,0,0,map);\r\n        \r\n        for(List<Pair> lss:map.values()){\r\n            \r\n            Collections.sort(lss,(x,y)->x.hlevel==y.hlevel?x.value-y.value:x.hlevel-y.hlevel);\r\n            List<Integer> temp=new ArrayList<>();\r\n            for(Pair p:lss)temp.add(p.value);\r\n            res.add(new ArrayList<>(temp));\r\n        }\r\n        return res;\r\n        \r\n    }\r\n    public void vertical(TreeNode root,int vlevel,int hlevel,Map<Integer,List<Pair>> map){\r\n        \r\n        if(root==null)return;\r\n        \r\n        if(map.containsKey(vlevel))map.get(vlevel).add(new Pair(hlevel,root.val));\r\n        else{\r\n            \r\n            List<Pair> ls=new ArrayList<>();\r\n            ls.add(new Pair(hlevel,root.val));\r\n            map.put(vlevel,ls);\r\n        }\r\n        \r\n        vertical(root.left,vlevel-1,hlevel+1,map);\r\n        vertical(root.right,vlevel+1,hlevel+1,map);\r\n    }\r\n    private class Pair{\r\n        \r\n        int hlevel,value;\r\n        Pair(int h,int val){\r\n            \r\n            this.hlevel=h;\r\n            this.value=val;\r\n        }\r\n        \r\n    }\r\n}\r\n```\r\n## Complexity\r\nTime: O(nlogn)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202413453","body":"## Idea\nUse a hashMap to store the (val, index) pairs\n## Code\n```\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.put(nums[i], i);\n        }\n        int[] res = new int[2];\n        for (int i = 0; i < nums.length; i++) {\n            int diff = target - nums[i];\n            if (map.containsKey(diff) && map.get(diff) != i) {\n                res[0] = i;\n                res[1] = map.get(diff);\n                break;\n            }\n        }\n        return res;\n    }\n}\n```\n## Complexity\nTime: O(n)\nSpace: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203969807","body":"## Idea\nUse a map to store (value, frequence) pair and sort pair using a priorityqueue. Push the first k pairs.\n## Code\n```\nclass Solution {\n    static class Num {\n        int number;\n        int frequent;\n        \n        public Num(int n, int f) {\n            this.number = n;\n            this.frequent = f;\n        }\n    }\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (map.containsKey(nums[i])) {\n                int freq = map.get(nums[i]);\n                map.put(nums[i], freq+1);\n            }\n            else {\n                map.put(nums[i], 1);\n            }\n        }\n        PriorityQueue<Num> q = new PriorityQueue<>((n1, n2) -> n2.frequent - n1.frequent);\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            q.add(new Num(entry.getKey(), entry.getValue()));\n        }\n        int[] res = new int[k];\n        for (int i = 0; i < k; i++) {\n            res[i] = q.poll().number;\n        }\n        return res;\n    }\n}\n```\n## Complexity\nTime: O(nlogn)\nSpace: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ye2222":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185386008","body":"## Code\n```c++\nvector<int> addToArrayForm(vector<int>& num, int k) {\n    int n = num.size();\n    int count = n-1;\n    vector<int> res;\n    // å› ä¸ºå¯èƒ½ä¸æ˜¯ç›¸åŒä½æ•°æ“ä½œï¼Œæ‰€ä»¥è¦ç¡®ä¿æ¯ä¸€ä½éƒ½å‚åŠ è¿ç®—\n    while(count >= 0 || k != 0) {\n        // å¯¹kè¿›è¡Œæ“ä½œæ¯”è¾ƒæ–¹ä¾¿ï¼Œè¿›è¡ŒåŠ æ³•è¿è¡Œæ—¶ä¼šéµå¾ªåŠ å‡æ³•åŸåˆ™\n        if(count >= 0) {\n            k += num[count];\n            count--;\n        }\n        res.insert(res.begin(), k%10);\n        k /= 10;\n    }\n    return res;\n}\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n) \n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186052432","body":"## æ€è·¯\næ­£å‘éå†ï¼Œç»™å­—ç¬¦cå³è¾¹çš„å­—ç¬¦èµ‹å€¼è·ç¦»ï¼Œé‡åˆ°å¦ä¸€ä¸ªå­—ç¬¦cåœæ­¢ï¼›åå‘éå†ï¼Œè®¡ç®—è·ç¦»ï¼ŒåŒæ ·é‡åˆ°å¦ä¸€ä¸ªå­—ç¬¦cåœæ­¢ï¼Œè·ç¦»å–æœ€å°å€¼\n## Code\n```c++\nvector<int> shortestToChar(string s, char c) {\n    int n = s.size();\n    vector<int> res;\n    for(int i = 0; i < n; i++) res.push_back(100001);\n    // æ­£å‘éå†\n    for(int i = 0; i < n; i++) {\n        if(s[i] == c) {\n            res[i] = 0;\n            for(int j = i + 1; j < n; j++) {\n                if(s[j] != c) res[j] = j - i;\n                else break; \n            }\n        }\n    }\n    // åå‘éå†\n    for(int i = n - 1; i >= 0; i--) {\n        if(s[i] == c) {\n            for(int j = i - 1; j >= 0; j--) {\n                if(s[j] != c) {\n                    int dis = i - j;\n                    if(res[j] > dis) res[j] = dis;\n                } \n                else break;\n            }\n        }\n    }\n    return res;\n}\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n^2)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186546066","body":"## Code\nclass CustomStack {\npublic:\n    int maxSize;\n    int a[1001];\n    int count;\n    CustomStack(int maxSize) {\n        this->maxSize = maxSize;\n        this->count = 0;\n    }\n    \n    void push(int x) {\n        if(count < maxSize) {\n            a[count++] = x;\n        } else {\n            return;\n        }\n    }\n    \n    int pop() {\n        if(count > 0) {\n            int res = a[count-1];\n            count--;\n            return res;\n        }  \n        else {\n            return -1;\n        }\n    }\n    \n    void increment(int k, int val) {\n        for(int i = 0; i < count && i < k; i++) {\n            a[i]+=val;\n        }\n    }\n};\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186724001","body":"## æ€è·¯\nåˆ©ç”¨æ ˆå…ˆè¿›åå‡ºçš„ç‰¹æ€§ï¼Œè¿›è¡Œæ‹¬å·åŒ¹é…ï¼Œå°†ç”Ÿæˆçš„å­—ç¬¦ä¸€å¹¶å‹å…¥æ ˆä¸­è¿›è¡Œå¤„ç†\n## Code \n```c++\nint power(int x, int k) {\n    int pow = 1;\n    for(int i = 0; i < k; i++) {\n        pow *= 10;\n    }\n    return x * pow;\n}\n\nstring decodeString(string s) {\n    stack <char> stk;\n    int n = s.size();\n    bool isNum =true;\n    string s1 = \"\";\n    int i = 1;\n    stk.push(s[0]);\n    while(!stk.empty() && i < n) {\n        if (s[i] == ']') {\n            isNum = true;\n            // é‡å¤çš„å­—ç¬¦\n            while(stk.top() != '[') {\n                char c = stk.top();\n                stk.pop();\n                s1.insert(0, 1, c);\n            }\n            // å¼¹å‡ºå·¦æ‹¬å·\n            stk.pop();\n            // é‡å¤çš„æ¬¡æ•°\n            int count = 0, pow = 0;\n            while(!stk.empty() && stk.top() - '0' <= 9 && stk.top() - '0' >= 0) {\n                count += power(stk.top()-'0', pow);\n                pow++;\n                stk.pop();\n            }\n            // é‡å¤å‹å…¥æ ˆä¸­\n            while(count > 0) {\n                for(int i = 0; i < s1.size(); i++) {\n                    stk.push(s1[i]);\n                }\n                count--;\n            }\n            s1 = \"\";\n        }\n        else if(isNum && s[i] != '[') {\n            stk.push(s[i]);\n        } \n        else if (s[i] == '[') {\n            stk.push(s[i]);\n            isNum = false;\n        }\n        else{\n            stk.push(s[i]);\n        }\n        i++;\n    }\n\n    string res;\n    while(!stk.empty()) {\n        res.insert(0, 1, stk.top());\n        stk.pop();\n    }\n    return res;\n}\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189038312","body":"## æ€è·¯\nä½¿ç”¨ä¸¤ä¸ªå•è°ƒæ ˆï¼Œåˆ©ç”¨ä¸¤ä¸ªæ ˆè¿›è¡Œå…ƒç´ çš„é€†ç½®ï¼Œè¾¾åˆ°è¾“å‡ºé˜Ÿé¦–çš„ç›®çš„\n## Code\n```c++\nclass MyQueue {\npublic:\n    stack<int> stk;\n    stack<int> temp;\n    MyQueue() {\n    }\n    \n    void push(int x) {\n        stk.push(x);\n    }\n    \n    int pop() {\n        if(stk.empty()) return -1;\n        int n = stk.size();\n        for(int i = 0; i < n; i++) {\n            temp.push(stk.top());\n            stk.pop();\n        }\n        int res = temp.top();\n        temp.pop();\n        for(int i = 0; i < n - 1; i++) {\n            stk.push(temp.top());\n            temp.pop();\n        }\n        return res;\n    }\n    \n    int peek() {\n        if(stk.empty()) return -1;\n        int n = stk.size();\n        for(int i = 0; i < n; i++) {\n            temp.push(stk.top());\n            stk.pop();\n        }\n        int res = temp.top();\n        for(int i = 0; i < n; i++) {\n            stk.push(temp.top());\n            temp.pop();\n        }\n        return res;\n    }\n    \n    bool empty() {\n        if(stk.empty()) return true;\n        return false;\n    }\n};\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189740812","body":"## æ€è·¯\nåˆ©ç”¨åˆ†ç»„æ’åºä¸åŸæ•°æ®æ’åºçš„ç‰¹ç‚¹ï¼Œå¯»æ‰¾æ¯ä¸€ä¸ªåˆ†ç»„çš„åˆ†ç•Œç‚¹ï¼ˆåˆ†ç»„çš„æœ€å¤§å€¼ï¼‰ï¼Œåˆ©ç”¨å•è°ƒæ ˆè¿›è¡Œè®¡æ•°ï¼Œå­˜å…¥æ¯ä¸ªåˆ†ç»„çš„æœ€å¤§å€¼ã€‚\n## Code\n```c++\nint maxChunksToSorted2(vector<int>& arr) {\n    stack<int> stk;\n    stk.push(arr[0]);\n    for(int i = 1; i < arr.size(); i++) {\n        // å½“å‰çš„æ•°å¤§äºå‰é¢æœ€å¤§å€¼çš„æ—¶å€™ï¼Œå¯ä»¥å»ºç«‹ä¸€ä¸ªæ–°çš„åˆ†ç»„\n        if(arr[i] >= stk.top()) {\n            stk.push(arr[i]);\n        } \n        // å½“å‰çš„æ•°å°äºå‰é¢æœ€å¤§å€¼çš„æ—¶å€™ï¼Œå¯ä»¥ä¸å‰é¢å¤§äºå½“å‰å€¼çš„æ•°å€¼ç»„æˆä¸€ä¸ªåˆ†ç»„\n        else {\n            int temp = stk.top();\n            stk.pop();\n            while(!stk.empty() && arr[i] < stk.top()) {\n                stk.pop();\n            }\n            stk.push(temp);\n        }\n    }\n    return stk.size();\n}\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191494430","body":"## Code\n```c++\nListNode* rotateRight(ListNode* head, int k) {\n    if(head == NULL) return NULL;\n    ListNode* tmp = head;\n    int num = 0;\n    ListNode* tmp1 = head;\n\n    // å¾—åˆ°é“¾è¡¨çš„é•¿åº¦\n    while(tmp1 != NULL) {\n        num++;\n        tmp1 = tmp1->next;\n    }\n    k = k % num;\n    if(num == 1 || k == 0) return head;\n    ListNode tmp2;\n    int count = num - k;\n    while(count >= 1 &&head!=NULL) {\n        if(count == 1) {\n            tmp2.next = head->next;\n            head->next = NULL;\n            break;\n        }\n        head = head->next;\n        count--;\n    }\n    ListNode* tmp3 = tmp2.next;\n    while(tmp3 != NULL && tmp3->next != NULL) {\n        tmp3 = tmp3->next;\n    }\n    tmp3->next = tmp;\n    return tmp2.next;\n}\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192111329","body":"## æ€è·¯\nå¿˜è®°åŠ ä¸Šä¸€ä¸ªdummyç»“ç‚¹ï¼Œè®©ç¬¬ä¸€æ­¥çš„æ“ä½œè·Ÿåé¢ä¸€è‡´ï¼Œå†™çš„å¤æ‚äº†\n## Code\n```c++\nListNode* swapPairs(ListNode* head) {\n    if(head == NULL) return NULL;\n\n    ListNode* temp = head;\n    ListNode* swap = new ListNode();\n    int count = 0;\n    while(temp != NULL && temp->next != NULL) {\n        if(count == 0) {\n            swap = temp->next;\n            temp->next = temp->next->next;\n            swap->next = temp;\n            head = swap;\n            count++;\n        }\n        else {\n            swap = temp->next;\n            if(swap->next != NULL) {\n                temp->next = swap->next;\n                swap->next = swap->next->next;\n                temp->next->next = swap;\n                temp = swap;\n            } else break;\n        }\n\n    }\n    return head;\n}\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193141385","body":"## æ€è·¯\nä¿è¯å½“å‰ç»“ç‚¹çš„å·¦å³å­æ ‘ä¸ºäºŒå‰å¹³è¡¡æ ‘ï¼Œä»¥å½“å‰ç»“ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„æ ‘ä¹Ÿä¸ºäºŒå‰å¹³è¡¡æ ‘ï¼Œå¯ä»¥å¯»æ‰¾å½“å‰å—çš„ä¸­ä½å€¼ä½œä¸ºæ ¹èŠ‚ç‚¹ï¼Œé€’å½’è¿›è¡Œå¤„ç†\n## Code\n```c++\nTreeNode* BST(ListNode* head, int left, int right) {\n    if(left < 0 || left > right) return NULL;\n    int mid = left + (right - left + 1) / 2; // ä¸­ä½å€¼çš„ä½ç½®\n    ListNode* tmp1 = head;\n    int count = 1;\n    while(count != mid) {\n        tmp1 = tmp1->next;\n        count++;\n    }\n    TreeNode* res = new TreeNode(tmp1->val); // ä¸­ä½å€¼\n    res->left = BST(head, left, mid-1);\n    res->right = BST(head, mid+1, right);\n    return res;\n}\n\nTreeNode* sortedListToBST(ListNode* head) {\n    if(head == NULL) return NULL;\n\n    // è·å–å½“å‰é“¾è¡¨çš„é•¿åº¦\n    int len = 0;\n    ListNode* tmp = head;\n    while(tmp != NULL) {\n        len++;\n        tmp = tmp->next;\n    }\n    TreeNode* res = BST(head, 1, len);\n    return res;\n}\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193234090","body":"## Code\n```c++\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n    if(headA == NULL ||headB == NULL) return NULL;\n    ListNode* a = headA;\n    ListNode* b = headB;\n    while(a != b) {\n        a= a->next; \n        b= b->next;\n        if(a == NULL && b == NULL) return NULL;\n        if(a == NULL) a = headB;\n        if(b == NULL) b = headA;\n    }\n    return a;\n}\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(m+n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194208732","body":"## Code\n```c++\nListNode *detectCycle(ListNode *head) {\n    if(head == NULL || head->next == NULL) return NULL;\n    ListNode* slow = head;\n    ListNode* fast = head;\n    while(fast && fast->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n        if(slow == fast) {\n            fast = head;\n            while(fast != slow) {\n                slow = slow->next;\n                fast = fast->next;\n            }\n            return slow;\n        }\n    }\n    return NULL;\n}\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195158337","body":"## Code\n```c++\n// åŒå‘é“¾è¡¨+å“ˆå¸Œè¡¨\n\nstruct DoubleLinked{\n    int val,key;\n    DoubleLinked* pre;\n    DoubleLinked* next;\n    DoubleLinked() {}\n    DoubleLinked(int key, int val)\n                : key(key), val(val), pre(NULL), next(NULL) {}\n    DoubleLinked(int key,int val, DoubleLinked* pre)\n                : key(key), val(val), pre(pre), next(NULL) {}\n    DoubleLinked(int key,int val, DoubleLinked* pre, DoubleLinked* next) \n                : key(key), val(val), pre(pre), next(next) {}\n\n};\nclass LRUCache {\nprivate:\n    map<int, DoubleLinked*> m;\n    int capacity;   \n    DoubleLinked* head = new DoubleLinked();\n    DoubleLinked* tail = new DoubleLinked(); \n\n    // æ’å…¥å¤´éƒ¨\n    void insert(DoubleLinked* new_node) {\n        DoubleLinked* temp = head->next;\n        head->next = new_node;\n        temp->pre = new_node;\n        new_node->next = temp;\n        new_node->pre = head;\n    }\n\n    // åˆ é™¤å°¾éƒ¨\n    void del() {\n        DoubleLinked* temp = tail->pre->pre;\n        DoubleLinked* dele = tail->pre;\n        temp->next = tail;\n        tail->pre = temp;\n        \n    }\n\n    // æå‰åˆ°å¤´éƒ¨\n    void move_head(DoubleLinked* target) {\n        // åˆ é™¤åŸæ¥ä½ç½®ä¸Š\n        target->pre->next = target->next;\n        target->next->pre = target->pre;\n        // æ”¾ç½®åˆ°å¤´éƒ¨\n        target->next = head->next;\n        head->next->pre = target;\n        head->next = target;\n        target->pre = head;\n    }\npublic:\n    LRUCache(int capacity) {\n        this->capacity = capacity;\n        head->next = tail;\n        tail->pre = head;\n    }\n    \n    int get(int key) {\n        if(!m.count(key)) {\n            return -1;\n        }\n        // æå‰åˆ°å¤´éƒ¨\n        move_head(m[key]);\n        // cout << \"get : \" << m[key]->val << endl;\n        return m[key]->val;\n    }\n    \n    void put(int key, int value) {\n\n        if(!m.count(key)){\n            // ä¸å­˜åœ¨ï¼Œæ’å…¥åŒå‘é“¾è¡¨çš„å¤´éƒ¨\n            capacity--;\n            DoubleLinked* new_node = new DoubleLinked(key, value);\n            m[key] = new_node;\n            insert(new_node);\n            if(capacity < 0) {\n                // åˆ é™¤åŒå‘é“¾è¡¨å°¾éƒ¨æœ€ä¹…æœªä½¿ç”¨\n                m.erase(tail->pre->key);\n                del();\n                capacity = 0;\n            } \n        }\n        else {\n            // å­˜åœ¨ï¼Œæ”¹å˜å€¼ï¼Œå¹¶ä¸”æå‰\n            m[key]->val = value;\n            move_head(m[key]);\n        }\n    }\n\n};\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(1)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196326612","body":"## Code\r\n```c++\r\nint maxDepth(TreeNode* root) {\r\n    if(root == NULL) return 0;\r\n    return 1 + max(maxDepth(root->left), maxDepth(root->right));\r\n}\r\n```\r\n## å¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(log2n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197573264","body":"## Code\n```c++\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(p == NULL && q == NULL) return true;\n        if(p == NULL || q == NULL) return false;\n        bool left = isSameTree(p->left, q->left);\n        bool right = isSameTree(p->right, q->right);\n        if(p->val == q->val && left && right) return true;\n        return false;\n    }\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(min(m, n))\n- ç©ºé—´å¤æ‚åº¦ï¼šO(min(m, n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198814884","body":"## æ€è·¯\r\nä½¿ç”¨BFSè¿›è¡Œå±‚åºéå†ï¼Œæ”¹å˜å½“å‰æ ¹çš„å·¦å³ç»“ç‚¹çš„å€¼è¿›è¡Œç´¯ç§¯ï¼Œå½“åˆ°è¾¾å¶å­ç»“ç‚¹æ—¶ï¼ŒåŠ åˆ°ç»“æœä¸­\r\n## Code\r\n```c++\r\nint sumNumbers(TreeNode* root) {\r\n    queue<TreeNode*> q;\r\n    q.push(root);\r\n    int res = 0;\r\n    TreeNode* tmp;\r\n    while(!q.empty()) {\r\n        tmp = q.front();\r\n        q.pop();\r\n        if(tmp->left != NULL) {\r\n            tmp->left->val += 10 * tmp->val;\r\n            q.push(tmp->left);\r\n        }\r\n        if(tmp->right != NULL) {\r\n            tmp->right->val += 10 * tmp->val;\r\n            q.push(tmp->right);\r\n        }\r\n        if(tmp->left==NULL && tmp->right==NULL)\r\n            res+=tmp->val;\r\n    }\r\n    return res;\r\n}\r\n```\r\n## å¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200117973","body":"## æ€è·¯\nä¸€å±‚ä¸€å±‚åœ°éå†ï¼Œä½¿ç”¨ä¸¤ä¸ªé˜Ÿåˆ—æ¥å­˜å‚¨å½“å‰å±‚å’Œä¸‹ä¸€å±‚ï¼Œå½“å‘ç°ä¸‹ä¸€å±‚ä¸ºç©ºçš„æ—¶å€™ï¼Œè¯´æ˜å½“å‰å±‚ä¸ºæœ€åº•å±‚ï¼Œè¾“å‡ºè®°å½•çš„æœ€å·¦ç«¯çš„ç»“ç‚¹çš„æ•°\n## Code\n```c++\nint findBottomLeftValue(TreeNode* root) {\n    queue<TreeNode*> q1;\n    queue<TreeNode*> q2;\n    q1.push(root);\n    int temp;\n    TreeNode* tmp;\n    int turn = 1;\n    while(!q1.empty() || !q2.empty()) {\n        if(turn == 1) {        \n            temp = q1.front()->val;\n            while(!q1.empty()) {\n                tmp = q1.front();\n                q1.pop(); \n                if(tmp->left != NULL) q2.push(tmp->left);\n                if(tmp->right != NULL) q2.push(tmp->right);\n\n            }\n            if(q2.empty()) \n                return temp;\n            turn = 2;\n        }\n        if(turn == 2) {\n            temp = q2.front()->val;\n            while(!q2.empty()) {\n                tmp = q2.front();\n                q2.pop(); \n                if(tmp->left != NULL) q1.push(tmp->left);\n                if(tmp->right != NULL) q1.push(tmp->right);\n            }\n            if(q1.empty()) \n                return temp;\n            turn = 1;\n        }\n    }\n    return -1;\n}\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200452859","body":"å¾…è¡¥é¢˜\n## Code\n```c++\n    void rserialize(TreeNode* root, string& str) {\n        if (root == nullptr) {\n            str += \"None,\";\n        } else {\n            str += to_string(root->val) + \",\";\n            rserialize(root->left, str);\n            rserialize(root->right, str);\n        }\n    }\n\n    string serialize(TreeNode* root) {\n        string ret;\n        rserialize(root, ret);\n        return ret;\n    }\n\n    TreeNode* rdeserialize(list<string>& dataArray) {\n        if (dataArray.front() == \"None\") {\n            dataArray.erase(dataArray.begin());\n            return nullptr;\n        }\n\n        TreeNode* root = new TreeNode(stoi(dataArray.front()));\n        dataArray.erase(dataArray.begin());\n        root->left = rdeserialize(dataArray);\n        root->right = rdeserialize(dataArray);\n        return root;\n    }\n\n    TreeNode* deserialize(string data) {\n        list<string> dataArray;\n        string str;\n        for (auto& ch : data) {\n            if (ch == ',') {\n                dataArray.push_back(str);\n                str.clear();\n            } else {\n                str.push_back(ch);\n            }\n        }\n        if (!str.empty()) {\n            dataArray.push_back(str);\n            str.clear();\n        }\n        return rdeserialize(dataArray);\n    }\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201445127","body":"## æ€è·¯\nä½¿ç”¨map\n## Code\n```c++\nclass Solution {\npublic:\n    map<int, map<int,vector<int>>> mp;\n    void dfs(TreeNode*p, int x, int y) {\n        if (!p) return;\n        mp[y][x].push_back(p->val);\n        dfs(p->left, x+1, y-1);\n        dfs(p->right, x+1, y+1);\n    }\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        vector<vector<int>> ret;\n        dfs(root, 0, 0);\n        for (auto it = mp.begin(); it != mp.end(); ++it) {\n            vector<int> tmp;\n            for (auto i = it->second.begin(); i != it->second.end(); ++i) {\n                if (i->second.size()>1) \n                    sort(i->second.begin(), i->second.end());\n                for (int j = 0; j < i->second.size(); ++j)\n                    tmp.push_back(i->second[j]);\n            }\n            ret.push_back(tmp);\n        }\n        return ret;\n    }\n};\n```\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202916591","body":"## æ€è·¯\né¦–å…ˆæƒ³åˆ°çš„æ˜¯éå†ä¸¤éï¼Œç„¶åä½¿ç”¨çš„æ˜¯å“ˆå¸Œè¡¨è®°å½•\n## Code\n```c++\nvector<int> twoSum(vector<int>& nums, int target) {\n    unordered_map<int, int> temp;\n    int tmp;\n    for(int i = 0; i < nums.size(); i++) temp[nums[i]] = i+1;\n    for(int i = 0; i < nums.size(); i++) {\n        tmp = target - nums[i];\n        if(tmp != nums[i] && temp[tmp] != 0) {\n            return vector{i, temp[tmp]-1};\n        } else if(temp == nums[i]){\n            if(temp[tmp] - 1 != i) return vector{i, temp[tmp]-1};\n        }\n    }\n    return vector{0,0};\n}\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203398700","body":"## æ€è·¯\nä½¿ç”¨mapè¿›è¡Œç»Ÿè®¡ï¼Œç„¶åæ ¹æ®valueè¿›è¡Œæ’åº\n## Code\n```c++\nvector<int> topKFrequent(vector<int> &nums, int k)\n{\n    unordered_map<int, int> m;\n    for (int i = 0; i < nums.size(); i++)\n        m[nums[i]]++;\n    vector<pair<int, int>> vtm;\n    for(auto it = m.begin(); it != m.end(); it++)\n        vtm.push_back(make_pair(it->first, it->second));\n    sort(vtm.begin(), vtm.end(),\n        [](const pair<int, int> &x, const pair<int, int> &y)-> int {\n            return x.second > y.second;\n        });\n    vector<int> res;\n    for(auto it = vtm.begin(); it != vtm.end(); it++){\n        res.push_back(it->first);\n        k--;\n        if(k==0) break;\n    }\n    return res;\n}\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(nlog2n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204683097","body":"## æ€è·¯\nå“ˆå¸Œè¡¨+æ’åˆ—ï¼Œé¢˜ç›®å°±æ˜¯æ‰¾åˆ°ä¸€ä¸ªç‚¹åˆ°å…¶ä»–ä¸¤ä¸ªç‚¹è·ç¦»ä¸€è‡´çš„ï¼Œå¯ä»¥éå†ä¸€éï¼Œå°†è·ç¦»çš„æ¬¡æ•°ï¼ˆå³åˆ°å½“å‰ç‚¹è·ç¦»ç›¸åŒçš„ç‚¹çš„ä¸ªæ•°ï¼‰è®°å½•åœ¨å“ˆå¸Œè¡¨ä¸­ï¼›\nç„¶åéå†è·ç¦»çš„å“ˆå¸Œè¡¨ï¼Œæ ¹æ®æ’åˆ—ï¼Œä»ç›¸åŒè·ç¦»çš„ç‚¹ä¸­å¯ä»»é€‰ä¸¤ä¸ªï¼Œè®¡ç®—æ’åˆ—æ•°\n## Code\n```c++\nint numberOfBoomerangs(vector<vector<int>> &points)\n{\n    int res = 0;\n    for(int i = 0; i < points.size(); i++) {\n        unordered_map<int, int> cnt;\n        for(int j = 0; j < points.size(); j++) {\n            int distance = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0])\n                        + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\n            cnt[distance]++;\n        }\n        for(auto it = cnt.begin(); it != cnt.end(); it++)\n            res += it->second * (it->second - 1);\n    }\n    return res;\n}\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n^2)\n- ç©ºé—´å¤æ‚åº¦: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205979074","body":"## æ€è·¯\nç”¨å¿«æ…¢æŒ‡é’ˆéå†ï¼Œæ€è·¯ä¸å¤§å¥½ï¼Œçœ‹çœ‹åˆ«äººçš„æ€è·¯\n## Code\n```c++\nint lengthOfLongestSubstring(string s)\n{\n    if(s == \"\") return 0;\n    int n = s.length();\n    int slow = 0, fast = 1;\n    int tmp = 1;\n    int res = 1;\n    unordered_map<char, int> m;\n    m[s[0]] = 1;\n    while (fast < n && slow < n)\n    {\n        // æŒ‡å‘å­—ç¬¦ä¸åŒ\n        if (s[fast] != s[slow])\n        {\n            if(m[s[fast]] != 0) {\n                m[s[slow]]--;\n                slow++;\n                tmp--;\n                continue;\n            }\n            tmp++;\n            if (tmp > res)\n                res = tmp;\n            m[s[fast]]++;\n            fast++;\n        }\n        // æŒ‡å‘å­—ç¬¦ç›¸åŒ\n        else\n        {\n            tmp--;\n            m[s[slow]]--;\n            slow++;\n            if(slow == fast) {\n                m[s[slow]]++;\n                fast = slow+1;\n                tmp = 1;\n            }\n        }\n    }\n    return res;\n}\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207238165","body":"## æ€è·¯\næ»‘åŠ¨çª—å£ï¼Œä½†æ˜¯ä¸ä¼šå†™ï¼Œçœ‹äº†åˆ«äººçš„ä»£ç ï¼Œåé¢è¡¥ä¸ªc++ç‰ˆæœ¬çš„\n## Code\n```java\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        int n = s.length(), m = words.length, w = words[0].length();\n        Map<String, Integer> map = new HashMap<>();\n        for (String str : words) map.put(str, map.getOrDefault(str, 0) + 1);\n        List<Integer> ans = new ArrayList<>();\n        for (int i = 0; i < w; i++) {\n            Map<String, Integer> temp = new HashMap<>();\n            for (int j = i; j + w <= n; j += w) {   \n                String cur = s.substring(j, j + w);\n                temp.put(cur, temp.getOrDefault(cur, 0) + 1);\n                if (j >= i + (m * w)) {\n                    int idx = j - m * w;\n                    String prev = s.substring(idx, idx + w);\n                    if (temp.get(prev) == 1) temp.remove(prev);\n                    else temp.put(prev, temp.get(prev) - 1);\n                    if (!temp.getOrDefault(prev, 0).equals(map.getOrDefault(prev, 0))) continue;\n                }\n                if (!temp.getOrDefault(cur, 0).equals(map.getOrDefault(cur, 0))) continue;\n                if (temp.equals(map)) ans.add(j - (m - 1) * w);\n            }\n        }\n        return ans;\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207437084","body":"## Code\n```\nclass Solution:\n    def solve(self, nums, k):\n        total = sum(nums)\n        mod = total % k\n\n        ans = len(nums)\n        total = 0\n        dic = {0: -1}\n        for j in range(len(nums)):\n            total += nums[j]\n            cur = total % k\n            target = (cur - mod + k) % k\n            if target in dic:\n                ans = min(ans, j - dic[target])\n            dic[cur] = j\n\n        if ans == len(nums):\n            return -1\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1209571162","body":"## ä»£ç \r\n```c++\r\n    ListNode* middleNode(ListNode* head) {\r\n        ListNode* slow = head;\r\n        ListNode* fast = head;\r\n        while (fast != NULL && fast->next != NULL) {\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n        }\r\n        return slow;\r\n    }\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209564487","body":"## æ€è·¯\nåŒæŒ‡é’ˆæ±‚è§£\n## Code\n```c++\n    int removeDuplicates(vector<int>& nums) {\n        int len = nums.size();\n        int j = 0;\n        for (int i = 0; i < len; i++) {\n            if (nums[i] != nums[j]) {\n                nums[++j] = nums[i];\n            }\n        }\n        return j + 1;\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uyplayer":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185419128","body":"## æ€è·¯\r\n\r\næ¯æ¬¡éå†æœ€åä¸€ä¸ªå…ƒç´ å’ŒkåŠ èµ·æ¥ï¼Œå¦‚æœå¤§äº10çš„è¯ è¿›è¡Œè¿‘ä½\r\n\r\n## ä»£ç \r\n``` go\r\n\r\nfunc addToArrayForm(num []int, k int) (ans []int) {\r\n\r\n    // æ¯æ¬¡éå†æå–æœ€åä¸€ä¸ªå…ƒç´ \r\n    for i:=len(num)-1;i>=0;i-- {\r\n        // æœ€åä¸€ä¸ªå…ƒç´ å’ŒkåŠ èµ·æ¥\r\n        sum := num[i] + k\r\n        k = k / 10\r\n        // åˆ¤æ–­sumæ˜¯å¦å¤§äº10\r\n        if sum > 10 {\r\n            k ++\r\n            sum = sum - 10\r\n        }\r\n        ans = append(ans, sum)\r\n\r\n    }\r\n\r\n    for ; k > 0; k /= 10 {\r\n        ans = append(ans, k%10)\r\n    }\r\n    reverse(ans)\r\n    return\r\n   \r\n}\r\n\r\n// åè½¬\r\nfunc reverse(num []int) {\r\n    for i, n := 0, len(num); i < n/2; i++ {\r\n        num[i], num[n-1-i] = num[n-1-i], num[i]\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n## å¤æ‚åº¦åˆ†æ\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(max(n,logk))ï¼Œå…¶ä¸­ n ä¸ºæ•°ç»„çš„é•¿åº¦ã€‚\r\n\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1) ï¼Œé™¤äº†è¿”å›å€¼ä»¥å¤–ï¼Œä½¿ç”¨çš„ç©ºé—´ä¸ºå¸¸æ•°ã€‚\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186211992","body":"## LC 821. å­—ç¬¦çš„æœ€çŸ­è·ç¦»\r\n[Leetcodeè¿æ¥](https://leetcode.cn/problems/shortest-distance-to-a-character/)\r\n\r\n- [é¢å¤–æ•°ç»„è®°å½•ä¸‹æ ‡](#solution1)\r\n\r\n### <span id=\"solution1\">é¢å¤–æ•°ç»„è®°å½•ä¸‹æ ‡</span>\r\n\r\n- é¦–å…ˆç”¨é¢å¤–çš„æ•°ç»„æ¥ä¿å­˜ç›®æ ‡å­—ç¬¦åœ¨ç»™å®šå­—ç¬¦ä¸²çš„ä¸‹è¾¹\r\n- éå†ç»™å®šå­—ç¬¦ä¸²ä¸‹è¾¹å’Œä¸Šé¢ä¿å­˜çš„ç›®æ ‡å­—ç¬¦çš„ä¸‹è¾¹ï¼Œè®¡ç®—å®ƒä»¬ä¸¤ä¸ªçš„è·ç¦»ï¼Œå–æœ€å°çš„è·ç¦»\r\n- ç»“æœä¿å­˜åˆ°å¦ä¸€ä¸ªé¢å¤–çš„æ•°ç»„\r\n\r\n### Golang ä»£ç \r\n\r\n``` go\r\n\r\n\r\nimport \"math\"\r\nimport \"fmt\"\r\nfunc shortestToChar(s string, c byte) []int {\r\n\r\n\r\n    // é€‰è´¤è·å–eçš„ä¸‹è¾¹\r\n    e := make([]int,0)\r\n    for i:=0;i<len(s);i++{\r\n        if s[i] == c {\r\n           e = append(e,i) \r\n        }\r\n\r\n    }\r\n    fmt.Println(e)\r\n    // ç»“æœ\r\n    result := make([]int,0)\r\n\r\n    for i:=0;i<len(s);i++{\r\n        min := 99999999\r\n        for j:=0;j<len(e);j++{\r\n            // fmt.Println(math.Abs(float64(e[j]-j)))\r\n            distance := int(math.Abs(float64(e[j]-i)))\r\n            fmt.Println(distance)\r\n            if distance < min {\r\n                min =  distance\r\n            }\r\n        }\r\n        fmt.Println(min)\r\n        result = append(result,min)\r\n\r\n    }\r\n\r\n    return result\r\n\r\n}\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186446312","body":"\r\n## LC 1381. è®¾è®¡ä¸€ä¸ªæ”¯æŒå¢é‡æ“ä½œçš„æ ˆ\r\n[Leetcodeè¿æ¥](https://leetcode.cn/problems/design-a-stack-with-increment-operation/submissions/)\r\n\r\n- [æ€è·¯](#solution1)\r\n\r\n### <span id=\"solution1\">æ€è·¯</span>\r\n\r\nè¿™ä¸€é“è®¾è®¡é¢˜ï¼Œå·²ç»ç»™å®šäº†maxé•¿åº¦ï¼Œæˆ‘ä»¬ç¬¬ä¸€ä¸ªæƒ³è±¡çš„çš„ä¸€ä¸ªæ•°ç»„,æ•°ç»„æ¥å¯ä»¥æ¨¡æ‹Ÿä¸€ä¸ªæ ˆå’Œæ ˆæ“ä½œ\r\n\r\n\r\n### Golang ä»£ç \r\n\r\n``` go\r\n\r\n\r\n// æ„é€ ä¸€ä¸ªç»“æ„ä½“\r\ntype CustomStack struct {\r\n    maxLen int\r\n\tarray []int\r\n\r\n}\r\n\r\n// æ–°å»ºä¸€ä¸ªstack\r\nfunc Constructor(maxSize int) CustomStack {\r\n\r\n    stack := CustomStack{\r\n\t\tmaxLen: maxSize,\r\n\t\tarray: make([]int, 0),\r\n\t}\r\n\treturn stack\r\n}\r\n\r\n// puhsæ“ä½œ\r\nfunc (this *CustomStack) Push(x int)  {\r\n\r\n    if len(this.array) < this.maxLen {\r\n\t\tthis.array = append(this.array, x)\r\n\t}\r\n\r\n}\r\n\r\n// popæ“ä½œ\r\nfunc (this *CustomStack) Pop() int {\r\n\r\n    if len(this.array) == 0 {\r\n\t\treturn -1\r\n\t}\r\n\tnum := this.array[len(this.array)-1]\r\n\tthis.array = this.array[:len(this.array)-1]\r\n\treturn num\r\n\r\n}\r\n\r\n// å¢å¤§æ ˆ\r\nfunc (this *CustomStack) Increment(k int, val int)  {\r\n\r\n    if len(this.array) <= k {\r\n\t\tfor i := 0; i < len(this.array);i++ {\r\n\t\t\tthis.array[i] += val\r\n\t\t}\r\n\t} else {\r\n\t\tfor i := 0; i < k;i++ {\r\n\t\t\tthis.array[i] += val\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n}\r\n\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * obj := Constructor(maxSize);\r\n * obj.Push(x);\r\n * param_2 := obj.Pop();\r\n * obj.Increment(k,val);\r\n */\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼špop & push O(1)ï¼ŒIncrement : O(k)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(maxSize) ,array ç­‰é•¿åº¦","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186659388","body":"## LC 394. å­—ç¬¦ä¸²è§£ç \r\n[Leetcodeè¿æ¥](https://leetcode.cn/problems/decode-string/)\r\n\r\n- [åˆ†æ”¯æ–¹æ³•](#solution1)\r\n\r\n### <span id=\"solution1\">åˆ†æ”¯æ–¹æ³•</span>\r\n\r\næœ¬é¢˜ä¸­å¯èƒ½å‡ºç°æ‹¬å·åµŒå¥—çš„æƒ…å†µï¼Œæ¯”å¦‚ 2[a2[bc]]ï¼Œè¿™ç§æƒ…å†µä¸‹æˆ‘ä»¬å¯ä»¥å…ˆè½¬åŒ–æˆ 2[abcbc]ï¼Œåœ¨è½¬åŒ–æˆ abcbcabcbcã€‚æˆ‘ä»¬å¯ä»¥æŠŠå­—æ¯ã€æ•°å­—å’Œæ‹¬å·çœ‹æˆæ˜¯ç‹¬ç«‹çš„ TOKENï¼Œå¹¶ç”¨æ ˆæ¥ç»´æŠ¤è¿™äº› TOKENã€‚å…·ä½“çš„åšæ³•æ˜¯ï¼Œéå†è¿™ä¸ªæ ˆï¼š\r\n\r\n- å¦‚æœå½“å‰çš„å­—ç¬¦ä¸ºæ•°ä½ï¼Œè§£æå‡ºä¸€ä¸ªæ•°å­—ï¼ˆè¿ç»­çš„å¤šä¸ªæ•°ä½ï¼‰å¹¶è¿›æ ˆ\r\n- å¦‚æœå½“å‰çš„å­—ç¬¦ä¸ºå­—æ¯æˆ–è€…å·¦æ‹¬å·ï¼Œç›´æ¥è¿›æ ˆ\r\n- å¦‚æœå½“å‰çš„å­—ç¬¦ä¸ºå³æ‹¬å·ï¼Œå¼€å§‹å‡ºæ ˆï¼Œä¸€ç›´åˆ°å·¦æ‹¬å·å‡ºæ ˆï¼Œå‡ºæ ˆåºåˆ—åè½¬åæ‹¼æ¥æˆä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæ­¤æ—¶å–å‡ºæ ˆé¡¶çš„æ•°å­—ï¼ˆæ­¤æ—¶æ ˆé¡¶ä¸€å®šæ˜¯æ•°å­—ï¼Œæƒ³æƒ³ä¸ºä»€ä¹ˆï¼Ÿï¼‰ï¼Œå°±æ˜¯è¿™ä¸ªå­—ç¬¦ä¸²åº”è¯¥å‡ºç°çš„æ¬¡æ•°ï¼Œæˆ‘ä»¬æ ¹æ®è¿™ä¸ªæ¬¡æ•°å’Œå­—ç¬¦ä¸²æ„é€ å‡ºæ–°çš„å­—ç¬¦ä¸²å¹¶è¿›æ ˆ\r\n\r\n\r\n### Golang ä»£ç \r\n\r\n``` go\r\n\r\n\r\nfunc decodeString(s string) string {\r\n    // æ ˆ\r\n    stk := []string{}\r\n    ptr := 0\r\n    for ptr < len(s) {\r\n        cur := s[ptr]\r\n        // å¦‚æœæ˜¯æ•°å­—è¿›æ ˆ\r\n        if cur >= '0' && cur <= '9' {\r\n            digits := getDigits(s, &ptr)\r\n            stk = append(stk, digits)\r\n            // å¦‚æœæ˜¯å­—æ¯æˆ–è€…å·¦å£å·è¿›æ ˆ\r\n        } else if (cur >= 'a' && cur <= 'z' || cur >= 'A' && cur <= 'Z') || cur == '[' {\r\n            stk = append(stk, string(cur))\r\n            // ä¸‹è¾¹å¾€å‰èµ°ä¸€æ­¥\r\n            ptr++\r\n        } else {\r\n            // é‡åˆ°å³æ‹¬å·\r\n            ptr++\r\n            sub := []string{}\r\n            for stk[len(stk)-1] != \"[\" {\r\n                // å‡ºæ ˆ\r\n                sub = append(sub, stk[len(stk)-1])\r\n                // æ›´æ–°str\r\n                stk = stk[:len(stk)-1]\r\n            }\r\n            // åè½¬ \r\n            for i := 0; i < len(sub)/2; i++ {\r\n                sub[i], sub[len(sub)-i-1] = sub[len(sub)-i-1], sub[i]\r\n            }\r\n            //   stk[len(stk)-1] != \"[\" å·²ç»ç¢°åˆ°å³æ‹¬å·']'ï¼Œå»æ‰å®ƒ\r\n            stk = stk[:len(stk)-1]\r\n            // å‡ºæ ˆ çš„æ—¶å€™æ•°å­—\r\n            repTime, _ := strconv.Atoi(stk[len(stk)-1])\r\n            // æ›´æ–°æ ˆ\r\n            stk = stk[:len(stk)-1]\r\n            // é‡å¤\r\n            t := strings.Repeat(getString(sub), repTime)\r\n            // æ·»åŠ åˆ°æ•°ç»„ä¸­\r\n            stk = append(stk, t)\r\n        }\r\n    }\r\n    return getString(stk)\r\n}\r\n\r\nfunc getDigits(s string, ptr *int) string {\r\n    ret := \"\"\r\n    for ; s[*ptr] >= '0' && s[*ptr] <= '9'; *ptr++ {\r\n        ret += string(s[*ptr])\r\n    }\r\n    return ret\r\n}\r\n\r\nfunc getString(v []string) string {\r\n    ret := \"\"\r\n    for _, s := range v {\r\n        ret += s\r\n    }\r\n    return ret\r\n}\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼š è®°è§£ç åå¾—å‡ºçš„å­—ç¬¦ä¸²é•¿åº¦ä¸º SSï¼Œé™¤äº†éå†ä¸€æ¬¡åŸå­—ç¬¦ä¸² ssï¼Œæˆ‘ä»¬è¿˜éœ€è¦å°†è§£ç åçš„å­—ç¬¦ä¸²ä¸­çš„æ¯ä¸ªå­—ç¬¦éƒ½å…¥æ ˆï¼Œå¹¶æœ€ç»ˆæ‹¼æ¥è¿›ç­”æ¡ˆä¸­ï¼Œæ•…æ¸è¿›æ—¶é—´å¤æ‚åº¦ä¸ºO(S+âˆ£sâˆ£)ï¼Œå³ O(S) \r\n- ç©ºé—´å¤æ‚åº¦ï¼šè®°è§£ç åå¾—å‡ºçš„å­—ç¬¦ä¸²é•¿åº¦ä¸º SSï¼Œè¿™é‡Œç”¨æ ˆç»´æŠ¤ TOKENï¼Œæ ˆçš„æ€»å¤§å°æœ€ç»ˆä¸ SS ç›¸åŒï¼Œæ•…æ¸è¿›ç©ºé—´å¤æ‚åº¦ä¸º O(S)ã€‚","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189139221","body":"## LC 232. ç”¨æ ˆå®ç°é˜Ÿåˆ—\r\n[Leetcodeè¿æ¥](https://leetcode.cn/problems/implement-queue-using-stacks/)\r\n\r\n- [åŒæ ˆæ¨¡æ‹Ÿé˜Ÿåˆ—](#solution1)\r\n\r\n### <span id=\"solution1\">æ€è·¯</span>\r\né€šè¿‡åŒæ ˆæ¨¡æ‹Ÿé˜Ÿåˆ—\r\n- push æ“ä½œç›´æ¥å…¥é˜Ÿåˆ—\r\n- pop æ“ä½œç›´åˆ°ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œé˜Ÿåˆ—é‡Œé¢å…ƒç´ ç§»åŠ¨åˆ°å¦ä¸€æ ˆä¸Š\r\n\r\n### Golang ä»£ç \r\n\r\n``` go\r\n/\r\n//  MyQueue\r\n//  @Description: é˜Ÿåˆ—ç»“æ„ä½“\r\n//\r\ntype MyQueue struct {\r\n\tinStack  []int\r\n\toutStack []int\r\n}\r\n\r\n//\r\n//  Constructor\r\n//  @Description: åˆ›å»º\r\n//  @return MyQueue\r\n//\r\nfunc Constructor() MyQueue {\r\n\r\n\treturn MyQueue{\r\n\t\tinStack:  make([]int, 0),\r\n\t\toutStack: make([]int, 0),\r\n\t}\r\n\r\n}\r\n\r\n//\r\n//  Push\r\n//  @Description: å…¥é˜Ÿåˆ—\r\n//  @receiver this\r\n//  @param x\r\n//\r\nfunc (this *MyQueue) Push(x int) {\r\n\r\n\tthis.inStack = append(this.inStack, x)\r\n\r\n}\r\n\r\n//\r\n//  Pop\r\n//  @Description: å‡ºé˜Ÿåˆ—\r\n//  @receiver this\r\n//  @return int\r\n//\r\nfunc (this *MyQueue) Pop() int {\r\n\r\n\t// outStack é•¿åº¦ç­‰äº0\r\n\tif len(this.outStack) == 0 {\r\n\t\tfor len(this.inStack) > 0 {\r\n\t\t\tthis.outStack = append(this.outStack, this.inStack[len(this.inStack)-1])\r\n\t\t\tthis.inStack = this.inStack[:len(this.inStack)-1]\r\n\t\t}\r\n\r\n\t}\r\n\t// è·å–æœ€åä¸€ä¸ªå…ƒç´ \r\n\telem := this.outStack[len(this.outStack)-1]\r\n\t// æ›´æ–°\r\n\tthis.outStack = this.outStack[:len(this.outStack)-1]\r\n\treturn elem\r\n\r\n}\r\n\r\n//\r\n//  Peek\r\n//  @Description: æœ€åä¸€ä¸ªå…ƒç´ \r\n//  @receiver this\r\n//  @return int\r\n//\r\nfunc (this *MyQueue) Peek() int {\r\n\r\n\tif len(this.outStack) == 0 {\r\n\t\tfor len(this.inStack) > 0 {\r\n\t\t\tthis.outStack = append(this.outStack, this.inStack[len(this.inStack)-1])\r\n\t\t\tthis.inStack = this.inStack[:len(this.inStack)-1]\r\n\t\t}\r\n\t}\r\n\treturn this.outStack[len(this.outStack)-1]\r\n\r\n}\r\n\r\nfunc (this *MyQueue) Empty() bool {\r\n\treturn len(this.inStack) == 0 && len(this.outStack) == 0\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * obj := Constructor();\r\n * obj.Push(x);\r\n * param_2 := obj.Pop();\r\n * param_3 := obj.Peek();\r\n * param_4 := obj.Empty();\r\n */\r\n\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼špushå’Œemptyæ“ä½œO(1),popå’Œpeekæ“ä½œO(N),å…¶ä¸­Næ˜¯å…ƒç´ ä»ä¸€ä¸ªæ ˆç§»åŠ¨åˆ°å¦ä¸€ä¸ªæ ˆæ¬¡æ•°\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190443337","body":"## LC 768. æœ€å¤šèƒ½å®Œæˆæ’åºçš„å— II\r\n[Leetcodeè¿æ¥](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/)\r\n\r\n- [æ€è·¯](#solution1)\r\n\r\n### <span id=\"solution1\">æ€è·¯</span>\r\n\r\nåˆ†å—åè¿›è¡Œæ’åºå’ŒåŸæ¥æ•°ç»„ç›¸ç­‰çš„æ—¶å€™åˆ†å—æ•°é‡å§\r\n- åˆ†å—åæ¯ä¸€ä¸ªåˆ†å—è¿›è¡Œæ’åº\r\n- æ’åºåï¼Œæ‰€æœ‰çš„åˆ†å—è¿›è¡Œè¿æ¥\r\n- æ’åºæ•°ç»„å’ŒåŸæ¥æ•°ç»„çš„å‰kå…ƒç´ ç›¸å‡å»åçš„ç»“æœç­‰äº0çš„è¯ï¼Œé‚£ä¹ˆè¿™ä½ä¸€ä¸ªåˆ†å—\r\n- è¿æ¥çš„æ•°ç»„æ˜¯å¦ç›¸ç­‰åŸæ¥çš„æ•°ç»„\r\n\r\n\r\n### Golang ä»£ç \r\n\r\n``` go\r\n\r\nimport \"sort\"\r\n\r\nfunc maxChunksToSorted(arr []int) int {\r\n\r\n\tlength := len(arr)\r\n\tif length <= 1 {\r\n\t\treturn 1\r\n\t}\r\n\tarray := make([]int, length)\r\n\tcopy(array, arr)\r\n\tsort.Ints(array)\r\n\tsum, ret := 0, 0\r\n\tfor i := 0; i < l; i++ {\r\n\t\tsum += (arr[i] - array[i])\r\n\t\tif sum == 0 {\r\n\t\t\tret++\r\n\t\t}\r\n\t}\r\n\treturn ret\r\n\r\n}\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šæ’åºï¼šO(NLogN)ï¼Œå¾ªç¯:O(N);å…¶ä¸­Næ•°ç»„é•¿åº¦ï¼ŒO(N(1+logN))ç®€åŒ–ä¸ºO(NLogN)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N);å…¶ä¸­Næ•°ç»„é•¿åº¦ï¼Œåˆ›å»ºäº†ä¸€ä¸ªæ•°ç»„","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191586881","body":"## LC 61. æ—‹è½¬é“¾è¡¨\r\n[Leetcodeè¿æ¥](https://leetcode.cn/problems/rotate-list/)\r\n\r\n- [é“¾è¡¨](#solution1)\r\n\r\n### <span id=\"solution1\">é“¾è¡¨</span>\r\n\r\n- å…ˆè®¡ç®—è¡¨é•¿åº¦å’Œæ‰¾åˆ°å°¾èŠ‚ç‚¹\r\n- è®¡ç®—éœ€è¦ç§»åŠ¨çš„å…ƒç´ æ•°é‡\r\n- å¼€å§‹ç§»åŠ¨ num-k-1 æ¬¡\r\n- å½¢æˆç¯tail.Next = head\r\n- å½¢æˆå¤´head = mid.Next\r\n- æ–­å¼€mid.Next = nil\r\n\r\n### Golang ä»£ç \r\n\r\n``` go\r\n\r\n\r\nfunc rotateRight(head *ListNode, k int) *ListNode {\r\n\r\n\tif head == nil {\r\n\t\treturn nil\r\n\t}\r\n\t//tail := &ListNode{\r\n\t//\tNext: head,\r\n\t//}\r\n\ttail := head\r\n\tmid, cur := head, head\r\n\tnum := 0\r\n\t// æ‰¾\r\n\tfor cur != nil {\r\n\t\tnum++\r\n\t\ttail = tail.Next\r\n\t\tcur = cur.Next\r\n\t}\r\n\t// è®¡ç®—è¦ç§»åŠ¨æ­¥æ•°\r\n\tk = k % num\r\n\t// å¼€å§‹ç§»åŠ¨\r\n\tfor i := 0; i < num-k-1; i++ {\r\n\t\tmid = mid.Next\r\n\t}\r\n\t// æ¢\r\n\ttail.Next = head\r\n\t// è¿æ¥å¤´\r\n\thead = mid.Next\r\n\t// æ–­å¼€\r\n\tmid.Next = nil\r\n\r\n\treturn head\r\n\r\n}\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­Né“¾è¡¨é•¿åº¦ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)ï¼Œç§»åŠ¨æŒ‡é’ˆè€Œå·²","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192189056","body":"## LC 24. ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹\r\n[Leetcodeè¿æ¥](https://leetcode-solution.cn/solutionDetail?type=3&id=8&max_id=2)\r\n\r\n- [è¿­ä»£](#solution1)\r\n- [é€’å½’](#solution2)\r\n- [æ€»ç»“æˆ‘çš„é”™è¯¯](#solution3)\r\n\r\n### <span id=\"solution1\">è¿­ä»£</span>\r\n\r\n\r\né¦–å…ˆè€ƒè™‘ä¿®æ”¹ä¸¤ä¸ªèŠ‚ç‚¹å‡ éœ€è¦å‡ æ¬¡æ“ä½œå‘¢ï¼Ÿ ç­”æ¡ˆ4æ¬¡ï¼›æ¯”å¦‚\r\npreA -> A -> B ->BNext ä¿®æ”¹ä¸º preA ->B ->A ->nextB\r\n\r\n- AæŒ‡å‘BNext ï¼Œ preA ->A->nextB ;B->nextB\r\n- B èŠ‚ç‚¹çš„ next æŒ‡å‘ A; preA -> A -> nextB ;B -> A\r\n- preA èŠ‚ç‚¹çš„ next æŒ‡å‘ B;B -> A;preA -> B -> A -> nextB\r\n\r\nA.next = next.B;\r\nB.next = A;\r\npreA.next = B;\r\n\r\n### Golang ä»£ç \r\n\r\n``` go\r\n\r\n\r\n\r\n//\r\n//  swapPairs\r\n//  @Description:ç»™ä½ ä¸€ä¸ªé“¾è¡¨ï¼Œä¸¤ä¸¤äº¤æ¢å…¶ä¸­ç›¸é‚»çš„èŠ‚ç‚¹ï¼Œå¹¶è¿”å›äº¤æ¢åé“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚ä½ å¿…é¡»åœ¨ä¸ä¿®æ”¹èŠ‚ç‚¹å†…éƒ¨çš„å€¼çš„æƒ…å†µä¸‹å®Œæˆæœ¬é¢˜ï¼ˆå³ï¼Œåªèƒ½è¿›è¡ŒèŠ‚ç‚¹äº¤æ¢ï¼‰ã€‚\r\n//  @param head\r\n//  @return *ListNode\r\n//\r\nfunc swapPairs(head *ListNode) *ListNode {\r\n\r\n\tnodes := &ListNode{\r\n\t\tNext: head,\r\n\t}\r\n\r\n\t//result := nodes\r\n\t//previous := nodes\r\n\t//for head != nil && head.Next != nil {\r\n\t//\t// å½“å‰çš„èŠ‚ç‚¹å’Œä¸‹ä¸€ä¸ªèŠ‚ç‚¹\r\n\t//\tnow := head\r\n\t//\tnext := head.Next\r\n\t//\t// now å“¨å…µæŒ‡å‘nextçš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹\r\n\t//\tnow.Next = next.Next\r\n\t//\tnext.Next = previous.Next\r\n\t//\tprevious.Next = next\r\n\t//\r\n\t//\tprevious = now\r\n\t//\thead = now.Next\r\n\t//\r\n\t//}\r\n\r\n\t//result := nodes\r\n\t//previous := nodes\r\n\t//for previous.Next != nil && previous.Next.Next != nil {\r\n\t//\tnow := previous.Next\r\n\t//\tnext := previous.Next.Next\r\n\t//\r\n\t//\tprevious.Next = next\r\n\t//\tnow.Next = next.Next\r\n\t//\tnext.Next = now\r\n\t//\r\n\t//\tprevious = now\r\n\t//\r\n\t//}\r\n\r\n\tprevious := nodes\r\n\tcurrent := previous.Next // ç›¸å½“äºhead\r\n\tfor current != nil && current.Next != nil {\r\n\t\tnext := current.Next\r\n\t\tcurrent.Next = next.Next\r\n\t\tnext.Next = current\r\n\t\tprevious.Next = next\r\n\r\n\t\tprevious = current\r\n\t\tcurrent = current.Next\r\n\t}\r\n\r\n\treturn nodes.Next\r\n}\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºèŠ‚ç‚¹é•¿åº¦é•¿åº¦ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)\r\n\r\n\r\n\r\n### <span id=\"solution2\">é€’å½’</span>\r\n\r\n- å°±æ˜¯cur.Next.Next æ”¾è¿›é€’å½’é‡Œé¢\r\n- cur.Next æŒ‡å‘ é€’å½’è¿”å›è¿‡æ¥çš„ä¿¡æ¯\r\n- next.Next æŒ‡å‘cur\r\n\r\n### ä»£ç \r\n\r\n\r\n``` goï¼ˆæ­¤å¤„æ¢æˆä½ çš„è¯­è¨€ï¼Œæ¯”å¦‚jsï¼Œpy ç­‰ï¼‰\r\n\r\n\r\n//\r\n//  swapPairs\r\n//  @Description: é€’å½’\r\n//  @param head\r\n//  @return *ListNode\r\n//\r\nfunc swapPairs(head *ListNode) *ListNode {\r\n\r\n\t// é€’å½’ç»“æŸæ¡ä»¶\r\n\tif head == nil && head.Next == nil {\r\n\t\treturn head\r\n\t}\r\n\r\n\tnow := head\r\n\tnext := head.Next\r\n\tnextNext := swapPairs(next.Next)\r\n\tnow.Next = nextNext\r\n\tnext.Next = now\r\n\r\n\treturn next\r\n\r\n}\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºèŠ‚ç‚¹é•¿åº¦é•¿åº¦ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)\r\n\r\n\r\n### <span id=\"solution3\">æ€»ç»“æˆ‘çš„é”™è¯¯</span>\r\n\r\n``` go\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * type ListNode struct {\r\n *     Val int\r\n *     Next *ListNode\r\n * }\r\n */\r\nfunc swapPairs(head *ListNode) *ListNode {\r\n\r\n    nodes := &ListNode{\r\n\t\tNext: head,\r\n\t}\r\n\r\n\tresult := nodes\r\n\t\r\n  \r\n\tfor nodes.Next != nil && nodes.Next.Next != nil {\r\n\t\t\r\n        next := nodes.Next.Next\r\n\t\tcurrent := nodes.Next\r\n\t\tnodes.Next = next.Next\r\n\t\tnodes.Next.Next = current\r\n\t\t\r\n\t}\r\n\r\n\treturn result.Next\r\n\r\n}\r\n\r\n```\r\nå…¶å®ä¸Šé¢ä»£ç é‡Œé¢æˆ‘åªåœ¨ä¹å½“å‰å’Œä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚æ›´æœ¬æ²¡åœ¨ä¹å½“å‰èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹\r\nè¿™é‡Œæ ¹æœ¬æ²¡è€ƒè™‘previous å’Œ previous.Next èŠ‚ç‚¹\r\næ³¨æ„è¿™é‡Œ å¦‚æœå†™æˆ  next.Next = current å½¢æˆä¸€ä¸ªç¯ ï¼Œæ‰€ä»¥ä¸èƒ½è¿™æ ·å†™ï¼Œåªè¿™æ ·å†™ next.Next = pre.Next\r\n\r\n``` go\r\nnodes := &ListNode{\r\n\t\tNext: head,\r\n\t}\r\n\r\n\tresult := nodes\r\n\tpre := nodes\r\n\tfor head != nil && head.Next != nil {\r\n\r\n\t\tcurrent := head\r\n\t\tnext := head.Next\r\n\t\tcurrent.Next = next.Next\r\n\t\tnext.Next = pre.Next\r\n\t\tpre.Next = next\r\n\r\n\t\tpre = current\r\n\t\thead = current.Next\r\n\r\n\t}\r\n\r\n\treturn result.Next\r\n\r\n```\r\n\r\n\r\n### æ€è·¯\r\né¦–å…ˆè€ƒè™‘ä¿®æ”¹ä¸¤ä¸ªèŠ‚ç‚¹å‡ éœ€è¦å‡ æ¬¡æ“ä½œå‘¢ï¼Ÿ ç­”æ¡ˆ4æ¬¡ï¼›æ¯”å¦‚\r\npreA -> A -> B ->BNext ä¿®æ”¹ä¸º preA ->B ->A ->nextB\r\n\r\n- AæŒ‡å‘BNext ï¼Œ preA ->A->nextB ;B->nextB\r\n- B èŠ‚ç‚¹çš„ next æŒ‡å‘ A; preA -> A -> nextB ;B -> A\r\n- preA èŠ‚ç‚¹çš„ next æŒ‡å‘ B;B -> A;preA -> B -> A -> nextB\r\n\r\nA.next = next.B;\r\nB.next = A;\r\npreA.next = B;\r\nå…¶å®ä¸Šé¢ä»£ç é‡Œé¢æˆ‘åªåœ¨ä¹å½“å‰å’Œä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚æ›´æœ¬æ²¡åœ¨ä¹å½“å‰èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹\r\nè¿™é‡Œæ ¹æœ¬æ²¡è€ƒè™‘previous å’Œ previous.Next èŠ‚ç‚¹\r\næ³¨æ„è¿™é‡Œ å¦‚æœå†™æˆ  next.Next = current å½¢æˆä¸€ä¸ªç¯ ï¼Œæ‰€ä»¥ä¸èƒ½è¿™æ ·å†™ï¼Œåªè¿™æ ·å†™ next.Next = pre.Next\r\nå¦‚æœ next.Next = current çš„è¯ å½¢æˆä¸€ä¸ªç¯ï¼Œå› ä¸º next.Next =  nodes.Next ï¼Œ ç„¶åcurrent.NextæŒ‡å‘next.Next\r\n\r\n``` go\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * type ListNode struct {\r\n *     Val int\r\n *     Next *ListNode\r\n * }\r\n */\r\nfunc swapPairs(head *ListNode) *ListNode {\r\n\r\n    nodes := &ListNode{\r\n\t\tNext: head,\r\n\t}\r\n\r\n\tresult := nodes\r\n\tpre := nodes\r\n\tfor nodes.Next != nil && nodes.Next.Next != nil {\r\n\t\tcurrent := nodes.Next\r\n\t\tnext := nodes.Next.Next\r\n\t\t// å½“å‰èŠ‚ç‚¹ A\r\n\t\tcurrent.Next = next.Next\r\n\t\t// èŠ‚ç‚¹B\r\n\t\tnext.Next = pre.Next\r\n\t\t// preANext\r\n\t\tpre.Next = next\r\n\r\n\t\t// pre\r\n\t\tpre = current\r\n        nodes = nodes.Next\r\n\r\n\t}\r\n\r\n\r\n\r\n\treturn result.Next\r\n\t\r\n}\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºèŠ‚ç‚¹é•¿åº¦é•¿åº¦ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193066414","body":"## LC 109. æœ‰åºé“¾è¡¨è½¬æ¢äºŒå‰æœç´¢æ ‘\r\n[Leetcodeè¿æ¥](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/)\r\n\r\n- [é€’å½’+å¿«æ…¢æŒ‡é’ˆ](#solution1)\r\n- [é€’å½’+æ•°ç»„](#solution2)\r\n\r\n### <span id=\"solution1\">é€’å½’+å¿«æ…¢æŒ‡é’ˆ</span>\r\n\r\né€šè¿‡æ¯æ¬¡é€’å½’æ…¢æŒ‡é’ˆæ‰¾æ­£ä¸­é—´å…ƒç´ ï¼Œç„¶åè¿›è¡Œèµ‹å€¼;åœ¨è¿›è¡Œéå†æ ‘çš„å·¦å³çš„å­æ ‘\r\n\r\n### Golang ä»£ç \r\n\r\n``` go\r\n\r\n\r\n//\r\n//  sortedListToBST\r\n//  @Description:\r\n//  @param head\r\n//  @return *TreeNode\r\n//\r\nfunc sortedListToBST(head *ListNode) *TreeNode {\r\n\t// å¦‚æœ head ç©º\r\n\tif head == nil {\r\n\t\treturn nil\r\n\t}\r\n\t// å¼€å§‹iéå†\r\n\treturn dfs(head, nil)\r\n\r\n}\r\n\r\nfunc dfs(head, tail *ListNode) *TreeNode {\r\n\t// é€’å½’æ¨å‡ºé¢˜æ¡ä»¶\r\n\tif head == tail {\r\n\t\treturn nil\r\n\t}\r\n\t// å¿«æ…¢æŒ‡é’ˆ\r\n\tfast, slow := head, head\r\n\tfor fast != tail && fast.Next != tail {\r\n\t\tfast = fast.Next.Next\r\n\t\tslow = slow.Next\r\n\t}\r\n\t// åˆ›å»ºrootèŠ‚ç‚¹\r\n\troot := &TreeNode{Val: slow.Val}\r\n\troot.Left = dfs(head, slow)\r\n\troot.Right = dfs(slow.Next, tail)\r\n\treturn root\r\n\r\n}\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šé€’å½’æ ‘çš„æ·±åº¦ä¸º lognï¼Œæ¯ä¸€å±‚çš„åŸºæœ¬æ“ä½œæ•°ä¸º nï¼Œå› æ­¤æ€»çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(nlogn);ä¸€èˆ¬é€’å½’çš„æ—¶é—´å¤æ‚åº¦æ˜¯èŠ‚ç‚¹æ•°é‡ * å…·ä½“æ“ä½œ\r\n- ç©ºé—´å¤æ‚åº¦ï¼šç©ºé—´å¤æ‚åº¦ä¸ºO(logn)\r\n\r\n\r\n\r\n\r\n\r\n### <span id=\"solution2\">é€’å½’+æ•°ç»„</span>\r\n\r\n- åˆ›å»ºä¸€ä¸ªæ•°ç»„ï¼Œå¹¶æ‰€æœ‰çš„ å…ƒç´ å­˜åˆ°æ•°ç»„ä¸­ï¼Œ\r\n- æ¯æ¬¡è·ä¸­é—´çš„å…ƒç´ ä½œä¸ºrootï¼Œmid = (end - start) / 2 + star\r\n\r\n### ä»£ç \r\n\r\n\r\n``` goï¼ˆæ­¤å¤„æ¢æˆä½ çš„è¯­è¨€ï¼Œæ¯”å¦‚jsï¼Œpy ç­‰ï¼‰\r\n\r\n\r\nfunc sortedListToBST1(head *ListNode) *TreeNode {\r\n\tif head == nil {\r\n\t\treturn nil\r\n\t}\r\n\r\n\tarray := make([]int, 0)\r\n\t// æ¯ä¸ªèŠ‚ç‚¹å­˜åˆ°æ•°ç»„ä¸­\r\n\tfor head != nil {\r\n\t\tarray = append(array, head.Val)\r\n\t\thead = head.Next\r\n\t}\r\n\t// å¼€å§‹è°ƒç”¨é€’å½’\r\n\treturn dfs1(array, 0, len(array))\r\n}\r\n\r\nfunc dfs1(res []int, start, end int) *TreeNode {\r\n\t//  éå†å®Œ\r\n\tif start >= end {\r\n\t\treturn nil\r\n\t}\r\n\t//  è·å–ä¸­é—´çš„èŠ‚ç‚¹\r\n\tmid := (end-start)/2 + start\r\n\troot := &TreeNode{Val: res[mid]}\r\n\troot.Left = dfs1(res, start, mid)\r\n\troot.Right = dfs1(res, mid+1, end)\r\n\treturn root\r\n\r\n}\r\n\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šæ—¶é—´å¤æ‚åº¦ä¸ºO(n)ï¼ŒèŠ‚ç‚¹æ•°é‡\r\n- ç©ºé—´å¤æ‚åº¦ï¼šç©ºé—´å¤æ‚åº¦ä¸ºO(n)ï¼Œåˆ›å»ºä¸€ä¸ªå¤§å°nçš„æ•°ç»„\r\n\r\n\r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193333517","body":"## LC 160. ç›¸äº¤é“¾è¡¨\r\n[Leetcodeè¿æ¥](https://leetcode.cn/problems/intersection-of-two-linked-lists/)\r\n\r\n- [å­—å…¸](#solution1)\r\n- [è¿­ä»£](#solution2)\r\n\r\n### <span id=\"solution1\">å­—å…¸</span>\r\n\r\n- å…ˆéå†Aé“¾è¾¹ï¼Œå­˜åˆ°å­—å…¸ä¸­\r\n- åœ¨éå†Bé“¾è¡¨ï¼Œä»å­—å…¸æŸ¥è¯¢ï¼Œå¦‚æœæŸ¥åˆ°å°±å½“å‰èŠ‚ç‚¹äº¤æ¥ç‚¹\r\n\r\n### Golang ä»£ç \r\n\r\n``` go\r\n//\r\n//  getIntersectionNode\r\n//  @Description: é¢å¤–ç©ºé—´å­—å…¸\r\n//  @param headA\r\n//  @param headB\r\n//  @return *ListNode\r\n//\r\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\r\n\r\n\tif headA == nil || headB == nil {\r\n\t\treturn nil\r\n\t}\r\n\r\n\tdic := make(map[*ListNode]bool)\r\n\r\n\tfor headA != nil {\r\n\t\tdic[headA] = true\r\n\t\theadA = headB.Next\r\n\t}\r\n\r\n\tfor headB != nil {\r\n\t\tif _, ok := dic[headB]; ok {\r\n\t\t\treturn headB\r\n\t\t}\r\n\r\n\t\theadB = headB.Next\r\n\t}\r\n\r\n\treturn nil\r\n\r\n}\r\n\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šAå’ŒBé“¾è¡¨çš„å…ƒç´ ä¸ªæ•°åˆ†åˆ« M å’Œ N ï¼›ä¸¤æ¬¡è¿­ä»£ï¼Œåˆ™æ—¶é—´å¤æ‚åº¦ O(M+N)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šé¢å¤–ä½¿ç”¨é“¾ä¸€ä¸ªå­—å…¸ï¼Œå­—å…¸é•¿åº¦ç­‰äºAçš„é“¾è¡¨å…ƒç´ é•¿åº¦ï¼Œåˆ™ ç©ºé—´å¤æ‚åº¦ O(M)\r\n\r\n\r\n\r\n\r\n\r\n### <span id=\"solution2\">è¿­ä»£</span>\r\n\r\nä¸¤ä¸ªè¡¨çš„é•¿åº¦ä¸ä¸€æ ·ï¼Œæ€ä¹ˆæ‰èƒ½è·å–åˆ°è¿™ä¸ªäº¤æ¥ç‚¹å‘¢ï¼Ÿå¦‚æœä¸¤ä¸ªè¡¨åŒæ—¶åˆ°äº¤æ¥ç‚¹å‘¢\r\n\r\nç­” ï¼š paéå†Aè¡¨åç»§ç»­éå†Bè¡¨ï¼Œpbéå†å®ŒBè¡¨åç»§ç»­éå†Aè¡¨ï¼Œè¿™ç”¨èƒ½ä¿è¯å®ƒä»¬åŒæ—¶åˆ°äº¤ç•Œç‚¹\r\n\r\n\r\n### ä»£ç \r\n\r\n\r\n``` goï¼ˆæ­¤å¤„æ¢æˆä½ çš„è¯­è¨€ï¼Œæ¯”å¦‚jsï¼Œpy ç­‰ï¼‰\r\n\r\n\r\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\r\n\r\n\tpA, pB := headA, headB\r\n\r\n\tfor pA != pB {\r\n\t\tif pA == nil {\r\n\t\t\tpA = headB\r\n\t\t} else {\r\n\t\t\tpA = pA.Next\r\n\t\t}\r\n\r\n\t\tif pB == nil {\r\n\t\t\tpB = headA\r\n\t\t} else {\r\n\t\t\tpB = pB.Next\r\n\t\t}\r\n\t}\r\n\r\n\treturn pA\r\n\r\n}\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šAå’ŒBé“¾è¡¨çš„å…ƒç´ ä¸ªæ•°åˆ†åˆ« M å’Œ N ï¼›ä¸¤æ¬¡è¿­ä»£ï¼Œåˆ™æ—¶é—´å¤æ‚åº¦ O(M+N)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šç©ºé—´å¤æ‚åº¦ O(1) \r\n\r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194219876","body":"## LC æ ‡é¢˜\r\n[Leetcodeè¿æ¥](https://leetcode.cn/problems/linked-list-cycle-ii/)\r\n\r\n- [å­—å…¸](#solution1)\r\n- [è¿­ä»£](#solution2)\r\n\r\n### <span id=\"solution1\">å­—å…¸</span>\r\n\r\n-è¾¹éå†è¾¹æŸ¥è¯¢ï¼Œå¦‚æœæŸ¥åˆ°ï¼Œå°±æ˜¯å…¥ç¯çš„èŠ‚ç‚¹\r\n\r\n### Golang ä»£ç \r\n\r\n``` go\r\n\r\n\r\n//\r\n//  detectCycle\r\n//  @Description:\r\n//  @param head\r\n//  @return *ListNode\r\n//\r\nfunc detectCycle(head *ListNode) *ListNode {\r\n\tif head == nil || head.Next == nil {\r\n\t\treturn nil\r\n\t}\r\n\r\n\tdic := make(map[*ListNode]bool)\r\n\r\n\tp := head\r\n\tfor p != nil {\r\n\t\tif _, ok := dic[p]; ok {\r\n\t\t\treturn p\r\n\t\t} else {\r\n\t\t\tdic[p] = true\r\n\t\t}\r\n\t\tp = p.Next\r\n\r\n\t}\r\n\r\n\treturn nil\r\n}\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N) å…¶ä¸­ N ä¸ºå…ƒç´ ä¸ªæ•°\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(M) å­—å…¸é•¿åº¦\r\n\r\n\r\n\r\n\r\n### <span id=\"solution1\">è¿­ä»£</span>\r\n\r\n- fast æ¯” slow å¿«ä¸€æ­¥\r\n- å½“å®ƒä»¬ä¸¤ä¸ªé‡åˆ°çš„æ—¶å€™ï¼Œfast é‡å®šå‘åˆ°head èŠ‚ç‚¹ï¼Œå¹¶ä¸”å®ƒä»¬ä¸¤ä¸ªé€Ÿåº¦ä¸€æ ·æ¯æ¬¡èµ°ä¸€æ­¥\r\n- ç»§ç»­é€šè¿‡å¦ä¸€ä¸ªå¾ªç¯éå† fast å’Œ slow ï¼Œå½“å®ƒä»¬é‡åˆ°çš„æ—¶å€™ï¼Œå°±æ˜¯ç¯çš„å…¥å£èŠ‚ç‚¹\r\n\r\n### ä»£ç \r\n\r\n\r\n``` goï¼ˆæ­¤å¤„æ¢æˆä½ çš„è¯­è¨€ï¼Œæ¯”å¦‚jsï¼Œpy ç­‰ï¼‰\r\n\r\n\r\n//\r\n//  detectCycle\r\n//  @Description:\r\n//  @param head\r\n//  @return *ListNode\r\n//\r\nfunc detectCycle1(head *ListNode) *ListNode {\r\n\tif head == nil || head.Next == nil {\r\n\t\treturn nil\r\n\t}\r\n\r\n\tfast, slow := head, head\r\n\tfor fast != nil && fast.Next != nil {\r\n\t\tfast = fast.Next.Next\r\n\t\tslow = slow.Next\r\n\t\tif slow == fast {\r\n\t\t\tslow = head\r\n\t\t\tfor fast != slow {\r\n\t\t\t\tfast = fast.Next\r\n\t\t\t\tslow = slow.Next\r\n\t\t\t}\r\n\t\t\treturn slow\r\n\t\t}\r\n\t}\r\n\r\n\treturn nil\r\n\r\n}\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºèŠ‚ç‚¹ä¸ªä¸ªæ•°ã€‚åœ¨æœ€åˆåˆ¤æ–­å¿«æ…¢æŒ‡é’ˆæ˜¯å¦ç›¸é‡æ—¶ï¼Œslow æŒ‡é’ˆèµ°è¿‡çš„è·ç¦»ä¸ä¼šè¶…è¿‡é“¾è¡¨çš„æ€»é•¿åº¦ï¼›éšåå¯»æ‰¾å…¥ç¯ç‚¹æ—¶ï¼Œèµ°è¿‡çš„è·ç¦»ä¹Ÿä¸ä¼šè¶…è¿‡é“¾è¡¨çš„æ€»é•¿åº¦ã€‚å› æ­¤ï¼Œæ€»çš„æ‰§è¡Œæ—¶é—´ä¸º O(N) + O(N)=O(2N)  ï¼Œç®€åŒ–ä¸º O(N)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)ï¼Œåªåˆ›å»ºäº†ä¸¤ä¸ªæŒ‡é’ˆslow å’Œ fast\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195649264","body":"### æ€è·¯\r\nåŒå‘é“¾è¡¨ + map\r\n\r\n### ä»£ç \r\n``` go\r\n\r\n// åŒå‘é“¾è¡¨ + map\r\ntype LRUCache struct {\r\n\tm          map[int]*DLinkNode\r\n\tcapacity   int // å®¹é‡\r\n\tsize       int // å½“å‰å¤§å°\r\n\thead, tail *DLinkNode\r\n}\r\n\r\n// åŒå‘é“¾è¡¨  å¤´éƒ¨ä»£è¡¨æœ€æ–°ï¼Œå°¾éƒ¨ä»£è¡¨æœ€ä¹…æœªä½¿ç”¨\r\ntype DLinkNode struct {\r\n\tkey, val  int\r\n\tpre, next *DLinkNode\r\n}\r\n\r\nfunc newDLinkNode(key, value int) *DLinkNode {\r\n\treturn &DLinkNode{\r\n\t\tkey: key,\r\n\t\tval: value,\r\n\t}\r\n}\r\n\r\nfunc Constructor(capacity int) LRUCache {\r\n\tl := LRUCache{\r\n\t\tm:        make(map[int]*DLinkNode, capacity),\r\n\t\tcapacity: capacity,\r\n\t\tsize:     0,\r\n\t\thead:     newDLinkNode(0, 0),\r\n\t\ttail:     newDLinkNode(0, 0),\r\n\t}\r\n\tl.head.next = l.tail\r\n\tl.tail.pre = l.head\r\n\treturn l\r\n}\r\n\r\nfunc (this *LRUCache) Get(key int) int {\r\n\tnode, ok := this.m[key]\r\n\tif ok {\r\n\t\t// æŠŠnodeèŠ‚ç‚¹æ”¾åˆ°å¤´éƒ¨\r\n\t\tnode.pre.next = node.next\r\n\t\tnode.next.pre = node.pre\r\n\t\tthis.head.next.pre = node\r\n\t\tnode.next = this.head.next\r\n\t\tnode.pre = this.head\r\n\t\tthis.head.next = node\r\n\t\treturn node.val\r\n\t} else {\r\n\t\treturn -1\r\n\t}\r\n}\r\n\r\nfunc (this *LRUCache) Put(key int, value int) {\r\n\t// å…ˆåˆ¤æ–­æ˜¯å¦å·²ç»æœ‰äº†keyï¼Œå¦‚æœæœ‰å°±æ›´æ–°å€¼å¹¶æ”¾åˆ°å¤´ç»“ç‚¹ï¼Œæ²¡æœ‰å†æ’å…¥\r\n\tnode, ok := this.m[key]\r\n\tif ok {\r\n\t\t// æ›´æ–°nodeå€¼ï¼Œç„¶åå°†nodeèŠ‚ç‚¹æŠ½å‡ºå†å¤´æ’\r\n\t\tnode.val = value\r\n\t\tnode.pre.next = node.next\r\n\t\tnode.next.pre = node.pre\r\n\t\tthis.head.next.pre = node\r\n\t\tnode.next = this.head.next\r\n\t\tthis.head.next = node\r\n\t\tnode.pre = this.head\r\n\t} else {\r\n\t\tif this.size < this.capacity {\r\n\t\t\t// ç›´æ¥å¤´æ’\r\n\t\t\tthis.size++\r\n\t\t} else {\r\n\t\t\t// å…ˆå¼¹å‡ºæœ«å°¾\r\n\t\t\tdelete(this.m, this.tail.pre.key)\r\n\t\t\tthis.tail.pre.pre.next = this.tail\r\n\t\t\tthis.tail.pre = this.tail.pre.pre\r\n\t\t}\r\n\t\t// å†å¤´æ’nodeèŠ‚ç‚¹\r\n\t\tnode := newDLinkNode(key, value)\r\n\t\tthis.m[key] = node\r\n\t\tthis.head.next.pre = node\r\n\t\tnode.next = this.head.next\r\n\t\tthis.head.next = node\r\n\t\tnode.pre = this.head\r\n\t}\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * obj := Constructor(capacity);\r\n * param_1 := obj.Get(key);\r\n * obj.Put(key,value);\r\n */\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šget å’Œ put æ“ä½œæ—¶é—´å¤æ‚åº¦éƒ½æ˜¯O(1)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­Nå­—å…¸çš„é•¿åº¦\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196831235","body":"\r\n## LC 104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦\r\n[Leetcodeè¿æ¥](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)\r\n\r\n- [BFS](#solution1)\r\n- [DFS](#solution2)\r\n- [å›æº¯](#solution3)\r\n\r\n### <span id=\"solution1\">æ€è·¯DFS</span>\r\n\r\næ€è·¯éå¸¸ç®€å•ã€‚é€šè¿‡é€’å½’éå†æ¯ä¸ªèŠ‚ç‚¹å·¦å³èŠ‚ç‚¹\r\n- é€’å½’ç»“æŸæ¡ä»¶æ˜¯å½“èŠ‚ç‚¹nil çš„æ—¶å€™è¿”å›0\r\n\r\n### Golang ä»£ç \r\n\r\n``` go\r\n//\r\n//  maxDepth\r\n//  @Description: é€’å½’\r\n//  @param root\r\n//  @return int\r\n//\r\nfunc maxDepth(root *TreeNode) int {\r\n\r\n\tif root == nil {\r\n\t\treturn 0\r\n\t}\r\n\tleft := maxDepth(root.Left)\r\n\tright := maxDepth(root.Right)\r\n\treturn int(math.Max(float64(left), float64(right))) + 1\r\n}\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N èŠ‚ç‚¹ä¸ªæ•°ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(M)ï¼Œé«˜åº¦ï¼Œå…¶å®æ„æ€æ˜¯é€’å½’æ ˆç©ºé—´çš„å¤§å°\r\n\r\n\r\n\r\n\r\n### <span id=\"solution2\">æ€è·¯BFS</span>\r\n\r\næ€è·¯ç®€å•\r\n- é¦–å…ˆç»´æŠ¤ä¸€ä¸ªé˜Ÿåˆ—\r\n- æ¯æ¬¡å¯¹ç«‹åŠ åˆ°ä¸€ä¸ªå±‚çš„å…ƒç´ ï¼Œéå†ä¸€ä¸ªå±‚ï¼Œæ·±åº¦ +1 \r\n- ä¸‹ä¸€æ¬¡è¿›å…¥éå†ä¸‹ä¸€å±‚\r\n- é‡å¤ä»¥ä¸Šçš„æ­¥éª¤\r\n\r\n### Golang ä»£ç \r\n\r\n\r\n``` goï¼ˆæ­¤å¤„æ¢æˆä½ çš„è¯­è¨€ï¼Œæ¯”å¦‚jsï¼Œpy ç­‰ï¼‰\r\n\r\n\r\n//\r\n//  maxDepth1\r\n//  @Description:å¹¿åº¦ä¼˜å…ˆæœç´¢\r\n//  @param root\r\n//\r\nfunc maxDepth1(root *TreeNode) int {\r\n\r\n\tif root == nil {\r\n\t\treturn 0\r\n\t}\r\n\r\n\tqueue := make([]*TreeNode, 0)\r\n\tresult := 0\r\n\tqueue = append(queue, root)\r\n\r\n\tfor len(queue) > 0 {\r\n\r\n\t\tqueueLength := len(queue)\r\n\t\tfor queueLength > 0 {\r\n\t\t\tnode := queue[0]\r\n\t\t\tqueue = queue[1:]\r\n\t\t\tif node.Left != nil {\r\n\t\t\t\tqueue = append(queue, node.Left)\r\n\t\t\t}\r\n\t\t\tif node.Right != nil {\r\n\t\t\t\tqueue = append(queue, node.Right)\r\n\t\t\t}\r\n\r\n\t\t\tqueueLength--\r\n\t\t}\r\n\t\tresult++\r\n\r\n\t}\r\n\r\n\treturn result\r\n\r\n}\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N èŠ‚ç‚¹ä¸ªæ•°ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(M)ï¼ŒM æœ€åæƒ…å†µä¸‹é˜Ÿåˆ—é•¿åº¦ã€‚\r\n\r\n\r\n\r\n\r\n### <span id=\"solution3\">å›æº¯</span>\r\n\r\nåŸºæœ¬æ€è·¯å°±æ˜¯è®°å½•è®¿é—®è¿‡çš„èŠ‚ç‚¹\r\n\r\n\r\n### Golang ä»£ç \r\n\r\n``` goï¼ˆæ­¤å¤„æ¢æˆä½ çš„è¯­è¨€ï¼Œæ¯”å¦‚jsï¼Œpy ç­‰ï¼‰\r\n//\r\n//  maxDepth2\r\n//  @Description:\r\n//  @param root\r\n//  @return int\r\n//\r\n\r\nvar depth = 0\r\nvar res = 0\r\n\r\nfunc maxDepth2(root *TreeNode) int {\r\n\r\n\ttraverse(root)\r\n\treturn res\r\n}\r\n\r\nfunc traverse(root *TreeNode) {\r\n\r\n\tif root == nil {\r\n\t\treturn\r\n\t}\r\n\r\n\tdepth++\r\n\tres = int(math.Max(float64(res), float64(depth)))\r\n\ttraverse(root.Right)\r\n\ttraverse(root.Left)\r\n\tdepth--\r\n}\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N èŠ‚ç‚¹ä¸ªæ•°ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(M)ï¼Œé«˜åº¦ï¼Œå…¶å®æ„æ€æ˜¯é€’å½’æ ˆç©ºé—´çš„å¤§å°","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198133136","body":"## LC 100. ç›¸åŒçš„æ ‘\r\n[Leetcodeè¿æ¥](https://leetcode.cn/problems/same-tree/)\r\n\r\n- [DFS](#solution1)\r\n- [è¿­ä»£](#solution1)\r\n\r\n### <span id=\"solution1\">DFS</span>\r\n\r\n- ä¸¤ä¸ªæ ‘çš„ä»»ä½•èŠ‚ç‚¹å·¦å­æ ‘å’Œå¦ä¸€æ£µæ ‘çš„å·¦å­æ ‘ç›¸ç­‰å¹¶ä¸”ä¸¤æ£µæ ‘çš„ä»»ä½•èŠ‚ç‚¹çš„å³å­æ ‘å’Œå¦ä¸€æ£µæ ‘çš„å³å³å­æ ‘ç›¸ç­‰\r\n- å¦‚æœéå†åˆ°å¶å­èŠ‚ç‚¹ï¼Œå¹¶ä¸”å€¼ç›¸ç­‰è¯´æ˜å­æ ‘ç›¸ç­‰\r\n\r\n### Golang ä»£ç \r\n\r\n``` go\r\n\r\n//\r\n//  isSameTree\r\n//  @Description: dfs\r\n//  @param p\r\n//  @param q\r\n//  @return bool\r\n//\r\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\r\n\tvar dfs func(pp *TreeNode, qq *TreeNode) bool\r\n\tdfs = func(pp *TreeNode, qq *TreeNode) bool {\r\n\t\tif pp == nil && qq == nil {\r\n\t\t\treturn true\r\n\t\t}\r\n\t\tif pp == nil || qq == nil {\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\treturn qq.Val == pp.Val && dfs(pp.Left, qq.Left) && dfs(pp.Right, qq.Right)\r\n\t}\r\n\r\n\treturn dfs(p, q)\r\n}\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N èŠ‚ç‚¹ä¸ªæ•°ï¼ŒDFSè®¿é—®æ¯ä¸ªèŠ‚ç‚¹\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(M)ï¼Œå…¶ä¸­Mæ˜¯DFSæ ˆç©ºé—´çš„å¤§å°\r\n\r\n\r\n\r\n\r\n\r\n### <span id=\"solution2\">è¿­ä»£</span>\r\n\r\n- è¿­ä»£ä¸¤æ£µæ ‘çš„æ ‘æ¯ä¸€ä¸ªèŠ‚ç‚¹\r\n- ä¸¤æ£µæ ‘å¯¹åº”èŠ‚ç‚¹çš„åŒæ—¶æ·»åŠ åˆ°é˜Ÿåˆ—ä¸­ï¼Œ\r\n- æ¯æ¬¡è¿­ä»£å¯¹é˜Ÿåˆ—ä¸­ä¸¤ä¸ªèŠ‚ç‚¹å¼¹å‡ºï¼Œ\r\n- ä¸¤ä¸ªèŠ‚ç‚¹å’Œå€¼è¿›è¡Œå¯¹æ¯”æ˜¯å¦ç›¸ç­‰\r\n- ç»§ç»­ä¸¤ä¸ªèŠ‚ç‚¹å¯¹åº”çš„å·¦å³èŠ‚ç‚¹æ·»åŠ åˆ°é˜Ÿåˆ—ä¸­\r\n\r\n### Golang ä»£ç \r\n\r\n\r\n``` goï¼ˆæ­¤å¤„æ¢æˆä½ çš„è¯­è¨€ï¼Œæ¯”å¦‚jsï¼Œpy ç­‰ï¼‰\r\n\r\n//\r\n//  isSameTree1\r\n//  @Description:\r\n//  @param p\r\n//  @param q\r\n//  @return bool\r\n//\r\nfunc isSameTree1(p *TreeNode, q *TreeNode) bool {\r\n\r\n\tqueue := []*TreeNode{}\r\n\tqueue = append(queue, q)\r\n\tqueue = append(queue, p)\r\n\r\n\tfor len(queue) > 0 {\r\n\t\tqq := queue[0]\r\n\t\tpp := queue[1]\r\n\t\t// æ›´æ–°queue\r\n\t\tqueue = queue[2:]\r\n\t\tif pp == nil && qq == nil {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tif qq == nil || pp == nil {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\tif qq.Val != pp.Val {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\t// left\r\n\t\tqueue = append(queue, pp.Left)\r\n\t\tqueue = append(queue, qq.Left)\r\n\r\n\t\t// right\r\n\t\tqueue = append(queue, pp.Right)\r\n\t\tqueue = append(queue, qq.Right)\r\n\r\n\t}\r\n\r\n\treturn true\r\n\r\n}\r\n\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N èŠ‚ç‚¹ä¸ªæ•°ï¼Œè®¿é—®æ¯ä¸€ä¸ªèŠ‚ç‚¹\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(M)ï¼Œé˜Ÿåˆ—çš„é•¿åº¦\r\n\r\n\r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199476739","body":"## LC 129. æ±‚æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹æ•°å­—ä¹‹å’Œ\r\n[Leetcodeè¿æ¥](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)\r\n\r\n- [DFS](#solution1)\r\n\r\n### <span id=\"solution1\">æ€è·¯</span>\r\n\r\nDFS æ€è·¯å¾ˆç®€å•\r\n- åˆ°å¶å­èŠ‚ç‚¹çš„æ—¶å€™è¿›è¡Œè®¡ç®—\r\n\r\n### Golang ä»£ç \r\n\r\n``` go\r\n\r\n\r\n\r\n//\r\n//  sumNumbers\r\n//  @Description:\r\n//  @param root\r\n//  @return int\r\n//\r\nfunc sumNumbers(root *TreeNode) int {\r\n\tsum := 0\r\n\tvar dfs func(root *TreeNode, elemVal int)\r\n\tdfs = func(root *TreeNode, elemVal int) {\r\n\t\tif root == nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif root.Left == nil && root.Right == nil {\r\n\r\n\t\t\tsum += elemVal*10 + root.Val\r\n\t\t\treturn\r\n\r\n\t\t}\r\n\r\n\t\tdfs(root.Left, elemVal*10+root.Val)\r\n\t\tdfs(root.Right, elemVal*10+root.Val)\r\n\t}\r\n\r\n\tdfs(root, 0)\r\n\r\n\treturn sum\r\n\r\n}\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­NèŠ‚ç‚¹æ€»æ•°é‡ï¼Œæ¯ä¸€ä¸ªèŠ‚ç‚¹è®¿é—®ä¸€æ¬¡\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(H)ï¼Œæ ‘çš„é«˜åº¦ï¼Œæ¯å±‚ä¸€æ¬¡è®¡ç®—","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200237562","body":"\r\n## LC æ ‡é¢˜\r\n[Leetcodeè¿æ¥](https://leetcode.cn/problems/find-bottom-left-tree-value/)\r\n\r\n- [DFS](#solution1)\r\n- [BFS](#solution2)\r\n\r\n### <span id=\"solution1\">DFS</span>\r\n\r\nç”¨DFS\r\n\r\n### Golang ä»£ç \r\n\r\n``` go\r\n\r\n\r\n\r\n//\r\n//  findBottomLeftValue\r\n//  @Description:\r\n//  @param root\r\n//  @return int\r\n//\r\nfunc findBottomLeftValue(root *TreeNode) int {\r\n\tlastHight := 0\r\n\tlastVal := 0\r\n\tvar dfs func(node *TreeNode, high int)\r\n\tdfs = func(node *TreeNode, high int) {\r\n\r\n\t\tif node == nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\thigh++\r\n\t\tdfs(node.Left, high)\r\n\t\tdfs(node.Right, high)\r\n\t\tif high > lastHight {\r\n\t\t\tlastHight = high\r\n\t\t\tlastVal = node.Val\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tdfs(root, 0)\r\n\treturn lastVal\r\n\r\n}\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N èŠ‚ç‚¹ä¸ªæ•°ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(M)ï¼Œå…¶ä¸­ M DFSæ ˆç©ºé—´å¤§å°\r\n\r\n\r\n\r\n### <span id=\"solution2\">BFS</span>\r\n\r\né€šè¿‡é˜Ÿåˆ—æ¨¡æ‹ŸBFS,ä¸ºäº†ä¿è¯å·¦è¾¹çš„æœ€ä¸‹é¢çš„å·¦èŠ‚ç‚¹ï¼Œå…ˆéå†å³å­æ ‘ï¼Œå†éå†å·¦å­æ ‘ï¼Œè¿™æ ·çš„è¯ä¿è¯æœ€ä¸‹é¢çš„å·¦èŠ‚ç‚¹æœ€åä¸€ä¸ªå…ƒç´ \r\n\r\n### Golang ä»£ç \r\n\r\n\r\n``` goï¼ˆæ­¤å¤„æ¢æˆä½ çš„è¯­è¨€ï¼Œæ¯”å¦‚jsï¼Œpy ç­‰ï¼‰\r\n\r\n\r\n//\r\n//  findBottomLeftValue\r\n//  @Description:\r\n//  @param root\r\n//  @return int\r\n//\r\nfunc findBottomLeftValue(root *TreeNode) int {\r\n\r\n\tres := make([]int, 0)\r\n\tqueue := make([]*TreeNode, 0)\r\n\tqueue = append(queue, root)\r\n\r\n\tfor len(queue) > 0 {\r\n\t\tq := queue[0]\r\n\t\t// æ›´æ–°\r\n\t\tqueue = queue[1:]\r\n        if q.Right != nil {\r\n\t\t\tqueue = append(queue, q.Right)\r\n\t\t}\r\n\t\tif q.Left != nil {\r\n\t\t\tqueue = append(queue, q.Left)\r\n\t\t}\r\n\t\t\r\n\t\tres = append(res, q.Val)\r\n\r\n\t}\r\n\r\n\treturn res[len(res)-1]\r\n\r\n}\r\n\r\n```\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N èŠ‚ç‚¹ä¸ªæ•°ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(M)ï¼Œå…¶ä¸­ MèŠ‚ç‚¹å¤§å°,é˜Ÿåˆ—å’Œæ•°ç»„çš„æ ˆçš„ç©ºé—´ 0(M)+ 0(M) = 0(2M) ç®€åŒ–ä¸º 0(M)\r\n\r\n\r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200398277","body":"## LC 297. äºŒå‰æ ‘çš„åºåˆ—åŒ–ä¸ååºåˆ—åŒ–\r\n[Leetcodeè¿æ¥](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)\r\n\r\n- [DFSè§£æ³•å‰¯æ ‡é¢˜](#solution1)\r\n\r\n### <span id=\"solution1\">DFS</span>\r\n\r\néƒ½æ˜¯DFSæ€è·¯\r\n- nill ä¹Ÿä½ç½®è¡¨ç¤ºä¸€å±‚éå†ç»“æŸ\r\n- åœ¨è¿›è¡Œæ›´æ–°å€¼\r\n\r\n### Golang ä»£ç \r\n\r\n``` go\r\n\r\ntype Codec struct {\r\n}\r\n\r\nfunc Constructor() Codec {\r\n\r\n\treturn Codec{}\r\n\r\n}\r\n\r\n// Serializes a tree to a single string.\r\nfunc (this *Codec) serialize(root *TreeNode) string {\r\n\t sb := \"\"\r\n    var dfs func(*TreeNode)\r\n    dfs = func(node *TreeNode) {\r\n        if node == nil {\r\n            sb = sb + \"null,\"\r\n            return\r\n        }\r\n        sb = sb + strconv.Itoa(node.Val)\r\n        sb = sb + \",\"\r\n        dfs(node.Left)\r\n        dfs(node.Right)\r\n    }\r\n    dfs(root)\r\n    fmt.Println(sb)\r\n    return sb\r\n}\r\n\r\n// Deserializes your encoded data to tree.\r\nfunc (this *Codec) deserialize(data string) *TreeNode {\r\n\tsp := strings.Split(data, \",\")\r\n\tvar dfs func() *TreeNode\r\n\tdfs = func() *TreeNode {\r\n        // é‡åˆ° ä¸€æ¬¡æ˜¯ç»“æŸäº†ä¸€å±‚\r\n        if sp[0] == \"null\" {\r\n            sp = sp[1:]\r\n            return nil\r\n        }\r\n        val, _ := strconv.Atoi(sp[0])\r\n        sp = sp[1:]\r\n        root := &TreeNode{Val :val }\r\n        root.Left = dfs()\r\n        root.Right =  dfs()\r\n        return root\r\n    }\r\n\r\n\treturn dfs()\r\n\r\n}\r\n\r\n/**\r\n * Your Codec object will be instantiated and called as such:\r\n * ser := Constructor();\r\n * deser := Constructor();\r\n * data := ser.serialize(root);\r\n * ans := deser.deserialize(data);\r\n */\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N èŠ‚ç‚¹é•¿åº¦\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N) é€’å½’ç©ºé—´çš„å¤§å°","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201376822","body":"\r\n## LC 987. äºŒå‰æ ‘çš„å‚åºéå†\r\n[Leetcodeè¿æ¥](https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/)\r\n\r\n- [DFS](#solution1)\r\n\r\n### <span id=\"solution1\">DFS</span>\r\n\r\n - æ¯æ¬¡éå†çš„æ—¶å€™ä¼  åæ ‡å·¦å­©å­ (x-1,y+1),å³å­©å­(x+1,y+1)\r\n\r\n### Golang ä»£ç \r\n\r\n``` go\r\n\r\n\r\ntype data struct{ col, row, val int }\r\n\r\nfunc verticalTraversal(root *TreeNode) (ans [][]int) {\r\n    nodes := []data{}\r\n    var dfs func(*TreeNode, int, int)\r\n    dfs = func(node *TreeNode, row, col int) {\r\n        if node == nil {\r\n            return\r\n        }\r\n        nodes = append(nodes, data{col, row, node.Val})\r\n        dfs(node.Left, row+1, col-1)\r\n        dfs(node.Right, row+1, col+1)\r\n    }\r\n    dfs(root, 0, 0)\r\n\r\n    sort.Slice(nodes, func(i, j int) bool {\r\n        a, b := nodes[i], nodes[j]\r\n        return a.col < b.col || a.col == b.col && (a.row < b.row || a.row == b.row && a.val < b.val)\r\n    })\r\n\r\n    lastCol := math.MinInt32\r\n    for _, node := range nodes {\r\n        if node.col != lastCol {\r\n            lastCol = node.col\r\n            ans = append(ans, nil)\r\n        }\r\n        ans[len(ans)-1] = append(ans[len(ans)-1], node.val)\r\n    }\r\n    return\r\n}\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)ï¼Œå…¶ä¸­DFSéå†éœ€è¦O(n)ï¼Œæ··åˆæ’åºéœ€è¦ O(nlogn)ï¼Œ0(n+nlogn) = 0(n(1+logn));ç®€åŒ–ä¸ºO(nlogn)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)ï¼ŒDFSéœ€è¦çš„æ ˆç©ºé—´","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202814451","body":"## LC 1. ä¸¤æ•°ä¹‹å’Œ\r\n[Leetcodeè¿æ¥](https://leetcode.cn/problems/two-sum/)\r\n\r\n- [å“ˆå¸Œè¡¨](#solution1)\r\n- [æš´åŠ›ç ´è§£](#solution2)\r\n\r\n### <span id=\"solution1\">å“ˆå¸Œè¡¨</span>\r\n\r\nç”¨å“ˆå¸Œè¡¨æ¥ä¿å­˜æ¯ä¸ªå…ƒç´ çš„ç´¢å¼•\r\n\r\n### Golang ä»£ç \r\n\r\n``` go\r\n//\r\n//  twoSum\r\n//  @Description:  map\r\n//  @param nums\r\n//  @param target\r\n//  @return []int\r\n//\r\nfunc twoSum(nums []int, target int) []int {\r\n\r\n\thashmap := make(map[int]int)\r\n\tfor i := 0; i < len(nums); i++ {\r\n\r\n\t\tif _, ok := hashmap[target-nums[i]]; ok {\r\n\t\t\treturn []int{hashmap[target-nums[i]], i}\r\n\t\t} else {\r\n\t\t\thashmap[nums[i]] = i\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn []int{}\r\n\r\n}\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)ï¼Œæœ€åçš„æƒ…å†µä¸‹æ¯ä¸ªå…ƒå­˜åˆ°å“ˆå¸Œè¡¨é‡Œé¢\r\n\r\n\r\n\r\n\r\n\r\n### <span id=\"solution2\">æš´åŠ›ç ´è§£</span>\r\nä¸¤ä¸ªåµŒå¥—å¾ªç¯æš´åŠ›ç ´è§£\r\n\r\n### Golang ä»£ç \r\n\r\n\r\n``` goï¼ˆæ­¤å¤„æ¢æˆä½ çš„è¯­è¨€ï¼Œæ¯”å¦‚jsï¼Œpy ç­‰ï¼‰\r\n\r\n\r\n//\r\n//  twoSum\r\n//  @Description: æš´åŠ›\r\n//  @param nums\r\n//  @param target\r\n//  @return []int\r\n//\r\nfunc twoSum(nums []int, target int) []int {\r\n\r\n\tfor i := 0; i < len(nums); i++ {\r\n\t\tfor j := i + 1; j < len(nums); j++ {\r\n\t\t\tif nums[i]+nums[j] == target {\r\n\t\t\t\treturn []int{i, j}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn []int{}\r\n}\r\n\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N^2)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ï¼Œä½¿ç”¨åµŒå¥—å¾ªç¯\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)\r\n\r\n\r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1204085693","body":"## LC 347. å‰ K ä¸ªé«˜é¢‘å…ƒç´ \r\n[Leetcodeè¿æ¥](https://leetcode.cn/problems/top-k-frequent-elements/)\r\n\r\n- [å“ˆå¸Œè¡¨](#solution1)\r\n\r\n### <span id=\"solution1\">å“ˆå¸Œè¡¨</span>\r\n\r\n- é¦–é€‰ç”¨å“ˆå¸Œè¡¨æ±‚é¢‘ç‡\r\n- åˆ›å»ºåˆ‡ç‰‡ç„¶åç”¨ç»“æ„ä½“æ¥ä¿å­˜å“ˆå¸Œè¡¨æ¯ä¸€ä¸ªå…ƒç´ æ·»åŠ åˆ°åˆ‡ç‰‡ä¸­\r\n- å†ç”¨sort.Sliceæ–¹æ¥å¯¹é¢‘ç‡è¿›è¡Œæ’åº\r\n- æ’åºç»“æ„ä¸­æœ€åæå–å‰kçš„å…ƒç´ \r\n\r\n### Golang ä»£ç \r\n\r\n``` go\r\n\r\ntype sortMap struct {\r\n\telem   int\r\n\tcounts int\r\n}\r\n\r\nfunc topKFrequent(nums []int, k int) []int {\r\n\t// record count\r\n\thashmap := make(map[int]int)\r\n\tfor i := 0; i < len(nums); i++ {\r\n\t\thashmap[nums[i]]++\r\n\t}\r\n\tans := make([]*sortMap, 0)\r\n\tfor key, value := range hashmap {\r\n\t\tans = append(ans, &sortMap{elem: key, counts: value})\r\n\t}\r\n\r\n\tsort.Slice(ans, func(i, j int) bool {\r\n\r\n\t\treturn ans[i].counts > ans[j].counts\r\n\r\n\t})\r\n\r\n\tres := make([]int, 0)\r\n\r\n\tfor i := 0; i < k; i++ {\r\n        fmt.Println(ans[i].elem)\r\n\t\tres = append(res, ans[i].elem)\r\n\t}\r\n\r\n\treturn res\r\n\r\n}\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šæ—¶é—´å¤æ‚åº¦æ˜¯æ’åºæ‰€æœ‰çš„æ—¶é—´O(nlogn),å…¶ä¸­Nå…ƒç´ æ•°é‡\r\n- ç©ºé—´å¤æ‚åº¦ï¼šç©ºé—´å¤æ‚åº¦O(n),å“ˆå¸Œè¡¨ï¼Œåˆ‡ç‰‡ç©ºé—´å¤æ‚åº¦å‡ä¸ºO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205165730","body":"\r\n## 447. å›æ—‹é•–çš„æ•°é‡\r\n[Leetcodeè¿æ¥](https://leetcode.cn/problems/number-of-boomerangs/)\r\n\r\n- [æš´åŠ›è§£æ³•+å­—å…¸](#solution1)\r\n- [å“ˆå¸Œè¡¨](#solution2)\r\n\r\n### <span id=\"solution1\">æš´åŠ›è§£æ³•</span>\r\n\r\nè¶…æ—¶\r\n\r\n### Golang ä»£ç \r\n\r\n``` go\r\n\r\n//\r\n//  numberOfBoomerangs\r\n//  @Description: points è¾ƒå¤§çš„æ—¶å€™è¶…æ—¶\r\n//  @param points\r\n//  @return int\r\n//\r\nfunc numberOfBoomerangs(points [][]int) int {\r\n\tans := make(map[int][][]int)\r\n\tindex := 0\r\n\tfor i := 0; i < len(points); i++ {\r\n\t\tfirst := points[i]\r\n\t\tfor j := 0; j < len(points); j++ {\r\n\t\t\tmiddle := points[j]\r\n\t\t\tfor k := 0; k < len(points); k++ {\r\n\t\t\t\tif i == j || j == k || i == k {\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t\tlast := points[k]\r\n\t\t\t\tdis1 := math.Pow(math.Pow(float64(first[0]-middle[0]), 2)+math.Pow(float64(first[1]-middle[1]), 2), 0.5)\r\n\t\t\t\tdis2 := math.Pow(math.Pow(float64(first[0]-last[0]), 2)+math.Pow(float64(first[1]-last[1]), 2), 0.5)\r\n\t\t\t\tif dis2 == dis1 {\r\n\t\t\t\t\tans[index] = append(ans[index], first)\r\n\t\t\t\t\tans[index] = append(ans[index], middle)\r\n\t\t\t\t\tans[index] = append(ans[index], last)\r\n\t\t\t\t\tindex++\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\tfmt.Println(ans)\r\n\treturn len(ans)\r\n}\r\n\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N^3),å…¶ä¸­Nç‚¹çš„ä¸ªæ•°ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(M),å“ˆå¸Œè¡¨çš„é•¿åº¦\r\n\r\n\r\n\r\n### <span id=\"solution2\">å“ˆå¸Œè¡¨</span>\r\næš´åŠ›ç ´è§£ç›´æ¥è¶…æ—¶ï¼Œé‚£æˆ‘ä»¬æ¢ä¸ªæ€è·¯ï¼Œç»„æˆä¸‰ç‚¹ a,b,cï¼› ä»aåˆ°bçš„è·ç¦»ç­‰äºä»aåˆ°cè·ç¦»\r\n- å¯¹æ¯ä¸ªèŠ‚ç‚¹ä¸ªå…¶ä»–èŠ‚ç‚¹ä¹‹é—´è·ç¦»è¿›è¡Œè®¡ç®—ã€‚distance := (fixed[0]-other[0])*(fixed[0]-other[0]) + (fixed[1]-other[1])*(fixed[1]-other[1])\r\n- è®¡ç®—å‡ºæ¥çš„è·ç¦»å½“å¤§å­—å…¸ä¸­hashmap[distance]++ ï¼Œ å…¶ä¸­å­—å…¸keyæ˜¯è·ç¦»\r\n- æœ‰ç›¸åŒçš„è·ç¦»è¯´æ˜æ¯”å¦‚ç›¸åŒè·ç¦»å¤§äº1ï¼›è¯´æ˜æœ‰èŠ‚ç‚¹ä¸‰ç»„èŠ‚ç‚¹ï¼›\r\n- è¿˜æœ‰ä¸€ä¸ªæ¡ä»¶æœ‰åºï¼›é‚£è¿™ä¸ªé—®é¢˜å˜æˆæ’åºé—®é¢˜äº†ï¼›Am ^2 = m * (m-1)\r\n\r\n\r\n### Golang ä»£ç \r\n\r\n\r\n``` goï¼ˆæ­¤å¤„æ¢æˆä½ çš„è¯­è¨€ï¼Œæ¯”å¦‚jsï¼Œpy ç­‰ï¼‰\r\n\r\n//\r\n//  numberOfBoomerangs1\r\n//  @Description: \r\n//  @param points\r\n//  @return int\r\n//\r\nfunc numberOfBoomerangs(points [][]int) int {\r\n\r\n\tres := 0\r\n\tfor _, fixed := range points {\r\n\t\thashmap := make(map[int]int)\r\n\t\tfor _, other := range points {\r\n\t\t\tdistance := (fixed[0]-other[0])*(fixed[0]-other[0]) + (fixed[1]-other[1])*(fixed[1]-other[1])\r\n\t\t\thashmap[distance]++\r\n\t\t}\r\n\t\tfor _, m := range hashmap {\r\n\t\t\tres += m * (m - 1)\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn res\r\n\r\n}\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N^2),å…¶ä¸­Nç‚¹çš„ä¸ªæ•°ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(M),å“ˆå¸Œè¡¨çš„é•¿åº¦\r\n\r\n\r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206012313","body":"## LC æ ‡é¢˜\r\n[Leetcodeè¿æ¥](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)\r\n\r\n- [æšä¸¾](#solution1)\r\n- [å“ˆå¸Œè¡¨](#solution2)\r\n### <span id=\"solution1\">æšä¸¾</span>\r\n\r\né€šè¿‡åŒå¾ªç¯æšä¸¾æ¯ä¸€ä¸ªå­ä¸²ï¼Œæ¯æ¬¡å¾ªç¯å†…è®¡ç®—æœ€å¤§å­ä¸²é•¿åº¦\r\n\r\n### Golang ä»£ç \r\n\r\n``` go\r\n\r\n\r\n\r\n//\r\n//  lengthOfLongestSubstring\r\n//  @Description:\r\n//  @param s\r\n//  @return int\r\n//\r\nfunc lengthOfLongestSubstring(s string) int {\r\n\r\n\tres := 0\r\n\tfor i := 0; i < len(s); i++ {\r\n\t\thashmap := make(map[byte]bool)\r\n\t\tfor j := i; j < len(s); j++ {\r\n\t\t\t// è¯´æ˜åˆé‡å¤å€¼\r\n\t\t\tif _, ok := hashmap[s[j]]; ok {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\thashmap[s[j]] = true\r\n\t\t\t// æœ‰é‡å¤çš„å€¼ï¼Œé‚£å°±è®¡ç®—é•¿åº¦\r\n\t\t\tres = int(math.Max(float64(res), float64(j-i+1)))\r\n\t\t}\r\n\t}\r\n\r\n\treturn res\r\n\r\n}\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N^2)ï¼Œå…¶ä¸­ N å­—ç¬¦ä¸²é•¿åº¦ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(M)ï¼Œå…¶ä¸­Må“ˆå¸Œè¡¨çš„é•¿åº¦\r\n\r\n\r\n### <span id=\"solution2\">å“ˆå¸Œè¡¨</span>\r\n\r\n\r\nåˆ©ç”¨å“ˆå¸Œè¡¨è®°å½•é‡å¤æ¬¡æ•°\r\n\r\n### Golang ä»£ç \r\n\r\n\r\n``` goï¼ˆæ­¤å¤„æ¢æˆä½ çš„è¯­è¨€ï¼Œæ¯”å¦‚jsï¼Œpy ç­‰ï¼‰\r\n\r\n\r\n//\r\n//  lengthOfLongestSubstring1\r\n//  @Description:\r\n//  @param s\r\n//  @return int\r\n//\r\nfunc lengthOfLongestSubstring1(s string) int {\r\n\thashmap := make(map[byte]int)\r\n\tans := 0\r\n\tleft := 0\r\n\tfor i := 0; i < len(s); i++ {\r\n\t\tleft = int(math.Max(float64(left), float64(hashmap[s[i]])))\r\n\t\thashmap[s[i]] = i + 1\r\n\t\tans = int(math.Max(float64(ans), float64(i-left+1)))\r\n\r\n\t}\r\n\treturn ans\r\n}\r\n\r\n\r\n```\r\n\r\n``` go\r\n\r\n//\r\n//  lengthOfLongestSubstring3\r\n//  @Description:\r\n//  @param s\r\n//  @return int\r\n//\r\nfunc lengthOfLongestSubstring3(s string) int {\r\n\thashmap := make(map[byte]int)\r\n\tleft := 0\r\n\tright := 0\r\n\tans := 0\r\n\tfor right < len(s) {\r\n\t\thashmap[s[right]]++\r\n\t\t// å¦‚æœé¢‘ç‡å¤§äº1ï¼Œleft ç§»åŠ¨åˆ° right ä½ç½®ï¼Œright å‰è¿›ä¸€æ­¥\r\n\t\tfor hashmap[s[right]] > 1 {\r\n\t\t\thashmap[s[left]]--\r\n\t\t\tleft++\r\n\t\t}\r\n\t\tans = int(math.Max(float64(ans), float64(right-left+1)))\r\n\t\tright++\r\n\r\n\t}\r\n\treturn ans\r\n}\r\n\r\n\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºå­—ç¬¦ä¸²é•¿åº¦ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(M)ï¼Œå“ˆå¸Œè¡¨çš„é•¿åº¦\r\n\r\n\r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207221391","body":"## LC 30. ä¸²è”æ‰€æœ‰å•è¯çš„å­ä¸²\r\n[Leetcodeè¿æ¥](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/)\r\n\r\n- [æš´åŠ›ç ´è§£](#solution1)\r\n- [å“ˆå¸Œè¡¨+æ»‘åŠ¨çª—å£](#solution2)\r\n### <span id=\"solution1\">æš´åŠ›ç ´è§£</span>\r\n\r\næš´åŠ›ç ´è§£ï¼Œä½†æ˜¯è¿™ä¸¤ä¸ªæ–¹æ³•è¶…æ—¶\r\n\r\n### Golang ä»£ç \r\n\r\n``` go\r\n\r\n\r\n//\r\n//  findSubstring\r\n//  @Description:\r\n//  @param s\r\n//  @param words\r\n//  @return []int\r\n//\r\nfunc findSubstring(s string, words []string) []int {\r\n\tans := make([]int, 0)\r\n\twordLength := len(words[0])\r\n\twindow := wordLength * len(words)\r\n\tif len(s) < window {\r\n\t\treturn []int{}\r\n\t}\r\n\tleft := 0\r\n\tright := window\r\n\tfor right <= len(s) {\r\n\t\t// æ’åº\r\n\t\tsub := make([]string, 0)\r\n\t\tss := string(s[left:right])\r\n\t\tfmt.Println(ss)\r\n\t\tfor i := 0; i < len(ss)/wordLength; i++ {\r\n\t\t\tsub = append(sub, ss[wordLength*i:wordLength*i+wordLength])\r\n\t\t}\r\n\t\tsort.Slice(sub, func(i, j int) bool {\r\n\t\t\treturn sub[i] > sub[j]\r\n\t\t})\r\n\t\tw := words\r\n\t\tsort.Slice(w, func(i, j int) bool {\r\n\t\t\treturn w[i] > w[j]\r\n\t\t})\r\n\t\ttmp := true\r\n\t\tfmt.Println(sub, w)\r\n\t\tfor i := 0; i < len(w); i++ {\r\n\t\t\tif string(sub[i]) != string(w[i]) {\r\n\t\t\t\ttmp = false\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t}\r\n\t\tif tmp {\r\n\t\t\tans = append(ans, left)\r\n\t\t}\r\n\t\tleft++\r\n\t\tright++\r\n\t}\r\n\treturn ans\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n``` go\r\n\r\n//\r\n//  findSubstring\r\n//  @Description: è¶…æ—¶\r\n//  @param s\r\n//  @param words\r\n//  @return []int\r\n//\r\nfunc findSubstring1(s string, words []string) []int {\r\n\tans := make([]int, 0)\r\n\twordLength := len(words[0])\r\n\twindow := wordLength * len(words)\r\n\tshashMap := make(map[string]int)\r\n\tfor _, ch := range words {\r\n\t\tshashMap[ch]++\r\n\t}\r\n\tif len(s) < window {\r\n\t\treturn []int{}\r\n\t}\r\n\tleft := 0\r\n\tright := window\r\n\tfor right <= len(s) {\r\n\t\t// æ’åº\r\n\t\tsub := string(s[left:right])\r\n\t\tnewHashmap := make(map[string]int)\r\n\t\tfor i := 0; i < len(sub)/wordLength; i++ {\r\n\t\t\tnewHashmap[sub[wordLength*i:wordLength*i+wordLength]]++\r\n\t\t}\r\n\t\ttmp := true\r\n\t\tfor key, value := range shashMap {\r\n\t\t\tif v, k := newHashmap[key]; k {\r\n\t\t\t\tif v != value {\r\n\t\t\t\t\ttmp = false\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tleft++\r\n\t\t\t\tright++\r\n\t\t\t\tcontinue\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif tmp {\r\n\t\t\tans = append(ans, left)\r\n\t\t}\r\n\r\n\t}\r\n\treturn ans\r\n}\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N^2)ï¼Œå…¶ä¸­Nå­—ç¬¦ä¸²é•¿åº¦å…ƒç´ é•¿åº¦ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(J*K),wordsçš„å•è¯ä¸ªæ•°ï¼Œkæ¯ä¸€ä¸ªå•è¯é•¿åº¦\r\n\r\n\r\n\r\n\r\n\r\n### <span id=\"solution2\">å“ˆå¸Œè¡¨+æ»‘åŠ¨çª—å£</span>\r\n\r\nåŒå“ˆå¸Œè¡¨+æ»‘åŠ¨çª—å£\r\n\r\n### Golang ä»£ç \r\n\r\n\r\n``` goï¼ˆæ­¤å¤„æ¢æˆä½ çš„è¯­è¨€ï¼Œæ¯”å¦‚jsï¼Œpy ç­‰ï¼‰\r\n\r\n//\r\n//  findSubstring2\r\n//  @Description:\r\n//  @param s\r\n//  @param words\r\n//  @return []int\r\n//\r\nfunc findSubstring2(s string, words []string) []int {\r\n\twordLen := len(words[0])\r\n\twordsLen := len(words)\r\n\tlength := wordsLen * wordLen\r\n\r\n\twordsHash := map[string]int{}\r\n\tfor _, word := range words {\r\n\t\twordsHash[word]++\r\n\t}\r\n\tans := make([]int, 0)\r\n\tfor i := 0; i+length <= len(s); i++ {\r\n\t\tcnt := 0\r\n\t\tsubHash := map[string]int{}\r\n\t\tsub := s[i : i+length]\r\n\t\tfor j := 0; j < wordsLen; j++ {\r\n\t\t\titem := sub[j*wordLen : (j+1)*wordLen]\r\n\t\t\tif _, ok := wordsHash[item]; !ok {\r\n\t\t\t\tbreak\r\n\t\t\t} else {\r\n\t\t\t\tif subHash[item] == wordsHash[item] {\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t\tsubHash[item]++\r\n\t\t\t\tcnt++\r\n\t\t\t}\r\n\t\t}\r\n\t\tif len(wordsHash) == len(subHash) && cnt == wordsLen {\r\n\t\t\tans = append(ans, i)\r\n\t\t}\r\n\t}\r\n\treturn ans\r\n}\r\n\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N * W)ï¼Œå…¶ä¸­ N ä¸ºå­—ç¬¦ä¸²é•¿åº¦ï¼ŒW æ˜¯wordé‡Œé¢æ¯ä¸€ä¸ªwordé•¿åº¦çš„å’Œæ€»é•¿åº¦\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(J*K),wordsçš„å•è¯ä¸ªæ•°ï¼Œkæ¯ä¸€ä¸ªå•è¯é•¿åº¦\r\n\r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207381132","body":"## Delete Sublist to Make Sum Divisible By K\r\n[è¿æ¥](https://binarysearch.com/problems/Delete-Sublist-to-Make-Sum-Divisible-By-K)\r\n\r\n- [å“ˆå¸Œè¡¨](#solution1)\r\n\r\n### <span id=\"solution1\">å“ˆå¸Œè¡¨</span>\r\n\r\n\r\n\r\n### Golang ä»£ç \r\n\r\n``` go\r\n\r\n\r\nfunc solve(nums []int, k int) int {\r\n\ttotal := 0\r\n\tfor _, ch := range nums {\r\n\t\ttotal += ch\r\n\t}\r\n\tmod := total % k\r\n\thashmap := make(map[int]int)\r\n\thashmap[0] = -1\r\n\ttotal = 0\r\n\tans := len(nums)\r\n\tfor i := 0; i < len(nums); i++ {\r\n\t\ttotal += nums[i]\r\n\t\tcurrent := total % k\r\n\t\ttarget := (current - mod + k) % k\r\n\t\tif _, ok := hashmap[target]; ok {\r\n\t\t\tans = int(math.Min(float64(ans), float64(i-hashmap[target])))\r\n\t\t}\r\n\t\thashmap[current] = i\r\n\t}\r\n\tif ans == len(nums) {\r\n\t\treturn -1\r\n\t}\r\n\treturn ans\r\n}\r\n\r\nfunc floorMod(a int, b int) int {\r\n\treturn (a%b + b) % b\r\n}\r\n\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(minï¼ˆNï¼ŒKï¼‰)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208091112","body":"## LC 876. é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹\r\n[Leetcodeè¿æ¥](https://leetcode.cn/problems/middle-of-the-linked-list/)\r\n\r\n- [å¿«æ…¢æŒ‡é’ˆ](#solution1)\r\n\r\n### <span id=\"solution1\">å¿«æ…¢æŒ‡é’ˆ</span>\r\n\r\nå¿«æ…¢æŒ‡é’ˆ\r\n\r\n### Golang ä»£ç \r\n\r\n``` go\r\n\r\nfunc middleNode(head *ListNode) *ListNode {\r\n    fast, slow := head, head\r\n\tfor fast != nil && fast.Next != nil {\r\n\t\tslow = slow.Next\r\n\t\tfast = fast.Next.Next\r\n\t}\r\n\r\n\treturn slow\r\n}\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N èŠ‚ç‚¹ä¸ªæ•°ã€‚\r\n- ç©ºé—´å¤æ‚åº¦","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209337320","body":"## LC26. åˆ é™¤æœ‰åºæ•°ç»„ä¸­çš„é‡å¤é¡¹\r\n[Leetcodeè¿æ¥](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)\r\n\r\n- [å¿«æ…¢æŒ‡é’ˆ](#solution1)\r\n\r\n### <span id=\"solution1\">å¿«æ…¢æŒ‡é’ˆ</span>\r\n\r\nå¿«æ…¢æŒ‡é’ˆ\r\n\r\n### Golang ä»£ç \r\n\r\n``` go\r\n\r\nfunc removeDuplicates(nums []int) int {\r\n    lenght := len(nums)\r\n\tif lenght == 0 {\r\n\t\treturn 0\r\n\t}\r\n\r\n\tslow := 0\r\n\tfast := 0\r\n\tfor fast < lenght {\r\n\t\tif nums[slow] != nums[fast] {\r\n\t\t\tslow++\r\n\t\t\tnums[slow] = nums[fast]\r\n\t\t}\r\n\t\tfast++\r\n\t}\r\n\treturn slow + 1\r\n}\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guixian001":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185422953","body":"### æ€è·¯\n\nå¸¸è§„æ€è·¯\nå…ˆå°†ç»™çš„æ•°å€¼è½¬æˆæ•°å€¼ï¼Œç„¶åå’Œç»™çš„ k è¿›è¡Œç›¸åŠ ï¼Œå†å°†å…¶è½¬æ¢æˆæ•°ç»„\n\n### ä»£ç \n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num_length = len(num)\n        sum = 0\n        for index, i in enumerate(num):\n            sum += i * 10 ** (num_length - index  - 1)\n        sum += k\n        return [int(i) for i in str(sum)]\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186223257","body":"### æ€è·¯\n\nåˆ†åˆ«è®¡ç®—æ•°ç»„ä½ç½®ä¸­å·¦ä¾§å’Œåä¾§çš„æœ€è¿‘è·ç¦»ï¼Œç„¶åæœ€å®ƒä»¬ä¸­çš„æœ€å°å€¼ä½œä¸ºå½“å‰ index çš„æ•°å­—ã€‚\n\n### ä»£ç \n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        ans = [n+1] * n\n\n        c_index = -1\n        for index, char in enumerate(s):\n            if char == c:\n                c_index = index\n            if c_index != -1:\n                ans[index] = index - c_index \n\n        c_index = -1\n        for i in range(n-1, -1, -1):\n            if s[i] == c:\n                c_index = i\n            if c_index != -1:\n                ans[i] = min(ans[i], c_index - i)\n        return ans\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186551995","body":"### æ€è·¯\n\n1. ç¬¬ä¸€ç§æ–¹æ³•æ¯”è¾ƒä¾èµ–è¯­è¨€æœ¬èº«çš„ç‰¹æ€§ï¼Œä½¿ç”¨åˆ°äº† Python è‡ªå·±çš„æ•°æ®ç»“æ„ï¼Œlist çš„ append/pop æ–¹æ³•\n2. ä½¿ç”¨æ¯”è¾ƒåŸç”Ÿçš„æ–¹å¼å®ç°ï¼Œä¸»è¦ä½¿ç”¨åˆ°æ•°ç»„çš„ç›¸å…³ crud\n\n### ä»£ç \n- æ–¹æ³• 1\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self._stack = []\n        self._stack_cap = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self._stack) < self._stack_cap:\n            self._stack.append(x)\n\n    def pop(self) -> int:\n        if len(self._stack) > 0:\n            return self._stack.pop()\n        return -1\n    def increment(self, k: int, val: int) -> None:\n        curr_count = len(self._stack)\n        for i in range(k):\n            if i <= curr_count - 1:\n                self._stack[i] += val\n```\n- æ–¹æ³• 2\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self._stack = [0] * maxSize\n        self._stack_cap = maxSize\n        self._stack_index = -1  # å½“å‰ç´¢å¼•ï¼Œ-1 è¡¨ç¤ºå½“å‰æ ˆä¸ºç©º\n\n    def push(self, x: int) -> None:\n        if self._stack_index + 1 < self._stack_cap:\n            self._stack_index += 1\n            self._stack[self._stack_index] = x\n            \n\n\n    def pop(self) -> int:\n        if self._stack_index > -1:\n            top = self._stack[self._stack_index]\n            self._stack_index -= 1\n            return top\n        return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(k):\n            if i <= self._stack_index:\n                self._stack[i] += val\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189228149","body":"### æ€è·¯\n\n1. å…³é”®æ˜¯éœ€è¦å¯ä»¥ç›¸å‡ºå°†ä¸€ä¸ªæ ˆï¼ˆAæ ˆï¼‰ä¾æ¬¡å–å‡ºç„¶åæ”¾åˆ°å¦å¤–ä¸€ä¸ªæ ˆï¼ˆB æ ˆï¼‰é‡Œé¢ï¼Œä» B æ ˆå‡ºæ¥çš„å°±æ˜¯æŒ‰ç…§å…ˆè¿›å…ˆå‡ºçš„é¡ºåºäº†ï¼Œç›¸å½“äºå†…éƒ¨åšäº†ä¸€æ¬¡ç¿»è½¬ï¼›\n2. é¢˜ç›®ç»™å‡ºæ¡ä»¶ï¼Œæ‰€æœ‰æ“ä½œéƒ½æ˜¯æœ‰æ•ˆçš„ï¼Œä¸å­˜åœ¨ç©ºé˜Ÿåˆ—å»è¿›è¡Œ pop() peak() æ“ä½œï¼›\n3. åœ¨è°ƒç”¨ peak çš„æ—¶å€™ï¼Œæˆ‘ä»¬å°† A æ ˆçš„æ•°æ®ä¾æ¬¡å‡ºæ ˆï¼Œæ”¾å…¥ B æ ˆï¼Œç„¶åè¿”å›é˜Ÿåˆ—å¤´çš„æ•°æ®ï¼ˆåŠ B æ ˆçš„æ ˆé¡¶ï¼‰ï¼›\n4. åœ¨è°ƒç”¨ pop çš„æ—¶å€™ï¼Œé¦–å…ˆè§¦å‘ peakï¼Œç„¶åå°† B æ ˆè¿›è¡Œå‡ºæ ˆæ“ä½œï¼›\n\n### ä»£ç \n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self._stack_one = []\n        self._stack_two = []\n\n    def push(self, x: int) -> None:\n        self._stack_one.append(x)\n\n    def pop(self) -> int:\n        self.peek()\n        return self._stack_two.pop()\n\n    def peek(self) -> int:\n        if len(self._stack_two) == 0:\n            while len(self._stack_one) != 0:\n                self._stack_two.append(self._stack_one.pop())\n        return self._stack_two[-1]\n\n    def empty(self) -> bool:\n        return len(self._stack_one) == 0 and len(self._stack_two) == 0\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190339214","body":"### æ€è·¯\n\nå‚è€ƒ [max-chunks-to-make-sorted-ii](https://github.com/suukii/91-days-algorithm/blob/master/basic/array-stack-queue/06.max-chunks-to-make-sorted-ii.md)\n\n### ä»£ç \n\n1. é‡‡ç”¨æ»‘åŠ¨çª—å£\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        sorted_arr = sorted(arr)\n\n        count = 0\n        sum1 = 0\n        sum2 = 0\n\n        for i in range(len(arr)):\n            sum1 += arr[i]\n            sum2 += sorted_arr[i]\n\n            if (sum1 == sum2):\n                count += 1\n        \n        return count\n```\n\n2. å•è°ƒæ ˆ\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n\n        for i in arr:\n            if len(stack) == 0:\n                stack.append(i)\n                continue\n\n            if stack[-1] <= i:\n                stack.append(i)\n            else:\n                top = stack.pop()\n                while len(stack) != 0 and stack[-1] > i:\n                    stack.pop()\n                \n                stack.append(top)\n            \n        return len(stack)\n```\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192704036","body":"### æ€è·¯\r\n\r\n1. é‡‡ç”¨é€’å½’\r\n2. æ·»åŠ ä¸€ä¸ªè¾…åŠ©è™šæ‹Ÿå¤´ç»“ç‚¹\r\n\r\n### ä»£ç \r\n\r\n1. é‡‡ç”¨é€’å½’\r\n\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if (head is None or head.next is None):\r\n            return head\r\n        \r\n        new_head = head.next\r\n        head.next = self.swapPairs(new_head.next)\r\n        new_head.next = head\r\n\r\n        return new_head\r\n```\r\n\r\n2. æ·»åŠ ä¸€ä¸ªè¾…åŠ©è™šæ‹Ÿå¤´ç»“ç‚¹\r\n\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if (head is None or head.next is None):\r\n            return head\r\n        \r\n        dummy_head = ListNode()\r\n        dummy_head.next = head\r\n\r\n        temp = dummy_head\r\n\r\n        while temp.next and temp.next.next:\r\n            node1 = temp.next\r\n            node2 = node1.next\r\n\r\n            node1.next = node2.next\r\n            node2.next = node1\r\n            temp.next = node2\r\n\r\n            temp = node1\r\n\r\n        return dummy_head.next\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193141904","body":"### æ€è·¯\r\n\r\n1. æ„å»ºæ ‘é‡‡ç”¨é€’å½’ï¼Œæ‰¾åˆ°æœ‰åºé“¾è¡¨çš„ä¸­é—´ç‚¹ï¼Œåˆ†åˆ«æ„é€ ä¸¤è¾¹çš„å­æ ‘\r\n\r\n### ä»£ç \r\n\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        return self.build(head, None)\r\n\r\n    def build(self, begin, end):\r\n        if (begin == end):\r\n            return None\r\n\r\n        mid = self.get_mid(begin, end)\r\n        root = TreeNode(mid.val)\r\n        root.left = self.build(begin, mid)\r\n        root.right = self.build(mid.next, end)\r\n\r\n        return root\r\n\r\n    def get_mid(self, begin, end):\r\n        slow, fast = begin, begin\r\n        while (fast != end and fast.next != end):\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n\r\n        return slow\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193334980","body":"### æ€è·¯\r\n\r\nä¸¤ä¸ªæŒ‡é’ˆï¼Œåˆ†åˆ«éå† A + Bï¼ŒB + A å¯»æ‰¾å…¶ä¸­ç›¸äº¤çš„ç‚¹\r\n\r\n### ä»£ç \r\n\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        p1, p2 = headA, headB\r\n        len_a, len_b = 0, 0\r\n        while p1 != p2:\r\n            if p1 is None:\r\n                p1 = headB\r\n            else: \r\n                p1 = p1.next\r\n\r\n            if p2 is None:\r\n                p2 = headA\r\n            else:\r\n                p2 = p2.next\r\n\r\n        return p1\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194052788","body":"### æ€è·¯\r\n\r\nç†è§£å¿«æ…¢æŒ‡é’ˆï¼Œå¹¶ä¸”é€šè¿‡å˜é‡æ¨å¯¼ç®—æ³•åŸç†ï¼Œå¦‚ ç¬¬ä¸€æ¬¡ç›¸é‡ slowã€fast åˆ†åˆ«èµ°äº† kã€2kã€‚fast å¤šèµ°çš„ k ä¸ºç¯çš„æ•´æ•°å€ã€‚\r\nå‡è®¾ç¯çš„èµ·ç‚¹è·ç¦»ç¬¬ä¸€æ¬¡ç›¸é‡ç‚¹ä¸º mï¼Œé‚£ä¹ˆ k - m ä¸ºä» head åˆ°ç¯èµ·ç‚¹çš„è·ç¦»ï¼Œä¹Ÿæ˜¯å¿«æŒ‡é’ˆä»å½“å‰ç›¸é‡ç‚¹åˆ°ç¯èµ·ç‚¹å†ä¸€æ¬¡ç›¸é‡çš„ç‚¹ã€‚\r\n\r\n### ä»£ç \r\n\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        fast, slow = head, head\r\n\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            if fast == slow:\r\n                break\r\n\r\n        if fast is None or fast.next is None:\r\n            return None\r\n\r\n        slow = head\r\n        while slow != fast:\r\n            slow = slow.next\r\n            fast = fast.next\r\n\r\n        return slow\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196906544","body":"```python\n\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n        else:\n            return max(\n                self.maxDepth(root.left),\n                self.maxDepth(root.right)\n            ) + 1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198097159","body":"```python\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n\n        if p is None and q is None:\n            return True\n        if p is None or q is None:\n            return False\n        if p.val != q.val:\n            return False\n        \n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200238840","body":"```python\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        q = deque([root])\r\n        while q:\r\n            node = q.popleft()\r\n            if node.right:\r\n                q.append(node.right)\r\n            if node.left:\r\n                q.append(node.left)\r\n            \r\n        return node.val\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201388977","body":"```python\r\nclass Solution:\r\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\r\n        nodes = []\r\n        def dfs(root, col, row):\r\n            if root:\r\n                nodes.append((col, row, root.val))\r\n                dfs(root.left, col-1, row+1)\r\n                dfs(root.right, col+1, row+1)\r\n\r\n        dfs(root, 0, 0)\r\n        ans, last_col = [], float('-inf')\r\n        nodes.sort()\r\n        for col, row, val in nodes:\r\n            if col != last_col:\r\n                last_col = col\r\n                ans.append([])\r\n\r\n            ans[-1].append(val)\r\n        return ans\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206609604","body":"```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s):\n        ans = 0\n        queue = []\n\n        for i in s:\n            if i in queue:\n                ans = max(ans, len(queue))\n                while i in queue:\n                    queue.pop(0)\n\n            queue.append(i)\n\n        return max(ans, len(queue))\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208254725","body":"```python\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        if head:\n            slow, fast = head, head\n            while (fast and fast.next):\n                slow = slow.next\n                fast = fast.next.next\n        \n            return slow\n        return None\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"serena9":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185423747","body":"### ä»£ç \n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        temp = 0\n        for i in range(len(num)-1,-1,-1):\n            num[i], temp = (temp+num[i]+k%10)%10, (temp+num[i]+k%10)//10\n            k = k//10\n        l = []\n        n = []\n        k += temp\n        while k:\n            l.append(k%10)\n            k//=10\n        while l:\n            n.append(l.pop())\n        return n+num\n```\n### å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦ï¼šOï¼ˆnï¼‰  \nç©ºé—´å¤æ‚åº¦ï¼šOï¼ˆnï¼‰","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186139183","body":"### æ€è·¯\né¦–å…ˆéå†å­—ç¬¦ä¸²æ‰¾åˆ°ç»™å®šå­—ç¬¦çš„æ‰€æœ‰ä½ç½®ï¼Œç„¶åå†éå†å­—ç¬¦ä¸²ï¼Œæ¯”è¾ƒæ¯ä¸ªå­—ç¬¦å’Œç»™å®šå­—ç¬¦æ‰€æœ‰ä½ç½®ä¹‹é—´çš„è·ç¦»ï¼Œå–æœ€å°çš„è·ç¦»\n\n### ä»£ç \n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        s_list = list(s)\n        temp = []\n        for i in range(len(s_list)):\n            if s_list[i] == c:\n                temp.append(i)\n        answer = []\n        for i in range(len(s_list)):\n            temp2 = []\n            for j in range(len(temp)):\n                m = abs(i - temp[j])\n                temp2.append(m)\n            answer.append(min(temp2))\n        return answer\n```\n\n**å¤æ‚åº¦åˆ†æ**  \næ—¶é—´å¤æ‚åº¦ï¼šOï¼ˆn*kï¼‰ï¼Œnä¸ºå­—ç¬¦ä¸²é•¿åº¦ï¼Œkä¸ºç»™å®šå­—ç¬¦åœ¨å­—ç¬¦ä¸²ä¸­å‡ºç°çš„æ¬¡æ•°  \nç©ºé—´å¤æ‚åº¦ï¼šOï¼ˆnï¼‰","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186527404","body":"### æ€è·¯\næ•°ç»„å®ç°ï¼Œpushæ—¶æ³¨æ„åˆ¤æ–­æ˜¯å¦é•¿åº¦æº¢å‡ºï¼Œpopæ—¶åˆ¤æ–­æ˜¯å¦ä¸ºç©ºï¼Œå®šä¹‰ä¸€ä¸ªè®°å½•æ ˆé¡¶ä½ç½®çš„å˜é‡\n### ä»£ç \n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.length = maxSize\n        self.stack = []\n        self.top = 0\n\n    def push(self, x: int) -> None:\n        if self.top < self.length:\n            self.stack.append(x)\n            self.top += 1\n\n    def pop(self) -> int:\n        if self.stack:\n            self.top -= 1\n            return(self.stack.pop())\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        if self.top == 0:\n            return -1\n        elif self.top < k:\n            for i in range(self.top):\n                self.stack[i] += val\n        else:\n            for i in range(k):\n                self.stack[i] += val\n```\n**å¤æ‚åº¦åˆ†æ**  \n- æ—¶é—´å¤æ‚åº¦ï¼špushå’Œpopä¸ºOï¼ˆ1ï¼‰ï¼Œincrementä¸ºOï¼ˆminï¼ˆkï¼Œtopï¼‰ï¼‰\n- ç©ºé—´å¤æ‚åº¦ï¼šOï¼ˆ1ï¼‰","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186751669","body":"### æ€è·¯\néå†å­—ç¬¦ä¸²ï¼Œå¦‚æœé‡åˆ°â€˜ã€â€™ï¼Œæ•°å­—å’Œå­—æ¯ï¼Œå…¨éƒ¨å­˜åˆ°æ ˆä¸­ï¼›å¦‚æœé‡åˆ°â€˜ã€‘â€™ï¼Œå¼€å§‹å‡ºæ ˆï¼Œå°†â€˜ã€â€™ä¹‹å‰çš„å­—æ¯å…¨éƒ½å‡ºæ ˆå¹¶å­˜åˆ°ä¸´æ—¶å­—ç¬¦ä¸²ä¸­ï¼Œç„¶åæ•°å­—éƒ¨åˆ†å‡ºæ ˆå¹¶å­˜åˆ°æ¬¡æ•°å­—ç¬¦ä¸²ä¸­ï¼Œæœ€åè®¡ç®—å‡ºé‡å¤çš„å­—ç¬¦ä¸²å¹¶å…¥æ ˆ\n### ä»£ç \n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        ans = []\n        for c in s:\n            if c == ']':\n                string = ''\n                count = ''\n                while ans and ans[-1] != '[':\n                    string = ans.pop() + string\n                ans.pop()\n                while ans and ans[-1].isnumeric():\n                    count = ans.pop() + count\n                ans.append(string * int(count))\n            else:\n                ans.append(c)\n        return ''.join(ans)\n```\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šOï¼ˆnï¼‰\n- ç©ºé—´å¤æ‚åº¦ï¼šOï¼ˆnï¼‰","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188945623","body":"### æ€è·¯\r\nç”¨ä¸¤ä¸ªæ ˆæ¨¡æ‹Ÿå®ç°é˜Ÿåˆ—\r\n### ä»£ç \r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.queue = []\r\n        self.temp = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.queue.append(x)\r\n\r\n    def pop(self) -> int:\r\n        while self.queue:\r\n            self.temp.append(self.queue.pop())\r\n        n = self.temp.pop()\r\n        while self.temp:\r\n            self.queue.append(self.temp.pop())\r\n        return n\r\n\r\n    def peek(self) -> int:\r\n        while self.queue:\r\n            self.temp.append(self.queue.pop())\r\n        n = self.temp.pop()\r\n        self.queue.append(n)\r\n        while self.temp:\r\n            self.queue.append(self.temp.pop())\r\n        return n\r\n\r\n    def empty(self) -> bool:\r\n        if len(self.queue) == 0:\r\n            return True\r\n        else:\r\n            return False\r\n```\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šOï¼ˆnï¼‰  \r\n- ç©ºé—´å¤æ‚åº¦ï¼šOï¼ˆnï¼‰","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189981219","body":"### æ€è·¯\nå‚è€ƒé¢˜è§£ï¼Œåº”ç”¨å•è°ƒæ ˆï¼Œéå†æ•°ç»„ï¼Œä¸‹ä¸€åˆ†å—çš„æœ€å°å€¼åº”è¯¥å¤§äºä¸Šä¸€åˆ†å—çš„æœ€å¤§å€¼ï¼Œæ¯ä¸€åˆ†å—ç”¨å—ä¸­æœ€å¤§å€¼è¡¨ç¤ºï¼Œå¹¶ä¸”å­˜äºæ ˆä¸­ï¼Œè¯¥æ ˆå•è°ƒå¢ï¼Œæœ€ç»ˆåˆ†å—æ•°ç­‰äºæ ˆçš„é•¿åº¦\n### ä»£ç \n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for x in arr:\n            if stack and stack[-1] > x:\n                top = stack[-1]\n                while stack and stack[-1] > x:\n                    stack.pop()\n                stack.append(top)\n            else:\n                stack.append(x)\n        return len(stack)\n```\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šOï¼ˆnï¼‰  \n- ç©ºé—´å¤æ‚åº¦ï¼šOï¼ˆnï¼‰","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191627375","body":"### æ€è·¯\nå‚è€ƒå®˜æ–¹é¢˜è§£\n### ä»£ç \n```python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        # åŒæŒ‡é’ˆ\n        if head:\n            p1 = head\n            p2 = head\n            count = 1\n            i = 0\n            while i < k:\n                if p2.next:\n                    count += 1\n                    p2 = p2.next\n                else:\n                    k = k % count\n                    i = -1\n                    p2 = head\n                i += 1\n\n            while p2.next:\n                p1 = p1.next\n                p2 = p2.next\n\n            if p1.next:\n                tmp = p1.next\n            else:\n                return head\n            p1.next = None\n            p2.next = head\n            return tmp\n```\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šOï¼ˆnï¼‰  \n- ç©ºé—´å¤æ‚åº¦ï¼šOï¼ˆ1ï¼‰","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192660131","body":"### ä»£ç \n```python\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head == None or head.next == None:\n            return head\n        else:\n            ans = ListNode()\n            ans.next = head.next\n            pre = ans\n            first = head\n            while first and first.next:\n                second = first.next\n                post = second.next\n\n                first.next = post\n                second.next = first\n                pre.next = second\n\n                pre = first\n                first = post\n            return ans.next\n```\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šOï¼ˆnï¼‰  \n- ç©ºé—´å¤æ‚åº¦ï¼šOï¼ˆ1ï¼‰","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193123313","body":"### ä»£ç \n```python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193281721","body":"### æ€è·¯\nä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«ä»A,Bä¸¤é“¾è¡¨å¼€å§‹éå†ï¼Œéå†Açš„æŒ‡é’ˆéå†ç»“æŸåé‡æ–°å¼€å§‹éå†Bï¼Œéå†Bçš„æŒ‡é’ˆéå†å®Œåé‡æ–°å¼€å§‹éå†Aï¼Œæ­¤æ—¶è‹¥äºŒè€…ç›¸é‡åˆ™ä¸ºç›¸äº¤çš„èµ·å§‹èŠ‚ç‚¹\n### ä»£ç \n```python\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        p1 = headA\n        p2 = headB\n        while p1 != p2:\n            if not p1:\n                p1 = headB\n            else:\n                p1 = p1.next\n            if not p2:\n                p2 = headA\n            else:\n                p2 = p2.next\n        return p1\n```\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šOï¼ˆnï¼‰  \n- ç©ºé—´å¤æ‚åº¦ï¼šOï¼ˆ1ï¼‰","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1208894468","body":"### æ€è·¯\nå¿«æ…¢æŒ‡é’ˆï¼Œå¿«æŒ‡é’ˆæ¯æ¬¡èµ°2æ­¥ï¼Œæ…¢æŒ‡é’ˆæ¯æ¬¡èµ°1æ­¥ï¼Œå½“äºŒè€…ç¬¬ä¸€æ¬¡ç›¸é‡æ—¶ï¼Œå¿«æŒ‡é’ˆæ¯”æ…¢æŒ‡é’ˆå¤šèµ°ä¸€åœˆç¯ï¼Œæ­¤æ—¶å¿«æŒ‡é’ˆèµ°è¿‡çš„ä»ç›¸é‡ç‚¹åˆ°ç¯èµ·å§‹ç‚¹çš„è·ç¦»ä¸æ…¢æŒ‡é’ˆèµ°çš„ä»é“¾è¡¨å¤´ç»“ç‚¹åˆ°ç¯èµ·å§‹ç‚¹çš„è·ç¦»ç›¸ç­‰ï¼Œåˆ©ç”¨è¿™ç‚¹ï¼Œå°†å¿«æŒ‡é’ˆé‡æ–°å®šä½åˆ°é“¾è¡¨å¤´éƒ¨ï¼Œå’Œæ…¢æŒ‡é’ˆä¸€èµ·ä¸€æ¬¡èµ°ä¸€æ­¥ï¼Œç›´åˆ°ç›¸é‡ï¼Œæ­¤å¤„ä¸ºç¯çš„èµ·å§‹ä½ç½®\n### ä»£ç \n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        fast = slow = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                break\n        if not (fast and fast.next): return None\n        fast = head\n        while fast != slow:\n            fast = fast.next\n            slow = slow.next\n        return slow\n```\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šOï¼ˆnï¼‰  \n- ç©ºé—´å¤æ‚åº¦ï¼šOï¼ˆ1ï¼‰","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1199383568","body":"### æ€è·¯\né€’å½’\n### ä»£ç \n```python\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n```\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šOï¼ˆnï¼‰ï¼Œnä¸ºæ ‘çš„èŠ‚ç‚¹æ•°  \n- ç©ºé—´å¤æ‚åº¦ï¼šOï¼ˆhï¼‰ï¼Œhä¸ºæ ‘çš„é«˜åº¦","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198245294","body":"### æ€è·¯\nå‚è€ƒå®˜æ–¹é¢˜è§£æ€è·¯ï¼Œé€’å½’\n### ä»£ç \n```python\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šOï¼ˆnï¼‰  ï¼Œnä¸ºæ ‘çš„èŠ‚ç‚¹æ•°\n- ç©ºé—´å¤æ‚åº¦ï¼šOï¼ˆhï¼‰ï¼Œhä¸ºæ ‘çš„é«˜åº¦","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199309813","body":"### æ€è·¯\næ·±åº¦ä¼˜å…ˆéå†ï¼ˆdfsï¼‰ï¼Œæ‰¾åˆ°æ ¹èŠ‚ç‚¹åˆ°å¶ç»“ç‚¹çš„æ¯æ¡è·¯å¾„ï¼Œæ±‚å’Œ\n### ä»£ç \n```python\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def dfs(root, cur):\n            if not root:\n                return 0\n            res = cur * 10 + root.val\n            if not root.left and not root.right:\n                return res\n            return dfs(root.left, res) + dfs(root.right, res)\n        return dfs(root, 0)\n```\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šOï¼ˆnï¼‰  nä¸ºæ ‘çš„èŠ‚ç‚¹æ•°\n- ç©ºé—´å¤æ‚åº¦ï¼šOï¼ˆhï¼‰ï¼Œhä¸ºæ ‘çš„é«˜åº¦","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202400994","body":"### ä»£ç \n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        remain = {}\n        ans = []\n        for i,num in enumerate(nums):  \n            if remain.get(num) is not None:\n                ans=[i, remain[num]]\n            remain[target-num] = i\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203859495","body":"### æ€è·¯\nå“ˆå¸Œè¡¨+å †æ’åº\n### ä»£ç \n```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        ans = []\n        count = collections.Counter(nums)\n        for key, val in count.items():\n            if len(ans) < k:\n                heapq.heappush(ans, [val,key])\n            else:\n                heapq.heappushpop(ans, [val,key])\n        return [key for val, key in ans]\n```\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šOï¼ˆn*logkï¼‰  \n- ç©ºé—´å¤æ‚åº¦ï¼šOï¼ˆnï¼‰","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205323470","body":"### ä»£ç \n```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        n = len(points)\n        ans = 0\n        for i in range(n):\n            m = collections.defaultdict(int)\n            for j in range(n):\n                dist = abs(points[i][0] - points[j][0]) ** 2 + abs(points[i][1] - points[j][1]) ** 2\n                m[dist] += 1\n            for count in m.values():\n                ans += count * (count-1)\n        return ans\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207569682","body":"### æ€è·¯\nå¿«æ…¢æŒ‡é’ˆï¼Œæ…¢æŒ‡é’ˆæ¯æ¬¡èµ°ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆæ¯æ¬¡èµ°ä¸¤æ­¥ï¼Œå½“å¿«æŒ‡é’ˆåˆ°è¾¾é“¾è¡¨å°¾éƒ¨æ—¶ï¼Œæ…¢æŒ‡é’ˆåˆšå¥½æŒ‡å‘ä¸­é—´\n### ä»£ç \n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        i = head\n        j = head\n        while j and j.next:\n            i = i.next\n            j = j.next.next\n        return i\n```\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šOï¼ˆnï¼‰  \n- ç©ºé—´å¤æ‚åº¦ï¼šOï¼ˆ1ï¼‰","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208788726","body":"### æ€è·¯\nè¯»å†™åŒæŒ‡é’ˆï¼Œé‡åˆ°ä¸åŒçš„å†™æŒ‡é’ˆå‰ç§»ä¸€æ­¥ï¼Œå¹¶å†™å…¥è¯»æŒ‡é’ˆçš„å€¼ï¼Œè¯»æŒ‡é’ˆä¸€ç›´å‰è¿›\n### ä»£ç \n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        w = r = 0\n        if not nums:\n            return 0\n        while r < len(nums):\n            if nums[w] != nums[r]:\n                w += 1\n                nums[w] = nums[r]\n            r += 1\n        return w+1\n```\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šOï¼ˆnï¼‰  \n- ç©ºé—´å¤æ‚åº¦ï¼šOï¼ˆ1ï¼‰","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"junzmer":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185423785","body":"### **æ€è·¯**\r\nç®€å•ç›´æ¥ç‰ˆ\r\n\r\n1. å…ˆæŠŠæ•°ç»„è½¬æˆæ•°å­—\r\n2. ç›¸åŠ \r\n3. æŠŠæ•°å­—è½¬æˆæ•°ç»„ï¼Œå…ˆé™¤10æ±‚ä½™æ•°ï¼Œç„¶åé™¤10æ±‚å•†ï¼Œç»“æœåšä¸ªåè½¬\r\n\r\n### **ä»£ç **\r\n\r\n```python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        num_sum = 0\r\n        num = num[::-1]\r\n        num_length = len(num)\r\n        for i in range(num_length):\r\n            num_sum += (10 ** i) * num[i]\r\n        all_sum = num_sum + k\r\n        result = []\r\n        while all_sum > 0:\r\n            mod = all_sum % 10\r\n            all_sum = all_sum // 10\r\n            result.append(mod)\r\n        return result[::-1]\r\n```\r\n\r\n### **å¤æ‚åº¦**\r\n\r\n- æ—¶é—´å¤æ‚åº¦O(N) Næ•°ç»„é•¿åº¦\r\n- ç©ºé—´å¤æ‚åº¦O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1188666034","body":"### **æ€è·¯**\r\n\r\n1. è·å¾—cçš„æ‰€æœ‰ç´¢å¼•\r\n2. éå†sä¸­çš„å…ƒç´ ï¼Œç´¢å¼•å°äºæœ€å°ç´¢å¼•çš„ï¼Œæœ€å°è·ç¦»æ˜¯åˆ°æœ€å°ç´¢å¼•çš„è·ç¦»\r\n3. å¤§äºæœ€å¤§ç´¢å¼•çš„ï¼Œæœ€å°è·ç¦»æ˜¯åˆ°æœ€å¤§ç´¢å¼•çš„è·ç¦»\r\n4. ä½äºä¸Šè¿°ä¸¤è€…ä¸­é—´çš„ï¼Œè®¡ç®—æ‰€æœ‰è·ç¦»ï¼Œå–æœ€å°å€¼\r\n\r\n### **ä»£ç **\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        s = list(s)\r\n        len_s = len(s)\r\n        index_c = [index for (index,value) in enumerate(s) if value == c]\r\n        result = []\r\n        for i in range(len_s):\r\n            if i<=index_c[0] :\r\n                result.append(index_c[0]-i)\r\n            elif i>=index_c[-1]:\r\n                result.append(i-index_c[-1])\r\n            else:\r\n                min_dis = len_s\r\n                for k in index_c:\r\n                    dis = abs(i-k)\r\n                    if dis < min_dis:\r\n                        min_dis = dis\r\n                result.append(min_dis)\r\n        return result\r\n```\r\n### **å¤æ‚åº¦**\r\n\r\n- æ—¶é—´ï¼šO(N)\r\n- ç©ºé—´ï¼šO(N)\r\n","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188631434","body":"### **æ€è·¯**\r\nç”¨pythonåˆ—è¡¨å®ç°\r\npush -> list.append()\r\npop -> list.pop(0)\r\npeek -> list[0]\r\nempty -> len(list)\r\n\r\n### **ä»£ç **\r\n```python\r\nclass MyQueue(object):\r\n\r\n    def __init__(self):\r\n        self.queue = []\r\n\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.queue.append(x)\r\n        return self.queue\r\n\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        x = self.queue.pop(0)\r\n        return x\r\n\r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        x = self.queue[0]\r\n        return x\r\n\r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        :rtype: bool\r\n        \"\"\"\r\n        if len(self.queue) == 0:\r\n            return True\r\n        else:\r\n            return False\r\n\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n ```\r\n\r\n### **å¤æ‚åº¦**\r\n\r\n- ### æ—¶é—´å¤æ‚åº¦ \r\n\r\npush  : O(1)\r\npop  : O(N)\r\npeek : O(1)\r\nempty :O(N)\r\n\r\n- ### ç©ºé—´å¤æ‚åº¦ï¼š\r\npush  : O(1)\r\npop  : O(N)\r\npeek : O(1)\r\nempty :O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190328408","body":"### **æ€è·¯**\r\n\r\n1. æ„é€ æ ˆï¼Œæ ˆå¤´ä¸ºæœ€å¤§å€¼\r\n2. éå†æ•°ç»„ï¼Œå…ƒç´ å°äºæ ˆå¤´ï¼Œæ ˆå¤´å‡ºæ ˆï¼Œä¿å­˜ä¸ºæœ€å¤§å€¼ï¼Œ\r\n3. å…ƒç´ ä¾æ¬¡ä¸æ ˆå†…æ•°å€¼æ¯”è¾ƒï¼Œå°äºå…ƒç´ åˆ™å‡ºæ ˆï¼Œä¸å°äºæ ˆé‡Œçš„å€¼ï¼Œæˆ–è€…æ ˆä¸ºç©ºï¼Œæœ€å¤§å€¼å…¥æ ˆ\r\n4. å…ƒç´ å¤§äºæ ˆå¤´ï¼Œç›´æ¥å…¥æ ˆï¼Œæ ˆå¤´ä¸ºæœ€å¤§å€¼\r\n\r\n### **ä»£ç **\r\n```python\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        \"\"\"\r\n        :type arr: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n        # å•è°ƒæ ˆ\r\n        stack = [arr[0]]\r\n        head = arr[0]\r\n        for i in range(1,len(arr)):\r\n            if arr[i] < head and len(stack) > 0:\r\n                temp_head = head\r\n                while len(stack) > 0 and arr[i] < stack[-1] :\r\n                    if stack.pop(-1) > head:\r\n                        head = stack.pop(-1)\r\n                stack.append(head)\r\n            else:\r\n                stack.append(arr[i])   \r\n                head = arr[i]\r\n        return len(stack)\r\n```\r\n### **å¤æ‚åº¦åˆ†æ**\r\næ‰§è¡Œç”¨æ—¶ï¼š\r\n```\r\n20 ms, åœ¨æ‰€æœ‰ Python æäº¤ä¸­å‡»è´¥äº†91.67%çš„ç”¨æˆ·\r\nå†…å­˜æ¶ˆè€—ï¼š13.2 MB, åœ¨æ‰€æœ‰ Python æäº¤ä¸­å‡»è´¥äº†75.00%çš„ç”¨æˆ·\r\n```\r\n\r\n- æ—¶é—´å¤æ‚åº¦: O(N)\r\n- ç©ºé—´å¤æ‚åº¦: O(N)\r\n\r\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195489992","body":"### **æ€è·¯**\r\nå“ˆå¸Œè¡¨ï¼ˆå­—å…¸ï¼‰+ åŒé“¾è¡¨\r\n### **ä»£ç **\r\n```python\r\nclass DLinkedNode:\r\n    def __init__(self, key=0, value=0):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = None\r\n        self.next = None\r\n\r\nclass LRUCache(object):\r\n\r\n    def __init__(self, capacity):\r\n        \"\"\"\r\n        :type capacity: int\r\n        \"\"\"\r\n        self.cache = dict()\r\n        self.head = DLinkedNode()\r\n        self.tail = DLinkedNode()\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n        self.capacity = capacity\r\n        self.size = 0\r\n\r\n\r\n    def get(self, key):\r\n        \"\"\"\r\n        :type key: int\r\n        :rtype: int\r\n        \"\"\"\r\n        if key not in self.cache:\r\n            return -1\r\n        node = self.cache[key]\r\n        self.moveToHead(node)\r\n        return node.value\r\n\r\n\r\n    def put(self, key, value):\r\n        \"\"\"\r\n        :type key: int\r\n        :type value: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if key not in self.cache:\r\n            node = DLinkedNode(key, value)\r\n            self.cache[key] = node\r\n            self.addToHead(node)\r\n            self.size += 1\r\n            if self.size > self.capacity:\r\n                removed = self.removeTail()\r\n                self.cache.pop(removed.key)\r\n                self.size -= 1\r\n        else:\r\n            node = self.cache[key]\r\n            node.value = value\r\n            self.moveToHead(node)\r\n    \r\n    def addToHead(self, node):\r\n        node.prev = self.head\r\n        node.next = self.head.next\r\n        self.head.next.prev = node\r\n        self.head.next = node\r\n    \r\n    def removeNode(self, node):\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n\r\n    def moveToHead(self, node):\r\n        self.removeNode(node)\r\n        self.addToHead(node)\r\n\r\n    def removeTail(self):\r\n        node = self.tail.prev\r\n        self.removeNode(node)\r\n        return node\r\n\r\n```\r\n### **å¤æ‚åº¦åˆ†æ**\r\næ—¶é—´å¤æ‚åº¦ï¼šput å’Œ get éƒ½æ˜¯ O(1)\r\nç©ºé—´å¤æ‚åº¦ï¼šO(\\text{capacity})O(capacity)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hx-code":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185455662","body":"var addToArrayForm = function(num, k) {\n    let res = [];\n    let len = num.length;\n    for(let i=len-1; i>=0;i--){\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if(sum>=10){\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);  \n    }\n    for(let i =k;i>0;i=Math.floor(i/10)){\n        res.push(i % 10)\n    }\n    res.reverse();\n    return res;\n\n};\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186492043","body":"class CustomStack:\n    def __init__(self, maxSize: int):\n        self.s = []\n        self.maxSize = maxSize\n    def push(self, x: int) -> None:\n        if len(self.s) < self.maxSize:\n            self.s.append(x)\n    def pop(self) -> int:\n        if not self.s:\n            return -1\n        return self.s.pop()\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,len(self.s))):\n            self.s[i] += val","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187606802","body":"Â·Â·Â·js\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    let stack = []\n    let num = 0, char = '', cur = '', top \n\n    for (let i = 0; i < s.length; i++) {\n        cur = s.charAt(i)\n\n        if (typeof +cur === 'number' && !isNaN(+cur)) {\n            num = num * 10 + +cur\n        } else if (cur === '[') {\n            stack.push([num, char])\n            num = 0\n            char = ''\n        } else if (cur === ']') {\n            top = stack.pop()\n            char = top[1] + new Array(top[0]).fill(char).join('')\n        } else {\n            char += cur\n        }\n    }\n\n    return char\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189234839","body":"var MyQueue = function() {\n    this.stack1 = [];\n    this.stack2 = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    while(this.stack2.length) {\n        this.stack1.push(this.stack2.pop());\n    }\n    this.stack1.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    while(this.stack1.length) {\n        this.stack2.push(this.stack1.pop());\n    }\n    return this.stack2.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    while(this.stack1.length) {\n        this.stack2.push(this.stack1.pop());\n    }\n    return this.stack2[this.stack2.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.stack1.length && !this.stack2.length\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190263393","body":"```js/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function (arr) {\n    const sorted = [...arr];\n    sorted.sort((a, b) => a - b);\n\n    let count = 0,\n        sum1 = 0,\n        sum2 = 0;\n\n    for (let i = 0; i < arr.length; i++) {\n        sum1 += arr[i];\n        sum2 += sorted[i];\n\n        if (sum1 === sum2) {\n            count++;\n            sum1 = sum2 = 0; // è¿™è¡Œä¸è¦ä¹Ÿå¯ä»¥å•¦\n        }\n    }\n\n    return count;\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191638313","body":"Â·Â·Â·js\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n        if (!head || !head.next || !k) {\n            return head\n        }\n        let len = 1\n        let p = head\n        while(p.next) {\n            len++\n            p = p.next\n        }\n        if (k%len === 0) {\n            return head\n        }\n        p.next = head // å½¢æˆç¯å½¢é“¾\n        let index = len - k % len\n        while(index) {\n            p = p.next\n            index--\n        }\n        let head2 = p.next\n        p.next = null\n        return head2\n    };\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192616244","body":"```js\nvar swapPairs = function(head) {\n    let dummyNode = new ListNode(0,head);\n    let now = dummyNode;\n    while(now.next && now.next.next) {\n        let second = now.next.next;\n        let first = now.next;\n        let next = second.next;\n        now.next = second;\n        second.next = first;\n        first.next = next;\n        now = now.next.next;\n    }\n    return dummyNode.next;\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194206294","body":"var detectCycle = function (head) {\n  let fast = head;\n  let slow = head;\n  let iscycle = false;\n\n  while (fast && fast.next) {\n    fast = fast.next.next;\n    slow = slow.next;\n\n    if (fast === slow) {\n      iscycle = true;\n      break;\n    }\n  }\n\n  if (!iscycle) {\n    return null;\n  }\n\n  fast = head;\n  while (fast !== slow) {\n    fast = fast.next;\n    slow = slow.next;\n  }\n\n  return fast;\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196553884","body":"```js\nvar maxDepth = function(root) {\n    if(root == null){\n        return 0;\n    }\n\n    //æ ‘çš„çš„æœ€å¤§æ·±åº¦ç­‰äºå·¦å­æ ‘å’Œå³å­æ ‘æ·±åº¦+1 \n    return Math.max(maxDepth(root.left),maxDepth(root.right))+1\n    t \n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198338129","body":"```JS\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n    if(p == null && q == null) \n        return true;\n    if(p == null || q == null) \n        return false;\n    if(p.val != q.val) \n        return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n};\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200237512","body":"```JS\nvar findBottomLeftValue = function(root) {\n    const dfs = (root, height) => {\n        if (!root) {\n            return;\n        }\n        height++;\n        dfs(root.left, height);\n        dfs(root.right, height);\n        if (height > curHeight) {\n            curHeight = height;\n            curVal = root.val;\n        }\n    }\n\n    let curHeight = 0;\n    dfs(root, 0);\n    return curVal;\n};\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203746692","body":"```JS\nfunction topKFrequent(nums: number[], k: number): number[] {\n  const map = new Map<number, number>();\n  for (let i = 0; i < nums.length; i++) {\n    const num = nums[i];\n    if (!map.has(num)) {\n      map.set(num, 1)\n    } else {\n      map.set(num, (map.get(num) ?? 0) + 1)\n    }\n  }\n  const buckets = new Array<number[]>()\n  const returnArr: number[] = []\n  map.forEach((v, k) => buckets[v] ? buckets[v].push(k) : buckets[v] = [k])\n  let j = buckets.length - 1\n  while(returnArr.length<k){\n    if(buckets[j]){\n      returnArr.push(...buckets[j])\n    }\n    j--\n  }\n  return returnArr\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207231423","body":"var findSubstring = function(s, words) {\n    const wordSize = words[0].length\n    const substringLen = wordSize * words.length\n\n    const wordsCount = {}\n    words.forEach(w => (wordsCount[w] = (wordsCount[w] || 0) + 1))\n\n    const res = []\n    for (let i = 0; i <= s.length - substringLen; i++) {\n        const tempCount = {...wordsCount}\n        let count = words.length\n\n        for (let j = i; j < i + substringLen; j += wordSize) {\n            const word = s.slice(j, j + wordSize)\n\n            if (!(word in tempCount) || tempCount[word] <= 0) break\n\n            tempCount[word]--\n            count--\n        }\n\n        if (count === 0) res.push(i)\n    }\n    return res\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207435967","body":"class Solution:\n    def solve(self, nums, k):\n        total = sum(nums)\n        mod = total % k\n\n        ans = len(nums)\n        total = 0\n        dic = {0: -1}\n        for j in range(len(nums)):\n            total += nums[j]\n            cur = total % k\n            target = (cur - mod + k) % k\n            if target in dic:\n                ans = min(ans, j - dic[target])\n            dic[cur] = j\n\n        if ans == len(nums):\n            return -1\n        return ans","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"admu":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185460667","body":"**æ€è·¯**  \r\nä¸€å¼€å§‹åªèƒ½ç”¨listè½¬æ•°å­—ç›¸åŠ æ–¹å¼ï¼Œåæ¥å‚è€ƒäº†è¿›ä½æ–¹æ³•ï¼š  \r\n1.1 å¾ªç¯åˆ¤æ–­æ¡ä»¶å½“ k å’Œ åˆ—è¡¨éƒ½ä¸ºç©ºæ—¶å€™ç»ˆæ­¢  \r\n1.2 å–ä½™æ–¹å¼æ¯æ¬¡å»kçš„æœ«å°¾å€¼ä¸åˆ—è¡¨æœ«å°¾å€¼è¿›è¡Œç›¸åŠ ï¼ŒåŒæ—¶è®°å½•è¿›ä½çš„å€¼  \r\n\r\n**ä»£ç **  \r\n```python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        res = []\r\n        carry = 0 \r\n        if len(str(k))>len(num):\r\n            num = [0]*(len(str(k))-len(num))+num\r\n        n = len(num)-1 \r\n        while n>=0 and k>=0:\r\n            i = num[n]\r\n            kk = k%10 \r\n            res.append((i+k+carry)%10)\r\n            carry = (i+kk+carry)//10 \r\n            n -= 1\r\n            k = (k-kk)//10 \r\n        if carry!=0: res.append(carry)\r\n        return res[::-1]\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**  \r\n1.1 æ—¶é—´å¤æ‚åº¦ O(n)  \r\n1.2 ç©ºé—´å¤æ‚åº¦ O(1)  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186109783","body":"**æ€è·¯**  \r\n1.1 ä¸€å¼€å§‹ç”¨æš´åŠ›æ±‚è§£æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯O(cn)ç©ºé—´å¤æ‚åº¦O(cn)  \r\n1.2 çœ‹äº†é¢˜è§£è¿›è¡Œä¼˜åŒ–,å€ŸåŠ©-nå’Œ2nè¿›è¡ŒåŒå‘æœç´¢ï¼Œç§’å•Š  \r\n\r\n**ä»£ç **\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n = len(s)\r\n        ans = [0] * n\r\n\r\n        idx = -n\r\n        for i, ch in enumerate(s):\r\n            if ch == c:\r\n                idx = i\r\n            ans[i] = i - idx\r\n        idx = 2 * n\r\n        for i in range(n - 1, -1, -1):\r\n            if s[i] == c:\r\n                idx = i\r\n            ans[i] = min(ans[i], idx - i)\r\n        return ans\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**  \r\n1.1 æ—¶é—´å¤æ‚åº¦ O(n)  \r\n1.2 ç©ºé—´å¤æ‚åº¦ O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186462349","body":"**æ€è·¯**  \r\n***1381 https://leetcode.cn/problems/design-a-stack-with-increment-operation/submissions/***  \r\n1.1 åˆ©ç”¨åˆ—è¡¨appendåŠpopå®ç°å¤æ‚åº¦O(k)    \r\n\r\n**ä»£ç **\r\n```python\r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.maxSize = maxSize\r\n        self.list = []\r\n        self.index = 0\r\n        \r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if self.index< self.maxSize:\r\n            self.list.append(x)\r\n            self.index+=1\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if len(self.list)==0:\r\n            return -1 \r\n        else:\r\n            self.index-=1\r\n            return self.list.pop()\r\n\r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if k > self.index:\r\n            k = self.index\r\n        for i in range(k):\r\n            self.list[i] += val\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**  \r\n1.1 æ—¶é—´å¤æ‚åº¦ O(k)  \r\n1.2 ç©ºé—´å¤æ‚åº¦ O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187625717","body":"**æ€è·¯**  \r\n***394 https://leetcode.cn/problems/decode-string/  \r\n1.1 å…ˆè®²æ‰€æœ‰é]è¿›æ ˆ  \r\n1.2 é‡åˆ°]æ—¶ä¸åœçš„å‡ºæ ˆç›´åˆ°é‡åˆ°äº†[  \r\n1.3 [å‰é¢åˆ¤æ–­ä¸‹æ˜¯å¦æ˜¯æ•°å­—ä»¥åŠæ ˆéç©ºï¼Œå¦‚æœä¸æ˜¯é‚£ä¹ˆæŠŠæ•°å­—å‡ºæ ˆ  \r\n1.4 å‡ºæ ˆç›¸åŠ æ—¶å€™æ³¨æ„å­—ç¬¦ä¸²é¡ºåºï¼Œæ­£ç¡®é¡ºåºçš„str*numså®Œæˆåæ¯ä¸€éƒ¨åˆ†appendåˆ°æ ˆä¸­  \r\n\r\n**ä»£ç **\r\n```python\r\nclass Solution(object):\r\n    def decodeString(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: str\r\n        \"\"\"\r\n        stack = []\r\n        res = ''\r\n        for i in s:\r\n            if i != ']':\r\n                stack.append(i)\r\n            else:\r\n                word = stack.pop()\r\n                words = ''\r\n                while word!='[':\r\n                    words=word+words # å€’å™\r\n                    word = stack.pop()\r\n                num = stack.pop()\r\n                nums = ''\r\n                while num.isnumeric():\r\n                    nums=num+nums\r\n                    if stack and stack[-1].isnumeric():\r\n                        num = stack.pop()\r\n                    else: \r\n                        break\r\n                stack.append(words*int(nums))\r\n        return ''.join(stack)\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**  \r\n1.1 æ—¶é—´å¤æ‚åº¦ O(n)  \r\n1.2 ç©ºé—´å¤æ‚åº¦ O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189157723","body":"**æ€è·¯**  \r\n***232 https://leetcode.cn/problems/implement-queue-using-stacks/solution/yong-zhan-shi-xian-dui-lie-by-leetcode/***  \r\n1.1 åˆ©ç”¨åŒæ ˆå®ç°,ç»´æŠ¤ä¸€ä¸ªè¾“å…¥æ ˆä¸€ä¸ªè¾“å‡ºæ ˆ  \r\n1.2 å› ä¸ºæŠŠç¬¬ä¸€ä¸ªæ ˆpopåå‹å…¥åˆ°ç¬¬äºŒä¸ªæ ˆè¾“å…¥æ ˆçš„é¡ºåºåè¿‡æ¥è¿™æ—¶å€™popå°±èƒ½å®ç°é˜Ÿåˆ—çš„popåŠŸèƒ½  \r\n\r\n```python  \r\nclass MyQueue():\r\n    def __init__(self):\r\n        self.stackin = []\r\n        self.stackout = []\r\n        \r\n    def push(self,i):\r\n        self.stackin.append(i)\r\n        \r\n    def pop(self):\r\n        if not self.stackout:\r\n            while self.stackin:\r\n                self.stackout.append(self.stackin.pop())\r\n        return self.stackout.pop()\r\n    \r\n    def peak(self):\r\n        if not self.stackout:\r\n            while self.stackin:\r\n                self.stackout.append(self.stackin.pop())\r\n        return self.stackout[-1]\r\n    \r\n    def empty(self):\r\n        if not(self.stackin or self.stackout):\r\n            return True\r\n        return False\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**  \r\n1.1 æ—¶é—´å¤æ‚åº¦ O(n)  \r\n1.2 ç©ºé—´å¤æ‚åº¦ O(n)  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190341806","body":"**æ€è·¯**  \r\nèœé¸¡çš„ä¸€å¤©ï¼Œæ²¡æœ‰æ€è·¯ï¼Œè¿˜æ˜¯çœ‹å®˜æ–¹é¢˜è§£å¥½  \r\n768 https://leetcode-solution.cn/solutionDetail?type=3&id=6&max_id=2  \r\n\r\n**ä»£ç **\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, A):\r\n        stack = []\r\n        for a in A:\r\n            # é‡åˆ°ä¸€ä¸ªæ¯”æ ˆé¡¶å°çš„å…ƒç´ ï¼Œè€Œå‰é¢çš„å—ä¸åº”è¯¥æœ‰æ¯” a å°çš„\r\n            # è€Œæ ˆä¸­æ¯ä¸€ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªå—ï¼Œå¹¶ä¸”æ ˆçš„å­˜çš„æ˜¯å—çš„æœ€å¤§å€¼ï¼Œå› æ­¤æ ˆä¸­æ¯” a å°çš„å€¼éƒ½éœ€è¦ pop å‡ºæ¥\r\n            if stack and stack[-1] > a:\r\n                # æˆ‘ä»¬éœ€è¦å°†èåˆåçš„åŒºå—çš„æœ€å¤§å€¼é‡æ–°æ”¾å›æ ˆ\r\n                # è€Œ stack æ˜¯é€’å¢çš„ï¼Œå› æ­¤ stack[-1] æ˜¯æœ€å¤§çš„\r\n                cur = stack[-1]\r\n                # ç»´æŒæ ˆçš„å•è°ƒé€’å¢\r\n                while stack and stack[-1] > a: stack.pop()\r\n                stack.append(cur)\r\n            else:\r\n                stack.append(a)\r\n        # æ ˆå­˜çš„æ˜¯å—ä¿¡æ¯ï¼Œå› æ­¤æ ˆçš„å¤§å°å°±æ˜¯å—çš„æ•°é‡\r\n        return len(stack)\r\n```\r\n**å¤æ‚åº¦åˆ†æ**  \r\n1.1 æ—¶é—´å¤æ‚åº¦ O(n)  \r\n1.2 ç©ºé—´å¤æ‚åº¦ O(n)  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191443120","body":"**æ€è·¯**    \r\n61 https://leetcode-solution.cn/solutionDetail?type=3&id=7&max_id=2\r\n1.1 è¿™ä¸ªè‡ªå·±æƒ³äº†ä¸ªè¡Œå¾—é€šçš„æ€è·¯ï¼Œä½†æ˜¯è¾¹ç•Œæ²¡å¤„ç†å¥½  \r\n1.2 é¦–å…ˆå§kè§„èŒƒåˆ°é“¾è¡¨é•¿åº¦ä»¥å†…ï¼Œåœ¨æ±‚è§£è¦æ–­å¼€çš„åœ°æ–¹l = l-k\r\n1.3 åœ¨æ±‚é“¾è¡¨é•¿åº¦æ˜¯åšä¸‹å¤„ç†æŠŠé“¾è¡¨å˜æˆä¸€ä¸ªç¯ï¼Œç„¶ååœ¨låœ°æ–¹æ–­å¼€å°±å¯ä»¥äº†\r\n\r\n**ä»£ç **\r\n```python\r\nclass Solution(object):\r\n    def rotateRight(self, head, k):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :type k: int\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        if not head :return head \r\n        temp1 = head\r\n        \r\n        count1 = 1\r\n        while temp1.next:\r\n            temp1 = temp1.next\r\n            count1+=1\r\n        \r\n        temp1.next = head\r\n        reverse_k = count1-k%count1\r\n        \r\n        temp2 = head\r\n        while reverse_k>1:\r\n            reverse_k-=1\r\n            temp2 = temp2.next\r\n\r\n        head = temp2.next\r\n        temp2.next = None\r\n        return head\r\n```\r\n**å¤æ‚åº¦åˆ†æ**  \r\n1.1 æ—¶é—´å¤æ‚åº¦ O(n)  \r\n1.2 ç©ºé—´å¤æ‚åº¦ O(1)  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192172667","body":"**æ€è·¯**  \r\n1.1 25é¢˜çš„ç®€åŒ–ç‰ˆ\r\n\r\n**ä»£ç **\r\n```python\r\nclass Solution(object):\r\n    def reverse(self,head):\r\n        temp = None \r\n        while head:\r\n            p = head\r\n            head = p.next \r\n            p.next = temp \r\n            temp = p \r\n        return temp \r\n    def swapPairs(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        dummy = ListNode(0)\r\n        dummy.next = head \r\n        pre = dummy\r\n        end = dummy \r\n        \r\n        while end.next:\r\n            count = 0\r\n            while count<2:\r\n                end = end.next\r\n                count+=1\r\n            if not end:break \r\n            start = pre.next \r\n            next = end.next \r\n            end.next = None \r\n            \r\n            pre.next = self.reverse(start)\r\n            \r\n            start.next = next \r\n            pre = start \r\n            end = pre \r\n        return dummy.next\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**  \r\n1.1 æ—¶é—´å¤æ‚åº¦ O(n)  \r\n1.2 ç©ºé—´å¤æ‚åº¦ O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193142258","body":"**æ€è·¯**  \r\n1.1 åˆæ˜¯èœé¸¡çš„ä¸€å¤©ï¼Œå¥½å¥½å­¦ä¸‹é€’å½’\r\n\r\n**ä»£ç **\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head):\r\n        def getMedian(left, right):\r\n            fast = slow = left\r\n            while fast != right and fast.next != right:\r\n                fast = fast.next.next\r\n                slow = slow.next\r\n            return slow\r\n        \r\n        def buildTree(left, right):\r\n            if left == right:\r\n                return None\r\n            mid = getMedian(left, right)\r\n            root = TreeNode(mid.val)\r\n            root.left = buildTree(left, mid)\r\n            root.right = buildTree(mid.next, right)\r\n            return root\r\n        \r\n        return buildTree(head, None)\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**  \r\n1.1 æ—¶é—´å¤æ‚åº¦ O(nlogn)  \r\n1.2 ç©ºé—´å¤æ‚åº¦ O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193267904","body":"**æ€è·¯**  \r\n1.1 åŒæŒ‡é’ˆå‡è®¾æœ‰ç›¸äº¤èŠ‚ç‚¹ï¼Œåˆ™èŠ‚ç‚¹åˆ†åˆ«å°†Aä¸Båˆ†å‰²æˆé•¿åº¦a+cï¼Œb+cï¼Œé‚£ä¹ˆç›¸äº¤èŠ‚ç‚¹ä¸€å®šåœ¨ a+c+b=b+c+a\r\n1.2 æ²¡æœ‰äº¤ç‚¹åˆ™Aå’ŒBä¸€ç›´èµ°åˆ°éƒ½æŒ‡å‘None\r\n\r\n**ä»£ç **\r\n```python\r\nclass Solution(object):\r\n    def getIntersectionNode(self, headA, headB):\r\n        \"\"\"\r\n        :type head1, head1: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        if not headA or not headB:\r\n            return None \r\n        A = headA\r\n        B = headB\r\n        while A!=B:\r\n            if A!=None:\r\n                A = A.next \r\n            else:\r\n                A = headB\r\n\r\n            if B!=None:\r\n                B = B.next \r\n            else:\r\n                B = headA \r\n        return A\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**  \r\n1.1 æ—¶é—´å¤æ‚åº¦ O(n)  \r\n1.2 ç©ºé—´å¤æ‚åº¦ O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193837746","body":"**æ€è·¯**  \r\n142 https://leetcode.cn/problems/linked-list-cycle-ii/  \r\n1.1 å¿«æ…¢æŒ‡é’ˆæ€è·¯  \r\n\r\n**ä»£ç **\r\n```python\r\nclass Solution(object):\r\n    def detectCycle(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        if not head or not head.next:\r\n            return None\r\n        slow = head \r\n        fast = head \r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            if fast==slow:\r\n                break \r\n        if not fast or not fast.next:\r\n            return None \r\n        fast = head \r\n        while slow!=fast:\r\n            slow = slow.next\r\n            fast = fast.next\r\n        return fast \r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**  \r\n1.1 æ—¶é—´å¤æ‚åº¦ O(n)  \r\n1.2 ç©ºé—´å¤æ‚åº¦ O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195237560","body":"**æ€è·¯**  \r\n146 https://leetcode-cn.com/problems/lru-cache/  \r\n1.1 åªèƒ½çœ‹é¢˜è§£\r\n\r\n```python\r\n# nodeé‡Œé¢å­˜å‚¨äº†key å’Œ value  \r\n\r\n# from collections import OrderedDict\r\n# class LRUCache(OrderedDict):\r\n\r\n#     def __init__(self, capacity):\r\n    \r\n#         self.capacity = capacity\r\n\r\n#     def get(self, key):\r\n    \r\n#         if key not in self:\r\n#             return - 1\r\n        \r\n#         self.move_to_end(key)\r\n#         return self[key]\r\n\r\n#     def put(self, key, value):\r\n        \r\n#         if key in self:\r\n#             self.move_to_end(key)\r\n#         self[key] = value\r\n#         if len(self) > self.capacity:\r\n#             self.popitem(last = False)\r\n\r\nclass Node:\r\n    def __init__(self,key,val,pre=None,next=None):\r\n        self.key = key\r\n        self.val = val\r\n        self.pre = None \r\n        self.next = None\r\nclass LRUCache:\r\n    def __init__(self, capacity):\r\n        self.capacity = capacity\r\n        self.cur = 0\r\n        self.hashmap = {}\r\n        self.dummy = Node(0,0)\r\n        self.tail = Node(0,0)\r\n        \r\n        self.dummy.next = self.tail\r\n        self.tail.pre = self.dummy\r\n    \r\n    def get(self, key):\r\n        if key in self.hashmap:\r\n            node = self.hashmap[key]\r\n            \r\n            node.pre.next = node.next\r\n            node.next.pre = node.pre \r\n            \r\n            temp = self.dummy.next\r\n            self.dummy.next = node\r\n            node.next = temp\r\n            \r\n            temp.pre = node\r\n            node.pre = self.dummy\r\n            return self.hashmap[key].val\r\n        else:\r\n            return -1\r\n    def put(self, key, value):\r\n        if key in self.hashmap:\r\n            self.hashmap[key].val = value\r\n            \r\n            node = self.hashmap[key]\r\n            node.pre.next = node.next\r\n            node.next.pre = node.pre\r\n            \r\n        else:\r\n            new = Node(key,value)\r\n            self.hashmap[key] = new\r\n            if self.cur>=self.capacity:\r\n                self.tail = self.tail.pre\r\n                self.tail.next = None\r\n                \r\n                del self.hashmap[self.tail.key]\r\n                self.cur -=1 \r\n            self.cur+=1\r\n        node = self.hashmap[key]\r\n        \r\n        temp = self.dummy.next\r\n        self.dummy.next = node\r\n        node.next = temp\r\n        \r\n        temp.pre = node\r\n        node.pre = self.dummy\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**  \r\n1.1 æ—¶é—´å¤æ‚åº¦ O(1)  \r\n1.2 ç©ºé—´å¤æ‚åº¦ O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196699630","body":"**æ€è·¯**  \r\n104 https://leetcode-cn.com/problems/maximum-depth-of-binary-tree  \r\n\r\n**ä»£ç **\r\n```python\r\nclass Solution(object):\r\n    def maxDepth(self, root):\r\n        \"\"\"\r\n        :type root: TreeNode\r\n        :rtype: int\r\n        \"\"\"\r\n        if root==None:\r\n            return 0\r\n        else:\r\n            left = self.maxDepth(root.left)\r\n            right= self.maxDepth(root.right)\r\n        return max(left,right)+1\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**  \r\n1.1 æ—¶é—´å¤æ‚åº¦ O(n)  \r\n1.2 ç©ºé—´å¤æ‚åº¦ O(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198088045","body":"**æ€è·¯**  \r\n100 https://leetcode-cn.com/problems/same-tree/\r\n\r\n**ä»£ç **\r\n```python\r\nclass Solution:\r\n    def isSameTree(self, tree1, tree2):\r\n        if tree1 is None and tree2 is None:\r\n            return True \r\n        if tree1 is not None and tree2 is None:\r\n            return False \r\n        if tree1 is None and tree2 is not None:\r\n            return False \r\n        if tree1.val!=tree2.val:\r\n            return False \r\n        return self.isSameTree(tree1.left, tree2.left) and self.isSameTree(tree1.right, tree2.right)\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**  \r\n1.1 æ—¶é—´å¤æ‚åº¦ O(n)  \r\n1.2 ç©ºé—´å¤æ‚åº¦ O(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199230934","body":"```python\r\nclass Solution(object):\r\n    def sumNumbers(self, root):\r\n        \"\"\"\r\n        :type root: TreeNode\r\n        :rtype: int\r\n        \"\"\"\r\n        res = 0\r\n        def dfs (root,nums, res):\r\n            if not root :\r\n                return 0\r\n            res = nums*10+ root.val \r\n            if root.left is None and root.right is None :\r\n                return res\r\n            return dfs(root.left, res, res)+dfs(root.right, res, res)\r\n        res = dfs(root, 0, 0)\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200166697","body":"```python\r\nfrom collections import deque\r\nclass Solution(object):\r\n    def findBottomLeftValue(self, root):\r\n        \"\"\"\r\n        :type root: TreeNode\r\n        :rtype: int\r\n        \"\"\"\r\n        queue = deque([root])\r\n        left = None\r\n        while queue:\r\n            node = queue.popleft() #éœ€è¦ä»é˜Ÿåˆ—å¤´éƒ¨å…ˆå‡º\r\n            left = node.val \r\n            if node.right:\r\n                queue.append(node.right)\r\n            if node.left:\r\n                queue.append(node.left)\r\n        return left\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200416323","body":"```python\r\nclass Codec:\r\n\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        if not root:\r\n            return 'None'\r\n        return str(root.val)+','+str(self.serialize(root.left))+','+str(self.serialize(root.right))\r\n        \r\n\r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        def dfs(datalist):\r\n            val = datalist.pop(0)\r\n            if val=='None':\r\n                return None \r\n            root = TreeNode(int(val))\r\n            root.left = dfs(datalist)\r\n            root.right = dfs(datalist)\r\n            return root \r\n        datalist = data.split(',')\r\n        return dfs(datalist)\r\n```\r\n**å¤æ‚åº¦åˆ†æ**\r\n1.1 æ—¶é—´å¤æ‚åº¦ O(n)   \r\n1.2 ç©ºé—´å¤æ‚åº¦ O(n)   ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201176899","body":"**æ€è·¯**  \r\n1.1 ä¸»è¦è¿˜æ˜¯æŠŠæ•°æ®ç»“æ„æƒ³å‡ºæ¥ï¼Œæƒ³å‡ºæ¥å°±å¥½äº†  \r\n <0, 0, 1>  \r\n <-1,1, 2>  \r\n <-2,2,4>  \r\n <0, 2, 6>  \r\n <1, 1, 3>  \r\n <0, 2, 5>  \r\n <2, 2, 7>  \r\n \r\n```python\r\nclass Solution:\r\n    def verticalTraversal(self, root):\r\n        self.info = []\r\n        self.dfs(root,0,0)\r\n        \r\n        info = sorted(self.info)\r\n        ans = [[]]\r\n        pre_col = info[0][0]\r\n        for col,row,val in info:\r\n            if col == pre_col:\r\n                ans[-1].append(val)\r\n            else:\r\n                ans.append([val])\r\n                pre_col = col\r\n        return ans\r\n    \r\n    def dfs(self,root,row,col):\r\n        if not root:\r\n            return None\r\n        self.info.append((col,row,root.val))\r\n        self.dfs(root.left,row+1,col-1)\r\n        self.dfs(root.right,row+1,col+1)\r\n```\r\n**å¤æ‚åº¦**  \r\n1.1 æ—¶é—´: O(nlogn)  \r\n1.2 ç©ºé—´: O(height)  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202837724","body":"```python\r\nclass Solution(object):\r\n    def twoSum(self, nums, target):\r\n        \"\"\"\r\n        :type nums: List[int]\r\n        :type target: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        hashmap = {}\r\n        for i,j in enumerate(nums):\r\n            hashmap[j]=i\r\n        for i,j in enumerate(nums):\r\n            if target-j in hashmap and i!=hashmap[target-j]:\r\n                return [i,hashmap[target-j]]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203617368","body":"```python\r\ndef topKFrequent(nums, k):\r\n    counter = {}\r\n    for i in nums:\r\n        if i in counter:\r\n            counter[i]+=1\r\n        else:\r\n            counter[i]=1\r\n    counter = sorted(counter.items(), key = lambda x:x[1], reverse = True)\r\n    result = []\r\n    for i in range(k):\r\n        result.append(counter[i][0])\r\n    return result\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205195695","body":"```python\r\nclass Solution(object):\r\n    def numberOfBoomerangs(self, points):\r\n        \"\"\"\r\n        :type points: List[List[int]]\r\n        :rtype: int\r\n        \"\"\"\r\n        def get_distance(x,y):\r\n            return (x[0]-y[0])**2+(x[1]-y[1])**2\r\n        res = 0\r\n        for i in points:\r\n            count = collections.defaultdict(int)\r\n            for j in points:\r\n                distance = get_distance(i,j)\r\n                count[distance]+=1\r\n\r\n            for value in count.values():\r\n                res+=value*(value-1)\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206007847","body":"```python\r\nclass Solution(object):\r\n    def lengthOfLongestSubstring(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: int\r\n        \"\"\"\r\n        if not s:return 0\r\n        length = 0\r\n        max_length=0\r\n        left = 0\r\n        s_set = set()\r\n        for i in s:\r\n            length+=1\r\n            while i in s_set:\r\n                s_set.remove(s[left])\r\n                left+=1\r\n                length-=1\r\n            max_length = max(length,max_length)\r\n            s_set.add(i)\r\n        return max_length\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207189790","body":"**æ€è·¯**  \r\n1.æ˜ç¡®æè¿°ï¼Œwordsé‡Œé¢è¯é•¿åº¦ä¸€æ ·ï¼Œå‚è€ƒå®˜æ–¹é¢˜è§£ï¼Œå¯¹æ¯ä¸€ä¸ªsçš„indexä½ç½®åšä¸€ä¸ªl*nçš„æ»‘çª—å¹¶è¿›è¡Œåˆ†å‰²ï¼Œçœ‹æ˜¯å¦ä¸wordsçš„hashmapä¸€è‡´ï¼Œå¦‚æœä¸€è‡´å°±è®°å½•ä¸‹å½“å‰çš„ä½ç½®  \r\n```python\r\nclass Solution(object):\r\n    def findSubstring(self, s, words):\r\n        \"\"\"\r\n        :type s: str\r\n        :type words: List[str]\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        ls, l, n = len(s), len(words), len(words[0])\r\n        counter = collections.Counter(words)\r\n        ans = []\r\n        for i in range(ls):\r\n            temp = []\r\n            if i+l*n>ls:\r\n                break\r\n            for j in range(i,i+l*n,n):\r\n                temp.append(s[j:j+n])\r\n            if collections.Counter(temp)==counter:\r\n                ans.append(i)\r\n        return ans\r\n```\r\n**å¤æ‚åº¦**    \r\n1.æ—¶é—´å¤æ‚åº¦Oï¼ˆmnï¼‰  \r\n2.ç©ºé—´å¤æ‚åº¦Oï¼ˆnï¼‰","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207345479","body":"```python\r\nclass Solution:\r\n    def solve(self, nums, k):\r\n        total = (sum(nums) + k) % k\r\n        prefix_sum = 0\r\n        hashmap = {0: -1}\r\n        res = len(nums)\r\n        for i, num in enumerate(nums):\r\n            prefix_sum += num\r\n            mod = (prefix_sum + k) % k\r\n            hashmap[mod] = i\r\n            if (mod - total + k) % k in hashmap:\r\n                res = min(res, i - hashmap[(mod - total + k) % k])\r\n        return res if res != len(nums) else -1\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208185818","body":"```python\r\nclass Solution(object):\r\n    def middleNode(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        fast = head\r\n        slow = head\r\n\r\n        while slow and fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next \r\n        return slow\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209272773","body":"```python\r\nclass Solution(object):\r\n    def removeDuplicates(self, nums):\r\n        \"\"\"\r\n        :type nums: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n        l=0\r\n        r=1\r\n        ans=0\r\n        n=len(nums)\r\n        while r<n:\r\n            if nums[l]==nums[r]:\r\n                nums.pop(l)\r\n                n-=1\r\n            else:\r\n                ans+=1\r\n                l+=1\r\n                r+=1\r\n        return ans+1\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxiaomm":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185468498","body":"## æ€è·¯\n\n1. Add two numbers from right to left, column by column, and record the carry.\n2. If carry > 0, add it to the next column.\n3. Add the result to the first position of the result list.\n4. Implement the loop until all digit in two numbers has been calculated, or carry = 0;\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int i = num.length - 1, carry = 0;\n        while (i >= 0 || k > 0 || carry > 0) {\n            int val1 = i < 0 ? 0 : num[i--];\n            int val2 = k % 10;\n            int sum = val1 + val2 + carry;\n            carry = sum / 10;\n            res.add(0, sum % 10);\n            k = k / 10;\n        }\n        return res;\n    }\n}\n```\n\nTime complexity: O(n), n is the greater length of the two numbers.\nSpace complexity: O(1), not include the space of output array.\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186159091","body":"\n# Link\n\nhttps://leetcode.com/problems/shortest-distance-to-a-character/\n\n## Idea_1\n\n1. Traverse the string for two times;\n2. Firstly, when going from left to right, we record the distance from index i to their last/previous target character(first target on their left): ```i - prev```;\n3. Secondly, when going from right to left, we record the distance form index i to their right previous target(first target on their right), and compared with original value in the array;\n4. Update the minimum distance of every node;\n\n\n## Code_1\n\n```java\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int n = S.length(), pos = -n, res[] = new int[n];\n        // è·ç¦»æœ€å·¦è¾¹çš„eçš„è·ç¦»\n        for (int i = 0; i < n; ++i) {\n            if (S.charAt(i) == C) pos = i;\n            res[i] = i - pos;\n        }\n        // å€’åº: è·ç¦»æœ€å³è¾¹çš„eçš„è·ç¦»ä¸ä¹‹æ¯”è¾ƒ\n        for (int i = pos - 1; i >= 0; --i) {\n            if (S.charAt(i) == C)  pos = i;\n            res[i] = Math.min(res[i], pos - i);\n        }\n        return res;\n    }\n}\n```\n\n## Idea_2\n\n1. Use two pointer: ```slow``` and ```fast```.\n2. After finding the first target with ```fast``` on the right, write the distance of nodes on its left into the array, and store the index of this target as ```prev```.\n3. Continue the above step, compare the distance from the nodes to the previous target node and the next target node, update the array.\n\n\n\n## Code_2\n\n```java\nclass Solution {\n    // two pointer\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] res = new int[len];\n        int i = 0, j = 0, prev = -1;;\n        while (i < len) {\n            // æ‰¾åˆ°å³è¾¹çš„ç¬¬ä¸€ä¸ªe\n            while (j < len && s.charAt(j) != c )\n                j++;\n            if (j == len) break;    // å³è¾¹æ²¡æœ‰eäº†\n            \n            // æ¯”è¾ƒå³è¾¹çš„eå’Œå·¦è¾¹çš„eå“ªä¸ªè¿œ\n            while (i <= j){\n                res[i] = Math.min(j-i, (prev==-1 ? len : i-prev));\n                i++;\n            }\n            prev = j++; // è®°å½•å‰ä¸€ä¸ªeçš„ä½ç½®\n        }\n        // è‹¥æ•°ç»„æ²¡å¡«å……å®Œ, åˆ™å¡«å……, è·ç¦»å·¦è¾¹eçš„è·ç¦»å³æ˜¯ç»“æœ\n        while (i < len) \n            res[i] = (prev==-1 ? i : i++ -prev);    \n        \n        return res;\n    }\n}\n```\n\n\n## Complexity\n\nTime complexity: O(n), n is the length of the string.  \nSpace complexity: O(n), the length of output array.\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186548391","body":"\n# Link\n\nhttps://leetcode.com/problems/design-a-stack-with-increment-operation/\n\n## Idea\n\n1. Use an array to store the increment, inc[i] means that from ```0 - i```, the element should add ```inc[i]```;\n2. While poping an element form the stack, the size of the stack decrease, and inc[i] should be update to 0; so we need to update the increment array;  \n3. Update the former: ```inc[i-1] += inc[i]```, because element from 0 to i-1 still should add inc[i], then update ```inc[i] = 0```;\n\n## Code\n\n```java\nclass CustomStack {\n    private int capacity;\n    private int[] inc;\n    Stack<Integer> s;\n    \n    // O(n), O(n)\n    public CustomStack(int maxSize) {\n        this.capacity = maxSize;\n        inc = new int[capacity];\n        s  = new Stack<>();\n    }\n    // O(1)\n    public void push(int x) {\n        if (s.size() < capacity)\n            s.push(x);\n    }\n    // O(1)\n    public int pop() {\n        if (s.isEmpty()) return -1;\n        \n        int i = s.size()-1;\n        if (i > 0)\n            inc[i-1] += inc[i];\n        int val = s.pop()+inc[i];\n        inc[i] = 0;\n        return val;\n    }\n    // O(1)\n    public void increment(int k, int val) {\n        int bound = Math.min(s.size(),k) - 1;\n        if (bound >= 0)\n            inc[bound] += val;\n    }\n}\n```\n\n\n## Complexity\n\nTime complexity: Initialization: O(n); Others: O(1).\nSpace complexity: Initialization: O(n); Others: O(1).\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187440232","body":"\n## Link\n\nhttps://leetcode.com/problems/decode-string/\n\n## Idea_1\n\n1. Using Two Stack to sotre the number and decoded strings;\n2. While meeting digit or character, append it with varible ```count``` or ```res```;\n3. While meeting opening bracket```'['```, push digit and string into those two stack;\n4. While meeting closing bracket```']'```, pop the previous string  and count from the stack, decode current string for ```count``` times and append it to the previous string;\n\n## Code_1\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Integer> in = new Stack<>();\n        Stack<String> stack = new Stack<>();\n        String res = \"\";\n        int i = 0, count = 0;\n        while (i < s.length()) {\n            char c = s.charAt(i++);\n            if (Character.isDigit(c))\n                count = count*10 + c - '0';\n            else if (c == '[') {\n                in.push(count);\n                stack.push(res);\n                res = \"\";\n                count = 0;\n            }\n            else if (Character.isAlphabetic(c))\n                res += c;\n            else if (c == ']') {\n                int cnt = in.pop();\n                StringBuilder temp = new StringBuilder(stack.pop());\n                for (int j = 0; j < cnt; j++) \n                    temp.append(res);\n                res = temp.toString();\n            }\n        }\n        return res;\n    }\n}\n```\n\n## Idea_2\n\n1. Using one stack to store everything;\n2. While meeting character instead of ```']'```, push it into the stack;\n3. While meeting ```']'```, pop the character from the stack;\n4. Use varible ```sb``` to store the substring until meet ```'['```;\n5. Then pop ```'['``` out, and use ```count``` to store the following digit;\n6. Decode the substring ```sb``` for ```count``` times and push it back to the stack;\n7. Pop the result from the stack;\n\n## Code_2\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n        for(char c : s.toCharArray()) {\n            if(c != ']') \n                stack.push(c); //push everything but ]\n            else {\n                //step 1: \n                    //if you find a closing ] then \n                    //retrieve the string it encapsulates\n                StringBuilder sb = new StringBuilder();\n                while(!stack.isEmpty() && Character.isLetter(stack.peek()))\n                    sb.insert(0, stack.pop());\n                String sub = sb.toString(); //this is the string contained in [ ]\n                stack.pop(); //Discard the '[';\n                //step 2: \n                    //after that get the number of\n                    // times it should repeat from stack\n                sb = new StringBuilder();\n                while(!stack.isEmpty() && Character.isDigit(stack.peek()))\n                    sb.insert(0, stack.pop());\n                int count = Integer.valueOf(sb.toString()); // this is the number\n                //step 3: \n                    //repeat the string within the [ ] count \n                    //number of times and push it back into stack\n                while(count > 0) {\n                    for(char ch : sub.toCharArray())  \n                        stack.push(ch);\n                    count--;\n                }\n            }\n        }\n        //final fetching and returning the value in stack \n        StringBuilder retv = new StringBuilder();\n        while(!stack.isEmpty())\n            retv.insert(0, stack.pop());\n        return retv.toString();\n    }\n}\n```\n\n## Idea_3\n\n1. Using recursion and global varible ```index```;\n2. While meeting digits, build the number ```count``` by iterating over the string ```s```;\n3. While meeting ```'['```, ignore it and recursively find the nested string ```temp```;\n4. Decode the current pattern ```count[temp]```;\n5. While meeting ```']'```, finished and return;\n   \n\n## Code_3\n\n```java\nclass Solution {\n    int index = 0;\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        int num = 0;\n        String temp = \"\";\n        \n        while (index < s.length()) {\n            char ch = s.charAt(index++);\n            if (Character.isDigit(ch))\n                num = num*10 + ch - '0';\n            else if (ch == '['){\n                temp = decodeString(s);\n                for (int j = 0; j < num; j++)\n                    res.append(temp);\n                num = 0;\n            }\n            else if (Character.isAlphabetic(ch))\n                res.append(ch);  \n            else \n                break;\n                \n        }\n        return res.toString();\n    }\n}\n```\n\n\n## Complexity\n\nTime complexity: O(n), n is the length of decoded string.  \nSpace complexity: O(n), n is the length of decoded string. \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189097770","body":"\n## Link\n\nhttps://leetcode.com/problems/implement-queue-using-stacks/\n\n## Idea\n\n1. Use two stacks;\n2. While poping, we push all the elements from stack1 into the stack2, and find the first element.\n\n\n## Code\n\n```java\nclass MyQueue {\n    Stack<Integer> s;\n    Stack<Integer> ss;\n    public MyQueue() {\n        s = new Stack<>();\n        ss = new Stack<>();\n    }\n    \n    public void push(int x) {\n        s.push(x);\n    }\n    \n    public int pop() {\n        while (!s.isEmpty())\n            ss.push(s.pop());\n        int val = ss.pop();\n        while (!ss.isEmpty())\n            s.push(ss.pop());\n        return val;\n        \n    }\n    \n    public int peek() {\n        return s.get(0);\n    }\n    \n    public boolean empty() {\n        return s.isEmpty();\n    }\n}\n```\n\n\n## Complexity\n\nTime complexity: pop(): O(n), others: O(1).  \nSpace complexity: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190379759","body":"\n## Link\n\nhttps://leetcode.com/problems/max-chunks-to-make-sorted-ii/\n\n## Idea\n\n1. Sort the array;\n2. Traverse the sorted and original array and compute their sum seperately, if the sum1 == sum2, the result plus 1;\n\n## Code\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int[] sorted = arr.clone();\n        Arrays.sort(sorted);\n        int res = 0, sum1 = 0, sum2 = 0;\n        for (int i = 0; i < arr.length; i++) {\n            sum1 += arr[i];\n            sum2 += sorted[i];\n            if (sum1 == sum2) res += 1;\n        }\n        return res;\n    }\n}\n```\n\n\n## Complexity\n\nTime complexity: O(nlogn), sort the array need nlogn time.  \nSpace complexity: O(n), clone the original array need n space. ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191405197","body":"\n## Link\n\nhttps://leetcode.com/problems/rotate-list/\n\n## Idea\n\n \n 1. Close the list into the ring.\n 2. Traverse the list and get the length of it.\n 3. Find the previous node of the last k % length node from the end of the list. \n 4. Break the ring at the position: after the new tail or before the new head.\n \n\n## Code\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null) return head;\n        ListNode dummy = new ListNode(-1,head), curr = dummy;\n        int len = 0;\n        while (curr.next != null) {\n            len++;\n            curr = curr.next;\n        }\n        curr.next = head;   // close the list into the ring\n        curr = dummy;\n        for (int i = 0; i < len-k%len; i++) \n            curr = curr.next;\n        head = curr.next;\n        curr.next = null;\n        return head;\n    }\n}\n```\n\n\n## Complexity\n\nTime complexity: O(n), n is the length of the list.  \nSpace complexity: O(1). \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192623209","body":"\n### Link\n\nhttps://leetcode.com/problems/swap-nodes-in-pairs/\n\n### Clarifications / Constraints\n\n1. number of nodes;\n\n### Idea_1\n\n1. Recursion;\n2. Store the recursion result with node ```ret```;\n3. Swap the current pair;\n4. The tail point to the ```ret```;\n5. return the new head;\n\n\n#### Code\n\n```java\n// recursion: O(n), O(n)\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode ret = swapPairs(head.next.next);\n        ListNode nxt = head.next;\n        head.next = ret;\n        nxt.next = head;\n        return nxt;\n        \n    }\n} \n```\n\n#### Complexity\n\nTime complexity: O(n).   \nSpace complexity: O(n).  \n\n\n### Idea_2\n\n1. Iteration;\n2. Use the ```dummy``` node, because the head node changed;\n3. Store the next pair pointer and the prev pointer of the current pair;\n4. swap the current pair;\n\n\n#### Code\n\n```java\n// Iteration: O(n), O(1)\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(-1, head);\n        ListNode prev = dummy, curr = head, nxt = null;\n        while (curr != null && curr.next != null) {\n            nxt = curr.next.next;\n            prev.next = curr.next;\n            curr.next.next = curr;\n            curr.next = nxt;\n            prev = curr;\n            curr = nxt;\n        }\n        return dummy.next;\n    }\n}\n```\n\n#### Complexity\n\nTime complexity: O(n).   \nSpace complexity: O(1).\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193132973","body":"\n## Link\n\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/\n\n## Idea_1\n\n \n 1. Using inorder traversal to build the tree.\n 2. Store the values in a list.\n 3. Construct the tree.\n \n\n## Code\n\n```java\nclass Solution {\n    List<Integer> arr = new LinkedList<>();\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n        while (head != null) {\n            arr.add(head.val);\n            head = head.next;\n        }\n        return build(0, arr.size()-1);    \n    }\n    public TreeNode build(int l, int r) {\n        if (l > r) return null;\n        int mid = l + (r-l)/2;\n        TreeNode root = new TreeNode(arr.get(mid));\n        root.left = build(l, mid-1);\n        root.right = build(mid+1, r);\n        return root;\n    }\n}  \n```\n\n\n## Complexity\n\nTime complexity: O(n), traverse all nodes.  \nSpace complexity: O(n), store all values need n size list. \n\n\n## Idea_2\n\n \n 1. Using Recursion.\n 2. Find the middle of every sub list -> balanced BST.\n 3. Construct the tree.\n \n\n## Code\n\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n        ListNode mid = findMid(head);\n        TreeNode root = new TreeNode(mid.val);\n        if (head == mid) return root;\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(mid.next);\n        return root;\n    }\n    public ListNode findMid(ListNode head) {\n        ListNode slow = head, fast = head, prev = null;\n        while (fast != null && fast.next != null) {\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        if(prev != null) prev.next = null; // split the first and second list\n        return slow;\n    }\n}\n```\n\n\n## Complexity\n\nTime complexity: O(nlogn), build tree need logn times, find mid need n time.    \nSpace complexity: O(height), the recursion stack needs height. \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193260221","body":"\n### Link\n\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/\n\n### Clarifications / Constraints\n\n1. head != null\n2. intersection not exist ?\n3. one list is the sublist of another one?\n\n### Idea_1\n\n1. Use two pointer pA, pB start with two list headA, headB seperately;\n2. Set pointer pA to point at headA, set pointer pB to point at headB;\n3. While pA != pB, move to the next node;\n4. If pA == null, pA = headB, if pB == null, pB = headA;\n5. Then both of pA and pB move the same distance: lenA + lenB - the public;\n\n#### Code\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode pA = headA, pB = headB;\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n```\n\n#### Complexity\n\nTime complexity: O(n+m), n and m are the length of lsit1 and list2.  \nSpace complexity: O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194077990","body":"\n\n### Link\n\nhttps://leetcode.com/problems/linked-list-cycle-ii/\n\n### Clarifications / Constraints\n\n1. no cycle;\n2. length of list: null ?\n\n### Idea\n\n1. Use two pointer(slow-fast) to detect the cycle;\n2. If has the cycle, slow-fast will intersect at the cycle, at this time, set fast at  head, and change the step size to two;\n3. Then slow-fast will intersect at the position of the starting point of the cycle.\n\n\n#### Code\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null)  return null;\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast)\n                break;\n        }\n        if (slow != fast) return null;\n        fast = head;\n        while (slow != fast) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n}\n```\n\n#### Complexity\n\nTime complexity: O(n)  \nSpace complexity: O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195483940","body":"\n### Link\n\nhttps://leetcode.com/problems/lru-cache/\n\n\n### Idea\n\n1. Use Hash table and linked list.\n\n\n#### Code\n\n```java\nclass LRUCache extends LinkedHashMap<Integer, Integer>{\n    int capacity;\n    public LRUCache(int capacity) {\n// public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) \n// è¿™é‡Œçš„ accessOrder é»˜è®¤æ˜¯ä¸ºfalseï¼Œå¦‚æœè¦æŒ‰è¯»å–é¡ºåºæ’åºéœ€è¦å°†å…¶è®¾ä¸º true\n// initialCapacity ä»£è¡¨ map çš„ å®¹é‡ï¼ŒloadFactor ä»£è¡¨åŠ è½½å› å­ (é»˜è®¤å³å¯)\n       super(capacity, 0.75F, true);\n        this.capacity = capacity;\n    }\n\n    public int get(int key) {\n        return super.getOrDefault(key, -1);\n    }\n\n    public void put(int key, int value) {\n        super.put(key, value);\n    }\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\n        return size() > capacity;\n        // é»˜è®¤åœ¨ LinkedHashMap é‡Œè¿”å›false\n    }\n}\n```\n\n#### Complexity\n\nTime complexity: O(1)  \nSpace complexity: O(n) \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196302672","body":"\n### Link\n\nhttps://leetcode.com/problems/maximum-depth-of-binary-tree/\n\n### Clarifications / Constraints\n\n1. root: depth =1\n2. root: null -> return 0\n\n### Idea\n\n1. DFS\n\n\n#### Code\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        return dfs(root, 1);\n    \n    }\n    public int dfs(TreeNode root, int depth) {\n        if (root == null) return depth-1;\n        int left = dfs(root.left, depth+1);\n        int right = dfs(root.right, depth+1);\n        return Math.max(left, right);\n    }\n}\n```\n\n#### Complexity\n\nTime complexity: O(n), traverse all nodes.  \nSpace complexity: O(height), recursion stack need height space. the worst is n, the best is logn. \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198334898","body":"\n### Link\n\nhttps://leetcode.com/problems/same-tree/\n\n### Clarifications / Constraints\n\n1. the number of nodes: >= 0\n\n### Idea_1\n\n1. Use recursion method;\n2. Judge the current pair of nodes:\n   1. if both equal to null: return true;\n   2. if one of them equals to null or the values are not equal: return false;\n   3. else continue to compare their subtrees;\n\n\n#### Code\n\n```java\n// Recursion: O(n), O(n)\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null || p.val != q.val) \n            return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n```\n\n#### Complexity\n\nTime complexity: O(n), we traverse all nodes to compare them;   \nSpace complexity: O(n): logn~n, recursion needs stack, the beset case is balanced tree: O(logn), the worst case is completely unbalanced tree: O(n);\n\n\n### Idea_2\n\n1. Use iteration method;\n2. Push the root node in the queues;\n3. While the queues are not empty:\n   1. poll the current nodes in both trees and compare:\n   2. if both equal to null: continue to compare the subtrees;\n   3. if one of them equals to null or the values are not equal: return false;\n   4. add their left and right nodes in the queues;\n\n\n#### Code\n\n```java\n// Iteration: O(n), O(n)\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        Queue<TreeNode> qp = new LinkedList<>();\n        Queue<TreeNode> qq = new LinkedList<>();\n        qp.offer(p);\n        qq.offer(q);\n        \n        while (!qp.isEmpty() || !qq.isEmpty()) {\n            TreeNode pNode = qp.poll();\n            TreeNode qNode = qq.poll();\n            if (pNode == null && qNode == null)\n                continue;\n            if (pNode == null || qNode == null || pNode.val != qNode.val)\n                return false;\n            qp.offer(pNode.left);\n            qq.offer(qNode.left);\n            qp.offer(pNode.right);\n            qq.offer(qNode.right);\n        }\n        return true;\n    }\n}\n```\n\n#### Complexity\n\nTime complexity: O(n), we traverse all nodes to compare them;     \nSpace complexity: O(n), the maximum number of nodes is n/2: leaves; \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199290813","body":"\n### Link\n\nhttps://leetcode.com/problems/sum-root-to-leaf-numbers/\n\n### Clarifications / Constraints\n\n1. the number of nodes\n2. the value of every node\n\n### Idea_1\n\n1. Use dfs and a global variable to calculate the sum;\n2. Calculate the value of every path using math;\n\n\n#### Code\n\n```java\nclass Solution {\n    int sum = 0;\n    public int sumNumbers(TreeNode root) {\n        dfs(root, 0);\n        return sum;\n    }\n    public void dfs(TreeNode n, int digit) {\n        if(root == null) return;\n        sum += digit*10 + root.val;\n        dfs(root.left, digit*10+root.val);\n        dfs(root.right, digit*10+root.val);\n    }\n}\n```\n\n#### Complexity\n\nTime complexity: O(n), we traverse every node;   \nSpace complexity: O(height), recursion stack need height space: logn for best case ~ n for worst case;\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200225986","body":"\n### Link\n\nhttps://leetcode.com/problems/find-bottom-left-tree-value/\n\n### Clarifications / Constraints\n\n1. the number of nodes > 0\n\n### Idea\n\n1. BFS\n\n\n#### Code\n\n```java\npublic int findLeftMostNode(TreeNode root) {\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.add(root);\n    while (!queue.isEmpty()) {\n        root = queue.poll();\n        if (root.right != null)\n            queue.add(root.right);\n        if (root.left != null)\n            queue.add(root.left);\n    }\n    return root.val;\n}\n```\n\n#### Complexity\n\nTime complexity: O(n).  \nSpace complexity: O(n)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201379895","body":"```java\nclass Solution { \n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        TreeMap<Integer, TreeMap<Integer,PriorityQueue<Integer> > > m = new TreeMap<>();\n        List<List<Integer>> res = new ArrayList<>();\n        dfs(root, 0, 0, m);\n\n        for (TreeMap<Integer, PriorityQueue<Integer>> ys : m.values()) {\n            res.add(new ArrayList<>());\n            for (PriorityQueue<Integer> nodes : ys.values()) {\n                while (!nodes.isEmpty()) \n                    res.get(res.size() - 1).add(nodes.poll());\n            }\n        }\n        return res;\n    }\n        \n    public void dfs(TreeNode root, int x, int y, TreeMap<Integer, TreeMap<Integer,PriorityQueue<Integer>>> m) {\n        if (root == null) return;\n        m.putIfAbsent(x,new TreeMap<>());\n        m.get(x).putIfAbsent(y,new PriorityQueue<>());\n        m.get(x).get(y).add(root.val);\n        dfs(root.left, x-1, y+1, m);\n        dfs(root.right, x+1, y+1, m);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202559165","body":"```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        \n        return null;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1204101835","body":"```java\nclass Solution {\n    public List<Integer> topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int num : nums) \n            map.put(num, map.getOrDefault(num, 0) + 1); \n        \n        Queue<Integer> heap = new PriorityQueue<>(\n            (a, b) -> map.get(b) - map.get(a)\n        );\n        for(int key : map.keySet()) \n            heap.add(key); \n        \n        List<Integer> res = new ArrayList<>();\n        for(int i = 0; i < k; i++)\n            res.add(heap.poll());\n        \n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205315168","body":"```java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int res = 0;\n\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i=0; i<points.length; i++) {\n            for(int j=0; j<points.length; j++) {\n                if(i == j)\n                    continue;\n\n                int d = getDistance(points[i], points[j]);                \n                map.put(d, map.getOrDefault(d, 0) + 1);\n            }\n\n            for(int val : map.values()) {\n                res += val * (val-1);\n            }            \n            map.clear();\n        }\n\n        return res;\n    }\n\n    private int getDistance(int[] a, int[] b) {\n        int dx = a[0] - b[0];\n        int dy = a[1] - b[1];\n\n        return dx*dx + dy*dy;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206612018","body":"```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        // å“ˆå¸Œé›†åˆï¼Œè®°å½•æ¯ä¸ªå­—ç¬¦æ˜¯å¦å‡ºç°è¿‡\n        Set<Character> occ = new HashSet<Character>();\n        int n = s.length();\n        // å³æŒ‡é’ˆï¼Œåˆå§‹å€¼ä¸º -1ï¼Œç›¸å½“äºæˆ‘ä»¬åœ¨å­—ç¬¦ä¸²çš„å·¦è¾¹ç•Œçš„å·¦ä¾§ï¼Œè¿˜æ²¡æœ‰å¼€å§‹ç§»åŠ¨\n        int rk = -1, ans = 0;\n        for (int i = 0; i < n; ++i) {\n            if (i != 0) {\n                // å·¦æŒ‡é’ˆå‘å³ç§»åŠ¨ä¸€æ ¼ï¼Œç§»é™¤ä¸€ä¸ªå­—ç¬¦\n                occ.remove(s.charAt(i - 1));\n            }\n            while (rk + 1 < n && !occ.contains(s.charAt(rk + 1))) {\n                // ä¸æ–­åœ°ç§»åŠ¨å³æŒ‡é’ˆ\n                occ.add(s.charAt(rk + 1));\n                ++rk;\n            }\n            // ç¬¬ i åˆ° rk ä¸ªå­—ç¬¦æ˜¯ä¸€ä¸ªæé•¿çš„æ— é‡å¤å­—ç¬¦å­ä¸²\n            ans = Math.max(ans, rk - i + 1);\n        }\n        return ans;\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207217384","body":"```java\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        final Map<String, Integer> counts = new HashMap<>();\n        for (final String word : words) {\n            counts.put(word, counts.getOrDefault(word, 0) + 1);\n        }\n        final List<Integer> indexes = new ArrayList<>();\n        final int n = s.length(), num = words.length, len = words[0].length();\n        for (int i = 0; i < n - num * len + 1; i++) {\n            final Map<String, Integer> seen = new HashMap<>();\n            int j = 0;\n            while (j < num) {\n                final String word = s.substring(i + j * len, i + (j + 1) * len);\n                if (counts.containsKey(word)) {\n                    seen.put(word, seen.getOrDefault(word, 0) + 1);\n                    if (seen.get(word) > counts.getOrDefault(word, 0)) {\n                        break;\n                    }\n                } else {\n                    break;\n                }\n                j++;\n            }\n            if (j == num) {\n                indexes.add(i);\n            }\n        }\n        return indexes;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207430764","body":"```java\nclass Solution {\n    public int solve(int[] nums, int k) {\n        int total = 0;\n        for (int n : nums)\n            total += n;\n        total = Math.floorMod(total, k);\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, -1);\n        int prefix = 0, res = nums.length;\n        for (int i = 0; i < nums.length; i++) {\n            prefix += nums[i];\n            int mod = Math.floorMod(prefix, k);\n            map.put(mod, i);\n            if (map.containsKey(Math.floorMod(prefix - total, k)))\n                res = Math.min(res, i - map.get(Math.floorMod(prefix - total, k)));\n        }\n        return res == nums.length ? -1 : res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208213525","body":"```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209381347","body":"```java\n// O(n), O(1)\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        if (nums.length == 0) return 0;\n        int i = 0;\n        for (int j = i+1; j < nums.length; j++) {\n            if (nums[j] == nums[i]) continue;\n            else nums[++i] = nums[j];\n        }\n        return i + 1;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pgquestions":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185484818","body":"## æ€è·¯\r\n\r\n1ã€åˆ›å»ºä¸€ä¸ªé“¾è¡¨æ•°ç»„ç”¨æ¥å­˜æ”¾ç»“æœ  \r\n2ã€æŠŠæ•°ç»„å’Œæ•°å­—ç›¸åŒä½æ•°çš„å€¼è¿›è¡Œç›¸åŠ ã€‚ç›´åˆ°å…¨éƒ¨è®¡ç®—å®Œ  \r\n3ã€æ¯æ¬¡è®¡ç®—å®Œçš„æ•°å­—æ·»åŠ åœ¨æ•°ç»„å¤´éƒ¨  \r\n\r\n\r\n\r\n## ä»£ç \r\n\r\n- è¯­è¨€æ”¯æŒï¼šJava\r\n\r\nJava Code:\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> arr = new LinkedList<>();\r\n        int index = num.length - 1;\r\n        int temp = 0;\r\n        while (index >= 0 || k > 0 || temp > 0) {\r\n            int temp_data = k % 10 + temp;\r\n            k = k / 10;\r\n            if (index >= 0) {\r\n                temp_data += num[index];\r\n                index--;\r\n            }\r\n            arr.addFirst(temp_data % 10);\r\n            temp = temp_data / 10;\r\n        }\r\n        return arr;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n\r\nä»¤ n ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185682411","body":"## æ€è·¯\r\n\r\nå…ˆä»å·¦å¾€å³è¿›è¡Œéå†ã€‚  \r\nç„¶åä»å³å¾€å·¦éå†ï¼Œè®°å½•æœ€å°çš„å€¼\r\n\r\n\r\n\r\n## ä»£ç \r\n\r\n- è¯­è¨€æ”¯æŒï¼šJava\r\n\r\nJava Code:\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] res = new int[n];\r\n        // ä»å·¦å¾€å³éå†\r\n        for (int i = 0, index = -n; i < n; i++) {\r\n            if (s.charAt(i) == c) {\r\n                index = i;\r\n            }\r\n            res[i] = i - index;\r\n\r\n        }\r\n        \r\n        // ä»å³å¾€å·¦éå†\r\n        for (int i = n - 1, index = 2 * n; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                index = i;\r\n            }\r\n            res[i] = Math.min(res[i], index - i);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n\r\nä»¤ n ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186532017","body":"\r\n## æ€è·¯\r\n\r\né€šè¿‡æ ¹æ®æ•°ç»„å®ç°æ ˆçš„æ€è·¯\r\n\r\n\r\n\r\n## ä»£ç \r\n\r\n- è¯­è¨€æ”¯æŒï¼šJava\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass CustomStack {\r\n    private int[] arr;\r\n    private int index = -1;\r\n    private int limit = 0;\r\n\r\n    public CustomStack(int maxSize) {\r\n        arr = new int[maxSize];\r\n        limit = maxSize - 1;\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (index == limit){\r\n            return;\r\n        }\r\n        index++;\r\n        arr[index] = x;\r\n    }\r\n\r\n    public int pop() {\r\n        if (index == -1){\r\n            return -1;\r\n        }\r\n        int ans = arr[index];\r\n        index--;\r\n        return ans;\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int min = Math.min(k, index+1);\r\n        for (int i = 0; i < min; i++) {\r\n            arr[i] = arr[i] + val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n\r\n```\r\n\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n\r\nä»¤ n ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(1)$\r\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187309867","body":"## å‰ç½®çŸ¥è¯†\r\n\r\n- æ ˆ\r\n\r\n\r\n\r\n## æ€è·¯\r\n\r\nä¸€ä¸ªæ ˆç”¨æ¥å­˜æ”¾æ•°å­—  \r\nä¸€ä¸ªæ ˆç”¨æ¥å­˜æ”¾å­—ç¬¦ä¸²\r\n\r\n-  \r\n\r\n## ä»£ç \r\n\r\n- è¯­è¨€æ”¯æŒï¼šJava\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        StringBuilder str = new StringBuilder();\r\n        Stack<Integer> num = new Stack<>();\r\n        Stack<StringBuilder> str_sta = new Stack<>();\r\n        int k = 0;\r\n        for (char c : s.toCharArray()) {\r\n            if (Character.isDigit(c)) {\r\n                k = k * 10 + (c - '0');\r\n            } else if (c == '[') {\r\n                num.push(k);\r\n                k = 0;\r\n                str_sta.push(str);\r\n                str = new StringBuilder();\r\n            } else if (c == ']') {\r\n                StringBuilder temp = str_sta.pop();\r\n                for (int i = num.pop(); i > 0; i--) {\r\n                    temp.append(str);\r\n                }\r\n                str = temp;\r\n            } else {\r\n                str.append(c);\r\n            }\r\n\r\n        }\r\n        return str.toString();\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n\r\nä»¤ n ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(kn)\r\n- ç©ºé—´å¤æ‚åº¦ï¼š O(num(k) + num(char))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188935888","body":"\r\n## æ€è·¯\r\nä¸€ä¸ªæ ˆstackpushï¼Œä¸€ä¸ªæ ˆstackpopã€‚åªæœ‰å½“stackpopä¸ºç©ºæ—¶ï¼Œå¯ä»¥æŠŠstackpushé‡Œé¢çš„æ•°å­—è¿›å…¥åˆ°stackpopæ ˆ ï¼Œå¹¶ä¸”éœ€è¦ä¸€æ¬¡æ€§å…¨éƒ¨å…¥æ ˆ\r\nstackpopç”¨äºå‡ºæ ˆ  \r\nstackpushç”¨äºè¿›æ ˆ  \r\n\r\n\r\n## ä»£ç \r\n\r\n- è¯­è¨€æ”¯æŒï¼šJava\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass MyQueue {\r\n    private Stack<Integer> stackpush;\r\n    private Stack<Integer> stackpop;\r\n\r\n    public MyQueue() {\r\n        stackpush = new Stack<>();\r\n        stackpop = new Stack<>();\r\n    }\r\n\r\n    public void push(int x) {\r\n        stackpush.push(x);\r\n    }\r\n\r\n    public int pop() {\r\n        if (!stackpop.isEmpty()) {\r\n            return stackpop.pop();\r\n        }\r\n        while (!stackpush.isEmpty()) {\r\n            stackpop.push(stackpush.pop());\r\n        }\r\n        return stackpop.pop();\r\n    }\r\n\r\n    public int peek() {\r\n        if (!stackpop.isEmpty()) {\r\n            return stackpop.peek();\r\n        }\r\n        while (!stackpush.isEmpty()) {\r\n            stackpop.push(stackpush.pop());\r\n        }\r\n        return stackpop.peek();\r\n    }\r\n\r\n    public boolean empty() {\r\n        return stackpush.isEmpty() && stackpop.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n\r\n\r\n```\r\n\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n\r\nä»¤ n ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190317364","body":"\r\n## æ€è·¯\r\n1ã€åªè¦æ•°ç»„çš„æ•°æ¯”æ ˆé¡¶å¤§ï¼Œåˆ™å…¥æ ˆ\r\n2ã€æ•°ç»„çš„æ•°æ¯”æ ˆé¡¶å°ï¼Œåˆ™å‡ºæ ˆï¼ŒåŒæ—¶ç»§ç»­æ¯”è¾ƒæ•°ç»„ä¸æ ˆé¡¶ã€‚ä¾æ¬¡ç»§ç»­\r\n3ã€æ ˆçš„å¤§å°å°±æ˜¯æœ€å¤šçš„å—æ•°\r\n\r\n\r\n## ä»£ç \r\n\r\n- è¯­è¨€æ”¯æŒï¼šJava\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        stack.push(arr[0]);\r\n        for (int i = 1; i < arr.length;i++) {\r\n            if (!stack.isEmpty() && arr[i] >= stack.peek()){\r\n                stack.push(arr[i]);\r\n            }else {\r\n                int curMax = stack.pop();\r\n                while (!stack.isEmpty() && stack.peek() > arr[i]) {\r\n                    stack.pop();\r\n                }\r\n                stack.push(curMax);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n\r\nä»¤ n ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191407764","body":"\r\n## æ€è·¯\r\n1ã€å…ˆç»Ÿè®¡é“¾è¡¨çš„é•¿åº¦  \r\n2ã€è®¡ç®—å®é™…éœ€è¦ç§»åŠ¨çš„æ¬¡æ•°  \r\n3ã€ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆè¿›è¡Œç§»åŠ¨  \r\næ…¢æŒ‡é’ˆä¸ºå¤´ï¼Œå¿«æŒ‡é’ˆçš„nextè¿æ¥åˆ°åŸå…ˆçš„å¤´ï¼Œç„¶åå†æŠŠæ…¢æŒ‡é’ˆçš„nextæŒ‡å‘nullã€‚  \r\n\r\n\r\n## ä»£ç \r\n\r\n- è¯­è¨€æ”¯æŒï¼šJava\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null || head.next == null) return head;\r\n        int count = 0;\r\n        ListNode now = head;\r\n\r\n        // ç»Ÿè®¡é“¾è¡¨é•¿åº¦\r\n        while (now != null) {\r\n            now = now.next;\r\n            count++;\r\n        }\r\n        // è®¡ç®—å®é™…éœ€è¦ç§»åŠ¨çš„æ¬¡æ•°\r\n        k = k % count;\r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n        // ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆè¿›è¡Œå®ç°\r\n        while (fast.next != null) {\r\n            if (k-- <= 0) {\r\n                slow = slow.next;\r\n            }\r\n            fast = fast.next;\r\n        }\r\n        fast.next = head;\r\n        ListNode res = slow.next;\r\n        slow.next = null;\r\n        return res;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n\r\nä»¤ n ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192504553","body":"\r\n\r\n## æ€è·¯\r\n\r\nç”±äºæ‰€æœ‰çš„ä¸¤ä¸¤äº¤æ¢é€»è¾‘éƒ½æ˜¯ä¸€æ ·çš„ï¼Œå› æ­¤æˆ‘ä»¬åªè¦å…³æ³¨æŸä¸€ä¸ªä¸¤ä¸¤äº¤æ¢å¦‚ä½•å®ç°å°±å¯ä»¥äº†ã€‚\r\n\r\nå› ä¸ºè¦ä¿®æ”¹çš„æ˜¯äºŒä¸ªä¸€ç»„çš„é“¾è¡¨èŠ‚ç‚¹ï¼Œæ‰€ä»¥éœ€è¦æ“ä½œ 4 ä¸ªèŠ‚ç‚¹ã€‚ä¾‹å¦‚ï¼šå°†é“¾è¡¨ A -> B è¿›è¡Œé€†è½¬ï¼Œæˆ‘ä»¬éœ€è¦å¾—åˆ° A,B ä»¥åŠ A çš„å‰ç½®èŠ‚ç‚¹ preA,ä»¥åŠ B çš„åç½®èŠ‚ç‚¹ nextB\r\n\r\nåŸå§‹é“¾è¡¨ä¸º preA -> A -> B -> nextBï¼Œæˆ‘ä»¬éœ€è¦æ”¹ä¸º preA -> B -> A -> nextBï¼Œæ¥ä¸‹æ¥ç”¨åŒæ ·çš„é€»è¾‘äº¤æ¢ nextB ä»¥åŠ nextB çš„ä¸‹ä¸€ä¸ªå…ƒç´ ã€‚\r\n\r\n-  \r\n\r\n## ä»£ç \r\n\r\n- è¯­è¨€æ”¯æŒï¼šJava\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if (head == null || head.next == null) return head;\r\n        ListNode preNode = new ListNode(-1, head);\r\n        ListNode res;\r\n        preNode.next = head;\r\n        res = head.next;\r\n        ListNode firstNode = head;\r\n        ListNode secondNode;\r\n        ListNode nextNode;\r\n        while (firstNode != null && firstNode.next != null) {\r\n            secondNode = firstNode.next;\r\n            nextNode = secondNode.next;\r\n            firstNode.next = nextNode;\r\n            secondNode.next = firstNode;\r\n            preNode.next = secondNode;\r\n            preNode = firstNode;\r\n            firstNode = nextNode;\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n\r\nä»¤ n ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193114962","body":"## æ€è·¯\r\nå› ä¸ºæœ¬é¢˜æ˜¯å‡åºçš„é“¾è¡¨ï¼Œæ‰€ä»¥å…ˆæ‰¾åˆ°ä¸­é—´èŠ‚ç‚¹ä½œä¸ºäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚  \r\næ ¹èŠ‚ç‚¹å·¦è¾¹çš„æ•°éƒ½å°äºæ ¹èŠ‚ç‚¹  \r\næ ¹èŠ‚ç‚¹å³è¾¹çš„æ•°éƒ½å¤§äºæ ¹èŠ‚ç‚¹\r\nå¾ªç¯ä»¥ä¸Šæ­¥éª¤\r\n\r\n\r\n\r\n## ä»£ç \r\n\r\n- è¯­è¨€æ”¯æŒï¼šJava\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        // å¦‚æœé“¾è¡¨ä¸ºç©ºï¼Œåˆ™ç›´æ¥è¿”å›null\r\n        if (head == null) return null;\r\n        return dfs(head, null);\r\n    }\r\n\r\n    public TreeNode dfs(ListNode head, ListNode tail) {\r\n        if (head == tail) return null;\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        // å¿«æ…¢æŒ‡é’ˆï¼Œå¿«æŒ‡é’ˆèµ°ä¸¤æ­¥ï¼Œæ…¢æŒ‡é’ˆèµ°ä¸€æ­¥,\r\n        while (fast != tail && fast.next != tail) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        // æ­¤æ—¶æ…¢æŒ‡é’ˆåˆšå¥½èµ°åœ¨é“¾è¡¨çš„ä¸­ç‚¹\r\n        TreeNode root = new TreeNode(slow.val);\r\n        // æ¯”çˆ¶èŠ‚ç‚¹å°çš„åœ¨å·¦è¾¹\r\n        root.left = dfs(head, slow);\r\n        // æ¯”çˆ¶èŠ‚ç‚¹å¤§çš„åœ¨å³è¾¹\r\n        root.right = dfs(slow.next, tail);\r\n        return root;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n\r\nä»¤ n ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(logn)$\r\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(logn)$\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193320802","body":"\r\n## æ€è·¯\r\n\r\næˆ‘ä»¬å¯ä»¥è®© p1 éå†å®Œé“¾è¡¨ A ä¹‹åå¼€å§‹éå†é“¾è¡¨ Bï¼Œè®© p2 éå†å®Œé“¾è¡¨ B ä¹‹åå¼€å§‹éå†é“¾è¡¨ Aï¼Œè¿™æ ·ç›¸å½“äºã€Œé€»è¾‘ä¸Šã€ä¸¤æ¡é“¾è¡¨æ¥åœ¨äº†ä¸€èµ·ã€‚\r\n\r\nå¦‚æœè¿™æ ·è¿›è¡Œæ‹¼æ¥ï¼Œå°±å¯ä»¥è®© p1 å’Œ p2 åŒæ—¶è¿›å…¥å…¬å…±éƒ¨åˆ†ï¼Œä¹Ÿå°±æ˜¯åŒæ—¶åˆ°è¾¾ç›¸äº¤èŠ‚ç‚¹ c1ï¼š\r\n\r\n-  \r\n\r\n## ä»£ç \r\n\r\n- è¯­è¨€æ”¯æŒï¼šJava\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode p1 = headA;\r\n        ListNode p2 = headB;\r\n        // å¦‚æœP1å’ŒP2ä¸æƒ³äº¤çš„è¯ï¼Œåˆ°æ—¶P1=null.p2=nullã€‚æ­¤æ—¶é€€å‡ºå¾ªç¯ã€‚\r\n        while (p1 != p2) {\r\n            // p1 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° A é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° B é“¾è¡¨\r\n            if (p1 == null) {\r\n                p1 = headB;\r\n            } else {\r\n                p1 = p1.next;\r\n            }\r\n            // p2 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° B é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° A é“¾è¡¨\r\n            if (p2 == null) {\r\n                p2 = headA;\r\n            } else {\r\n                p2 = p2.next;\r\n            }\r\n        }\r\n        return p1;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n\r\nä»¤ n ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194002665","body":"\r\n\r\n## æ€è·¯\r\n\r\nä½¿ç”¨å¿«æ…¢æŒ‡é’ˆï¼Œå¿«æŒ‡é’ˆèµ°ä¸¤æ­¥ï¼Œæ…¢æŒ‡é’ˆèµ°ä¸€æ­¥ã€‚ç¬¬ä¸€æ¬¡å¦‚æœæ²¡æœ‰ç›¸é‡çš„è¯ï¼Œè¯´æ˜è¿™ä¸ªé“¾è¡¨æ˜¯æ— ç¯é“¾è¡¨ã€‚  \r\nä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘headèŠ‚ç‚¹ï¼Œä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘ç›¸é‡çš„èŠ‚ç‚¹ï¼Œç„¶åä¸€ç›´èµ°ï¼Œç›´åˆ°ä¸¤è€…ç›¸é‡åˆ™æ˜¯å…¥ç¯çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹\r\n\r\n-  \r\n\r\n## ä»£ç \r\n\r\n- è¯­è¨€æ”¯æŒï¼šJava\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if (head == null || head.next == null || head.next.next == null) {\r\n            return null;\r\n        }\r\n        ListNode slow = head.next;\r\n        ListNode fast = head.next.next;\r\n        while (slow != fast) {\r\n            if (fast.next == null || fast.next.next == null) {\r\n                return null;\r\n            }\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        fast = head;\r\n        while (fast != slow) {\r\n            slow = slow.next;\r\n            fast = fast.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n\r\nä»¤ n ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195447536","body":"\r\n## æ€è·¯\r\nåŒæŒ‡é’ˆ+å“ˆå¸Œè¡¨\r\n\r\n\r\n\r\n## ä»£ç \r\n\r\n- è¯­è¨€æ”¯æŒï¼šJava\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass LRUCache {\r\n    class DLinkedNode {\r\n        int key, value;\r\n        DLinkedNode prev, next;\r\n\r\n        public DLinkedNode() {\r\n\r\n        }\r\n\r\n        public DLinkedNode(int _key, int _value) {\r\n            key = _key;\r\n            value = _value;\r\n        }\r\n    }\r\n\r\n\r\n    private Map<Integer, DLinkedNode> cache = new HashMap<>();\r\n    private int size, cap;\r\n    private DLinkedNode head, tail;\r\n\r\n    public LRUCache(int capacity) {\r\n        size = 0;\r\n        cap = capacity;\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head.next = tail;\r\n        tail.prev = head;\r\n    }\r\n\r\n    public int get(int key) {\r\n        DLinkedNode node = cache.get(key);\r\n        if (node == null) return -1;\r\n        moveToHead(node);\r\n        return node.value;\r\n\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        DLinkedNode node = cache.get(key);\r\n        if (node == null) {\r\n            DLinkedNode newNode = new DLinkedNode(key, value);\r\n            cache.put(key, newNode);\r\n            addToHead(newNode);\r\n            ++size;\r\n            if (size > cap) {\r\n                DLinkedNode removeTail = removeTail();\r\n                cache.remove(removeTail.key);\r\n                size--;\r\n            }\r\n        } else {\r\n            node.value = value;\r\n            moveToHead(node);\r\n        }\r\n    }\r\n\r\n\r\n    private void addToHead(DLinkedNode node) {\r\n        node.prev = head;\r\n        node.next = head.next;\r\n        head.next.prev = node;\r\n        head.next = node;\r\n    }\r\n\r\n    private void removeNode(DLinkedNode node) {\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n    }\r\n\r\n    private void moveToHead(DLinkedNode node) {\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n\r\n    private DLinkedNode removeTail() {\r\n        DLinkedNode res = tail.prev;\r\n        removeNode(res);\r\n        return res;\r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n\r\n```\r\n\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n\r\nä»¤ n ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196682539","body":"## æ€è·¯\r\nåˆ©ç”¨äºŒå‰æ ‘çš„å±‚æ¬¡éå†ã€‚æ¯éå†å®Œä¸€æ¬¡è®°ä¸€æ¬¡ã€‚ç´¯è®¡æ€»å’Œå°±æ˜¯æ·±åº¦ã€‚\r\n\r\n\r\n-  \r\n\r\n## ä»£ç \r\n\r\n- è¯­è¨€æ”¯æŒï¼šJava\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\r\n        if (root == null) return 0;\r\n        int depth = 0;\r\n        queue.offer(root);\r\n        while (!queue.isEmpty()){\r\n            depth++;\r\n            int len = queue.size();\r\n            for (int i = 0;i < len; i++){\r\n                TreeNode node = queue.poll();\r\n                if (node.left != null) queue.offer(node.left);\r\n                if (node.right != null) queue.offer(node.right);\r\n            }\r\n        }\r\n        return depth;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n\r\nä»¤ n ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(logn)$\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198042500","body":"\r\n## æ€è·¯\r\nè¿›è¡Œéå†ï¼Œåªè¦é‡åˆ°ä¸€ä¸ªä¸ä¸€è‡´çš„åˆ™è¿”å›false\r\n\r\n-  \r\n\r\n## ä»£ç \r\n\r\n- è¯­è¨€æ”¯æŒï¼šJava\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null && q == null) {\r\n            return true;\r\n        } else if (p == null || q == null) {\r\n            return false;\r\n        } else if (p.val != q.val) {\r\n            return false;\r\n        } else {\r\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n\r\nä»¤ n ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(logn)$\r\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eldinzhou":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185485651","body":"```go\nfunc addToArrayForm(num []int, k int) (ans []int) {\n    for i := len(num) - 1; i >= 0; i-- {\n        sum := num[i] + k%10\n        k /= 10\n        if sum >= 10 {\n            k++\n            sum -= 10\n        }\n        ans = append(ans, sum)\n    }\n    for ; k > 0; k /= 10 {\n        ans = append(ans, k%10)\n    }\n    reverse(ans)\n    return\n}\n\nfunc reverse(num []int) {\n    for i, n := 0, len(num); i < n/2; i++ {\n        num[i], num[n-1-i] = num[n-1-i], num[i]\n    }\n}","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190278600","body":"```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: [int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]: \r\n                head = stack.pop()\r\n                while stack and num < stack[-1]: stack.pop()\r\n                stack.append(head)\r\n            else: stack.append(num)\r\n        return len(stack)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiangwenzhe":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185496245","body":"### æ€è·¯\n\næœ¬æ¥ä¸€å¼€å§‹æƒ³ç›´æ¥ä½¿ç”¨ JavaScript çš„ api çš„ï¼š\n1. è®¡ç®— sum æ•°ç»„çš„å€¼\n2. æŠŠå€¼å’Œ k ç›¸åŠ \n3. æŠŠå€¼é€šè¿‡ `String(number).split('').map(n => Number(n))` è½¬æ¢å›æ•°ç»„\n\nå‡ºç°çš„é—®é¢˜æ˜¯ `IEEE754` ç¼–ç çš„æ•°å­—ä¼šå‡ºç°ç²¾åº¦ä¸¢å¤±çš„é—®é¢˜\n\næ‰€ä»¥è¿˜æ˜¯è€è€å®å®çš„ä½¿ç”¨é€ä½ç›¸åŠ çš„æ–¹æ³•\n\n1. æŠŠæ•°ç»„ä¸­çš„ä½ç½®ä»é«˜åˆ°åº•ç›¸åŠ \n2. å¦‚æœç»“æœå¤§äº 10 çš„è¯ï¼ŒæŠŠè¿›ä½ 1 åŠ å…¥ä¸‹ä¸€ä½çš„è®¡ç®—\n\n### ä»£ç \n\n```js\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (let k; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```\n\n### å¤æ‚åº¦åˆ†æ\n\n* æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n* ç©ºé—´å¤æ‚åº¦ï¼šO(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186141162","body":"### æ€è·¯\n\n* æŠŠ c åœ¨ s å­—ç¬¦ä¸²çš„ä½ç½®æ”¾åœ¨ä¸€ä¸ªæ–°å¼€è¾Ÿçš„æ•°ç»„é‡Œ\n* éå† s å­—ç¬¦ä¸²ï¼ŒæŠŠç»“æŸè¾“å…¥åˆ°æ•°ç»„ä¸­\n\n### ä»£ç \n\n```js\nvar shortestToChar = function(s, c) {\n  const sArr = s.split('');\n  const cIndexArr = [];\n  sArr.forEach((i, index) => {\n    if (i === c) {\n      cIndexArr.push(index);\n    }\n  });\n  const res = Array(s.length).fill(Infinity);\n  sArr.forEach((i, index) => {\n    if (i === c) {\n      res[index] = 0;\n      return;\n    }\n    for (const cIndex of cIndexArr) {\n      const dis = Math.abs(cIndex - index);\n      if (dis >= res[index]) {\n        break;\n      }\n      res[index] = dis;\n    }\n  });\n  return res;\n};\n```\n\n### å¤æ‚åº¦\n\n* æ—¶é—´å¤æ‚åº¦ O(N^2)\n* ç©ºé—´å¤æ‚åº¦ O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186441685","body":"### æ€è·¯\n\n- ä½¿ç”¨æ•°ç»„æ¨¡æ‹Ÿ stack\n\n### ä»£ç \n\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.stack = [];\n  this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.stack.length <= this.maxSize - 1) {\n    this.stack.unshift(x);\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  if (this.stack.length === 0) {\n    return -1;\n  }\n  const elemrnt = this.stack.shift();\n  return elemrnt;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  const stackLength = this.stack.length;\n  if (stackLength === 0) {\n    return [];\n  }\n this.stack = this.stack.map((i, index) => {\n    if (stackLength - index <= k ) {\n      return i + val;\n    }\n   return i;\n });\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n### å¤æ‚åº¦\n\n- Timeï¼šO(N)\n- Spaceï¼šO(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187630436","body":"var decodeString = function(s) {\n    let numStack = [];          \n    let strStack = [];            \n    let num = 0, result = '';\n\n    for(let i = 0; i < s.length; i++) {\n        const item = s[i];\n\n        if(!isNaN(item)) {              // åˆ¤æ–­æ˜¯æ•°å­—æ—¶\n            num = num * 10 + parseInt(item);\n        } else if(item === '[') {\n            strStack.push(result);\n            result = '';\n            numStack.push(num);\n            num = 0;\n        } else if(item === ']') {\n            const repeatTimes = numStack.pop();         // ä»æ ˆä¸­è·å–æ¬¡æ•°\n            result = strStack.pop() + result.repeat(repeatTimes);\n        } else {\n            result += item;\n        }\n    }\n    return result;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189196478","body":"\tvar MyQueue = function () {\n\t  this.stack1 = [];\n\t  this.stack2 = [];\n\t};\n\t\n\tMyQueue.prototype.push = function (x) {\n\t  this.stack1.push(x);\n\t};\n\t\n\tMyQueue.prototype.pop = function () {\n\t  if (this.stack2.length > 0) {\n\t    return this.stack2.pop();\n\t  }\n\t\n\t  while (this.stack1.length > 0) {\n\t    this.stack2.push(this.stack1.pop());\n\t  }\n\t\n\t  return this.stack2.pop();\n\t};\n\t\n\tMyQueue.prototype.peek = function () {\n\t  let tmp = this.pop();\n\t  this.stack2.push(tmp);\n\t  return tmp;\n\t};\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192712314","body":"\nvar swapPairs = function(head) {\n    if (head === null|| head.next === null) {\n        return head;\n    }\n    const newHead = head.next;\n    head.next = swapPairs(newHead.next);\n    newHead.next = head;\n    return newHead;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193142307","body":"```js\r\nvar sortedListToBST = function(head) {\r\n    if (head === null) return null;\r\n    return help([head], 0, countSize(head)-1);\r\n};\r\n\r\nfunction countSize(head) {\r\n    let count = 0;\r\n    while (head !== null) {\r\n        count++;\r\n        head = head.next;\r\n    }\r\n    return count;\r\n}\r\n\r\nfunction help(arr, left, right) {\r\n    if (left > right) return null;\r\n    let mid = Math.floor((left + right) / 2);\r\n    let leftNode = help(arr, left, mid-1);\r\n    let node = new TreeNode(arr[0].val);\r\n    arr[0] = arr[0].next;\r\n    let rightNode = help(arr, mid+1, right);\r\n    node.left = leftNode;\r\n    node.right = rightNode;\r\n    return node;\r\n}\r\n\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194172361","body":"## é¢˜è§£\n```js\nvar detectCycle = function(head) {\n    const visited = new Set();\n    while (head !== null) {\n        if (visited.has(head)) {\n            return head;\n        }\n        visited.add(head);\n        head = head.next;\n    }\n    return null;\n};\n```\n\n## å¤æ‚åº¦\n* æ—¶é—´å¤æ‚åº¦: O(N)\n* ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200382208","body":"```js\n\nfunction serialize(root) {\n    const res = [];\n    const stack = [root];\n    while (stack.length) {\n        const n = stack.pop();\n        if (n == null) {\n            res.push('#');\n            continue;\n        } else {\n            res.push(n.val);\n            stack.push(n.left);\n            stack.push(n.right);\n        } \n    }\n    return res.reverse().toString();\n};\n\nfunction deserialize(data) {\n    const list = data.split(',');\n    const buildTree = (list) => {\n        const last = list.pop(); \n        if (last == \"#\") { \n            return null;\n        }\n        const root = new TreeNode(last);\n        root.right = buildTree(list);\n        root.left = buildTree(list);\n        return root;\n    }\n    return buildTree(list);\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205508024","body":"```js\r\nvar lengthOfLongestSubstring = function(s) {\r\n    const occ = new Set();\r\n    const n = s.length;\r\n    let rk = -1\r\n    let ans = 0;\r\n    for (let i = 0; i < n; ++i) {\r\n        if (i != 0) {\r\n            occ.delete(s.charAt(i - 1));\r\n        }\r\n        while (rk + 1 < n && !occ.has(s.charAt(rk + 1))) {\r\n            occ.add(s.charAt(rk + 1));\r\n            rk+=1;\r\n        }\r\n        ans = Math.max(ans, rk - i + 1);\r\n    }\r\n    return ans;\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnwu6688":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185508439","body":"# 989.Add to Array-Form of Integer\n\n**æ€è·¯:**\n\nè‡ªå·±æƒ³çš„æ€è·¯å’Œleetcodeä¸Šé«˜èµç­”æ¡ˆå·®ä¸å¤šï¼Œä½†æ˜¯å®ç°èµ·æ¥ï¼Œå‘ç°ä»–çš„æ›´ä¼˜é›…ï¼Œæœæ–­ä½¿ç”¨ä»–çš„å®ç°æ€è·¯ã€‚ä¼˜é›…ï¼ŒçœŸçš„å¤ªä¼˜é›…äº†ï¼ï¼ï¼\n1. ä¸è¦ç”¨forå¾ªç¯ï¼Œå› ä¸ºä½ ä¸çŸ¥é“num,ké‚£ä¸ªé•¿åº¦æ›´é•¿ï¼Œå¦‚æœä¸€å¼€å§‹å°†kè½¬ä¸ºæ•°ç»„æ¥æ¯”è¾ƒé•¿åº¦å°±å¤ªä¸ä¼˜é›…äº†ï¼ï¼ï¼æ‰€ä»¥ç”¨while()\n2. ç”¨LinkedListä¸è¦ç”¨ArrayListå› ä¸ºåº•å±‚ä¸ºé“¾è¡¨å®ç°çš„LinkedListå¯ä»¥å¤´æ’\n3. æ•°ç»„çš„æ¯ä¸€ä½éƒ½ä¸Kæ•´ä½“ç›¸åŠ ï¼Œé™¤10å°±æ˜¯Kçš„æœ€æ–°å€¼å‚ä¸ä¸‹ä¸€æ¬¡éå†ï¼Œä¸ç”¨è€ƒè™‘è¿›ä½é—®é¢˜\n4. æŠŠæ•°ç»„ç›¸åŠ çš„é—®é¢˜è½¬åŒ–ä¸ºå¯¹æœ€æ–°å€¼å¤„ç†é—®é¢˜ï¼Œä¸ç”¨è€ƒè™‘é•¿åº¦å’Œä½æ•°\n\n```java\npublic class AddToArrayFormOfInteger {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int len = num.length;\n        int lastNum = k;\n        int i = len - 1;\n        LinkedList<Integer> result = new LinkedList<>();\n        while (i >= 0 || lastNum > 0) {\n            if (i >= 0)\n                lastNum += num[i];\n            //å–æ¨¡åŠ å…¥åˆ°æ•°ç»„\n            result.addFirst(lastNum % 10);\n            //æ›´æ–°æœ€æ–°å€¼\n            lastNum /= 10;\n            i--;\n        }\n        return result;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186078726","body":"# 821. Shortest Distance to a Character\n\n**æ€è·¯ï¼š**\næœ€æ— è„‘çš„æ€è·¯\n1. è®°å½•cçš„ä¸‹æ ‡å­˜å…¥æ•°ç»„\n2. éå†ç›¸å‡å–æœ€å°ç»å¯¹å€¼\n\n```java\npublic int[] shortestToChar(String s, char c) {\n        char[] chars = s.toCharArray();\n        ArrayList<Integer> index = new ArrayList<>();\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] == c){\n                index.add(i);\n            }\n\n        }\n        int[] ret = new int[chars.length];\n        int minAbs = 0;\n        for (int i = 0; i < chars.length; i++) {\n            for (int j = 0; j < index.size(); j++) {\n                if (j ==0){\n                    //å†æ¬¡åˆå§‹åŒ–\n                    minAbs = Math.abs(index.get(j) - i);\n                    continue;\n                }\n                minAbs = Math.min(Math.abs(index.get(j) - i), minAbs);\n\n            }\n            ret[i] = minAbs;\n\n        }\n        return ret;\n\n    }\n```\n>æ—¶é—´å¤æ‚åº¦ï¼š O(n^2)\n> \n>ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186499905","body":"# 1381. Design a Stack With Increment Operation\n\n**æ€è·¯ï¼š**\n1. ç”¨æ•°ç»„æ¥å­˜å‚¨æ•°æ®\n2. ç”¨æŒ‡é’ˆæ¨¡æ‹Ÿæ ˆçš„æ“ä½œ\n```java\npublic class CustomStack {\n\n    int[] stack;\n    int index;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        index = 0;\n    }\n\n    public void push(int x) {\n        if(index < stack.length){\n            stack[index]=x;\n            index ++;\n        }\n    }\n\n    public int pop() {\n        int ret = index - 1 <0? -1:stack[index - 1];\n        if (ret != -1){\n            index --;\n        }\n        return ret;\n    }\n\n    public void increment(int k, int val) {\n        k = Math.min(k, index);\n        for (int i = 0; i < k; i++) {\n            stack[i] += val;\n        }\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        for (int i = 0; i < index; i++) {\n            if (i == index -1){\n                sb.append(stack[i]);\n            }else {\n                sb.append(stack[i]+\",\");\n            }\n\n\n        }\n        sb.append(\"]\");\n        return sb.toString();\n        //return Arrays.toString(stack);\n    }\n}\n```\n>æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n>ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187301558","body":"# 394. Decode String\n**æ€è·¯:**\n1. æ ˆæ‹¬å·åŒ¹é…å¤„ç†å°è§„æ¨¡äº‹ä»¶\n2. é€’å½’è°ƒç”¨å¤„ç†æ•´ä½“äº‹ä»¶\n```java\npublic String decodeString(String s) {\n        Stack<Integer> brackets = new Stack<>();\n        char[] chars = s.toCharArray();\n        char leftBracket = '[';\n        char rightBracket = ']';\n        //ä»¥\"3[a211[c]]\"ä¸ºä¾‹ï¼Œæ‹¿åˆ°\"a2[c]\"çš„ä½ç½®ï¼Œå¤„ç†æˆ\"3[acc]\"é€’å½’å¤„ç†\n        //å·¦æ‹¬å·ä½ç½®ç¡®å®šå€æ•°\n        Integer leftBracketIndex = -1;\n        //å³æ‹¬å·ä½ç½®ç¡®å®šæ‹¬å·å†…çš„å­—ç¬¦\n        Integer rightBracketIndex = -1;\n\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] == leftBracket) {\n                brackets.push(i);\n            }\n            if (chars[i] == rightBracket) {\n                leftBracketIndex = brackets.pop();\n                rightBracketIndex = i;\n                break;\n            }\n        }\n        if (leftBracketIndex == -1) {\n            return s;\n        } else {\n            StringBuilder times = new StringBuilder();\n            for (int i = leftBracketIndex -1; i >= 0; i--) {\n                if (chars[i] <48 || chars[i] >57){\n                    break;\n                }\n                times.append(chars[i]);\n            }\n            StringBuilder reverse = times.reverse();\n            int time = Integer.valueOf(reverse.toString());\n\n            StringBuilder tempString = new StringBuilder();\n            StringBuilder timedString = new StringBuilder();\n            tempString.append(chars, leftBracketIndex + 1, rightBracketIndex - (leftBracketIndex + 1));\n            for (int i = 0; i < time; i++) {\n                timedString.append(tempString);\n            }\n            StringBuilder sBuilder = new StringBuilder();\n\n            for (int i = 0; i < chars.length; i++) {\n                int i1 = leftBracketIndex - String.valueOf(time).length();\n                if (i1 < i && i <= rightBracketIndex) {\n\n                } else if (i1 == i) {\n                    sBuilder.append(timedString);\n                } else {\n                    sBuilder.append(chars[i]);\n                }\n            }\n            s = sBuilder.toString();\n            return decodeString(s);\n        }\n\n    }\n```\n>æ—¶é—´å¤æ‚åº¦ï¼šO(n^2)\n>ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188901199","body":"# 232. Implement Queue using Stacks\n**æ€è·¯:**\n1. ç”¨ä¸¤ä¸ªæ ˆæ¨¡æ‹Ÿé˜Ÿåˆ—æ“ä½œ\n```java\npublic class MyQueue {\n    private Stack<Integer> stack;\n    private Stack<Integer> tempStack;\n    public MyQueue() {\n        stack = new Stack<>();\n        tempStack = new Stack<>();\n    }\n\n    public void push(int x) {\n        stack.push(x);\n    }\n\n    public int pop() {\n        int popInt = 0;\n        while (stack.size() != 0){\n            if (stack.size() == 1){\n                popInt =  stack.pop();\n            }else {\n                tempStack.push(stack.pop());\n            }\n\n        }\n        while (tempStack.size() != 0){\n            stack.push(tempStack.pop());\n        }\n        return popInt;\n    }\n\n    public int peek() {\n        int peekInt = 0;\n        while (stack.size() != 0){\n            if (stack.size() == 1){\n                peekInt =  stack.peek();\n            }\n            tempStack.push(stack.pop());\n\n        }\n        while (tempStack.size() != 0){\n            stack.push(tempStack.pop());\n        }\n\n        return peekInt;\n    }\n\n    public boolean empty() {\n        return stack.empty();\n    }\n\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        while (stack.size() != 0){\n\n            tempStack.push(stack.pop());\n\n        }\n        while (tempStack.size() != 0){\n            if (tempStack.size() == 1){\n                sb.append(tempStack.peek());\n            }else {\n                sb.append(tempStack.peek()).append(\",\");\n            }\n            stack.push(tempStack.pop());\n        }\n        sb.append(\"]\");\n        return sb.toString();\n    }\n}\n```\n>æ—¶é—´å¤æ‚åº¦ O(n)\n>ç©ºé—´å¤æ‚åº¦ O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190295429","body":"# 768. Max Chunks To Make Sorted II\n**Thinking:**\n1. Assuming there are already those maximum partitions, what features are in these partitions?\n   1. The minimum value in the latter partition is greater than the maximum value in the previous partitions.\n   2. based on above,we have a stack storage the biggest number in each partition and ensure the condition above.\n2. How could we make it?\n   1. iterate array,if `arr[i] >= stack.top()`,`arr[i]` can be one of the latter partition. \n   2. if not, compare to each number in stack if the number bigger than `arr[i]`: `stack.pop()`,till any number is smaller,each `stack.pop()`means partitions which the numbers represent has been merged\n```java\npublic class Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int currMax = arr[0];\n        Stack<Integer> stack = new Stack<>();\n        stack.push(arr[0]);\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] >= stack.peek()){\n                stack.push(arr[i]);\n                currMax = arr[i];\n            }else {\n                stack.pop();\n                while (!stack.empty()){\n                    if (arr[i]<stack.peek()){\n                        stack.pop();//merge\n                        break;\n                    }\n                    stack.push(currMax);\n                }\n                if (stack.empty()){\n                    stack.push(currMax);\n                }\n            }\n        }\n\n        return stack.size() == 0? 1 : stack.size();\n    }\n\n}\n```\n> Time Complexity O(n^2)\n> Space Complexity O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191665012","body":"# 61. Rotate List\n**Thinking:**\n1. é“¾è¡¨å°¾éƒ¨å‘å‰æ•°kä¸ªå…ƒç´ ä½œä¸ºå¤´ï¼ŒåŸæ¥çš„å¤´æ¥åˆ°åŸæ¥çš„å°¾ä¸Š\n2. å¦‚æœéœ€è¦æ—‹è½¬å¿…é¡»å°†å•å‘é“¾è¡¨æ”¶å°¾ç›¸è¿æˆå¾ªç¯é“¾è¡¨ï¼Œä¾¿äºæ–­å¼€æ—¶å½¢æˆæ–°çš„é“¾è¡¨\n\n```java\n//code\npublic ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) return head;\n        int count = 1; // åŒäºç»Ÿè®¡æ€»èŠ‚ç‚¹æ•°\n        ListNode tempHead =head;\n        while (tempHead.next != null){\n        count++;//åˆå§‹åŒ–æ€»èŠ‚ç‚¹æ•°\n        tempHead = tempHead.next;//åˆå§‹åŒ–é“¾è¡¨å°¾\n        }\n        k %= count;//å–æ¨¡\n\n        if (k == 0) return head;\n        //ä»¥ä¸Šéƒ½ä¸æ»¡è¶³å¼€å§‹æ—‹è½¬\n        tempHead.next = head; //é“¾è¡¨æ”¶å°¾ç›¸è¿\n        for (int i = 0; i < count - k; i++) {\n        tempHead = tempHead.next; //ä»é“¾è¡¨å°¾å¼€å§‹å‘åæ•°count - k -1ä¸ªä¹Ÿå°±æ˜¯å‘å‰æ•°kä¸ªå°±æ˜¯æ–°çš„èŠ‚ç‚¹\n        }\n\n        ListNode newHead = tempHead.next;\n        tempHead.next = null;\n        return newHead;\n        }\n```\n> Time  Complexity O(n)\n> Space Complexity O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192718394","body":"# 24. Swap Nodes in Pairs\n**Thinking:**\n1. é€’å½’\n2. è™šæ‹Ÿå¤´èŠ‚ç‚¹\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode pre = dummy;\n        ListNode cur = head;\n        while (cur != null && cur.next != null){\n            pre.next = cur.next;\n            cur.next = cur.next.next;\n            pre.next.next = cur;\n\n            pre = cur;\n            cur = cur.next;\n        }\n        return dummy.next;\n    }\n}\n```\n> Time  Complexity O(n)\n> Space Complexity O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193145243","body":"# 109. Convert Sorted List to Binary Search Tree\n**Thinking:**\n1. äºŒåˆ†æ³•ï¼Œå¿«æ…¢æŒ‡é’ˆ\n\n```java\npublic class Solution {\n    //äºŒåˆ†æ³•ï¼Œå¿«æ…¢æŒ‡é’ˆ\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n        if (head.next == null) return new TreeNode(head.val);\n        ListNode fast = head, slow = head, pre = null;\n        while (fast != null && fast.next != null){\n            fast = fast.next.next;\n            pre = slow;\n            slow = slow.next;\n        }\n        //åˆ†å‰²rootèŠ‚ç‚¹å’Œå·¦å³é“¾è¡¨\n        pre.next = null;\n        ListNode rightList = slow.next;\n        TreeNode root = new TreeNode(slow.val);\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(rightList);\n        return root;\n    }\n}\n```\n> Time  Complexity O(n)\n> Space Complexity O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193305034","body":"# 160. Intersection of Two Linked Lists\n**Thinking:**\n 1. è‹¥ç›¸äº¤å¿…åœ¨çŸ­é“¾è¡¨å¤„\n 2. åŒæ­¥Aé“¾(é•¿)å’ŒBé“¾(çŸ­)éå†ä½ç½®è‡³Bé“¾headå¤„,åœ¨åŒæ—¶å‘åéå†æŸ¥æ‰¾ç›¸äº¤ç‚¹\n >åŒæ­¥éå†æ–¹æ³•\n >a + b = b + a;\n> åŒæ—¶åœ¨A headå¤„å’ŒB headå¤„éå†é•¿åº¦ a+b,æœ€ç»ˆä¼šåœ¨b headå¤„åŒæ­¥éå†ä½ç½®\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        //ListNode countHead = headA;\n        ////å¸¸è§„æ€è·¯å¤„ç†:\n        ////è®¡ç®— a+b\n        //while (countHead.next != null){\n        //    countHead = countHead.next;\n        //}\n        //countHead.next = headB;\n        //\n        //ListNode pA = headA;\n        //ListNode pB = headB;\n        //while (countHead.next != null){\n        //    //åŒæ­¥åˆ°B headä½ç½®\n        //    pA = pA == null ? headB: pB.next;\n        //    pB = pB == null ? pA: pB.next;\n        //}\n        ////å¦‚æœæœ‰ç›¸äº¤ç‚¹ä¼šåœ¨pA = pBå¤„ç›¸äº¤,å¦‚æœæ²¡æœ‰,åˆ™ä¼šåœ¨é“¾å°¾ç›¸äº¤\n        //while (pA != pB){\n        //    pA = pA.next;\n        //    pB = pB.next;\n        //}\n        //æ ‡å‡†æ€è·¯å¤„ç†\n        if (headA == null || headB == null) return null;\n        ListNode pA = headA, pB = headB;\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n```\n> Time  Complexity O(n)\n> Space Complexity O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194131535","body":"# Problem Name\n**Thinking:**\n 1. å¿«æŒ‡é’ˆæ¯”æ…¢æŒ‡é’ˆå¿«ä¸€æ ¼,ä¸”æœ‰ç¯çš„æƒ…å†µä¸‹,å¿«æ…¢æŒ‡é’ˆä¸€å®šä¼šç›¸é‡\n 2. ä¸‰å˜é‡\n > 1. x = é“¾è¡¨å¤´åˆ°ç¯å…¥å£çš„è·ç¦»\n > 2. y = ç¯å…¥å£åˆ°ç›¸é‡çš„è·ç¦»\n > 3. z = ç›¸é‡åˆ°ç¯å…¥å£çš„è·ç¦»\n slow = x + y\n fast = x + n(y + z) +y\n 2slow = fast\n 2(x + y) = x + n(y + z) +y\n x + y = n(y + z)\n x = n(y + z) -y\n x = (n - 1)(y + z) + z\n (n - 1)(y + z)ç›¸å½“äºä¸æ–­åœ¨è½¬åœˆ\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        //è®¾å¿«æ…¢æŒ‡é’ˆ\n        ListNode fast = head;\n        ListNode slow = head;\n        //é€€å‡ºå¾ªç¯,ä¸¤æ­¥ä¸¤æ­¥è·³,æ³¨æ„nextä¹Ÿä¸ä¸ºç©º\n        while ((fast != null && fast.next != null) ){\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow){\n                ListNode index1 = head;\n                ListNode index2 = fast;\n                while (index1 != index2){\n                    index1 = index1.next;\n                    index2 = index2.next;\n                }\n                return index1;\n            }\n        }\n\n\n        return null;\n\n    }\n}\n```\n> Time  Complexity O(n**2)\n> Space Complexity O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195560862","body":"# 146. LRU Cache\n**Thinking:**\n> 1. çœ‹äº†é¢˜ç›®è§£æï¼Œå…·ä½“å®ç°ä¸æ˜¯å¾ˆéš¾ï¼Œé‡Œè¾¹å¾ˆå¤šæ€æƒ³å€¼å¾—å­¦ä¹ ã€‚\n> 2. LRU æ€æƒ³æ—¢è¦ä¿è¯æŸ¥è¯¢å¿«ï¼Œåˆè¦ä¿è¯æ’å…¥åˆ é™¤å¿«ï¼Œhashè¡¨+åŒå‘é“¾è¡¨ï¼Œåªèƒ½æ˜¯åŒåˆ—é›†åˆï¼Œä¸€ä¸ªç”¨äºå¿«é€Ÿç¡®å®šä½ç½®ï¼Œä¸€ä¸ªç”¨äºå¿«é€Ÿå¢åˆ ï¼Œå…·ä½“å®ç°LinkedHashMapæ‰æ˜¯è¦å­¦ä¹ çš„ã€‚\n\n```java\npublic class LRUCache {\n    int capacity;\n    LinkedHashMap<Integer, Integer> cache = new LinkedHashMap<>();\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n    }\n\n    public int get(int key) {\n        if (!cache.containsKey(key)) {\n            return -1;\n        }\n        makeRecently(key);\n        return cache.get(key);\n    }\n\n    public void put(int key, int value) {\n        //key exists,replace value\n        if (cache.containsKey(key)) {\n            //modify value\n            cache.put(key, value);\n            makeRecently(key);\n            return;\n        }\n        if (cache.size() >= this.capacity) {\n            Integer oldestKey = cache.keySet().iterator().next();\n            cache.remove(oldestKey);\n        }\n        cache.put(key, value);\n\n    }\n\n    public void makeRecently(int key) {\n        //è·å–åˆ°node\n        int val = cache.get(key);\n        //åˆ é™¤key,é‡æ–°å°¾æ’\n        cache.remove(key);\n        cache.put(key, val);\n\n    }\n\n}\n```\n> Time  Complexity O(1)\n> Space Complexity O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196134306","body":"# 104. Maximum Depth of Binary Tree\n**Thinking:**\né€’å½’\n**tag: DFS**\n1. æ‰¾å‡ºç»ˆæ­¢æ¡ä»¶: å½“å‰èŠ‚ç‚¹ä¸ºç©º\n2. æ‰¾å‡ºè¿”å›å€¼: èŠ‚ç‚¹ä¸ºç©ºè¿”å›0ï¼ŒèŠ‚ç‚¹ä¸ä¸ºç©ºåˆ†åˆ«æ±‚å·¦å³èŠ‚ç‚¹æœ€å¤§å€¼åœ¨åŠ 1è¡¨ç¤ºå½“å‰èŠ‚ç‚¹çš„é«˜åº¦å¹¶è¿”å›\n3. æŸå±‚çš„æ‰§è¡Œè¿‡ç¨‹: è§è¿”å›å€¼éƒ¨åˆ†\n\n```java\npublic class Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null){\n            return 0;\n        }else {\n            int left = maxDepth(root.left);\n            int right = maxDepth(root.right);\n            return Math.max(left,right) + 1;\n        }\n\n    }\n\n}\n```\n> Time  Complexity O(n)\n> Space Complexity O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198125325","body":"# 100. Same Tree\n**Thinking:**\n1. é€’å½’\n2. æ³¨æ„æ‰¾ç»ˆæ­¢æ¡ä»¶\n\n```java\npublic class Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        //Input: p = [1,2], q = [1,null,2]\n        if (p == null && q == null) return true;\n        //if (p != null && q != null) return p.val == q.val;\n        if ((p ==null && q != null) || (p !=null && q == null)) return false;\n        if (p.val != q.val) return false;\n\n        boolean boolLeft = isSameTree(p.left, q.left);\n        boolean boolRight = isSameTree(p.right, q.right);\n\n        return boolLeft && boolRight;\n\n\n    }\n\n}\n```\n> Time  Complexity O(n)\n> Space Complexity O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199422597","body":"# 129. Sum Root to Leaf Numbers\n**Thinking:**\n1. dfs\n2. æ¯ä¸ªèŠ‚ç‚¹ä¸ºä¸€ä¸ªæ•°ï¼Œæ‰€æœ‰èŠ‚ç‚¹çš„å’Œå°±æ˜¯è¯¥æ•°çš„ä»£è¡¨æ•°å­—ï¼Œå½“å‰èŠ‚ç‚¹çš„è®¡ç®—å‘æ”¾ curNum = prev * 10 +node.val;\n\n```java\npublic class Solution {\n    public int sumNumbers(TreeNode root) {\n        return dfs(root,0);\n    }\n\n    private int dfs(TreeNode root, int prevNum){\n        if (root == null) return 0;\n        int sum = prevNum * 10 + root.val;\n        if (root.left == null && root.right == null) return sum;\n        return dfs(root.left,sum) + dfs(root.right,sum);\n    }\n\n}\n```\n> Time  Complexity O(n)\n> Space Complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200185390","body":"# 513. Find Bottom Left Tree Value\n**Thinking:**\n dfs\n 1. ç»´æŠ¤curHeight curVal\n 2. ç»ˆæ­¢æ¡ä»¶ å½“å‰èŠ‚ç‚¹ä¸ºnull\n 3. ä¼˜å…ˆå½“å‰èŠ‚ç‚¹çš„å·¦å­èŠ‚ç‚¹ï¼Œåªæœ‰å½“heighté«˜äºcurHeightç»´æŠ¤curValåŠcurHeight\n\n```java\npublic class Solution {\n    int curVal, curHeight= Integer.MIN_VALUE;\n\n    public int findBottomLeftValue(TreeNode root) {\n        dfs(root, 0);\n        return curVal;\n    }\n\n    private void dfs(TreeNode root, int height) {\n        if (root == null) return;\n        if (height > curHeight) {\n            curHeight = height;\n            curVal = root.val;\n        }\n        height++;\n        dfs(root.left, height);\n        dfs(root.right, height);\n    }\n}\n```\n> Time  Complexity O(n)\n> Space Complexity O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202713083","body":"# 1. Two Sum\n**Thinking:**\n> å¦‚ä½•æ‰¾åˆ°target - xçš„å€¼\n 1. æš´åŠ›è§£æ³•\n     * æšä¸¾æ¯ä¸ªxæ˜¯å¦å­˜åœ¨ä¸ä¹‹å¯¹åº”çš„target -x\n     * x ä¸€å±‚éå†\n     * target - x ä¸€å±‚éå† æ€»æ—¶é—´å¤æ‚åº¦O(n2)\n 2. å°†target - xçš„O(n) æ“ä½œé€šè¿‡å“ˆå¸Œè¡¨å˜ä¸ºO(1)æ“ä½œ\n    * ä»¥ç©ºé—´æ¢æ—¶é—´\n    \n\n```java\npublic class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        //1. æš´åŠ› åŒå±‚éå†\n        //int l = nums.length;\n        //for (int i = 0; i < l; ++i) {\n        //    for (int j = i + 1; j < l; ++j) {\n        //        if (nums[i] + nums[j] == target) {\n        //            return new int[]{i, j};\n        //        }\n        //    }\n        //}\n        //return new int[0];\n        //2. hashmap\n        HashMap<Integer, Integer> map = new HashMap<>();\n        int l = nums.length;\n        for (int i = 0; i < l; i++) {\n            if (map.containsKey(target - nums[i])){\n                return new int[]{map.get(target - nums[i]),i};\n            }\n            map.put(nums[i],i);\n        }\n        return new int[0];\n    }\n}\n```\n> Time  Complexity O(n)\n> Space Complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203973847","body":"# 347. Top K Frequent Elements\n**Thinking:**\n1. hashè¡¨è®°å½•æ•°å­—å‡ºç°çš„æ¬¡æ•°\n2. å †å®ç°çš„ä¼˜å…ˆé˜Ÿåˆ—æŒ‰ç…§ä»å¤§åˆ°å°æ’åº\n3. æ”¾å…¥æ•°ç»„\n\n```java\npublic class Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        //hashè¡¨\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.put(nums[i],map.getOrDefault(nums[i],0) +1);\n        }\n        //ä¼˜å…ˆé˜Ÿåˆ—\n        PriorityQueue<int[]> pq = new PriorityQueue<>(\n                (m,n)->m[1] - n[1]);\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            int num = entry.getKey(), count = entry.getValue();\n            //pq.size()å°äºkæ—¶ï¼Œç›´æ¥å­˜å…¥æ’åºï¼Œå­˜æ»¡äº†ä¸é¡¶ä¸Šçš„æ•°æ¯”è¾ƒ\n            if (pq.size() == k){\n                if (pq.peek()[1] < count){\n                    pq.poll();\n                    pq.offer(new int[]{num,count});\n                }\n            }else {\n                pq.offer(new int[]{num,count});\n            }\n        }\n        int[] ret = new int[k];\n        for (int i = 0; i < k; i++) {\n            ret[i] = pq.poll()[0];\n        }\n        return ret;\n\n    }\n\n}\n```\n> Time  Complexity O(Nlogk) O(logk) ä¸ºä¼˜å…ˆé˜Ÿåˆ—å¼€æ”¯\n> Space Complexity O(N) hashè¡¨å¼€æ”¯","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207431240","body":"# Delete Sublist to Make Sum Divisible By K\n**Thinking:**\n 1. allSum % p = rangeSum % p\n 2. rangeSum = preSum2 - preSum1\n 3. æ‰¾å‡ºä¸allSumç›¸åŒçš„rangeSumçš„modå€¼\n 4. rangeSum % p = mod\n 5. preSum1 % p = curMod\n 6. targetMod = mod - curMod\n 7. æ³¨æ„å¤§æ•°\n\n```java\npublic class Solution {\n    public int minSubarray(int[] nums, int p) {\n        HashMap<Integer, Integer> table = new HashMap<>();\n        long allSum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            //æ±‚allSum\n            allSum += nums[i];\n        }\n        //æ±‚mod\n        int mod = (int)(allSum % p);\n        if (mod == 0) return 0;\n\n        table.put(0, -1);\n        int res = nums.length;\n        long preSum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            preSum += nums[i];\n            //æ±‚curMod\n            int curMod = (int)(preSum % p);\n\n            //æ±‚targetMod è´Ÿæ•°åšå¤„ç†\n            int targetMod = (curMod - mod + p ) % p;\n            if (table.containsKey(targetMod)) {\n                res = Math.min(i - table.get(targetMod), res);\n            }\n            table.put(curMod, i);\n        }\n        return res == nums.length ? -1 : res;\n    }\n\n}\n```\n> Time  Complexity O(n)\n> Space Complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207511049","body":"# 876. Middle of the Linked List\n**Thinking:**\n1. å¿«æ…¢æŒ‡é’ˆ\n\n```java\npublic class Solution {\n    public ListNode middleNode(ListNode head) {\n        if (head.next == null) return head;\n        if (head.next.next == null) return head.next;\n        ListNode fast = head, slow = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n\n    }\n\n}\n```\n> Time  Complexity O(n)\n> Space Complexity O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209524483","body":"# 26. Remove Duplicates from Sorted Array\n**Thinking:**\n1. åŒæŒ‡é’ˆ\n\n\n```java\npublic class Solution {\n    public int removeDuplicates(int[] nums) {\n        if (nums.length < 2) return nums.length;\n        int j = 0;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[j] == nums[i]){\n\n            }else {\n                nums[j+1] = nums[i];\n\n                j++;\n            }\n        }\n        return j + 1;\n    }\n\n}\n```\n> Time  Complexity O(n)\n> Space Complexity O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tomtao626":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185520837","body":"## æ€è·¯\r\n\r\n> + kä½œä¸ºä½æ•°ç´¯åŠ ,è¿›ä½\r\n\r\n##ä»£ç \r\n\r\n```go\r\nfunc addToArrayForm(num []int, k int) []int {\r\n\ti := len(num) - 1\r\n\tfor i >= 0 || k > 0 {\r\n\t\tif i > 0 && k > 0 {\r\n\t\t\tsum := num[i] + k%10\r\n\t\t\tnum[i] = sum\r\n\t\t\tk = k / 10  // drop the last element of k\r\n\r\n\t\t\tif sum > 9 {\r\n\t\t\t\tnum[i] = sum % 10\r\n\t\t\t\tk++ //  add carry(1) to k\r\n\t\t\t}\r\n\t\t\ti--\r\n\t\t} else if i >= 0 {\r\n\t\t\tbreak\r\n\t\t} else {\r\n\t\t\tnum = append([]int{k % 10}, num...)\r\n\t\t}\r\n\t}\r\n\r\n\treturn num\r\n}   \r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n> + æ—¶é—´å¤æ‚åº¦: O(n)\r\n> + ç©ºé—´å¤æ‚åº¦: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186214965","body":"## æ€è·¯\r\n\r\n> + ä¸¤æ¬¡éå†-å³æ±‚s[i]åˆ°cå·¦å³æœ€è¿‘è·ç¦»çš„æœ€å°å€¼\r\n\r\n## ä»£ç \r\n\r\n```go\r\nfunc shortestToChar(s string, c byte) []int {\r\n    n := len(s)\r\n    ans := make([]int, n)\r\n\r\n    idx := -n\r\n    for i, ch := range s {\r\n        if byte(ch) == c {\r\n            idx = i\r\n        }\r\n        ans[i] = i - idx\r\n    }\r\n\r\n    idx = n * 2\r\n    for i := n - 1; i >= 0; i-- {\r\n        if s[i] == c {\r\n            idx = i\r\n        }\r\n        ans[i] = min(ans[i], idx-i)\r\n    }\r\n    return ans\r\n}\r\n\r\nfunc min(a, b int) int {\r\n    if a > b {\r\n        return b\r\n    }\r\n    return a\r\n}\r\n```\r\n\r\n## å¤æ‚åº¦åˆ†æ\r\n\r\n> + æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n> + ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186543466","body":"## æ€è·¯\r\n\r\n> + æ¨¡æ‹Ÿ\r\n\r\n## ä»£ç \r\n\r\n```go\r\ntype CustomStack struct {\r\n    stack []int\r\n    size int\r\n}\r\n\r\n\r\nfunc Constructor(maxSize int) CustomStack {\r\n    return CustomStack{\r\n        make([]int, 0),\r\n        maxSize,\r\n    }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Push(x int)  {\r\n    if len(this.stack) < this.size {\r\n        this.stack = append(this.stack, x)\r\n    }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Pop() int {\r\n    if len(this.stack) > 0 {\r\n        res := this.stack[len(this.stack)-1]\r\n        this.stack = this.stack[:len(this.stack)-1]\r\n        return res\r\n    }\r\n    return -1\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Increment(k int, val int)  {\r\n    if k > len(this.stack) {\r\n        k = len(this.stack)\r\n    }\r\n    for i := 0; i < k; i++ {\r\n        this.stack[i] += val\r\n    }\r\n}\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n> + æ—¶é—´: O(1)\r\n> + ç©ºé—´: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187447665","body":"## æ€è·¯\r\n\r\n> + åŒæ ˆ\r\n\r\n## ä»£ç \r\n\r\n```go\r\nfunc decodeString(s string) string {\r\n    stk := []string{}\r\n    ptr := 0\r\n    for ptr < len(s) {\r\n        cur := s[ptr]\r\n        if cur >= '0' && cur <= '9' {\r\n            digits := getDigits(s, &ptr)\r\n            stk = append(stk, digits)\r\n        } else if (cur >= 'a' && cur <= 'z' || cur >= 'A' && cur <= 'Z') || cur == '[' {\r\n            stk = append(stk, string(cur))\r\n            ptr++\r\n        } else {\r\n            ptr++\r\n            sub := []string{}\r\n            for stk[len(stk)-1] != \"[\" {\r\n                sub = append(sub, stk[len(stk)-1])\r\n                stk = stk[:len(stk)-1]\r\n            }\r\n            for i := 0; i < len(sub)/2; i++ {\r\n                sub[i], sub[len(sub)-i-1] = sub[len(sub)-i-1], sub[i]\r\n            }\r\n            stk = stk[:len(stk)-1]\r\n            repTime, _ := strconv.Atoi(stk[len(stk)-1])\r\n            stk = stk[:len(stk)-1]\r\n            t := strings.Repeat(getString(sub), repTime)\r\n            stk = append(stk, t)\r\n        }\r\n    }\r\n    return getString(stk)\r\n}\r\n\r\nfunc getDigits(s string, ptr *int) string {\r\n    ret := \"\"\r\n    for ; s[*ptr] >= '0' && s[*ptr] <= '9'; *ptr++ {\r\n        ret += string(s[*ptr])\r\n    }\r\n    return ret\r\n}\r\n\r\nfunc getString(v []string) string {\r\n    ret := \"\"\r\n    for _, s := range v {\r\n        ret += s\r\n    }\r\n    return ret\r\n}\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n> + æ—¶é—´: O(n)\r\n> + ç©ºé—´: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189127036","body":"## æ€è·¯\r\n\r\n> + åŒæ ˆ\r\n\r\n## ä»£ç \r\n\r\n```go\r\ntype MyQueue struct {\r\n    inStack, outStack []int\r\n}\r\n\r\nfunc Constructor() MyQueue {\r\n    return MyQueue{}\r\n}\r\n\r\nfunc (q *MyQueue) Push(x int) {\r\n    q.inStack = append(q.inStack, x)\r\n}\r\n\r\nfunc (q *MyQueue) in2out() {\r\n    for len(q.inStack) > 0 {\r\n        q.outStack = append(q.outStack, q.inStack[len(q.inStack)-1])\r\n        q.inStack = q.inStack[:len(q.inStack)-1]\r\n    }\r\n}\r\n\r\nfunc (q *MyQueue) Pop() int {\r\n    if len(q.outStack) == 0 {\r\n        q.in2out()\r\n    }\r\n    x := q.outStack[len(q.outStack)-1]\r\n    q.outStack = q.outStack[:len(q.outStack)-1]\r\n    return x\r\n}\r\n\r\nfunc (q *MyQueue) Peek() int {\r\n    if len(q.outStack) == 0 {\r\n        q.in2out()\r\n    }\r\n    return q.outStack[len(q.outStack)-1]\r\n}\r\n\r\nfunc (q *MyQueue) Empty() bool {\r\n    return len(q.inStack) == 0 && len(q.outStack) == 0\r\n}\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n> + æ—¶é—´: O(1)\r\n> + ç©ºé—´: O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191324785","body":"## æ€è·¯\r\n\r\n> + é—­åˆä¸ºç¯-å°†ç»™å®šçš„é“¾è¡¨è¿æ¥æˆç¯ï¼Œç„¶åå°†æŒ‡å®šä½ç½®æ–­å¼€\r\n\r\n## ä»£ç \r\n\r\n```go\r\nfunc rotateRight(head *ListNode, k int) *ListNode {\r\n    if k == 0 || head == nil || head.Next == nil {\r\n        return head\r\n    }\r\n    n := 1\r\n    iter := head\r\n    for iter.Next != nil {\r\n        iter = iter.Next\r\n        n++\r\n    }\r\n    add := n - k%n\r\n    if add == n {\r\n        return head\r\n    }\r\n    iter.Next = head\r\n    for add > 0 {\r\n        iter = iter.Next\r\n        add--\r\n    }\r\n    ret := iter.Next\r\n    iter.Next = nil\r\n    return ret\r\n}\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n> + æ—¶é—´:O(n)\r\n> + ç©ºé—´:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192252113","body":"## æ€è·¯\r\n\r\n> + é€’å½’\r\n\r\n## ä»£ç \r\n\r\n```go\r\nfunc swapPairs(head *ListNode) *ListNode {\r\n\tif head == nil || head.Next == nil {\r\n\t\treturn head\r\n\t}\r\n\tnewHead := head.Next\r\n\thead.Next = swapPairs(newHead.Next)\r\n\tnewHead.Next = head\r\n\treturn newHead\r\n}\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n> + æ—¶é—´\tO(n)\r\n> + ç©ºé—´\tO(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193250155","body":"## æ€è·¯\r\n\r\n> + åŒæŒ‡é’ˆ\r\n\r\n## ä»£ç \r\n\r\n```go\r\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\r\n    if headA == nil || headB == nil {\r\n        return nil\r\n    }\r\n    pa, pb := headA, headB\r\n    for pa != pb {\r\n        if pa == nil {\r\n            pa = headB\r\n        } else {\r\n            pa = pa.Next\r\n        }\r\n        if pb == nil {\r\n            pb = headA\r\n        } else {\r\n            pb = pb.Next\r\n        }\r\n    }\r\n    return pa\r\n}\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n> + æ—¶é—´:O(m+n)\r\n> + ç©ºé—´:O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194855004","body":"## æ€è·¯\r\n\r\n> + å“ˆå¸Œ+åŒå‘é“¾è¡¨\r\n\r\n## ä»£ç \r\n\r\n```go\r\ntype LRUCache struct {\r\n    size int\r\n    capacity int\r\n    cache map[int]*DLinkedNode\r\n    head, tail *DLinkedNode\r\n}\r\n\r\ntype DLinkedNode struct {\r\n    key, value int\r\n    prev, next *DLinkedNode\r\n}\r\n\r\nfunc initDLinkedNode(key, value int) *DLinkedNode {\r\n    return &DLinkedNode{\r\n        key: key,\r\n        value: value,\r\n    }\r\n}\r\n\r\nfunc Constructor(capacity int) LRUCache {\r\n    l := LRUCache{\r\n        cache: map[int]*DLinkedNode{},\r\n        head: initDLinkedNode(0, 0),\r\n        tail: initDLinkedNode(0, 0),\r\n        capacity: capacity,\r\n    }\r\n    l.head.next = l.tail\r\n    l.tail.prev = l.head\r\n    return l\r\n}\r\n\r\nfunc (this *LRUCache) Get(key int) int {\r\n    if _, ok := this.cache[key]; !ok {\r\n        return -1\r\n    }\r\n    node := this.cache[key]\r\n    this.moveToHead(node)\r\n    return node.value\r\n}\r\n\r\n\r\nfunc (this *LRUCache) Put(key int, value int)  {\r\n    if _, ok := this.cache[key]; !ok {\r\n        node := initDLinkedNode(key, value)\r\n        this.cache[key] = node\r\n        this.addToHead(node)\r\n        this.size++\r\n        if this.size > this.capacity {\r\n            removed := this.removeTail()\r\n            delete(this.cache, removed.key)\r\n            this.size--\r\n        }\r\n    } else {\r\n        node := this.cache[key]\r\n        node.value = value\r\n        this.moveToHead(node)\r\n    }\r\n}\r\n\r\nfunc (this *LRUCache) addToHead(node *DLinkedNode) {\r\n    node.prev = this.head\r\n    node.next = this.head.next\r\n    this.head.next.prev = node\r\n    this.head.next = node\r\n}\r\n\r\nfunc (this *LRUCache) removeNode(node *DLinkedNode) {\r\n    node.prev.next = node.next\r\n    node.next.prev = node.prev\r\n}\r\n\r\nfunc (this *LRUCache) moveToHead(node *DLinkedNode) {\r\n    this.removeNode(node)\r\n    this.addToHead(node)\r\n}\r\n\r\nfunc (this *LRUCache) removeTail() *DLinkedNode {\r\n    node := this.tail.prev\r\n    this.removeNode(node)\r\n    return node\r\n}\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n> + æ—¶é—´: O(1)\r\n> + ç©ºé—´: O(capacity)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196793112","body":"## æ€è·¯\r\n\r\n> + BFS\r\n\r\n## ä»£ç \r\n\r\n```go\r\nfunc maxDepth(root *TreeNode) int {\r\n    if root == nil {\r\n        return 0\r\n    }\r\n    queue := []*TreeNode{}\r\n    queue = append(queue, root)\r\n    ans := 0\r\n    for len(queue) > 0 {\r\n        sz := len(queue)\r\n        for sz > 0 {\r\n            node := queue[0]\r\n            queue = queue[1:]\r\n            if node.Left != nil {\r\n                queue = append(queue, node.Left)\r\n            }\r\n            if node.Right != nil {\r\n                queue = append(queue, node.Right)\r\n            }\r\n            sz--\r\n        }\r\n        ans++\r\n    }\r\n    return ans\r\n}\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n> + æ—¶é—´: O(n)\r\n> + ç©ºé—´: O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198902869","body":"## æ€è·¯\r\n\r\n> + DFS\r\n\r\n## ä»£ç \r\n```go\r\nfunc dfs(root *TreeNode, prevSum int) int {\r\n    if root == nil {\r\n        return 0\r\n    }\r\n    sum := prevSum*10 + root.Val\r\n    if root.Left == nil && root.Right == nil {\r\n        return sum\r\n    }\r\n    return dfs(root.Left, sum) + dfs(root.Right, sum)\r\n}\r\n\r\nfunc sumNumbers(root *TreeNode) int {\r\n    return dfs(root, 0)\r\n}\r\n```\r\n\r\n## å¤æ‚åº¦åˆ†æ\r\n\r\n> + æ—¶é—´å¤æ‚åº¦: O(N)\r\n> + ç©ºé—´å¤æ‚åº¦: O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200424852","body":"## æ€è·¯\r\n\r\n> + DFS\r\n\r\n## ä»£ç \r\n\r\n```go\r\ntype Codec struct{}\r\n\r\nfunc Constructor() (_ Codec) {\r\n    return\r\n}\r\n\r\nfunc (Codec) serialize(root *TreeNode) string {\r\n    sb := &strings.Builder{}\r\n    var dfs func(*TreeNode)\r\n    dfs = func(node *TreeNode) {\r\n        if node == nil {\r\n            sb.WriteString(\"null,\")\r\n            return\r\n        }\r\n        sb.WriteString(strconv.Itoa(node.Val))\r\n        sb.WriteByte(',')\r\n        dfs(node.Left)\r\n        dfs(node.Right)\r\n    }\r\n    dfs(root)\r\n    return sb.String()\r\n}\r\n\r\nfunc (Codec) deserialize(data string) *TreeNode {\r\n    sp := strings.Split(data, \",\")\r\n    var build func() *TreeNode\r\n    build = func() *TreeNode {\r\n        if sp[0] == \"null\" {\r\n            sp = sp[1:]\r\n            return nil\r\n        }\r\n        val, _ := strconv.Atoi(sp[0])\r\n        sp = sp[1:]\r\n        return &TreeNode{val, build(), build()}\r\n    }\r\n    return build()\r\n}\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n> + æ—¶é—´: O(N) \r\n> + ç©ºé—´: O(N)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204656031","body":"## æ€è·¯\r\n\r\n> + æšä¸¾+å“ˆå¸Œè¡¨\r\n\r\n## ä»£ç \r\n\r\n```go\r\nfunc numberOfBoomerangs(points [][]int) (ans int) {\r\n    for _, p := range points {\r\n        cnt := map[int]int{}\r\n        for _, q := range points {\r\n            dis := (p[0]-q[0])*(p[0]-q[0]) + (p[1]-q[1])*(p[1]-q[1])\r\n            cnt[dis]++\r\n        }\r\n        for _, m := range cnt {\r\n            ans += m * (m - 1)\r\n        }\r\n    }\r\n    return\r\n}\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n> + æ—¶é—´: O(N^2)\r\n> + ç©ºé—´: O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207348685","body":"## æ€è·¯\r\n\r\n> + å‰ç¼€å’Œ\r\n\r\n## ä»£ç \r\n\r\n```python\r\nclass Solution:\r\n    def solve(self, nums, k):\r\n        tar_remainder = (sum(nums) + k) % k\r\n        if tar_remainder == 0:\r\n            return 0\r\n        n, presum = len(nums), 0\r\n        hashmap = {0: -1}\r\n        res = n\r\n        for i in range(n):\r\n            presum += nums[i]\r\n            modulus = (presum + k) % k\r\n            hashmap[modulus] = i\r\n            if (modulus - tar_remainder + k) % k in hashmap:\r\n                res = min(res, i - hashmap[(modulus - tar_remainder + k) % k])\r\n        return res if res != n else -1\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n> + æ—¶é—´: O(N)\r\n> + ç©ºé—´: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aiweng1981":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185533265","body":"#Python 3\n#Idea:å¯¹å°†å…¶ä»åˆ—è¡¨å˜å­—ç¬¦ä¸²ï¼Œå†å˜æ•´å‹ï¼Œå®ŒæˆåŠ æ³•ï¼Œå†å°†ç»“æœå˜æˆå­—ç¬¦ä¸²ï¼Œæœ€åå­—ç¬¦ä¸²æ¢æˆåˆ—è¡¨ã€‚\ndef day1(A,K):\n    A0 = []\n    for i in A:\n        A0.append(str(i))\n    A1 = \"\".join(A0)\n    a1 = int(A1)\n    sm = a1 + K\n    sm1 = str(sm)\n    sm2 = []\n    for j in sm1:\n        sm2.append(int(j))\n    return sm2\nA = [1,2,0,0]\nK = 304\nday1(A,K)\n#Complexity\n#Time: O(N)\n#Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186165511","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°: çœ‹çš„ç­”æ¡ˆï¼Œå…ˆå­¦ä¹ ä¸€ä¸‹ï¼›åæ¥å‘ç°è‡ªå·±çš„æ€è·¯å’Œç­”æ¡ˆå·®ä¸å¤šï¼Œä½†æ˜¯ä¸ä¼šå†™ï¼Œå“ˆå“ˆï¼\n\n##ä»£ç \nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n\n\n        n = len(s)\n        ans = [0] * n\n\n        idx = -n\n        for i, ch in enumerate(s):\n            if ch == c:\n                idx = i\n            ans[i] = i - idx\n\n        idx = 2 * n\n        for i in range(n - 1, -1, -1):\n            if s[i] == c:\n                idx = i\n            ans[i] = min(ans[i], idx - i)\n        return ans\n```python\n#ä»£ç \n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦:  O(N)\n> + ç©ºé—´å¤æ‚åº¦:  O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186384452","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°:è¿™ä¸ªé¢˜ç›®æ¯”è¾ƒæ‡µï¼Œå…ˆæ‰“å¡ï¼Œæ…¢æ…¢ç¢ç£¨ï¼\n\n##ä»£ç \nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.c = maxSize\n        self.s = []\n\n    def push(self, x: int) -> None:\n        if len(self.s) < self.c:\n            self.s.append(x)\n\n    def pop(self) -> int:\n        if self.s:\n            return self.s.pop()\n        return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len(self.s))):\n            self.s[i] += val\n\n```python\n#ä»£ç \n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦:  O(N)\n> + ç©ºé—´å¤æ‚åº¦:  O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187290014","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°:è¿™ä¸ªé¢˜ç›®å¼€å§‹æ²¡æœ‰æ˜ç™½ï¼Œä½†æ˜¯åæ¥å¯¹ç€ç­”æ¡ˆï¼Œæ…¢æ…¢ç¢ç£¨æ˜ç™½ï¼\n\n##ä»£ç \nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == ']':\n                repeatStr = ''\n                repeatCount = ''\n                while stack and stack[-1] != '[':\n                    repeatStr = stack.pop() + repeatStr\n              \n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    repeatCount = stack.pop() + repeatCount\n                stack.append(repeatStr * int(repeatCount))\n            else:\n                stack.append(c)\n        return \"\".join(stack)\n```python\n#ä»£ç \n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦:  O(N)\n> + ç©ºé—´å¤æ‚åº¦:  O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189177220","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°:è¿™ç±»é¢˜ç›®ä¸ç†Ÿæ‚‰ï¼Œä¸è¿‡è¿˜æ˜¯æœ‰æ‰€æ”¶è·ï¼Œæœ‰äº›æ„Ÿè§‰äº†ï¼\n\n##ä»£ç \n\n\n```python\n#ä»£ç \nclass MyQueue:\n    def __init__(self):\n        self.queue = []\n    def push(self, x: int) -> None:\n        self.queue.append(x)\n    def pop(self) -> int:\n#å¼¹å‡ºç¬¬ä¸€ä¸ªå…ƒç´ \n        return self.queue.pop(0)\n    def peek(self) -> int:\n#è¿”å›ç¬¬ä¸€ä¸ªå…ƒç´ \n        return self.queue[0]\n    def empty(self) -> bool:\n        return not self.queue\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦:  O(1)\n> + ç©ºé—´å¤æ‚åº¦:  O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190277906","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°:å¤´ä¸€æ¬¡é‡ä¸Šhardï¼èƒ½çœ‹æ‡‚ç­”æ¡ˆï¼Œè§‰å¾—å°±OKäº†ã€\n\n##ä»£ç \n\n\n```python\n#ä»£ç \nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        count_a = collections.defaultdict(int)\n        count_b = collections.defaultdict(int)\n        ans = 0\n\n        for a, b in zip(arr, sorted(arr)):\n            count_a[a] += 1\n            count_b[b] += 1\n            if count_a == count_b: ans += 1\n\n        return ans\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦:  O(N**2)\n> + ç©ºé—´å¤æ‚åº¦:  O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191579179","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°:å¯¹é“¾è¡¨çš„æ¦‚å¿µè¿˜ä¸ç†Ÿæ‚‰ï¼Œå¼„ä¸€åŠï¼Œè¿˜æ˜¯æŠ„çš„ç­”æ¡ˆã€‚\n\n##ä»£ç \n\n\n```python\n#ä»£ç \nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        # åŒæŒ‡é’ˆ\n        if head:\n            p1 = head\n            p2 = head\n            count = 1\n            i = 0\n            while i < k:\n                if p2.next:\n                    count += 1\n                    p2 = p2.next\n                else:\n                    k = k % count\n                    i = -1\n                    p2 = head\n                i += 1\n\n            while p2.next:\n                p1 = p1.next\n                p2 = p2.next\n\n            if p1.next:\n                tmp = p1.next\n            else:\n                return head\n            p1.next = None\n            p2.next = head\n            return tmp\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦:  O(N)\n> + ç©ºé—´å¤æ‚åº¦:  O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192412390","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°:ä»Šå¤©å…ˆæ‰“å¡ï¼Œå†æ…¢æ…¢ç¢ç£¨ï¼Œè¦åŠ ç­äº†ã€\n\n##ä»£ç \n\n\n```python\n#ä»£ç \nif not head or not head.next: return head\n    ans = ListNode()\n    ans.next = head.next\n    pre = ans\n    while head and head.next:\n        next = head.next\n        n_next = next.next\n\n        next.next = head\n        pre.next = next\n        head.next = n_next\n        # æ›´æ–°æŒ‡é’ˆ\n        pre = head\n        head = n_next\n    return ans.next\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦:  O(Nï¼‰\n> + ç©ºé—´å¤æ‚åº¦:  O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194015868","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°:æœ‰äº›æ‡µã€\n\n##ä»£ç \n\n\n```python\n#ä»£ç \nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow = fast = head\n        x = None\n\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                x = fast\n                break\n        if not x:\n            return None\n        slow = head\n        while slow != x:\n            slow = slow.next\n            x = x.next\n        return slow\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦:  O(N)\n> + ç©ºé—´å¤æ‚åº¦:  O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195460148","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°:ä»Šå¤©çœŸæ˜¯çº¯å­¦ä¹ äº†ï¼Œè¿™ä¸ªå¯¹ç°åœ¨çš„æˆ‘æ¥è¯´å¤ªæœ‰æŒ‘æˆ˜æ€§äº†ã€‚\n\n##ä»£ç \n\n\n```JavaScript Codeï¼ˆå‡è£…è‡ªå·±å¾ˆä¼šï¼‰\n#ä»£ç \nclass DoubleLinkedListNode {\n    constructor(key, value) {\n        this.key = key\n        this.value = value\n        this.prev = null\n        this.next = null\n    }\n}\n\nclass LRUCache {\n    constructor(capacity) {\n        this.capacity = capacity\n        this.usedSpace = 0\n        // Mappings of key->node.\n        this.hashmap = {}\n        this.dummyHead = new DoubleLinkedListNode(null, null)\n        this.dummyTail = new DoubleLinkedListNode(null, null)\n        this.dummyHead.next = this.dummyTail\n        this.dummyTail.prev = this.dummyHead\n    }\n\n    _isFull() {\n        return this.usedSpace === this.capacity\n    }\n\n    _removeNode(node) {\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        node.prev = null\n        node.next = null\n        return node\n    }\n\n    _addToHead(node) {\n        const head = this.dummyHead.next\n        node.next = head\n        head.prev = node\n        node.prev = this.dummyHead\n        this.dummyHead.next = node\n    }\n\n    get(key) {\n        if (key in this.hashmap) {\n            const node = this.hashmap[key]\n            this._addToHead(this._removeNode(node))\n            return node.value\n        }\n        else {\n            return -1\n        }\n    }\n\n    put(key, value) {\n        if (key in this.hashmap) {\n            // If key exists, update the corresponding node and move it to the head.\n            const node = this.hashmap[key]\n            node.value = value\n            this._addToHead(this._removeNode(node))\n        }\n        else {\n        // If it's a new key.\n            if (this._isFull()) {\n                // If the cache is full, remove the tail node.\n                const node = this.dummyTail.prev\n                delete this.hashmap[node.key]\n                this._removeNode(node)\n                this.usedSpace--\n            }\n            // Create a new node and add it to the head.\n            const node = new DoubleLinkedListNode(key, value)\n            this.hashmap[key] = node\n            this._addToHead(node)\n            this.usedSpace++\n        }\n    }\n}\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦:  O(1)\n> + ç©ºé—´å¤æ‚åº¦:  O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196803041","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°:ççŒ«è¦é‡ä¸Šæ­»è€—å­äº†ï¼Œå“ˆå“ˆ\n\n##ä»£ç \n\n\n```python\n#ä»£ç \nclass Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        if not root: return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦:  O(N)\n> + ç©ºé—´å¤æ‚åº¦:  æœ‰ç‚¹åƒä¸å‡†","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198144163","body":"\n## æ€è·¯\n\n> + æ€è·¯æè¿°:æ„Ÿè§‰ä¸æ˜¯å¾ˆéš¾\n\n##ä»£ç \n\n\n```python\n#ä»£ç \nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦:  O(N)\n> + ç©ºé—´å¤æ‚åº¦:  O(high)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199284542","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°:å…ˆå­¦ä¹ ï¼Œæ‰“å¡ï¼Œä¸è¦æ‰é˜Ÿã€‚\n##ä»£ç \n\n\n```python\n#ä»£ç \nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        def dfs(root, cur):\n            if not root: return 0\n            if not root.left and not root.right: return cur * 10 + root.val\n            return dfs(root.left, cur * 10 + root.val) + dfs(root.right, cur * 10 + root.val)\n        return dfs(root, 0)\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦:  O(N)\n> + ç©ºé—´å¤æ‚åº¦:  O(h)    h ä¸ºæ ‘çš„é«˜åº¦ã€‚","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200156997","body":"\n\n\n\n## æ€è·¯\n\n> + æ€è·¯æè¿°:å¤´ä¸€æ¬¡é‡ä¸Šhardï¼èƒ½çœ‹æ‡‚ç­”æ¡ˆï¼Œè§‰å¾—å°±OKäº†ã€\n\n##ä»£ç \n\n\n```python\n#ä»£ç \nclass Solution(object):\n    def findBottomLeftValue(self, root):\n        queue = collections.deque()\n        queue.append(root)\n        while queue:\n            length = len(queue)\n            res = queue[0].val\n            for _ in range(length):\n                cur = queue.popleft()\n                if cur.left:\n                    queue.append(cur.left)\n                if cur.right:\n                    queue.append(cur.right)\n        return res\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦:  O(N)\n> + ç©ºé—´å¤æ‚åº¦:  O(ï¼Ÿ)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200420463","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°:è¿™ä¸ªçœŸæä¸å®šï¼Œåªèƒ½æŠ„ç­”æ¡ˆæ¥å­¦ä¹ \n\n##ä»£ç \n\n\n```python\n#ä»£ç \nclass Codec:\n    def serialize(self, root):\n        ans = ''\n        queue = [root]\n        while queue:\n            node = queue.pop(0)\n            if node:\n                ans += str(node.val) + ','\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                ans += '#,'\n        print(ans[:-1])\n        return ans[:-1]\n\n\n\n    def deserialize(self, data: str):\n        if data == '#': return None\n        nodes = data.split(',')\n        if not nodes: return None\n        root = TreeNode(nodes[0])\n        queue = [root]\n        # å·²ç»æœ‰ root äº†ï¼Œå› æ­¤ä» 1 å¼€å§‹\n        i = 1\n\n        while i < len(nodes) - 1:\n            node = queue.pop(0)\n            lv = nodes[i]\n            rv = nodes[i + 1]\n            i += 2\n            if lv != '#':\n                l = TreeNode(lv)\n                node.left = l\n                queue.append(l)\n\n            if rv != '#':\n                r = TreeNode(rv)\n                node.right = r\n                queue.append(r)\n        return root\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦:  O(N)\n> + ç©ºé—´å¤æ‚åº¦:  O(N)ï¼Ÿ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201136180","body":"\n\n## æ€è·¯\n\n> + æ€è·¯æè¿°:çœŸçš„å†™ä¸å‡ºï¼Œå…ˆæŠ„ä¸‹æ¥æŠŠã€‚\n\n##ä»£ç \n\n\n```python\n#ä»£ç \nclass Solution(object):\n    def verticalTraversal(self, root):\n        seen = collections.defaultdict(\n            lambda: collections.defaultdict(list))\n\n        def dfs(root, x=0, y=0):\n            if not root:\n                return\n            seen[x][y].append(root.val)\n            dfs(root.left, x-1, y+1)\n            dfs(root.right, x+1, y+1)\n\n        dfs(root)\n        ans = []\n        # x æ’åºã€\n        for x in sorted(seen):\n            level = []\n            # y æ’åº\n            for y in sorted(seen[x]):\n                # å€¼æ’åº\n                level += sorted(v for v in seen[x][y])\n            ans.append(level)\n\n        return ans\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦:  O(N*logï¼ˆNï¼‰)\n> + ç©ºé—´å¤æ‚åº¦:  O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203921882","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°:ç”¨pythonå†…ç½®å †å‡½æ•°\n\n##ä»£ç \n\n\n```python\n#ä»£ç \n\ndef top_k_frequent(nums, k):\n    freq_dict = {}\n    for num in nums:\n        if num not in freq_dict:\n            freq_dict[num] = 1\n        else:\n            freq_dict[num] += 1\n\n    import heapq\n    h_list = []\n\n    for key, value in freq_dict.items():\n        if k > 0:\n            heapq.heappush(h_list, (value, key))\n            k = k - 1\n            continue\n        else:\n            h_v, h_k = heapq.heappop(h_list)\n            if value > h_v:\n                heapq.heappush(h_list, (value, key))\n            else:\n                heapq.heappush(h_list, (h_v, h_k))\n\n    return [x[1] for x in h_list]\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: æœ‰äº›åƒä¸å‡†\n> + ç©ºé—´å¤æ‚åº¦:  æœ‰äº›åƒä¸å‡†","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206447122","body":"\n## æ€è·¯\n\n> + æ€è·¯æè¿°:åˆ©ç”¨python çš„å­—å…¸æ¥å¤„ç†\n\n##ä»£ç \n\n\n```python\n#ä»£ç \nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        if len(s) == 0 : return 0\n        end = 0\n        dic = {}\n        m = 0\n        for each in range(len(s)):\n            if s[each] in dic :\n                end = max(end,dic[s[each]]+1)\n            dic[s[each]] = each\n            m = max(m,each-end+1)\n            \n        return m\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦:  O(N)\n> + ç©ºé—´å¤æ‚åº¦:  O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207167966","body":"\n\n\n\n## æ€è·¯\n\n> + æ€è·¯æè¿°:ç¡®å®å¥½éš¾ã€\n\n##ä»£ç \n\n\n```python\n#ä»£ç \nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        from collections import Counter\n\n        # å¤„ç†ç‰¹æ®Šæƒ…å†µ\n        if not s or not words:\n            return []\n        \n        # å“ˆå¸Œè¡¨ç»Ÿè®¡å•è¯å‡ºç°æ¬¡æ•°ï¼Œç”¨ä»¥åç»­æ¯”è¾ƒ\n        word_cnt = Counter(words)\n        \n        # å•è¯é•¿åº¦\n        word_len = len(words[0])\n\n        # è¿”å›ç»“æœåˆ—è¡¨\n        ans = []\n\n        # éå†ï¼Œè¿›è¡Œçª—å£æ»‘åŠ¨\n        for i in range(word_len):\n            left = i\n            right = i\n            cnt = 0\n\n            # å“ˆå¸Œè¡¨è®°å½•çª—å£çš„å•è¯å‡ºç°æ¬¡æ•°\n            window = Counter()\n\n            # é™å®šè¾¹ç•Œ\n            # è¿™é‡Œè¡¨ç¤ºçª—å£çš„å†…å®¹ä¸è¶³ä»¥ç»„æˆä¸²è”æ‰€æœ‰å•è¯çš„å­ä¸²ï¼Œå¾ªç¯ç»“æŸ\n            while left + len(words) * word_len <= len(s):\n                # çª—å£å•è¯å‡ºç°çš„æ¬¡æ•°ï¼Œä¸ word_cnt å¯¹æ¯”\n                while cnt <  len(words):\n                    word = s[right:right+word_len]\n                    # å¦‚æœå•è¯ä¸åœ¨ words ä¸­ï¼Œæˆ–è€…æ­¤æ—¶å•è¯æ•°é‡å¤§äº words ä¸­çš„å•è¯æ•°é‡æ—¶ï¼Œé€€å‡ºå¾ªç¯å¦å¤–å¤„ç†\n                    # å•è¯æ¬¡æ•°ç›¸ç­‰ä¹Ÿè·³å‡ºå¦å¤–åˆ¤æ–­\n                    # å¦åˆ™æ›´æ–°å“ˆå¸Œè¡¨ window\n                    if (word not in words) or (window[word] >= word_cnt[word]):\n                        break\n                    window[word] += 1\n                    cnt += 1\n                    right += word_len\n                \n                # å…ˆåˆ¤æ–­å“ˆå¸Œè¡¨æ˜¯å¦ç›¸ç­‰ï¼Œç›¸ç­‰åˆ™åŠ å…¥è¿”å›åˆ—è¡¨ä¸­\n                if word_cnt == window:\n                    ans.append(left)\n\n                # å†å¤„ç†å•è¯æ•°æº¢å‡ºçš„æƒ…å†µ\n                # åŒºåˆ†åœ¨äºå•è¯æ˜¯å¦åœ¨ words ä¸­\n                if word in words:\n                    # å‰”é™¤å·¦è¾¹éƒ¨åˆ†\n                    left_word = s[left: left+word_len]\n                    window[left_word] -= 1\n                    left += word_len\n                    cnt -= 1\n                    \n                else:\n                    # å¦‚æœå•è¯ä¸åœ¨ words ä¸­ï¼Œ\n                    # æ¸…ç©ºå“ˆå¸Œè¡¨ï¼Œé‡ç½®çª—å£å¼€å§‹ä½ç½®\n                    right += word_len\n                    window.clear()\n                    left = right\n                    cnt = 0\n\n        return ans\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦:  O(N**2)\n> + ç©ºé—´å¤æ‚åº¦:  O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207380364","body":"\n\n\n\n## æ€è·¯\n\n> + æ€è·¯æè¿°:çœ‹äº†ç­”æ¡ˆäº†ã€\n\n##ä»£ç \n\n\n```python\n#ä»£ç \nclass Solution:\n    def solve(self, nums, k):\n        total = sum(nums)\n        mod = total % k\n\n        ans = len(nums)\n        total = 0\n        dic = {0: -1}\n        for j in range(len(nums)):\n            total += nums[j]\n            cur = total % k\n            target = (cur - mod + k) % k\n            if target in dic:\n                ans = min(ans, j - dic[target])\n            dic[cur] = j\n\n        if ans == len(nums):\n            return -1\n        return ans\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦:  O(N)\n> + ç©ºé—´å¤æ‚åº¦:  O(min(n,k))","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209082148","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°:å¤´ä¸€æ¬¡èƒ½æƒ³å‡ºä¸åŒæ–¹æ³•çš„ï¼Œè¿˜æ˜¯æŒ‰ç…§æ ‡ç­”æ¥å§ï¼Œè‡ªå·±çš„é‡è·¯å­æ„ä¹‰æœ‰é™\n\n##ä»£ç \n\n\n```python\n#ä»£ç \n def removeDuplicates(nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums: return 0\n\n        l, r = 0, 0#l ä¸ºï¼ˆä¸‹æ–¹çš„ï¼‰å†™æŒ‡é’ˆã€‚ï¼Œrä¸ºï¼ˆä¸Šæ–¹çš„ï¼‰å†™æŒ‡é’ˆã€‚\n        while r < len(nums):\n            if nums[l] != nums[r]:\n                l += 1\n                nums[l] = nums[r]\n            r += 1\n        return l + 1\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦:  O(N)\n> + ç©ºé—´å¤æ‚åº¦:  O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richard-lime":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185549904","body":"### æ€è·¯\r\nç”¨æ•°ç»„è¿›è¡Œç´¯åŠ \r\n### ä»£ç \r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        for(int i = num.size() - 1; i > -1; i--){\r\n            num[i] += k % 10;\r\n            k = k / 10;\r\n        }\r\n        while(k > 0){\r\n            num.insert(num.begin(), k % 10);\r\n            k /= 10;\r\n        }\r\n        int j = num.size() - 1;\r\n        while(j > 0){\r\n            if(num[j] >= 10){\r\n                num[j] -= 10;\r\n                num[j - 1]++;\r\n            }     \r\n            j--;\r\n        }\r\n        if(num[0] >= 10){\r\n            num[0] -= 10;\r\n            num.insert(num.begin(), 1);\r\n        }\r\n        return num;\r\n    }\r\n};\r\n\r\n```\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦O(n)\r\n- ç©ºé—´å¤æ‚åº¦O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186216657","body":"# æ€è·¯\nè›®åŠ›\n# ä»£ç \n```c++\nvector<int> shortestToChar(string s, char c) {\n        vector<int> ans;\n        vector<int> re;\n        for(int i = 0; i < s.length(); i++){\n            if(s[i] == c){\n                re.push_back(i);\n            }\n        }\n        int count = 0;\n        while(count < s.length()){\n            int min = INT_MAX;\n            for(int i = 0; i < re.size(); i++){\n                if(min > abs(re[i] - count)){\n                    min = abs(re[i] - count);\n                }\n            }\n            ans.push_back(min);\n            count++;\n        }\n        return ans;\n    }\n```\n**å¤æ‚åº¦**\n- æ—¶é—´O(n2)\n- ç©ºé—´O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186506125","body":"# ä»£ç \n```c++\nclass CustomStack {\npublic:\n\n    vector<int> res;\n    int top;\n\n    CustomStack(int maxSize) {\n        res.resize(maxSize);\n        top = -1;\n    }\n    \n    void push(int x) {\n        if(top != res.size() - 1){\n            top++;     \n            res[top] = x;\n        }\n    }\n    \n    int pop() {\n        if(top == -1){\n            return -1;\n        }\n        else{\n            top--;\n            return res[top + 1];\n        }\n    }\n    \n    void increment(int k, int val) {\n        for(int i = 0; i < k; i++){\n            if(i > top){\n                break;\n            }\n            res[i] += val;\n        }\n        return;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187051742","body":"# ä»£ç \n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<char> str;\n        stack<int> nums;\n        int i = 0;\n        while(i < s.length()){\n            int num = 0;\n            while(s[i] >= '0' && s[i] <= '9'){\n                num = num * 10 + (s[i] - '0');\n                i++;\n            }            \n            if(num != 0){\n                nums.push(num);\n            }\n            if(s[i] != ']'){\n                str.push(s[i]);\n            }\n            else{\n                int n = nums.top();\n                nums.pop();\n                string zifu = \"\";\n                string zifu1 = \"\";\n                while(str.top() != '['){\n                    zifu.insert(zifu.begin(), str.top());\n                    str.pop();\n                }\n                str.pop();\n                for(int i = 0; i < n; i++){\n                    zifu1 += zifu;\n                }\n                for(int i = 0; i < zifu1.length(); i++){\n                    str.push(zifu1[i]);\n                }\n            }\n            i++;\n        }\n        string ans = \"\";\n        while(!str.empty()){\n            ans.insert(ans.begin(), str.top());\n            str.pop();\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189123157","body":"# ä»£ç \n```c++\nclass MyQueue {\npublic:\n    stack<int> stk1;\n    stack<int> stk2;\n\n    MyQueue() {\n        \n    }\n    \n    void push(int x) {\n        while(!stk1.empty()){\n            stk2.push(stk1.top());\n            stk1.pop();\n        }\n        stk1.push(x);\n        while(!stk2.empty()){\n            stk1.push(stk2.top());\n            stk2.pop();\n        }\n    }\n    \n    int pop() {\n        int t = stk1.top();\n        stk1.pop();\n        return t;\n    }\n    \n    int peek() {\n        return stk1.top();\n    }\n    \n    bool empty() {\n        return stk1.empty();\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190456030","body":"# ä»£ç \n```c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int>maxStk;\n        maxStk.push(arr[0]);\n        for(int i=1;i<arr.size();i++){\n            if(arr[i]<maxStk.top()){\n                int maxNum=maxStk.top();\n                while(!maxStk.empty()&&maxStk.top()>arr[i])maxStk.pop();\n                maxStk.push(maxNum);\n            }\n            else maxStk.push(arr[i]);\n        }\n        return maxStk.size();\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191628634","body":"# ä»£ç \n```c++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        ListNode* fast = head;\n        ListNode* slow = head;\n        int count = 1;\n        if(head == nullptr){\n            return head;\n        }\n        while(fast -> next != nullptr){\n            count++;\n            fast = fast -> next;\n        }\n        fast = head;\n        for(int i = 0; i < count - (k % count); i++){\n            if(fast -> next == nullptr){\n                fast = head;\n            }\n            else{\n                fast = fast -> next;\n            }\n        }\n        ListNode* fast1 = fast;\n        for(int i = 0; i < count - 1; i++){\n            if(fast1 -> next != nullptr){\n                fast1 = fast1 -> next;\n            }\n            else{\n                fast1 -> next = slow;\n                fast1 = slow;\n            }\n        }\n        fast1 -> next = nullptr;\n        return fast;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192708179","body":"# ä»£ç \n```c++\nclass Solution {\npublic:    \n    ListNode* swapPairs(ListNode* head) {\n        ListNode* head0=new ListNode(0);\n        ListNode* head00=head0;\n        head0->next=head;\n        ListNode* head1=head;\n        ListNode* head2;\n        if(head==nullptr || head->next==nullptr){\n            return head;\n        }\n        while(head1!=nullptr && head1->next!=nullptr){\n            head2=head1->next;\n            head0->next=head1->next;\n            head1->next=head2->next;\n            head2->next=head1;\n            head0=head1;\n            head1=head1->next;\n        }\n        return head00->next;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193145505","body":"```c++\nclass Solution {\npublic:\n    ListNode* getMedian(ListNode* left, ListNode* right) {\n        ListNode* fast = left;\n        ListNode* slow = left;\n        while (fast != right && fast->next != right) {\n            fast = fast->next;\n            fast = fast->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n\n    TreeNode* buildTree(ListNode* left, ListNode* right) {\n        if (left == right) {\n            return nullptr;\n        }\n        ListNode* mid = getMedian(left, right);\n        TreeNode* root = new TreeNode(mid->val);\n        root->left = buildTree(left, mid);\n        root->right = buildTree(mid->next, right);\n        return root;\n    }\n\n    TreeNode* sortedListToBST(ListNode* head) {\n        return buildTree(head, nullptr);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193332811","body":"```c++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if (headA == nullptr || headB == nullptr) {\n            return nullptr;\n        }\n        ListNode *pA = headA, *pB = headB;\n        while (pA != pB) {\n            pA = pA == nullptr ? headB : pA->next;\n            pB = pB == nullptr ? headA : pB->next;\n        }\n        return pA;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194049011","body":"```c++\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *slow = head, *fast = head;\n        while (fast != nullptr) {\n            slow = slow->next;\n            if (fast->next == nullptr) {\n                return nullptr;\n            }\n            fast = fast->next->next;\n            if (fast == slow) {\n                ListNode *ptr = head;\n                while (ptr != slow) {\n                    ptr = ptr->next;\n                    slow = slow->next;\n                }\n                return ptr;\n            }\n        }\n        return nullptr;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195443181","body":"```c++\nstruct DLinkedNode {\n    int key, value;\n    DLinkedNode* prev;\n    DLinkedNode* next;\n    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}\n    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\nprivate:\n    unordered_map<int, DLinkedNode*> cache;\n    DLinkedNode* head;\n    DLinkedNode* tail;\n    int size;\n    int capacity;\n\npublic:\n    LRUCache(int _capacity): capacity(_capacity), size(0) {\n        // ä½¿ç”¨ä¼ªå¤´éƒ¨å’Œä¼ªå°¾éƒ¨èŠ‚ç‚¹\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head->next = tail;\n        tail->prev = head;\n    }\n    \n    int get(int key) {\n        if (!cache.count(key)) {\n            return -1;\n        }\n        // å¦‚æœ key å­˜åœ¨ï¼Œå…ˆé€šè¿‡å“ˆå¸Œè¡¨å®šä½ï¼Œå†ç§»åˆ°å¤´éƒ¨\n        DLinkedNode* node = cache[key];\n        moveToHead(node);\n        return node->value;\n    }\n    \n    void put(int key, int value) {\n        if (!cache.count(key)) {\n            // å¦‚æœ key ä¸å­˜åœ¨ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„èŠ‚ç‚¹\n            DLinkedNode* node = new DLinkedNode(key, value);\n            // æ·»åŠ è¿›å“ˆå¸Œè¡¨\n            cache[key] = node;\n            // æ·»åŠ è‡³åŒå‘é“¾è¡¨çš„å¤´éƒ¨\n            addToHead(node);\n            ++size;\n            if (size > capacity) {\n                // å¦‚æœè¶…å‡ºå®¹é‡ï¼Œåˆ é™¤åŒå‘é“¾è¡¨çš„å°¾éƒ¨èŠ‚ç‚¹\n                DLinkedNode* removed = removeTail();\n                // åˆ é™¤å“ˆå¸Œè¡¨ä¸­å¯¹åº”çš„é¡¹\n                cache.erase(removed->key);\n                // é˜²æ­¢å†…å­˜æ³„æ¼\n                delete removed;\n                --size;\n            }\n        }\n        else {\n            // å¦‚æœ key å­˜åœ¨ï¼Œå…ˆé€šè¿‡å“ˆå¸Œè¡¨å®šä½ï¼Œå†ä¿®æ”¹ valueï¼Œå¹¶ç§»åˆ°å¤´éƒ¨\n            DLinkedNode* node = cache[key];\n            node->value = value;\n            moveToHead(node);\n        }\n    }\n\n    void addToHead(DLinkedNode* node) {\n        node->prev = head;\n        node->next = head->next;\n        head->next->prev = node;\n        head->next = node;\n    }\n    \n    void removeNode(DLinkedNode* node) {\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n\n    void moveToHead(DLinkedNode* node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    DLinkedNode* removeTail() {\n        DLinkedNode* node = tail->prev;\n        removeNode(node);\n        return node;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"acoada":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185584460","body":"## æ€è·¯\n\n```raw\nres = []\nwhile (A or B):\n    a = A å½“å‰ä½\n    b = B å½“å‰ä½\n    \n    sum = a + b + è¿›ä½\n    \n    è¿›ä½, å½“å‰ä½ = divmod(sum, 10)\n    res.insert(0, å½“å‰ä½)\n\nå¦‚æœè¿˜æœ‰é 0 è¿›ä½ï¼Œ res.insert(0, carry)\n```\n\n## ä»£ç \n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res = []\n        idx, sum_, carry = len(num) -1, 0, 0\n        while idx >= 0 or k != 0:\n            a = num[idx] if idx >= 0 else 0\n            b = k % 10 if k else 0\n\n            sum_ = a + b + carry\n            carry, curr = divmod(sum_, 10)\n            idx -= 1\n            k //= 10\n            res.insert(0, curr)\n        if carry:\n            res.insert(0, carry)\n        return res\n```\n\n## å¤æ‚åº¦\n\n- Time: O(N)\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186206414","body":"## æ€è·¯\n\n1. æ‰¾åˆ°æ‰€æœ‰ `s` ä¸­ `c` çš„åæ ‡\n2. å¯¹äº `s` ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½è®¡ç®—å’Œæ‰€æœ‰ `c` çš„åæ ‡çš„è·ç¦»\n\n## ä»£ç \n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res = [None for _ in range(len(s))]\n        c_idxes = [idx for idx, i in enumerate(s) if i == c]\n\n        for idx, i in enumerate(s):\n            res[idx] = min( abs(idx - c_idx) for c_idx in c_idxes)\n        \n        return res\n```\n\n## å¤æ‚åº¦\n\n- Time: O(N)\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186546673","body":"## æ€è·¯\n\næŒ‰é¢˜ä¹‰æ¨¡æ‹Ÿå³å¯\n\n## ä»£ç \n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self._storage = []\n        self._room = maxSize\n\n    def push(self, x: int) -> None:\n        if self._room > 0:\n            # got room to store element\n            self._storage.append(x)\n            self._room -= 1\n        \n    def pop(self) -> int:\n        try:\n            res = self._storage.pop()\n        except IndexError:\n            return -1\n        else:\n            self._room += 1\n        return res\n\n    def increment(self, k: int, val: int) -> None:\n        for idx in range(len(self._storage[:k])):\n            self._storage[idx] += val\n```\n\n## å¤æ‚åº¦\n\n- Time: O(N)\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187612588","body":"## æ€è·¯\n\næ ˆçš„åº”ç”¨ã€‚\n\n## ä»£ç \n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for i in s:\n            if i != \"]\":\n                # keep pushing char into stack until the end `]`\n                stack.append(i)\n            else:\n                lookback = []\n                while (c := stack.pop()) != \"[\":\n                    lookback.append(c)\n                lookback = \"\".join(lookback[::-1])\n                repeat_time = []\n                try:\n                    while (c := stack.pop()) in \"0123456789\":\n                        repeat_time.append(c)\n                except IndexError:\n                    pass\n                else:\n                    # well, c is not number for now, put it back\n                    stack.append(c)\n                repeat_time = int(\"\".join(repeat_time[::-1]))\n                stack.append(repeat_time * lookback)\n\n        return \"\".join(stack)\n```\n\n## å¤æ‚åº¦\n\n- Time: O(N)\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189195523","body":"## æ€è·¯\n\nåŸºç¡€æ•°æ®ç»“æ„ï¼Œæ¨¡æ‹Ÿå³å¯ã€‚\n\n## ä»£ç \n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.in_ = []\n        self.out = []\n\n    @staticmethod\n    def _switch(source, target):\n        while source:\n            target.append(source.pop())\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        # out -> in_\n        self._switch(self.out, self.in_)\n        self.in_.append(x)\n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        # in_ -> out\n        self._switch(self.in_, self.out)\n        return self.out.pop()\n\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        # in_ -> out\n        self._switch(self.in_, self.out)\n        return self.out[-1]\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return len(self.in_) + len(self.out) == 0\n```\n\n## å¤æ‚åº¦\n\n- Time: O(1) (æ‘Šè¿˜åˆ†æä¸‹æ˜¯ O(1)ï¼Œæœ€å·® O(N))\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190456694","body":"## æ€è·¯\n\né¢˜ç›®æ¯”è¾ƒæŠ½è±¡ï¼Œä¸¾ä¸€ä¸ªğŸŒ°ï¸  \n\nè¾“å…¥ `arr := [2, 1, 3, 4, 4]`  \n\n1. åˆ‡åˆ†æˆè‹¥å¹²ä»½  `[2, 1]`, `[3, 4]`, `[4]`  \n2. æ¯ä¸€ä»½ç‹¬ç«‹æ’åº `[1, 2]`, `[3, 4]`, `[4]`\n3. å°†ä¸Šé¢å¾—åˆ°çš„ç»„ä»¶æ‹¼èµ·æ¥ `res := [1, 2, 3, 4, 4]`\n\nåœ¨ä¿è¯ `sorted(arr) == res` çš„å‰æä¸‹ï¼Œä¸Šé¢ç¬¬ 1 æ­¥ï¼Œæœ€å¤šèƒ½åˆ‡å¤šå°‘å—å‡ºæ¥ï¼Ÿ  \n\næœ‰ç‚¹ç±»ä¼¼æ¡¶æ’åº/è®¡æ•°æ’åºï¼š\n\nå°†åŸæ•°ç»„å’Œæ•´ä½“æ’å¥½åºçš„æ•°ç»„å¹¶æ’(zip)åœ¨ä¸€èµ·å‘å‰éå†ï¼Œæ£€æŸ¥ `arr[:i]` å’Œ `sorted_arr[:i]` æ˜¯å¦**è®¡æ•°**ä¸€è‡´ï¼Œæ˜¯åˆ™å¯å¤šåˆ‡ä¸€å— (`res +=1`)ã€‚\n\n## ä»£ç \n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr):\n        res = 0\n        c1 = Counter()\n        c2 = Counter()\n        for a, b in zip(arr, sorted(arr)):\n            c1[a] += 1\n            c2[b] += 1\n            if c1 == c2:\n                res += 1\n        return res\n```\n\n## å¤æ‚åº¦\n\n- Time: O(N^2)\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191632864","body":"## æ€è·¯\n\næ¨¡æ‹Ÿæ“ä½œï¼šå…ˆç»„åˆæˆç¯ï¼Œå†ç§»åŠ¨æŒ‡é’ˆåœ¨åˆé€‚çš„åœ°æ–¹æ–­å¼€ã€‚\n\n## ä»£ç \n\n```python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        # ç±»ä¼¼ itertools.cycle\n        if k == 0 or head is None:\n            return head\n\n        tail = head\n        n = 1\n        while tail.next is not None:\n            # æ‰¾åˆ°å°¾å·´\n            tail = tail.next\n            n += 1\n    \n        # å·èµ·æ¥ï¼\n        tail.next = head\n        add = n - k % n\n        while add > 0:\n            head = head.next\n            tail = tail.next\n            add -= 1\n        # æ–­å¼€\n        tail.next = None\n        return head\n```\n\n## å¤æ‚åº¦\n\n- Time: O(N)\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192702476","body":"## æ€è·¯\n\nç”»å›¾æ¨¡æ‹Ÿï¼Œç©¿é’ˆå¼•çº¿ã€‚\n\n## ä»£ç \n\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        dummy = ListNode(next=head)\n        prev, curr = dummy, head\n        while curr and curr.next:\n            # save pointers\n            next_pair = curr.next.next\n            second = curr.next\n            # reverse pair\n            second.next = curr\n            curr.next = next_pair\n            prev.next = second\n            # update pointers\n            prev = curr\n            curr = next_pair\n        return dummy.next\n```\n\n## å¤æ‚åº¦\n\n- Time: O(N)\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193143972","body":"## æ€è·¯\n\nBST çš„ä¸­åºéå†ç»“æœæ˜¯æœ‰åºæ•°ç»„ï¼Œæ˜¯ä¸€ç§å°†æœ‰å±‚çº§çš„æ ‘çŠ¶ç»“æ„å‹æ‰æˆä¸€ç»´æ•°ç»„ï¼›\n\nå°†æœ‰åºé“¾è¡¨ã€Œè¿˜åŸæˆã€BST å°±ç›¸å½“äºå†æ¢å¤æ ‘çŠ¶å±‚çº§ç»“æ„ï¼š\n\n1. å…ˆæ‰¾åˆ°ä¸­ç‚¹ï¼Œå°±æ˜¯ BST çš„ root\n2. å†æ‰¾åˆ°å·¦åŠéƒ¨ä»½çš„ä¸­ç‚¹ï¼Œå°±æ˜¯ root.leftï¼Œç±»ä¼¼åœ°å¯ä»¥æ‰¾åˆ° root.right\n3. é€’å½’\n\nè€Œæ‰¾ä¸­ç‚¹çš„è¿‡ç¨‹å¯ä»¥ç”¨==å¿«æ…¢æŒ‡é’ˆ==ã€‚\n\n## ä»£ç \n\n```python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:        \n        if not head:\n            return head\n        if not head.next:\n            return  TreeNode(head.val)\n        pre, slow, fast = None, head, head\n        while fast and fast.next:\n            pre = slow\n            slow = slow.next\n            fast = fast.next.next\n        pre.next = None\n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        return root\n```\n\n## å¤æ‚åº¦\n\n- Time: O(NlogN)\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193340193","body":"## æ€è·¯\n\næ–¹æ³•1: åˆ©ç”¨ hashtable\n\n## ä»£ç \n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        A = set()\n        while headA:\n            A.add(headA)\n            headA = headA.next\n        while headB:\n            if headB in A:\n                return headB\n            headB = headB.next\n        return None\n```\n\n## å¤æ‚åº¦\n\n- Time: O(m + n)\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194168679","body":"## æ€è·¯\n\nå¿«æ…¢æŒ‡é’ˆã€‚\n\n## ä»£ç \n\n```python\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast, slow = head, head\n        \n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast is slow:\n                break\n        else:\n          \t# æ ¹æœ¬æ²¡å‘ç°ç¯\n            return None\n\n        fast = head\n        while fast is not slow:\n            fast = fast.next\n            slow = slow.next\n        return fast\n```\n\n## å¤æ‚åº¦\n\n- Time: O(N)\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195580546","body":"## æ€è·¯\n\nç›´æ¥ç»§æ‰¿ Python å†…ç½®çš„ OrderedDict\n\n## ä»£ç \n\n```python\nclass LRUCache(OrderedDict):\n\n    def __init__(self, capacity: int):\n        super().__init__()\n        self.capacity = capacity\n\n\n    def get(self, key: int) -> int:\n        if key not in self:\n            return -1\n        self.move_to_end(key)          # æ³¨æ„è¿™é‡Œæ˜¯å°†æœ€è¿‘å…ƒç´ æ”¾åˆ°å°¾å·´äº†\n        return self[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self:\n            self.move_to_end(key)\n        self[key] = value\n        if len(self) > self.capacity:\n            self.popitem(last=False)   # å¯¹åº”çš„ï¼Œåˆ é™¤å°±ä»å¤´éƒ¨åˆ \n```\n\n## å¤æ‚åº¦\n\n- Time: O(1)\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196772116","body":"## æ€è·¯\n\næ‰€æœ‰èŠ‚ç‚¹ä¸­æœ€å¤§çš„æ·±åº¦(depth)å°±æ˜¯æ ‘çš„é«˜åº¦\n\n## ä»£ç \n\n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n```\n\n## å¤æ‚åº¦\n\n- Time: O(N)\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198789020","body":"## æ€è·¯\r\n\r\né€ä¸ªæ¯”è¾ƒ TreeNode çš„æ¯ä¸ªå±æ€§ï¼Œçœ‹æ˜¯å¦ä¸€è‡´ï¼š\r\n\r\n1. val æ˜¯å¦ä¸€è‡´\r\n2. left æ˜¯å¦ä¸€è‡´\r\n3. right æ˜¯å¦ä¸€è‡´\r\n\r\nleft å’Œ right éƒ½æ˜¯é€’å½’å®šä¹‰çš„ï¼Œæ‰€ä»¥ä¹Ÿè¦é€’å½’çš„åˆ¤æ–­\r\n\r\n\r\n## ä»£ç \r\n\r\n```python\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if p is None and q is None:\r\n            return True\r\n        if None in (p, q):\r\n            # åªæœ‰ä¸€ä¸ªæ˜¯ None\r\n            return False\r\n        if p.val != q.val: \r\n            return False\r\n        if not self.isSameTree(p.left, q.left):\r\n            return False\r\n        if not self.isSameTree(p.right, q.right):\r\n            return False\r\n        return True\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n- Time: O(N)\r\n- Space: O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199343955","body":"## æ€è·¯\n\næšä¸¾å‡ºæ‰€æœ‰ root -> leaf çš„ pathï¼Œç„¶åæ±‚å’Œ\n\n\n## ä»£ç \n\n```python\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        nums = []\n\n        def dfs(root, path):\n            if root is None:\n                return\n            path.append(root.val)\n            if root.left is None and root.right is None:\n                # LEAF\n                num = int(\"\".join([str(p) for p in path]))\n                nums.append(num)\n            if root.left:\n                dfs(root.left, path)\n            if root.right:\n                dfs(root.right, path)\n            path.pop()\n        \n        dfs(root, [])\n        return sum(nums)\n```\n\n## å¤æ‚åº¦\n\n- Time: O(N)\n- Space: O(H)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200168777","body":"## æ€è·¯\n\nå±‚åºéå†ï¼Œè¿”å›æœ€åä¸€å±‚æœ€å·¦è¾¹çš„èŠ‚ç‚¹å³å¯\n\n## ä»£ç \n\n```python\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        res = None\n        queue = Deque([root])\n        while queue:\n            res = queue[0]\n            for _ in range(len(queue)):\n                node = queue.popleft()\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        return res.val if res else None\n```\n\n## å¤æ‚åº¦\n\n- Time: O(N)\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200442835","body":"## æ€è·¯\n\npreorder + DFS\n\n## ä»£ç \n\n```python\nclass Codec:\n    def serialize(self, root):\n        res = []\n        def dfs(node):\n            if not node:\n                res.append(\"N\")\n                return\n            res.append(str(node.val))\n            dfs(node.left)\n            dfs(node.right)\n        dfs(root)\n        return \",\".join(res)\n\n    def deserialize(self, data):\n        vals = data.split(\",\")\n        self.i = 0\n        \n        def dfs():\n            if vals[self.i] == \"N\":\n                self.i += 1\n                return None\n            node = TreeNode(int(vals[self.i]))\n            self.i += 1\n            node.left = dfs()\n            node.right = dfs()\n            return node\n        return dfs()\n```\n\n## å¤æ‚åº¦\n\n- Time: O(N)\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201346319","body":"## æ€è·¯\n\næ¨¡æ‹Ÿæ“ä½œå³å¯ã€‚\n\n## ä»£ç \n\n```python\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        if not root:\n            return []\n      \n        res = []\n        stack = [(0, 0, root)]\n\n        # éå†\n        while stack:\n            x, y, cur = stack.pop()\n            res.append((x, y, cur.val))\n\n            if cur.left:\n                stack.append((x -1, y + 1, cur.left))\n            if cur.right:\n                stack.append((x +1, y + 1, cur.right))\n        \n        ans = []\n        last_level = None\n        for i in sorted(res):\n            level = i[0]\n            if level != last_level:\n                # åˆ›å»ºæ–°çš„ã€Œåˆ†ç»„ã€\n                ans.append([i[-1]])\n                last_level = level\n            else:\n                # append åˆ°æœ€æ–°çš„ã€Œåˆ†ç»„ã€ä¸­\n                ans[-1].append(i[-1])\n\n        return ans\n```\n\n## å¤æ‚åº¦\n\n- Time: O(NlogN)\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202003599","body":"## æ€è·¯\n\nhashtable\n\n## ä»£ç \n\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        if not nums:\n            return []\n\n        lookup = {}\n        for idx, a in enumerate(nums):\n            b = target - a\n            if b in lookup:\n                return [idx, lookup[b]]\n            else:\n                lookup[a] = idx\n        \n        return []\n```\n\n## å¤æ‚åº¦\n\n- Time: O(N)\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203364069","body":"## æ€è·¯\n\næ¡¶æ’åº\n\n## ä»£ç \n\n```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        buckets = [[] for _ in range(len(nums))]\n\n        for num, freq in Counter(nums).items():\n            # freq - 1, because buckets list index starts from 0\n            # but counter, starts from 1ã€‚è®¡æ•°æ˜¯ä» 1 å¼€å§‹ï¼Œ0 å°±ä¸ä¼šè¢«æ•°åˆ°\n            buckets[freq-1].append(num)\n        \n        ans = []\n        for li in buckets[::-1]:\n            for num in li:\n                ans.append(num)\n                if len(ans) == k:\n                    return ans\n```\n\n## å¤æ‚åº¦\n\n- Time: O(NlogN)\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205445430","body":"## æ€è·¯\n\nhashtable\n\n## ä»£ç \n\n```python\nclass Solution:\n    def numberOfBoomerangs(self, points):\n        n = 0\n        for a,b in points:\n            counter = {}\n            for x,y in points:\n                dist = sqrt((x-a)**2 + (y-b)**2)\n                if dist in counter:\n                    n += 2*counter[dist]\n                    counter[dist] += 1\n                else:\n                    counter[dist] = 1\n        return n\n```\n\n## å¤æ‚åº¦\n\n- Time: O(N^2)\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206598606","body":"## æ€è·¯\n\nä¸€æ¬¡éå†ï¼Œéå†è¿‡ç¨‹ä¸­:\n\n- ç”¨ hash è®°ä½å½“å‰å­—ç¬¦å’Œ idxã€‚å‘ç°æ—§è®°å½•å°±æ›´æ–°ï¼ŒåŒæ—¶æ›´æ–° left ç´¢å¼•ï¼ˆçª—å£å·¦æ²¿ï¼‰\n- æ£€æŸ¥å½“å‰å­—ç¬¦ï¼ˆaka çª—å£å³æ²¿ï¼‰åˆ°çª—å£å·¦æ²¿ï¼ˆæ¥è‡ª leftï¼‰çš„é•¿åº¦ï¼ˆaka çª—å£å…¨é•¿ï¼‰\n\n## ä»£ç \n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        if not s:\n            return 0\n        \n        win = {}\n        left = 0\n        max_len = 0\n\n        for idx, c in enumerate(s):\n            if c in win:\n                left = max(win.get(c) + 1, left)\n            \n            win[c] = idx\n            max_len = max(max_len, idx + 1 - left)\n        return max_len\n```\n\n## å¤æ‚åº¦\n\n- Time: O(N)\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207237696","body":"## æ€è·¯\n\nhashtable + sliding window\n\n## ä»£ç \n\n```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        if len(words) == 0 or len(words[0]) == 0:\n            return []\n\n        word_freq = {}\n\n        for word in words:\n            if word not in word_freq:\n                word_freq[word] = 0\n            word_freq[word] += 1\n\n        res = []\n        words_count = len(words)\n        word_length = len(words[0])\n\n        for i in range((len(s) - words_count * word_length) + 1):\n            seen = {}\n            for j in range(0, words_count):\n                next_word_idx = i + j * word_length\n                word = s[next_word_idx: next_word_idx + word_length]\n                if word not in word_freq:\n                    break\n\n                if word not in seen:\n                    seen[word] = 0\n                seen[word] += 1\n\n                if seen[word] > word_freq.get(word, 0):\n                    break\n\n                if j + 1 == words_count:\n                    res.append(i)\n            return res\n```\n\n## å¤æ‚åº¦\n\n- Time: O(M*N)\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207435296","body":"## æ€è·¯\n\nhash + prefix\n\nå‡è®¾åŸæ•°ç»„é™¤ä»¥ K çš„ä½™æ•°æ˜¯ Rï¼Œè¦æ±‚åˆ é™¤ subarray ä¹‹åå‰©ä½™æ•°ç»„ä¹‹å’Œé™¤ä»¥ K ä½™æ•°ä¸º 0ï¼Œè¯´æ˜å¾…åˆ é™¤çš„ subarray æœ¬èº«ä¹‹å’Œé™¤ä»¥ K çš„ä½™æ•°å°±æ˜¯ Rï¼š\n\nä¾‹å¦‚ {1, 6, 11, 16} mod 5 éƒ½æ˜¯ 1\n\n## ä»£ç \n\n```python\nclass Solution:\n    def solve(self, nums, k)\n        res = n = len(nums)\n        mod = sum(nums) % k\n        if mod == 0: \n            return 0\n        hashtable = {0: -1}\n        sub_mod = 0\n        for i, num in enumerate(nums):\n            sub_mod = (sub_mod + num) % k\n            target = (sub_mod - mod + k) % k\n            if target in hashtable:\n                res = min(res, i - hashtable[target])\n                if res == 1 and res != n:\n                    return res\n            hashtable[sub_mod] = i\n        if res == n:\n            res = -1\n        return res\n```\n\n## å¤æ‚åº¦\n\n- Time: O(N)\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208192938","body":"## æ€è·¯\n\nå¿«æ…¢æŒ‡é’ˆ\n\n## ä»£ç \n\n```python\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        fast, slow = head, head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        \n        return slow\n```\n\n## å¤æ‚åº¦\n\n- Time: O(N)\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209512871","body":"## æ€è·¯\n\né‡åˆ°é‡å¤çš„å…ƒç´ çš„æ—¶å€™ï¼Œå°†å®ƒæ ‡è®°ä¸ºå·²åˆ é™¤ï¼Œé‡åˆ°ä¸‹ä¸€ä¸ªæ–°å…ƒç´ å°±æŠŠå®ƒç§»åŠ¨åˆ°æ ‡è®°ä¸ºå·²åˆ é™¤çš„ä½å­ä¸Šã€‚\n\n## ä»£ç \n\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        n = len(nums)\n\n        next_free_slot = 1\n\n        for i in range(1, n):\n            if nums[next_free_slot-1] != nums[i]:\n                nums[next_free_slot] = nums[i]\n                next_free_slot += 1\n        \n        return next_free_slot\n```\n\n## å¤æ‚åº¦\n\n- Time: O(N)\n- Space: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duanyaqi":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185585215","body":"# Day 1. [989. æ•°ç»„å½¢å¼çš„æ•´æ•°åŠ æ³•](https://leetcode.cn/problems/add-to-array-form-of-integer/)\r\n## æ€è·¯\r\nåŠ æ³•æœ‰ä»¥ä¸‹å…¬å¼ï¼š\r\n\r\nå½“å‰ä½ = (A çš„å½“å‰ä½ + B çš„å½“å‰ä½ + è¿›ä½carry) % 10   \r\n\r\nç›´æ¥éå†ç›¸åŠ å³å¯ï¼Œä¿å­˜ carryï¼Œæœ€åæœ‰ carry é¢å¤–åŠ  1ï¼Œä»å°åˆ°å¤§åŠ ï¼Œæœ€åä¿å­˜çš„ç»“æœè¦ç¿»è½¬\r\n- åŠ¨æ€æ•°ç»„éå†æ•°ç»„\r\n- int æ•°å­— `%10` å–æœ€ä½ä½ï¼Œ`/10` ä¸ºäº†éå†ä¸‹ä¸€ä¸ªæœ€ä½ä½\r\n\r\n```c++\r\nvector<int> addToArrayForm(vector<int>& num, int k) {\r\n    int carry = 0; \r\n    vector<int> res;\r\n    \r\n    // éå†æ•°ç»„ï¼Œè¿›è¡ŒåŠ \r\n    for (int i = num.size() - 1; i >= 0; --i) {\r\n        int kn = k % 10;\r\n        k /= 10;\r\n\r\n        int sumn = kn + num[i] + carry;  //å…³é”®å…¬å¼!!!\r\n\r\n        res.push_back(sumn % 10);\r\n        if (sumn >= 10) {\r\n            carry = 1;\r\n        } else {\r\n            carry = 0;\r\n        }\r\n    }\r\n\r\n    // å¦‚æœ k è¿˜æ²¡å¤„ç†å®Œï¼Œç»§ç»­å¤„ç† k\r\n    while (k > 0) {\r\n        int kn = k % 10;\r\n        k /= 10;\r\n\r\n        int sumn = kn + carry; //å…³é”®å…¬å¼!!! æ­¤æ—¶ num[i] å·²ç»æ˜¯ 0 äº†\r\n\r\n        res.push_back(sumn % 10);\r\n        if (sumn >= 10) {\r\n            carry = 1;\r\n        } else {\r\n            carry = 0;\r\n        }\r\n    }\r\n\r\n    if (carry == 1) res.push_back(1);\r\n    reverse(res.begin(), res.end());\r\n\r\n    return res;\r\n}\r\n```\r\n> + æ—¶é—´å¤æ‚åº¦: O(max(n,logk))\r\n> + ç©ºé—´å¤æ‚åº¦: O(1)ï¼Œå¸¸æ•°çº§åˆ«ï¼Œåªæœ‰res\r\n\r\n\r\n## ä¼˜åŒ–\r\n\r\nå‘ç°ä¸¤ä¸ªå¾ªç¯å…¶å®æ˜¯ä¸€æ ·çš„ï¼Œå¯ä»¥æ”¾åœ¨ä¸€èµ·å¤„ç†\r\n\r\n```c++\r\nvector<int> addToArrayForm(vector<int>& num, int k) {\r\n    int carry = 0;\r\n        \r\n    vector<int> res;\r\n    int i = num.size() - 1;\r\n    // æ”¾åˆ°ä¸€èµ·å¤„ç†, å¦‚æœæœ‰ä¸€ä¸ªå˜æˆ 0, sumn è¿™é‡Œå°±ç›¸å½“äº + 0\r\n    while (i >= 0 || k > 0) {\r\n        int a = i < 0 ? 0 : num[i];\r\n        int kn = k == 0 ? 0 : k % 10;\r\n        k /= 10;\r\n\r\n        int sumn = a + kn + carry;\r\n\r\n        res.push_back(sumn % 10);\r\n        if (sumn >= 10) {\r\n            carry = 1;\r\n        } else {\r\n            carry = 0;\r\n        }\r\n        i--;\r\n    }\r\n\r\n    // å¦‚æœæœ‰è¿›ä½\r\n    if (carry == 1) res.push_back(1);\r\n    reverse(res.begin(), res.end());\r\n\r\n    return res;\r\n}\r\n```\r\n\r\næ²¡å˜åŒ–\r\n> + æ—¶é—´å¤æ‚åº¦: O(max(n,logk))\r\n> + ç©ºé—´å¤æ‚åº¦: O(1)ï¼Œå¸¸æ•°çº§åˆ«ï¼Œåªæœ‰res\r\n\r\n\r\n## æ¨¡æ¿\r\n\r\nåŠ æ³•æ¨¡æ¿\r\n```c++\r\nwhile ( A æ²¡å®Œ || B æ²¡å®Œ)\r\n    A çš„å½“å‰ä½\r\n    B çš„å½“å‰ä½\r\n\r\n    å’Œ = A çš„å½“å‰ä½ + B çš„å½“å‰ä½ + è¿›ä½carry\r\n\r\n    å½“å‰ä½ = å’Œ % 10;\r\n    è¿›ä½ = å’Œ / 10;\r\nend\r\n\r\nåˆ¤æ–­è¿˜æœ‰è¿›ä½å—\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186090818","body":"# Day 2. [821. å­—ç¬¦çš„æœ€çŸ­è·ç¦»](https://leetcode.cn/problems/shortest-distance-to-a-character/)\r\n## æ€è·¯\r\n\r\næš´åŠ›\r\n\r\n- æ‰¾å‡ºæ¥æ‰€æœ‰å­—ç¬¦cçš„ä½ç½®\r\n- æ¯ä¸ªä½ç½®éƒ½ä¸sçš„æ¯ä¸ªå­—ç¬¦è®¡ç®—è·ç¦», æ›´æ–°æœ€å°å€¼\r\n\r\n```c++\r\nvector<int> shortestToChar(string s, char c) {\r\n    vector<int> res(s.size(), 0x3f3f3f3f);\r\n\r\n    vector<int> cset;\r\n\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        if (s[i] == c) \r\n            cset.push_back(i);\r\n    }\r\n\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        for (int j = 0; j < cset.size(); ++j) {\r\n            res[i] = min(res[i], abs(i - cset[j]));\r\n        }\r\n    }\r\n\r\n    return res;\r\n}\r\n```\r\n> + æ—¶é—´å¤æ‚åº¦: O(mn), mæ˜¯cçš„ä¸ªæ•°, n æ˜¯sçš„é•¿åº¦\r\n> + ç©ºé—´å¤æ‚åº¦: O(m + n)\r\n\r\n\r\n## ä¼˜åŒ–\r\n\r\nbfs + åˆ¤æ–­ (ä¸»è¦å¥½ä¹…æ²¡å†™bfsäº†, ç»ƒç»ƒæ‰‹)\r\n\r\n\r\n```c++\r\nvector<int> shortestToChar(string s, char c) {\r\n    vector<int> res(s.size(), 0x3f3f3f3f);\r\n\r\n    queue<int> q;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        if (s[i] == c) {\r\n            q.push(i);\r\n        }\r\n    }\r\n\r\n    while (q.size()) {\r\n        int idx = q.front(); q.pop();\r\n\r\n        for (int i = 0; i < s.size(); ++i) {\r\n            int dis = abs(i - idx);\r\n            if (res[i] > dis) {\r\n                res[i] = dis;\r\n            }\r\n        }\r\n    }\r\n    \r\n\r\n    return res;\r\n}\r\n```\r\n\r\n\r\n> + æ—¶é—´å¤æ‚åº¦: O(mn)\r\n> + ç©ºé—´å¤æ‚åº¦: O(m + n)\r\n\r\n\r\n## æ¨¡æ¿\r\n\r\nbfs è¿­ä»£æ¨¡æ¿\r\n```c++\r\nqueue<int> q;\r\n// q.push(i);\r\nwhile (q.size()) {\r\n    int idx = q.front(); q.pop();\r\n\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        int dis = abs(i - idx);\r\n        if (res[i] > dis) {\r\n            res[i] = dis;\r\n            //q.push(i);\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186457659","body":"# Day 3. [1381. è®¾è®¡ä¸€ä¸ªæ”¯æŒå¢é‡æ“ä½œçš„æ ˆ](https://leetcode.cn/problems/design-a-stack-with-increment-operation/)\r\n## æ€è·¯\r\n\r\nç›´æ¥ç”¨ stack æ¨¡æ‹Ÿ\r\n\r\n- increment çš„æ—¶å€™ï¼Œéœ€è¦ç”¨ä¸€ä¸ªè¾…åŠ©æ ˆï¼Œè®¡ç®—å‡ºéœ€è¦ +val çš„è¾¹ç•Œ `int remain = max(0, (int)(mSt.size() - k));`\r\n\r\n```c++\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) : mMaxSize(maxSize) {\r\n\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (mSt.size() < mMaxSize) {\r\n            mSt.push(x);\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (mSt.size() == 0) return -1;\r\n        int num = mSt.top(); mSt.pop();\r\n        return num;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        stack<int> mStTmp;\r\n        int remain = max(0, (int)(mSt.size() - k));    // ä¸åŠ çš„ä¸ªæ•°\r\n\r\n        while (remain) {                        // æŠŠä¸åŠ  val çš„æ•°å­—ç»™è·³è¿‡å»\r\n            mStTmp.push(mSt.top()); mSt.pop();\r\n            remain--;\r\n        }\r\n\r\n        while (mSt.size()) {                    // æŠŠå‰©ä¸‹çš„ mSt é‡Œçš„å…ƒç´  + val\r\n            mStTmp.push(mSt.top() + val); mSt.pop();\r\n        }\r\n\r\n        while (mStTmp.size()) {                 // \r\n            mSt.push(mStTmp.top()); mStTmp.pop();\r\n        }\r\n    }\r\n\r\nprivate:\r\n    int mMaxSize;\r\n    stack<int> mSt;\r\n};\r\n```\r\n> + æ—¶é—´å¤æ‚åº¦: O(n)\r\n> + ç©ºé—´å¤æ‚åº¦: O(n)\r\n\r\n----\r\n\r\n## ä¼˜åŒ–\r\n\r\nç›´æ¥ç”¨æ•°ç»„æ¨¡æ‹Ÿæ ˆå°±å¥½äº†ï¼Œå¯¹æ ˆåº•å…ƒç´ å¥½å¤„ç†\r\n\r\n```c++\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) : mMaxSize(maxSize) {\r\n\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (mVec.size() < mMaxSize) {\r\n            mVec.push_back(x);\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (mVec.size() == 0) return -1;\r\n        int num = mVec.back(); mVec.erase((--mVec.end()));\r\n        return num;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        for (int i = 0; i < min(k, (int)mVec.size()); ++i) \r\n            mVec[i] += val;\r\n    }\r\n\r\nprivate:\r\n    int mMaxSize;\r\n    vector<int> mVec;\r\n};\r\n```\r\n\r\n\r\n> + æ—¶é—´å¤æ‚åº¦: O(n)\r\n> + ç©ºé—´å¤æ‚åº¦: O(n)\r\n\r\n----\r\n\r\n## è´Ÿä¼˜åŒ–\r\n\r\nå»é™¤ç¹ççš„ eraseï¼Œç›´æ¥ç”¨ `top` è¡¨ç¤ºæ ˆé¡¶ä½ç½®\r\n\r\n```c++\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) : mMaxSize(maxSize) {\r\n        mVec.resize(maxSize);\r\n        top = -1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (top < mMaxSize - 1) {\r\n            ++top;\r\n            mVec[top] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (top == -1) return -1;\r\n        int num = mVec[top]; \r\n        --top;\r\n        return num;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        for (int i = 0; i < min(k, top+1); ++i) \r\n            mVec[i] += val;\r\n    }\r\n\r\nprivate:\r\n    int mMaxSize;\r\n    int top;        // è¡¨ç¤ºæ ˆé¡¶\r\n    vector<int> mVec;\r\n};\r\n```\r\n> + æ—¶é—´å¤æ‚åº¦: O(n)\r\n> + ç©ºé—´å¤æ‚åº¦: O(n)\r\n\r\n---\r\n## ç©¶æä¼˜åŒ–\r\n\r\n- åªæœ‰åœ¨ pop æ“ä½œæ—¶ï¼Œæˆ‘ä»¬æ‰éœ€è¦çŸ¥é“æ ˆé¡¶å…ƒç´ çš„å…·ä½“å€¼ï¼Œåœ¨å…¶ä½™çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬åªè¦å­˜å‚¨æ¯ä¸ªå…ƒç´ çš„å¢é‡å°±è¡Œäº†ã€‚\r\n- å› æ­¤åœ¨é‡åˆ° pop æ“ä½œæ—¶ï¼Œæˆ‘ä»¬è¿”å›æ ˆé¡¶å…ƒç´ çš„åˆå§‹å€¼åŠ ä¸Šå¢é‡ add[top]ã€‚\r\n- `add[i]` è¡¨ç¤ºå‰ i - 1 ä¸ªå…ƒç´ çš„å¢é‡\r\n\r\n```c++\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) : mMaxSize(maxSize) {\r\n        mVec.resize(maxSize);\r\n        mInc.resize(maxSize);\r\n        top = -1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (top < mMaxSize - 1) {\r\n            ++top;\r\n            mVec[top] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (top == -1) return -1;\r\n        int num = mVec[top] + mInc[top]; \r\n        if (top > 0) {\r\n            mInc[top - 1] += mInc[top];\r\n        }\r\n        mInc[top] = 0;\r\n        --top;\r\n        return num;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int idx = min(k - 1, top); \r\n        \r\n        if (idx >= 0)   // top å¯èƒ½æ˜¯ -1\r\n            mInc[idx] += val;\r\n    }\r\n\r\nprivate:\r\n    int mMaxSize;\r\n    int top;        // è¡¨ç¤ºæ ˆé¡¶\r\n    vector<int> mVec, mInc; //mInc[i] è¡¨ç¤ºä¸‹æ ‡<=içš„å…ƒç´ çš„å¢é‡\r\n};\r\n```\r\n> + æ—¶é—´å¤æ‚åº¦: O(1)\r\n> + ç©ºé—´å¤æ‚åº¦: O(1)\r\n\r\n\r\n\r\n## æ¨¡æ¿\r\n\r\næ— æ¨¡æ¿","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187637162","body":"# Day 4. [394. å­—ç¬¦ä¸²è§£ç ](https://leetcode.cn/problems/decode-string/)\r\n## æ€è·¯\r\n\r\né€’å½’è§£æè¡¨è¾¾å¼ï¼Œç¼–è¯‘åŸç†ï¼Œç¬¦åˆ LL(1) æ–‡æ³•\r\n- ä»å·¦å‘å³åˆ†æï¼ˆLeft-to-right-parseï¼‰\r\n- æœ€å·¦æ¨å¯¼ï¼ˆLeftmost-derivationï¼‰\r\n- è¶…å‰æŸ¥çœ‹ä¸€ä¸ªç¬¦å·ï¼ˆ1-symbol lookaheadï¼‰\r\n\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int getDigit() {\r\n        int res = 0;\r\n        while (ptr < src.size() && isdigit(src[ptr])) {\r\n            res = res * 10 + src[ptr] - '0';\r\n            ptr++;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    string getString() {    \r\n        if (ptr == src.size() || src[ptr] == ']') {\r\n            return \"\";  //String -> eps\r\n        }\r\n\r\n        string res;             // æœ€åè¿”å›çš„ç»“æœ\r\n        char cur = src[ptr];    // pträ¸‹æ ‡çš„å­—ç¬¦\r\n\r\n        if (isdigit(cur)) {\r\n            // String -> Digits[String] String\r\n            // è§£æ Digits \r\n            int times = getDigit(); //å­—ç¬¦ä¸²ä¹˜çš„æ¬¡æ•°\r\n            // è¿‡æ»¤å·¦æ‹¬å·\r\n            ++ptr;\r\n            // è§£æ string\r\n            string str = getString();\r\n            // è¿‡æ»¤å³æ‹¬å·\r\n            ++ptr;\r\n            // å­—ç¬¦ä¸²ç´¯ä¹˜\r\n            while(times--) \r\n                res += str;\r\n        } else if (isalpha(cur)) {\r\n            // String -> Alpha String\r\n            // è§£æ Alpha\r\n            res = src[ptr++];\r\n        }\r\n\r\n        return res + getString();       \r\n        // èµ°åˆ°è¿™ä¸€æ­¥ï¼Œåè¾¹å¯èƒ½è¿˜æœ‰è¡¨è¾¾å¼,\r\n        // æ‰€ä»¥è¦ç»§ç»­é€’å½’å¹¶ä¸”æŠŠåè¾¹çš„ç»“æœæ‹¼æ¥èµ·æ¥\r\n    }\r\n\r\n    string decodeString(string s) {\r\n        src = s;\r\n        ptr = 0;\r\n        return getString();\r\n    }\r\n\r\nprivate:\r\n    string src;\r\n    size_t ptr;\r\n};\r\n```\r\n> + æ—¶é—´å¤æ‚åº¦: O(n)ï¼Œn ä¸º s é•¿åº¦\r\n> + ç©ºé—´å¤æ‚åº¦: O(n)\r\n\r\n----\r\n\r\n## æ ˆ\r\n\r\nä¸¤ä¸ªæ ˆåˆ†åˆ«ç»´æŠ¤æ•°å­—å’Œå­—ç¬¦ä¸²\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int getDigit(string &src, size_t &ptr) {\r\n        int res = 0;\r\n        while (ptr < src.size() && isdigit(src[ptr])) {\r\n            res = res * 10 + src[ptr] - '0';\r\n            ptr++;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    string decodeString(string s) {        \r\n        stack<int> numSt;\r\n        stack<string> stringSt;\r\n        string res;\r\n        int numT;\r\n        size_t ptr = 0; \r\n\r\n        while (ptr < s.size()) {\r\n            char cur = s[ptr];\r\n\r\n            if (cur == '[') {\r\n                ptr++;\r\n                numSt.push(numT);\r\n                stringSt.push(res);\r\n                res = \"\";\r\n            } else if (cur == ']') {\r\n                ptr++;\r\n                string tmpSrc;\r\n                int times = numSt.top(); numSt.pop();\r\n                while (times--)\r\n                    tmpSrc += res;\r\n                res = stringSt.top() + tmpSrc; stringSt.pop();\r\n            } else if (isdigit(cur)) {\r\n                numT = getDigit(s, ptr);\r\n            } else if (isalpha(cur)) {\r\n                ptr++;\r\n                res += cur;\r\n            }  \r\n        } \r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n\r\n> + æ—¶é—´å¤æ‚åº¦: O(n)ï¼Œn ä¸º s é•¿åº¦\r\n> + ç©ºé—´å¤æ‚åº¦: O(n)\r\n\r\n\r\n## æ¨¡æ¿\r\n\r\næ— æ¨¡æ¿","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188982095","body":"# Day 5. [232. ç”¨æ ˆå®ç°é˜Ÿåˆ—](https://leetcode.cn/problems/implement-queue-using-stacks/)\r\n## æ€è·¯\r\n\r\nä¸¤ä¸ªæ ˆæ¥å›å€’ï¼Œè¿™æ€ä¹ˆéš¾åº¦åˆä¸‹å»äº†\r\n\r\n\r\n```c++\r\nclass MyQueue {\r\npublic:\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    void push(int x) {\r\n        st.push(x);\r\n    }\r\n    \r\n    int pop() {\r\n        while (st.size()) {\r\n            stT.push(st.top()); st.pop();\r\n        }\r\n\r\n        int res = stT.top(); stT.pop();\r\n        while (stT.size()) {\r\n            st.push(stT.top()); stT.pop();\r\n        }\r\n\r\n        return res;\r\n    }\r\n    \r\n    int peek() {\r\n        stT = st;\r\n        while (stT.size() != 1) {\r\n            stT.top(); stT.pop();\r\n        }\r\n\r\n        int res = stT.top(); stT.pop();\r\n        return res;\r\n    }\r\n    \r\n    bool empty() {\r\n        return st.empty();\r\n    }\r\n\r\nprivate:\r\n    stack<int> st, stT;    \r\n};\r\n```\r\n> + æ—¶é—´å¤æ‚åº¦: O(n)\r\n> + ç©ºé—´å¤æ‚åº¦: O(n)\r\n\r\n----\r\n\r\n## æ¨¡æ¿\r\n\r\næ— æ¨¡æ¿","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190490612","body":"# Day 6. [768. æœ€å¤šèƒ½å®Œæˆæ’åºçš„å— II](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/)\r\n## æ€è·¯\r\n\r\nå°†åŸæ•°ç»„è¿›è¡Œåˆ†å—åï¼Œå¯¹å„åˆ†å—åˆ†åˆ«è¿›è¡Œæ’åºåçš„ç»“æœç­‰äºåŸæ•°ç»„æ’åºåçš„ç»“æœ.\r\n\r\nä¸‹ä¸€ä¸ªåˆ†å—ä¸­çš„æ‰€æœ‰æ•°å­—éƒ½ä¼šå¤§äºç­‰äºä¸Šä¸€ä¸ªåˆ†å—ä¸­çš„æ‰€æœ‰æ•°å­—.\r\n\r\n- æ ˆå­˜æ¯ä¸ªåˆ†å—çš„æœ€å¤§å€¼\r\n- å¦‚æœéå†åˆ°çš„æ–°æ•°å­—æ¯”ä¹‹å‰åˆ†å—çš„æœ€å¤§å€¼éƒ½è¦å¤§ï¼Œæˆ‘ä»¬å°±æŠŠå®ƒä½œä¸ºä¸€ä¸ªæ–°çš„åˆ†å—\r\n- å¦‚æœéå†åˆ°çš„æ–°æ•°å­—å°äºä¹‹å‰æŸäº›åˆ†å—çš„æœ€å¤§å€¼ï¼Œé‚£è¿™äº›åˆ†å—éƒ½è¦è¢«åˆæˆä¸€ä¸ªåˆ†å—\r\n\r\n\r\n```c++\r\nint maxChunksToSorted(vector<int>& arr) {\r\n    stack<int> st;\r\n    st.push(arr[0]);\r\n\r\n    for (int i = 1; i < arr.size(); ++i) {\r\n        if (arr[i] >= st.top()) {\r\n            st.push(arr[i]);\r\n        } else {\r\n            int head = st.top(); st.pop();  // å…ˆæŠŠå¤´éƒ¨å–å‡ºæ¥\r\n            while (st.size() != 0 && arr[i] < st.top()) { // åˆå¹¶æ¯”ä»–å¤§çš„æ•°\r\n                st.pop();\r\n            }\r\n            st.push(head);\r\n        }\r\n    }\r\n\r\n    return st.size();\r\n}\r\n```\r\n> + æ—¶é—´å¤æ‚åº¦: O(N)ï¼ŒN ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n> + ç©ºé—´å¤æ‚åº¦: O(N)\r\n\r\n----\r\n## æ¨¡æ¿\r\n\r\næ— æ¨¡æ¿","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191512129","body":"# Day 7. [61. æ—‹è½¬é“¾è¡¨](https://leetcode.cn/problems/rotate-list/)\r\n## æ€è·¯\r\n\r\nå…ˆæŠŠä»–å˜æˆç¯ï¼Œç„¶åè®¡ç®—å‡ºè¦ç§»åŠ¨çš„è·ç¦»\r\n\r\n- å˜æˆç¯ï¼Œæ‰¾åˆ°æœ«ç«¯èŠ‚ç‚¹ï¼Œè¿æ¥å¤´å°¾ï¼Œæå¸¦è®¡ç®—é“¾è¡¨é•¿åº¦\r\n- å› ä¸ºæ¯ä¸ªèŠ‚ç‚¹å‘å³ç§»åŠ¨ï¼Œç›¸å½“äºå¤´èŠ‚ç‚¹å‘å·¦ç§»åŠ¨ï¼Œä¸é“¾è¡¨æ–¹å‘ç›¸åï¼Œæ‰€ä»¥è¦è®¡ç®—ç§»åŠ¨çš„è·ç¦» = size - k\r\n\r\n\r\n```c++\r\nListNode* rotateRight(ListNode* head, int k) {\r\n    if (head == nullptr) return nullptr;\r\n\r\n    ListNode *root = head, *cur = head;\r\n\r\n    int size = 1;\r\n    while (cur->next != nullptr) {\r\n        cur = cur->next;\r\n        size++;\r\n    }\r\n    cur->next = head;  //æˆç¯\r\n\r\n    int num = size - k % size;//è®¡ç®—æ­£å‘ç§»åŠ¨çš„æ ¼å­\r\n\r\n    while(num--) {\r\n        if (num == 0) {\r\n            ListNode* now = root; \r\n            root = root->next;\r\n            now->next = nullptr;\r\n            break;\r\n        }\r\n\r\n        root = root->next;\r\n    }\r\n\r\n    return root;\r\n}\r\n```\r\n> + æ—¶é—´å¤æ‚åº¦: O(N)ï¼ŒN ä¸ºé“¾è¡¨é•¿åº¦\r\n> + ç©ºé—´å¤æ‚åº¦: O(N)\r\n\r\n----\r\n\r\n## æ¨¡æ¿\r\n\r\næ— æ¨¡æ¿","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192708395","body":"# Day 8. [24. ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹](https://leetcode.cn/problems/swap-nodes-in-pairs/)\r\n## æ€è·¯\r\n\r\né“¾è¡¨æ¨¡æ‹Ÿå³å¯\r\n\r\n- è®¾ç½®è™šæ‹Ÿå¤´èŠ‚ç‚¹è¾…åŠ©\r\n\r\n```c++\r\nListNode* swapPairs(ListNode* head) {\r\n    if (head == nullptr) return nullptr;\r\n    \r\n    ListNode* dummyHead = new ListNode(0, head);\r\n    ListNode* cur = head, *before = dummyHead;\r\n\r\n    while (cur->next != nullptr) {\r\n        ListNode* next = cur->next;\r\n        cur->next = next->next;\r\n        before->next = next;\r\n        next->next = cur;\r\n\r\n        if (cur->next != nullptr) {\r\n            before = cur; \r\n            cur = cur->next;                \r\n        }\r\n        else break;  \r\n                 \r\n    }\r\n\r\n    return dummyHead->next;\r\n}\r\n```\r\n\r\n\r\n> + æ—¶é—´å¤æ‚åº¦: O(N)ï¼ŒN ä¸º é“¾è¡¨é•¿åº¦\r\n> + ç©ºé—´å¤æ‚åº¦: O(N)\r\n\r\n\r\n## æ¨¡æ¿\r\n\r\næ— æ¨¡æ¿","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193149785","body":"# Day 9. [109. æœ‰åºé“¾è¡¨è½¬æ¢äºŒå‰æœç´¢æ ‘](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/)\r\n## æ€è·¯\r\n\r\nå¹³è¡¡äºŒå‰æœç´¢æ ‘\r\n\r\n- å¹³è¡¡ï¼šè¦é€‰å–é“¾è¡¨çš„ä¸­é—´èŠ‚ç‚¹ä½œä¸ºæ ¹èŠ‚ç‚¹ï¼Œä¸€å®šå¹³è¡¡ï¼ˆå‚åŠ åç»­è¯æ˜ï¼‰\r\n- æœç´¢ï¼šæœ‰åºï¼Œé¢˜ç›®è¾“å…¥é“¾è¡¨å°±æ˜¯æœ‰åºçš„ï¼Œæ‰€ä»¥éšä¾¿æ‰¾ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå‰é©±èŠ‚ç‚¹å»ºå·¦å­æ ‘ï¼Œåç»§èŠ‚ç‚¹å»ºå³å­æ ‘ï¼Œä¸€å®šæ˜¯æœç´¢æ ‘\r\n\r\nä¸­é—´èŠ‚ç‚¹è®¡ç®—æ–¹æ³•ï¼š\r\n- å¿«æ…¢æŒ‡é’ˆèµ°ä¸€éæ…¢æŒ‡é’ˆä½ç½®\r\n- æŠŠé“¾è¡¨å­˜æ•°ç»„é‡Œ `start + end >> 1`\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    TreeNode* buildAVL(vector<ListNode*> &vecs, int start, int end) {\r\n        if (start > end) return nullptr;\r\n\t\t\r\n        //start + end >> 1 å’Œ start + end + 1 >> 1 é’ˆå¯¹å¶æ•°é“¾è¡¨ï¼Œä¸€ä¸ªé€‰æ‹©å‰è¾¹ä½œä¸ºæ ¹èŠ‚ç‚¹ï¼Œå¦ä¸€ä¸ªé€‰æ‹©åè¾¹ä½œä¸ºæ ¹èŠ‚ç‚¹ï¼Œéƒ½å¯¹\r\n        int mid = start + end >> 1;\r\n        TreeNode* root = new TreeNode(vecs[mid]->val);\r\n        root->left = buildAVL(vecs, start, mid);\r\n        root->right = buildAVL(vecs, mid + 1, end);\r\n        return root;    \r\n    }\r\n\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        vector<ListNode*> vecs;\r\n\r\n        for (ListNode* cur = head; cur != nullptr; cur = cur->next) {\r\n            vecs.push_back(cur);\r\n        }\r\n\r\n        TreeNode* root = buildAVL(vecs, 0, vecs.size() - 1);\r\n\r\n        return root;\r\n    }\r\n};\r\n```\r\n> + æ—¶é—´å¤æ‚åº¦: O(N)ï¼ŒN ä¸ºé“¾è¡¨é•¿åº¦\r\n> + ç©ºé—´å¤æ‚åº¦: O(logN)ï¼Œå¹³è¡¡äºŒå‰æ ‘çš„é«˜åº¦ä¸º O(logn)ï¼Œå³ä¸ºé€’å½’è¿‡ç¨‹ä¸­æ ˆçš„æœ€å¤§æ·±åº¦ï¼Œä¹Ÿå°±æ˜¯éœ€è¦çš„ç©ºé—´ã€‚\r\n\r\n----\r\n\r\n## å¿«æ…¢æŒ‡é’ˆ\r\n\r\nå¿«æ…¢æŒ‡é’ˆå¥½ä¹…æ²¡å†™äº†ï¼Œå†™ä¸€ä¸‹ç»ƒæ‰‹\r\n\r\n```c++\r\nListNode* getMid(ListNode* left, ListNode* right) {\r\n    ListNode *slow = left, *fast = left;\r\n\r\n    while (fast != right && fast->next != right) {\r\n        slow = slow->next;\r\n        fast = fast->next->next;\r\n    }\r\n\r\n    return slow;\r\n}\r\n\r\nTreeNode* buildAVL(ListNode* left, ListNode* right) {\r\n    if (left == right) return nullptr;\r\n    ListNode* midNode = getMid(left, right);\r\n    TreeNode* root = new TreeNode(midNode->val);\r\n    root->left = buildAVL(left, midNode);\r\n    root->right = buildAVL(midNode->next, right);\r\n    return root;    \r\n}\r\n\r\nTreeNode* sortedListToBST(ListNode* head) {\r\n    TreeNode* root = buildAVL(head, nullptr);\r\n\r\n    return root;\r\n}\r\n```\r\n\r\n\r\n> + æ—¶é—´å¤æ‚åº¦: O(NlogN)ï¼ŒN ä¸ºé“¾è¡¨é•¿åº¦\r\n> + ç©ºé—´å¤æ‚åº¦: O(logN)\r\n\r\n\r\n## æ¨¡æ¿\r\n\r\næ— æ¨¡æ¿","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193291401","body":"# Day 10. [160. ç›¸äº¤é“¾è¡¨](https://leetcode.cn/problems/intersection-of-two-linked-lists/)\r\n## æ€è·¯\r\n\r\nå…ˆå­˜å¥½ä¸€ä¸ªé“¾è¡¨çš„å…¨éƒ¨èŠ‚ç‚¹ï¼Œæš´åŠ›åŒ¹é…\r\n\r\n\r\n```c++\r\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n    vector<ListNode*> vecs;\r\n    for (ListNode* cur = headA; cur != nullptr; cur = cur->next) {\r\n        vecs.push_back(cur);\r\n    }\r\n\r\n\r\n    for (ListNode* cur = headB; cur != nullptr; cur = cur->next) {\r\n        for (ListNode* aNode : vecs) {\r\n            if (cur == aNode)\r\n                return cur;\r\n        }\r\n    }\r\n\r\n    return nullptr;\r\n}\r\n```\r\n> + æ—¶é—´å¤æ‚åº¦: O(MN)ï¼ŒMï¼ŒN ä¸ºä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦é•¿åº¦\r\n> + ç©ºé—´å¤æ‚åº¦: O(N)\r\n\r\n----\r\n\r\n## é“¾è¡¨å˜ç¯\r\n\r\nå…¶å®å°±æ˜¯ä¸€ä¸ªå…¬å¼æ¨å¯¼\r\n\r\n- é“¾è¡¨Aï¼Œä¸ç›¸äº¤å‰é•¿åº¦ä¸º aï¼Œç›¸äº¤åé•¿åº¦ä¸º cï¼Œæ€»é•¿åº¦ä¸º a+c\r\n- é“¾è¡¨Bï¼Œä¸ç›¸äº¤å‰é•¿åº¦ä¸º bï¼Œç›¸äº¤åé•¿åº¦ä¸º cï¼Œæ€»é•¿åº¦ä¸º b+c\r\n\r\né‚£ä¹ˆ A èµ°å®Œç»§ç»­èµ° b æ­¥ï¼ŒB èµ°å®Œç»§ç»­èµ° a æ­¥ï¼Œåˆ™å…±èµ°äº† a + b + cï¼Œç›¸äº¤ã€‚\r\n\r\n> å¦‚æœä¸¤é“¾è¡¨ä¸ç›¸äº¤ï¼Œé‚£ä¹ˆ c ä¸º 0ï¼Œåˆ™å…±èµ°äº† a + b æ­¥ï¼Œåˆ°è¾¾ nullptr\r\n\r\n```c++\r\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n    if (headA == nullptr || headB == nullptr) {\r\n        return nullptr;\r\n    }\r\n\r\n    ListNode *acur = headA, *bcur = headB;\r\n\r\n    while (acur != bcur) {\r\n        acur = acur == nullptr ? headB : acur->next;\r\n        bcur = bcur == nullptr ? headA : bcur->next;\r\n    }\r\n\r\n    return acur;\r\n}\r\n```\r\n\r\n\r\n> + æ—¶é—´å¤æ‚åº¦: O(M+N)\r\n> + ç©ºé—´å¤æ‚åº¦: O(1)\r\n\r\n\r\n## æ¨¡æ¿\r\n\r\næ— æ¨¡æ¿","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194163450","body":"# Day 11. [142. ç¯å½¢é“¾è¡¨ II](https://leetcode.cn/problems/linked-list-cycle-ii/)\r\n## æ€è·¯\r\n\r\n![image](https://user-images.githubusercontent.com/30496905/180805264-c5c5bc96-f203-40fb-a070-c6bf74661371.png)\r\n\r\nslow èµ°çš„è·¯: a + bï¼Œ\r\nfast  èµ°çš„è·¯: a + b + n(b + c)ï¼Œ\r\nå…¶ä¸­ n å¿…ä¸º 1ï¼Œ\r\nåœ¨ b ç›¸é‡ï¼Œå› ä¸º fast é€Ÿåº¦æ˜¯ slow çš„ä¸¤å€ï¼Œåˆ™æœ‰ï¼ša + b + n(b + c) = (a + b) * 2ï¼Œæ±‚è§£å‡ºæ¥ c = aï¼Œ\r\né‚£ä¹ˆ slow å†èµ° c = a æ­¥ï¼Œå°±æ˜¯ç›¸äº¤èŠ‚ç‚¹ï¼Œæ‰¾å¦ä¸€ä¸ªæŒ‡é’ˆ cur ä» head èµ° a æ­¥ï¼Œcur == slow æ—¶ï¼Œå³ä¸ºç¯çš„èµ·ç‚¹\r\n\r\n```c++\r\nListNode *detectCycle(ListNode *head) {\r\n    ListNode *slow = head, *fast = head, *res = head;\r\n\r\n    while (slow != nullptr && fast != nullptr) {\r\n        if (fast->next == nullptr) return nullptr;\r\n        slow = slow->next;\r\n        fast = fast->next->next;\r\n\r\n        \r\n        if (slow == fast) {\r\n            //cout << slow->val << endl;\r\n            while (res != slow) {\r\n                res = res->next;\r\n                slow = slow->next;\r\n            }\r\n            return slow;\r\n        }   \r\n    }\r\n\r\n    return nullptr;\r\n}\r\n```\r\n> + æ—¶é—´å¤æ‚åº¦: O(N)ï¼ŒN ä¸º s é•¿åº¦\r\n> + ç©ºé—´å¤æ‚åº¦: O(1)\r\n\r\n----\r\n\r\n## æ¨¡æ¿\r\n\r\næ— æ¨¡æ¿","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195690164","body":"# Day 12. [146. LRU ç¼“å­˜](https://leetcode.cn/problems/lru-cache/)\r\n## æ€è·¯\r\n\r\nè¦è®© `put` å’Œ `get` æ–¹æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º O(1)ï¼Œæˆ‘ä»¬å¯ä»¥æ€»ç»“å‡º `cache` è¿™ä¸ªæ•°æ®ç»“æ„å¿…è¦çš„æ¡ä»¶ï¼š\r\n\r\n1ã€æ˜¾ç„¶ `cache` ä¸­çš„å…ƒç´ å¿…é¡»æœ‰æ—¶åºï¼Œä»¥åŒºåˆ†æœ€è¿‘ä½¿ç”¨çš„å’Œä¹…æœªä½¿ç”¨çš„æ•°æ®ï¼Œå½“å®¹é‡æ»¡äº†ä¹‹åè¦åˆ é™¤æœ€ä¹…æœªä½¿ç”¨çš„é‚£ä¸ªå…ƒç´ è…¾ä½ç½®ï¼›\r\n\r\n2ã€æˆ‘ä»¬è¦åœ¨ `cache` ä¸­å¿«é€Ÿæ‰¾æŸä¸ª `key` æ˜¯å¦å·²å­˜åœ¨å¹¶å¾—åˆ°å¯¹åº”çš„ `val`ï¼›\r\n\r\n3ã€æ¯æ¬¡è®¿é—® `cache` ä¸­çš„æŸä¸ª `key`ï¼Œéœ€è¦å°†è¿™ä¸ªå…ƒç´ å˜ä¸ºæœ€è¿‘ä½¿ç”¨çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ `cache` è¦æ”¯æŒåœ¨ä»»æ„ä½ç½®å¿«é€Ÿæ’å…¥å’Œåˆ é™¤å…ƒç´ ã€‚\r\n\r\n\r\n\r\n\r\n\r\nLRU ç¼“å­˜ç®—æ³•çš„æ ¸å¿ƒæ•°æ®ç»“æ„å°±æ˜¯**å“ˆå¸Œé“¾è¡¨**ï¼Œ**åŒå‘é“¾è¡¨**å’Œ**å“ˆå¸Œè¡¨**çš„ç»“åˆä½“ã€‚è¿™ä¸ªæ•°æ®ç»“æ„é•¿è¿™æ ·ï¼š\r\n\r\n![image](https://user-images.githubusercontent.com/30496905/181057314-f135514d-295e-4e97-b911-41f7f002c528.png)\r\n\r\n1ã€å¦‚æœæˆ‘ä»¬æ¯æ¬¡é»˜è®¤ä»é“¾è¡¨å°¾éƒ¨æ·»åŠ å…ƒç´ ï¼Œé‚£ä¹ˆæ˜¾ç„¶è¶Šé å°¾éƒ¨çš„å…ƒç´ å°±æ˜¯æœ€è¿‘ä½¿ç”¨çš„ï¼Œè¶Šé å¤´éƒ¨çš„å…ƒç´ å°±æ˜¯æœ€ä¹…æœªä½¿ç”¨çš„ã€‚\r\n\r\n2ã€å¯¹äºæŸä¸€ä¸ª `key`ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å“ˆå¸Œè¡¨å¿«é€Ÿå®šä½åˆ°é“¾è¡¨ä¸­çš„èŠ‚ç‚¹ï¼Œä»è€Œå–å¾—å¯¹åº” `val`ã€‚\r\n\r\n3ã€é“¾è¡¨æ˜¾ç„¶æ˜¯æ”¯æŒåœ¨ä»»æ„ä½ç½®å¿«é€Ÿæ’å…¥å’Œåˆ é™¤çš„ï¼Œæ”¹æ”¹æŒ‡é’ˆå°±è¡Œã€‚åªä¸è¿‡ä¼ ç»Ÿçš„é“¾è¡¨æ— æ³•æŒ‰ç…§ç´¢å¼•å¿«é€Ÿè®¿é—®æŸä¸€ä¸ªä½ç½®çš„å…ƒç´ ï¼Œè€Œè¿™é‡Œå€ŸåŠ©å“ˆå¸Œè¡¨ï¼Œå¯ä»¥é€šè¿‡ `key` å¿«é€Ÿæ˜ å°„åˆ°ä»»æ„ä¸€ä¸ªé“¾è¡¨èŠ‚ç‚¹ï¼Œç„¶åè¿›è¡Œæ’å…¥å’Œåˆ é™¤ã€‚\r\n\r\n\r\n\r\nä¸ºä»€ä¹ˆå¿…é¡»è¦ç”¨åŒå‘é“¾è¡¨?\r\n\r\nå› ä¸ºæˆ‘ä»¬éœ€è¦åˆ é™¤æ“ä½œã€‚åˆ é™¤ä¸€ä¸ªèŠ‚ç‚¹ä¸å…‰è¦å¾—åˆ°è¯¥èŠ‚ç‚¹æœ¬èº«çš„æŒ‡é’ˆï¼Œä¹Ÿéœ€è¦æ“ä½œå…¶å‰é©±èŠ‚ç‚¹çš„æŒ‡é’ˆï¼Œè€ŒåŒå‘é“¾è¡¨æ‰èƒ½æ”¯æŒç›´æ¥æŸ¥æ‰¾å‰é©±ï¼Œä¿è¯æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ O(1)ã€‚\r\n\r\n\r\n\r\n```c++\r\nstruct DLinkedNode{\r\n    int key, value;\r\n    DLinkedNode* next;\r\n    DLinkedNode* prev;\r\n    DLinkedNode() : key(0), value(0), prev(nullptr), next(nullptr) {}\r\n    DLinkedNode(int k, int v) : key(k), value(v), prev(nullptr), next(nullptr) {}\r\n}\r\n```\r\n\r\né¦–å…ˆä½¿ç”¨å“ˆå¸Œè¡¨å®šä½ï¼Œæ‰¾å‡ºç¼“å­˜é¡¹åœ¨åŒå‘é“¾è¡¨ä¸­çš„ä½ç½®ï¼Œéšåå°†å…¶ç§»åŠ¨åˆ°åŒå‘é“¾è¡¨çš„å¤´éƒ¨ï¼Œå³å¯åœ¨ $O(1)$ çš„æ—¶é—´å†…å®Œæˆ `get` æˆ–è€… `put` æ“ä½œã€‚å…·ä½“æ–¹æ³•å¦‚ä¸‹ï¼š\r\n\r\n- å¯¹äº `get` æ“ä½œï¼Œé¦–å…ˆåˆ¤æ–­ `key` æ˜¯å¦å­˜åœ¨ï¼š\r\n\r\n  - å¦‚æœ `key` ä¸å­˜åœ¨ï¼Œåˆ™è¿”å› `-1`ï¼›\r\n  - å¦‚æœ `key` å­˜åœ¨ï¼Œåˆ™ `key` å¯¹åº”çš„èŠ‚ç‚¹æ˜¯æœ€è¿‘è¢«ä½¿ç”¨çš„èŠ‚ç‚¹ã€‚é€šè¿‡å“ˆå¸Œè¡¨å®šä½åˆ°è¯¥èŠ‚ç‚¹åœ¨åŒå‘é“¾è¡¨ä¸­çš„ä½ç½®ï¼Œå¹¶å°†å…¶ç§»åŠ¨åˆ°åŒå‘é“¾è¡¨çš„å¤´éƒ¨ï¼Œæœ€åè¿”å›è¯¥èŠ‚ç‚¹çš„å€¼\r\n\r\n- å¯¹äº `put` æ“ä½œï¼Œé¦–å…ˆåˆ¤æ–­ `key` æ˜¯å¦å­˜åœ¨ï¼š\r\n\r\n  - å¦‚æœ `key` ä¸å­˜åœ¨ï¼Œä½¿ç”¨ `key` å’Œ `value` åˆ›å»ºä¸€ä¸ªæ–°çš„èŠ‚ç‚¹ï¼Œåœ¨åŒå‘é“¾è¡¨å¤´éƒ¨æ·»åŠ è¯¥èŠ‚ç‚¹ï¼›å¹¶å°† `key` å’Œè¯¥èŠ‚ç‚¹æ·»åŠ åˆ°å“ˆå¸Œè¡¨ä¸­ã€‚ç„¶ååˆ¤æ–­åŒå‘é“¾è¡¨çš„èŠ‚ç‚¹æ•°æ˜¯å¦è¶…å‡ºå®¹é‡ï¼Œå¦‚æœè¶…å‡ºå®¹é‡ï¼Œåˆ™åˆ é™¤åŒå‘é“¾è¡¨çš„å°¾éƒ¨èŠ‚ç‚¹ï¼Œå¹¶åˆ é™¤å“ˆå¸Œè¡¨ä¸­å¯¹åº”çš„é¡¹ï¼›\r\n  - å¦‚æœ `key` å­˜åœ¨ï¼Œåˆ™ä¸ `get` æ“ä½œç±»ä¼¼ï¼Œå…ˆé€šè¿‡å“ˆå¸Œè¡¨å®šä½ï¼Œå†å°†å¯¹åº”çš„èŠ‚ç‚¹çš„å€¼æ›´æ–°ä¸º `value`ï¼Œå¹¶å°†è¯¥èŠ‚ç‚¹ç§»åˆ°åŒå‘é“¾è¡¨çš„å¤´éƒ¨ã€‚\r\n\r\n  \r\n\r\nåœ¨åŒå‘é“¾è¡¨çš„å®ç°ä¸­ï¼Œä½¿ç”¨ä¸€ä¸ªä¼ªå¤´éƒ¨ï¼ˆdummy headï¼‰å’Œä¼ªå°¾éƒ¨ï¼ˆdummy tailï¼‰æ ‡è®°ç•Œé™ï¼Œè¿™æ ·åœ¨æ·»åŠ èŠ‚ç‚¹å’Œåˆ é™¤èŠ‚ç‚¹çš„æ—¶å€™å°±ä¸éœ€è¦æ£€æŸ¥ç›¸é‚»çš„èŠ‚ç‚¹æ˜¯å¦å­˜åœ¨ã€‚\r\n\r\n\r\n\r\n\r\n\r\n```c++\r\nclass LRUCache {\r\nprivate:\r\n\tunordered_map<int, DLinkedNode*> _cache;\r\n    DLinkedNode* _head;\r\n    DLinkedNode* _tail;\r\n    int _size;\r\n    int _capacity;\r\n    \r\npublic:\r\n    LRUCache(int _capacity): capacity(_capacity), size(0) {\r\n        // ä½¿ç”¨ä¼ªå¤´éƒ¨å’Œä¼ªå°¾éƒ¨èŠ‚ç‚¹\r\n        _head = new DLinkedNode();\r\n        _tail = new DLinkedNode();\r\n        _head->next = _tail;\r\n        _tail->prev = _head;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if (!_cache.count(key)) { // å¦‚æœ key ä¸å­˜åœ¨ï¼Œæ·»åŠ ä¸€ä¸ªæ–°çš„èŠ‚ç‚¹\r\n            DLinkedNode* node = new DLinkedNode(key, value);\r\n            _cache[key] = node;\r\n            addToHead(node);\r\n            ++_size;\r\n            \r\n            if (_size > _capacity) {\r\n                // åˆ é™¤åŒå‘é“¾è¡¨çš„å°¾éƒ¨èŠ‚ç‚¹\r\n                DLinkedNode* removed = removeTail();\r\n                // åˆ é™¤å“ˆå¸Œè¡¨ä¸­å¯¹åº”çš„é¡¹\r\n                _cache.erase(removed->key);\r\n                // é˜²æ­¢å†…å­˜æ³„éœ²\r\n                delete removed;\r\n                --_size;\r\n            }\r\n        } else {\t\t\t// key å­˜åœ¨ï¼Œä¿®æ”¹valueï¼Œå¹¶ç§»è‡³å¤´éƒ¨\r\n            DLinkedNode* node = cache[key];\r\n            node->value = value;\r\n            moveToHead(node);\r\n        }        \r\n    }\r\n    \r\n    int get(int key) {\r\n        if (!_cache.count(key)) {\r\n            return -1;\r\n        }\r\n        // å¦‚æœ key å­˜åœ¨ï¼Œå…ˆé€šè¿‡å“ˆå¸Œè¡¨å®šä½ï¼Œå†ç§»åˆ°å¤´éƒ¨\r\n        DLinkedNode* node = cache[key];\r\n        moveToHead(node);\r\n        return node->value;\r\n    }\r\n    \r\n    void moveToHead(DLinkedNode* node) {\r\n    \tremoveNode(node);\r\n        addToHead(node);\r\n    }\r\n    \r\n    // å¯¹åº”å®˜æ–¹å›¾è§£ç¬¬ 3 > 4 å›¾\r\n    void addToHead(DLinkedNode* node) {\r\n        node->prev = head;\t\t\t\t// 1->prev = head;\r\n        node->next = head->next;\t\t// 1->next = 2;\r\n        head->next->prev = node;\t\t// 2->prev = 1;\r\n        head->next = node;\t\t\t\t// head->next = 1;\r\n    }\r\n    \r\n    // å¯¹åº”å®˜æ–¹å›¾è§£ç¬¬ 3 > 4 å›¾\r\n\tvoid removeNode(DLinkedNode* node) {\r\n        node->prev->next = node->next;\t// 2->next = dummy_Tail\r\n        node->next->prev = node->prev;\t// dummy_Tail->prev = 2\r\n        // æ­¤æ—¶ 2 è¢«å®Œå…¨éš”å¼€\r\n    }\r\n    \r\n    // å¯¹åº”å®˜æ–¹å›¾è§£ç¬¬ 4 > 5 å›¾\r\n    DLinkedNode* removeTail() {\r\n        DLinkedNode node = tail->prev;\t\t// 2 = tail->prev\r\n        removeNode(node);\t\t\t\t\t// remove(2)\r\n        return node;\t\t\t\t\t\t// return 2\r\n    }\r\n    \r\n    \r\n}\r\n```\r\n\r\n> + æ—¶é—´å¤æ‚åº¦: O(1)ï¼Œå¯¹äº put å’Œ get éƒ½æ˜¯ O(1)ã€‚\r\n> + ç©ºé—´å¤æ‚åº¦: O(capacity)ï¼Œå› ä¸ºå“ˆå¸Œè¡¨å’ŒåŒå‘é“¾è¡¨æœ€å¤šå­˜å‚¨ capacity+1 ä¸ªå…ƒç´ ã€‚\r\n\r\n----\r\n## æ¨¡æ¿\r\n\r\næ— æ¨¡æ¿\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196893728","body":"# Day 13. [104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)\r\n## BFS\r\n\r\n```c++\r\nint maxDepth(TreeNode* root) {\r\n    if (root == nullptr) return 0;\r\n\r\n    queue<TreeNode*> q;\r\n    q.push(root);\r\n\r\n    int res = 0;\r\n    while (q.size()) {\r\n        int size = q.size();\r\n\r\n        for (int i = 0; i < size; ++i) {\r\n            auto cur = q.front(); q.pop();\r\n            if (cur->left) q.push(cur->left);\r\n            if (cur->right) q.push(cur->right);\r\n        }\r\n\r\n        res++;\r\n    }\r\n\r\n    return res;\r\n}\r\n```\r\n> + æ—¶é—´å¤æ‚åº¦: O(N)ï¼Œå…¶ä¸­ n ä¸ºäºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°ã€‚\r\n> + ç©ºé—´å¤æ‚åº¦: ç©ºé—´çš„æ¶ˆè€—å–å†³äºé˜Ÿåˆ—å­˜å‚¨çš„å…ƒç´ æ•°é‡ï¼Œå…¶åœ¨æœ€åæƒ…å†µä¸‹ä¼šè¾¾åˆ° O(n)ã€‚\r\n\r\n----\r\n\r\n## DFS\r\n\r\n\r\n```c++\r\nconstexpr int inf = 0x3f3f3f3f;\r\nclass Solution {\r\npublic:\r\n    void dfs(TreeNode* root, int resT) {\r\n        if (root == nullptr) {\r\n            res = max(res, resT);\r\n            return;\r\n        }\r\n\r\n        dfs(root->left, resT + 1);\r\n        dfs(root->right, resT + 1);\r\n        return;\r\n    }\r\n\r\n    int maxDepth(TreeNode* root) {\r\n        res = -inf;\r\n        dfs(root, 0);\r\n        return res;\r\n    }\r\n\r\nprivate:\r\n    int res;    \r\n};\r\n```\r\n\r\n\r\n> + æ—¶é—´å¤æ‚åº¦: O(N)ï¼Œå…¶ä¸­ N ä¸ºäºŒå‰æ ‘èŠ‚ç‚¹çš„ä¸ªæ•°ã€‚æ¯ä¸ªèŠ‚ç‚¹åœ¨é€’å½’ä¸­åªè¢«éå†ä¸€æ¬¡ã€‚\r\n> + ç©ºé—´å¤æ‚åº¦: O(height)ï¼Œå…¶ä¸­ height è¡¨ç¤ºäºŒå‰æ ‘çš„é«˜åº¦ã€‚é€’å½’å‡½æ•°éœ€è¦æ ˆç©ºé—´ï¼Œè€Œæ ˆç©ºé—´å–å†³äºé€’å½’çš„æ·±åº¦ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦ç­‰ä»·äºäºŒå‰æ ‘çš„é«˜åº¦.\r\n\r\n\r\n## æ¨¡æ¿\r\n\r\næ— æ¨¡æ¿","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198065749","body":"# Day 14. [100. ç›¸åŒçš„æ ‘](https://leetcode.cn/problems/same-tree/)\r\n## æ€è·¯\r\n\r\næ‰€æœ‰æƒ…å†µè€ƒè™‘åˆ°å³å¯\r\n\r\n\r\n```c++\r\nbool isSameTree(TreeNode* p, TreeNode* q) {\r\n    if (p == nullptr && q != nullptr) return false;\r\n    if (p != nullptr && q == nullptr) return false;\r\n\r\n    if (p == nullptr && q == nullptr) return true;\r\n\r\n    if (p->val != q->val) return false;\r\n\r\n    return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\r\n}\r\n```\r\n> + æ—¶é—´å¤æ‚åº¦: O(N)ï¼Œå…¶ä¸­ N ä¸ºäºŒå‰æ ‘èŠ‚ç‚¹çš„ä¸ªæ•°ã€‚æ¯ä¸ªèŠ‚ç‚¹åœ¨é€’å½’ä¸­åªè¢«éå†ä¸€æ¬¡ã€‚\r\n> + ç©ºé—´å¤æ‚åº¦: O(height)ï¼Œå…¶ä¸­ height è¡¨ç¤ºäºŒå‰æ ‘çš„é«˜åº¦ã€‚é€’å½’å‡½æ•°éœ€è¦æ ˆç©ºé—´ï¼Œè€Œæ ˆç©ºé—´å–å†³äºé€’å½’çš„æ·±åº¦ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦ç­‰ä»·äºäºŒå‰æ ‘çš„é«˜åº¦ã€‚\r\n\r\n----\r\n\r\n\r\n## æ¨¡æ¿\r\n\r\næ— æ¨¡æ¿","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199311192","body":"# Day 15. [129. æ±‚æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹æ•°å­—ä¹‹å’Œ](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)\r\n## æ€è·¯\r\n\r\næ‰€æœ‰å¶å­èŠ‚ç‚¹éƒ½è¦è®¡ç®—ï¼Œæ‰€ä»¥è¦ DFS\r\n\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    void dfs (TreeNode* root, int val) {\r\n        if (root->left == nullptr && root->right == nullptr) {\r\n            // cout << val << endl;\r\n            res += 10 * val + root->val;\r\n            return;\r\n        } \r\n\r\n        if (root->left != nullptr) dfs(root->left, val * 10 + root->val);\r\n        if (root->right != nullptr) dfs(root->right, val * 10 + root->val);\r\n\r\n        return;\r\n    }\r\n\r\n\r\n    int sumNumbers(TreeNode* root) {\r\n        res = 0;\r\n        dfs(root, 0);\r\n        return res;\r\n    }\r\n\r\nprivate:\r\n    int res;\r\n};\r\n```\r\n> + æ—¶é—´å¤æ‚åº¦: O(N)ï¼ŒN ä¸ºèŠ‚ç‚¹ä¸ªæ•°\r\n> + ç©ºé—´å¤æ‚åº¦: O(height)ï¼Œ\r\n\r\n----\r\n\r\n## æ¨¡æ¿\r\n\r\næ— æ¨¡æ¿","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200259121","body":"# Day 16. [513. æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼](https://leetcode.cn/problems/find-bottom-left-tree-value/)\r\n## BFS\r\n\r\n\r\n```c++\r\nint findBottomLeftValue(TreeNode* root) {\r\n    queue<TreeNode*> q;\r\n    q.push(root);\r\n\r\n    int res = root->val;\r\n\r\n\r\n    while (q.size()) {\r\n        int size = q.size();\r\n\r\n        for (int i = 0; i < size; ++i) {\r\n            TreeNode* cur = q.front(); q.pop();\r\n            if (i == 0) res = cur->val;\r\n\r\n            if (cur->left != nullptr) q.push(cur->left);\r\n            if (cur->right != nullptr) q.push(cur->right);\r\n        }\r\n    }\r\n\r\n    return res;\r\n}\r\n```\r\n> + æ—¶é—´å¤æ‚åº¦: O(N)ï¼Œå³æ‰€æœ‰èŠ‚ç‚¹å…¨éå†ä¸€é\r\n> + ç©ºé—´å¤æ‚åº¦: O(N)ï¼Œæ»¡å®Œå…¨äºŒå‰æ ‘ï¼Œå…¶ä¸­ä¸€æ»¡å±‚å…¨å­˜\r\n\r\n----\r\n\r\n## DFS\r\n\r\nå…ˆåºéå†ï¼Œå·¦å³ä¸­\r\n\r\n- `å·¦` åœ¨ `å³ä¸­` çš„å‰è¾¹ï¼Œä¿è¯æœ€å·¦èŠ‚ç‚¹\r\n- `å·¦å³` åœ¨ `ä¸­` çš„å‰è¾¹ï¼Œä¿è¯æœ€åº•å±‚\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    void dfs(TreeNode* root, int level) {\r\n        if (root->left != nullptr) dfs(root->left, level + 1);\r\n        if (root->right != nullptr) dfs(root->right, level + 1);\r\n        \r\n        if (maxlevel < level) {\r\n            maxlevel = level;\r\n            res = root->val;\r\n            return;\r\n        }\r\n\r\n        return;\r\n    }\r\n\r\n    int findBottomLeftValue(TreeNode* root) {\r\n        maxlevel = -1;\r\n        dfs(root, 0);\r\n        return res;\r\n    }\r\n\r\nprivate:\r\n    int res;\r\n    int maxlevel;\r\n};\r\n```\r\n\r\n\r\n> + æ—¶é—´å¤æ‚åº¦: O(N)ï¼Œå³å…¨éƒ¨éå†ä¸€é\r\n> + ç©ºé—´å¤æ‚åº¦: O(height)ï¼Œæ ‘çš„é«˜åº¦ï¼Œæœ€å·®ä¸º O(N)\r\n\r\n\r\n## æ¨¡æ¿\r\n\r\næ— æ¨¡æ¿","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200432430","body":"# Day 17. [394. å­—ç¬¦ä¸²è§£ç ](https://leetcode.cn/problems/decode-string/)\r\n## æ€è·¯\r\n\r\nç¼–ç +è§£ç ï¼Œæ²¡å•¥å¥½è¯´çš„\r\n\r\n```c++\r\nclass Codec {\r\npublic:\r\n    void dfs(TreeNode* root, string &s) { // ä¸­åº\r\n        if (root == nullptr) {\r\n            s += \"-1111,\";\r\n            return;\r\n        }\r\n        \r\n        s += to_string(root->val) + \",\";\r\n        dfs(root->left, s);        \r\n        dfs(root->right, s);\r\n    }\r\n\r\n    // Encodes a tree to a single string.\r\n    string serialize(TreeNode* root) {\r\n        string res;\r\n        dfs(root, res);\r\n        //cout << res;\r\n        return res;\r\n    }\r\n\r\n    void stringsplit(string &s, char split, vector<int> &nums) {\r\n        istringstream iss(s); \r\n        string token;\r\n        while (getline(iss, token, split)) {\r\n            nums.push_back(stoi(token));\r\n        }\r\n        return;\r\n    }\r\n\r\n    TreeNode* dfsBuild(vector<int> &nums, int &idx) {\r\n        if (nums[idx] == -1111) return nullptr;\r\n        TreeNode* root = new TreeNode(nums[idx]);\r\n        root->left = dfsBuild(nums, ++idx);\r\n        root->right = dfsBuild(nums, ++idx);\r\n        return root;\r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    TreeNode* deser(vector<int> nums;) {\r\n        int idx = 0;\r\n        TreeNode* res = dfsBuild(nums, idx);   \r\n        // TreeNode* res = dfsBuild(nums, 0);\r\n        return res;\r\n    }\r\n};\r\n```\r\n> + æ—¶é—´å¤æ‚åº¦: O(N)ï¼ŒN ä¸º s é•¿åº¦\r\n> + ç©ºé—´å¤æ‚åº¦: O(N)\r\n\r\n---\r\n\r\n## æ¨¡æ¿\r\n\r\næ— æ¨¡æ¿","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201187275","body":"# Day 987. [987. äºŒå‰æ ‘çš„å‚åºéå†](https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/)\r\n## æ€è·¯\r\n\r\næ’åºèŠ‚ç‚¹å³å¯\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    void dfs(TreeNode* root, int x, int y) {\r\n        if (root == nullptr) return;\r\n        dfs(root->left, x - 1, y + 1);\r\n        vecs.emplace_back(x, y, root->val);\r\n        dfs(root->right, x + 1, y + 1);\r\n        return;\r\n    }\r\n\r\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\r\n        dfs(root, 0, 0);\r\n        sort(vecs.begin(), vecs.end());\r\n\r\n        vector<vector<int>> res;\r\n\r\n        int lastX = INT_MIN;\r\n        for (auto const &[x, y, val] : vecs ) {\r\n            if (x != lastX) {\r\n                lastX = x;\r\n                res.emplace_back();\r\n            }\r\n\r\n            res.back().push_back(val);\r\n        }\r\n\r\n        return res;\r\n    }\r\nprivate:\r\n    vector<tuple<int, int, int>> vecs;    \r\n};\r\n```\r\n\r\n\r\n> + æ—¶é—´å¤æ‚åº¦: O(NlogN)ï¼ŒN ä¸ºéå†æ‰€æœ‰èŠ‚ç‚¹ï¼ŒlogN ä¸ºæ’åºæ—¶é—´\r\n> + ç©ºé—´å¤æ‚åº¦: O(N)ï¼Œå…¨åŠ è¿›å»\r\n\r\n\r\n## æ¨¡æ¿\r\n\r\næ— æ¨¡æ¿","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202658487","body":"# Day 19. [1. ä¸¤æ•°ä¹‹å’Œ](https://leetcode.cn/problems/two-sum/)\r\n## æ€è·¯\r\n\r\nå“ˆå¸Œè¡¨å­˜æœ‰çš„æ•°å€¼ï¼Œéå†æ‰€æœ‰æ•°å€¼ï¼Œæ‰¾ target - num\r\n\r\n```c++\r\nvector<int> twoSum(vector<int>& nums, int target) {\r\n\r\n    unordered_map<int, int> ump; //key-value æ•°å€¼-ç´¢å¼•\r\n\r\n    for (int i = 0; i < nums.size(); ++i) {\r\n        int num = target - nums[i];\r\n        if (ump.count(num)) {\r\n            return {ump[num], i};\r\n        }\r\n\r\n        ump[nums[i]] = i;\r\n    }\r\n\r\n    return {0, 0};\r\n}\r\n```\r\n> + æ—¶é—´å¤æ‚åº¦: O(N)ï¼ŒN ä¸º nums é•¿åº¦\r\n> + ç©ºé—´å¤æ‚åº¦: O(N)ï¼Œå…¨éƒ¨åŠ å…¥å“ˆå¸Œè¡¨\r\n\r\n----\r\n\r\n## æ¨¡æ¿\r\n\r\næ— æ¨¡æ¿","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1204053383","body":"# Day 20. [347. å‰ K ä¸ªé«˜é¢‘å…ƒç´ ](https://leetcode.cn/problems/top-k-frequent-elements/)\r\n## æ€è·¯\r\n\r\nå­˜åˆ° map é‡Œï¼Œç„¶åæ’åº\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> topKFrequent(vector<int>& nums, int k) {\r\n        unordered_map<int, int> ump;\r\n\r\n        for (int i = 0; i < nums.size(); ++i) {\r\n            ump[nums[i]]++;\r\n        }\r\n\r\n        vector<pair<int, int>> vecs(ump.begin(), ump.end());\r\n        sort(vecs.begin(), vecs.end(), cmp);\r\n\r\n        vector<int> res;\r\n        for (int i = 0; i < k; i++) {\r\n            res.push_back(vecs[i].first);\r\n        }\r\n\r\n        return res;\r\n    }\r\nprivate:\r\n    static bool cmp(pair<int, int> &p1, pair<int, int> &p2) {\r\n        return p1.second > p2.second;\r\n    }    \r\n};\r\n```\r\n> + æ—¶é—´å¤æ‚åº¦: O(NlogN)\r\n> + ç©ºé—´å¤æ‚åº¦: O(N)\r\n\r\n----\r\n\r\n\r\n## æ¨¡æ¿\r\n\r\næ— æ¨¡æ¿","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205350944","body":"# Day 21. [447. å›æ—‹é•–çš„æ•°é‡](https://leetcode.cn/problems/number-of-boomerangs/)\r\n## æ€è·¯\r\n\r\né¢˜ç›®æ‰€æè¿°çš„å›æ—‹é•–å¯ä»¥è§†ä½œä¸€ä¸ª V å‹çš„æŠ˜çº¿ã€‚æˆ‘ä»¬å¯ä»¥æšä¸¾æ¯ä¸ª points[i]ï¼Œå°†å…¶å½“ä½œ V å‹çš„æ‹ç‚¹ã€‚è®¾ points ä¸­æœ‰ m ä¸ªç‚¹åˆ° points[i] çš„è·ç¦»å‡ç›¸ç­‰ï¼Œæˆ‘ä»¬éœ€è¦ä»è¿™ m ç‚¹ä¸­é€‰å‡º 2 ä¸ªç‚¹å½“ä½œå›æ—‹é•–çš„ 2 ä¸ªç«¯ç‚¹ï¼Œç”±äºé¢˜ç›®è¦æ±‚è€ƒè™‘å…ƒç»„çš„é¡ºåºï¼Œå› æ­¤æ–¹æ¡ˆæ•°å³ä¸ºåœ¨ m ä¸ªå…ƒç´ ä¸­é€‰å‡º 2 ä¸ªä¸åŒå…ƒç´ çš„æ’åˆ—æ•°ï¼Œå³ m * (m - 1)\r\næ®æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥éå† pointsï¼Œè®¡ç®—å¹¶ç»Ÿè®¡æ‰€æœ‰ç‚¹åˆ° points[i] çš„è·ç¦»ï¼Œå°†æ¯ä¸ªè·ç¦»çš„å‡ºç°æ¬¡æ•°è®°å½•åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œç„¶åéå†å“ˆå¸Œè¡¨ï¼Œå¹¶ç”¨ä¸Šè¿°å…¬å¼è®¡ç®—å¹¶ç´¯åŠ å›æ—‹é•–çš„ä¸ªæ•°ã€‚\r\n\r\n```c++\r\ninline int getDis(vector<int> &v1, vector<int> &v2) {\r\n    return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);\r\n}\r\n\r\nint numberOfBoomerangs(vector<vector<int>>& points) {\r\n    int res = 0, n = points.size();\r\n\r\n    \r\n    for (int i = 0; i < n; ++i) {               // é€‰ä¸ºæ‹ç‚¹\r\n        unordered_map<int, int> ump;            // k->v  è·ç¦»->ä¸ªæ•°\r\n        for (int j = 0; j < n; ++j) {           // è·ç¦»\r\n            if (i == j) continue;\r\n            ump[getDis(points[i], points[j])]++;\r\n        }\r\n\r\n        for (auto &[_, m] : ump) {              // éå† [è·ç¦»,ä¸ªæ•°]\r\n            res += m * (m - 1);\r\n        }\r\n\r\n    }\r\n    \r\n    return res;\r\n}\r\n```\r\n> + æ—¶é—´å¤æ‚åº¦: O(N^2)ï¼ŒN ä¸º points ä¸ªæ•°\r\n> + ç©ºé—´å¤æ‚åº¦: O(N)\r\n\r\n----\r\n\r\n## æ¨¡æ¿\r\n\r\næ— æ¨¡æ¿","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206634121","body":"# Day 22. [3. æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)\r\n## æ€è·¯\r\n\r\nåŒæŒ‡é’ˆ + å“ˆå¸Œè¡¨ï¼Œå› ä¸ºè¦æ»¡è¶³å“ˆå¸Œè¡¨é‡Œæ‰€æœ‰å€¼ä¸èƒ½è¶…è¿‡ 1ï¼Œhi æŒ‡é’ˆéå†æ‰€æœ‰å­—ç¬¦ï¼Œå½“è¿™ä¸ªå­—ç¬¦åœ¨å“ˆå¸Œè¡¨é‡Œå€¼å¤§äº 2 æ—¶ï¼Œæˆ‘ä»¬å°±æŠŠ lo æŒ‡é’ˆå‘å³ç§»åŠ¨ï¼Œå¹¶ä¸”å‡è®¡æ•°ï¼Œç›´åˆ° hi æŒ‡çš„å­—ç¬¦è®¡æ•°å˜æˆ 1ï¼Œå³åˆæ³•å¹¶ä¸”æ›´æ–°é•¿åº¦ã€‚\r\n\r\n\r\n```c++\r\nint lengthOfLongestSubstring(string s) {\r\n    int n = s.size();\r\n\r\n    int lo = 0, hi = lo;\r\n    unordered_map<char, int> ump;\r\n\r\n    int res = 0;\r\n    for (; hi < n; ++hi) {\r\n        ump[s[hi]]++;\r\n        if (ump[s[hi]] == 1) {\r\n            res = max(res, hi - lo + 1);\r\n        } else {\r\n            while (ump[s[hi]] != 1) {\r\n                ump[s[lo]]--;\r\n                lo++;\r\n            }                \r\n            res = max(res, hi - lo + 1);\r\n        }\r\n    }\r\n\r\n    return res;\r\n}\r\n```\r\n> + æ—¶é—´å¤æ‚åº¦: O(N)ï¼ŒN ä¸º s é•¿åº¦\r\n> + ç©ºé—´å¤æ‚åº¦: O(Î£)ï¼Œå…¶ä¸­ Î£ è¡¨ç¤ºå­—ç¬¦é›†ï¼ˆå³å­—ç¬¦ä¸²ä¸­å¯ä»¥å‡ºç°çš„å­—ç¬¦ï¼‰\r\n\r\n----\r\n\r\n## æ¨¡æ¿\r\n\r\næ— æ¨¡æ¿","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207366608","body":"# Day 23. [30. ä¸²è”æ‰€æœ‰å•è¯çš„å­ä¸²](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/)\r\n## æ€è·¯\r\n\r\nå› ä¸ºå­ä¸²é•¿åº¦æ˜¯å›ºå®šçš„ï¼Œå¹¶ä¸”ä¸ªæ•°æ˜¯ç¡®å®šçš„ï¼Œé‚£ä¹ˆå°±å¯ä»¥ç”¨å“ˆå¸Œè¡¨åŒ¹é…\r\n\r\n```c++\r\nvector<int> findSubstring(string s, vector<string>& words) {\r\n    unordered_map<string, int> ump; // ç»Ÿè®¡å­ä¸²çš„å­—ç¬¦ä¸ªæ•°\r\n    for (auto &s : words) {\r\n        ++ump[s];\r\n    }\r\n    \r\n    int n = s.size(), cnt = words.size(), length = words[0].size();\r\n    int childStrLen = cnt * length;\r\n    vector<int> res;\r\n    for (int i = 0; i < n - childStrLen + 1; ++i) {     // éå†èµ·å§‹åŒ¹é…ä½ç½®\r\n        string str = s.substr(i, childStrLen);          // å–å‡ºç­‰é•¿çš„å­—ç¬¦ä¸²\r\n        unordered_map<string, int> umpT;                // çœ‹æ˜ å°„ä¸ä¹‹å‰çš„umpæ˜¯å¦ç›¸åŒ\r\n        bool flag = true;\r\n        for (int j = 0, prePos = 0; j < cnt; ++j, prePos += length) {   // å¾ªç¯å–å‡ºæ¥\r\n            string strT = str.substr(prePos, length);\r\n            umpT[strT]++;\r\n            if (ump.count(strT) == 0 || umpT[strT] > ump[strT]) {\r\n                flag = false;\r\n                break;\r\n            }\r\n        }\r\n        if (flag) res.push_back(i);\r\n    }\r\n\r\n    return res;\r\n}\r\n```\r\n> + æ—¶é—´å¤æ‚åº¦: O(lsÃ—n)ï¼Œå…¶ä¸­ ls æ˜¯è¾“å…¥ s çš„é•¿åº¦ï¼Œn æ˜¯ words ä¸­æ¯ä¸ªå•è¯çš„é•¿åº¦ã€‚éœ€è¦åš n æ¬¡æ»‘åŠ¨çª—å£ï¼Œæ¯æ¬¡éœ€è¦éå†ä¸€æ¬¡ sã€‚\r\n> + ç©ºé—´å¤æ‚åº¦: O(mÃ—n)ï¼Œå…¶ä¸­ m æ˜¯ words çš„å•è¯æ•°ï¼Œn æ˜¯ words ä¸­æ¯ä¸ªå•è¯çš„é•¿åº¦ã€‚æ¯æ¬¡æ»‘åŠ¨çª—å£æ—¶ï¼Œéœ€è¦ç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨ä¿å­˜å•è¯é¢‘æ¬¡ã€‚\r\n\r\n----\r\n\r\n## æ¨¡æ¿\r\n\r\næ— æ¨¡æ¿","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208318067","body":"# Day 25. [876. é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹](https://leetcode.cn/problems/middle-of-the-linked-list/)\r\n## æ€è·¯\r\n\r\nå¿«æ…¢æŒ‡é’ˆï¼Œæ³¨æ„å¿«æŒ‡é’ˆçš„è¾¹ç•Œæ¡ä»¶ï¼Œå½“è‡ªå·±ä¸ºç©ºæˆ–è€…ä¸‹ä¸€ä¸ªä¸ºç©ºï¼Œå®ƒçš„ ->next->next å°±ä¸åˆæ³•äº†ï¼Œå°±è¦ç»ˆæ­¢å¾ªç¯\r\n\r\n\r\n```c++\r\nListNode* middleNode(ListNode* head) {\r\n    ListNode* slow = head;\r\n    ListNode* fast = head;\r\n    while (fast != nullptr && fast->next != nullptr) {\r\n        slow = slow->next;\r\n        fast = fast->next->next;\r\n    }\r\n\r\n    return slow;\r\n}\r\n```\r\n> + æ—¶é—´å¤æ‚åº¦: O(N)ï¼ŒN ä¸ºé“¾è¡¨é•¿åº¦\r\n> + ç©ºé—´å¤æ‚åº¦: O(1)\r\n\r\n----\r\n## æ¨¡æ¿\r\n\r\næ— æ¨¡æ¿","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208355943","body":"# Day 26. [26. åˆ é™¤æœ‰åºæ•°ç»„ä¸­çš„é‡å¤é¡¹](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)\r\n## æ€è·¯\r\n\r\nåŒæŒ‡é’ˆï¼Œèµ‹å€¼å fast è·³è¿‡æ‰€æœ‰è·Ÿ lo-1 ç›¸ç­‰å€¼\r\n\r\n\r\n```c++\r\nint removeDuplicates(vector<int>& nums) {\r\n    int res;\r\n\r\n    int lo = 0, hi = 0, n = nums.size();\r\n    for (; hi < n; ) {\r\n        nums[lo++] = nums[hi];\r\n        while (hi < n && nums[hi] == nums[lo-1]) { // è·³è¿‡ç›¸ç­‰çš„ï¼Œä¸Šè¾¹ lo++ äº†ï¼Œæ‰€ä»¥è¦è·Ÿ nums[lo-1] æ¯”\r\n            hi++;\r\n        }           \r\n    }\r\n\r\n    return lo;\r\n}\r\n```\r\n> + æ—¶é—´å¤æ‚åº¦: O(N)ï¼ŒN ä¸º nums é•¿åº¦\r\n> + ç©ºé—´å¤æ‚åº¦: O(1)\r\n\r\n----\r\n\r\n## æ¨¡æ¿\r\n\r\næ— æ¨¡æ¿","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ccslience":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185589950","body":"# æ€è·¯\r\n\r\n```\r\nå½“å‰ä½ = (A çš„å½“å‰ä½ + B çš„å½“å‰ä½ + è¿›ä½carry) % 10\r\n\r\n```\r\n\r\n# ä»£ç \r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& A, int K) {\r\n        int a_len = A.size() - 1, sum = 0, carry = 0;\r\n        vector<int> res;\r\n        while (a_len >= 0 || K != 0) {\r\n            int x = a_len >= 0 ? A[a_len] : 0;\r\n            int y = K != 0 ? K % 10 : 0;\r\n            sum = x + y + carry;\r\n            carry = sum / 10;\r\n            sum %= 10;\r\n            K /= 10;\r\n            a_len--;\r\n            res.push_back(sum);\r\n        }\r\n        if (carry != 0)\r\n            res.push_back(carry);\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n# å¤æ‚åº¦\r\n+ æ—¶é—´å¤æ‚åº¦ï¼šO(n);\r\n+ ç©ºé—´å¤æ‚åº¦ï¼šO(1);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186225771","body":"# æ€è·¯\r\n```\r\nè®°å½•ä¸‹cçš„ç´¢å¼•ï¼Œç„¶åæ¯ä¸ªå­—ç¬¦æŒ¨ä¸ªæ±‚æœ€å°å€¼\r\n```\r\n\r\n# ä»£ç \r\n```\r\nvector<int> shortestToChar(string &s, char c) {\r\n        vector<int> index;\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s[i] == c) {\r\n                index.push_back(i);\r\n            }\r\n        }\r\n        vector<int> res;\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s[i] == c)\r\n                res.push_back(0);\r\n            else {\r\n                int min_index = s.length();\r\n                for (int j = 0; j < index.size(); j++) {\r\n                    int deterval = index[j] - i >= 0 ? index[j] - i : i - index[j];\r\n                    if (deterval < min_index)\r\n                        min_index = deterval;\r\n                }\r\n                res.push_back(min_index);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n```\r\n\r\n# å¤æ‚åº¦\r\n+ ç©ºé—´ï¼šO(N)\r\n+ æ—¶é—´ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186547531","body":"/*\r\n * 1. æ€è·¯: æ­£å¸¸çš„ç”¨æ•°ç»„ç›´æ¥æ“ä½œ,incrçš„æ—¶é—´å¤æ‚åº¦ä¸ºO(k), å¯ä»¥ç”¨å‰ç¼€å’Œç”¨æ—¶é—´æ¢ç©ºé—´\r\n * 2. æ—¶é—´å¤æ‚åº¦: O(1), ç©ºé—´å¤æ‚åº¦: O(1)\r\n * */\r\n \r\n```\r\nclass CustomStack\r\n{\r\npublic:\r\nCustomStack(int maxSize)\r\n{\r\n    this->maxSize = maxSize;\r\n    stack = new int[maxSize];\r\n    incre = new int[maxSize];\r\n    cur = 0;\r\n}\r\n\r\nvoid push(int x)\r\n{\r\n    if (cur == maxSize)\r\n        return;\r\n    stack[cur] = x;\r\n    incre[cur] = 0;\r\n    cur++;\r\n}\r\n\r\nint pop()\r\n{\r\n    if (cur == 0)\r\n        return -1;\r\n    int res = stack[cur - 1] + incre[cur - 1];\r\n    if (cur > 1)\r\n        incre[cur - 2] += incre[cur - 1];\r\n    incre[cur - 1] = 0;\r\n    cur--;\r\n    return res;\r\n}\r\n\r\nvoid increment(int k, int val)\r\n{\r\n    if (cur == 0)\r\n        return ;\r\n    if (k > cur)\r\n        incre[cur - 1] += val;\r\n    else\r\n        incre[k - 1] += val;\r\n}\r\n\r\n~CustomStack()\r\n{\r\n    delete[] stack;\r\n    delete[] incre;\r\n}\r\nprivate:\r\nint maxSize;\r\nint* stack;\r\nint* incre;\r\nint cur;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186853934","body":"/*\r\n * 1ã€æ€è·¯: åˆ©ç”¨æ ˆï¼Œé']'å³å…¥æ ˆï¼Œå¦åˆ™å‡ºæ ˆ;\r\n * 2ã€å‡ºæ ˆçš„æ—¶å€™æ³¨æ„å°†ä¸€ä¸ª[]ä¹‹å†…è§£ç å¥½çš„å‹å›æ ˆï¼Œæœ€ååœ¨å¯¹æ ˆä¸­æ‰€æœ‰è§£ç åçš„å­—ç¬¦ä¸²è¿›è¡Œæ‹¼æ¥;\r\n * 2ã€éœ€è¦æ³¨æ„charè½¬stringï¼Œåˆ©ç”¨stringçš„æ„é€ å‡½æ•°string(n, char);\r\n * 3ã€æ•°å­—å¯èƒ½æ˜¯å¤šä½çš„ï¼Œå› æ­¤éœ€è¦æ³¨æ„è½¬æ¢;\r\n * 4ã€æ—¶é—´å¤æ‚åº¦O(n), ç©ºé—´å¤æ‚åº¦O(n)\r\n * */\r\n\r\n```\r\nstring decodeString(string &s)\r\n    {\r\n        stack<string> data;\r\n        for(int i = 0; i < s.length(); i++)\r\n        {\r\n            // æ•°å­—ã€å­—æ¯å’Œå·¦æ–¹æ‹¬å·å…¥æ ˆ\r\n            if ((s[i] >= '0' && s[i] <= '9') || (s[i] == '[') || (s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z'))\r\n            {\r\n                data.push(string(1, s[i]));\r\n            }\r\n                // å³æ–¹æ‹¬å·å‡ºæ ˆ\r\n            else\r\n            {\r\n                string cur = \"\";\r\n                while(data.top().data()[0] != '[')\r\n                {\r\n                    cur = data.top() + cur;\r\n                    data.pop();\r\n                }\r\n                data.pop();\r\n                // å–æ•´æ•°\r\n                int digit = 0;\r\n                int carry = 1;\r\n                while(!data.empty() && data.top().data()[0] >= '0' && data.top().data()[0] <= '9')\r\n                {\r\n                    digit = digit + (data.top().data()[0] - '0') * carry;\r\n                    carry *= 10;\r\n                    data.pop();\r\n                }\r\n                string res = \"\";\r\n                for (int j = 0; j < digit; j++)\r\n                    res += cur;\r\n                data.push(res);\r\n            }\r\n        }\r\n        string res = \"\";\r\n        while(!data.empty())\r\n        {\r\n            res = data.top() + res;\r\n            data.pop();\r\n        }\r\n        return res;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189128910","body":"/*\r\n * leetcode: 232\r\n * ç”¨ä¸¤ä¸ªæ ˆæ¨¡æ‹Ÿé˜Ÿåˆ—,å¯ä»¥é€šè¿‡åœ¨popæ—¶åªæœ‰reverseä¸ºç©ºæ—¶å†å€’è…¾æ ˆæ¥ä¼˜åŒ–\r\n * æ—¶é—´å¤æ‚åº¦:å‡æ‘ŠO(1), ç©ºé—´å¤æ‚åº¦:O(n)\r\n * */\r\n\r\n```\r\nclass MyQueue{\r\npublic:\r\n    MyQueue()\r\n    {\r\n\r\n    }\r\n\r\n    void push(int x)\r\n    {\r\n        normal_stack.push(x);\r\n    }\r\n\r\n    int pop()\r\n    {\r\n        if (reverse_stack.empty())\r\n        {\r\n            while(!normal_stack.empty())\r\n            {\r\n                reverse_stack.push(normal_stack.top());\r\n                normal_stack.pop();\r\n            }\r\n        }\r\n\r\n        int res = reverse_stack.top();\r\n        reverse_stack.pop();\r\n        return res;\r\n    }\r\n\r\n    int peek()\r\n    {\r\n        if (reverse_stack.empty())\r\n        {\r\n            while(!normal_stack.empty())\r\n            {\r\n                reverse_stack.push(normal_stack.top());\r\n                normal_stack.pop();\r\n            }\r\n        }\r\n\r\n        int res = reverse_stack.top();\r\n        return res;\r\n    }\r\n\r\n    bool empty()\r\n    {\r\n        return (normal_stack.empty() && reverse_stack.empty());\r\n    }\r\nprivate:\r\n    stack<int> normal_stack;\r\n    stack<int> reverse_stack;\r\n\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190458724","body":"/*\r\n * 1.æ€è·¯: å•è°ƒæ ˆå¤§å€¼èåˆå°å€¼æ„æˆé€’å¢æ ˆ\r\n * 2.æ—¶é—´å¤æ‚åº¦: O(n), ç©ºé—´å¤æ‚åº¦:O(n)\r\n * */\r\n ```\r\nint maxChunksToSorted(vector<int>& arr)\r\n    {\r\n        stack<int> info;\r\n        int max_value;\r\n        for(auto it: arr)\r\n        {\r\n            if(!info.empty() && it < info.pop())\r\n            {\r\n                max_value = info.top();\r\n                if(it < max_value)\r\n                {\r\n                    while(!info.empty() && info.top() > it)\r\n                    {\r\n                        info.pop();\r\n                    }\r\n                    info.push(max_value);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                info.push(it);\r\n            }   \r\n        }\r\n        return info.size();\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191587809","body":"/*\r\n * 1. æ€è·¯:å¿«æ…¢æŒ‡é’ˆæ‰¾åˆ°å€’æ•°ç¬¬kä¸ªèŠ‚ç‚¹ç„¶åæ–­é“¾é‡æ‹¼\r\n * 2. æ—¶é—´å¤æ‚åº¦:O(n), ç©ºé—´å¤æ‚åº¦O(1)\r\n * */\r\n ```\r\nListNode* rotateRight(ListNode *head, int k)\r\n    {\r\n        if(head == nullptr)\r\n            return nullptr;\r\n        int len_list = 0;\r\n        ListNode *p = head;\r\n        while(p)\r\n        {\r\n            len_list++;\r\n            p = p->next;\r\n        }\r\n        k = k % len_list;\r\n        ListNode *slow, *fast;\r\n        slow = head;\r\n        fast = head;\r\n        for(int i = 0; i < k; i++)\r\n        {\r\n            fast = fast->next;\r\n        }\r\n        while(fast->next)\r\n        {\r\n            slow = slow->next;\r\n            fast = fast->next;\r\n        }\r\n        ListNode *new_head = slow->next;\r\n        slow->next = nullptr;\r\n        fast->next = head;\r\n        return new_head;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192144541","body":"/*\r\n * 1. æ€è·¯1: ä¸¤ä¸¤äº¤æ¢ï¼Œè®°å½•åœ¨äº¤æ¢è¿‡ç¨‹ä¸­ä¼šæ–­è¿çš„èŠ‚ç‚¹ï¼Œlast_tailå’Œnew_head;\r\n * 2. æ€è·¯1æ—¶é—´å¤æ‚åº¦: O(n), ç©ºé—´å¤æ‚åº¦O(1)\r\n * 3. æ€è·¯2(é€’å½’): (1)å…³æ³¨æœ€å°å­ç»“æ„å³å°†ä¸¤ä¸ªèŠ‚ç‚¹é€†è½¬;\r\n *               (2)å½“å‰çš„ç¬¬äºŒä¸ªèŠ‚ç‚¹çš„nextä¸ºä¸‹ä¸€æ¬¡é€’å½’çš„èµ·ç‚¹;\r\n *               (3)é€’å½’è¿”å›é€†è½¬åçš„å¤´èŠ‚ç‚¹;\r\n *               (4)å°†é€†è½¬ç»“æœèµ‹å€¼ç»™headçš„next.\r\n * 4. æ€è·¯2æ—¶é—´å¤æ‚åº¦: O(n), ç©ºé—´å¤æ‚åº¦: O(1)(ä¸è€ƒè™‘é€’å½’é€ æˆçš„å‡½æ•°æ ˆ)\r\n * */\r\n \r\n```\r\nListNode *swapPairs(ListNode *head) {\r\n        if (head == nullptr || head->next == nullptr)\r\n            return head;\r\n        ListNode *p, *q, *new_head, *last_tail;\r\n        new_head = head->next;\r\n        p = head;\r\n        q = head->next;\r\n        last_tail = nullptr;\r\n        while (p && q) {\r\n            ListNode *tmp_head = q->next;\r\n            // äº¤æ¢\r\n            if (q != nullptr) {\r\n                p->next = tmp_head;\r\n                q->next = p;\r\n\r\n            }\r\n            // æ‹¼æ¥\r\n            if (last_tail != nullptr) {\r\n                last_tail->next = q;\r\n            }\r\n            last_tail = p;\r\n            // æŒªæŒ‡é’ˆ\r\n            p = tmp_head;\r\n            if (p != nullptr)\r\n                q = p->next;\r\n        }\r\n        return new_head;\r\n    }\r\n\r\n    ListNode *swapPairs_v1(ListNode *head)\r\n    {\r\n        if(head == nullptr || head->next == nullptr)\r\n            return head;\r\n        ListNode *next = head->next;\r\n        head->next = swapPairs_v1(next->next);\r\n        next->next = head;\r\n        return next;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193097937","body":"/*\r\n * 1.æ€è·¯: åˆ†ææ¯æ¬¡æ‰¾åˆ°ä¸­é—´å€¼ç„¶åé€’å½’æ„é€ å·¦å³å­æ ‘;\r\n * 2.é€’å½’çš„ä¸‰ä¸ªè¦ç‚¹:a.åˆ¤æ–­å­ç»“æ„åŠé€€å‡ºé€’å½’è¾¹ç•Œ;b.å¦‚ä½•ä»å½“å‰é€’å½’è¿›å…¥ä¸‹ä¸€æ¬¡é€’å½’;c.å½“å‰é€’å½’ä¸é€’å½’è¿”å›å€¼çš„å…³ç³».\r\n * 3.æ—¶é—´å¤æ‚åº¦O(nlogn), ç©ºé—´å¤æ‚åº¦O(logn)\r\n * 4.æ—¶é—´å¤æ‚åº¦è§£æ:é€’å½’æ ‘æ·±logn, æ¯ä¸€å±‚é€’å½’æ ‘çš„æ—¶é—´å¤æ‚åº¦ä¸º2*(n / 2)=n, æ‰€ä»¥æ€»çš„æ—¶é—´å¤æ‚åº¦ä¸ºnlogn, n/2å³å¯»æ‰¾ä¸­é—´èŠ‚ç‚¹çš„æ—¶é—´å¤æ‚åº¦\r\n * 5.ç©ºé—´å¤æ‚åº¦åˆ†æ:é€’å½’æ ‘æ·±logn, æ¯ä¸€å±‚é€’å½’æ ‘çš„ç©ºé—´å¤æ‚åº¦ä¸ºO(1), æ‰€ä»¥æ€»çš„ç©ºé—´å¤æ‚åº¦ä¸ºlogn\r\n * */\r\n \r\n```\r\nTreeNode* toBST(ListNode*head, int len)\r\n    {\r\n        if (head == nullptr || len == 0)\r\n            return nullptr;\r\n        // åˆ¤æ–­è¾¹ç•Œæ¡ä»¶\r\n        if(len == 1)\r\n        {\r\n            TreeNode *node = new TreeNode(head->val);\r\n            return node;\r\n        }\r\n        ListNode *p;\r\n        p = head;\r\n        for(int k = 0; k < len / 2; k++)\r\n            p = p->next;\r\n        TreeNode *new_head = new TreeNode(p->val);\r\n        int left_length = len / 2;\r\n        int right_length = len / 2;\r\n        if (len % 2 == 0)\r\n            right_length = len / 2 - 1;\r\n        new_head->left = toBST(head, left_length);\r\n        new_head->right = toBST(p->next, right_length);\r\n        return new_head;\r\n    }\r\n\r\nTreeNode* sortedListToBST(ListNode* head)\r\n    {\r\n        if(head == nullptr)\r\n            return nullptr;\r\n        int len = 0;\r\n        ListNode *p = head;\r\n        while(p)\r\n        {\r\n            len++;\r\n            p = p->next;\r\n        }\r\n        return toBST(head, len);\r\n    }\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193284161","body":"/*\r\n * 1. é¢˜ç›®ç†è§£: æœ€å¼€å§‹ç†è§£æˆç»“ç‚¹çš„å€¼ç›¸ç­‰äº†,ç„¶è€Œé¢˜ç›®æ˜¯ç»“ç‚¹ç›¸ç­‰,åŒ…æ‹¬ç»“ç‚¹çš„å€¼å’Œnextå³æŒ‡å‘ç»“ç‚¹çš„æŒ‡é’ˆ(åœ°å€)ç›¸ç­‰;\r\n * 2. æ€è·¯1: ç©ºé—´æ¢æ—¶é—´, å…ˆéå†Aç„¶åéå†Bæ‰¾Bä¸­æ˜¯å¦å«Aä¸­çš„ç»“ç‚¹,å«åˆ™è¿”å›;\r\n * 3. æ€è·¯1: æ—¶é—´å¤æ‚åº¦O(n), ç©ºé—´å¤æ‚åº¦O(n);\r\n * 4. æ€è·¯2: ä¸¤ä¸ªæŒ‡é’ˆp,qåˆ†åˆ«ä»headAå’ŒheadBå¼€å§‹éå†ä¸€éä¸¤ä¸ªé“¾è¡¨,ç›¸ç­‰åˆ™åœæ­¢éå†,è¯´æ˜æ‰¾åˆ°äº†ç›¸äº¤çš„ç»“ç‚¹,\r\n * 5. headA:A+C, headB:B+C,éå†å®Œpéå†äº†A+C+B, qéå†äº†B+C+A;\r\n * 6. æ€è·¯2: æ—¶é—´å¤æ‚åº¦O(n), ç©ºé—´å¤æ‚åº¦O(1).\r\n * */\r\n\r\n```\r\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB)\r\n    {\r\n        map<ListNode*, bool> infoA;\r\n        ListNode *p = headA;\r\n        while(p)\r\n        {\r\n            infoA[p] = true;\r\n            p = p->next;\r\n        }\r\n        p = headB;\r\n        while(p)\r\n        {\r\n            if(infoA.find(p) != infoA.end()) return p;\r\n            p = p->next;\r\n        }\r\n        return nullptr;\r\n    }\r\n\r\n    ListNode *getIntersectionNodev1(ListNode *headA, ListNode *headB)\r\n    {\r\n        ListNode *a = headA;\r\n        ListNode *b = headB;\r\n        while(a != b)\r\n        {\r\n            a = a == nullptr ? headB : a->next;\r\n            b = b == nullptr ? headA:  b->next;\r\n        }\r\n        return a;\r\n\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194214380","body":"/*\r\n * 1.æ€è·¯ï¼‘:ç©ºé—´æ¢æ—¶é—´,ã€€è¾¹éå†è¾¹å­˜åˆ°å“ˆå¸Œè¡¨ä¸­ï¼Œè‹¥é‡åˆ°åœ¨å“ˆå¸Œè¡¨åœ¨ä¸­å­˜åœ¨çš„ç»“ç‚¹åˆ™è¯´æ˜æ˜¯ç¯çš„èµ·å§‹ç‚¹ï¼›\r\n * 2.æ€è·¯ï¼‘æ—¶é—´å¤æ‚åº¦:O(n), ç©ºé—´å¤æ‚åº¦O(n);\r\n * 3.æ€è·¯2: å¿«æ…¢æŒ‡é’ˆ, å¿«æŒ‡é’ˆæ¯æ¬¡buæ­¥é•¿ä¸º2, mæ…¢æŒ‡é’ˆæ­¥ï½ƒé•¿ä¸ºï¼‘, å½“å¿«æ…¢æŒ‡é’ˆç¬¬ä¸€æ¬¡ç›¸é‡æ—¶;\r\n * 4.æ€è·¯2:æ…¢æŒ‡é’ˆæŒ‡å‘ä¸‹ä¸€ä¸ª,å¿«æŒ‡é’ˆæŒ‡å‘å¤´ç»“ç‚¹, å¿«æ…¢æŒ‡é’ˆéƒ½ä»¥æ­¥é•¿ä¸º1å¾€å‰èµ°,è¿™æ ·å†æ¬¡ç›¸é‡æ—¶å³ä¸ºç¯å¼€å§‹çš„ç»“ç‚¹;\r\n * 5.æ€è·¯2åˆ†è§£,å‡è®¾é“¾åˆ†ä¸ºL+C,Cä¸ºç¬¬ä¸€æ¬¡ç›¸é‡çš„ç»“ç‚¹,ç¯é•¿ç­‰äºC+D, é‚£ä¹ˆç¬¬ä¸€æ¬¡ç›¸é‡æ…¢æŒ‡é’ˆèµ°äº†L+n1*(C+D)+C\r\n * 5.æ€è·¯2åˆ†è§£,ç¬¬ä¸€æ¬¡ç›¸é‡å¿«æŒ‡é’ˆèµ°äº†L+n2*(C+D)+C,åˆå› ä¸ºå¿«æŒ‡é’ˆèµ°çš„è·ç¦»æ˜¯æ…¢æŒ‡é’ˆçš„ä¸¤å€,æ‰€ä»¥å­˜åœ¨ç­‰å¼:\r\n * 5.æ€è·¯2åˆ†è§£,2*(L+n1*(C+D)+C) = L+n2*(C+D)+C, æ•´ç†å¯å¾—, L = (2*n2-n1-1)*(C+D) + D\r\n * 5.æ€è·¯2åˆ†è§£,è¿™æ ·qèµ°Lç­‰äºpèµ°D,på’Œqåœ¨ç¯èµ·å§‹ç‚¹ç›¸é‡.\r\n * 6.æ€è·¯2æ—¶é—´å¤æ‚åº¦:O(n), ç©ºé—´å¤æ‚åº¦O(1).\r\n * */\r\n\r\n```\r\nListNode *detectCycle(ListNode *head)\r\n    {\r\n        map<ListNode*, bool> data;\r\n        ListNode *p = head;\r\n        while(p && data.find(p) == data.end())\r\n        {\r\n            data[p] = true;\r\n            p = p->next;\r\n        }\r\n        return p;\r\n    }\r\n\r\n    ListNode *detectCyclev1(ListNode *head)\r\n    {\r\n        if (head == nullptr || head->next == nullptr)\r\n            return nullptr;\r\n        ListNode *p, *q;\r\n        p = head;\r\n        q = head->next;\r\n        while(p != q)\r\n        {\r\n            p = p->next;\r\n            if (q && q->next)\r\n                q = q->next->next;\r\n            else\r\n                q = nullptr;\r\n        }\r\n        if (p == nullptr)\r\n            return nullptr;\r\n        q = head;\r\n        p = p->next;\r\n        while(p != q)\r\n        {\r\n            p = p->next;\r\n            q = q->next;\r\n        }\r\n        return p;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195309209","body":"/*\r\n * 1.æ€è·¯1: ç”¨ä¸¤ä¸ªå“ˆå¸Œè¡¨ï¼Œä¸€ä¸ªå­˜keyå’Œvalueï¼Œä¸€ä¸ªå­˜æœ€åä¸€æ¬¡è¢«è®¿é—®çš„æ—¶é—´;\r\n * 2.æ€è·¯1æ—¶é—´å¤æ‚åº¦:O(n), ç©ºé—´å¤æ‚åº¦:O(n).\r\n * 3.æ€è·¯2: ç”¨åŒå‘é“¾è¡¨ç»“åˆå“ˆå¸Œè¡¨æ¥å®ç°ï¼ŒåŒå‘é“¾è¡¨ä¸ºè®¿é—®çš„å…ˆåé¡ºåºï¼Œå“ˆå¸Œè¡¨å­˜keyå¯¹åº”çš„ç»“ç‚¹ä»¥èŠ‚çœé“¾è¡¨æŸ¥æ‰¾ç»“ç‚¹çš„æ—¶é—´;\r\n * 3.æ€è·¯2: ç”¨ä¸¤ä¸ªç©ºçš„ç»“ç‚¹æ¥è¡¨ç¤ºheadå’Œtailï¼Œä»¥å…¼å®¹å¤´ç»“ç‚¹å°¾ç»“ç‚¹å˜åŒ–çš„æƒ…å†µ;\r\n * 4.æ€è·¯2çš„æ—¶é—´å¤æ‚åº¦:O(1), ç©ºé—´å¤æ‚åº¦:O(n)\r\n * */\r\n \r\n```\r\nclass LRUCache\r\n{\r\npublic:\r\n    LRUCache(int capacity)\r\n    {\r\n        cap = capacity;\r\n        cur = 0;\r\n        len = 0;\r\n    }\r\n\r\n    int get(int key)\r\n    {\r\n        if(info.find(key) != info.end())\r\n        {\r\n            cur++;\r\n            update[key] = cur;\r\n            return info[key];\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    void put(int key, int value)\r\n    {\r\n        if(len == cap && info.find(key) == info.end())\r\n        {\r\n            // åˆ é™¤æœ€ä¹…æœªä½¿ç”¨çš„\r\n            int min_use = cur + 1;\r\n            int min_key;\r\n            for(auto it : update)\r\n            {\r\n                if(it.second < min_use)\r\n                {\r\n                    min_use = it.second;\r\n                    min_key = it.first;\r\n                }\r\n            }\r\n            info.erase(min_key);\r\n            update.erase(min_key);\r\n            len--;\r\n        }\r\n        cur++;\r\n        if (info.find(key) == info.end())\r\n            len++;\r\n        info[key] = value;\r\n        update[key] = cur;\r\n\r\n    }\r\n\r\n\r\nprivate:\r\n    int cap;\r\n    int cur;\r\n    int len;\r\n    unordered_map<int, int> info;\r\n    unordered_map<int, int> update;\r\n\r\n};\r\n```\r\n\r\n```\r\nstruct DLinkedNode\r\n{\r\n    int key;\r\n    int value;\r\n    DLinkedNode *pre;\r\n    DLinkedNode *next;\r\n    DLinkedNode(): key(0), value(0), pre(nullptr), next(nullptr) {}\r\n    DLinkedNode(int key, int value): key(key), value(value), pre(nullptr), next(nullptr) {}\r\n    DLinkedNode(int key, int value, DLinkedNode *pre, DLinkedNode *next): key(key), value(value), pre(pre), next(next) {}\r\n};\r\n\r\nclass LRUCache\r\n{\r\npublic:\r\n    LRUCache(int capacity)\r\n    {\r\n        cap = capacity;\r\n        info_len = 0;\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head->next = tail;\r\n        tail->pre = head;\r\n    }\r\n\r\n    void update_tail(DLinkedNode *p)\r\n    {\r\n        p->pre->next = p->next;\r\n        p->next->pre = p->pre;\r\n\r\n        p->pre = tail->pre;\r\n        tail->pre->next = p;\r\n        p->next = tail;\r\n        tail->pre = p;\r\n    }\r\n\r\n    int get(int key)\r\n    {\r\n        if(info.find(key) != info.end())\r\n        {\r\n            // æ›´æ–°é“¾è¡¨é¡ºåº\r\n            DLinkedNode *p = info[key];\r\n            update_tail(p);\r\n            return info[key]->value;\r\n\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    void put(int key, int value)\r\n    {\r\n        // å½“å‰keyä¸å­˜åœ¨\r\n        if(info.find(key) == info.end())\r\n        {\r\n            // åˆ¤æ–­å½“å‰çš„é•¿åº¦æ˜¯å¦è¾¾åˆ°capï¼Œè¾¾åˆ°åˆ™åˆ é™¤å¤´ç»“ç‚¹\r\n            if(info_len == cap)\r\n            {\r\n                // å°†å¤´ç»“ç‚¹åˆ é™¤\r\n                DLinkedNode *p = head->next;\r\n                head->next = p->next;\r\n                p->next->pre = head;\r\n                info_len--;\r\n                info.erase(p->key);\r\n                delete p;\r\n\r\n            }\r\n            info_len++;\r\n            DLinkedNode *p = new DLinkedNode(key, value);\r\n            // ä¿®æ”¹å°¾æŒ‡é’ˆ\r\n            tail->pre->next = p;\r\n            p->pre = tail->pre;\r\n            p->next = tail;\r\n            tail->pre = p;\r\n            info[key] = p;\r\n        }\r\n        // å½“å‰keyå·²å­˜åœ¨\r\n        else\r\n        {\r\n            // å°†keyæŒªåˆ°æœ€å\r\n            DLinkedNode *p = info[key];\r\n            p->value = value;\r\n            update_tail(p);\r\n        }\r\n    }\r\n\r\n\r\n\r\nprivate:\r\n    // ç›®çš„å°±æ˜¯å‡å°‘é“¾è¡¨æŸ¥æ‰¾ç»“ç‚¹å¤æ‚åº¦ï¼ŒæŸ¥æ‰¾æ–¹ä¾¿\r\n    unordered_map<int, DLinkedNode*> info;\r\n    //åŒå‘é“¾è¡¨å­˜å‚¨ç»“ç‚¹çš„è®¿é—®å…ˆåï¼Œä¼˜å…ˆæ˜¯å·²çŸ¥ç»™å®šèŠ‚ç‚¹ï¼Œæ’å…¥ï¼Œåˆ é™¤æ–¹ä¾¿ï¼›\r\n    // ç»“ç‚¹åœ¨é“¾è¡¨ä¸­ä»å¤´åˆ°å°¾ä¸ºï¼Œæœ€æ—©è®¿é—® -> æœ€è¿‘è®¿é—®çš„é¡ºåºï¼›\r\n    // æ‰€ä»¥å¤´ç»“ç‚¹ä¸ºæœ€æ—©è®¿é—®çš„ç»“ç‚¹ï¼Œå½“å½“å‰é“¾è¡¨çš„é•¿åº¦ä¸ºcapä¸”è¦putçš„æ—¶å€™è¦å°†å¤´ç»“ç‚¹åˆ é™¤ï¼Œå°†æœ€æ–°çš„ç»“ç‚¹æ”¾åˆ°tailçš„preï¼›\r\n    // headçš„nextæŒ‡å‘å¤´ç»“ç‚¹ï¼Œtailçš„preæŒ‡å‘å°¾ç»“ç‚¹.\r\n    DLinkedNode *head, *tail;\r\n    int cap;\r\n    int info_len;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196301951","body":"/*\r\n * 1.æ€è·¯:é€’å½’å¥—è·¯ï¼Œæ‰¾åˆ°å­ç»“æ„ï¼Œç¡®å®šè¾¹ç•Œæ¡ä»¶ï¼Œç¡®å®šæ€ä¹ˆå…¥é€’å½’ï¼Œç¡®å®šé€’å½’è¿”å›å€¼ä¸å½“å‰çš„å…³ç³»ï¼›\r\n * 2.æ—¶é—´å¤æ‚åº¦:O(n), æ¯æ¬¡éå†ä¸€ä¸ªç»“ç‚¹, ç©ºé—´å¤æ‚åº¦:O(h), hä¸ºæ ‘çš„é«˜åº¦ï¼Œæœ€å¿«çš„æƒ…å†µä¸ºé€€åŒ–æˆå•é“¾è¡¨ä¸ºO(n)\r\n * */\r\n *\r\n```\r\nclass Solution\r\n{\r\npublic:\r\n    int dfs(TreeNode* root, int cnt)\r\n    {\r\n        // åˆ¤æ–­é€€å‡ºæ¡ä»¶\r\n        if(root->left == nullptr && root->right == nullptr)\r\n        {\r\n            return cnt+1;\r\n        }\r\n        // è¿›å…¥ä¸‹ä¸€æ¬¡é€’å½’\r\n        cnt++;\r\n        int cnt_left = 0;\r\n        if(root->left)\r\n            cnt_left = dfs(root->left, cnt);\r\n        // é€’å½’é€€å‡ºä¸å½“å‰çš„å…³ç³»\r\n        if (cnt_left > depth)\r\n            depth = cnt_left;\r\n        // å·¦è¾¹éå†å®Œäº†éå†å³è¾¹\r\n        int cnt_right = 0;\r\n        if(root->right)\r\n            cnt_right = dfs(root->right, cnt);\r\n        if (cnt_right > depth)\r\n            depth = cnt_right;\r\n        // éƒ½éå†å®Œäº†è¿”å›\r\n        return depth;\r\n    }\r\n    int maxDepth(TreeNode* root)\r\n    {\r\n        depth = 0;\r\n        if (root == nullptr)\r\n            return depth;\r\n        int cnt = 0;\r\n        return dfs(root, cnt);\r\n    }\r\nprivate:\r\n    int depth;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197585745","body":"/*\r\n * 1.æ€è·¯: å±‚åºéå†åŠ æ ‡è®°å·¦å³å­æ ‘,åˆ¤æ–­ç»“æ„æ˜¯å¦ç›¸ç­‰;\r\n * 2.æ—¶é—´å¤æ‚åº¦:O(n), ç©ºé—´å¤æ‚åº¦:O(n).\r\n * */\r\n \r\n```\r\nbool isSameTree(TreeNode* p, TreeNode* q)\r\n    {\r\n        queue<TreeNode*> info_p, info_q;\r\n        if (p != nullptr)\r\n            info_p.push(p);\r\n        if (q != nullptr)\r\n            info_q.push(q);\r\n        while(!info_p.empty())\r\n        {\r\n            TreeNode *head_p = info_p.front();\r\n            int p_left = 0, p_right = 0;\r\n            if (head_p->left)\r\n            {\r\n                info_p.push(head_p->left);\r\n                p_left = 1;\r\n            }\r\n            if(head_p->right)\r\n            {\r\n                info_p.push(head_p->right);\r\n                p_right = 1;\r\n            }\r\n            info_p.pop();\r\n\r\n            if(!info_q.empty())\r\n            {\r\n                TreeNode *head_q = info_q.front();\r\n                int q_left = 0, q_right = 0;\r\n\r\n                if (head_q->left)\r\n                {\r\n                    info_q.push(head_q->left);\r\n                    q_left = 1;\r\n                }\r\n                if(head_q->right)\r\n                {\r\n                    info_q.push(head_q->right);\r\n                    q_right = 1;\r\n                }\r\n                info_q.pop();\r\n                if(p_left != q_left || p_right != q_right || head_p->val != head_q->val)\r\n                    return false;\r\n            }\r\n            else\r\n            {\r\n                return false;\r\n            }\r\n\r\n        }\r\n        if(!info_q.empty())\r\n            return false;\r\n        return true;\r\n\r\n    }\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198825268","body":"/*\r\n * 1.æ€è·¯1: dfså¸¦è®°å½•çš„é€’å½’, é€’å½’å››è¦ç´ : a.åˆ†è§£å­ç»“æ„åŠåˆ¤æ–­é€€å‡ºæ¡ä»¶;b.å½“å‰é€’å½’æ˜¯å¦éœ€è¦æ“ä½œ;c.å¦‚ä½•è¿›å…¥ä¸‹ä¸€æ¬¡é€’å½’;d.é€’å½’è¿”å›ä¸å½“å‰é€’å½’çš„å…³ç³»;\r\n * 2.æ€è·¯1æ—¶é—´å¤æ‚åº¦:O(n), ç©ºé—´å¤æ‚åº¦:O(h), hä¸ºæ ‘çš„é«˜åº¦ï¼Œæœ€åæƒ…å†µä¸ºé€€åŒ–æˆå•é“¾è¡¨æ­¤æ—¶ä¸ºO(n);\r\n *\r\n * 3.æ€è·¯2: é˜Ÿåˆ—å®ç°bfs, bfsä¹Ÿèƒ½æ‰¾åˆ°å­ç»“ç‚¹;\r\n * 3.æ€è·¯2åˆ†æ: æŠ€å·§åœ¨äºæ‰¾åˆ°å­ç»“ç‚¹åæ€ä¹ˆè®°å½•åˆ°å­ç»“ç‚¹çš„æ•°å€¼, æ–¹æ³•æ˜¯æ¯éå†åˆ°ä¸€ä¸ªç»“ç‚¹å°±ä¿®æ”¹è¯¥ç»“ç‚¹çš„valå€¼ä¸ºåˆ°è¯¥ç»“ç‚¹å¯¹åº”çš„æ•´æ•°å€¼;\r\n * 3.æ€è·¯2æ—¶é—´å¤æ‚åº¦:O(n), ç©ºé—´å¤æ‚åº¦O(q), qä¸ºé˜Ÿåˆ—é•¿åº¦, æœ€åçš„æƒ…å†µæ˜¯æ»¡äºŒå‰æ ‘ï¼Œæ­¤æ—¶å’Œ n åŒé˜¶\r\n * */\r\n\r\n```\r\nvoid dfs(TreeNode *root, int k, int &sum) {\r\n        // å½“å‰é€’å½’æ“ä½œ\r\n        k = k * 10 + root->val;\r\n        // åˆ¤æ–­é€€å‡ºæ¡ä»¶\r\n        if (root->left == nullptr && root->right == nullptr) {\r\n            sum += k;\r\n            return;\r\n        }\r\n        // è¿›å…¥ä¸‹ä¸€æ¬¡é€’å½’\r\n        if (root->left)\r\n            dfs(root->left, k, sum);\r\n        if (root->right)\r\n            dfs(root->right, k, sum);\r\n    }\r\n\r\n    int sumNumbersv1(TreeNode *root) {\r\n        if (root == nullptr)\r\n            return 0;\r\n        int sumTree = 0;\r\n        dfs(root, 0, sumTree);\r\n        return sumTree;\r\n    }\r\n\r\nint sumNumbers(TreeNode* root)\r\n    {\r\n        int res = 0;\r\n        queue<TreeNode*> info;\r\n        if(root != nullptr)\r\n            info.push(root);\r\n        while(!info.empty())\r\n        {\r\n            TreeNode *tmp = info.front();\r\n            info.pop();\r\n            if(tmp->left)\r\n            {\r\n                tmp->left->val = tmp->val * 10 + tmp->left->val;\r\n                info.push(tmp->left);\r\n            }\r\n            if(tmp->right)\r\n            {\r\n                tmp->right->val = tmp->val * 10 + tmp->right->val;\r\n                info.push(tmp->right);\r\n            }\r\n            if(tmp->left == nullptr && tmp->right == nullptr)\r\n            {\r\n                res += tmp->val;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200110462","body":"/*\r\n * 1.æ€è·¯1: å¸¦æ·±åº¦è®°å½•çš„dfs;\r\n * 2.æ—¶é—´å¤æ‚åº¦:O(n), ç©ºé—´å¤æ‚åº¦:O(h), hä¸ºæ ‘çš„é«˜åº¦ï¼Œæœ€åæƒ…å†µä¸ºé€€åŒ–æˆå•é“¾è¡¨æ­¤æ—¶ä¸ºO(n);\r\n * \r\n * 3.æ€è·¯2: å±‚åºéå†, ç”¨é¢å¤–çš„ä¸€ä¸ªqueueæ¥è®°å½•æ·±åº¦\r\n * 4.æ€è·¯2æ—¶é—´å¤æ‚åº¦:O(n), ç©ºé—´å¤æ‚åº¦:O(q), å…¶ä¸­qä¸ºé˜Ÿåˆ—é•¿åº¦ï¼Œæœ€åçš„æƒ…å†µæ˜¯æ»¡äºŒå‰æ ‘ï¼Œæ­¤æ—¶å’ŒnåŒé˜¶ï¼Œå…¶ä¸­nä¸ºæ ‘çš„èŠ‚ç‚¹æ€»æ•°\r\n * */\r\n```\r\nvoid dfs(TreeNode* root, int len)\r\n    {\r\n        // åˆ¤æ–­ç»“æŸæ¡ä»¶\r\n        if (root->left == nullptr && root->right == nullptr)\r\n        {\r\n            len++;\r\n            if (len > max_length)\r\n            {\r\n                max_length = len;\r\n                left = root->val;\r\n            }\r\n\r\n        }\r\n        // å½“å‰æ“ä½œ\r\n        len++;\r\n        // è¿›å…¥ä¸‹ä¸€æ¬¡é€’å½’\r\n        if(root->left)\r\n            dfs(root->left, len);\r\n        if(root->right)\r\n            dfs(root->right, len);\r\n    }\r\n    int findBottomLeftValuev1(TreeNode* root)\r\n    {\r\n        max_length = -1;\r\n        dfs(root, 0);\r\n        return left;\r\n    }\r\n    int findBottomLeftValue(TreeNode* root)\r\n    {\r\n        queue<TreeNode*> info;\r\n        queue<int> info_len;\r\n        info.push(root);\r\n        info_len.push(1);\r\n        int treelen = 0;\r\n        int max_left;\r\n        while(!info.empty())\r\n        {\r\n            TreeNode *p = info.front();\r\n            info.pop();\r\n            int len = info_len.front();\r\n            info_len.pop();\r\n            if(p->left == nullptr && p->right == nullptr)\r\n            {\r\n                if (len > treelen)\r\n                {\r\n                    treelen = len;\r\n                    max_left = p->val;\r\n                }\r\n            }\r\n            len++;\r\n            if(p->left)\r\n            {\r\n                info.push(p->left);\r\n                info_len.push(len);\r\n            }\r\n            if(p -> right)\r\n            {\r\n                info.push(p->right);\r\n                info_len.push(len);\r\n            }\r\n        }\r\n        return max_left;\r\n    }\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200442036","body":"/*\r\n * 1. æ€è·¯1: bfs, è¿™é‡Œéœ€è¦å¤„ç†ç©ºç»“ç‚¹æ‰€ä»¥å…¥é˜Ÿåˆ—çš„æ—¶å€™æŠŠç©ºç»“ç‚¹å…¥é˜Ÿ;\r\n * 2. æ€è·¯1åˆ†æ: åœ¨åºåˆ—åŒ–çš„æ—¶å€™,æ³¨æ„å­—ç¬¦ä¸²çš„ç´¯åŠ çš„æ—¶å€™ç”¨.append()æˆ–è€…+=(å»ºè®®ç”¨append), ä¸ç„¶å¤§æ ‘ä¼šæŠ¥è¶…æ—¶;\r\n * 3. æ€è·¯1æ—¶é—´å¤æ‚åº¦:O(n), ç©ºé—´å¤æ‚åº¦:O(h), , hä¸ºæ ‘çš„é«˜åº¦ï¼Œæœ€åæƒ…å†µä¸ºé€€åŒ–æˆå•é“¾è¡¨æ­¤æ—¶ä¸ºO(n);\r\n *\r\n * 4. æ€è·¯2: dfs, ååºåˆ—åŒ–çš„æ—¶å€™æœ‰ä¸€ä¸ªè¦ç‚¹å°±æ˜¯è¿”å›å½“ç„¶éå†çš„å¶å­çš„ä¸‹æ ‡, å› ä¸ºè¦æ ¹æ®è¿™ä¸ªæ‰¾å³å­æ ‘çš„å¤´ç»“ç‚¹;\r\n * 5. æ€è·¯2æ—¶é—´å¤æ‚åº¦:O(n), ç©ºé—´å¤æ‚åº¦:O(h), , hä¸ºæ ‘çš„é«˜åº¦ï¼Œæœ€åæƒ…å†µä¸ºé€€åŒ–æˆå•é“¾è¡¨æ­¤æ—¶ä¸ºO(n);\r\n * */\r\n \r\n```\r\nclass Solution\r\n{\r\npublic:\r\n\r\n    void splitString(string data)\r\n    {\r\n        while(data.find(\"#\") != string::npos)\r\n        {\r\n            int pos = data.find(\"#\");\r\n            string val = data.substr(0, pos);\r\n            ressplit.push_back(val);\r\n            data = data.substr(pos+1, data.length() - pos - 1);\r\n        }\r\n    }\r\n    void dfs(TreeNode* root)\r\n    {\r\n        // åˆ¤æ–­ç»“æŸæ¡ä»¶\r\n        if(root == nullptr)\r\n        {\r\n            res.append(\"$#\");\r\n            return;\r\n        }\r\n        // å½“å‰æ“ä½œ\r\n        res.append(to_string(root->val)).append(\"#\");\r\n        // è¿›å…¥ä¸‹ä¸€æ¬¡é€’å½’\r\n        dfs(root->left);\r\n        dfs(root->right);\r\n\r\n    }\r\n\r\n    string serialize(TreeNode* root)\r\n    {\r\n        if(root == nullptr)\r\n            return \"\";\r\n        dfs(root);\r\n        int last_flag = 0;\r\n        for(int i = 0; i < res.size() - 1;)\r\n        {\r\n            if(res.substr(i, 2) != \"$#\")\r\n                last_flag = i;\r\n            i += 2;\r\n        }\r\n        res = res.substr(0, last_flag + 2);;\r\n        return res;\r\n    }\r\n\r\n    TreeNode* des_dfs(int flag, int &k)\r\n    {\r\n        // åˆ¤æ–­ç»“æŸæ¡ä»¶\r\n        if( flag > ressplit.size() - 1 || ressplit[flag] == \"$\")\r\n        {\r\n            k = flag;\r\n            return nullptr;\r\n        }\r\n\r\n        // å½“å‰æ“ä½œ\r\n        TreeNode *p = new TreeNode(atoi(ressplit[flag].c_str()));\r\n        // è¿›å…¥ä¸‹ä¸€æ¬¡é€’å½’\r\n        p->left = des_dfs(flag+1, k);\r\n        p->right = des_dfs(k + 1, k);\r\n        return p;\r\n    }\r\n\r\n    TreeNode* deserialize(string data)\r\n    {\r\n        splitString(data);\r\n        if (ressplit.size() == 0)\r\n            return nullptr;\r\n        TreeNode *head = new TreeNode(atoi(ressplit[0].c_str()));\r\n        int next_flag;\r\n        head->left = des_dfs(1, next_flag);\r\n        head->right = des_dfs(next_flag+1, next_flag);\r\n        return head;\r\n    }\r\nprivate:\r\n    string res = \"\";\r\n    vector<string> ressplit;\r\n};\r\n\r\nclass Solution1\r\n{\r\npublic:\r\n    string serialize(TreeNode* root)\r\n    {\r\n        string res = \"\";\r\n        queue<TreeNode*> info;\r\n        if(root)\r\n            info.push(root);\r\n        while(!info.empty())\r\n        {\r\n            TreeNode *tmp = info.front();\r\n            info.pop();\r\n            if(tmp != nullptr)\r\n            {\r\n                // res  += to_string(tmp->val) + \"#\";\r\n                res.append(to_string(tmp->val)).append(\"#\");\r\n                info.push(tmp->left);\r\n                info.push(tmp->right);\r\n            }\r\n            else\r\n                res.append(\"$#\");\r\n            // res += \"$#\";\r\n        }\r\n        // å»é™¤åé¢çš„null\r\n        int last_flag = 0;\r\n        for(int i = 0; i < res.length();)\r\n        {\r\n            if( \"$#\" != res.substr(i, 2))\r\n            {\r\n                last_flag = i;\r\n            }\r\n            i += 2;\r\n        }\r\n        res = res.substr(0, last_flag+2);\r\n        return res;\r\n    }\r\n    vector<string> splitString(string data)\r\n    {\r\n        vector<string> res;\r\n        while(data.find(\"#\") != string::npos)\r\n        {\r\n            int pos = data.find(\"#\");\r\n            string val = data.substr(0, pos);\r\n            res.push_back(val);\r\n            data = data.substr(pos+1, data.length() - pos - 1);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    TreeNode* deserialize(string data)\r\n    {\r\n        if(data == \"\")\r\n            return nullptr;\r\n        queue<TreeNode*> root;\r\n        vector<string> res = splitString(data);\r\n        TreeNode* head = new TreeNode(atoi(res[0].c_str()));\r\n        root.push(head);\r\n        if(data.length() == 1)\r\n            return head;\r\n        for(int i = 1; i < res.size();)\r\n        {\r\n            TreeNode *p = root.front();\r\n            root.pop();\r\n            if(res[i] != \"$\")\r\n            {\r\n                TreeNode *left = new TreeNode(atoi(res[i].c_str()));\r\n                p->left = left;\r\n                root.push(left);\r\n            }\r\n            if(i < res.size() - 1 && res[i+1] != \"$\")\r\n            {\r\n                TreeNode *right = new TreeNode(atoi(res[i+1].c_str()));\r\n                p->right = right;\r\n                root.push(right);\r\n            }\r\n            i += 2;\r\n        }\r\n        return head;\r\n    }\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200750611","body":"/*\r\n * 1.æ€è·¯: å¸¦è®°å½•(x,y)çš„dfs, ç”¨mapæ¥å­˜, mapæ˜¯è‡ªå¸¦æ’åºçš„;\r\n * 2.æ€è·¯åˆ†æ: åˆšå¼€å§‹çœ‹æˆå¯¹åŒä¸€åˆ—çš„è¿›è¡Œæ’åº, åé¢æ‰çœ‹åˆ°æ˜¯åŒè¡ŒåŒåˆ—æ‰æ’åº, å› æ­¤ç”¨ map<int, map<int, vector<int>>>ç»“æ„;\r\n * 3.æ—¶é—´å¤æ‚åº¦:O(nlogn)(ä¸»è¦æ˜¯æ’åºçš„æ—¶é—´), ç©ºé—´å¤æ‚åº¦:O(n)(mapå­˜çš„æ€»ç»“ç‚¹æ•°ä¸ºæ ‘çš„ç»“ç‚¹æ•°).\r\n * */\r\n \r\n```\r\nclass Solution\r\n{\r\npublic:\r\n    void dfs(TreeNode * root, int row, int col)\r\n    {\r\n        // å½“å‰æ“ä½œ\r\n        if(info.find(col) == info.end() || info[col].find(row) == info[col].end())\r\n            info[col][row] = vector<int>(1, root->val);\r\n        else\r\n            info[col][row].push_back(root->val);\r\n        // åˆ¤æ–­é€€å‡ºæ¡ä»¶\r\n        if(root->left == nullptr && root->right == nullptr)\r\n            return;\r\n\r\n        // è¿›å…¥ä¸‹ä¸€æ¬¡å¾ªç¯\r\n        if(root->left)\r\n            dfs(root->left, row + 1, col - 1);\r\n        if(root->right)\r\n            dfs(root->right, row + 1, col + 1);\r\n    }\r\n    vector<vector<int>> verticalTraversal(TreeNode * root)\r\n    {\r\n        vector<vector<int>> res;\r\n        dfs(root, 0, 0);\r\n        for(auto i: info)\r\n        {\r\n            vector<int> tmp;\r\n            for(auto it : i.second)\r\n            {\r\n                sort(it.second.begin(), it.second.end());\r\n                for(auto it1: it.second)\r\n                    tmp.push_back(it1);\r\n            }\r\n            res.push_back(tmp);\r\n        }\r\n        return res;\r\n\r\n    }\r\nprivate:\r\n    // æ¯åˆ—å­˜ä¸€ä¸ªhashè¡¨ï¼Œæ¯åˆ—çš„hashè¡¨ä¸»é”®ä¸ºè¡Œå·, è¿™é‡Œç”¨map, mapé‡Œé¢å­˜çš„å°±æ˜¯æŒ‰keyæ’åºçš„, å› æ­¤ä¸ç”¨å•ç‹¬å¯¹åˆ—æ’åºï¼Œè¡ŒåŒç†\r\n    map<int, map<int, vector<int>>> info;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202235719","body":"/*\r\n * 1.æ€è·¯: å“ˆå¸Œè¡¨ç©ºé—´æ¢æ—¶é—´;\r\n * 2.æ—¶é—´å¤æ‚åº¦:O(n), ç©ºé—´å¤æ‚åº¦:O(1);\r\n * */\r\n \r\n```\r\nvector<int> twoSum(vector<int>& nums, int target) {\r\n        unordered_map<int, int> info;\r\n        vector<int> res;\r\n        for(int i = 0; i < nums.size(); i++)\r\n        {\r\n            if(info.find(target - nums[i]) != info.end())\r\n            {\r\n                res.push_back(info[target-nums[i]]);\r\n                res.push_back(i);\r\n                break;\r\n            }\r\n            else\r\n                info.insert(pair<int, int>(nums[i], i));\r\n        }\r\n        return res;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203969383","body":"/*\r\n * 1.æ€è·¯1: ç”¨å“ˆå¸Œè¡¨è®¡æ•°ï¼Œç„¶åç”¨vectorè½¬å­˜å¯¹valueè¿›è¡Œä»å¤§åˆ°å°æ’åºï¼ˆå› ä¸ºå“ˆå¸Œè¡¨ä¸èƒ½ç”¨sortè¿›è¡Œæ’åºï¼Œæ‰€ä»¥è¦è½¬å­˜ï¼‰ï¼Œæœ€åå–å‰kä¸ªæ•°ï¼›\r\n * 1.æ€è·¯1æ—¶é—´å¤æ‚åº¦:O(nlogn)(ä¸»è¦æ˜¯æ’åºçš„æ—¶é—´å¤æ‚åº¦)ï¼Œç©ºé—´å¤æ‚åº¦:O(n);\r\n *\r\n * 2.æ€è·¯2: ç”¨å“ˆå¸Œè¡¨è®¡æ•°ï¼Œç„¶åç”¨å¤§å°ä¸ºkçš„ä¼˜å…ˆé˜Ÿåˆ—è¿›è¡Œå †æ’åº(å°é¡¶å †), å¤§äºæœ€å°çš„æ‰å…¥å †, æ‰€ä»¥æ„å»ºå°é¡¶å †;\r\n * 3.æ€è·¯2æ—¶é—´å¤æ‚åº¦:O(nlogk)(å› ä¸ºå°é¡¶å †çš„å¤§å°ä¸ºk), ç©ºé—´å¤æ‚åº¦:O(n);\r\n *\r\n * 4.æ•°æ®ç»“æ„ç†è§£:sortæ—¶æ¯”è¾ƒå‚æ•°æ˜¯å‡½æ•°ç±»å‹çš„ï¼Œmultimapæ—¶æ¯”è¾ƒå‚æ•°æ—¶ç»“æ„ç±»å‹ï¼Œgreater<int>()æ˜¯å‡½æ•°ç±»å‹ï¼Œgreater<int>æ˜¯ç»“æ„ç±»å‹;\r\n * 5.priority_queueæ¯”è¾ƒå‚æ•°æ˜¯ç»“æ„ç±»å‹ï¼Œæ‰€ä»¥è¦ç”¨structä¿®é¥°, å®ç°operator()å‡½æ•°;\r\n * 6.ä»¿å‡½æ•°:ä½¿â¼€ä¸ªç±»çš„ä½¿â½¤çœ‹ä¸Šå»åƒâ¼€ä¸ªå‡½æ•°ã€‚å…¶å®ç°å°±æ˜¯ç±»ä¸­å®ç°â¼€ä¸ªoperator()ï¼Œè¿™ä¸ªç±»å°±æœ‰äº†ç±»ä¼¼å‡½æ•°çš„â¾ä¸ºï¼Œå°±æ˜¯â¼€ä¸ªä»¿å‡½æ•°ç±».\r\n * */\r\n\r\n```\r\nbool cmp(pair<int, int> a, pair<int, int> b) {\r\n    return a.second > b.second;\r\n}\r\n\r\nstruct pq_cmp\r\n{\r\n    bool operator() (pair<int, int> a, pair<int, int> b)\r\n    {\r\n        return a.first > b.first;\r\n    }\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n\r\n    vector<int> topKFrequentv1(vector<int> &num, int k) {\r\n        unordered_map<int, int> info;\r\n        for (auto i: num) {\r\n            if (info.find(i) != info.end())\r\n                info[i]++;\r\n            else\r\n                info[i] = 1;\r\n        }\r\n        vector<pair<int, int>> sortedinfo;\r\n        for(auto it : info)\r\n            sortedinfo.push_back(make_pair(it.first, it.second));\r\n        sort(sortedinfo.begin(), sortedinfo.end(), cmp);\r\n        int count = 0;\r\n        vector<int> res;\r\n        for (auto it : sortedinfo) {\r\n            if (count < k) {\r\n                res.push_back(it.first);\r\n                count++;\r\n            } else\r\n                break;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    vector<int> topKFrequent(vector<int> &num, int k) {\r\n        unordered_map<int, int> info;\r\n        for (auto i: num) {\r\n            if (info.find(i) != info.end())\r\n                info[i]++;\r\n            else\r\n                info[i] = 1;\r\n        }\r\n        priority_queue<pair<int, int>, vector<pair<int,int>>, pq_cmp> pq;\r\n        for(auto it : info)\r\n        {\r\n            if(pq.size() < k)\r\n                pq.push(make_pair(it.second, it.first));\r\n            else\r\n            {\r\n                auto tmp = pq.top();\r\n                if (it.second > tmp.first)\r\n                {\r\n                    pq.pop();\r\n                    pq.push(make_pair(it.second, it.first));\r\n                }\r\n            }\r\n        }\r\n        vector<int> res;\r\n        while(!pq.empty())\r\n        {\r\n            auto it = pq.top();\r\n            pq.pop();\r\n            res.push_back(it.second);\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204724744","body":"/*\r\n * 1.æ€è·¯:ä»”ç»†è¯»é¢˜, æš´åŠ›æ–¹æ³•æ—¶é—´å¤æ‚åº¦ä¸ºO(n^3), æƒ³åˆ°ç”¨hashè¡¨è®¡æ•°, è¿™æ ·å¯ä»¥å°†æ—¶é—´å¤æ‚åº¦é™åˆ°O(n^2);\r\n * 2.æ—¶é—´å¤æ‚åº¦:O(n^2), ç©ºé—´å¤æ‚åº¦:O(n).\r\n *\r\n * 3.ä¼˜åŒ–æ€»ç»“: è¦ä¼˜åŒ–æ—¶é—´å’Œå†…å­˜æ¶ˆè€—åº”è¯¥å°½é‡ä¸è¦åœ¨å¾ªç¯ä½“å†…éƒ¨ç”Ÿæˆä¸´æ—¶å˜é‡å³å°½é‡å‡å°‘å˜é‡å®šä¹‰ä»¥åŠåœ¨ç»“æ„ä½“å†…å°½é‡å‡å°‘ç®€å•çš„å‡½æ•°è°ƒç”¨(å¦‚æœ¬é¢˜ä¸­çš„è®¡ç®—è·ç¦»);\r\n * 3.ä¼˜åŒ–æ€»ç»“: æœ¬é¢˜å°±æ˜¯, æœ€å¼€å§‹åœ¨ç¬¬äºŒå±‚è®­ç»ƒé‡Œå®šä¹‰key, ä»¥åŠè°ƒç”¨è®¡ç®—è·ç¦»å‡½æ•°å¯¼è‡´ç¨‹åºæ‰§è¡Œæ—¶é—´é•¿, å†…å­˜æ¶ˆè€—å¤š.\r\n * */\r\n \r\n```\r\nint numberOfBoomerangs(vector<vector<int>>& points)\r\n    {\r\n        int res = 0;\r\n        unordered_map<int, int> info;\r\n        int key;\r\n        unordered_map<int, int>::iterator iter;\r\n        for (int i = 0; i < points.size(); i++) {\r\n            for (int j = 0; j < points.size(); j++) {\r\n                if (j == i)\r\n                    continue;\r\n                key = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\r\n                info[key]++;\r\n            }\r\n            iter = info.begin();\r\n            while (iter != info.end()) {\r\n                res += iter->second * (iter->second - 1);;\r\n                iter++;\r\n            }\r\n            info.clear();\r\n        }\r\n        return res;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206566738","body":"/*\r\n * 1.æ€è·¯: å“ˆå¸Œè¡¨ +ã€€åŒæŒ‡é’ˆ, å¯ä»¥é€šè¿‡åˆ¤æ–­å½“å‰é‡å¤å­—ç¬¦åœ¨å“ˆå¸Œè¡¨ä¸­çš„ç´¢å¼•æ˜¯å¦åœ¨>=å½“å‰çš„å·¦æŒ‡é’ˆ, æ¥å‡å°‘å¯¹äºå“ˆå¸Œè¡¨çš„åŒæ­¥æ“ä½œ;\r\n * 2.æ—¶é—´å¤æ‚åº¦:O(n), ç©ºé—´å¤æ‚åº¦O(1)(å› ä¸ºç”±æœ‰é™ç§ç±»çš„å­—ç¬¦ç»„æˆ).\r\n * \r\n * 3.åˆ†æ:åšåŒæŒ‡é’ˆçš„é¢˜å°±æ˜¯è¦å‡†ç¡®æŒæ¡æ€ä¹ˆåˆå§‹åŒ–ä»¥åŠæŒªåŠ¨æŒ‡é’ˆçš„åˆ¤æ–­æ¡ä»¶,æ¯”å¦‚æœ¬é¢˜ä¸­åŠ åˆ¤æ–­info[s[q]] >= p\r\n * */\r\n```\r\nint lengthOfLongestSubstring(string s)\r\n    {\r\n        if(s.length() == 0)\r\n            return 0;\r\n        if (s.length() == 1)\r\n            return 1;\r\n        int p = 0, q = 1;\r\n        int res = -1;\r\n        unordered_map<int, int> info;\r\n        info[s[p]] = 0;\r\n        while(q < s.length())\r\n        {\r\n            if(info.find(s[q]) != info.end() && info[s[q]] >= p)\r\n            {\r\n                res = q - p > res ? q - p : res;\r\n                p = info[s[q]] + 1;\r\n            }\r\n            info[s[q]] = q;\r\n            q++;\r\n        }\r\n        res = q - p > res ? q - p : res;\r\n        return res;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207233547","body":"```\r\npublic List<Integer> findSubstring(String s, String[] words) {\r\n\r\n        List<Integer> res = new ArrayList<>();\r\n\r\n        Map<String, Integer> map = new HashMap<>();\r\n\r\n        if (words == null || words.length == 0)\r\n            return res;\r\n\r\n        for (String word : words)\r\n            map.put(word, map.getOrDefault(word, 0) + 1);\r\n\r\n        int sLen = s.length(), wordLen = words[0].length(), count = words.length;\r\n\r\n        int match = 0;\r\n\r\n        for (int i = 0; i < sLen - wordLen * count + 1; i++) {\r\n\r\n            //å¾—åˆ°å½“å‰çª—å£å­—ç¬¦ä¸²\r\n            String cur = s.substring(i, i + wordLen * count);\r\n            Map<String, Integer> temp = new HashMap<>();\r\n            int j = 0;\r\n\r\n            for (; j < cur.length(); j += wordLen) {\r\n\r\n                String word = cur.substring(j, j + wordLen);\r\n                // å‰ªæ\r\n                if (!map.containsKey(word))\r\n                    break;\r\n\r\n                temp.put(word, temp.getOrDefault(word, 0) + 1);\r\n                // å‰ªæ\r\n                if (temp.get(word) > map.get(word))\r\n                    break;\r\n            }\r\n\r\n            if (j == cur.length())\r\n                res.add(i);\r\n        }\r\n\r\n        return res;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207416718","body":"```\r\nint floorMod(const int& a, const int& b)\r\n{\r\n    return (a % b + b) % b;\r\n}\r\nint solve(vector<int>& nums, int k) {\r\n    int allSum = 0;\r\n    for (int& num : nums)\r\n        allSum += num;\r\n\r\n    allSum = floorMod(allSum, k);\r\n    unordered_map<int, int> dict;\r\n    dict[0] = -1;\r\n\r\n    int preSum = 0;\r\n    int minLen = nums.size();\r\n    for (int i = 0; i < nums.size(); i++) {\r\n        preSum += nums[i];\r\n        int mod = floorMod(preSum, k);\r\n        dict[mod] = i;\r\n\r\n        if (dict.count(floorMod(preSum - allSum, k)))\r\n            minLen = min(minLen, i - dict[floorMod(preSum - allSum, k)]);\r\n    }\r\n    return minLen == nums.size() ? -1 : minLen;\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207696676","body":"/*\r\n * 1. æ€è·¯: å¿«æ…¢æŒ‡é’ˆ, ä¸€ä¸ªæ­¥é•¿ä¸º1, ä¸€ä¸ªæ­¥é•¿ä¸º2;\r\n * 2. æ—¶é—´å¤æ‚åº¦: O(n), ç©ºé—´å¤æ‚åº¦: O(1).\r\n * */\r\n \r\n```\r\nListNode* middleNode(ListNode* head)\r\n    {\r\n        if(head == nullptr || head->next == nullptr)\r\n            return head;\r\n        ListNode *p = head;\r\n        ListNode *q = head->next;\r\n        while(q)\r\n        {\r\n            if(q->next != nullptr)\r\n                q = q->next->next;\r\n            else\r\n                q = q->next;\r\n            p = p->next;\r\n        }\r\n        return p;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208856935","body":"/*\r\n * 1.æ€è·¯: åŒæŒ‡é’ˆ, ä¸€ä¸ªéå†, ä¸€ä¸ªæŒ‡å‘ä¸é‡å¤çš„å°¾å·´, æ³¨æ„è¾¹ç•Œæ¡ä»¶;\r\n * 2.æ—¶é—´å¤æ‚åº¦:O(n), ç©ºé—´å¤æ‚åº¦:O(1).\r\n * */\r\n\r\n```\r\nint removeDuplicates(vector<int> &nums)\r\n    {\r\n        int p = 0, q = 1;\r\n        while(q < nums.size()) {\r\n            if (nums[q] != nums[p]) {\r\n                nums[p + 1] = nums[q];\r\n                p++;\r\n            }\r\n            q++;\r\n\r\n        }\r\n        return p + 1;\r\n    }\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaiykk":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185593642","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°\nå€’ç€è¿‡ä¸€énumï¼Œå’Œké€ä½ç›¸åŠ ã€‚\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res = []\n        idx = len(num) - 1\n        while k or idx > -1:\n            cur = k % 10 + num[idx] if idx >= 0 else k % 10\n            k //= 10\n            if cur >= 10:\n                k += 1\n                cur = cur % 10\n            res.append(cur)\n            idx -= 1\n        res.reverse()\n        return res\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: O(N)\n> + ç©ºé—´å¤æ‚åº¦: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186180673","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°\næ­£å‘å’Œè´Ÿå‘å„è®¡ç®—ä¸€æ¬¡ï¼Œæ¯æ¬¡ä¸€ä¸ªæŒ‡é’ˆæ‰¾cä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘å°šæœªè®¡ç®—çš„å…ƒç´ \n\n```python\n#ä»£ç \nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res = [len(s)] * len(s)\n        i = 0\n        for j in range(len(s)):\n            if s[j] == c:\n                while i <= j:\n                    res[i] = min(res[i], j - i)\n                    i += 1\n        i = len(s) - 1\n        for j in range(len(s)-1, -1, -1):\n            if s[j] == c:\n                while i >= j:\n                    res[i] = min(res[i], i - j)\n                    i -= 1\n        return res\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦:  O(n)\n> + ç©ºé—´å¤æ‚åº¦:  O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186544663","body":"## **æ€è·¯ï¼šç”¨æ•°ç»„æ¨¡æ‹Ÿ**\n\næœ´ç´ çš„æ¨¡æ‹Ÿæ–¹æ³•\n\n### **ä»£ç **\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = list()\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack) < k:\n            self.stack = [n+val for n in self.stack]\n        else:\n            self.stack = [n+val for n in self.stack[:k]] + self.stack[k:]\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n### **å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n) push popæ˜¯O(1)ï¼Œincrementæ˜¯O(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1188955309","body":"## æ€è·¯\nä¸€ä¸ªæ ˆå­˜æ”¾æ•°å­—ï¼Œä¸€ä¸ªæ ˆå­˜æ”¾å­—æ¯\n```python\nä»£ç \nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for i, char in enumerate(s):\n            if char != ']':\n                stack.append(char)\n            elif char == ']':\n                repeat_s = ''\n                while stack and stack[-1] != '[':\n                    repeat_s = stack.pop() + repeat_s\n                stack.pop() # pop æ‰'['\n                cnt = ''\n                while stack and stack[-1].isdigit():\n                    cnt = stack.pop() + cnt\n                repeat_s = repeat_s * int(cnt)\n                stack.append(repeat_s) \n        return ''.join(stack)\n```\n\n## å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n) \n- ç©ºé—´å¤æ‚åº¦ï¼šO(n) ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189184499","body":"## æ€è·¯\n- ä¸¤ä¸ªæ ˆæ¥å›å˜æ¢ï¼Œä¸¤ä¸ªæ ˆstackinå’Œstackoutä¸€ä¸ªåªç”¨æ¥è¿›æ–°çš„å…ƒç´ ä¸€ä¸ªåªç”¨æ¥å‡ºç»“æœã€‚ç”¨ä¸€ä¸ªè¾…åŠ©çš„self.frontå˜é‡ï¼Œè®°å½•stackinæœ€å‰é¢çš„å…ƒç´ ã€‚\n- popçš„æ—¶å€™ï¼Œå¯ä»¥åœ¨stackoutç©ºçš„æ—¶å€™å€’å‡ºæ¥ï¼Œä¸ç©ºçš„æ—¶å€™ç›´æ¥å‡ºæ ˆé¡¶å³å¯ã€‚peakçš„æ—¶å€™ï¼Œå¦‚æœstackoutéç©ºçš„è¯ï¼Œè‚¯å®šå°±æ˜¯æ ˆé¡¶çš„å…ƒç´ ï¼Œå¦åˆ™ï¼Œå°±æ˜¯self.front.\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stackin = []\n        self.stackout = []\n        self.front = None\n\n    def push(self, x: int) -> None:\n        if not self.stackin:\n            self.front = x\n        self.stackin.append(x)\n\n    def pop(self) -> int:\n        if not self.stackout:\n            while self.stackin:\n                self.stackout.append(self.stackin.pop())\n        if self.empty():\n            return\n        return self.stackout.pop()\n\n    def peek(self) -> int:\n        return self.stackout[-1] if self.stackout else self.front\n\n    def empty(self) -> bool:\n        return not self.stackin and not self.stackout\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(1)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1191393742","body":"## æ€è·¯\nä¸€å¼€å§‹çš„åšæ³•æ˜¯æ‰¾å•è°ƒåº•å±‚çš„åœ°æ–¹ï¼Œåœ¨æ¯ä¸ªå•è°ƒé€’å¢çš„åœ°æ–¹åˆ‡å—ï¼Œæ˜¯ä¸å¯¹çš„ã€‚ä¹Ÿå°±æ˜¯æ‰«ææ•°ç»„ï¼Œè®°å½•ä¸‹ä¸€ä¸ªå¤§äºæ•°içš„æ•°ï¼Œå¦‚æœæ˜¯å•è°ƒé€’å¢çš„ï¼Œä¸‹ä¸€ä¸ªæ¯”æ•°iå¤§çš„æ•°å°±æ˜¯1ï¼Œè®°å½•é€’å¢çš„æ•°é‡ï¼ˆæ¯æ¬¡åŠ 1ï¼‰ï¼Œé€’å¢æ•°é‡å’Œå°±æ˜¯ç»“æœï¼Œä½†æ˜¯[4,2,2,1,1]è¿‡ä¸äº†ã€‚æ‰€ä»¥é¢˜ç›®è¿˜æœ‰ä¸€å±‚æ„æ€å°±æ˜¯æ¯ä¸€ä¸ªå—è¦æ¯”å‰ä¸€ä¸ªå—å¤§ï¼Œæ¯ä¸ªå—çš„æœ€å°è¦æ¯”å‰ä¸€ä¸ªå—çš„æœ€å¤§è¦å¤§ã€‚\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for i, v in enumerate(arr):\n            if stack and stack[-1] > v:\n                cur = stack[-1]\n                while stack and stack[-1] > v:\n                    stack.pop()\n                stack.append(cur)\n            else:\n                stack.append(v)\n        \n        return len(stack)\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ O(n)\n- ç©ºé—´å¤æ‚åº¦ O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191636009","body":"## æ€è·¯\nå…ˆè®¡ç®—é“¾è¡¨çš„é•¿åº¦ï¼Œè®°ä¸ºcntï¼Œkå¯¹é“¾è¡¨é•¿åº¦å–ä½™æ˜¯è¦æ—‹è½¬çš„æ¬¡æ•°ï¼Œæ—‹è½¬å‡ æ¬¡ï¼Œå°±æ˜¯å€’æ•°ç¬¬å‡ ä¸ªé“¾è¡¨æ‹†å‡ºæ¥ä½œä¸ºå¤´ï¼Œç›¸å½“äºæ‰¾åˆ°è¦æ—‹è½¬æ–­å¼€çš„åœ°æ–¹ï¼Œæ‹†æˆä¸¤ä¸ªé“¾è¡¨ï¼ŒæŠŠåé¢çš„é“¾è¡¨æ‹¼åˆ°å‰é¢é“¾è¡¨ä¸Šï¼Œåé¢é“¾è¡¨æŒ‡å‘å¤´ï¼Œå‰é¢é“¾è¡¨æŒ‡å‘None\n\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return\n        cnt = 0\n        cur = head\n        while cur:\n            cur = cur.next\n            cnt += 1\n        k = k % cnt\n        cur = head\n        cut = 0\n        res = None\n        while cur.next:\n            cut += 1\n            if cut == cnt - k:\n                tmp = cur.next\n                cur.next = None\n                cur = tmp\n                res = cur\n            else:\n                cur = cur.next\n        if res:\n            cur.next = head\n            \n        return res if res else head\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ O(n)\n- ç©ºé—´å¤æ‚åº¦ O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192651609","body":"## æ€è·¯\nåŠ ä¸€ä¸ªdummyå¤´ï¼Œéœ€è¦ä¸¤ä¸ªæŒ‡é’ˆä½œä¸ºprevå’Œcurï¼Œå¯ä»¥å®¹æ˜“æ‰¾å¤´èŠ‚ç‚¹ï¼Œå› ä¸ºæœ€åè¿”å›è‚¯å®šæ˜¯è¦å¤´èŠ‚ç‚¹çš„\n\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head:\n            return head\n        dummy_node = ListNode(-1)\n        dummy_node.next = head\n        prev_node, cur_node = dummy_node, head\n        while cur_node and cur_node.next:\n            next_node = cur_node.next\n            prev_node.next = next_node\n            next_cur_node = next_node.next\n            next_node.next = cur_node\n            cur_node.next = next_cur_node\n            prev_node, cur_node = cur_node, next_cur_node\n\n        return dummy_node.next\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ O(n)\n- ç©ºé—´å¤æ‚åº¦ O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1194025279","body":"## æ€è·¯ï¼šé€’å½’+åŒæŒ‡é’ˆ\næŠŠé“¾è¡¨æƒ³è±¡æˆä¸€ä¸ªç»³å­ï¼Œæ¯æ¬¡æ“ä½œæ˜¯ä»ä¸­é—´æŠŠç»³å­æ‹èµ·æ¥ã€‚ç”¨é€’å½’çš„æ–¹å¼æŠŠé—®é¢˜ç¼©å°ï¼Œæ¯æ¬¡æ‰¾åˆ°ä¸­é—´çš„èŠ‚ç‚¹ä½œä¸ºrootï¼Œå·¦è¾¹æ¥é“¾è¡¨çš„å‰åŠéƒ¨åˆ†sortåçš„äºŒå‰æœç´¢æ ‘ï¼Œåé¢æ¥é“¾è¡¨ååŠéƒ¨åˆ†sortåçš„äºŒå‰æœç´¢æ ‘ã€‚å…¶ä¸­ä¸­é—´èŠ‚ç‚¹ç”¨å¿«æ…¢æŒ‡é’ˆæ‰¾åˆ°ã€‚è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœåªæœ‰ä¸€ä¸ªèŠ‚ç‚¹çš„è¯ï¼Œä¹Ÿè¦é€€å‡ºé€’å½’çš„ï¼Œå› ä¸ºè¿™æ ·leftå’Œlistnodeä¼šä¸€ç›´è¿™æ ·ï¼Œå°±ä¼šå‡ºä¸æ¥ã€‚\n\n```python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        def balanced_tree(listnode):\n            if not listnode:\n                return None\n            # å¦‚æœèŠ‚ç‚¹ä¸­åªæœ‰1ä¸ªçš„è¯ï¼Œleftå°±ä¸€ç›´æ˜¯listnodeï¼Œé€€å‡ºä¸äº†é€’å½’\n            if not listnode.next:\n                return TreeNode(listnode.val)\n            # æ‰¾ä¸­ç‚¹\n            prev = ListNode(-1)\n            prev.next = listnode\n            slow, fast = listnode, listnode\n            while fast and fast.next:\n                prev = prev.next\n                slow = slow.next\n                fast = fast.next.next\n            cur_head = TreeNode(slow.val)\n            prev.next = None\n            left, right = listnode, slow.next\n            cur_head.left, cur_head.right = balanced_tree(left), balanced_tree(right)\n\n            return cur_head\n        return balanced_tree(head)\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ O(n*logn)\n- ç©ºé—´å¤æ‚åº¦ O(logn)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1194048778","body":"## æ€è·¯\néå†aå…¨éƒ¨æ”¾è¿›å“ˆå¸Œè¡¨ï¼Œéå†bå¦‚æœè§åˆ°å·²ç»åœ¨å“ˆå¸Œè¡¨ä¸­çš„åˆ™å°±æ˜¯è¦æ‰¾çš„èŠ‚ç‚¹ï¼Œå¦åˆ™æ²¡æœ‰èŠ‚ç‚¹\n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        a = headA\n        b = headB\n        if not a or not b:\n            return None\n        hash = {}\n        while a:\n            hash[a] = 1\n            a = a.next\n        while b:\n            if b in hash:\n                return b\n            else:\n                b = b.next\n        return None\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ O(n)\n- ç©ºé—´å¤æ‚åº¦ O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194070467","body":"## æ€è·¯\néå†é“¾è¡¨çœ‹èŠ‚ç‚¹æ˜¯å¦é‡è§è¿‡ï¼Œä½†æ˜¯å“ˆå¸Œæ–¹æ³•å¤æ‚åº¦ä¸æ»¡è¶³è¿›é˜¶è¦æ±‚\n\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        hash = {}\n        while head:\n            if head not in hash:\n                hash[head] = 1\n            else:\n                return head\n            head = head.next\n        return None\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦: O(n)\n- ç©ºé—´å¤æ‚åº¦: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1197845390","body":"## æ€è·¯\nç”±äºè¦æ±‚çš„æ˜¯O(1)çš„å¤æ‚åº¦ï¼Œè¦æ±‚åˆ é™¤ã€æ·»åŠ ã€æ¢ä½ç½®éƒ½æ˜¯O1èƒ½å¤Ÿç”¨çš„æ˜¯é“¾è¡¨å’Œå“ˆå¸Œï¼Œè¿™é¢˜çš„å…³é”®å°±æ˜¯ç”¨åŒå‘é“¾è¡¨+å“ˆå¸Œï¼ŒåŒå‘é“¾è¡¨å­˜å‚¨èŠ‚ç‚¹çš„é¡ºåºï¼Œå“ˆå¸Œå­˜å‚¨keyå¯¹åº”çš„nodeã€‚è¿™é‡Œè¦æ³¨æ„çš„æ˜¯ï¼š\n- åŒå‘é“¾è¡¨ç”¨ä¸¤ä¸ªå“¨å…µåšå¤´å°¾ä¼šæ¯”è¾ƒæ–¹ä¾¿è¾¹ç•Œè®¡ç®—ï¼Œç”¨ä¸€ä¸ªdummyå¤´å’Œä¸€ä¸ªcurnodeæŒ‡é’ˆä¹Ÿå¯ä»¥ï¼Œä½†æ˜¯æ¯æ¬¡æ”¹curnodeçš„ä½ç½®ï¼Œå®¹æ˜“é”™\n- putå’Œgetå€¼çš„æ—¶å€™è™½ç„¶ä¸æŠŠnodeå–å‡ºï¼Œä½†æ˜¯éƒ½ç®—è®¿é—®äº†nodeï¼Œéœ€è¦æŠŠnodeæ”¾åˆ°æœ€å\n- åŒå‘é“¾è¡¨ç›´æ¥å­˜å‚¨keyå’Œvalï¼Œä¸èƒ½åªå­˜valï¼Œå› ä¸ºkeyå’Œvalå¯èƒ½ä¸ä¸€æ ·\n\n```python\nclass ListNode:\n    def __init__(self, key=None, val=None):\n        self.prev = None\n        self.next = None\n        self.val = val\n        self.key = key\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        # åˆå§‹åŒ–å“ˆå¸Œè¡¨ {key: ListNode}\n        self.hashmap = dict()\n        # åˆå§‹åŒ–åŒå‘é“¾è¡¨\n        self.head = ListNode()\n        self.tail = ListNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def get(self, key: int) -> int:\n        # å¦‚æœåœ¨hashä¸­ï¼Œè¿”å›è¯¥å€¼ã€‚æ”¾åˆ°åŒå‘é“¾è¡¨æœ€å\n        if key in self.hashmap:\n            self.move_to_tail(key)\n        res = self.hashmap.get(key, -1)\n        return -1 if res == -1 else res.val\n\n    def move_to_tail(self, key: int) -> None:\n        node = self.hashmap[key]\n        # æ‹†å‡º\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        # æ’å…¥\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev.next = node\n        self.tail.prev = node\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.hashmap:\n            # è‹¥keyå·²ç»åœ¨åŒå‘é“¾è¡¨ä¸­ï¼ŒæŠŠè¯¥keyæ”¾åˆ°æœ€åï¼Œå¹¶ä¸”æ”¹å˜å€¼\n            self.hashmap[key].val = value\n            self.move_to_tail(key)\n            return\n        if len(self.hashmap) == self.capacity:\n            # åˆ é™¤å¤´èŠ‚ç‚¹\n            del_node = self.head.next\n            self.head.next = del_node.next\n            del_node.next.prev = self.head\n            self.hashmap.pop(del_node.key)\n\n        new_node = ListNode(key, value)\n        self.hashmap[key] = new_node\n        self.tail.prev.next = new_node\n        new_node.prev = self.tail.prev\n        new_node.next = self.tail\n        self.tail.prev = new_node\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(1)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1197896559","body":"## æ€è·¯\n- å±‚åºéå†ï¼Œæ¯ä¸€å±‚æ·±åº¦åŠ 1\n\n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        # bfs\n        queue = deque()\n        if not root:\n            return 0\n        queue.append(root)\n        depth = 0\n        while queue:\n            for i in range(len(queue)):\n                cur_node = queue.popleft()\n                if cur_node.left:\n                    queue.append(cur_node.left)\n                if cur_node.right:\n                    queue.append(cur_node.right)\n            depth += 1\n        return depth\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198042720","body":"## æ€è·¯ï¼šå…ˆåºéå†+é€’å½’\nå‰åºåœ°çœ‹æ¯ä¸ªèŠ‚ç‚¹æ˜¯å¦ç›¸ç­‰ï¼Œä¸”è¾“å…¥æ˜¯ä¸¤ä¸ªnode\n1. è¾“å…¥è¾“å‡ºï¼šè¾“å…¥æ˜¯ä¸¤ä¸ªæ ‘çš„æ ‘èŠ‚ç‚¹ï¼Œè¾“å‡ºæ˜¯èŠ‚ç‚¹æ˜¯å¦ç›¸ç­‰\n2. é€’å½’å‡ºå£ï¼šå¦‚æœæœ‰nodeæ˜¯noneï¼Œè¦ä¹ˆä¸¤ä¸ªæ ‘ç›¸ç­‰çš„æ—¶å€™éƒ½æ˜¯noneï¼Œè¦ä¹ˆä¸€ä¸ªnoneä¸€ä¸ªä¸æ˜¯noneï¼Œå‰è€…æ˜¯trueåè€…æ˜¯false\n3. é€’å½’é€»è¾‘ï¼šè¦åˆ¤æ–­æ˜¯å¦ç›¸ç­‰ï¼Œè¦çœ‹å½“å‰èŠ‚ç‚¹ç›¸ç­‰ï¼Œå·¦èŠ‚ç‚¹ç›¸ç­‰ã€å³èŠ‚ç‚¹ç›¸ç­‰\n\n```python\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        def preorder(p_node, q_node):\n            # å…ˆåºçš„çœ‹på’Œqæ˜¯å¦æƒ³ç­‰\n            if not p_node and not q_node:\n                return True\n            if not p_node or not q_node:\n                return False\n            cur_same = p_node.val == q_node.val\n            left_same = preorder(p_node.left, q_node.left)\n            right_same = preorder(p_node.right, q_node.right)\n            return cur_same and left_same and right_same\n        return preorder(p, q)\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n) æ¯ä¸ªèŠ‚ç‚¹éå†ä¸€æ¬¡\n- ç©ºé—´å¤æ‚åº¦ï¼šO(h) é€’å½’æ ˆå¤§å°æ˜¯æ ‘çš„æ·±åº¦","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1200156869","body":"## æ€è·¯\n- è®°å½•æ‰€æœ‰çš„è·¯å¾„ï¼Œæœ€åsumï¼Œå…¶ä¸­ï¼Œè¦ç”¨strå½¢å¼è®°å½•è·¯å¾„ï¼Œä¸ç„¶000è¿™ç§æ— æ³•è®°ä½\n\n```python\nclass TreeNode():\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n            è¾“å…¥:node\n            è¿”å›:å½“å‰èŠ‚ç‚¹å­è·¯å¾„\n            é€»è¾‘:æœ¬èŠ‚ç‚¹æ‰€æœ‰å­è·¯å¾„æ˜¯è‡ªå·±*10,åŠ ä¸Šæ¯ä¸ªå­è·¯å¾„å‡ºå£ï¼ŒNoneçš„æ—¶å€™è¿”å›ä¸€ä¸ªåˆ—è¡¨\n        \"\"\"\n        def dfs(node):\n            if not node:\n                return []\n            next_path = dfs(node.left) + dfs(node.right)\n            if not next_path:\n                cur_path = [str(node.val)]\n            else:\n                cur_path = [str(node.val) + v for v in next_path]\n            return cur_path\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200159923","body":"## æ€è·¯\n- å–æœ€åä¸€å±‚bfsçš„ç¬¬ä¸€ä¸ªå€¼\n\n```python\nfrom collections import deque\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        # bfs\n        queue = deque([root])\n        while queue:\n            res = queue[0].val\n            for _ in range(len(queue)):\n                cur_node = queue.popleft()\n                if cur_node.left:\n                    queue.append(cur_node.left)\n                if cur_node.right:\n                    queue.append(cur_node.right)\n        \n        return res\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(w) é˜Ÿåˆ—æœ€å¤§æ˜¯æ ‘çš„æ·±åº¦","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200423148","body":"## æ€è·¯\næœ‰ä¸¤ä¸ªåœ°æ–¹éœ€è¦æ³¨æ„ï¼š\n- nodeèŠ‚ç‚¹å¯èƒ½æ˜¯è´Ÿæ•°ï¼Œæ‰€ä»¥éœ€è¦åˆ†å‰²ç¬¦å·\n- ååºåˆ—åŒ–åªè¦ä¼ då°±è¶³å¤Ÿäº†ï¼Œå› ä¸ºdæ˜¯åŠ¨æ€çš„ï¼Œdä¸€ç›´åœ¨popï¼Œå·¦è¾¹æ‹¼å®Œæ‹¼å³è¾¹çš„æ—¶å€™å·¦è¾¹å·²ç»éå†å®Œ\n\n```python\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        # å‰åºéå†\n        if not root:\n            return \"#\"\n        left = self.serialize(root.left)\n        right = self.serialize(root.right)\n        return str(root.val) + \",\" + left + \",\" + right\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        data_list = data.split(\",\")\n        return self.build_tree(data_list)\n\n    def build_tree(self, data_list):\n        if not data_list:\n            return\n        val = data_list.pop(0)\n        if val == \"#\":\n            return\n        root = TreeNode(val)\n        root.left = self.build_tree(data_list)\n        root.right = self.build_tree(data_list)\n        return root\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1202559717","body":"## æ€è·¯ï¼šæ’åº+åŒæŒ‡é’ˆ\n- è·Ÿä¸‰æ•°ä¹‹å’Œä¸€æ ·çš„æ–¹æ³•ï¼Œæ¯”ä¸‰æ•°ä¹‹å’Œå¤šä¸€å±‚å¾ªç¯ã€‚å°±è·Ÿä¸‰æ•°ç›¸æ¯”ï¼Œå¤šå›ºå®šä¸€ä¸ªæ•°å­—\n\n```python\nclass Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        if not nums or len(nums) < 4:\n            return []\n        nums.sort()\n        res = []\n        for a in range(len(nums) - 3): # èµ·ç è¦å››ä¸ªæ•°å­—\n            if a > 0 and nums[a] == nums[a-1]:\n                continue\n            for b in range(a+1, len(nums)-2):\n                if b > a+1 and nums[b] == nums[b-1]:\n                    continue\n                l, r = b+1, len(nums)-1\n                while l < r:\n                    if nums[a] + nums[b] + nums[l] + nums[r] == target:\n                        res.append([nums[a], nums[b], nums[l], nums[r]])\n                        while l < r and nums[l] == nums[l+1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r-1]:\n                            r -= 1\n                        l += 1\n                        r -= 1\n                    elif nums[a] + nums[b] + nums[l] + nums[r] > target:\n                        r -= 1\n                    else:\n                        l += 1\n        return res\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n**3)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202680328","body":"## æ€è·¯\n- å…ˆæ’åºï¼Œç„¶åæŒ‡é’ˆä¸€å¤´ä¸€å°¾æ‰¾target\n\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        nums = [(i, n) for i, n in enumerate(nums)]\n        nums = sorted(nums, key=lambda x: x[1])\n        left, right = 0, len(nums) - 1\n        while left < right:\n            if nums[left][1] + nums[right][1] == target:\n                return [nums[left][0], nums[right][0]]\n            elif nums[left][1] + nums[right][1] < target:\n                left += 1\n            elif nums[left][1] + nums[right][1] > target:\n                right -= 1\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(logn)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1208114457","body":"## æ€è·¯ï¼šå“ˆå¸Œã€å‰ç¼€å’Œã€åŒä½™å®šç†\nå‡è®¾åŸæ•°ç»„é™¤ä»¥Kçš„ä½™æ•°æ˜¯Rï¼Œè¦æ±‚åˆ é™¤subarrayä¹‹åå‰©ä½™æ•°ç»„ä¹‹å’Œé™¤ä»¥Kä½™æ•°ä¸º0ï¼Œè¯´æ˜å¾…åˆ é™¤çš„subarrayæœ¬èº«ä¹‹å’Œé™¤ä»¥Kçš„ä½™æ•°å°±æ˜¯Rã€‚\nä¾‹å¦‚ {1, 6, 11, 16} mod 5 éƒ½æ˜¯1\n\n``` python\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        sm = 0\n        res = len(nums)\n\n        # key is the preSum%p, val is the current index, default is 0:-1\n        mp = {0:-1}\n\n        target = sum(nums) % p\n\n        for i,v in enumerate(nums):\n            sm += v\n            \n            mp[sm%p] = i\n\n            if (sm-target) % p in mp:\n                res = min(res, i-mp[(sm-target) % p])\n\n        if res == len(nums):\n            return -1\n\n        return res\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208105802","body":"## æ€è·¯ï¼šå¿«æ…¢æŒ‡é’ˆ\næ¯æ¬¡å¿«æŒ‡é’ˆèµ°ä¸¤æ­¥ï¼Œæ…¢æŒ‡é’ˆèµ°ä¸€æ­¥ï¼Œæœ€åæ…¢æŒ‡é’ˆå°±ç•™åœ¨é“¾è¡¨çš„ä¸­é—´\n\n```python\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        slow, fast = head, head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        return slow\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cachezhou0617":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185598055","body":"## æ€è·¯\r\n\r\n> + å‚è€ƒé¢˜è§£åè§£ç­”ï¼Œå›å»æŸ¥çœ‹è®²ä¹‰å’Œç±»ä¼¼é¢˜ç›® å·©å›ºä¹‹\r\n\r\n##ä»£ç \r\n\r\n```java\r\npublic List<Integer> addToArrayForm(int[] A, int K) {\r\n    List<Integer> res = new ArrayList<>();\r\n    int carry = 0;\r\n    int l1 = A.length - 1;\r\n    while (l1 >= 0 || K != 0) {\r\n        int x = l1 < 0 ? 0 : A[l1];\r\n        int y = K == 0 ? 0 : K % 10;\r\n\r\n        int sum = x + y + carry;\r\n        res.add(sum % 10);\r\n        carry = sum / 10;\r\n\r\n        l1--;\r\n        K = K / 10;\r\n    }\r\n    if (carry != 0) res.add(carry);\r\n    Collections.reverse(res);\r\n    return res;\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n\r\n## å¤æ‚åº¦\r\n\r\n> + æ—¶é—´å¤æ‚åº¦: O(n)\r\n> + ç©ºé—´å¤æ‚åº¦: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186225705","body":"### æ€è·¯\r\n\r\nåŒå‘éå†ï¼Œè®°å½•æœ€å°çš„å€¼\r\n\r\n### ä»£ç \r\n\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] res = new int[n];\r\n        // ä»å·¦å¾€å³éå†\r\n        for (int i = 0, index = -n; i < n; i++) {\r\n            if (s.charAt(i) == c) {\r\n                index = i;\r\n            }\r\n            res[i] = i - index;\r\n\r\n        }\r\n        \r\n        // ä»å³å¾€å·¦éå†\r\n        for (int i = n - 1, index = 2 * n; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                index = i;\r\n            }\r\n            res[i] = Math.min(res[i], index - i);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186551756","body":"### æ€è·¯\r\n\r\næœ‰ç‚¹è¿·ç³Šï¼Œå‚è€ƒé¢˜è§£ å¤šæ¬¡è°ƒè¯•å¤§æ¦‚ç†è§£ æ•°ç»„æ¨¡æ‹Ÿæ ˆçš„æ€è·¯ ç»§ç»­ç ”ç©¶ä¸€ä¸‹\r\n\r\n### ä»£ç \r\n\r\n\r\n```java\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top != stack.length -1){\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top+1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k,top+1);\r\n        for (int i = 0; i < limit; ++i){\r\n            stack[i] = stack[i] + val;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\r\n- ç©ºé—´å¤æ‚åº¦ï¼š","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187669690","body":"### æ€è·¯\r\n\r\næƒ³èµ·ç®—æ³•4ä¸­Dijkstraçš„åŒæ ˆç®—æœ¯è¡¨è¾¾å¼æ±‚å€¼ç®—æ³•ï¼Œæ€è·¯ä¸€æ · åªä¸è¿‡å°†()å˜æˆ[] \r\n\r\n### ä»£ç \r\n\r\n\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Stack<Integer> tStack = new Stack<>();\r\n        Stack<String> sStack = new Stack<>();\r\n        String temp = \"\";\r\n        int times = 0;\r\n\r\n        for (int i = 0; i < s.length(); i++) {\r\n            char c = s.charAt(i);\r\n            if (Character.isDigit(c)) {\r\n                times = times * 10 + c - '0';\r\n                continue;\r\n            }\r\n            if (c == '[') {\r\n                sStack.push(temp);\r\n                tStack.push(times);\r\n                temp = \"\";\r\n                times = 0;\r\n                continue;\r\n            }\r\n            if (c == ']') {\r\n                temp = sStack.pop() + temp.repeat(tStack.pop());\r\n                continue;\r\n            }\r\n            temp = temp + c;\r\n        }\r\n        return temp;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºå­—ç¬¦ä¸²é•¿åº¦ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189229330","body":"### æ€è·¯\r\n\r\næ ˆå…ˆè¿›åå‡º  é˜Ÿåˆ—å…ˆè¿›å…ˆå‡º\r\n\r\n### ä»£ç \r\n\r\n\r\n```java\r\nimport java.util.Stack;\r\n\r\n//leetcode submit region begin(Prohibit modification and deletion)\r\nclass MyQueue {\r\n    // åˆ›å»ºä¸¤ä¸ªæ ˆ å‡ºå…¥\r\n    Stack<Integer> stkIn;\r\n    Stack<Integer> stkOut;\r\n    public MyQueue() {\r\n        stkIn = new Stack<>();\r\n        stkOut = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        stkIn.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (stkOut.isEmpty()){\r\n            while(!stkIn.isEmpty()){\r\n                stkOut.push(stkIn.pop());\r\n            }\r\n        }\r\n        return stkOut.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (stkOut.isEmpty()) {\r\n            while(!stkIn.isEmpty()){\r\n                stkOut.push(stkIn.pop());\r\n            }\r\n        }\r\n        return stkOut.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return stkOut.isEmpty() && stkIn.isEmpty();\r\n    }\r\n}\r\n\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190428049","body":"### æ€è·¯\r\n\r\nå¯¹æ•°ç»„è¿›è¡Œå¾ªç¯å…¥æ ˆï¼Œé‡åˆ°å¤§äºç­‰äºæ ˆé¡¶çš„å…ƒç´ ç›´æ¥å…¥æ ˆï¼Œè‹¥å°äºæ ˆé¡¶çš„å…ƒç´ ï¼Œå…ˆå–å‡ºæ ˆé¡¶å…ƒç´ ï¼Œç„¶åå…¥æ ˆ \r\næ ˆçš„å…ƒç´ ä¸ªæ•°å³ä¸ºæ‰€å¾—å—çš„æœ€å¤§ä¸ªæ•°\r\n\r\n### ä»£ç \r\n\r\n\r\n```java\r\nimport java.util.Stack;\r\n\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> resStk = new Stack<>();\r\n        resStk.push(arr[0]);\r\n        for (int i = 1; i < arr.length; i++ ) {\r\n            if(!resStk.isEmpty() && arr[i] >= resStk.peek()){\r\n                resStk.push(arr[i]);\r\n            } else {\r\n                int curMax =resStk.pop();\r\n                while(!resStk.isEmpty() && resStk.peek() > arr[i]) {\r\n                    resStk.pop();\r\n                }\r\n                resStk.push(curMax);\r\n            }\r\n        }\r\n        return resStk.size();\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n### å¤æ‚åº¦\r\n\r\næ—¶é—´å¤æ‚åº¦:O(n)\r\nç©ºé—´å¤æ‚åº¦:O(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193344327","body":"### æ€è·¯\r\n\r\nåŒæŒ‡é’ˆ åˆ†åˆ«ä»ä¸¤ä¸ªé“¾è¡¨å¤´ç»“ç‚¹å¼€å§‹éå†ï¼Œéå†å®Œä¸€ä¸ªä¹‹åä»å¦ä¸€ä¸ªé“¾è¡¨å¤´ç»“ç‚¹ç»§ç»­éå†\r\nè‹¥ä¸¤ä¸ªæŒ‡é’ˆç›¸é‡ï¼Œåˆ™ç›¸é‡ç‚¹æ˜¯æ‰€æ±‚äº¤ç‚¹ è‹¥ä¸ç›¸é‡ï¼Œè¿”å›null\r\n\r\n### ä»£ç \r\n\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if (headA == null || headB == null)\r\n        {return null;}\r\n\r\n        ListNode Pa = headA;\r\n        ListNode Pb = headB;\r\n\r\n        while (Pa != Pb) {\r\n            if (Pa == null) {\r\n                Pa = headB;\r\n            } else {\r\n                Pa = Pa.next;\r\n            }\r\n            if (Pb == null) {\r\n                Pb = headA;\r\n            } else {\r\n                Pb = Pb.next;\r\n            }\r\n        }\r\n        return Pa;\r\n    }\r\n}\r\n```\r\n\r\n### å¤æ‚åº¦\r\n\r\næ—¶é—´å¤æ‚åº¦:O(n)\r\nç©ºé—´å¤æ‚åº¦:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194216885","body":"### æ€è·¯\r\n\r\nåŒæŒ‡é’ˆ å¿«æ…¢æŒ‡é’ˆ åˆ†åˆ«ä»ä¸¤ä¸ªé“¾è¡¨å¤´ç»“ç‚¹å¼€å§‹éå†\r\nslowèµ°ä¸€æ­¥ fastèµ°ä¸¤æ­¥ ç›¸é‡å³ä¸ºç¯æ‰€åœ¨ç‚¹\r\nç„¶åå°†æŒ‡é’ˆæŒ‡å‘headï¼Œä¸slowå†æ¬¡ç›¸é‡å³ä¸ºç¯çš„èŠ‚ç‚¹\r\nå¦åˆ™è¿”å›null\r\n\r\n\r\n### ä»£ç \r\n\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if (head == null || head.next == null) {\r\n            return null;\r\n        }\r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n\r\n        while (fast != null) {\r\n            slow =  slow.next;\r\n            if (fast.next != null) {\r\n                fast = fast.next.next;\r\n            } else {\r\n                return null;\r\n            }\r\n\r\n            while (fast == slow) {\r\n                ListNode idx = head;\r\n                if (idx != slow) {\r\n                    idx = idx.next;\r\n                    slow = slow.next;\r\n                }\r\n                return idx;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n### å¤æ‚åº¦\r\n\r\næ—¶é—´å¤æ‚åº¦:O(n)\r\nç©ºé—´å¤æ‚åº¦:O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196900125","body":"### æ€è·¯\r\n\r\næ·±åº¦ä¼˜å…ˆæœç´¢ é€’å½’2\r\n\r\n### ä»£ç \r\n\r\n\r\n```java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n        int leftHeight = maxDepth(root.left);\r\n        int rightHeight = maxDepth(root.right);\r\n        return Math.max(leftHeight,rightHeight) + 1;\r\n    }\r\n}\r\n```\r\n\r\n### å¤æ‚åº¦\r\n\r\næ—¶é—´å¤æ‚åº¦:O(n)\r\nç©ºé—´å¤æ‚åº¦:O(H)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198283390","body":"### æ€è·¯\r\n\r\nç®€å•é¢˜æˆ‘é‡æ‹³å‡ºå‡»ï¼Œä½†æ˜¯åªä¼šé€’å½’ æ ‘çš„éå†ç ”ç©¶ä¸€ä¸‹\r\n\r\n### ä»£ç \r\n\r\n\r\n```java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null && q == null ) {return true;}\r\n        if (p == null || q == null ) {return false;}\r\n        if (p.val != q.val ) {return false;}\r\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\r\n    }\r\n}\r\n```\r\n\r\n### å¤æ‚åº¦\r\n\r\næ—¶é—´å¤æ‚åº¦:O(n)\r\nç©ºé—´å¤æ‚åº¦:O(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202788648","body":"### æ€è·¯\r\n\r\nå…ˆæš´åŠ›å¼„ä¸€ä¸ªå†è¯´\r\n\r\n### ä»£ç \r\n\r\n\r\n```java\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int target) {\r\n        for (int i = 0 ; i < nums.length; i++){\r\n            for(int j = i + 1; j < nums.length ; j++){\r\n                if (nums[i] + nums[j] == target) {\r\n                    return new int[]{i,j};\r\n                }\r\n            }\r\n        }\r\n        return new int[]{-1,-1};\r\n    }\r\n}\r\n```\r\n\r\n### å¤æ‚åº¦\r\n\r\næ—¶é—´å¤æ‚åº¦:O(nÂ²)\r\nç©ºé—´å¤æ‚åº¦:O(1)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209482210","body":"### æ€è·¯\r\n\r\nå¿«æ…¢æŒ‡é’ˆ\r\n\r\n### ä»£ç \r\n\r\n\r\n```java\r\nclass Solution {\r\n    public int removeDuplicates(int[] nums) {\r\n        if (nums.length == 0) return 0;\r\n        int slow = 0;\r\n    //    int fast = 1;\r\n        for (int fast = 1; fast < nums.length; fast++){\r\n            if (nums[fast] != nums[slow]){\r\n                slow++;\r\n                nums[slow] = nums[fast];\r\n            }\r\n        }\r\n        return slow+1;\r\n    }\r\n}\r\n```\r\n\r\n### å¤æ‚åº¦\r\n\r\næ—¶é—´å¤æ‚åº¦:O(n)\r\nç©ºé—´å¤æ‚åº¦:O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangtuo1999":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185599809","body":"## æ€è·¯\r\næŠŠ k è½¬æ¢æˆæ•°ç»„ï¼Œå†å°† num å’Œ k ä¸¤ä¸ªæ•°ç»„åè½¬ã€‚åŒæŒ‡é’ˆï¼Œä»å¤´åˆ°å°¾ä¾æ¬¡å°†ä½™æ•°æ’å…¥ç»“æœæ•°ç»„ä¸­ã€‚\r\n\r\n## ä»£ç \r\n```javascript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n  const num1 = num.reverse();\r\n  const num2 = k\r\n    .toString()\r\n    .split(\"\")\r\n    .map((item) => parseInt(item))\r\n    .reverse();\r\n  const result = [];\r\n  let m = 0;\r\n  let n = 0;\r\n  let extra = 0;\r\n  while (m < num1.length && n < num2.length) {\r\n    const sum = num1[m++] + num2[n++] + extra;\r\n    extra = sum > 9 ? 1 : 0;\r\n    result.push(sum % 10);\r\n  }\r\n  while (m < num1.length) {\r\n    const sum = num1[m++] + extra;\r\n    extra = sum > 9 ? 1 : 0;\r\n    result.push(sum % 10);\r\n  }\r\n  while (n < num2.length) {\r\n    const sum = num2[n++] + extra;\r\n    extra = sum > 9 ? 1 : 0;\r\n    result.push(sum % 10);\r\n  }\r\n  if (extra) {\r\n    result.push(1);\r\n  }\r\n  return result.reverse();\r\n};\r\n```\r\n## å¤æ‚åº¦\r\næ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\nç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186218481","body":"```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n  const result = [];\r\n  for (let i = 0; i < s.length; i++) {\r\n    for (let j = 0; j < s.length; j++) {\r\n      if (s[j] === c) {\r\n        result[i] = Math.abs(i - j);\r\n        break;\r\n      }\r\n    }\r\n    for (let j = s.length - 1; j >= 0; j--) {\r\n      if (s[j] === c && Math.abs(i - j) < result[i]) {\r\n        result[i] = Math.abs(i - j);\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n};\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186532482","body":"## æ€è·¯\r\né¡ºåºæ ˆï¼Œå­¦è¿‡æ•°æ®ç»“æ„çš„éƒ½æ‡‚\r\n\r\n## ä»£ç \r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n  this.maxSize = maxSize;\r\n  this.ptr = 0;\r\n  this.stack = [];\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.ptr < this.maxSize) {\r\n    this.stack[this.ptr++] = x;\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n  if (this.ptr === 0) {\r\n    return -1;\r\n  }\r\n  return this.stack[--this.ptr];\r\n};\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n  for (let i = 0; i < Math.min(k, this.ptr); i++) {\r\n    this.stack[i] += val;\r\n  }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187635454","body":"```javascript\r\nvar decodeString = function (s) {\r\n  let numStack = [];\r\n  let strStack = [];\r\n\r\n  let num = 0,\r\n    result = \"\";\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    const item = s[i];\r\n\r\n    if (!isNaN(item)) {\r\n      num = num * 10 + parseInt(item);\r\n    } else if (item === \"[\") {\r\n      strStack.push(result);\r\n      result = \"\";\r\n      numStack.push(num);\r\n      num = 0;\r\n    } else if (item === \"]\") {\r\n      const repeatTimes = numStack.pop();\r\n      result = strStack.pop() + result.repeat(repeatTimes);\r\n    } else {\r\n      result += item;\r\n    }\r\n  }\r\n  return result;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189199748","body":"```javascript\r\nvar MyQueue = function () {\r\n  this.front = null;\r\n  this.stack1 = [];\r\n  this.stack2 = [];\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function (x) {\r\n  if (this.stack1.length === 0) {\r\n    this.front = x;\r\n  }\r\n  this.stack1.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function () {\r\n  if (this.stack2.length === 0) {\r\n    while (this.stack1.length > 0) {\r\n      this.stack2.push(this.stack1.pop());\r\n    }\r\n  }\r\n  return this.stack2.pop();\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function () {\r\n  if (this.stack2.length > 0) {\r\n    return this.stack2[this.stack2.length - 1];\r\n  }\r\n  return this.front;\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function () {\r\n  return this.stack1.length === 0 && this.stack2.length === 0;\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190392983","body":"## æ€è·¯\r\nå‰ç¼€å’Œ\r\n\r\n## ä»£ç \r\n```javascript\r\nvar maxChunksToSorted = function (arr) {\r\n  let sum1 = 0;\r\n  let sum2 = 0;\r\n  let ans = 0;\r\n  let arr2 = [...arr].sort((a, b) => a - b);\r\n  for (let i in arr) {\r\n    sum1 = sum1 + arr[i];\r\n    sum2 = sum2 + arr2[i];\r\n    if (sum1 == sum2) {\r\n      ans += 1;\r\n      sum1 = 0;\r\n      sum2 = 0;\r\n    }\r\n  }\r\n  return ans;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191572805","body":"```javascript\r\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\r\n    if (head === null || k === 0) return head\r\n    let temp = head\r\n    let n = 1\r\n    while (temp.next) {\r\n        temp = temp.next\r\n        n++\r\n    }\r\n    temp.next = head\r\n\r\n    k = n - k % n - 1\r\n    while (k > 0) {\r\n        head = head.next\r\n        k--\r\n    }\r\n\r\n    const res = head.next\r\n    head.next = null\r\n    return res\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192630124","body":"```javascript\r\nfunction swapPairs(head: ListNode | null): ListNode | null {\r\n  const dummy = new ListNode(0)\r\n  let pre = dummy\r\n  pre.next = head\r\n  while (pre.next && pre.next.next) {\r\n    let one = pre.next\r\n    let two = one.next;\r\n    [pre.next, one.next, two.next] = [two, two.next, one]\r\n    pre = one\r\n  }\r\n\r\n  return dummy.next\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193125223","body":"```javascript\r\nvar sortedListToBST = function(head) {\r\n   const arr = []\r\n   while(head){\r\n       arr.push(head.val)\r\n       head=head.next\r\n   }\r\n   return buildBST(arr,0,arr.length-1)\r\n   function buildBST(arr,start,end){\r\n      if (start > end) return null;\r\n     let mid = Math.floor((start+end)/2)\r\n     const root= new TreeNode(arr[mid])\r\n     root.left=buildBST(arr,start,mid-1)\r\n     root.right=buildBST(arr,mid+1,end)\r\n     return root\r\n   }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193344644","body":"```javascript\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let a = headA, b = headB;\r\n    while(a !== b) {\r\n        a = a ? a.next : headB;\r\n        b = b ? b.next : headA;\r\n    }\r\n    return a;\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cytrue":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185613290","body":"           public List<Integer> addToArrayForm(int[] num, int k) {\n\n        List<Integer> res=new ArryList<Integer>();\n        int n=num.length;\n        for(int i=n-1;i>=0;--i)\n        {\n            int sum=num[i] + k % 10;//å¦‚æœK=123è¿™ä¸ªæ•°ï¼Œé‚£K % 10 å–å‡ºæ¥çš„æ˜¯ä¸ªæ•°çš„ä½™æ•°ï¼Œå³æŠŠ3å–å‡ºæ¥\n            K / =10;//ç›¸å½“äºK=K/10ï¼›å°±æ˜¯123é™¤äº10å¹¶å–æ•´è¿”å›ï¼Œé‚£å°±æ˜¯å¾€å‰è¿›ä¸€ä½ï¼Œè¿”3å»æ‰ï¼Œè¿”å›12å€¼ç»™ä¸‹ä¸€æ¬¡ç”¨\n            if(sum>=10)//å¦‚æœsumå¾—å‡ºæ¥çš„å€¼å¤§äº10\n            {\n                k++;//æŠŠè¿›ä½çš„å€¼æ”¾åœ¨kä¸Šï¼Œå³kè¿›ä¸€ä½ï¼ŒåŠ 1\n                sum-=10;//æŠŠç›¸åŠ çš„å€¼å‡æ‰è¿›ä½\n            }\n            res.add(sum);\n        }\n        //å¦‚æœnumçš„ä½æ•°å°äºKçš„ä½æ•°ï¼Œé‚£è¿˜éœ€è¦å¤šä¸€æ­¥å¤„ç†Kå‰©ä¸‹çš„æ•°\n        for(; k > 0;k / =10)//æ¯æ¬¡å¾ªç¯Kçš„å‰è¿›ä¸€ä½ï¼Œå¦‚æœå°äº0åˆ™è¡¨ç¤ºå·²ç»æ²¡æœ‰æ•°å¯ä»¥è¿›ä½äº†\n        {\n            res.add(k % 10 ); //æŠŠKçš„ä½™æ•°å–å‡ºæ¥è¿”å›\n        }\n\n        Collections.reverse(res);\n        return res;\n\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186173222","body":"class Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n=s.length();\n        int[] ans=new int[n];\n        for(int i=0,idx=-n;i<n;++i)\n        {\n            //ç¬¬ä¸€å±‚å¾ªç¯ï¼Œä»å·¦å¾€å³æ‰¾ï¼Œä¸»è¦æ˜¯å…ˆæ‰¾åˆ°å€¼ï¼Œæ›´æ–°æ‰¾åˆ°å€¼çš„åé¢åç§»é‡ï¼Œidxçš„åˆå§‹å€¼æ— æ‰€è°“\n            if(s.charAt(i)==c)\n            {\n                idx=i;\n            }\n            ans[i]=i-idx;\n        }\n    //å¼€å§‹ç¬¬äºŒå±‚å¾ªç¯,ä»å³å¾€å·¦æ‰¾\n      for(int i=n-1,idx=2*n;i>=0;--i)\n        {\n            if(s.charAt(i)==c)\n            {\n                idx=i;\n            }\n            ans[i]=Math.min(ans[i],idx-i);\n\n        }\n        return ans;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186413613","body":"//å®šä¹‰è¿™ä¸ªç±»ï¼Œå¿…é¡»è¦æœ‰å¼¹å‡ºå’Œå¢åŠ æ•°æ®çš„æ¥å£\r\n//æ–°å¢ä¸€ä¸ªé™åˆ¶çš„æ•°ï¼Œè¿˜æ§åˆ¶æ•°é‡çš„å¢åŠ ï¼Œæ¯æ¬¡å¢å’Œå¼¹å‡ºæ ˆçš„æ—¶å€™ï¼Œå…ˆå¼¹å‡ºæ•°ç»„çš„é‚£ä¸ªæ•°ï¼Œé™åˆ¶å†å‡ä¸€\r\n\r\n class customerStack2{\r\n\r\n    int[] stack;\r\n    int top;\r\n\r\n    public customerStack2(int maxSize)\r\n    {\r\n    stack=new int[maxSize];\r\n    top =-1;\r\n    }\r\n\r\n    //æ–°å¢ä¸€ä¸ªæ•°\r\n    public void push(int x)\r\n    {\r\n        if(top!=stack.length-1)\r\n\r\n        {\r\n            top++;\r\n            stack[top]=x;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    //Â å¼¹å‡ºä¸€ä¸ªæ•°\r\n    public   int pop()\r\n    {\r\n\r\n        if (top==-1)\r\n        {\r\n            return -1;\r\n        }\r\n\r\n        --top;\r\n        return stack[top+1];\r\n\r\n    }\r\n\r\n    //åœ¨æ¯ä¸ªæ•°æ®ä¸Šé¢å¢åŠ ä¸€ä¸ªæ•°å­—\r\n    public void increment(int k,int x)\r\n    {\r\n\r\n        int max=Math.min(k, top+1);\r\n        for(int i=0;i<max;i++)\r\n        {\r\n         \r\n            stack[i] +=x;\r\n        }\r\n\r\n\r\n    }\r\n\r\n }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186728695","body":"//ç”¨æ ˆæ¥è§£å†³\n//æ•°å­—å’Œå­—æ¯éƒ½è¿›æ ˆï¼Œå½“ç¢°åˆ°ã€‘å·æ—¶ï¼Œå°±å¼€å§‹å¾ªç¯é‡å¤ç”Ÿæˆå­—ç¬¦ä¸²ï¼Œç”Ÿå®Œåå†åè½¬\n\nclass Solution {\n    int ptr;\n\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<String>();\n        ptr = 0;\n\n        while (ptr < s.length()) {\n            char cur = s.charAt(ptr);\n            if (Character.isDigit(cur)) {\n                // è·å–ä¸€ä¸ªæ•°å­—å¹¶è¿›æ ˆ\n                String digits = getDigits(s);\n                stk.addLast(digits);\n            } else if (Character.isLetter(cur) || cur == '[') {\n                // è·å–ä¸€ä¸ªå­—æ¯å¹¶è¿›æ ˆ\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \n            } else {\n                ++ptr;\n                LinkedList<String> sub = new LinkedList<String>();\n                while (!\"[\".equals(stk.peekLast())) {\n                    sub.addLast(stk.removeLast());\n                }\n                Collections.reverse(sub);\n                // å·¦æ‹¬å·å‡ºæ ˆ\n                stk.removeLast();\n                // æ­¤æ—¶æ ˆé¡¶ä¸ºå½“å‰ sub å¯¹åº”çš„å­—ç¬¦ä¸²åº”è¯¥å‡ºç°çš„æ¬¡æ•°\n                int repTime = Integer.parseInt(stk.removeLast());\n                StringBuffer t = new StringBuffer();\n                String o = getString(sub);\n                // æ„é€ å­—ç¬¦ä¸²\n                while (repTime-- > 0) {\n                    t.append(o);\n                }\n                // å°†æ„é€ å¥½çš„å­—ç¬¦ä¸²å…¥æ ˆ\n                stk.addLast(t.toString());\n            }\n        }\n\n        return getString(stk);\n    }\n\n    public String getDigits(String s) {\n        StringBuffer ret = new StringBuffer();\n        while (Character.isDigit(s.charAt(ptr))) {\n            ret.append(s.charAt(ptr++));\n        }\n        return ret.toString();\n    }\n\n    public String getString(LinkedList<String> v) {\n        StringBuffer ret = new StringBuffer();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190402692","body":"public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0;\n        int nonzero = 0;\n\n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n\n        //arr=2,1,3,4,4\n        //expect=1ï¼Œ2ï¼Œ3ï¼Œ4ï¼Œ4\n        for (int i = 0; i < arr.length; ++i) {\n            int x = arr[i];\n            int y = expect[i];\n            //ç¬¬ä¸€è½®ï¼Œx=2ï¼Œy=1\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            //count.map key=2,value=1\n            //nonzero=1;\n\n            //ç¬¬äºŒè½®ï¼Œx=1ï¼Œy=2\n            //count.map key=1,value=1\n            //nonzero=1\n\n            if (count.get(x) == 0) {\n                nonzero--;\n            }\n            if (count.get(x) == 1) {\n                nonzero++;\n            }\n\n\n            count.put(y, count.getOrDefault(y, 0) - 1);\n\n            //count map key=1 value=-1\n            //nonzero=2\n\n            //ç¬¬äºŒè½®\n            //count map key=2 value=0ï¼›\n\n            //nonzero=1\n\n            if (count.get(y) == -1) {\n                nonzero++;\n            }\n            if (count.get(y) == 0) {\n                nonzero--;\n            }\n\n            if (nonzero == 0) {\n                ans++;\n            }\n        }\n\n        return ans;\n    }","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192693913","body":"    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode newHead = head.next;\n        head.next = swapPairs(newHead.next);\n        newHead.next = head;\n        return newHead;\n    }","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193150087","body":"     public ListNode getINstersectionNode(ListNode headA,ListNode headB)\n     {\n        Set<ListNode> visted=new HashSet<ListNode>();\n        ListNode temp=headA;\n        while(temp!=null)\n        {\n            visted.add(temp);\n            temp=temp.next;\n        }\n\n        temp=headB;\n        while(temp!=null)\n        {\n            if(visted.contains(temp))\n            {\n                return temp;\n            }\n            temp=temp.next;\n\n        }\n\n        return null;\n\n\n     }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193468206","body":"     public static ListNode getLoopNode(ListNode head)\n     {\n\n        if(head==null||head.next==null||head.next.next==null)\n        {\n            return null;\n        }\n\n        ListNode n1=head.next;\n\n        ListNode n2=head.next.next;\n        while(n1!=n2)\n        {\n            if(n2.next==null||n2.next.next==null)\n            {\n                return null;\n            }\n            n2=n2.next.next;\n            n1=n1.next;\n        }\n\n        n2=head;\n        while(n1!=n2)\n        {\n            n1=n1.next;\n            n2=n2.next;\n        }\n\n        return n1;\n     }","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196268918","body":"var maxDepth = function(root) {\n    if(root === null) return 0\n    return Math.max(maxDepth(root.left),maxDepth(root.right))+1\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197596811","body":"public boolean isSameTree (ListNode p,ListNode q)\n{\n\n    if(q==null&&p==null) return true;\n    if (q==null ||p==null) return false;\n    if(p.val!=q.val) return false;\n    return isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198995497","body":"     public int dfs(TreeNode root,int preSum)\n     {\n\n        if(root==null)\n        {\n            return 0;\n        }\n        int sum=preSum*10+root.val;\n        if(root.left==null&&root.right==null)\n        {\n            return sum;\n\n        } else\n        {\n\n            return dfs(root.left,sum)+dfs(root.right,sum);\n        }\n\n     }","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200410905","body":"public class Codec {\n    public String serialize(TreeNode root) {\n        return rserialize(root, \"\");\n    }\n  \n    public TreeNode deserialize(String data) {\n        String[] dataArray = data.split(\",\");\n        List<String> dataList = new LinkedList<String>(Arrays.asList(dataArray));\n        return rdeserialize(dataList);\n    }\n\n    public String rserialize(TreeNode root, String str) {\n        if (root == null) {\n            str += \"None,\";\n        } else {\n            str += str.valueOf(root.val) + \",\";\n            str = rserialize(root.left, str);\n            str = rserialize(root.right, str);\n        }\n        return str;\n    }\n  \n    public TreeNode rdeserialize(List<String> dataList) {\n        if (dataList.get(0).equals(\"None\")) {\n            dataList.remove(0);\n            return null;\n        }\n  \n        TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0)));\n        dataList.remove(0);\n        root.left = rdeserialize(dataList);\n        root.right = rdeserialize(dataList);\n    \n        return root;\n    }\n}\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201915886","body":"class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer,Integer> map = new HashMap<>();\n        for(int i=0;i<nums.length;i++){\n            if(map.containsKey(target-nums[i])){\n                return new int[]{map.get(target-nums[i]),i};\n            }else{\n                map.put(nums[i],i);\n            }\n        }\n        return new int[]{0,0};\n    }\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206491768","body":"    public int lengthOfLongestSubstring(String s) {\n\n        int left = 0;\n        int maxLen = 0;\n        Set<Character> set = new HashSet<>();\n\n        for (int i = 0; i < s.length(); i++) {\n\n            if (!set.add(s.charAt(i))) {\n                \n                maxLen = Math.max(maxLen, set.size());\n                while (s.charAt(left) != s.charAt(i)) {\n\n                    set.remove(s.charAt(left));\n                    left++;\n                }\n\n                left += 1;\n            }\n        }\n\n        return Math.max(maxLen, set.size());\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207229749","body":"class Solution {\n\n    public List<Integer> findSubstring(String s, String[] words) {\n\n        List<Integer> res = new ArrayList<>();\n\n        Map<String, Integer> map = new HashMap<>();\n\n        if (words == null || words.length == 0)\n            return res;\n\n        for (String word : words)\n            map.put(word, map.getOrDefault(word, 0) + 1);\n\n        int sLen = s.length(), wordLen = words[0].length(), count = words.length;\n\n        int match = 0;\n\n        for (int i = 0; i < sLen - wordLen * count + 1; i++) {\n\n            //å¾—åˆ°å½“å‰çª—å£å­—ç¬¦ä¸²\n            String cur = s.substring(i, i + wordLen * count);\n            Map<String, Integer> temp = new HashMap<>();\n            int j = 0;\n\n            for (; j < cur.length(); j += wordLen) {\n\n                String word = cur.substring(j, j + wordLen);\n                // å‰ªæ\n                if (!map.containsKey(word))\n                    break;\n\n                temp.put(word, temp.getOrDefault(word, 0) + 1);\n                // å‰ªæ\n                if (temp.get(word) > map.get(word))\n                    break;\n            }\n\n            if (j == cur.length())\n                res.add(i);\n        }\n\n        return res;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207411036","body":"import java.util.*;\n\nclass Solution {\n\n    public int solve(int[] nums, int k) {\n\n        int tar = 0;\n\n        for (int n : nums)\n            tar += n;\n\n        tar = Math.floorMod(tar, k);\n\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, -1);\n\n        int prefix = 0, res = nums.length;\n\n        for (int i = 0; i < nums.length; i++) {\n\n            prefix += nums[i];\n            int mod = Math.floorMod(prefix, k);\n            map.put(mod, i);\n\n            if (map.containsKey(Math.floorMod(prefix - tar, k)))\n                res = Math.min(res, i - map.get(Math.floorMod(prefix - tar, k)));\n        }\n\n        return res == nums.length ? -1 : res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208049141","body":"class Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode fast = head, slow = head;\n        while(fast!=null&&fast.next!=null){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209012449","body":"class Solution {\n    public int removeDuplicates(int[] nums) {\n        int slow = 0;\n        for (int fast = 1; fast < nums.length; fast++) {\n            if (nums[fast] != nums[slow]) {\n                slow++;\n                nums[slow] = nums[fast];\n            }\n        }\n        return slow + 1;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyryan-web":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185615180","body":"```ts\nfunction addToArrayForm(num: number[], k: number): number[] {\n    const res: number[] = []\n\n    // ä»æ•°ç»„çš„æœ€å³è¾¹å¼€å§‹è®¡ç®—ï¼Œæ¥æ¨¡æ‹Ÿæ•°å­—ç›¸åŠ æ“ä½œ\n    const len = num.length\n\n    for (let i = len - 1; i >= 0; --i) {\n        let carry = num[i] + k % 10\n\n        k = Math.floor(k / 10)\n\n        if (carry >= 10) {\n            k++\n            carry = carry - 10\n        }\n\n        res.push(carry)\n    }\n\n    while (k > 0) {\n        res.push(k % 10)\n        k = Math.floor(k / 10)\n    }\n\n    res.reverse()\n\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186207697","body":"```ts\n/**\n * æ­£åéå†:\n * æ€è·¯ä¸ºæ­£åä¸¤ä¸ªæ–¹å‘éƒ½éå†ä¸€æ¬¡æ•°æ®ï¼Œç„¶åå–ä¸¤æ¬¡æ•°ç»„æ¯ä¸ªä¸‹è¡¨æ¯”è¾ƒçš„æœ€å°å€¼å³å¯\n */\nfunction shortestToChar(s: string, c: string): number[] {\n    const n = s.length\n\n    /** å…ˆå®šä¹‰ä¸€ä¸ªè·Ÿ s é•¿åº¦ä¸€æ ·çš„æ•°ç»„å»å­˜å‚¨å€¼ */\n    const answer: number[] = new Array(n).fill(0)\n\n    // æ­£å‘éå†\n    for (let i = 0, j = -n; i < n; i++) {\n        if (s[i] === c) {\n            j = i\n        }\n\n        // è®¡ç®—æ¯ä¸ªä¸‹æ ‡åˆ° \"c\" å­—ç¬¦ä¸²çš„è·ç¦»\n        answer[i] = i - j\n\n    }\n\n    // åå‘éå†\n    for (let i = n - 1, j = 2 * n; i >= 0; i--) {\n        if (s[i] === c) {\n            j = i\n        }\n\n        answer[i] = Math.min(answer[i], j - i)\n\n    }\n\n    return answer\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186416013","body":"```ts\nclass CustomStack {\n    protected stack!: number[]\n    protected top!: number\n\n    constructor(maxSize: number) {\n        this.stack = new Array(maxSize)\n        this.top = -1\n    }\n\n    push(x: number): void {\n        // åªè¦æ˜¯ä¸è¶…è¿‡æ ˆçš„æœ€å¤§é•¿åº¦\n        if (this.top !== this.stack.length - 1) {\n            this.top++\n            this.stack[this.top] = x\n        }\n    }\n\n    pop(): number {\n        // åˆ¤æ–­ä¸ºç©ºçš„æ ˆ\n        if (this.top === -1) {\n            return -1\n        }\n        this.top--\n        return this.stack[this.top + 1]\n    }\n\n    increment(k: number, val: number): void {\n        const limit = Math.min(k, this.top + 1)\n        for (let i = 0; i < limit; i++) {\n            this.stack[i] = this.stack[i] + val\n        }\n    }\n}\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187648428","body":"```ts\n/**\n * @author liuyuan\n * @date 2022-07-18 22:39\n * @since 1.0.0\n */\n\nfunction decodeString(s: string): string {\n    // é‡å¤å­—ç¬¦ä¸²\n    let stack_count: any[] = []\n    let stack_str: any[] = []\n\n    let result = ''\n\n    // é‡å¤æ¬¡æ•°çš„æ ˆ\n    let count = 0\n\n    for (let i = 0; i < s.length; i++) {\n        // å½“å‰éå†åˆ°çš„å­—ç¬¦ä¸²\n        let item = s[i]\n\n        if (!isNaN(Number(item))) {\n            count = count * 10 + parseInt(item)\n        } else if (item === '[') {\n            stack_str.push(result)\n            result = ''\n\n            stack_count.push(count)\n            count = 0\n        } else if (item === ']') {\n            const repeatTimes = stack_count.pop()\n            result = stack_str.pop() + result.repeat(repeatTimes)\n        } else {\n            result = result + item\n        }\n    }\n\n    return result\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189062920","body":"```ts\nclass MyQueue {\n    protected inStack: number[]\n\n    protected outStack: number[]\n\n    constructor() {\n        this.inStack = []\n        this.outStack = []\n    }\n\n    push(x: number): void {\n        this.inStack.push(x)\n    }\n\n    /**\n     * æŠŠæ‰€æœ‰çš„æ•°æ®éƒ½å¼¹å…¥å¦ä¸€ä¸ªé˜Ÿåˆ—ï¼Œç„¶ååœ¨å¦ä¸€ä¸ªé˜Ÿåˆ— pop()\n     */\n    pop(): number {\n        if (!this.outStack.length) {\n            this.formatIn2Out()\n        }\n\n        return this.outStack.pop() as number\n    }\n\n    peek(): number {\n        if (!this.outStack.length) {\n            this.formatIn2Out()\n        }\n\n        return this.outStack[this.outStack.length - 1]\n    }\n\n    empty(): boolean {\n        return !this.inStack.length && !this.outStack.length\n    }\n\n    formatIn2Out() {\n        while (this.inStack.length) {\n            this.outStack.push(this.inStack.pop() as number)\n        }\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190392499","body":"ä½¿ç”¨æ»‘åŠ¨çª—å£è§£æ³•ï¼Œåªéœ€è¦æ’åºåçš„æ•°ç»„è·ŸåŸæ•°ç»„è¿›è¡Œæ¯”è¾ƒï¼Œåˆ¤æ–­åˆ†åŒºåçš„ä»£ç æ€»å’Œä¸åŸæ•°ç»„ä¸€è‡´å³å¯åˆ¤æ–­ä¸ºå¯åˆ†åŒº\n\n```ts\nfunction maxChunksToSorted(arr: number[]): number {\n    const sorted = [...arr]\n\n    sorted.sort((a, b) => a - b)\n\n    let count = 0\n\n    /** åŸåˆ†ç»„çš„å’Œ */\n    let sum1 = 0\n\n    /** åˆ†å—åçš„æ•°ç»„çš„å’Œ */\n    let sum2 = 0\n\n    for (let i = 0; i < arr.length; i++) {\n        sum1 = sum1 + arr[i]\n\n        sum2 = sum2 + sorted[i]\n\n        if (sum1 === sum2) {\n            count++\n        }\n    }\n\n    return count\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191276779","body":"```ts\n\n\n/** \n * æ€è·¯: \n * æ—‹è½¬é“¾è¡¨ï¼Œå…¶å®å°±æ˜¯æŠŠå€’æ•°ç¬¬äºŒä½çš„ next -> null, ç„¶åæœ€åä¸€ä½çš„ next ä» null æŒ‡å‘äºå¤´éƒ¨,è¿™ä¸ªæµç¨‹å°±æ˜¯æ—‹è½¬äº†ä¸€ä½\n * å‡è®¾å¦‚é¢˜ç›®ä¸­çš„ 1 -> 2 -> 3 -> 4 -> 5 æ—‹è½¬ä¸€ä½ï¼Œå…¶å®å°±æ˜¯ 4 -> null å’Œ 5 -> 1, ç„¶åå†è¿”å›æœ€åä¸€ä½æŒ‡å‘ head æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œå³å¯å¾—åˆ°ç»“æœ\n * \n * æ¨ç®—:\n * ä»¥æ­¤ä¸ºæ¨ç®—ï¼Œå°±å¯ä»¥å‡è®¾ç§»åŠ¨çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ä¸º K, å€’æ•°ç¬¬äºŒä½èŠ‚ç‚¹ä¸º K+1\n * ä¹Ÿå°±æ˜¯ (K+1).next = null , K.next = head, ç„¶åè¿”å› K å³å¯\n * \n * è®¡ç®—ç§»åŠ¨ä½æ•°çš„æ—¶å€™ï¼Œåªéœ€è¦è€ƒè™‘åˆ° k & count(é“¾è¡¨é•¿åº¦)çš„ç»“æœå³å¯ï¼Œ å› ä¸ºé•¿åº¦ä¸º 3 çš„é“¾è¡¨å¾€å³è¾¹ç§»åŠ¨ 4 ä½è·Ÿå¾€å³è¾¹ç§»åŠ¨ä¸€ä½çš„ç»“æœæ˜¯ä¸€æ ·çš„\n */\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n    /** æ’é™¤ç©ºé“¾è¡¨å’Œç§»åŠ¨ä¸º 0 çš„æç«¯æƒ…å†µ */\n    if (!head || !head?.next || k === 0) {\n        return head\n    }\n\n    /** é“¾è¡¨ä¸­çš„æ€»é•¿åº¦, ä¸Šé¢åˆ¤æ–­äº†ç©ºå’Œé•¿åº¦ä¸º 0 çš„æƒ…å†µï¼Œæ‰€ä»¥é•¿åº¦è‡³å°‘ä¸º 1 */\n    let count = 1\n\n    let p = head\n\n    /** è®¡ç®—é“¾è¡¨çš„æ€»é•¿åº¦ */\n    while (p?.next !== null) {\n        p = p.next\n        count++\n    }\n\n    /** æœ€ç»ˆç§»åŠ¨çš„ä½ç½® */\n    k = k % count\n\n    let slow: ListNode | null = head\n\n    let fast: ListNode | null = head\n\n    while (fast?.next) {\n        if (k-- <= 0) {\n            slow = slow.next!\n        }\n        fast = fast.next\n    }\n\n    /** \n     * æ­¤æ—¶å·²ç»å½¢æˆä¸€ä¸ªç¯å½¢é“¾è¡¨äº†, ç„¶åæŠŠæ…¢æŒ‡é’ˆçš„ next è¿”å›å³ä¸ºç»“æœï¼Œç„¶åå†æŠŠ next -> null æ¥ç æ–­é“¾è¡¨\n     */\n    fast!.next = head\n\n    const res = slow.next\n\n    slow.next = null\n\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192593174","body":"```ts\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction swapPairs(head: ListNode | null): ListNode | null {\n    if (!head || !head?.next) {\n        return head\n    }\n\n    let preNode = new ListNode()\n\n    preNode.next = head\n\n    let p = preNode\n\n    while (p?.next !== null && p?.next?.next !== null) {\n        const node1 = p.next\n        const node2 = p.next.next\n\n        p.next = node2\n\n        node1.next = node2.next\n\n        node2.next = node1\n\n        p = node1\n    }\n\n    return preNode.next\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193115317","body":"```ts\n/**\n * é‡‡ç”¨å¿«æ…¢æŒ‡é’ˆæ–¹æ³•ï¼Œå¿«æŒ‡é’ˆç§»åŠ¨åˆ°æœ«å°¾çš„æ—¶å€™ï¼Œæ…¢æŒ‡é’ˆåˆšå¥½æŒ‡åˆ°ä¸­é—´\n */\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    if (!head) {\n        return null\n    }\n\n    return dfs(head, null)\n};\n\nfunction dfs(head: ListNode, tail: ListNode | null) {\n    if (head === tail) {\n        return null\n    }\n\n    let slow = head\n    let fast = head\n\n    /** æ ¹æ®å¿«æ…¢æŒ‡é’ˆï¼Œå¿«æŒ‡é’ˆç»“æŸçš„æ—¶å€™ï¼Œæ…¢æŒ‡é’ˆåˆšå¥½åˆ°ä¸­é—´ */\n    while (fast !== tail && fast.next !== tail) {\n        fast = fast.next!.next!\n        slow = slow.next!\n    }\n\n    const root = new TreeNode(slow.val)\n    root.left = dfs(head, slow)!\n    root.right = dfs(slow.next!, tail)!\n    return root\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193266938","body":"```ts\n/**\n * å¦‚æœæœ‰ç›¸äº¤ç‚¹çš„è¯ï¼ŒA + C + B è‚¯å®šå’Œ B + C + A æœ‰äº¤ç‚¹ï¼Œå°±å¯ä»¥è€ƒè™‘ç”¨åŒæŒ‡é’ˆæ¥è¿›è¡Œéå†\n * \n * æ—¶é—´å¤æ‚åº¦: O(m + n) æœ€åçš„æƒ…å†µä¸‹å°±æ˜¯è¦éå†ä¸¤ä¸ªé“¾è¡¨ï¼Œ m ä¸º A çš„é•¿åº¦ï¼Œn ä¸º B çš„é•¿åº¦\n * ç©ºé—´å¤æ‚åº¦: O(1) æ²¡æœ‰çº¿æ€§å¢é•¿çš„ç»“æ„\n */\nfunction getIntersectionNode_Double(headA: ListNode | null, headB: ListNode | null): ListNode | null {\n    if (!headA || !headB) {\n        return null\n    }\n\n    let p1: ListNode | null = headA\n    let p2: ListNode | null = headB\n\n    while (p1 !== p2) {\n        p1 = p1 ? p1.next : headB\n        p2 = p2 ? p2.next : headA\n    }\n\n    // åæ­£ p1 p2 éƒ½å¯ä»¥ï¼Œéå†åˆ°æœ€åå¦‚æœæ˜¯æ²¡æœ‰ç›¸äº¤çš„è¯éƒ½æ˜¯ä¸º null\n    return p1\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194115287","body":"åŒæŒ‡é’ˆå†™æ³•\n```ts\n/**\n * @author liuyuan\n * @date 2022-07-25 22:00\n * @since 1.0.0\n */\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction detectCycle(head: ListNode | null): ListNode | null {\n    if (!head || !head.next) {\n        return null\n    }\n\n    let p1: ListNode | null = head\n    let p2: ListNode | null = head\n\n    while (p1 && p2) {\n        p1 = p1?.next || null\n        p2 = p2.next?.next || null\n\n        if (p1 === p2) {\n            // return p1\n            let ptr: ListNode | null = head\n\n            while (ptr !== p1) {\n                ptr = ptr?.next || null\n                p1 = p1?.next || null\n            }\n\n            return ptr\n        }\n    }\n\n    return null\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195581811","body":"è¿™é“é¢˜æœ‰ç‚¹éš¾ï¼Œæ²¡æœ‰ä½œå‡º O(1)çš„è§£æ³•ï¼Œæš‚æ—¶ç”¨ map çš„ O(N)æ¥è§£ç­”é¢˜ç›®çš„è¦æ±‚\n```ts\n/**\n * @author liuyuan\n * @date 2022-07-26 22:15\n * @since 1.0.0\n */\n\nclass LRUCache {\n    protected capacity!: number\n    protected map: Map<number, number> = new Map()\n\n    constructor(capacity: number) {\n        this.capacity = capacity\n        this.map = new Map()\n    }\n\n    get(key: number): number {\n        if (this.map.has(key)) {\n            const value = this.map.get(key) as number\n\n            /** åœ¨ js é‡Œé¢ï¼Œmap æ˜¯æœ‰å­˜å…¥çš„å…ˆåé¡ºåºçš„ï¼Œæ‰€ä»¥åªéœ€è¦åˆ é™¤è¯¥èŠ‚ç‚¹å†åŠ å…¥å³å¯ */\n            this.map.delete(key)\n            this.map.set(key, value)\n\n            return value\n        }\n\n        return -1\n    }\n\n    put(key: number, value: number): void {\n        /** æœ‰å°±åˆ æ‰å†èµ‹å€¼ */\n        if (this.map.has(key)) {\n            this.map.delete(key)\n        }\n\n        this.map.set(key, value)\n\n        /** åˆ¤æ–­å®¹é‡å¤§å°ï¼Œæ·˜æ±°æ‰æœ«ä½ */\n        if (this.map.size > this.capacity) {\n            this.map.delete(this.map.keys().next().value)\n        }\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196810195","body":"```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction maxDepth(root: TreeNode | null): number {\n    let deepLen = 0\n\n    /**\n     *\n     * @param root {TreeNode | null} æ ‘çš„èŠ‚ç‚¹\n     * @param len {number} èŠ‚ç‚¹çš„é•¿åº¦\n     * @returns\n     */\n    const dfs = (root: TreeNode | null, len: number) => {\n        if (!root) {\n            return\n        }\n\n        // console.log(root.val)\n\n        // è¿™ä¸€è¡Œä¸ç”¨æ¯ä¸ªéå†éƒ½åˆ¤æ–­ï¼Œåªéœ€è¦åˆ¤æ–­æ˜¯å¦ä¸º â€œå¶å­èŠ‚ç‚¹â€ å³å¯\n        // deepLen = Math.max(deepLen, len)\n        if (!root.left && !root.right) {\n            deepLen = Math.max(deepLen, len)\n        }\n\n        dfs(root.left, len + 1)\n        dfs(root.right, len + 1)\n    }\n\n    dfs(root, 1)\n\n    return deepLen\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197619512","body":"```ts\n/**\n * ç›´æ¥ç”¨æ·±åº¦ä¼˜å…ˆéå†é€’å½’è‡ªèº«èŠ‚ç‚¹å³å¯\n */\n\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\n    if (!p || !q) {\n        return !p && !q\n    }\n\n    return (\n        p.val === q.val &&\n        isSameTree(q.left, p.left) &&\n        isSameTree(q.right, p.right)\n    )\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198990129","body":"```ts\n/**\n * æ·±åº¦ä¼˜å…ˆéå†\n */\nfunction sumNumbers(root: TreeNode | null): number {\n    let sum = 0\n\n    function dfs(root: TreeNode | null, cur: number) {\n        if (!root) {\n            return\n        }\n\n        let curSum = cur * 10 + root.val\n\n        if (!root.left && !root.right) {\n            sum = sum + curSum\n            return\n        }\n\n        dfs(root.left, curSum)\n        dfs(root.right, curSum)\n    }\n\n    dfs(root, 0)\n\n    return sum\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200101992","body":"```ts\n/**\n * å…¶å®å°±æ˜¯æ‹¿æœ€åä¸€è¡Œçš„æœ€å·¦è¾¹çš„å€¼\n */\nfunction findBottomLeftValue(root: TreeNode | null): number {\n    let curLevel: (TreeNode | null)[] = [root]\n\n    let res = root?.val || 0\n\n    while (curLevel.length) {\n        let nextLevel: (TreeNode | null)[] = []\n\n        for (let i = 0; i < curLevel.length; i++) {\n            if (curLevel[i]?.left) {\n                nextLevel.push(curLevel[i]?.left!)\n            }\n\n            if (curLevel[i]?.right) {\n                nextLevel.push(curLevel[i]?.right!)\n            }\n        }\n\n        res = curLevel[0]?.val || 0\n        curLevel = nextLevel!\n    }\n\n    return res\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200424960","body":"```ts\n\n/**\n * @author liuyuan\n * @date 2022-07-31 16:27\n * @since 1.0.0\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n/**\n * åºåˆ—å·é€šä¿—çš„è®²ï¼Œå°±æ˜¯æ ‘çš„ç»“æ„è½¬æ¢ä¸º string ç±»å‹ï¼Œ ç„¶åæŠŠ string å†è½¬æ¢ä¸ºæ ‘\n */\n\n/*\n * Encodes a tree to a single string.\n */\nfunction serialize(root: TreeNode | null): string {\n    if (root == null) {\n        // éå†åˆ° null èŠ‚ç‚¹\n        return '#'\n    }\n    const left = serialize(root.left) // å·¦å­æ ‘çš„åºåˆ—åŒ–ç»“æœ\n    const right = serialize(root.right) // å³å­æ ‘çš„åºåˆ—åŒ–ç»“æœ\n    return root.val + ',' + left + ',' + right // æŒ‰  æ ¹,å·¦,å³  æ‹¼æ¥å­—ç¬¦ä¸²\n}\n\n/*\n * Decodes your encoded data to tree.\n */\nfunction deserialize(data: string): TreeNode | null {\n    const list = data.split(',') // splitæˆæ•°ç»„\n\n    const buildTree = (list: string[]) => {\n        // åŸºäºlistæ„å»ºå½“å‰å­æ ‘\n        const node = list.shift() // å¼¹å‡ºé¦–é¡¹ï¼Œè·å–å®ƒçš„â€œæ•°æ®â€\n        if (node == '#') {\n            // æ˜¯#ï¼Œè¿”å›nullèŠ‚ç‚¹\n            return null\n        }\n        const root = new TreeNode(Number(node)) // ä¸æ˜¯#ï¼Œåˆ™åˆ›å»ºèŠ‚ç‚¹\n        root.left = buildTree(list) // é€’å½’æ„å»ºå·¦å­æ ‘\n        root.right = buildTree(list) // é€’å½’æ„å»ºå³å­æ ‘\n        return root // è¿”å›å½“å‰æ„å»ºå¥½çš„root\n    }\n\n    return buildTree(list) // æ„å»ºçš„å…¥å£\n}\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201281926","body":"```ts\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction verticalTraversal(root: TreeNode | null): number[][] {\n    const nodes = []\n    dfs(root, 0, 0, nodes)\n    nodes.sort((tuple1, tuple2) => {\n        if (tuple1[0] !== tuple2[0]) {\n            return tuple1[0] - tuple2[0]\n        } else if (tuple1[1] !== tuple2[1]) {\n            return tuple1[1] - tuple2[1]\n        } else {\n            return tuple1[2] - tuple2[2]\n        }\n    })\n\n    const ans = []\n    let lastcol = -Number.MAX_VALUE\n    for (const tuple of nodes) {\n        let col = tuple[0],\n            row = tuple[1],\n            value = tuple[2]\n        if (col !== lastcol) {\n            lastcol = col\n            ans.push([])\n        }\n        ans[ans.length - 1].push(value)\n    }\n    return ans\n}\n\nfunction dfs(node: TreeNode, row: number, col: number, nodes: any[]) {\n    if (node === null) {\n        return\n    }\n    nodes.push([col, row, node.val])\n    dfs(node.left, row + 1, col - 1, nodes)\n    dfs(node.right, row + 1, col + 1, nodes)\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201872234","body":"```ts\nfunction twoSum(nums: number[], target: number): number[] {\n    let map = new Map()\n\n    for (let i = 0; i <= nums.length; i++ ) {\n        if (map.has(target - nums[i])) {\n            return [map.get(target - nums[i]), i]\n        } else {\n            map.set(nums[i], i)\n        }\n    }\n\n    return []\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1204077842","body":"```ts\nfunction topKFrequent(nums: number[], k: number): number[] {\n    let length: number = nums.length\n    if (k >= length) {\n        return nums\n    }\n    let numsMap = new Map()\n    for (let i = 0; i < length; i++) {\n        const n: number | undefined = numsMap.get(nums[i])\n        numsMap.set(nums[i], typeof n === 'number' ? n + 1 : 1)\n    }\n    return Array.from(numsMap)\n        .sort((a: [number, number], b: [number, number]) => b[1] - a[1])\n        .slice(0, k)\n        .map((item) => item[0])\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205407038","body":"```ts\n    function numberOfBoomerangs(points: number[][]): number {\n        let num = 0\n\n        for (let i = 0; i < points.length; i++) {\n            const map = new Map()\n\n            for (let j = 0; j < points.length; j++) {\n                if (i === j) {\n                    continue\n                }\n                const distance = getDistance(points[i], points[j])\n\n                if (map.has(distance)) {\n                    map.set(distance, map.get(distance) + 1)\n                } else {\n                    map.set(distance, 1)\n                }\n            }\n\n            map.forEach((count, distance) => {\n                return (num += count * (count - 1))\n            })\n        }\n\n        return num\n    }\n\n    /**\n     * æŒ‰ç…§é¢˜æ„å°±æ˜¯ æ ¹å·â€œåæ ‡1çš„å¹³æ–¹ + åæ ‡2çš„å¹³æ–¹â€ å°±æ˜¯è·ç¦», åˆ¤æ–­è·ç¦»ç›¸ç­‰å³å¯\n     * @param x åæ ‡1\n     * @param y åæ ‡2\n     * @returns\n     */\n    function getDistance(x: number[], y: number[]) {\n        const distance1 = y[0] - x[0]\n        const distance2 = y[1] - x[1]\n\n        return Math.pow(distance1, 2) + Math.pow(distance2, 2)\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205907691","body":"ç»å…¸çš„æ»‘åŠ¨çª—å£è§£æ³•\n```ts\n/**\n * @author liuyuan\n * @date 2022-07-10 18:13\n * @since 1.0.0\n */\nfunction lengthOfLongestSubstring(s: string): number {\n    // å·¦æŒ‡é’ˆ\n    let left = 0\n\n    // æœ€å¤§æŒ‡é’ˆçš„é•¿åº¦\n    let maxLen = 0\n\n    // å®šä¹‰ä¸€ä¸ª map æ¥å­˜å‚¨å·²ç»å‡ºç°è¿‡çš„å­—ç¬¦ä¸²\n    const map = new Map()\n\n    // å³æŒ‡é’ˆéœ€è¦ä¸æ–­çš„ç§»åŠ¨ï¼Œéœ€è¦ä¸æ–­çš„æ”¹å˜\n    for (let right = 0; right < s.length; right++) {\n        // å¦‚æœæ˜¯é‡åˆ°äº†é‡å¤å­—ç¬¦ä¸²ï¼Œéœ€è¦æŠŠå·¦æŒ‡é’ˆå¾€å³è¾¹ç§»åŠ¨ä¸€ä½, ä¸”å·¦æŒ‡é’ˆçš„ä¸‹æ ‡éœ€è¦åœ¨æ»‘åŠ¨çª—å£å†…\n        if (map.has(s[right]) && map.get(s[right]) >= left) {\n            left = map.get(s[right]) + 1\n        }\n\n        // æ»‘åŠ¨çª—å£, çºªå½•æ¯ä¸ªæŒ‡é’ˆçš„æœ€å¤§å€¼\n        maxLen = Math.max(maxLen, right - left + 1)\n\n        // å­˜å‚¨å­—ç¬¦ä¸²å’Œä»–çš„ä¸‹æ ‡\n        map.set(s[right], right)\n    }\n\n    return maxLen\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207219068","body":"```js\n\n/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nvar findSubstring = function(s, words) {\n    const res = [];\n    const m = words.length, n = words[0].length, ls = s.length;\n    for (let i = 0; i < n; i++) {\n        if (i + m * n > ls) {\n            break;\n        }\n        const differ = new Map();\n        for (let j = 0; j < m; j++) {\n            const word = s.substring(i + j * n, i + (j + 1) * n);\n            differ.set(word, (differ.get(word) || 0) + 1);\n        }\n        for (const word of words) {\n            differ.set(word, (differ.get(word) || 0) - 1);\n            if (differ.get(word) === 0) {\n                differ.delete(word);\n            }\n        }\n        for (let start = i; start < ls - m * n + 1; start += n) {\n            if (start !== i) {\n                let word = s.substring(start + (m - 1) * n, start + m * n);\n                differ.set(word, (differ.get(word) || 0) + 1);\n                if (differ.get(word) === 0) {\n                    differ.delete(word);\n                }\n                word = s.substring(start - n, start);\n                differ.set(word, (differ.get(word) || 0) - 1);\n                if (differ.get(word) === 0) {\n                    differ.delete(word);\n                }\n            }\n            if (differ.size === 0) {\n                res.push(start);\n            }\n        }\n    }\n    return res;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207327712","body":"```js\n\nvar floorMod = function (a, b) {\n  return ((a % b) + b) % b;\n};\nclass Solution {\n  solve(nums, k) {\n    var map = new Map();\n    map.set(0, -1);\n    var res = nums.length;\n    var target = 0;\n    var currSum = 0;\n    for (let i = 0; i < nums.length; i++) {\n      target += nums[i];\n    }\n    target = target % k;\n    for (let i = 0; i < nums.length; i++) {\n      currSum = (nums[i] + currSum) % k;\n      map.set(currSum, i);\n      var prevSum = floorMod(currSum - target, k);\n      if (map.has(prevSum)) {\n        res = Math.min(res, i - map.get(prevSum));\n      }\n    }\n    return res === nums.length ? -1 : res;\n  }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208199806","body":"```ts\n/**\n * @author liuyuan\n * @date 2022-08-08 22:22\n * @since 1.0.0\n */\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * æ²¡å•¥å¥½è¯´çš„ï¼Œç›´æ¥å¿«æ…¢æŒ‡é’ˆè§£å†³é—®é¢˜\n * @param head \n * @returns \n */\nfunction middleNode(head: ListNode | null): ListNode | null {\n    let slow = head\n    let fast = head\n\n    while (fast && fast.next) {\n        fast = fast.next.next\n        slow = slow!.next\n    }\n\n    return slow\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209026398","body":"```ts\n/**\n * @author liuyuan\n * @date 2022-08-09 15:29\n * @since 1.0.0\n */\n\n/**\n * å¯ä»¥é‡‡ç”¨åŒæŒ‡é’ˆè§£æ³•ã€‚åœ¨ç¡®è®¤å·²ç»æ’åºçš„æƒ…å†µä¸‹ï¼Œå¿«æŒ‡é’ˆè¿›è¡Œå†™æ“ä½œï¼Œæ…¢æŒ‡é’ˆè¿›è¡Œè¯»å–å€¼æ“ä½œã€‚\n * ç­‰åˆ°å¿«æŒ‡é’ˆéå†å®Œçš„æ—¶å€™ï¼Œæ…¢æŒ‡é’ˆåˆšå¥½å­˜å‚¨å®Œæ‰€æœ‰çš„ä¸é‡å¤çš„å€¼ï¼Œç„¶åè¿”å›æ…¢æŒ‡é’ˆä¸‹æ ‡ + 1 å°±æ˜¯ä¸å«é‡å¤çš„å€¼çš„é•¿åº¦äº†\n * @param nums\n * @returns\n */\nfunction removeDuplicates(nums: number[]): number {\n    if (!nums.length) {\n        return 0\n    }\n\n    let slow = 0\n    let fast = 0\n\n    while (fast < nums.length) {\n        if (nums[fast] !== nums[slow]) {\n            slow++\n            nums[slow] = nums[fast]\n        }\n\n        fast++\n    }\n\n    // å› ä¸ºæ˜¯ä» 0 å¼€å§‹çš„\n    return slow + 1\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/42#issuecomment-1210031165","body":"```ts\n// ä¸ 278 é—®é¢˜ä¸€è‡´, åªéœ€è¦æ‰¾å‡ºä¸Šä¸ªç‰ˆæœ¬é”™è¯¯çš„ä½ç½®, ä½¿ç”¨äºŒåˆ†æ³•è·å– left\nfunction searchInsert(nums: number[], target: number): number {\n    let left = 0\n    let right = nums.length - 1\n\n    while (left <= right) {\n        let mid = Math.floor((right - left) / 2) + left\n\n        if (nums[mid] === target) {\n            return mid\n        } else if (nums[mid] < target) {\n            left = mid + 1\n        } else if (nums[mid] > target) {\n            right = mid - 1\n        }\n    }\n\n    return left\n}\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"naomiwufzz":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185615532","body":"### **æ€è·¯ï¼šåŠ æ³•é—®é¢˜**\n\nå€’ç€è¿‡ä¸€énumï¼Œå’Œké€ä½ç›¸åŠ ã€‚\n\n1. kçš„ä½æ•°ï¼šç”¨å–modå’Œåœ°æ¿é™¤å¯ä»¥ç›´æ¥æŠŠkç”¨æ‰çš„ä½ç½®æ‰”æ‰ï¼ŒåŒæ—¶å¦‚æœè¦è¿›ä½ï¼Œç›´æ¥è¿›ä½åˆ°kä¸Šå³å¯ã€‚æ˜¯ä¸€ç§æ¯”è¾ƒä¾¿æ·çš„æ–¹å¼ã€‚\n2. ä¸€å¼€å§‹æƒ³ç”¨å…ˆåˆå§‹åŒ–né•¿åº¦çš„listå­˜å‚¨ç»“æœï¼Œä½†æ˜¯å…¶å®listé•¿åº¦å¾ˆéš¾å®šï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥ç”¨reverseï¼Œreverseå¤æ‚åº¦æ˜¯O(n)\n3. æ³¨æ„ä¼šæœ‰ké•¿åº¦æ¯”numå¤§çš„æƒ…å†µçš„ï¼å¹¶ä¸éƒ½æ˜¯ké•¿åº¦å°äºnï¼Œæ‰€ä»¥è¦è€ƒè™‘éå†å®Œè¿˜æœ‰kæˆ–è€…carryçš„æƒ…å†µ\n    \n\n### **ä»£ç **\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = 0\n        res = []\n        for i in range(len(num)-1, -1, -1):\n            cur_n = num[i]\n            cur_add = k % 10\n            add_n = cur_n + cur_add + carry\n            res.append(add_n % 10)\n            carry = add_n // 10\n            k //= 10\n        while k or carry:\n            cur_add = k % 10\n            add_n = cur_add + carry\n            res.append(add_n % 10)\n            carry = add_n // 10\n            k //= 10\n        res.reverse()\n        return res\n\n```\n\n### **å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(min(n,k)) reverseå¤æ‚åº¦æ˜¯O(n) æ‰€ä»¥æ˜¯né•¿åº¦å’Œké•¿åº¦æœ€å°å€¼\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1) æ²¡æœ‰é¢å¤–ç©ºé—´","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186173638","body":"## **æ€è·¯: æ­£ååŒæŒ‡é’ˆ**\n\næ­£å‘å’Œè´Ÿå‘å„è®¡ç®—ä¸€æ¬¡ï¼Œæ¯æ¬¡ä¸€ä¸ªæŒ‡é’ˆæ‰¾cä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘å°šæœªè®¡ç®—çš„å…ƒç´ \n\n### **ä»£ç **\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res = [len(s)] * len(s)\n        i = 0\n        for j in range(len(s)): # jæ˜¯å³æŒ‡é’ˆï¼Œå³æŒ‡é’ˆç¢°åˆ°cçš„è¯ï¼Œå°±å¼€å§‹è®¡ç®—å·¦æŒ‡é’ˆ\n            if s[j] == c:\n                while i <= j:\n                    res[i] = min(res[i], j-i)\n                    i += 1\n        i = len(s) - 1\n        for j in range(len(s)-1, -1, -1):\n            if s[j] == c:\n                while i >= j:\n                    res[i] = min(res[i], i-j)\n                    i -= 1\n        return res\n```\n\n### **å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(2n) næ˜¯sé•¿åº¦\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186525310","body":"## **æ€è·¯2ï¼šå‰ç¼€å’Œæ€æƒ³**\n\nç”¨ä¸€ä¸ªincrementalsæ•°ç»„æ¥è®°å½•åŠ çš„æ•°å­—æœ€è¿œåŠ åˆ°å“ªé‡Œã€‚åœ¨popå‡ºå»çš„æ—¶å€™åªè¦å¯¹åº”æ‰¾è¯¥ä½ç½®åŠ äº†å¤šå°‘å³å¯ï¼Œä¸éœ€è¦å…¨éƒ¨éƒ½è®°å½•\n\n### **ä»£ç **\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.st = []\n        self.cnt = 0\n        self.size = maxSize\n        self.increments = [0] * maxSize\n\n    def push(self, x: int) -> None:\n        if self.cnt < self.size:\n            self.st.append(x)\n            self.cnt += 1\n        \n    def pop(self) -> int:\n        if self.cnt == 0:\n            return -1\n        # å¦‚æœåªå‰©ä¸€ä¸ªå…ƒç´ ï¼Œç›´æ¥æ˜¯popå‡ºå»\n        # å¦‚æœå¤šäºä¸€ä¸ªå…ƒç´ ï¼Œpopå‡ºå»çš„åŒæ—¶ï¼Œæ›´å‰é¢çš„å…ƒç´ è¦ç»§æ‰¿ä¸€ä¸‹åŠ çš„val\n        if self.cnt >= 2:\n            self.increments[self.cnt-2] += self.increments[self.cnt-1]\n        res = self.st.pop() + self.increments[self.cnt-1]\n        self.increments[self.cnt-1] = 0\n        self.cnt -= 1\n        return res\n\n    def increment(self, k: int, val: int) -> None:\n        # åˆ†ç•Œçº¿çš„åœ°æ–¹+valï¼Œåªåœ¨popçš„æ—¶å€™æ‰è€ƒè™‘åŠ å¤šå°‘\n        if self.cnt:\n            self.increments[min(k, self.cnt)-1] += val\n        \n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n### **å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(1)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(maxsize/n)  æŠŠnå½“ä½œæ“ä½œæ•°çš„è¯ï¼Œå¹³å‡æ¥çœ‹æ˜¯maxsize/n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187596495","body":"### **æ€è·¯**\n\nä¸æ˜¯']'å°±å…¨éƒ¨å…¥æ ˆï¼Œç¢°åˆ°']'å¼€å§‹è§£ç ï¼Œè§£ç å°±æ˜¯ä¸€ä¸ªä¸ªæ‹†å‡ºæ¥ï¼Œç¢°åˆ°'['åœæ­¢æ‹†å­—ç¬¦ä¸²ï¼Œç¢°åˆ°æ•°å­—å°±å¦å¤–ç®—è¦é‡å¤çš„æ•°å­—æ˜¯å¤šå°‘ã€‚è¿™é‡Œæœ‰ä¸¤ä¸ªåœ°æ–¹å®¹æ˜“é”™ï¼Œä¸€ä¸ªæ˜¯æ•°å­—æœªå¿…æ˜¯ä¸ªä½æ•°ï¼Œä¸€ä¸ªæ˜¯å‡ºæ ˆä¹‹åçš„strä¸è¦ç›´æ¥æ‹¼åˆ°ç»“æœä¸Šï¼Œç»§ç»­å…¥æ ˆï¼ˆä¸ç„¶è¿™æ ·çš„caseæ— æ³•é€šè¿‡\"3[a2[c]]\"ï¼‰ï¼Œæœ€åæŠŠæ ˆå½“ä½œç»“æœjoinä¸€ä¸‹å³å¯ã€‚\n\n### **ä»£ç **\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for i, char in enumerate(s):\n            if char != ']':\n                stack.append(char)\n            elif char == ']':\n                repeat_s = ''\n                while stack and stack[-1] != '[':\n                    repeat_s = stack.pop() + repeat_s\n                stack.pop() # pop æ‰'['\n                cnt = ''\n                while stack and stack[-1].isdigit(): # å¯èƒ½æœ‰å¤šä¸ªæ•°å­—\n                    cnt = stack.pop() + cnt\n                repeat_s = repeat_s * int(cnt)\n                stack.append(repeat_s) # è¿™é‡Œæ˜¯ä¸€ä¸ªè¦ç‚¹ï¼Œé‡å¤çš„å­—ç¬¦ä¸²ç›´æ¥å‹å›æ ˆé‡Œ\n        return ''.join(stack)\n```\n\n### **å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n) éå†\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n) ç”¨äº†è¾…åŠ©ç«™","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189002648","body":"æ€è·¯\nç›¸å½“äºä¸¤ä¸ªæ ˆå®¹å™¨ï¼Œäº’ç›¸å€’æ¥å€’å»ã€‚\nä»£ç \nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if self.stack2:\n            return self.stack2.pop()\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if self.stack2:\n            return self.stack2[-1]\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return len(self.stack1) + len(self.stack2) == 0\n\nå¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦ï¼šO(n) æœ€åO(n)ï¼Œæœ€å¥½O(1)\nç©ºé—´å¤æ‚åº¦ï¼šO(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190237191","body":"### **æ€è·¯1ï¼šå•è°ƒæ ˆ**\n\nä¸€å¼€å§‹çš„åšæ³•æ˜¯**æ‰¾å•è°ƒé€’å¢çš„åœ°æ–¹ï¼Œåœ¨æ¯ä¸ªå•è°ƒé€’å¢çš„åœ°æ–¹åˆ‡å—ï¼Œæ˜¯ä¸å¯¹çš„ã€‚**ä¹Ÿå°±æ˜¯æ‰«ææ•°ç»„ï¼Œè®°å½•ä¸‹ä¸€ä¸ªå¤§äºæ•°içš„æ•°ï¼Œå¦‚æœæ˜¯å•è°ƒé€’å¢çš„ï¼Œä¸‹ä¸€ä¸ªæ¯”æ•°iå¤§çš„æ•°å°±æ˜¯1ï¼Œè®°å½•é€’å¢çš„æ•°é‡ï¼ˆæ¯æ¬¡åŠ 1ï¼‰ï¼Œé€’å¢æ•°é‡å’Œå°±æ˜¯ç»“æœï¼Œä½†æ˜¯`[4,2,2,1,1]`è¿‡ä¸äº†ï¼æ‰€ä»¥é¢˜ç›®è¿˜æœ‰ä¸€å±‚æ„æ€å°±æ˜¯**æ¯ä¸€ä¸ªå—è¦æ¯”å‰ä¸€ä¸ªå—å¤§**ï¼Œæ¯ä¸ªå—çš„æœ€å°è¦æ¯”å‰ä¸€ä¸ªå—çš„æœ€å¤§è¦å¤§ã€‚\n\nsukkiçš„å›¾å¾ˆæ¸…æ¥šï¼š\n\n[https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/solution/768-zui-duo-neng-wan-cheng-pai-xu-de-kuai-iihua-do/](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/solution/768-zui-duo-neng-wan-cheng-pai-xu-de-kuai-iihua-do/)\n\n### **ä»£ç **\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = [] # ç”¨å•è°ƒæ ˆå­˜å‚¨ä¸€ä¸ªå—çš„æœ€å¤§å€¼ï¼Œå•è°ƒæ ˆæ˜¯é€’å¢çš„\n        for i, n in enumerate(arr):\n            if stack and n < stack[-1]: # ç¢°åˆ°æ›´å°çš„å€¼ï¼Œå°±å¾—æŠŠå‰é¢çš„ä¸€ä¸ªä¸ªæ‹¿å‡ºæ¥ï¼ŒçŸ¥é“å½¢æˆæ–°çš„å—èƒ½å¤Ÿåˆå¹¶æ‰è¿™ä¸ªæœ€å°å€¼\n                cur_val = stack[-1]\n                while stack and n < stack[-1]:\n                    stack.pop()\n                stack.append(cur_val)\n            else: # ç¢°åˆ°æ›´å¤§çš„å€¼ï¼Œå¯ä»¥æ— è„‘ä½œä¸ºä¸€ä¸ªæ–°çš„å—\n                stack.append(n)\n        return len(stack)\n```\n\n### **å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190998189","body":"### **æ€è·¯**\n\nå…ˆè®¡ç®—é“¾è¡¨çš„é•¿åº¦ï¼Œè®°ä¸ºcntï¼Œkå¯¹é“¾è¡¨é•¿åº¦å–ä½™æ˜¯è¦æ—‹è½¬çš„æ¬¡æ•°ï¼Œæ—‹è½¬å‡ æ¬¡ï¼Œå°±æ˜¯å€’æ•°ç¬¬å‡ ä¸ªé“¾è¡¨æ‹†å‡ºæ¥ä½œä¸ºå¤´ï¼Œç›¸å½“äºæ‰¾åˆ°è¦æ—‹è½¬æ–­å¼€çš„åœ°æ–¹ï¼Œæ‹†æˆä¸¤ä¸ªé“¾è¡¨ï¼ŒæŠŠåé¢çš„é“¾è¡¨æ‹¼åˆ°å‰é¢çš„é“¾è¡¨ä¸Šï¼Œåé¢é“¾è¡¨æŒ‡å‘å¤´ï¼Œå‰é¢é“¾è¡¨æŒ‡å‘None\n\n### **ä»£ç **\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if not head:\n            return\n        cnt = 0\n        cur = head\n        while cur:\n            cur = cur.next\n            cnt += 1\n        k = k % cnt\n        cur = head\n        cut = 0\n        res = None\n        while cur.next: # curä¼šåœåœ¨æœ€åä¸€ä¸ªnode\n            cut += 1\n            if cut == cnt - k: # ç¢°åˆ°è¦åˆ‡æ–­çš„nodeï¼Œå°±æ˜¯cur.next\n                tmp = cur.next\n                cur.next = None\n                cur = tmp\n                res = cur\n            else:\n                cur = cur.next\n        if res:\n            cur.next = head\n        return res if res else head\n```\n\n### **å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192127172","body":"### **æ€è·¯ï¼šåŒæŒ‡é’ˆ**\n\nåŠ ä¸€ä¸ªdummyå¤´ï¼Œéœ€è¦ä¸¤ä¸ªæŒ‡é’ˆä½œä¸ºprevå’Œcurï¼Œä¸ºä»€ä¹ˆéœ€è¦ä¸€ä¸ªdummyå‘¢ï¼Ÿè¿™æ ·å¯ä»¥å®¹æ˜“æ‰¾å¤´èŠ‚ç‚¹ï¼Œå› ä¸ºæœ€åè¿”å›è‚¯å®šæ˜¯è¦å¤´èŠ‚ç‚¹çš„ã€‚\n\n\n### **ä»£ç **\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        dummy = ListNode()\n        dummy.next = head\n        pre, cur = dummy, head\n        while cur and cur.next:\n            next_pre = cur\n            next_cur = cur.next.next\n            switch_node = cur.next\n            pre.next = switch_node\n            switch_node.next = cur\n            cur.next = next_cur\n            cur = next_cur\n            pre = next_pre\n        return dummy.next\n\n```\n\n### **å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193146754","body":"æ€è·¯ï¼šé€’å½’+åŒæŒ‡é’ˆ\r\næŠŠé“¾è¡¨æƒ³è±¡æˆä¸€ä¸ªç»³å­ï¼Œæ¯æ¬¡æ“ä½œæ˜¯ä»ä¸­é—´æŠŠç»³å­æ‹èµ·æ¥ã€‚ç”¨é€’å½’çš„æ–¹å¼æŠŠé—®é¢˜ç¼©å°ï¼Œæ¯æ¬¡æ‰¾åˆ°ä¸­é—´çš„èŠ‚ç‚¹ä½œä¸ºrootï¼Œå·¦è¾¹æ¥é“¾è¡¨çš„å‰åŠéƒ¨åˆ†sortåçš„äºŒå‰æœç´¢æ ‘ï¼Œåé¢æ¥é“¾è¡¨ååŠéƒ¨åˆ†sortåçš„äºŒå‰æœç´¢æ ‘ã€‚å…¶ä¸­ä¸­é—´èŠ‚ç‚¹ç”¨å¿«æ…¢æŒ‡é’ˆæ‰¾åˆ°ã€‚\r\nè¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœåªæœ‰ä¸€ä¸ªèŠ‚ç‚¹çš„è¯ï¼Œä¹Ÿè¦é€€å‡ºé€’å½’çš„ï¼Œå› ä¸ºè¿™æ ·leftå’Œlistnodeä¼šä¸€ç›´æ˜¯ä¸€æ ·çš„ï¼Œå°±å‡ºä¸æ¥\r\n\r\n```\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        def balanced_tree(listnode):\r\n            if not listnode:\r\n                return None\r\n            # å¦‚æœèŠ‚ç‚¹åªæœ‰ä¸€ä¸ªçš„è¯ï¼Œleftå°±ä¸€ç›´æ˜¯listnodeï¼Œé€€å‡ºä¸äº†é€’å½’\r\n            if not listnode.next:\r\n                return TreeNode(listnode.val)\r\n            # æ‰¾ä¸­ç‚¹\r\n            prev = ListNode(-1)\r\n            prev.next = listnode\r\n            slow, fast = listnode, listnode\r\n            while fast and fast.next:\r\n                prev = prev.next\r\n                slow = slow.next\r\n                fast = fast.next.next\r\n            cur_head = TreeNode(slow.val)\r\n            prev.next = None\r\n            left, right = listnode, slow.next\r\n            # # ä¸åŠ è¿™ä¸ªä¼šæœ‰é—®é¢˜\r\n            # if fast == slow:\r\n            #     return cur_head\r\n            cur_head.left, cur_head.right = balanced_tree(left), balanced_tree(right)\r\n\r\n            return cur_head\r\n        return balanced_tree(head)\r\n```\r\nå¤æ‚åº¦åˆ†æ\r\næ—¶é—´å¤æ‚åº¦ï¼šO(nlogn) é€’å½’å¤æ‚åº¦å¯ä»¥ç”»å‡ºé€’å½’æ ˆã€‚æ¯ä¸€å±‚é€’å½’çš„æ“ä½œæ˜¯ï¼Œå¯»æ‰¾é“¾è¡¨ä¸­é—´èŠ‚ç‚¹ï¼Œç¬¬ä¸€æ¬¡æ˜¯nï¼Œç¬¬äºŒæ¬¡æ˜¯ä¸¤å—åˆ†åˆ«æ‰¾ï¼Œæ˜¯n/2+n/2ï¼Œç¬¬ä¸‰æ¬¡æ˜¯4ä¸ªn/4ï¼Œæ¯ä¸€æ¬¡éƒ½æ˜¯nï¼Œä¹Ÿå°±æ˜¯è¯´é€’å½’çš„æ—¶å€™ï¼Œæ¯æ¬¡æ‰¾ä¸­é—´èŠ‚ç‚¹ç”¨æ—¶nï¼Œä¸€å…±æœ‰lognå±‚ï¼Œæ‰€ä»¥æ˜¯n*logn\r\nç©ºé—´å¤æ‚åº¦ï¼šO(logn)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193241518","body":"æ€è·¯1ï¼šå“ˆå¸Œ\næ¯”è¾ƒç›´æ¥ï¼Œéå†aå…¨éƒ¨æ”¾è¿›å“ˆå¸Œè¡¨ï¼Œéå†bå¦‚æœè§åˆ°å·²ç»åœ¨å“ˆå¸Œè¡¨ä¸­çš„åˆ™å°±æ˜¯è¦æ‰¾çš„èŠ‚ç‚¹ï¼Œå¦åˆ™æ²¡æœ‰äº¤ç‚¹\nä»£ç \n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA, headB):\n        a = headA\n        b = headB\n        if not a or not b:\n            return None\n        hash = {}\n        while a:\n            hash[a] = 1\n            a = a.next\n        while b:\n            if b in hash:\n                return b\n            else:\n                b = b.next\n        return None\nå¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦ï¼šO(n)\nç©ºé—´å¤æ‚åº¦ï¼šO(n)\næ€è·¯2ï¼šåŒæŒ‡é’ˆ\nheadaäº¤ç‚¹å‰é¢é•¿åº¦æ˜¯aï¼Œheadbäº¤ç‚¹å‰é¢é•¿åº¦æ˜¯bï¼Œç›¸äº¤çš„éƒ¨åˆ†é•¿åº¦æ˜¯cã€‚é‚£æŒ‡é’ˆ1èµ°å®Œaä¸€æ•´æ®µå†èµ°bï¼ŒæŒ‡é’ˆbèµ°å®Œbä¸€æ•´æ®µå†èµ°aï¼Œä¸€å®šèµ°çš„é•¿åº¦ä¸€æ ·ã€‚å¦‚æœä¸¤è€…ä¸ç›¸äº¤ï¼Œåœ¨èµ°å®Œa+b+cä¹‹åä¹Ÿä¼šåœ¨Noneå¤„ç›¸ç­‰ï¼Œæ‰€ä»¥å¾ªç¯çš„å‡ºå£æ˜¯æŒ‡é’ˆ1dçš„å€¼==æŒ‡é’ˆ2çš„å€¼\nä»£ç \n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA, headB):\n        a = headA\n        b = headB\n        while a != b:\n            if not a:\n                a = headB\n            else: \n                a = a.next\n            if not b:\n                b = headA\n            else:\n                b = b.next\n        return a\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        l1 = headA\n        l2 = headB\n        while l1 or l2:\n            if l1 == l2:\n                return l2\n            if l1:\n                l1 = l1.next\n            else:\n                l1 = headB\n            if l2:\n                l2 = l2.next\n            else:\n                l2 = headA\n\nå¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦ï¼šO(n)\nç©ºé—´å¤æ‚åº¦ï¼šO(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193988728","body":"### **æ€è·¯2ï¼šåŒæŒ‡é’ˆ**\n\nX = Zï¼Œæ‰€ä»¥ç¬¬ä¸€æ¬¡å¿«æŒ‡é’ˆ2æ­¥æ…¢æŒ‡é’ˆä¸€æ­¥ç›¸é‡ä¹‹åï¼ŒæŠŠå¿«æŒ‡é’ˆæ”¾åˆ°å¤´èŠ‚ç‚¹ï¼Œå¿«æ…¢æŒ‡é’ˆéƒ½èµ°ä¸€æ­¥å†ç›¸é‡çš„åœ°æ–¹å°±æ˜¯å…¥å£\n\n\nä¸¤ä¸ªæŒ‡é’ˆä¸€å¿«ä¸€æ…¢ã€‚å¿«æŒ‡é’ˆæ¯æ¬¡èµ°ä¸¤æ­¥ï¼Œæ…¢æŒ‡é’ˆæ¯æ¬¡èµ°ä¸€æ­¥ï¼Œå¦‚æœæœ‰ç¯ï¼Œå¿«æŒ‡é’ˆå…ˆè¿›å…¥ç¯ï¼Œæ…¢æŒ‡é’ˆå†è¿›å…¥ã€‚å½“æ…¢æŒ‡é’ˆåˆšè¿›å…¥ç¯çš„æ—¶å€™ï¼Œå¿«æŒ‡é’ˆå°±ä»¥æ¯æ¬¡ä¸€æ­¥çš„è·ç¦»æ¥è¿‘xï¼Œä¸¤è€…ä¸€å®šåœ¨ç¯ä¸­ç›¸é‡ï¼Œå‡è®¾æ…¢æŒ‡é’ˆåˆšå…¥ç¯çš„æ—¶å€™ï¼Œå¿«æŒ‡é’ˆè·ç¦»ç¯å…¥å£nä¸ªè·ç¦»ï¼Œé‚£æ…¢æŒ‡é’ˆå†èµ°nä¸ªè·ç¦»çš„æ—¶å€™å¿«æŒ‡é’ˆå°±èƒ½è¿½ä¸Šäº†ï¼Œè¿™æ˜¯**äºŒè€…ç¬¬ä¸€æ¬¡ç›¸é‡ã€‚ä½†ä¸èƒ½ä¿è¯åœ¨ç¯å…¥å£ç›¸é‡ã€‚**\n\nå¦‚å›¾å‡è®¾ï¼ŒäºŒè€…æ²¡æœ‰ç¯çš„åœ°æ–¹æ˜¯xï¼Œç›¸é‡çš„åœ°æ–¹ç¦»ç¯å…¥å£yè·ç¦»ï¼ˆå…¶å®å°±æ˜¯ä¸Šé¢çš„nï¼‰ï¼Œå‰©ä¸‹çš„ç¯é•¿åº¦æ˜¯zï¼Œé‚£ä¹ˆæœ‰ï¼š\n\nå¿«æŒ‡é’ˆèµ°çš„è·¯ç¨‹æ˜¯ x+k(y+z)+y\n\næ…¢æŒ‡é’ˆèµ°çš„è·¯ç¨‹æ˜¯ x+j(y+z)+y\n\nç”±äºå¿«æŒ‡é’ˆèµ°çš„è·¯ç¨‹æ˜¯æ…¢æŒ‡é’ˆçš„äºŒå€ï¼Œå¯ä»¥å»ºç«‹ç­‰å¼ \n\n$2(x+k(y+z)+y) =  x+j(y+z)+y$Â \n\nå¯å¾—ï¼š\n\n$x+y =  (j-k)(y+z)$ \n\nç”±äºç°åœ¨æ˜¯è¦æ‰¾xï¼Œæ•´ç†x\n\n$x =  (j-k)(y+z) -y = (j-k-1)(y+z)+z$ \n\nå…¶å®å°±æ˜¯**è½¬æ•´æ•°åœˆçš„ç¯+zï¼Œæ‰€ä»¥x = z**\n\né‚£è¿™ä¸ªç»“è®ºæœ‰ä»€ä¹ˆç”¨å‘¢ï¼Ÿæˆ‘ä»¬æ¯•ç«Ÿè¿˜ä¸çŸ¥é“zæ˜¯å¤šå°‘ã€‚ç›®å‰æˆ‘ä»¬æœ‰ä¸¤ä¸ªæŒ‡é’ˆå·²ç»åœ¨yå’Œzäº¤æ±‡å¤„ç›¸é‡ï¼Œå…¶å®å¯ä»¥æŠŠå¿«æŒ‡é’ˆï¼ˆå†ç”¨ä¸€ä¸ªæ–°æŒ‡é’ˆä¹Ÿå®Œå…¨å¯ä»¥ï¼‰æ”¾åˆ°headçš„åœ°æ–¹æ¯æ¬¡èµ°ä¸€ä¸ªä½ç½®ï¼Œé‚£å„éƒ½èµ°zé•¿åº¦ï¼Œäº¤æ±‡ç‚¹ä¸€å®šå°±æ˜¯ç¯å…¥å£\n\n### **ä»£ç **\n\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        fast, slow = head, head\n        x = None\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                x = fast\n                break\n        if not x:\n            return None\n        fast = head\n        while fast != slow:\n            fast = fast.next\n            slow = slow.next\n        return fast\n```\n\n### **å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195597201","body":"### **æ€è·¯ï¼šåŒå‘é“¾è¡¨+å“ˆå¸Œ**\n\n\nç”±äºè¦æ±‚çš„æ˜¯O1çš„å¤æ‚åº¦ï¼Œè¦æ±‚åˆ é™¤ã€æ·»åŠ ã€æ¢ä½ç½®éƒ½æ˜¯O1èƒ½å¤Ÿç”¨çš„æ˜¯é“¾è¡¨å’Œå“ˆå¸Œï¼Œè¿™é¢˜çš„å…³é”®å°±è¯´ç”¨**åŒå‘é“¾è¡¨+å“ˆå¸Œï¼ŒåŒå‘é“¾è¡¨å­˜å‚¨èŠ‚ç‚¹çš„é¡ºåºï¼Œå“ˆå¸Œå­˜å‚¨keyå¯¹åº”çš„node**ã€‚è¿™é‡Œè¦æ³¨æ„çš„æ˜¯ï¼š\n\nï¼ˆ1ï¼‰åŒå‘é“¾è¡¨ç”¨**ä¸¤ä¸ªå“¨å…µåšå¤´å°¾**ä¼šæ¯”è¾ƒæ–¹ä¾¿è¾¹ç•Œè®¡ç®—ï¼Œç”¨ä¸€ä¸ªdummyå¤´å’Œä¸€ä¸ªcurnodeæŒ‡é’ˆä¹Ÿå¯ä»¥ï¼Œä½†æ˜¯è¦æ¯æ¬¡æ”¹curnodeçš„ä½ç½®ï¼Œå®¹æ˜“é”™\n\nï¼ˆ2ï¼‰putå’Œgetå€¼çš„æ—¶å€™è™½ç„¶ä¸æŠŠnodeå–å‡ºï¼Œä½†æ˜¯éƒ½ç®—è®¿é—®äº†nodeï¼Œéœ€è¦æŠŠnodeæ”¾åˆ°æœ€å\n\nï¼ˆ3ï¼‰åŒå‘é“¾è¡¨ç›´æ¥å­˜å‚¨keyå’Œvalï¼Œä¸èƒ½åªå­˜valï¼Œå› ä¸ºkeyå’Œvalå¯èƒ½ä¸ä¸€æ ·\n\n### **ä»£ç **\n\n```python\nclass ListNode:\n    def __init__(self, key=None, val=None):\n        self.prev = None\n        self.next = None\n        self.val = val\n        self.key = key\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        # åˆå§‹åŒ–å“ˆå¸Œè¡¨ {key: ListNode}\n        self.hashmap = dict()\n        # åˆå§‹åŒ–åŒå‘é“¾è¡¨\n        self.head = ListNode()\n        self.tail = ListNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def get(self, key: int) -> int:\n        # å¦‚æœåœ¨hashä¸­ï¼Œè¿”å›è¯¥å€¼ã€‚æ”¾åˆ°åŒå‘é“¾è¡¨æœ€å\n        if key in self.hashmap:\n            self.move_to_tail(key)\n        res = self.hashmap.get(key, -1)\n        return -1 if res == -1 else res.val\n            \n    def move_to_tail(self, key) -> None:\n        node = self.hashmap[key]\n\t\t\t\t# æ‹†å‡º\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\t\t\t\t# æ’å…¥\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev.next = node\n        self.tail.prev = node\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.hashmap:\n            # è‹¥è¯¥keyå·²ç»åœ¨åŒå‘é“¾è¡¨ä¸­ï¼ŒæŠŠè¯¥keyæ”¾åˆ°æœ€åï¼Œå¹¶ä¸”æ”¹å˜å€¼\n            self.hashmap[key].val = value\n            self.move_to_tail(key)\n            return\n        if len(self.hashmap) == self.capacity:\n            # åˆ é™¤å¤´èŠ‚ç‚¹\n            del_node = self.head.next\n            self.head.next = del_node.next\n            del_node.next.prev = self.head\n            self.hashmap.pop(del_node.key)\n\n        new_node = ListNode(key, value)\n        self.hashmap[key] = new_node\n        self.tail.prev.next = new_node\n        new_node.prev = self.tail.prev\n        new_node.next = self.tail\n        self.tail.prev = new_node\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n```\n\n### **å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(1)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196676665","body":"### **æ€è·¯1ï¼šdfs-ååº**\n\næœ¬é¢˜å¯ä»¥ä½¿ç”¨å‰åºï¼ˆä¸­å·¦å³ï¼‰ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ååºéå†ï¼ˆ**å·¦å³ä¸­**ï¼‰ï¼Œä½¿ç”¨å‰åºæ±‚çš„å°±æ˜¯æ·±åº¦ï¼Œä½¿ç”¨ååºæ±‚çš„æ˜¯é«˜åº¦ã€‚\n\næ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œè¾“å…¥æ˜¯èŠ‚ç‚¹ï¼Œè¾“å‡ºæ˜¯å½“å‰rootçš„æœ€å¤§æ·±åº¦ï¼›å®ç°é€»è¾‘æ˜¯å½“å‰èŠ‚ç‚¹çš„æœ€å¤§æ·±åº¦æ˜¯å·¦èŠ‚ç‚¹æœ€å¤§æ·±åº¦å’Œå³èŠ‚ç‚¹æœ€å¤§æ·±åº¦çš„maxï¼›å‡ºå£æ˜¯å½“å‰èŠ‚ç‚¹æ˜¯none\n\n1. ç¡®å®šé€’å½’å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼ï¼šå‚æ•°å°±æ˜¯ä¼ å…¥æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œè¿”å›å°±è¿”å›è¿™æ£µæ ‘çš„æ·±åº¦ï¼Œæ‰€ä»¥è¿”å›å€¼ä¸ºintç±»å‹ã€‚\n2. ç¡®å®šç»ˆæ­¢æ¡ä»¶ï¼šå¦‚æœä¸ºç©ºèŠ‚ç‚¹çš„è¯ï¼Œå°±è¿”å›0ï¼Œè¡¨ç¤ºé«˜åº¦ä¸º0ã€‚\n3. ç¡®å®šå•å±‚é€’å½’çš„é€»è¾‘ï¼šå…ˆæ±‚å®ƒçš„å·¦å­æ ‘çš„æ·±åº¦ï¼Œå†æ±‚çš„å³å­æ ‘çš„æ·±åº¦ï¼Œæœ€åå–å·¦å³æ·±åº¦æœ€å¤§çš„æ•°å€¼ å†+1 ï¼ˆåŠ 1æ˜¯å› ä¸ºç®—ä¸Šå½“å‰ä¸­é—´èŠ‚ç‚¹ï¼‰å°±æ˜¯ç›®å‰èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„æ ‘çš„æ·±åº¦ã€‚\n\n### **ä»£ç **\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        def dfs(node):\n            # ä¼ å…¥èŠ‚ç‚¹ï¼Œè¿”å›é«˜åº¦\n            if not node:\n                return 0\n            # åç»­éå†ï¼Œå…ˆçœ‹å·¦å³é«˜åº¦\n            l = dfs(node.left)\n            r = dfs(node.right)\n            dep = max(l, r)\n            return dep + 1\n        return dfs(root)\n```\n\n### **å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n) æ¯ä¸ªèŠ‚ç‚¹éå†ä¸€æ¬¡\n- ç©ºé—´å¤æ‚åº¦ï¼šO(h) é€’å½’æ ˆçš„æ ˆç©ºé—´æ˜¯æ ‘çš„æ·±åº¦","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197597909","body":"### **æ€è·¯ï¼šå…ˆåºéå†+é€’å½’**\n\nå‰åºåœ°çœ‹æ¯ä¸ªèŠ‚ç‚¹æ˜¯å¦ç›¸ç­‰ï¼Œä¸”è¾“å…¥æ˜¯ä¸¤ä¸ªnode\n\nï¼ˆ1ï¼‰è¾“å…¥è¾“å‡ºï¼šè¾“å…¥æ˜¯ä¸¤ä¸ªæ ‘çš„æ ‘èŠ‚ç‚¹ï¼Œè¾“å‡ºæ˜¯èŠ‚ç‚¹æ˜¯å¦ç›¸ç­‰\n\nï¼ˆ2ï¼‰é€’å½’å‡ºå£ï¼šå¦‚æœæœ‰nodeæ˜¯noneï¼Œè¦ä¹ˆä¸¤ä¸ªæ ‘ç›¸ç­‰çš„æ—¶å€™éƒ½æ˜¯noneï¼Œè¦ä¹ˆä¸€ä¸ªnoneä¸€ä¸ªä¸æ˜¯noneï¼Œå‰è€…æ˜¯trueåè€…æ˜¯false\n\nï¼ˆ3ï¼‰é€’å½’é€»è¾‘ï¼šè¦åˆ¤æ–­æ˜¯å¦ç›¸ç­‰ï¼Œè¦çœ‹å½“å‰èŠ‚ç‚¹ç›¸ç­‰ï¼Œå·¦èŠ‚ç‚¹ç›¸ç­‰ã€å³èŠ‚ç‚¹ç›¸ç­‰\n\n### **ä»£ç **\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        def preorder(p_node, q_node):\n            # å…ˆåºåœ°çœ‹på’Œqæ˜¯å¦ç›¸ç­‰\n            if not p_node and not q_node:\n                return True\n            if not p_node or not q_node:\n                return False\n            cur_same = p_node.val == q_node.val\n            left_same = preorder(p_node.left, q_node.left)\n            right_same = preorder(p_node.right, q_node.right)\n            return cur_same and left_same and right_same\n        return preorder(p, q)\n```\n\n### **å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)æ¯ä¸ªèŠ‚ç‚¹éå†ä¸€æ¬¡\n- ç©ºé—´å¤æ‚åº¦ï¼šO(h)é€’å½’æ ˆå¤§å°æ˜¯æ ‘çš„æ·±åº¦","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199226263","body":"### **æ€è·¯ï¼šdfs**\n\nè®°å½•æ‰€æœ‰çš„è·¯å¾„ï¼Œæœ€åsumèµ·æ¥\n\n### **ä»£ç **\n\n```python\n# Definition for a binary tree node.\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def __init__(self):\n        self.res = 0\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        cur = 0\n        def dfs(root, cur):\n            if not root:\n                return \n            if not root.left and not root.right:\n                self.res += cur * 10 + root.val\n            next_val = cur*10+root.val\n            dfs(root.left, next_val)\n            dfs(root.right, next_val)\n        \n        dfs(root, cur)\n        return self.res\n            \n\n```\n\n### **å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200151888","body":"### **æ€è·¯1ï¼šbfs**\n\nè¿™é¢˜bfsæ¯”è¾ƒæ˜æ˜¾ï¼Œå°±æ˜¯æœ€åä¸€å±‚bfsçš„ç¬¬ä¸€ä¸ªå€¼\n\n### **ä»£ç **\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\nclass Solution:\n    def findBottomLeftValue(self, root: TreeNode) -> int:\n        # bfs\n        queue = deque([root])\n        while queue:\n            res = queue[0].val\n            for _ in range(len(queue)):\n                cur_node = queue.popleft()\n                if cur_node.left:\n                    queue.append(cur_node.left)\n                if cur_node.right:\n                    queue.append(cur_node.right)\n        return res\n```\n\n### **å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n) æ¯ä¸ªèŠ‚ç‚¹éå†ä¸€é\n- ç©ºé—´å¤æ‚åº¦ï¼šO(w) é˜Ÿåˆ—æœ€å¤§æ˜¯æ ‘çš„å®½åº¦","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200372074","body":"### **æ€è·¯ï¼šdfs**\n\nåºåˆ—åŒ–å’Œååºåˆ—åŒ–éƒ½æ˜¯dfsï¼Œè¦æ³¨æ„Noneçš„æ—¶å€™è¦ç»™ä¸€ä¸ªâ€œ#â€ï¼Œä¸ç„¶æ˜¯ä¸å”¯ä¸€çš„\n\n### **ä»£ç **\n\n```python\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\nfrom collections import deque\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root:\n            return \"#\"\n        return str(root.val) + \",\" + self.serialize(root.left) + \",\" + self.serialize(root.right)\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        data = deque(data.split(\",\"))\n        root = self.deserialize_lis(data)\n        return root\n    \n    def deserialize_lis(self, root_lis):\n        if not root_lis:\n            return\n        cur_val = root_lis.popleft()\n        if cur_val == \"#\":\n            return\n        root = TreeNode(cur_val)\n        root.left = self.deserialize_lis(root_lis)\n        root.right = self.deserialize_lis(root_lis)\n        return root\n        \n\n# Your Codec object will be instantiated and called as such:\n# ser = Codec()\n# deser = Codec()\n# ans = deser.deserialize(ser.serialize(root))\n        \n\n# Your Codec object will be instantiated and called as such:\n# ser = Codec()\n# deser = Codec()\n# ans = deser.deserialize(ser.serialize(root))\n```\n\n### **å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201204406","body":"### **æ€è·¯ï¼šdfs+hash**\n\néœ€è¦ä¸€ä¸ªå“ˆå¸Œè¡¨è®°å½•xè½´ï¼ŒåŒæ—¶dfsçš„æ—¶å€™éœ€è¦å¯¹èŠ‚ç‚¹è¿›è¡Œæ ‡è®°ï¼Œä¸»è¦æ˜¯æ ‡å‡ºæ¥åæ ‡ï¼ŒæŠŠåæ ‡å½•å…¥hashå³å¯\n\n### **ä»£ç **\n\n```python\nclass Solution:\n    def __init__(self):\n        self.hash = dict()\n\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        def dfs(node, coordinate):\n            # coordinate æ˜¯å½“å‰nodeçš„åæ ‡\n            if not node:\n                return\n            x, y = coordinate\n            self.hash[x] = self.hash.get(x, [])\n            self.hash[x].append((y, node.val))\n            dfs(node.left, (x - 1, y - 1))\n            dfs(node.right, (x + 1, y - 1))\n\n        dfs(root, (0, 0))\n        for k, v in self.hash.items():\n            v = [value[1] for value in sorted(v, key=lambda x: (x[0], -x[1]), reverse=True)]\n            self.hash[k] = v\n        res = sorted(self.hash.items())\n\n        return [r[1] for r in res]\n```\n\n### **å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202450098","body":"### **æ€è·¯ï¼šå“ˆå¸Œ**\n\næš´åŠ›è‚¯å®šæ˜¯ä¸åˆé€‚çš„ã€‚é‚£ä¹ˆè¦æŠŠO(n^2)é™ä¸‹æ¥ï¼Œå“ˆå¸Œã€å‰ç¼€å’Œã€äºŒåˆ†ã€åŒæŒ‡é’ˆéƒ½æ˜¯é€‰æ‹©ã€‚è¿™é¢˜è·Ÿæ˜¨å¤©çš„x/yä¸ç”¨æš´åŠ›ï¼Œè€Œæ˜¯é€šè¿‡ç¡®å®šçš„yå’Œå·²çŸ¥èŒƒå›´çš„quotientæ¥æ‰¾xå…¶å®æ€è·¯ä¹Ÿæœ‰ç‚¹åƒã€‚ä¸€ä¸ªåŠ æ³•ä¸€ä¸ªé™¤æ³•ï¼ˆå½“ç„¶é™¤æ³•éš¾å¤šäº†ï¼Œä½†æ˜¯è¿™é¢˜å¯ä»¥ä½œä¸ºæ€è·¯æŒ‡å¯¼ï¼‰ã€‚\n\né‚£ä¹ˆå°±æ˜¯å·²çŸ¥targetå’Œå·²çŸ¥ç›®å‰æ‰«è¿‡çš„æ•°ï¼ˆå¯ä»¥å­˜åœ¨hashé‡Œé¢ï¼‰ï¼Œé‚£ä¹ˆä¸ç”¨æ¯ä¸ªæ•°åŠ ä¸€éï¼Œå› ä¸ºæœ‰targetè¿™ä¸ªæ¡ä»¶ï¼Œå¯ä»¥ç”¨target-cur_numï¼Œçœ‹çœ‹å·®å€¼å‰é¢è§è¿‡æ²¡æœ‰ï¼Œè§è¿‡çš„è¯åˆšå¥½å°±ç›´æ¥è¿”å›ã€‚\n\nè¿™é‡Œä¸€ä¸ªé‡è¦çš„æ€è·¯æ˜¯ï¼šç¢°åˆ°ä¸¤ä¸ªæ•°xï¼Œyè®¡ç®—çš„é—®é¢˜ï¼Œå¯ä»¥**é€†å‘æ€ç»´ï¼Œå›ºå®šä¸€ä¸ªxæˆ–è€…y**ï¼Œreså…¶å®ä¸€èˆ¬éƒ½æ˜¯æœ‰é™åˆ¶ï¼Œè¦ä¹ˆç»™ä¸€ä¸ªç›®æ ‡å€¼ï¼Œè¦ä¹ˆç»™ä¸€ä¸ªç›®æ ‡èŒƒå›´ï¼ˆç›®æ ‡å€¼ç®€å•ï¼ŒèŒƒå›´å¯ä»¥å‰ç¼€å’Œï¼‰ï¼Œå›ºå®šä¹‹åï¼Œæ ¹æ®å›ºå®šå€¼å’Œä¸€ä¸ªç›®æ ‡å¯ä»¥çœ‹çœ‹xåœ¨ä¸åœ¨ï¼Œå°±å¯ä»¥é™ä½å¤æ‚åº¦äº†\n\n### **ä»£ç **\n\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        hash = dict()\n        for i, n in enumerate(nums):\n            if target - n in hash:\n                return [i, hash[target-n]]\n            hash[n] = i  # è¦æ”¾åœ¨åé¢æ˜¯å› ä¸ºæ”¾åœ¨å‰é¢å¦‚æœåˆšå¥½è¿™ä¸ªæ•°*2æ˜¯targetå°±é”™äº†\n        return False\n```\n\n### **å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)\n\n### **æ€è·¯ï¼šåŒæŒ‡é’ˆ**\n\nå…ˆæ’åºï¼Œç„¶åæŒ‡é’ˆä¸€å¤´ä¸€å°¾æ‰¾target\n\n### **ä»£ç **\n\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        nums = [(i, n) for i, n in enumerate(nums)]\n        nums = sorted(nums, key=lambda x: x[1])\n        left, right = 0, len(nums) - 1\n        while left < right:\n            if nums[left][1] + nums[right][1] == target:\n                return [nums[left][0], nums[right][0]]\n            elif nums[left][1] + nums[right][1] < target:\n                left += 1\n            elif nums[left][1] + nums[right][1] > target:\n                right -= 1\n```\n\n### **å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(logn) æ’åºçš„å¤æ‚åº¦\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203887809","body":"### **æ€è·¯ï¼šhash+heap**\n\nç”¨å“ˆå¸Œè¡¨è®°å½•é¢‘ç‡ï¼ŒæŠŠé¢‘ç‡å’Œnçš„å…ƒç»„å¯¹æ”¾åˆ°å †ä¸­ã€‚ç”¨å †æŠŠtopk popå‡ºæ¥\n### **ä»£ç **\n\n```python\nimport heapq\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        hash_map = dict()\n        for i, n in enumerate(nums):\n            hash_map[n] = hash_map.get(n, 0) + 1\n        h = []\n        for n, freq in hash_map.items():\n            heapq.heappush(h, (-freq, n))\n        res = []\n        while k:\n            res.append(heapq.heappop(h)[1])\n            k -= 1\n        return res\n```\n\n### **å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(nlogk)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205221039","body":"### **æ€è·¯ï¼šå“ˆå¸Œ**\n\nhashä¸»è¦æ˜¯è®°å½•è·ç¦»æ˜¯å¦æœ‰ä¸€æ ·çš„ï¼Œå¯¹æ¯ä¸ªç‚¹ï¼Œè®¡ç®—è¿™ä¸ªç‚¹åˆ°æ‰€æœ‰ç‚¹çš„è·ç¦»ï¼Œhashè®°å½•è·ç¦»æœ€åç”¨permutationä¸€ç®—\n\n### **ä»£ç **\n\n```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        res = 0\n        for i in range(len(points)):\n            # ç”¨hashè®°å½•è·ç¦»æ˜¯å¦æœ‰é‡å¤\n            hash_map = dict()\n            for j in range(len(points)):\n                # è®¡ç®—æ¬§å¼è·ç¦»\n                dx = points[i][0] - points[j][0]\n                dy = points[i][1] - points[j][1]\n                dis = dx ** 2 + dy ** 2\n                hash_map[dis] = hash_map.get(dis, 0) + 1\n            for val in hash_map.values():\n                # è‡ªå·±åšä¸€ä¸ªpermutationï¼Œvalé‡Œé¢å–ä¸€ä¸ªï¼Œå‰©ä¸‹val-1é‡Œé¢å–ä¸€ä¸ª\n                res += val * (val-1)\n        return res\n```\n\n### **å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n**2)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206470060","body":"### **æ€è·¯ï¼šhashmap + åŒæŒ‡é’ˆ**\n\nç”¨åŒæŒ‡é’ˆç¡®å®šæœ€é•¿å­—ä¸²çš„å·¦å³ä½ç½®ã€‚ç”¨hashè®°å½•æœ€è¿‘è§åˆ°çš„æŸä¸ªå­—ç¬¦ã€‚å¦‚æœå‘ç°å‡ºç°äº†é‡å¤å­—ç¬¦ï¼Œé‚£ä¹ˆåœ¨hashä¸­æ‰¾åˆ°è¿™ä¸ªå­—ç¬¦æœ€è¿‘å‡ºç°çš„åœ°æ–¹ï¼ŒæŠŠå·¦æŒ‡é’ˆç§»åŠ¨è¿‡æ¥\n\n**è¦ç‚¹ï¼š**\n\nhashmap**å­˜å­—ç¬¦å’Œå…¶ä½ç½®**\n\n**åˆ¤æ–­æ˜¯å¦åœ¨å½“å‰çª—å£æ˜¯ç›´æ¥åˆ¤æ–­æ˜¯å¦åœ¨åŒæŒ‡é’ˆå†…ï¼Œä¸æ˜¯åˆ¤æ–­æ˜¯å¦åœ¨hashä¸­**\n\n### **ä»£ç **\n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        \n        hash_map = dict()\n        left, right = 0, 0\n        if len(s) <= 1:\n            return len(s)\n        hash_map[s[left]] = 0\n        max_len = 1\n        while right < len(s):\n            if s[right] in s[left:right]:\n                max_len = max(max_len, right-left) # å½“å‰çš„rightä¸èƒ½ç®—äº†\n                left = hash_map[s[right]] + 1 # å·¦æŒ‡é’ˆç§»åŠ¨åˆ°é‡å¤æ•°å­—åé¢ä½ç½®\n                hash_map[s[right]] = right\n            else:\n                hash_map[s[right]] = right\n                max_len = max(max_len, right-left+1) \n            right += 1\n        return max_len\n```\n\n### **å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208036100","body":"### **æ€è·¯ï¼šå¿«æ…¢æŒ‡é’ˆ**\r\n\r\næ¯æ¬¡å¿«æŒ‡é’ˆèµ°ä¸¤æ­¥ï¼Œæ…¢æŒ‡é’ˆèµ°ä¸€æ­¥ã€‚æœ€åæ…¢æŒ‡é’ˆå°±ç•™åœ¨é“¾è¡¨çš„ä¸­é—´ï¼ˆé¢˜ç›®è¯´äº†å¦‚æœæ˜¯ä¸¤ä¸ªä¸­é—´ä½ç½®è¦åé¢é‚£ä¸ªï¼Œå°±åˆšå¥½ï¼‰\r\n\r\n### **ä»£ç **\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def middleNode(self, head: ListNode) -> ListNode:\r\n        slow, fast = head, head\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n        return slow\r\n```\r\n\r\n### **å¤æ‚åº¦åˆ†æ**\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209277270","body":"### **æ€è·¯ï¼šè¯»å†™æŒ‡é’ˆ**\n\nç”¨è¯»å†™æŒ‡é’ˆï¼Œè¯»æŒ‡é’ˆçœ‹æ˜¯å¦æœ‰æ–°çš„å…ƒç´ ï¼Œå†™æŒ‡é’ˆç”¨æ¥å†™å…¥å…ƒç´ ã€‚ç”±äºæœ€åå†™çš„å…ƒç´ é•¿åº¦ä¸€å®šæ˜¯å°äºç­‰äºåŸå§‹çš„é•¿åº¦çš„ï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥å†™\n\n### **ä»£ç **\n\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        read, write = 0, 0\n        for read in range(len(nums)):\n            if nums[read] == nums[write]:\n                continue\n            else:\n                write += 1\n                nums[write] = nums[read]\n        return write + 1\n                \n        \n            \n```\n\n### **å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuajingliu":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185624746","body":"#### è§£é¢˜æ€è·¯\n  1. ä½ä½åˆ°é«˜ä½é€ä½å°†æ•°å­—åŠ åœ¨ä¸€èµ·\n  2. è‹¥åŠ æ³•çš„ç»“æœå¤§äºç­‰äº 1010ï¼ŒæŠŠè¿›ä½çš„ 11 åŠ å…¥åˆ°ä¸‹ä¸€ä½çš„è®¡ç®—ä¸­\n#### ä»£ç å®ç°\n\n```\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```\n#### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦: O(max(n,logk), å…¶ä¸­ nn ä¸ºæ•°ç»„çš„é•¿åº¦\n- ç©ºé—´å¤æ‚åº¦: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186215661","body":"#### è§£é¢˜æ€è·¯\n- ä»å½“å‰ä¸‹æ ‡å‡ºå‘ï¼Œåˆ†åˆ«å‘å·¦ã€å³ä¸¤ä¸ªæ–¹å‘å»å¯»æ‰¾ç›®æ ‡å­—ç¬¦ Cã€‚\n- å¦‚æœåªåœ¨ä¸€ä¸ªæ–¹å‘æ‰¾åˆ°ï¼Œç›´æ¥è®¡ç®—å­—ç¬¦è·ç¦»ã€‚\n- å¦‚æœä¸¤ä¸ªæ–¹å‘éƒ½æ‰¾åˆ°ï¼Œå–ä¸¤ä¸ªè·ç¦»çš„æœ€å°å€¼\n\n#### ä»£ç å®ç°\n\n```\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  const res = Array(S.length).fill(0);\n\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) continue;\n    // å®šä¹‰ä¸¤ä¸ªæŒ‡é’ˆ l, r åˆ†åˆ«å‘å·¦ã€å³ä¸¤ä¸ªæ–¹å‘å¯»æ‰¾ç›®æ ‡å­—ç¬¦ Cï¼Œå–æœ€çŸ­è·ç¦»\n    let l = i,\n      r = i,\n      shortest = Infinity;\n\n    while (l >= 0) {\n      if (S[l] === C) {\n        shortest = Math.min(shortest, i - l);\n        break;\n      }\n      l--;\n    }\n\n    while (r < S.length) {\n      if (S[r] === C) {\n        shortest = Math.min(shortest, r - i);\n        break;\n      }\n      r++;\n    }\n\n    res[i] = shortest;\n  }\n  return res;\n};\n```\n#### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(N^2)$ï¼ŒN ä¸º S çš„é•¿åº¦ï¼Œä¸¤å±‚å¾ªç¯ã€‚\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186519978","body":"### æ€è·¯\n  ç”¨æ•°ç»„æ¨¡æ‹Ÿæ ˆï¼Œç”¨æ•°ç»„åŸç”Ÿæ–¹æ³•popã€pushæ–¹æ³•å®ç°\n  \n### ä»£ç \n\n```\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.maxSize = maxSize;\n  this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.stack.length >= this.maxSize) {\n    return;\n  }\n  this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  return this.stack.length ? this.stack.pop() : -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  const length = Math.min(k, this.stack.length);\n  for (let i = 0; i < length; i++) {\n    this.stack[i] += val;\n  }\n};\n```\n### å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ \n\n  push: O(1)\n\n  popï¼šO(1)\n  \n  incrementï¼šO(K) \n \n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187022598","body":"### æ€è·¯\n1. å°†å­—ç¬¦ä¸²ä»æœ«å°¾å¼€å§‹éå†\n2. é‡åˆ°â€œ]â€å…¥æ ˆ\n3. æ‹¼æ¥è¦å‡ºæ ˆçš„å­—ç¬¦ä¸²ï¼Œé‡åˆ°\"[\"å‡ºæ ˆ\n4. \"[\"åç´§è·Ÿæ•°æ®ï¼Œç´¯è®¡æœ€ç»ˆçš„æ•°å­—\n5. å°†éå†åå…¥æ ˆçš„å­—ç¬¦ä¸²å‡ºæ ˆï¼Œè¿›è¡Œåè½¬æ‹¼æ¥ï¼Œå¾—åˆ°æœ€ç»ˆç»“æœ\n\n### ä»£ç \n\n```\n/**\n * @param {string} s\n * @return {string}\n */\n var decodeString = function(s) {\n    let stack = []; // å®šä¹‰å­˜å‚¨å­—ç¬¦ä¸²çš„æ ˆ\n    let str = \"\"; // å®šä¹‰æœ€ç»ˆè¿”å›çš„å­—ç¬¦ä¸²\n    let num = \"\"; // å®šä¹‰å­—ç¬¦ä¸²é‡å¤çš„æ¬¡æ•°\n    const length = s.length;\n    for (let i = length - 1; i >= 0; i--) {\n      console.log(\"s[i]\", stack, i);\n      if (s[i] >= \"0\" && s[i] <= \"9\") {\n        // è§£æå‡ºè¿ç»­çš„æ•°å­—\n        while (s[i] >= \"0\" && s[i] <= \"9\") {\n          num += s[i];\n          i--;\n          console.log(\"num\", num);\n        }\n        stack.push(\n          str.repeat(\n            Number(\n              num\n                .split(\"\")\n                .reverse()\n                .join(\"\")\n            )\n          )\n        ); // æ‹¼æ¥å­—ç¬¦\n        str = \"\";\n        num = \"\"; //æ¸…ç©ºè®¡æ•°\n        i++;\n      } else if (s[i] === \"[\") {\n        // é‡åˆ°\"[\"æ—¶ï¼Œå°†åç»­å­—ç¬¦å‡ºæ ˆ\n        let curStr = stack.pop();\n        while (curStr !== \"]\") {\n          str += curStr;\n          curStr = stack.pop(); // æ‹¼æ¥å‡ºæ ˆçš„å­—ç¬¦ä¸² \"[\"åè·Ÿç€çš„ä¸€å®šæ˜¯æ•°å­—\n        }\n      } else {\n        // å°†å­—ç¬¦ æˆ– \"]\"å…¥æ ˆ\n        stack.push(s[i]);\n      }\n    }\n    return stack.reverse().join(\"\");\n  };\n```\n\n### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n),å¾ªç¯éå†ä¸€é\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189096773","body":"### è§£é¢˜æ€è·¯\n    å®šä¹‰ä¸¤ä¸ªæ ˆï¼Œ\n-   ä¸€ä¸ªæ˜¯pushStack, æ‰§è¡Œpushæ“ä½œæ—¶ï¼Œå°†å…ƒç´ å…¥pushStackæ ˆ\n-   å¦ä¸€ä¸ªæ˜¯popStack,æ‰§è¡Œpopæ“ä½œæ—¶ï¼Œåœ¨popStackå–å…ƒç´ ï¼›å½“popStackæ ˆä¸ºç©ºæ—¶ï¼Œä¾æ¬¡å°†pushStackå…ƒç´ popå–å‡ºï¼Œpushè¿›pushStackæ ˆ\n\n\n### ä»£ç å®ç°\n```\nvar MyQueue = function() {\n    this.pushStack = [];\n    this.popStack = [];\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.pushStack.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.popStack.length === 0) {\n        while(this.pushStack.length > 0) {\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(this.popStack.length === 0) {\n        while(this.pushStack.length > 0) {\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack[this.popStack.length - 1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.popStack.length === 0 && this.pushStack.length === 0;\n};\n\n```\n### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦ $O(1)$\n- ç©ºé—´å¤æ‚åº¦ $O(N)$, Nä¸ºé˜Ÿåˆ—å…ƒç´ ä¸ªæ•°","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190220524","body":"#### è§£é¢˜æ€è·¯\n> å•è°ƒæ ˆ\n\n#### ä»£ç å®ç°\n\n```\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    //å®šä¹‰æœ€å¤§æ•°æ®æ ˆ\n    let res=[]\n    for(let i = 0; i < arr.length; i++) {\n        if(res.length==0){\n            res.push(arr[i])\n        }else{\n            if(arr[i]>=res[res.length-1]){\n                res.push(arr[i])\n            }else{\n                let max=res[res.length-1]\n                while(arr[i]<res[res.length-1]){\n                    res.pop()\n                }\n                res.push(max)\n            }\n        }\n    }\n    return res.length\n};\n```\n#### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$ï¼ŒNä¸ºæ•°ç»„é•¿åº¦\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(N)$ï¼ŒNä¸ºæ•°ç»„é•¿åº¦\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191485317","body":"#### ä»£ç å®ç°\n\n```\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (k === 0 || !head || !head.next) {\n        return head;\n    }\n    let n = 1;\n    let cur = head;\n    while (cur.next) {\n        cur = cur.next;\n        n++;\n    }\n\n    let add = n - k % n;\n    if (add === n) {\n        return head;\n    }\n\n    cur.next = head;\n    while (add) {\n        cur = cur.next;\n        add--;\n    }\n\n    const ret = cur.next;\n    cur.next = null;\n    return ret;\n};\n```\n#### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦: $O(N)$\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192445404","body":"### è§£é¢˜æ€è·¯\n1. è®¾ç½®è™šæ‹ŸèŠ‚ç‚¹ï¼Œå®šä¹‰preæŒ‡é’ˆï¼ŒæŒ‡å‘å½“å‰è™šæ‹ŸèŠ‚ç‚¹\n2. å½“pre.nextä»¥åŠpre.next.nextæŒ‡é’ˆå‡ä¸ä¸ºç©ºæ—¶ï¼Œå¼€å§‹äº¤æ¢\n3. ä»¤curæŒ‡é’ˆæŒ‡å‘pre.nextï¼›nextæŒ‡é’ˆæŒ‡å‘pre.next.next\n4. äº¤æ¢è¿‡ç¨‹å¦‚ä¸‹ï¼š\n- pre.next = next\n- cur.next = next.next\n- next.next = cur\n- pre = cur\n\n### ä»£ç å®ç°\njavaScript\n\n```\nvar swapPairs = function(head) {\n    let dummyNode = new ListNode(0);\n    dummyNode.next = head;\n    let pre = dummyNode;\n    while(pre.next && pre.next.next) {\n        const cur = pre.next;\n        const next = pre.next.next;\n        pre.next = next;\n        cur.next = next.next;\n        next.next = cur;\n        pre = cur;\n    }\n    return dummyNode.next;\n};\n```\n### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦ $O(N)$, Nä¸ºé“¾è¡¨ä¸­èŠ‚ç‚¹æ•°ç›®\n- ç©ºé—´å¤æ‚åº¦ $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193139438","body":"### è§£é¢˜æ€è·¯\n    åˆ†æ²» \n### ä»£ç å®ç°\njavaScript\n\n```\nvar sortedListToBST = function(head) {\n  if(!head) return null;\n  let length = 0;\n  let current = head;\n  while(current){\n    current = current.next\n    length++\n  }\n\n  var buildBST = function(start, end){\n    if(start > end) return null;\n\n    const mid = start + ((end - start)>> 1)\n    const leftSide = buildBST(start, mid - 1);\n\n    const root = new TreeNode(head.val)\n    head = head.next;\n    root.left = leftSide\n\n    root.right = buildBST(mid+1, end)\n    return root;\n  }\n\n  return buildBST(0, length - 1)\n};\n```\n### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦ $O(N)$\n- ç©ºé—´å¤æ‚åº¦ $O(logN)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193331020","body":"### è§£é¢˜æ€è·¯ï¼š\n1. ä½¿ç”¨pAã€pBä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«æŒ‡å‘Aã€Bä¸¤ä¸ªé“¾è¡¨ï¼Œä¸¤ä¸ªæŒ‡é’ˆä»¥ç›¸åŒçš„é€Ÿç‡å‘åç§»åŠ¨\n2. å½“pAæŒ‡é’ˆç§»åŠ¨åˆ°äº†Aé“¾æ¥çš„æœ«å°¾ã€ä»¤æŒ‡é’ˆpAæŒ‡å‘Bé“¾è¡¨çš„å¤´éƒ¨\n3. å½“pBæŒ‡é’ˆç§»åŠ¨åˆ°äº†Aé“¾æ¥çš„æœ«å°¾ã€ä»¤æŒ‡é’ˆpBæŒ‡å‘Aé“¾è¡¨çš„å¤´éƒ¨\n4. å½“pAã€pBæŒ‡é’ˆç›¸é‡æ—¶å³ä¸ºä¸¤ä¸ªæŒ‡é’ˆç›¸é‡çš„èµ·ç‚¹ï¼Œå¦åˆ™ä¸¤ä¸ªæŒ‡é’ˆä¸ç›¸äº¤\n\n```\nvar getIntersectionNode = function(headA, headB) {\n    let pA = headA;\n    let pB = headB;\n    while (pA != pB) {\n        pA = pA === null ? headB : pA.next;\n        pB = pB === null ? headA : pB.next;\n    }\n    return pA;\n};\n```\n### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦ O(N)\n- ç©ºé—´å¤æ‚åº¦ O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193821888","body":"### è§£é¢˜æ€è·¯\n\nä»headå¼€å§‹å¿«æ…¢æŒ‡é’ˆï¼Œå¿«æŒ‡é’ˆæ¯æ¬¡ä¸¤æ­¥ï¼Œæ…¢æŒ‡é’ˆæ¯æ¬¡ä¸€æ­¥ï¼Œç¬¬ä¸€æ¬¡ç›¸é‡æ—¶å°†å¿«æŒ‡é’ˆå›åˆ°headï¼Œæ”¹ä¸ºæ¯æ¬¡å‰è¿›ä¸€æ­¥ï¼Œç¬¬äºŒæ¬¡ç›¸é‡ç‚¹ä¸ºç¯èµ·å§‹ç‚¹\n\n### ä»£ç å®ç°\n\n```\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    if(head === null || head.next === null) return null;\n    // å®šä¹‰å¿«æ…¢ä¸¤ä¸ªæŒ‡é’ˆã€åªæƒ³é“¾è¡¨å¤´éƒ¨\n    let fast = head;\n    let slow = head;\n    // å¿«æŒ‡é’ˆèµ°ä¸¤æ­¥ï¼Œæ»¡æŒ‡é’ˆèµ°ä¸€æ­¥\n    do {\n        if (fast !== null && fast.next !== null) {\n            fast = fast.next.next;\n        } else {\n            fast = null\n        }\n        slow = slow.next;\n    } while(fast !== slow)\n    if (fast === null) return null;\n    // ç›¸é‡åå°†å¿«æŒ‡é’ˆæŒ‡å‘é“¾è¡¨å¤´éƒ¨\n    fast = head;\n    while(fast !== slow) {\n        fast = fast.next;\n        slow = slow.next;\n    }\n    return fast;\n};\n```\n### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195338906","body":"### è§£é¢˜æ€è·¯\n    é‡‡ç”¨å“ˆå¸Œè¡¨,ä¿è¯getæ“ä½œåœ¨O(1)æ—¶é—´å¤æ‚åº¦å†…å®Œæˆï¼Œ\n    æ„å»ºåŒå‘é“¾è¡¨ï¼Œä¿è¯putæ“ä½œåœ¨O(1)æ—¶é—´å¤æ‚åº¦å†…å®Œæˆ\n### ä»£ç å®ç°\n> javaScript\n\n```\nvar LinkedList = function(key, val) {\n    this.key = key;\n    this.val = val;\n    this.prev = null;\n    this.next = null;\n}\n\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.capacity = capacity;\n    this.size = 0;\n    this.cache = new Map();\n    // æ„å»ºè™šæ‹ŸèŠ‚ç‚¹\n    this.dummyHead = new LinkedList();\n    this.dummyTail = new LinkedList();\n    this.dummyHead.next = this.dummyTail;\n    this.dummyTail.prev = this.dummyHead;\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if (!this.cache.has(key)) {\n        return -1;\n    }\n    const node = this.cache.get(key);\n    // å°†èŠ‚ç‚¹ç§»åŠ¨è‡³é“¾è¡¨å¤´éƒ¨\n    this.removeNode(node);\n    this.appendToHead(node);\n    return node.val;\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    // åˆ¤æ–­å…³é”®å­—keyæ˜¯å¦å­˜åœ¨äºç¼“å­˜ä¸­\n    const node = this.cache.get(key);\n    if (node) {\n        // æ›´æ–°å…³é”®å­—çš„å€¼\n        node.val = value;\n        this.cache.set(key, node);\n        // å°†å…³é”®å­—ç§»åŠ¨è‡³é“¾è¡¨å¤´éƒ¨\n        this.removeNode(node);\n        this.appendToHead(node);\n    } else {\n        // å½“ç¼“å­˜å®¹é‡è¾¾åˆ°ä¸Šé™æ—¶\n        if (this.size === this.capacity) {\n            // åˆ é™¤æœ€ä¹…æœªä½¿ç”¨çš„\n            this.removeTailNode();\n        }\n        // åˆ›å»ºæ–°èŠ‚ç‚¹\n        const newNode = new LinkedList(key, value);\n        this.cache.set(key, newNode)\n        this.appendToHead(newNode);\n        this.size ++;\n    }\n};\n\nLRUCache.prototype.removeNode = function(node) {\n    let preNode = node.prev;\n    let nextNode = node.next;\n    preNode.next = nextNode;\n    nextNode.prev = preNode;\n}\n\nLRUCache.prototype.appendToHead = function(node) {\n    let head = this.dummyHead.next;\n    this.dummyHead.next = node;\n    node.prev = this.dummyHead;\n    node.next = head;\n    head.prev = node;\n}\n\nLRUCache.prototype.removeTailNode = function() {\n    this.size --;\n    let tailNode = this.dummyTail.prev;\n    this.cache.delete(tailNode.key);\n    this.removeNode(tailNode);\n}\n```\n### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(1)$ \n- ç©ºé—´å¤æ‚åº¦ï¼š$O(capacity)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196572272","body":"### è§£é¢˜æ€è·¯\n> DFS\n\n### ä»£ç å®ç°\n> javaScript\n\n```\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root, depth = 0) {\n  if(!root) return depth;\n  return Math.max(maxDepth(root.left, depth + 1),maxDepth(root.right, depth + 1))\n};\n\n```\n### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦ $O(N)$ Nä¸ºäºŒå‰æ ‘ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°\n- ç©ºé—´å¤æ‚åº¦ $(K)$, kä¸ºäºŒå‰æ ‘çš„æ·±åº¦","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199141764","body":"### è§£é¢˜æ€è·¯\n> DFS\n\n### ä»£ç å®ç°\n\n```\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root) {\n    return dfs(root, 0)\n};\nvar dfs = function(root, sum) {\n    if (root === null) {\n        return 0;\n    }\n    const curSum = sum * 10 + root.val;\n    // éå†åˆ°æ ¹èŠ‚ç‚¹\n    if (root.left === null && root.right === null) {\n        return curSum;\n    } else {\n        return dfs(root.left, curSum) + dfs(root.right, curSum);\n    }\n}\n\n```\n### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦ $O(n)$ nä¸ºäºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°\n- ç©ºé—´å¤æ‚åº¦ $O(n)$ nä¸ºäºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°\n\n\n### è§£é¢˜æ€è·¯\n> BFS\n\n### ä»£ç å®ç°\n> javaScript\n```\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root) {\n    if (root === null) {\n        return 0;\n    }\n    const queue = [[root, root.val]];\n    let sum = 0;\n    while(queue.length > 0) {\n        const [node, curSum] = queue.shift();\n        if(node.left === null && node.right === null) {\n            sum += curSum;\n        } else {\n          node.left && queue.push([node.left, curSum * 10 + node.left.val]);  \n          node.right && queue.push([node.right, curSum * 10 + node.right.val]);  \n        }\n    }\n    return sum;\n};\n```\n### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦ $O(n)$ nä¸ºäºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°\n- ç©ºé—´å¤æ‚åº¦ $O(n)$ nä¸ºäºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200444046","body":"### è§£é¢˜æ€è·¯\n> DFSï¼ˆé€’å½’ï¼‰\n\n### ä»£ç å®ç°\n> javaScript\n\n```\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nconst serialize = (root) => {\n  if (root == null) {                  // éå†åˆ° null èŠ‚ç‚¹\n    return 'X';\n  } \n  const left = serialize(root.left);   // å·¦å­æ ‘çš„åºåˆ—åŒ–ç»“æœ\n  const right = serialize(root.right); // å³å­æ ‘çš„åºåˆ—åŒ–ç»“æœ\n  return root.val + ',' + left + ','+ right; // æŒ‰  æ ¹,å·¦,å³  æ‹¼æ¥å­—ç¬¦ä¸²\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n  const list = data.split(',');   // splitæˆæ•°ç»„\n\n  const buildTree = (list) => {   // åŸºäºlistæ„å»ºå½“å‰å­æ ‘\n    const rootVal = list.shift(); // å¼¹å‡ºé¦–é¡¹ï¼Œè·å–å®ƒçš„â€œæ•°æ®â€\n    if (rootVal == \"X\") {         // æ˜¯Xï¼Œè¿”å›nullèŠ‚ç‚¹\n      return null;\n    }\n    const root = new TreeNode(rootVal); // ä¸æ˜¯Xï¼Œåˆ™åˆ›å»ºèŠ‚ç‚¹\n    root.left = buildTree(list);        // é€’å½’æ„å»ºå·¦å­æ ‘\n    root.right = buildTree(list);       // é€’å½’æ„å»ºå³å­æ ‘\n    return root;                        // è¿”å›å½“å‰æ„å»ºå¥½çš„root\n  };\n\n  return buildTree(list);\n};\n\n```\n### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦ $O(N)$\n- ç©ºé—´å¤æ‚åº¦ $O(N)$","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203995263","body":"### è§£é¢˜æ€è·¯\n> æ¡¶æ’åº\n\n### ä»£ç å®ç°\n> javaScript\n\n```\nlet topKFrequent = function(nums, k) {\n    let map = new Map(), arr = [...new Set(nums)]\n    nums.map((num) => {\n        if(map.has(num)) map.set(num, map.get(num)+1)\n        else map.set(num, 1)\n    })\n    \n    // å¦‚æœå…ƒç´ æ•°é‡å°äºç­‰äº k\n    if(map.size <= k) {\n        return [...map.keys()]\n    }\n    \n    return bucketSort(map, k)\n};\n\n// æ¡¶æ’åº\nlet bucketSort = (map, k) => {\n    let arr = [], res = []\n    map.forEach((value, key) => {\n        // åˆ©ç”¨å‡ºç°é¢‘ç‡ä½œä¸ºä¸‹æ ‡ï¼Œå°†æ•°æ®åˆ†é…åˆ°å„ä¸ªæ¡¶ä¸­\n        if(!arr[value]) {\n            arr[value] = [key]\n        } else {\n            arr[value].push(key)\n        }\n    })\n    // å€’åºéå†è·å–å‡ºç°é¢‘ç‡æœ€å¤§çš„å‰kä¸ªæ•°\n    for(let i = arr.length - 1;i >= 0 && res.length < k;i--){\n        if(arr[i]) {\n            res.push(...arr[i])\n        }\n\t}\n\treturn res\n}\n```\n### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦ $O(N)$\n- ç©ºé—´å¤æ‚åº¦ $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205039240","body":"### è§£é¢˜æ€è·¯\n> å“ˆå¸Œè¡¨\n\n### ä»£ç å®ç°\n> javaScript\n\n```\n/**\n * @param {number[][]} points\n * @return {number}\n */\nvar numberOfBoomerangs = function(points) {\n    const maps = Array(points.length)\n        .fill(0)\n        .map(() => ({}));\n    let count = 0;\n\n    points.forEach((a, i) => {\n        const map = maps[i];\n        points.forEach((b, j) => {\n            if (a !== b) {\n                const dist = calcDistOf2Points(a, b);\n                map[dist] = (map[dist] || 0) + 1;\n            }\n        });\n        for (const dist in map) {\n            const num = map[dist];\n            if (num > 1) count += num * (num - 1);\n        }\n    });\n    return count;\n    function calcDistOf2Points([x1, y1], [x2, y2]) {\n        return (x1 - x2) ** 2 + (y1 - y2) ** 2;\n    }\n};\n```\n### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦ $O(NË†2)$ N æ˜¯æ•°ç»„é•¿åº¦\n- ç©ºé—´å¤æ‚åº¦ $O(NË†2)$ éœ€è¦ N ä¸ªå“ˆå¸Œè¡¨æ¥è®°å½• N ä¸ªç‚¹åˆ°å…¶ä»– N-1 ä¸ªç‚¹çš„è·ç¦»ï¼Œæœ€åçš„æƒ…å†µæ˜¯æ¯ä¸ªç‚¹åˆ°å…¶ä»–ç‚¹çš„è·ç¦»éƒ½ä¸ä¸€æ ·ï¼Œé‚£æ¯ä¸ªå“ˆå¸Œè¡¨çš„å¤§å°å°±æ˜¯ N-1","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208275602","body":"#### è§£é¢˜æ€è·¯\n> åŒæŒ‡é’ˆ\n\n#### ä»£ç å®ç°\n\n```\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function (head) {\n  let slow = (fast = head);\n  while (slow && fast && fast.next) {\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n  return slow;\n};\n```\n#### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦: $O(N)$\n\n- ç©ºé—´å¤æ‚åº¦: $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209415545","body":"### è§£é¢˜æ€è·¯\n- ä½¿ç”¨è¯»å†™æŒ‡é’ˆ,è¯»æŒ‡é’ˆéå†æ•°ç»„ï¼Œå†™æŒ‡é’ˆä¿®æ”¹æ•°ç»„ï¼Œåˆ é™¤é‡å¤å…ƒç´ \n\n### ä»£ç å®ç°\n\n```\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    // å®šä¹‰è¯»ã€å†™æŒ‡é’ˆï¼Œå¼€å§‹æ—¶å‡æŒ‡å‘æ•°ç»„èµ·ç‚¹\n    let writePoint = 0;\n    let readPoint = 0;\n    // æ•°ç»„æœªè¢«éå†è‡³æœ«å°¾\n    while(readPoint < nums.length) {\n        // å½“è¯»å†™æŒ‡é’ˆå†…å®¹ä¸ç›¸ç­‰æ—¶\n        if(nums[writePoint] !== nums[readPoint]) {\n            // ç§»åŠ¨å†™æŒ‡é’ˆ\n            writePoint ++;\n            // æ”¹å†™æ•°ç»„ç›¸åº”çš„å€¼\n            nums[writePoint] = nums[readPoint]\n        }\n        readPoint ++;\n    }\n    return writePoint + 1\n};\n```\n### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$, Nä¸ºæ•°ç»„é•¿åº¦\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miss1":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185628129","body":"### æ€è·¯\næ–°å»ºä¸€ä¸ªæ•°ç»„ï¼Œé•¿åº¦ä¸ºnumå’Œkçš„é•¿åº¦çš„æœ€å¤§å€¼ï¼Œä»numå’Œkçš„æœ«å°¾å¼€å§‹ç›¸åŠ ï¼Œå¾—åˆ°çš„å€¼èµ‹å€¼åˆ°æ–°æ•°ç»„ä¸­ï¼Œæ³¨æ„è¿›ä½ã€‚\n\n### ä»£ç \n```javascript\nvar addToArrayForm = function(num, k) {\n  let size = Math.max(num.length, (k + '').length);\n  let res = new Array(size);\n  let j = num.length - 1;\n  for (let i = res.length - 1; i >= 0; i--) {\n    let sum = k % 10;\n    if (j >= 0) sum += num[j];\n    if (res[i]) sum += res[i];\n    if (i === 0) {\n      res[i] = sum;\n    } else {\n      res[i] = sum % 10;\n      res[i - 1] = Math.floor(sum / 10);\n    }\n    k = Math.floor(k / 10);\n    j--;\n  }\n  if (res[0] >= 10) {\n    let s = res[0];\n    res[0] = s % 10;\n    res.unshift(Math.floor(s /10));\n  }\n  return res;\n};\n```\n\n### å¤æ‚åº¦\n* time: O(n)\n* space: O(n)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186381448","body":"```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.arr = [];\n  this.maxSize = maxSize;\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.arr.length < this.maxSize) this.arr.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  if (this.arr.length === 0) return -1;\n  else return this.arr.pop();\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  for (let i = 0; i < k; i++) {\n    if (i >= this.arr.length) break;\n    this.arr[i] += val;\n  }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n/**\n * æ ˆ\n * time: O(n)\n * space: O(n)\n*/\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189059597","body":"```javascript\n\nvar MyQueue = function() {\n  this.stack1 = [];\n  this.stack2 = [];\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  this.stack1.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  while (this.stack1.length > 0) {\n    this.stack2.push(this.stack1.pop());\n  }\n  let res = this.stack2.pop();\n  while (this.stack2.length > 0) {\n    this.stack1.push(this.stack2.pop());\n  }\n  return res;\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  return this.stack1[0];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return this.stack1.length === 0;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n\n/**\n * æ ˆ\n * time: O(n)\n * space: O(n)\n * å®šä¹‰ä¸¤ä¸ªæ ˆï¼Œpopçš„æ—¶å€™ï¼Œå°†stack1çš„æ•°æ®å…¨éƒ¨popåˆ°stack2ï¼Œè¿”å›stack2æ ˆé¡¶çš„å€¼ï¼Œå†å°†stack2å…¨éƒ¨popå›stack1\n */\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192290832","body":"```javascript\n/**\n * @param {ListNode} head\n * @return {ListNode}\n * time: O(n)\n * space: O(1)\n * å®šä¹‰ä¸€ä¸ªpreèŠ‚ç‚¹å’ŒnextèŠ‚ç‚¹ï¼Œä½ç½®åˆ†åˆ«åœ¨è¦äº¤æ¢çš„ä¸¤ä¸ªèŠ‚ç‚¹çš„å‰å\n * éå†äº¤æ¢èŠ‚ç‚¹\n */\nvar swapPairs = function(head) {\n  if (head === null || head.next === null) return head;\n  let res = new ListNode(0);\n  let p1 = head;\n  let p2 = head.next;\n  let pre = res;\n  pre.next = head;\n  while (p1 && p2) {\n    let next = p2.next;\n    p1.next = next;\n    p2.next = p1;\n    pre.next = p2;\n    pre = p1;\n    p1 = next;\n    p2 = p1 === null ? null : p1.next;\n  }\n  return res.next;\n};\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195037913","body":"```javascript\nfunction ListNode(val, key) {\n  this.val = val;\n  this.key = key;\n  this.next = null;\n  this.pre = null;\n}\n\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n  this.head = new ListNode(0);\n  this.tail = new ListNode(0);\n  this.head.next = this.tail;\n  this.tail.pre = this.head;\n  this.map = new Map();\n  this.size = capacity;\n};\n\n/**\n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n  if (this.map.has(key)) {\n    let node = this.map.get(key);\n    this.moveNodeInHead(node);\n    return node.val;\n  }\n  return -1;\n};\n\n/**\n * @param {number} key\n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n  if (this.map.has(key)) {\n    let node = this.map.get(key);\n    node.val = value;\n    this.moveNodeInHead(node);\n  } else {\n    let node = new ListNode(value, key);\n    this.map.set(key, node);\n    let next = this.head.next;\n    this.head.next = node;\n    node.pre = this.head;\n    node.next = next;\n    next.pre = node;\n    if (this.map.size > this.size) this.deleteNodeInTail();\n  }\n};\n\nLRUCache.prototype.moveNodeInHead = function(node) {\n  let pre = node.pre;\n  let next = node.next;\n  pre.next = next;\n  next.pre = pre;\n  let hnext = this.head.next;\n  this.head.next = node;\n  node.pre = this.head;\n  node.next = hnext;\n  hnext.pre = node;\n};\n\nLRUCache.prototype.deleteNodeInTail = function() {\n  let node = this.tail.pre;\n  this.map.delete(node.key);\n  let p = node.pre;\n  p.next = this.tail;\n  this.tail.pre = p;\n  node.next = null;\n  node.pre = null;\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201001475","body":"```javascript\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n * DFS, å…ˆåºéå†ï¼Œè®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„rowå’Œcolï¼Œå­˜å‚¨åˆ°mapä¸­ï¼Œmapä¸­colä¸ºkeyå€¼ï¼Œvalueä¸ºå¯¹è±¡æ•°ç»„[{row: row, val: root.val}]\n * å¯¹mapçš„keyæ’åºï¼Œéå†keyè·å–mapçš„å€¼ï¼Œå°†å–å‡ºæ¥çš„æ•°ç»„æ ¹æ®rowå’Œvalçš„å€¼æ’åºï¼ˆå…ˆæ¯”è¾ƒrowçš„å¤§å°ï¼Œrowç›¸åŒå†æ¯”è¾ƒvalï¼‰ï¼Œå†å°†æ’åºå¥½çš„æ•°ç»„pushåˆ°ç»“æœæ•°ç»„resä¸­\n * {0ï¼š[{row: row, val: root.val}]}\n * time: O(nlogn), sortæ’åºçš„æ—¶é—´å¤æ‚åº¦ä¸ºO(nlogn)\n * space: O(n)\n */\nvar verticalTraversal = function(root) {\n  let map = new Map();\n  let keys = [], res = [];\n  let preOrder = function(root, row, col) {\n    if (!root) return;\n    if (map.has(col)) map.get(col).push({row: row, val: root.val});\n    else {\n      map.set(col, [{row: row, val: root.val}]);\n      keys.push(col);\n    }\n    preOrder(root.left, row + 1, col - 1);\n    preOrder(root.right, row + 1, col + 1);\n  };\n  preOrder(root, 0, 0);\n  keys.sort((a,b) => { return a - b; });\n  for (let i = 0; i < keys.length; i++) {\n    let arr = map.get(keys[i]);\n    arr.sort((a,b) => {\n      if (a.row === b.row) return a.val - b.val;\n      else return a.row - b.row;\n    });\n    res.push(arr.map(val => {return val.val}));\n  }\n  return res;\n};\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206210888","body":"```javascript\n/**\n * @param {string} s\n * @return {number}\n * time: O(n)\n * space: O(n)\n * æ»‘åŠ¨çª—å£ï¼Œå¯å˜çª—å£å¤§å°,ç”¨setå­˜å‚¨å­ä¸²ï¼Œsetä¸­åŒ…å«å½“å‰å­—ç¬¦æ—¶ç§»åŠ¨å·¦æŒ‡é’ˆ\n */\nvar lengthOfLongestSubstring = function(s) {\n  let l = 0, set = new Set();\n  let res = 0;\n  for (let i = 0; i < s.length; i++) {\n    while (set.has(s[i])) {\n      res = Math.max(res, set.size);\n      set.delete(s[l]);\n      l++;\n    }\n    set.add(s[i]);\n  }\n  return Math.max(res, set.size);\n};\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209202251","body":"```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n * index è¡¨ç¤ºç»“æœæ•°ç»„çš„å½“å‰ä½ç½®\n * éå†numsï¼Œå½“nums[i] ä¸ç­‰äº nums[i+1]æ—¶ï¼Œè¯´æ˜nums[i+1]æ˜¯ç¬¬ä¸€ä¸ªæ–°çš„ä¸é‡å¤çš„å€¼ï¼Œå°†è¿™ä¸ªå€¼å­˜å‚¨åˆ°indexçš„ä½ç½®\n * æœ€åè¿”å›indexå€¼ï¼Œindexå€¼å°±æ˜¯ç»“æœæ•°ç»„çš„é•¿åº¦\n * time: O(n)\n * space: O(1)\n */\nvar removeDuplicates = function(nums) {\n  let index = 1;\n  for (let i = 0; i < nums.length - 1; i++) {\n    if (nums[i] !== nums[i + 1]) {\n      nums[index] = nums[i + 1];\n      index++;\n    }\n  }\n  return index;\n};\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"johnxizhao":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185630005","body":"## æ€è·¯\r\néå†æ•°ç»„ï¼Œä»åå‘å‰åŠ ï¼›éšæ—¶æ›´æ–°è¿›ä½å˜é‡;\r\næœ€åéœ€è¦æ³¨æ„è¿›ä½æ˜¯å¦ä¸º1\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        if(k == 0) {\r\n            return Arrays.stream(num).boxed().collect(Collectors.toList());\r\n        }\r\n        StringBuffer sb = new StringBuffer();\r\n        List<Integer> res = new ArrayList<>();\r\n        int n = num.length;\r\n        int carry = 0;\r\n        int ans = 0;\r\n        int i = n - 1;\r\n        while(i >= 0 || k != 0) {\r\n            int x = i >= 0 ? num[i] : 0;\r\n            int y =  k != 0 ? k % 10 : 0;\r\n            int sum = x + y + carry;\r\n            carry = sum / 10;\r\n            ans = sum % 10;\r\n            i--;\r\n            res.add(0, ans);\r\n            k /= 10;\r\n        }\r\n        \r\n        if(carry != 0) {\r\n            res.add(0, carry);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n## å¤æ‚åº¦åˆ†æ\r\næ—¶é—´å¤æ‚åº¦ O(n)\r\nç©ºé—´å¤æ‚åº¦ O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186207847","body":"## æ€è·¯\r\n0ï¼ŒåŒæŒ‡é’ˆï¼ši è¿›è¡Œå­—ç¬¦ä¸²éå†ï¼Œj è¿›è¡Œç›®æ ‡å­—ç¬¦ä½ç½®çš„å›ºå®šï¼›\r\n1ï¼Œä»å·¦å‘å³éå†ï¼Œè®°å½•æ¯ä¸ªå­—ç¬¦ä¸å…¶å·¦è¾¹çš„ç›®æ ‡å­—ç¬¦çš„è·ç¦»ï¼›\r\n2ï¼Œå†ä»å³å‘å·¦éå†ï¼Œè®°å½•æ¯ä¸ªå­—ç¬¦ä¸å…¶å³è¾¹å‡ºç°çš„ç›®æ ‡å­—ç¬¦çš„è·ç¦»ï¼Œä¸ç»“æœæ•°ç»„ä¸­çš„å–å°å€¼ï¼›\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        if(s == null || s.length() == 0) {\r\n            return new int[0];\r\n        }\r\n        int n = s.length();\r\n        int[] res = new int[n];\r\n        Arrays.fill(res, n + 1);\r\n        // j è®°å½•å·¦ä¾§ç¬¬ä¸€ä¸ª c çš„åæ ‡\r\n        for(int i = 0, j = -1; i < n; i++) {\r\n            if(s.charAt(i) == c) {\r\n                j = i;\r\n            }\r\n            if(j != -1) {\r\n                res[i] = i - j;\r\n            }\r\n        }\r\n        // ä»å³å‘å·¦éå†ï¼Œj ä¸ºç¬¬ä¸€ä¸ª c çš„åæ ‡\r\n        for(int i = n - 1, j = -1; i >= 0; i--) {\r\n            if(s.charAt(i) == c) {\r\n                j = i;\r\n            }\r\n            if(j != -1) {\r\n                res[i] = Math.min(res[i], j - i);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186679035","body":"## æ€è·¯\r\næ•°ç»„æ¨¡æ‹Ÿæ ˆï¼Œç”¨å˜é‡è®°å½•æ ˆé¡¶çš„ä½ç½®\r\nÂ·Â·Â·\r\nclass CustomStack {\r\n    int[] st;\r\n    int top = -1;\r\n\r\n    public CustomStack(int maxSize) {\r\n        st = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top == st.length - 1) {\r\n            return;\r\n        }\r\n        top++;\r\n        st[top] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top == -1) {\r\n            return -1;\r\n        }\r\n        return st[top--];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int cnt = k > st.length ? st.length : k;\r\n        for(int i = 0; i < cnt; i++) {\r\n            st[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\nÂ·Â·Â·","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187006693","body":"## æ€è·¯\r\n1ï¼Œä»¥ä¸€å¯¹ä¸­æ‹¬å·æ¥è§£æå­—ç¬¦ä¸²ï¼Œç”¨æ•°ç»„æ¥ç»´æŠ¤ä¸€ä¸ªæ ˆï¼Œé™¤å³æ‹¬å·å…¶ä»–éƒ½è¿›æ ˆï¼›é‡åˆ°å³æ‹¬å·åˆ™å‡ºæ ˆï¼›\r\n2ï¼Œè¿›æ ˆéœ€è¦å°†æ•°å­—å­—ç¬¦å¤„ç†å¦¥å½“ï¼Œå¤„ç†æˆå­—ç¬¦ï¼›ä¸¤ä½åŠä»¥ä¸Šçš„æ•°å­—å®¹æ˜“å‡ºé”™ï¼›\r\n```\r\nclass Solution {\r\n    int idx;\r\n    public String decodeString(String s) {\r\n        if(s == null || s.length() == 0) {\r\n            return \"\";\r\n        }\r\n        LinkedList<String> st = new LinkedList<>();\r\n        int n = s.length();\r\n        while(idx < n) {\r\n            if(Character.isDigit(s.charAt(idx))) {\r\n                st.add(getDigit(s));\r\n            }\r\n            else if(s.charAt(idx) != ']') {\r\n                st.add(String.valueOf(s.charAt(idx++)));\r\n            }\r\n            else {\r\n                LinkedList<String> path = new LinkedList<>();\r\n                while(!\"[\".equals(st.peekLast())) {\r\n                    path.add(st.pollLast());\r\n                }\r\n                Collections.reverse(path);\r\n                String sub = getString(path);\r\n                st.pollLast();\r\n                int cnt = Integer.valueOf(st.pollLast());\r\n                String str = getSubString(cnt, sub);\r\n                st.add(str);\r\n                idx++;\r\n            }\r\n        }\r\n        return getString(st);\r\n    }\r\n\r\n    private String getDigit(String s) {\r\n        StringBuffer sb = new StringBuffer();\r\n        while(Character.isDigit(s.charAt(idx))) {\r\n            sb.append(s.charAt(idx++));\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    private String getString(LinkedList<String> path) {\r\n        StringBuffer sb = new StringBuffer();\r\n        for(String s : path) {\r\n            sb.append(s);\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    private String getSubString(int cnt, String sub) {\r\n        StringBuffer sb = new StringBuffer();\r\n        while(cnt-- > 0) {\r\n            sb.append(sub);\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n```\r\n## å¤æ‚åº¦\r\nTï¼šO(n)ï¼Œéå†å­—ç¬¦ä¸²\r\nSï¼šO(n)ï¼Œæ•°ç»„æ¨¡æ‹Ÿæ ˆ\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188799537","body":"## æ€è·¯\r\nä¸¤ä¸ªæ ˆå®ç°é˜Ÿåˆ—ï¼Œä¸€ä¸ªè¿›ä¸€ä¸ªå‡º\r\n```\r\nclass MyQueue {\r\n    Stack<Integer> s1;\r\n    Stack<Integer> s2;\r\n    public MyQueue() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if(s1.isEmpty() && s2.isEmpty()) {\r\n            return -1;\r\n        }\r\n        if(s2.isEmpty()) {\r\n            while(!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if(s1.isEmpty() && s2.isEmpty()) {\r\n            return -1;\r\n        }\r\n        if(s2.isEmpty()) {\r\n            while(!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}\r\n```\r\n## å¤æ‚åº¦\r\nT: O(N)\r\nS: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189784256","body":"## æ€è·¯\r\nç»´æŠ¤ä¸€ä¸ªæ ˆï¼Œéå†æ•°ç»„ï¼Œå¹¶ä¸æ ˆé¡¶å…ƒç´ æ¯”è¾ƒï¼Œ\r\n1ï¼Œå½“å‰æ•°å°äºæ ˆé¡¶ï¼Œæ ˆé¡¶å‡ºæ ˆï¼›\r\n2ï¼Œå½“å‰æ•°å¤§äºç­‰äºæ ˆé¡¶ï¼Œç›´æ¥å…¥æ ˆ\r\n\r\n```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        if(arr == null || arr.length == 0) {\r\n            return 0;\r\n        }\r\n        LinkedList<Integer> st = new LinkedList<>();\r\n        int head = 0;\r\n        for(int x : arr) {\r\n            if(!st.isEmpty() && x < st.getLast()) {\r\n                head = st.pollLast();\r\n                while(!st.isEmpty() && x < st.getLast()) {\r\n                    st.pollLast();\r\n                }\r\n                st.add(head);\r\n            }\r\n            else {\r\n                st.add(x);\r\n            }\r\n        }\r\n        return st.size();\r\n    }\r\n}\r\n```\r\n##  å¤æ‚åº¦\r\nT:O(N)\r\nS:O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192618402","body":"```\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next == null){\r\n            return head;\r\n        }\r\n        ListNode next = head.next;\r\n        head.next = swapPairs(next.next);\r\n        next.next = head;\r\n        return next;\r\n    }\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193341285","body":"## æ€è·¯\r\nä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘ä¸¤ä¸ªé“¾è¡¨ï¼Œå¾ªç¯æŒ‡å‘ï¼Œç›´åˆ°ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘åŒä¸€ä¸ªèŠ‚ç‚¹\r\n```\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode p, ListNode q) {\r\n        if(p == null || q == null) {\r\n            return null;\r\n        }\r\n        ListNode l = p;\r\n        ListNode r = q;\r\n        while(l != r) {\r\n            if(l != null) {\r\n                l = l.next;\r\n            }\r\n            else {\r\n                l = q;\r\n            }\r\n            if(r != null) {\r\n                r = r.next;\r\n            }\r\n            else {\r\n                r = p;\r\n            }\r\n        }\r\n        return l;\r\n    }\r\n}\r\n```\r\n## å¤æ‚åº¦\r\nT: O(M+N)\r\nS: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194166187","body":"## æ€è·¯\r\nå¿«æ…¢æŒ‡é’ˆåˆ¤æ–­æ˜¯å¦æœ‰ç¯ï¼›å†åŒæŒ‡é’ˆæ±‚å…¥å£\r\n```\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if(head == null) {\r\n            return null;\r\n        }\r\n        ListNode f = head;\r\n        ListNode s = head;\r\n        while(true) {\r\n            if(f == null || f.next == null) {\r\n                return null;\r\n            }\r\n            f = f.next.next;\r\n            s = s.next;\r\n            if(f == s) {\r\n                break;\r\n            }\r\n        }\r\n        f = head;\r\n        while(f != s) {\r\n            f = f.next;\r\n            s = s.next;\r\n        }\r\n        return f;\r\n    }\r\n}\r\n```\r\n## å¤æ‚åº¦\r\nT: O(N)\r\nS: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195649294","body":"```\r\nclass LRUCache {\r\n    int cap;\r\n    LinkedHashMap<Integer, Integer> map = new LinkedHashMap<>();\r\n    public LRUCache(int capacity) { \r\n        this.cap = capacity;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        if (!map.containsKey(key)) {\r\n            return -1;\r\n        }\r\n        getKey(key);\r\n        return map.get(key);\r\n    }\r\n    \r\n    public void put(int key, int val) {\r\n        if (map.containsKey(key)) {\r\n            map.put(key, val);\r\n            getKey(key);\r\n            return;\r\n        }\r\n        \r\n        if (map.size() >= this.cap) {\r\n            int oldkey = map.keySet().iterator().next();\r\n            map.remove(oldkey);\r\n        }\r\n        map.put(key, val);\r\n    }\r\n    \r\n    private void getKey(int key) {\r\n        int val = map.get(key);\r\n        map.remove(key);\r\n        map.put(key, val);\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196870830","body":"## æ€è·¯\r\næ— è„‘é€’å½’ï¼Œå¯èƒ½æ˜¯å› ä¸ºå†™äº†å¥½å¤šæ¬¡ï¼Œæ‰€ä»¥ï¼Œåæ­£ï¼Œå°±æ˜¯è¿™æ ·çš„\r\n```\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if(root == null) {\r\n            return 0;\r\n        }\r\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198288063","body":"## æ€è·¯\r\näºŒè¯ä¸è¯´å°±æ˜¯é€’å½’\r\n```\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if(p == null && q == null) {\r\n            return true;\r\n        }\r\n        if(p == null || q == null) {\r\n            return false;\r\n        }\r\n        if(p.val != q.val) {\r\n            return false;\r\n        }\r\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200242678","body":"```\r\nclass Solution {\r\n    public int findBottomLeftValue(TreeNode root) {\r\n        Deque<TreeNode> q = new LinkedList<>();\r\n        q.addLast(root);\r\n        int ans = 0;\r\n        while (!q.isEmpty()) {\r\n            int size = d.size();\r\n            ans = q.peek().val;\r\n            while (size-- > 0) {\r\n                TreeNode poll = q.pollFirst();\r\n                if (poll.left != null) q.addLast(poll.left);\r\n                if (poll.right != null) q.addLast(poll.right);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200450251","body":"```\r\npublic class Codec {\r\n    int i = 0;\r\n    // Encodes a tree to a single string.\r\n    public String serialize(TreeNode root) {\r\n        if(root == null) {\r\n            return \"\";\r\n        }\r\n        StringBuffer sb = new StringBuffer();\r\n        Queue<TreeNode> q = new LinkedList<>();\r\n        q.offer(root);\r\n        while(!q.isEmpty()) {\r\n            TreeNode node = q.poll();\r\n            if(node == null) {\r\n                sb.append(\"null,\");\r\n            }\r\n            else {\r\n                sb.append(node.val + \",\");\r\n                q.offer(node.left);\r\n                q.offer(node.right);\r\n            }\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    public TreeNode deserialize(String data) {\r\n        if(data == null) {\r\n            return null;\r\n        }\r\n        String[] str = data.trim().split(\",\");\r\n        //Queue<String> q = \r\n        return buildTree(str);\r\n    }\r\n\r\n    private TreeNode buildTree(String[] str) {\r\n        ++i;\r\n        String value = str[i];\r\n        if(value.equals(\"null\")) {\r\n            return null;\r\n        }\r\n        \r\n        TreeNode node = new TreeNode(Integer.valueOf(value));\r\n        node.left = buildTree(str);\r\n        node.right = buildTree(str);\r\n        return node;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201329006","body":"```\r\nclass Solution {\r\n    Map<TreeNode, int[]> map = new HashMap<>();\r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n        map.put(root, new int[]{0, 0, root.val});\r\n        dfs(root);\r\n        List<int[]> list = new ArrayList<>(map.values());\r\n        Collections.sort(list, (a, b)->{\r\n            if (a[0] != b[0]) return a[0] - b[0];\r\n            if (a[1] != b[1]) return a[1] - b[1];\r\n            return a[2] - b[2];\r\n        });\r\n        int n = list.size();\r\n        List<List<Integer>> ans = new ArrayList<>();\r\n        for (int i = 0; i < n; ) {\r\n            int j = i;\r\n            List<Integer> tmp = new ArrayList<>();\r\n            while (j < n && list.get(j)[0] == list.get(i)[0]) tmp.add(list.get(j++)[2]);\r\n            ans.add(tmp);\r\n            i = j;\r\n        }\r\n        return ans;\r\n    }\r\n    private void dfs(TreeNode root) {\r\n        if (root == null) return ;\r\n        int[] info = map.get(root);\r\n        int col = info[0], row = info[1], val = info[2];\r\n        if (root.left != null) {\r\n            map.put(root.left, new int[]{col - 1, row + 1, root.left.val});\r\n            dfs(root.left);\r\n        }\r\n        if (root.right != null) {\r\n            map.put(root.right, new int[]{col + 1, row + 1, root.right.val});\r\n            dfs(root.right);\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202891735","body":"```\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int tar) {\r\n        int n = nums.length;\r\n        for (int i = 0; i < n; ++i) {\r\n            for (int j = i + 1; j < n; ++j) {\r\n                if (nums[i] + nums[j] == tar) {\r\n                    return new int[]{i, j};\r\n                }\r\n            }\r\n        }\r\n        return new int[0];\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1204122175","body":"```\r\nclass Solution {\r\n    public int[] topKFrequent(int[] nums, int k) {\r\n        if(nums == null || nums.length == 0) {\r\n            return new int[0];\r\n        }\r\n        HashMap<Integer, Integer> map = new LinkedHashMap<>();\r\n        for(int x : nums) {\r\n            map.put(x, map.getOrDefault(x, 0) + 1);\r\n        }\r\n\r\n        PriorityQueue<int[]> q = new PriorityQueue<int[]>(new Comparator<int[]>() {\r\n            public int compare(int[] o1, int[] o2) {\r\n                return o1[1] - o2[1];\r\n            }\r\n        });\r\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\r\n            int num = entry.getKey(), cnt = entry.getValue();\r\n            if (q.size() == k) {\r\n                if (q.peek()[1] < cnt) {\r\n                    q.poll();\r\n                    q.offer(new int[]{num, cnt});\r\n                }\r\n            } else {\r\n                q.offer(new int[]{num, cnt});\r\n            }\r\n        }\r\n        int[] res = new int[k];\r\n        for (int i = 0; i < k; ++i) {\r\n            res[i] = q.poll()[0];\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207232910","body":"```\r\nclass Solution {\r\n    public List<Integer> findSubstring(String s, String[] words) {\r\n        int n = s.length();\r\n        int m = words.length; \r\n        int len = words[0].length();\r\n        Map<String, Integer> map = new HashMap<>();\r\n        for (String word : words) {\r\n            map.put(word, map.getOrDefault(word, 0) + 1);\r\n        }\r\n        List<Integer> res = new ArrayList<>();\r\n        out:for (int i = 0; i + m * len <= n; i++) {\r\n            Map<String, Integer> cur = new HashMap<>();\r\n            String str = s.substring(i, i + m * len);\r\n            for (int j = 0; j < str.length(); j += len) {\r\n                String item = str.substring(j, j + len);\r\n                if (!map.containsKey(item)) continue out;\r\n                cur.put(item, cur.getOrDefault(item, 0) + 1);\r\n            }\r\n            if (cur.equals(map)) res.add(i);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208185288","body":"```\r\nclass Solution {\r\n    public ListNode middleNode(ListNode head) {\r\n        if(head == null) {\r\n            return null;\r\n        }\r\n        ListNode s = head;\r\n        ListNode f = head;\r\n        while(f != null && f.next != null) {\r\n            s = s.next;\r\n            f = f.next.next;\r\n        }\r\n        return s;\r\n\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209487101","body":"```\r\nclass Solution {\r\n    public int removeDuplicates(int[] nums) {\r\n        int n = nums.length;\r\n        int p = 0;\r\n        int q = 1;\r\n        while(q < n) {\r\n            if(nums[q] != nums[p]) {\r\n                nums[p + 1] = nums[q];\r\n                p++;\r\n            }\r\n            q++;\r\n        }\r\n        return p + 1;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"incipe-win":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185631706","body":"## æ€è·¯\r\næŠŠ `k` çš„æ¯ä¸€ä½è½¬æ¢æˆä¸€ä¸ª vectorï¼Œç„¶åè¿›è¡Œä¸¤ä¸ª vector ç›¸åŠ å³å¯ã€‚\r\n## ä»£ç \r\n````cpp\r\nclass Solution {\r\nprivate:\r\n    vector<int> addTwo(vector<int> &num1, vector<int> &num2) {\r\n        // [1, 2, 0, 0] + [3, 4]\r\n        int size1 = num1.size() - 1, size2 = num2.size() - 1;\r\n        vector<int> ans;\r\n        int carry = 0;\r\n        while (size1 >= 0 || size2 >= 0) {\r\n            int x1 = size1 >= 0 ? num1[size1] : 0;\r\n            int x2 = size2 >= 0 ? num2[size2] : 0;\r\n            int sum = x1 + x2 + carry;\r\n            carry = sum / 10;\r\n            sum %= 10;\r\n            ans.emplace_back(sum);\r\n            --size1;\r\n            --size2;\r\n        }\r\n        if (carry) {\r\n            ans.emplace_back(carry);\r\n        }\r\n        reverse(ans.begin(), ans.end());\r\n        return ans;\r\n    }\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> num1;\r\n        while (k) {\r\n            num1.emplace_back(k % 10);\r\n            k /= 10;\r\n        }\r\n        reverse(num1.begin(), num1.end());\r\n        return addTwo(num, num1);\r\n    }\r\n};\r\n````\r\n## æ—¶ç©ºå¤æ‚åº¦\r\næ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185717663","body":"## æ€è·¯\næš´åŠ›æ³•ï¼Œç›´æ¥è®°å½•æ‰€æœ‰ç»“æœçš„ç»™å®šå­—ç¬¦çš„ä½ç½®ï¼Œéå†ä¸€éå­—ç¬¦ä¸²ï¼Œå–è·ç¦»æœ€å°çš„å€¼\n## ä»£ç \n````cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> ans;\n        vector<int> tmp;\n        int size = s.size();\n        for (int i = 0; i < size; ++i) {\n            if (s[i] == c) {\n                tmp.emplace_back(i);\n            }\n        }\n        int cnt = 0;\n        for (int i = 0; i < size; ++i) {\n            int minn = INT_MAX;\n            for (int j = 0; j < (int)tmp.size(); ++j) {\n                minn = min(minn, abs(tmp[j] - i));\n            }\n            ans.emplace_back(minn);\n        }\n        return ans;\n    }\n};\n````\n## æ—¶ç©ºå¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦ï¼š$O(n \\times k)$ <br />\nç©ºé—´å¤æ‚åº¦ï¼š$O(k)$ <br />\nkä¸ºå­—ç¬¦çš„ä¸ªæ•°","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186235143","body":"## æ€è·¯\r\nåˆ©ç”¨æ•°ç»„æ¨¡æ‹Ÿæ ˆçš„ `push`, `pop` æ“ä½œï¼Œæœ€åçš„ `increment` ç›´æ¥æŠŠæ•°ç»„å‰ `k` ä¸ªåŠ ä¸Š `val` å³å¯ã€‚\r\n## ä»£ç \r\nC++\r\n````cpp\r\nclass CustomStack {\r\nprivate:\r\n    vector<int> vec;\r\n    int cnt;\r\n    int maxSize;\r\npublic:\r\n    CustomStack(int _maxSize) {\r\n        cnt = 0;\r\n        maxSize = _maxSize;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (cnt < maxSize) {\r\n            vec.emplace_back(x);\r\n            ++cnt;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (cnt == 0) {\r\n            return -1;\r\n        }\r\n        int ret = vec[cnt - 1];\r\n        vec.pop_back();\r\n        --cnt;\r\n        return ret;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        if (cnt < k) {\r\n            k = cnt;\r\n        }\r\n        for (int i = 0; i < k; ++i) {\r\n            vec[i] += val;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n````\r\nPython\r\n````python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.cnt = 0\r\n        self.vec = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cnt < self.maxSize:\r\n            self.vec.append(x)\r\n            self.cnt += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.cnt == 0:\r\n            return -1\r\n        self.cnt -= 1\r\n        return self.vec.pop(-1)\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if k > self.cnt:\r\n            k = self.cnt\r\n        for i in range(k):\r\n            self.vec[i] += val\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n````\r\n## æ—¶ç©ºå¤æ‚åº¦\r\næ—¶é—´å¤æ‚åº¦ï¼š$O(k)$\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(maxSize)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187585157","body":"## æ€è·¯\r\nåˆ©ç”¨ä¸¤ä¸ªæ ˆï¼Œä¸€ä¸ªå­˜å‚¨æ•°å­—çš„æ ˆï¼Œä¸€ä¸ªå­˜å‚¨å­—ç¬¦ä¸²çš„æ ˆã€‚\r\nå¦‚æœæ˜¯ `[`ï¼ŒæŠŠæ•°å­—å­˜å…¥æ•°ç»‡æ ˆï¼ŒæŠŠé‡åˆ° `]` ä¹‹å‰çš„å­—ç¬¦ä¸²å­˜åˆ°å­—ç¬¦ä¸²æ ˆé‡Œé¢ï¼Œå¦‚æœé‡åˆ° `]`ï¼Œåˆ™æŒ‰ç…§é¢˜ç›®è¦æ±‚è§£ç å­—ç¬¦ä¸²ã€‚\r\n## ä»£ç \r\nC++\r\n````cpp\r\nclass Solution {\r\n  public:\r\n    string decodeString(string s) {\r\n        int size = s.size();\r\n        int num = 0;\r\n        stack<int> num_stack;\r\n        stack<string> str_stack;\r\n        string cur = \"\";\r\n        string result = \"\";\r\n        for (int i = 0; i < size; ++i) {\r\n            if (isdigit(s[i])) {\r\n                num = 10 * num + (s[i] - '0');\r\n            } else if (s[i] == '[') {\r\n                num_stack.push(num);\r\n                str_stack.push(cur);\r\n                num = 0;\r\n                cur.clear();\r\n            } else if (isalpha(s[i])) {\r\n                cur += s[i];\r\n            } else if (s[i] == ']') {\r\n                int k = num_stack.top();\r\n                num_stack.pop();\r\n                for (int j = 0; j < k; ++j) {\r\n                    str_stack.top() += cur;\r\n                }\r\n                cur = str_stack.top();\r\n                str_stack.pop();\r\n            }\r\n        }\r\n        result = result + cur;\r\n        return result;\r\n    }\r\n};\r\n````\r\nPython\r\n````python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        size = len(s)\r\n        num = 0\r\n        num_stack = list()\r\n        str_stack = list()\r\n        cur = str()\r\n        result = str()\r\n        for i in range(size):\r\n            if s[i].isdigit():\r\n                num = num * 10 + int(s[i])\r\n            elif s[i] == '[':\r\n                num_stack.append(num)\r\n                str_stack.append(cur)\r\n                num = 0\r\n                cur = \"\"\r\n            elif s[i].isalpha():\r\n                cur += s[i]\r\n            elif s[i] == ']':\r\n                k = num_stack.pop(-1)\r\n                for j in range(k):\r\n                    str_stack[-1] += cur\r\n                cur = str_stack.pop(-1)\r\n        result = result + cur\r\n        return result\r\n````\r\n## æ—¶ç©ºå¤æ‚åº¦\r\nè®°å­—ç¬¦ä¸²çš„é•¿åº¦ä¸º $N$, ç”±äº `s` ä¸­æ‰€æœ‰çš„æ•´æ•°å–å€¼èŒƒå›´éƒ½æ˜¯ `[1, 300]`, æ•…æ‹¼æ¥å­—ç¬¦ä¸²çš„æ—¶é—´å¤æ‚åº¦å¯ä»¥å¿½ç•¥ã€‚\r\næ—¶é—´å¤æ‚åº¦ï¼š$O(N)$\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189097171","body":"## æ€è·¯\r\nåªè¦ç†è§£äº†æ ˆå’Œé˜Ÿåˆ—çš„åŸºæœ¬æ€æƒ³ï¼Œå°±å¯ä»¥å†™å‡ºæ­¤é¢˜äº†ã€‚\r\n## ä»£ç \r\nC++\r\n````cpp\r\nclass MyQueue {\r\n  private:\r\n    stack<int> st1, st2;\r\n\r\n  public:\r\n    MyQueue() {}\r\n\r\n    void push(int x) { st1.push(x); }\r\n\r\n    int pop() {\r\n        int ret = 0;\r\n        if (!st2.empty()) {\r\n            ret = st2.top();\r\n            st2.pop();\r\n            return ret;\r\n        }\r\n        while (!st1.empty()) {\r\n            st2.push(st1.top());\r\n            st1.pop();\r\n        }\r\n        ret = st2.top();\r\n        st2.pop();\r\n        return ret;\r\n    }\r\n\r\n    int peek() {\r\n        int ret = 0;\r\n        if (!st2.empty()) {\r\n            ret = st2.top();\r\n            return ret;\r\n        }\r\n        while (!st1.empty()) {\r\n            st2.push(st1.top());\r\n            st1.pop();\r\n        }\r\n        ret = st2.top();\r\n        return ret;\r\n    }\r\n\r\n    bool empty() {\r\n        return st1.empty() && st2.empty();\r\n    }\r\n};\r\n````\r\nPython\r\n````python\r\nclass MyQueue:\r\n    \r\n    def __init__(self):\r\n        self.st1 = []\r\n        self.st2 = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        self.st1.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if len(self.st2):\r\n            return self.st2.pop(-1)\r\n        while len(self.st1):\r\n            self.st2.append(self.st1.pop(-1))\r\n        return self.st2.pop(-1)\r\n\r\n\r\n    def peek(self) -> int:\r\n        if len(self.st2):\r\n            return self.st2[-1]\r\n        while len(self.st1):\r\n            self.st2.append(self.st1.pop(-1))\r\n        return self.st2[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return not (len(self.st1) or len(self.st2))\r\n````\r\n## æ—¶ç©ºå¤æ‚åº¦\r\næ—¶é—´å¤æ‚åº¦ï¼š$O(1)$\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(N)$","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191469274","body":"## æ€è·¯\r\nå…ˆè·å–é“¾è¡¨çš„é•¿åº¦ï¼Œå› ä¸ºå½“ k å¤§äºé“¾è¡¨é•¿åº¦çš„æ—¶å€™ï¼Œå…¶å®å¹¶ä¸éœ€è¦ç§»åŠ¨ k æ¬¡ï¼Œåªéœ€è¦ç§»åŠ¨ $k \\% n$ å°±å¥½äº†ã€‚ç„¶åè®¾å®šä¸¤ä¸ªæŒ‡é’ˆ fast, slowï¼Œ\r\nfast æŒ‡é’ˆå…ˆç§»åŠ¨ k æ­¥ï¼Œç„¶åè·Ÿ slow æŒ‡é’ˆä¸€èµ·ç§»åŠ¨ï¼Œè¿™æ ·å½“ fast æŒ‡é’ˆç§»åŠ¨åˆ°æœ€åä¸€ä¸ªå…ƒç´ æ—¶ï¼Œslow æŒ‡é’ˆå°±æ˜¯å¤„åœ¨å€’æ•°ç¬¬ k ä¸ªå…ƒç´ çš„å‰ä¸€ä¸ªå…ƒç´ ä½ç½®ï¼Œç„¶åé‡ç°é“¾æ¥ä¸€ä¸‹é“¾è¡¨å³å¯ã€‚\r\n## ä»£ç \r\nC++\r\n````cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if (!head) {\r\n            return head;\r\n        }\r\n        int n = 0;\r\n        ListNode *tmp = head;\r\n        while (tmp) {\r\n            ++n;\r\n            tmp = tmp->next;\r\n        }\r\n        k %= n;\r\n        if (k == 0) {\r\n            return head;\r\n        }\r\n        ListNode *fast = head, *slow = head;\r\n        for (int i = 0; i < k; ++i) {\r\n            fast = fast->next;\r\n        }\r\n        while (fast->next) {\r\n            fast = fast->next;\r\n            slow = slow->next;\r\n        }\r\n        ListNode *ans = slow->next;\r\n        slow->next = nullptr;\r\n        fast->next = head;\r\n        return ans;\r\n    }\r\n};\r\n````\r\nPython\r\n````python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return head\r\n        tmp = head\r\n        n = 0\r\n        while tmp:\r\n            n += 1\r\n            tmp = tmp.next\r\n        k %= n\r\n        if k == 0:\r\n            return head\r\n        fast, slow = head, head\r\n        for i in range(k):\r\n            fast = fast.next\r\n        while fast.next:\r\n            fast = fast.next\r\n            slow = slow.next\r\n        ans = slow.next\r\n        slow.next = None\r\n        fast.next = head\r\n        return ans\r\n````\r\n## æ—¶ç©ºå¤æ‚åº¦\r\næ—¶é—´å¤æ‚åº¦ï¼š$O(N)$\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192655135","body":"## æ€è·¯\r\næ¯æ¬¡äº¤æ¢é“¾è¡¨çš„ä¸¤ä¸ªå€¼å³å¯ã€‚\r\n## ä»£ç \r\nC++\r\n````cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        ListNode *ans = new ListNode(-1);\r\n        ListNode *p = ans;\r\n        p->next = head;\r\n        while (head && head->next) {\r\n            ListNode *q = head->next;\r\n\r\n            ListNode *tmp = q->next;\r\n            q->next = head;\r\n            head->next = tmp;\r\n\r\n            p->next = q;\r\n            head = head->next;\r\n            p = q->next;\r\n        }\r\n        return ans->next;\r\n    }\r\n};\r\n````\r\nPython\r\n````python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        ans = ListNode(-1)\r\n        p = ans\r\n        ans.next = head\r\n        while head and head.next:\r\n            q = head.next\r\n\r\n            tmp = q.next\r\n            q.next = head\r\n            head.next = tmp\r\n\r\n            p.next = q\r\n            head = head.next\r\n            p = q.next\r\n        return ans.next\r\n````\r\n## æ—¶ç©ºå¤æ‚åº¦\r\næ—¶é—´å¤æ‚åº¦ï¼š$O(N)$\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193109905","body":"## æ€è·¯\r\næ‰¾åˆ°é“¾è¡¨çš„ä¸­é—´èŠ‚ç‚¹ï¼Œè¿™æ ·ä¸­é—´èŠ‚ç‚¹çš„å·¦è¾¹å°±æ˜¯å·¦å­æ ‘ï¼Œå³è¾¹å°±æ˜¯å³å­æ ‘ï¼ŒåŒæ—¶æŒ‰ç…§ç›¸åŒçš„æ–¹æ³•é€’å½’å·¦å­æ ‘å’Œå³å­æ ‘ï¼Œè¿™æ ·å³å¯æ„æˆä¸€é¢—äºŒå‰æ ‘ã€‚\r\n## ä»£ç \r\nC++\r\n````cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\nprivate:\r\n    ListNode *get_mid(ListNode *left, ListNode *right) {\r\n        ListNode *fast = left, *slow = left;\r\n        while (fast != right && fast->next != right) {\r\n            fast = fast->next->next;\r\n            slow = slow->next;\r\n        }\r\n        return slow;\r\n    }\r\n    TreeNode *build_tree(ListNode *left, ListNode *right) {\r\n        if (left == right) {\r\n            return nullptr;\r\n        }\r\n        ListNode *mid = get_mid(left, right);\r\n        TreeNode *ans = new TreeNode(mid->val);\r\n        ans->left = build_tree(left, mid);\r\n        ans->right = build_tree(mid->next, right);\r\n        return ans;\r\n    }\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        return build_tree(head, nullptr);\r\n    }\r\n};\r\n````\r\nPython\r\n````python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        def get_mid(left, right):\r\n            fast, slow = left, left\r\n            while fast != right and fast.next != right:\r\n                fast = fast.next.next\r\n                slow = slow.next\r\n            return slow\r\n        def build_tree(left, right):\r\n            if (left == right):\r\n                return None\r\n            mid = get_mid(left, right)\r\n            ans = TreeNode(mid.val)\r\n            ans.left = build_tree(left, mid)\r\n            ans.right = build_tree(mid.next, right)\r\n            return ans\r\n        return build_tree(head, None)\r\n````\r\n## æ—¶ç©ºå¤æ‚åº¦\r\næ¯æ¬¡æ‰¾é“¾è¡¨ä¸­é—´èŠ‚ç‚¹çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(N)$ï¼Œæ ¹æ®ä¸»å®šç†å¯çŸ¥ï¼Œæ€»çš„æ—¶é—´å¤æ‚åº¦ï¼š$O(NlogN)$\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193254191","body":"## æ€è·¯\r\né”™çš„äººè¿Ÿæ—©ä¼šèµ°æ•£ï¼Œè€Œå¯¹çš„äººè¿Ÿæ—©ä¼šç›¸é€¢ã€‚\r\n## ä»£ç \r\nC++\r\n````cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        ListNode *tmpA = headA, *tmpB = headB;\r\n        while (tmpA != tmpB) {\r\n            tmpA = tmpA == nullptr ? headB : tmpA->next;\r\n            tmpB = tmpB == nullptr ? headA : tmpB->next;\r\n        }\r\n        return tmpA;\r\n    }\r\n};\r\n````\r\nPython\r\n````python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        tmpA, tmpB = headA, headB\r\n        while tmpA != tmpB:\r\n            tmpA = tmpA.next if tmpA else headB\r\n            tmpB = tmpB.next if tmpB else headA\r\n        return tmpA\r\n        \r\n````\r\n## æ—¶ç©ºå¤æ‚åº¦\r\næ—¶é—´å¤æ‚åº¦ï¼š$O(N + M)$ï¼ŒN å’Œ Måˆ†åˆ«ä¸ºä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194100786","body":"## æ€è·¯\r\n\r\npass\r\n\r\n## ä»£ç \r\n\r\nC++\r\n\r\n````cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        ListNode *fast = head, *slow = head;\r\n        bool flag = false;\r\n        while (fast && fast->next) {\r\n            fast = fast->next->next;\r\n            slow = slow->next;\r\n            if (fast == slow) {\r\n                flag = true;\r\n                break;\r\n            }\r\n        }\r\n        if (flag) {\r\n            fast = head;\r\n            while (fast != slow) {\r\n                fast = fast->next;\r\n                slow = slow->next;\r\n            }\r\n            return slow;\r\n        }\r\n        return nullptr;\r\n    }\r\n};\r\n````\r\n\r\nPython\r\n\r\n````python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        fast, slow = head, head\r\n        flag = False\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            if fast == slow:\r\n                flag = True\r\n                break\r\n        if flag:  \r\n            fast = head\r\n            while fast != slow:\r\n                fast = fast.next\r\n                slow = slow.next\r\n            return fast\r\n        return None\r\n````\r\n\r\n## æ—¶ç©ºå¤æ‚åº¦\r\n\r\næ—¶é—´å¤æ‚åº¦ï¼š$O(N)$\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195528460","body":"## æ€è·¯\r\n\r\npass\r\n\r\n## ä»£ç \r\n\r\nC++\r\n\r\n````cpp\r\nstruct DLinkedNode {\r\n    int key, value;\r\n    DLinkedNode *prev;\r\n    DLinkedNode *next;\r\n    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}\r\n    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}\r\n};\r\n\r\nclass LRUCache {\r\nprivate:\r\n    unordered_map<int, DLinkedNode*> cache;\r\n    DLinkedNode *head;\r\n    DLinkedNode *tail;\r\n    int size;\r\n    int capacity;\r\npublic:\r\n    LRUCache(int _capacity): capacity(_capacity), size(0) {\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head->next = tail;\r\n        tail->prev = head;\r\n    }\r\n    \r\n    int get(int key) {\r\n        if (!cache.count(key)) {\r\n            return -1;\r\n        }\r\n        DLinkedNode *node = cache[key];\r\n        moveToHead(node);\r\n        return node->value;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if (!cache.count(key)) {\r\n            DLinkedNode *node = new DLinkedNode(key, value);\r\n            cache[key] = node;\r\n            addToHead(node);\r\n            ++size;\r\n            if (size > capacity) {\r\n                DLinkedNode *removed = removeTail();\r\n                cache.erase(removed->key);\r\n                delete removed;\r\n                --size;\r\n            }\r\n        } else {\r\n            DLinkedNode *node = cache[key];\r\n            node->value = value;\r\n            moveToHead(node);\r\n        }\r\n    }\r\n\r\n    void addToHead(DLinkedNode *node) {\r\n        node->prev = head;\r\n        node->next = head->next;\r\n        head->next->prev = node;\r\n        head->next = node;\r\n    }\r\n\r\n    void removeNode(DLinkedNode *node) {\r\n        node->prev->next = node->next;\r\n        node->next->prev = node->prev;\r\n    }\r\n\r\n    void moveToHead(DLinkedNode *node) {\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n\r\n    DLinkedNode *removeTail() {\r\n        DLinkedNode *node = tail->prev;\r\n        removeNode(node);\r\n        return node;\r\n    }\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache* obj = new LRUCache(capacity);\r\n * int param_1 = obj->get(key);\r\n * obj->put(key,value);\r\n */\r\n````\r\n\r\nPython\r\n\r\n````python\r\nclass LRUCache(collections.OrderedDict):\r\n\r\n    def __init__(self, capacity: int):\r\n        super().__init__()\r\n        self.capacity = capacity\r\n\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self:\r\n            return -1\r\n        self.move_to_end(key)\r\n        return self[key]\r\n\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self:\r\n            self.move_to_end(key)\r\n        self[key] = value\r\n        if len(self) > self.capacity:\r\n            self.popitem(last=False)\r\n\r\n\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n````\r\n\r\n## æ—¶ç©ºå¤æ‚åº¦\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196624976","body":"## æ€è·¯\r\n\r\nç»å…¸é¢˜ï¼Œæ‰¾åˆ°å·¦å­æ ‘å’Œå³å­æ ‘æœ€é«˜çš„æ ‘å°±æ˜¯æ ‘çš„é«˜åº¦ã€‚\r\n\r\n## ä»£ç \r\n\r\nC++\r\n\r\n````cpp\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root:\r\n            return 0\r\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\r\n````\r\n\r\nPython\r\n\r\n````python\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if (!root) {\r\n            return 0;\r\n        }\r\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\r\n    }\r\n};\r\n````\r\n\r\n## æ—¶ç©ºå¤æ‚åº¦\r\n\r\næ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\n\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(height)$\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198249589","body":"## æ€è·¯\r\n\r\npass\r\n\r\n## ä»£ç \r\n\r\nC++\r\n\r\n````cpp\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        if (!p && !q) {\r\n            return true;\r\n        }\r\n        if (!p || !q) {\r\n            return false;\r\n        }\r\n        if (p->val != q->val) {\r\n            return false;\r\n        }\r\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\r\n    }\r\n};\r\n````\r\n\r\nPython\r\n\r\n````python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        if not p or not q:\r\n            return False\r\n        if p.val != q.val:\r\n            return False\r\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n````\r\n\r\n## æ—¶ç©ºå¤æ‚åº¦\r\n\r\næ—¶é—´å¤æ‚åº¦ï¼š$O(min(n, m))$\r\n\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(min(n, m))$\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199182012","body":"## æ€è·¯\r\n\r\npass\r\n\r\n## ä»£ç \r\n\r\nC++\r\n\r\n````cpp\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\nprivate:\r\n    int sum;\r\n    void helper(TreeNode *root, int tmp) {\r\n        if (!root) {\r\n            return;\r\n        }\r\n        tmp = tmp * 10 + root->val;\r\n        if (!root->left && !root->right) {\r\n            sum += tmp;\r\n            return;\r\n        }\r\n        helper(root->left, tmp);\r\n        helper(root->right, tmp);\r\n    }\r\npublic:\r\n    int sumNumbers(TreeNode* root) {\r\n        if (!root) {\r\n            return 0;\r\n        }\r\n        sum = 0;\r\n        helper(root, 0);\r\n        return sum;\r\n        \r\n    }\r\n};\r\n````\r\n\r\nPython\r\n\r\n````python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\r\n        ans = 0\r\n        def helper(root, tmp):\r\n            nonlocal ans\r\n            if not root:\r\n                return\r\n            tmp = tmp * 10 + root.val\r\n            if not root.left and not root.right:\r\n                ans += tmp\r\n            helper(root.left, tmp)\r\n            helper(root.right, tmp)\r\n        helper(root, 0)\r\n        return ans\r\n````\r\n\r\n## æ—¶ç©ºå¤æ‚åº¦\r\n\r\næ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\n\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(n)$\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200151433","body":"## æ€è·¯\r\n\r\nBFSï¼Œä»å³å¾€å·¦è¿›å…¥é˜Ÿåˆ—ï¼Œæœ€åä¸€ä¸ªèŠ‚ç‚¹å°±æ˜¯æ»¡è¶³æ¡ä»¶çš„èŠ‚ç‚¹ã€‚\r\n\r\n## ä»£ç \r\n\r\nC++\r\n\r\n````cpp\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int findBottomLeftValue(TreeNode* root) {\r\n        queue<TreeNode *> que;\r\n        que.push(root);\r\n        TreeNode *node;\r\n        while (!que.empty()) {\r\n            int size = que.size();\r\n            for (int i = 0; i < size; ++i) {\r\n                node = que.front();\r\n                que.pop();\r\n                if (node->right) {\r\n                    que.push(node->right);\r\n                }\r\n                if (node->left) {\r\n                    que.push(node->left);\r\n                } \r\n            }\r\n        }\r\n        return node->val;\r\n    }\r\n};\r\n````\r\n\r\nPython\r\n\r\n````python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        que = [root]\r\n        while len(que):\r\n            size = len(que)\r\n            for i in range(size):\r\n                node = que.pop(0)\r\n                if node.right:\r\n                    que.append(node.right)\r\n                if node.left:\r\n                    que.append(node.left)\r\n        return node.val\r\n````\r\n\r\n## æ—¶ç©ºå¤æ‚åº¦\r\n\r\næ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\n\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(n)$\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200449180","body":"## æ€è·¯\r\n\r\npass\r\n\r\n## ä»£ç \r\n\r\nC++\r\n\r\n````cpp\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * };\r\n */\r\nclass Codec {\r\npublic:\r\n    void rserialize(TreeNode *root, string &str) {\r\n        if (!root) {\r\n            str += \"None,\";\r\n        } else {\r\n            str += to_string(root->val) + \",\";\r\n            rserialize(root->left, str);\r\n            rserialize(root->right, str);\r\n        }\r\n    }\r\n    // Encodes a tree to a single string.\r\n    string serialize(TreeNode* root) {\r\n        string ret;\r\n        rserialize(root, ret);\r\n        return ret;\r\n    }\r\n\r\n    TreeNode *rdeserialize(list<string> &dataArray) {\r\n        if (dataArray.front() == \"None\") {\r\n            dataArray.erase(dataArray.begin());\r\n            return nullptr;\r\n        }\r\n\r\n        TreeNode *root = new TreeNode(stoi(dataArray.front()));\r\n        dataArray.erase(dataArray.begin());\r\n        root->left = rdeserialize(dataArray);\r\n        root->right = rdeserialize(dataArray);\r\n        return root;\r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    TreeNode* deserialize(string data) {\r\n        list<string> dataArray;\r\n        string str;\r\n        for (auto &ch : data) {\r\n            if (ch == ',') {\r\n                dataArray.push_back(str);\r\n                str.clear();\r\n            } else {\r\n                str.push_back(ch);\r\n            }\r\n        }\r\n        if (!str.empty()) {\r\n            dataArray.push_back(str);\r\n            str.clear();\r\n        }\r\n        return rdeserialize(dataArray);\r\n    }\r\n};\r\n\r\n// Your Codec object will be instantiated and called as such:\r\n// Codec ser, deser;\r\n// TreeNode* ans = deser.deserialize(ser.serialize(root));\r\n````\r\n\r\nPython\r\n\r\n````python\r\n# Definition for a binary tree node.\r\n# class TreeNode(object):\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\nclass Codec:\r\n\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        s, queue = \"\", [root]\r\n        while queue:\r\n            root = queue.pop(0)\r\n            if root:\r\n                s += str(root.val)\r\n                queue.append(root.left)\r\n                queue.append(root.right)\r\n            else:\r\n                s += \"n\"\r\n            s += \" \"\r\n        return s\r\n        \r\n\r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        tree = data.split()\r\n        if tree[0] == \"n\":\r\n            return None\r\n        queue, root = [], TreeNode(int(tree[0]))\r\n        queue.append(root)\r\n        i = 1\r\n        while queue:\r\n            cur = queue.pop(0)\r\n            if not cur:\r\n                continue\r\n            cur.left = TreeNode(int(tree[i])) if tree[i] != 'n' else None\r\n            cur.right = TreeNode(int(tree[i + 1])) if tree[i + 1] != \"n\" else None\r\n            i += 2\r\n            queue.append(cur.left)\r\n            queue.append(cur.right)\r\n        return root\r\n        \r\n\r\n# Your Codec object will be instantiated and called as such:\r\n# ser = Codec()\r\n# deser = Codec()\r\n# ans = deser.deserialize(ser.serialize(root))\r\n````\r\n\r\n## æ—¶ç©ºå¤æ‚åº¦\r\n\r\næ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\n\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(n)$\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201195144","body":"## æ€è·¯\r\n\r\npass\r\n\r\n## ä»£ç \r\n\r\nC++\r\n\r\n````cpp\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\nprivate:\r\n    vector<pair<TreeNode *, pair<int, int>>> vec;\r\n    void helper(TreeNode *root, int level, int cols) {\r\n        if (!root) {\r\n            return;\r\n        }\r\n        vec.emplace_back(make_pair(root, make_pair(level, cols)));\r\n        helper(root->left, level + 1, cols - 1);\r\n        helper(root->right, level + 1, cols + 1);\r\n    }\r\n    void print() {\r\n        for (auto &it : vec) {\r\n            cout << it.first->val << \" (\" << it.second.first << \", \" << it.second.second << \")\" << endl;\r\n        }\r\n    }\r\npublic:\r\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\r\n        helper(root, 0, 0);\r\n        vector<vector<int>> ans;\r\n        sort(vec.begin(), vec.end(), [=](const pair<TreeNode *, pair<int, int>> x1, const pair<TreeNode *, pair<int, int>> x2) {\r\n            if (x1.second.second < x2.second.second) {\r\n                return true;\r\n            } else if (x1.second.second == x2.second.second) {\r\n                if (x1.second.first < x2.second.first) {\r\n                    return true;\r\n                } else if (x1.second.first == x2.second.first) {\r\n                    return x1.first->val < x2.first->val;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        });\r\n        int size = vec.size();\r\n        vector<int> tmp;\r\n        tmp.emplace_back(vec[0].first->val);\r\n        for (int i = 1; i < size; ++i) {\r\n            if (vec[i].second.second != vec[i - 1].second.second) {\r\n                ans.emplace_back(tmp);\r\n                tmp.clear();\r\n            }\r\n            tmp.emplace_back(vec[i].first->val);\r\n        }\r\n        ans.emplace_back(tmp);\r\n        return ans;\r\n    }\r\n};\r\n````\r\n\r\nPython\r\n\r\n````python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\r\n        nodes = list()\r\n        def dfs(node, row, col):\r\n            if not node:\r\n                return\r\n            nodes.append((col, row, node.val))\r\n            dfs(node.left, row + 1, col - 1)\r\n            dfs(node.right, row + 1, col + 1)\r\n        dfs(root, 0, 0)\r\n        nodes.sort()\r\n        ans, lastcol = list(), float(\"-inf\")\r\n        for col, ros, value in nodes:\r\n            if col != lastcol:\r\n                lastcol = col\r\n                ans.append(list())\r\n            ans[-1].append(value)\r\n        return ans\r\n````\r\n\r\n## æ—¶ç©ºå¤æ‚åº¦\r\n\r\næ—¶é—´å¤æ‚åº¦ï¼š$O(nlogn)$\r\n\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(nlogn)$\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202636640","body":"## æ€è·¯\r\n\r\npass\r\n\r\n## ä»£ç \r\n\r\nC++\r\n\r\n````cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> twoSum(vector<int>& nums, int target) {\r\n        unordered_map<int, int> ump;\r\n        int size = nums.size();\r\n        for (int i = 0; i < size; ++i) {\r\n            int tmp = target - nums[i];\r\n            if (ump.find(tmp) == ump.end()) {\r\n                ump[nums[i]] = i;\r\n            } else {\r\n                return {i, ump[tmp]};\r\n            }\r\n        }\r\n        return {};\r\n    }\r\n};\r\n````\r\n\r\nPython\r\n\r\n````python\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        ump = dict()\r\n        size = len(nums)\r\n        for i in range(size):\r\n            tmp = target - nums[i]\r\n            if tmp not in ump:\r\n                ump[nums[i]] = i\r\n            else:\r\n                return [ump[tmp], i]\r\n        return list()\r\n````\r\n\r\n## æ—¶ç©ºå¤æ‚åº¦\r\n\r\næ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\n\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(n)$\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203973347","body":"## æ€è·¯\r\n\r\npass\r\n\r\n## ä»£ç \r\n\r\nC++\r\n\r\n````cpp\r\nstruct cmp {\r\n  bool operator()(const pair<int, int> &a, const pair<int, int> &b) {\r\n    return a.second > b.second;\r\n  }\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> topKFrequent(vector<int>& nums, int k) {\r\n        unordered_map<int, int> occ;\r\n        for (auto &v : nums) {\r\n            ++occ[v];\r\n        }\r\n        priority_queue<pair<int, int>, vector<pair<int, int>>, cmp> q;\r\n        for (auto &[num, count] : occ) {\r\n            if (q.size() == k) {\r\n                if (q.top().second < count) {\r\n                    q.pop();\r\n                    q.emplace(num, count);\r\n                }\r\n            } else {\r\n                q.emplace(num, count);\r\n            }\r\n        }\r\n        vector<int> ret;\r\n        while (!q.empty()) {\r\n            ret.emplace_back(q.top().first);\r\n            q.pop();\r\n        }\r\n        return ret;\r\n    }\r\n};\r\n````\r\n\r\nPython\r\n\r\n````python\r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        import heapq\r\n        ump = dict()\r\n        for i in range(len(nums)):\r\n            ump[nums[i]] = ump.get(nums[i], 0) + 1\r\n        pri_que = []\r\n        for key, freq in ump.items():\r\n            heapq.heappush(pri_que, (freq, key))\r\n            if len(pri_que) > k:\r\n                heapq.heappop(pri_que)\r\n        result = [0] * k\r\n        for i in range(k - 1, -1, -1):\r\n            result[i] = heapq.heappop(pri_que)[1]\r\n        return result\r\n````\r\n\r\n## æ—¶ç©ºå¤æ‚åº¦\r\n\r\næ—¶é—´å¤æ‚åº¦ï¼š$O(nlogk)$\r\n\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(nlogk)$\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205269576","body":"````cpp\r\nclass Solution {\r\npublic:\r\n    int numberOfBoomerangs(vector<vector<int>>& points) {\r\n        int ans = 0;\r\n        for (auto &p : points) {\r\n            unordered_map<int, int> cnt;\r\n            for (auto &q : points) {\r\n                int dist = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\r\n                ++cnt[dist];\r\n            }\r\n            for (auto &[_, m] : cnt) {\r\n                ans += m * (m - 1);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206587582","body":"````cpp\r\nclass Solution {\r\npublic:\r\n    int lengthOfLongestSubstring(string s) {\r\n      int size = s.size();\r\n      unordered_set<char> seen;\r\n      int res = 0, temp = -1;\r\n      for (int i = 0; i < size; ++i) {\r\n        if (i != 0) {\r\n          seen.erase(s[i - 1]);\r\n        }\r\n        while (temp + 1 < size && !seen.count(s[temp + 1])) {\r\n          seen.insert(s[temp + 1]);\r\n          ++temp;\r\n        }\r\n        res = max(res, temp - i + 1);\r\n      }\r\n      return res;\r\n    }\r\n};\r\n````","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207431402","body":"````cpp\r\nint solve(vector<int>& nums, int k) {\r\n    if (nums.empty()) {\r\n        return -1;\r\n    }\r\n    int target = 0;\r\n    for (int num : nums) {\r\n        target = (target + num) % k;\r\n    }\r\n    if (target == 0) {\r\n        return 0;\r\n    }\r\n    unordered_map<int, int> memo;\r\n    memo[0] = 0;\r\n    int pos = 0, now = 0, ans = nums.size();\r\n    for (int num : nums) {\r\n        ++pos;\r\n        now = (now + num) % k;\r\n        if (memo.count((now + k - target) % k)) {\r\n            ans = min(ans, pos - memo[(now + k - target) % k]);\r\n        }\r\n        memo[now] = pos;\r\n    }\r\n    return ans == nums.size() ? -1 : ans;\r\n}\r\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208106047","body":"````cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* middleNode(ListNode* head) {\r\n        ListNode *fast = head, *slow = head;\r\n        while (fast && fast->next) {\r\n            fast = fast->next->next;\r\n            slow = slow->next;\r\n        }\r\n        return slow;\r\n    }\r\n};\r\n````\r\n````python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def middleNode(self, head: ListNode) -> ListNode:\r\n        fast, slow = head, head\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n        return slow\r\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209403086","body":"````cpp\r\nclass Solution {\r\npublic:\r\n    int removeDuplicates(vector<int>& nums) {\r\n        int index = 1;\r\n        int size = nums.size();\r\n        for (int i = 1; i < size; ++i) {\r\n            if (nums[i] != nums[i - 1]) {\r\n                nums[index++] = nums[i];\r\n            }\r\n        }\r\n        return index;\r\n    }\r\n};\r\n````\r\n````python\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        index = 1\r\n        for i in range(1, len(nums)):\r\n            if nums[i] != nums[i - 1]:\r\n                nums[index] = nums[i]\r\n                index += 1\r\n        return index\r\n````","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"revisegoal":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185633040","body":"## è¿›ä½å¤„ç†\nä»ä½ä½å¾€é«˜ä½ç›¸åŠ ï¼Œå¹¶å¤„ç†è¿›ä½ï¼Œå¯ä»¥ç”¨kåŒæ—¶å­˜å‚¨è¿›ä½ä¿¡æ¯ï¼Œæ¯æ¬¡è¿­ä»£æœ‰ k = (num[i] + k) / 10\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int len = num.length;\n        for (int i = len - 1; i >= 0; i--) {\n            res.add(0, (num[i] + k) % 10);\n            k = (num[i] + k) / 10;\n        }\n        while (k != 0) {\n            res.add(0, k % 10);\n            k /= 10;\n        }\n        return res;\n    }\n}\n```\n\n```go\nfunc addToArrayForm(num []int, k int) []int {\n    res := make([]int, 0)\n    for i := len(num) - 1; i >= 0; i-- {\n        res = append(res, (num[i] + k) % 10)\n        k = (num[i] + k) / 10\n    }\n    for k != 0 {\n        res = append(res, k % 10)\n        k /= 10\n    }\n    for i, j := 0, len(res) - 1; i < j; i, j = i + 1, j - 1 {\n        res[i], res[j] = res[j], res[i]\n    }\n    return res\n}\n```\n- time: O(max(len(num), digit(k))ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯å’Œçš„é•¿åº¦nï¼Œæ˜¯numå’Œkæœ€å¤§çš„é‚£ä¸ªï¼ˆå¯èƒ½ä¼šæ˜¯max(len(num), digit(k)) + Cï¼Œä¸è¿‡å¤§Oè¡¨ç¤ºæ³•å¿½ç•¥å¸¸æ•°é¡¹Cï¼Œå¯ä»¥ä¸åšè®¨è®ºï¼‰\n- space: O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185703099","body":"## éå†\nå·¦å³éå†æ•°ç»„\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] res = new int[len];\n        int pre = Integer.MIN_VALUE / 2;\n        for (int i = 0; i < len; i++) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            res[i] = i - pre;\n        }\n        pre = Integer.MAX_VALUE;\n        for (int i = len - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            res[i] = Math.min(res[i], pre - i);\n        }\n        return res;\n    }\n}\n```\n```go\nfunc shortestToChar(s string, c byte) []int {\n    const (\n        INT_MAX = int(^uint(0) >> 1)\n        INT_MIN = ^INT_MAX\n    )\n    res := make([]int, 0)\n    pre := INT_MIN / 2\n    for i := 0; i < len(s); i++ {\n        if s[i] == c {\n            pre = i\n        }\n        res = append(res, i - pre)\n    }\n    pre = INT_MAX\n    for i := len(s) - 1; i >= 0; i-- {\n        if s[i] == c {\n            pre = i\n        }\n        tmp := pre - i\n        if tmp < res[i] {\n            res[i] = tmp\n        }  \n    }\n    return res\n}\n```\n- time: O(n)\n- space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186483335","body":"## æ ˆ\næ•°ç»„å®ç°æ ˆ\n```java\nclass CustomStack {\n    int[] stack;\n    int top = 0;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if (top < stack.length) {\n            stack[top++] = x;\n        }\n    }\n    \n    public int pop() {\n        return top != 0 ? stack[--top] : -1;\n    }\n    \n    public void increment(int k, int val) {\n        for (int i = 0; i < k && i < top; i++) {\n            stack[i] += val;\n        }\n    }\n}\n```\n```go\ntype CustomStack struct {\n    stack []int\n    top int\n}\n\n\nfunc Constructor(maxSize int) CustomStack {\n    return CustomStack{\n        stack: make([]int, maxSize, maxSize),\n    }\n}\n\n\nfunc (this *CustomStack) Push(x int)  {\n    if this.top >= len(this.stack) {\n        return\n    }\n    this.stack[this.top] = x\n    this.top++\n}\n\n\nfunc (this *CustomStack) Pop() int {\n    if this.top == 0 {\n        return -1\n    }\n    this.top--\n    return this.stack[this.top]\n}\n\n\nfunc (this *CustomStack) Increment(k int, val int)  {\n    for i := 0; i < k && i < this.top; i++ {\n        this.stack[i] += val\n    }\n}\n\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * obj := Constructor(maxSize);\n * obj.Push(x);\n * param_2 := obj.Pop();\n * obj.Increment(k,val);\n */\n```\n- time: push, pop = O(1), increment = O(min(k, top))\n- space: O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187662435","body":"## æ ˆ\nè¾…åŠ©æ ˆï¼Œè§£ç é¡ºåºæ˜¯ç”±å†…å‘å¤–ï¼Œè¶Šé‡Œé¢çš„æ‹¬å·è¶Šå…ˆè§£ç ï¼Œç¬¦åˆæ ˆå…ˆå…¥åå‡ºåŸåˆ™\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Deque<String> resStack = new LinkedList<>();\n        Deque<Integer> multiStack = new LinkedList<>();\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        for (char ch : s.toCharArray()) {\n            if (ch == '[') {\n                multiStack.push(multi);\n                multi = 0;\n                resStack.push(res.toString());\n                res = new StringBuilder();\n            } else if (ch == ']') {\n                StringBuilder tmp = new StringBuilder();\n                tmp.append(resStack.pop());\n                int repeat = multiStack.pop();\n                for (int i = 0; i < repeat; i++) {\n                    tmp.append(res);\n                }\n                res = tmp;\n            } else if (Character.isDigit(ch)) {\n                multi = multi * 10 + ch - '0';\n            } else {\n                res.append(ch);\n            }\n        }\n        return res.toString();\n    }\n}\n```\n- time: O(n)ï¼Œnä¸ºå­—ç¬¦ä¸²é•¿åº¦\n- space: æ ˆç©ºé—´ï¼ŒO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189189933","body":"## æ ˆ\nåŒæ ˆå®ç°é˜Ÿåˆ—\n```java\nclass MyQueue {\n    Deque<Integer> pushStack = new LinkedList<>();\n    Deque<Integer> popStack = new LinkedList<>();\n    public MyQueue() {\n\n    }\n    \n    public void push(int x) {\n        while (!popStack.isEmpty()) {\n            pushStack.push(popStack.pop());\n        }\n        pushStack.push(x);\n    }\n    \n    public int pop() {\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.pop();\n    }\n    \n    public int peek() {\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.peek();\n    }\n    \n    public boolean empty() {\n        return pushStack.isEmpty() && popStack.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n- time: O(n)\n- space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190341873","body":"## è®¡æ•°\néå†æ•°ç»„ï¼Œè‹¥å’Œæœ‰åºæ•°ç»„expectè®¡æ•°ç›¸åŒï¼Œåˆ™è¯´æ˜æ­¤æ—¶å¯åˆ†å—ï¼Œres++\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap<>();\n        int res = 0;\n        int nonzero = 0;\n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n        for (int i = 0; i < arr.length; i++) {\n            int x = arr[i], y = expect[i];\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if (count.get(x) == 0) {\n                nonzero--;\n            }\n            if (count.get(x) == 1) {\n                nonzero++;\n            }\n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if (count.get(y) == 0) {\n                nonzero--;\n            }\n            if (count.get(y) == -1) {\n                nonzero++;\n            }\n            if (nonzero == 0) {\n                res++;\n            }\n        }\n        return res;\n    }\n}\n```\n- time: O(nlogn)ï¼Œæ’åº\n- space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191624390","body":"## é“¾è¡¨æ“ä½œ\nå…ˆéå†é“¾è¡¨ï¼Œå¾—åˆ°é“¾è¡¨å°¾tailå’Œé“¾è¡¨é•¿åº¦lenï¼Œè‹¥k % len == 0è¯´æ˜ç§»åŠ¨çš„é•¿åº¦ä¸ºé“¾è¡¨é•¿åº¦çš„å€æ•°ï¼Œå³ä¸ç§»åŠ¨ç›´æ¥è¿”å›headï¼Œå¦åˆ™å°¾èŠ‚ç‚¹è¿æ¥å¤´èŠ‚ç‚¹ï¼Œæ–°å°¾èŠ‚ç‚¹ç¦»æ—§å¤´èŠ‚ç‚¹len - k % len - 1ï¼Œæ‰¾åˆ°æ–°å°¾èŠ‚ç‚¹newTailï¼Œåˆ™æ–°å¤´èŠ‚ç‚¹newHead = newTail.nextï¼Œå¹¶æ–­å¼€å°¾èŠ‚ç‚¹åçš„è¿æ¥newTail.next = nullï¼Œè¿”å›æ–°å¤´èŠ‚ç‚¹\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null) {\n            return null;\n        }\n        int len = 1;\n        ListNode tail = head;\n        while (tail.next != null) {\n            tail = tail.next;\n            len++;\n        }\n        k %= len;\n        if (k == 0) {\n            return head;\n        }\n        tail.next = head;\n        ListNode newTail = head;\n        for (int i = 0; i < k; i++) {\n            newTail = newTail.next;\n        }\n        ListNode newHead = newTail.next;\n        newTail.next = null;\n        return newHead;\n    }\n}\n```\n## åŒæŒ‡é’ˆ\n```go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc rotateRight(head *ListNode, k int) *ListNode {\n    if head == nil {\n        return nil\n    }\n    tail := head\n    len := 1\n    for tail.Next != nil {\n        tail = tail.Next\n        len++\n    }\n    k %= len\n    if k == 0 {\n        return head\n    }\n    next := head\n    for k != 0 {\n        next = next.Next\n        k--\n    }\n    pre := head\n    for next.Next != nil {\n        pre = pre.Next\n        next = next.Next\n    }\n    newHead := pre.Next\n    pre.Next = nil\n    next.Next = head\n    return newHead\n}\n```\n- time: O(n)\n- space: O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193144320","body":"## äºŒåˆ† or å¿«æ…¢æŒ‡é’ˆ\né€’å½’æ‰¾ä¸­ç‚¹ä½œä¸ºæ ¹èŠ‚ç‚¹åˆ›å»ºäºŒå‰æ ‘ï¼Œæœ‰ä¸¤ç§æ–¹å¼ï¼š\n1. æ•°ç»„äºŒåˆ†ï¼Œç©ºé—´æ¢æ—¶é—´\n2. æ¯æ¬¡é€’å½’éƒ½ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆæ‰¾ä¸­ç‚¹\n\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        List<Integer> list = new ArrayList<>();\n        while (head != null) {\n            list.add(head.val);\n            head = head.next;\n        }\n        return buildTree(0, list.size() - 1, list);\n    }   \n\n    TreeNode buildTree(int left, int right, List<Integer> list) {\n        if (left > right) {\n            return null;\n        }\n        int mid = left + (right - left + 1) / 2;\n        TreeNode root = new TreeNode(list.get(mid));\n        root.left = buildTree(left, mid - 1, list);\n        root.right = buildTree(mid + 1, right, list);\n        return root;\n    }\n}\n```\n```go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc sortedListToBST(head *ListNode) *TreeNode {\n    list := make([]int, 0)\n    for head != nil {\n        list = append(list, head.Val)\n        head = head.Next\n    }\n    return buildTree(0, len(list) - 1, list)\n}\n\nfunc buildTree(left int, right int, list []int) *TreeNode {\n    if left > right {\n        return nil\n    }\n    mid := left + (right - left) / 2\n    root := &TreeNode{Val: list[mid]}\n    root.Left = buildTree(left, mid - 1, list)\n    root.Right = buildTree(mid + 1, right, list)\n    return root\n}\n```\n## å¿«æ…¢æŒ‡é’ˆ\n```go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc sortedListToBST(head *ListNode) *TreeNode {\n    return buildTree(head, nil)\n}\n\nfunc buildTree(left, right *ListNode) *TreeNode {\n    if left == right {\n        return nil\n    }\n    mid := getMid(left, right)\n    root := &TreeNode{Val: mid.Val}\n    root.Left = buildTree(left, mid)\n    root.Right = buildTree(mid.Next, right)\n    return root\n}\n\nfunc getMid(left, right *ListNode) *ListNode {\n    slow, fast := left, left; \n    for fast != right && fast.Next != right {\n        slow = slow.Next;\n        fast = fast.Next.Next\n    }\n    return slow\n}\n```\n- æ—¶é—´ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193248180","body":"## åŒæŒ‡é’ˆ\nä»¤pA = headAï¼ŒpB = headBï¼Œéå†ç›´è‡³ä¸ºnullæ—¶pA = headBï¼ŒpB = headAï¼Œè‹¥ç›¸äº¤ä¸¤ä¸ªæŒ‡é’ˆå°†ä¼šåœ¨äº¤ç‚¹ä¼šåˆï¼ˆèµ°è¿‡çš„è·¯ç¨‹ç›¸åŒï¼‰ï¼Œå¦åˆ™éå†è‡³é“¾è¡¨å°¾è¿”å›null\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode pA = headA, pB = headB;\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n```\n```go/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\n    if headA == nil || headB == nil {\n        return nil\n    }\n    pA, pB := headA, headB\n    for pA != pB {\n        if pA == nil {\n            pA = headB\n        } else {\n            pA = pA.Next\n        }\n        if pB == nil {\n            pB = headA\n        } else {\n            pB = pB.Next\n        }\n    }\n    return pA\n}\n```\n- time: O(n)\n- space: O(1)\n## å“ˆå¸Œè¡¨\néå†ä¸€ä¸ªèŠ‚ç‚¹å¹¶å°†æ‰€æœ‰é‡åˆ°çš„èŠ‚ç‚¹å­˜è¿›å“ˆå¸Œè¡¨ä¸­ï¼Œéå†å¦ä¸€ä¸ªèŠ‚ç‚¹æ¯æ¬¡åˆ¤æ–­æ˜¯å¦å­˜åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œæ˜¯åˆ™ä¸ºäº¤å‰ç‚¹ï¼Œæ—¶ç©ºå¤æ‚åº¦çš†ä¸ºO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194142611","body":"## å¿«æ…¢æŒ‡é’ˆ\n- slowèµ°ä¸€æ­¥ï¼Œfastèµ°ä¸¤æ­¥ï¼Œè‹¥å­˜åœ¨ç¯åˆ™ä¸€å®šä¼šç›¸äº¤ï¼Œè®¾äº¤ç‚¹ç”±å¦‚ä¸‹å›¾bå’Œcç›¸äº¤å½¢æˆ\n- fastæŒ‡é’ˆèµ°è¿‡çš„é•¿åº¦ä¸º a + b + n(b + c) = a + (n + 1) b + nc\n- slowæŒ‡é’ˆèµ°è¿‡çš„é•¿åº¦ä¸º a + b\n- fastæŒ‡é’ˆèµ°è¿‡çš„é•¿åº¦æ˜¯slowçš„ä¸¤å€\n- a + (n + 1)b + nc  = 2(a + b)\n- a = c  + (n - 1)(b + c)\n- æ‰€ä»¥è‹¥pæŒ‡å‘headï¼ŒslowæŒ‡å‘bå’Œcçš„äº¤ç‚¹ï¼ŒåŒæ—¶ç§»åŠ¨æŒ‡é’ˆåˆ™å½“pèµ°äº†aè·ç¦»å³èµ°åˆ°ç¯å…¥å£ç‚¹æ—¶ï¼Œslowä¹Ÿèµ°è¿‡c  + (n - 1)(b + c)å³é¥¶äº†(n - 1)åœˆåèµ°äº†cè·ç¦»ä¹Ÿåˆ°è¾¾æ¢å…¥å£ç‚¹\n\n![](https://assets.leetcode-cn.com/solution-static/142/142_fig1.png)\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode fast = head, slow = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) {\n                ListNode p = head;\n                while (p != slow) {\n                    p = p.next;\n                    slow = slow.next;\n                }\n                return p;\n            }\n        }\n        return null;\n    }\n}\n```\n```go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc detectCycle(head *ListNode) *ListNode {\n    slow, fast := head, head\n    for fast != nil && fast.Next != nil {\n        slow = slow.Next\n        fast = fast.Next.Next\n        if slow == fast {\n            p := head\n            for p != slow {\n                p = p.Next\n                slow = slow.Next\n            }\n            return p\n        }\n    }\n    return nil\n}\n```\n- time: O(n)ï¼Œslowèµ°è¿‡çš„é•¿åº¦ä¸è¶…è¿‡é“¾è¡¨æ€»é•¿åº¦\n- space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195558833","body":"## åŒå‘é“¾è¡¨ + å“ˆå¸Œè¡¨\ngetå’Œputçš„å¹³å‡å¤æ‚åº¦ä¸ºO(1)ä¸éš¾è”æƒ³åˆ°å“ˆå¸Œè¡¨ï¼Œè€Œå®ç°LRUè¿˜éœ€è¦ç»´æŠ¤ä¸€ä¸ªåŒå‘é“¾è¡¨ï¼Œæˆ‘ä»¬ç§©åºæ¯æ¬¡æ·»åŠ æˆ–ä¿®æ”¹é“¾è¡¨æ—¶å°†å…ƒç´ æ”¾åœ¨è¡¨å¤´ï¼Œå½“å¤§äºå…ƒç´ æ•°é‡å¤§äºå®¹é‡æ—¶å°†è¡¨å°¾å…ƒç´ ç§»é™¤\n```java\nclass LRUCache {\n    class DListNode {\n        int key, value;\n        DListNode pre;\n        DListNode next;\n\n        DListNode() {}\n\n        DListNode(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n\n    int size, capacity;\n    Map<Integer, DListNode> cache = new HashMap<>();\n    DListNode head, tail;\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        size = 0;\n        head = new DListNode();\n        tail = new DListNode();\n        head.next = tail;\n        tail.pre = head;\n    }\n    \n    public int get(int key) {\n        DListNode node = cache.get(key);\n        if (node == null) {\n            return -1;\n        }\n        moveToHead(node);\n        return node.value;\n    }\n    \n    public void put(int key, int value) {\n        DListNode node = cache.get(key);\n        if (node == null) {\n            node = new DListNode(key, value);\n            cache.put(key, node);\n            addToHead(node);\n            size++;\n            if (size > capacity) {\n                DListNode removedTail = removeTail();\n                cache.remove(removedTail.key);\n                removeNode(removedTail);\n                size--;\n            }\n        } else {\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    void addToHead(DListNode node) {\n       node.pre = head;\n       node.next = head.next;\n       head.next.pre = node;\n       head.next = node;\n    }\n\n    DListNode removeTail() {\n        DListNode removedTail = tail.pre;\n        removeNode(removedTail);\n        return removedTail;\n    }\n\n    void moveToHead(DListNode node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    void removeNode(DListNode node) {\n        node.pre.next = node.next;\n        node.next.pre = node.pre;\n    }\n}\n```\n```go\ntype LRUCache struct {\n    head, tail *ListNode1\n    cap, size int\n    nodeMap map[int]*ListNode1\n}\n\ntype ListNode1 struct {\n    key, val int\n    pre, next *ListNode1\n}\n\n\nfunc Constructor(capacity int) LRUCache {\n    head, tail := &ListNode1{}, &ListNode1{}\n    head.next = tail\n    tail.pre = head\n    return LRUCache{\n        head: head,\n        tail: tail,\n        cap: capacity,\n        nodeMap: make(map[int]*ListNode1),\n    }\n}\n\nfunc (this *LRUCache) Get(key int) int {\n    if node, ok := this.nodeMap[key]; ok {\n        this.moveToHead(node)        \n        return node.val\n    }\n    return -1\n}\n\n\nfunc (this *LRUCache) Put(key int, value int)  {\n    if node, ok := this.nodeMap[key]; ok{\n        node.val = value\n        this.moveToHead(node)\n        return\n    }\n    node := &ListNode1{key: key, val: value}\n    this.nodeMap[key] = node\n    this.addToHead(node)\n    if this.size == this.cap {\n        removedTail := this.removeTail()\n        delete(this.nodeMap, removedTail.key)\n    } else {\n        this.size++\n    }\n}\n\nfunc (this *LRUCache) removeNode(node *ListNode1) {\n    node.pre.next = node.next\n    node.next.pre = node.pre\n}\n\nfunc (this *LRUCache) moveToHead(node *ListNode1) {\n    this.removeNode(node)\n    this.addToHead(node)\n}\n\nfunc (this *LRUCache) addToHead(node *ListNode1) {\n    node.pre = this.head\n    node.next = this.head.next\n    this.head.next.pre = node\n    this.head.next = node\n}\n\nfunc (this *LRUCache) removeTail() *ListNode1 {\n    removedTail := this.tail.pre\n    this.removeNode(removedTail)\n    return removedTail\n}\n/**\n * Your LRUCache object will be instantiated and called as such:\n * obj := Constructor(capacity);\n * param_1 := obj.Get(key);\n * obj.Put(key,value);\n */\n```\n## LinkedHashMap\nJava APIå°±æœ‰æ­¤å®ç°LinkedHashMapï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ç»§æ‰¿è¯¥ç±»ç„¶åè¦†ç›–removeEldestEntryæ–¹æ³•å®Œæˆé¢˜ç›®\n```java\nclass LRUCache extends LinkedHashMap<Integer, Integer>{\n    private int capacity;\n    \n    public LRUCache(int capacity) {\n        super(capacity, 0.75F, true);\n        this.capacity = capacity;\n    }\n\n    public int get(int key) {\n        return super.getOrDefault(key, -1);\n    }\n\n    public void put(int key, int value) {\n        super.put(key, value);\n    }\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\n        return size() > capacity; \n    }\n}\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196361067","body":"## äºŒå‰æ ‘DFS\næ ‘çš„æœ€å¤§æ·±åº¦ = maxï¼ˆå·¦å­æ ‘æœ€å¤§æ·±åº¦ï¼Œå³å­æ ‘æœ€å¤§æ·±åº¦ï¼‰+ 1\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n    }\n}\n```\n```go\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc maxDepth(root *TreeNode) int {\n    if root == nil {\n        return 0\n    }\n    return max(maxDepth(root.Left), maxDepth(root.Right)) + 1\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n```\n- time: O(n)\n- space: O(depth)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197711305","body":"## å‰åºéå†\n```go\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\n    if p == nil && q == nil {\n        return true\n    }\n    if p == nil || q == nil {\n        return false\n    }\n    return p.Val == q.Val && isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\n}\n```\n- time: O(n)\n- space: O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200410344","body":"## DFS\nåºåˆ—åŒ–ï¼šååºéå†ï¼Œå‰æ„é€ å·¦å³å­æ ‘å­—ç¬¦ä¸²ï¼Œå†å’Œå½“å‰èŠ‚ç‚¹å­—ç¬¦ä¸²åˆå¹¶\nååºåˆ—åŒ–ï¼šå‰åºéå†ï¼Œå…ˆåˆ›å»ºå½“å‰èŠ‚ç‚¹ï¼Œå†åˆ›å»ºå·¦å³å­æ ‘ï¼Œç”¨é˜Ÿåˆ—ä¿å­˜æ„é€ å€¼\n```java\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        if (root == null) {\n            return \"null,\";\n        }\n        String left = serialize(root.left);\n        String right = serialize(root.right);\n        return root.val + \",\" + left + right;\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        String[] split = data.split(\",\");\n        Queue<String> queue = new LinkedList<>(Arrays.asList(split));\n        return buildTree(queue);\n    }\n\n    TreeNode buildTree(Queue<String> queue) {\n        String s = queue.poll();\n        if (\"null\".equals(s)) {\n            return null;\n        }\n        TreeNode root = new TreeNode(Integer.parseInt(s));\n        root.left = buildTree(queue);\n        root.right = buildTree(queue);\n        return root;\n    }\n}\n```\n- time: O(n)\n- space: O(depth)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206389138","body":"## é›†åˆ + æ»‘åŠ¨çª—å£\néå†å­—ç¬¦ä¸²ï¼Œæ¯ä¸€è½®éƒ½å¾ªç¯åˆ¤æ–­é›†åˆæ˜¯å¦åŒ…å«å¸¦åŠ å…¥é›†åˆçš„å³æŒ‡é’ˆæŒ‡å‘å…ƒç´ ï¼Œæ˜¯åˆ™ç§»é™¤å·¦æŒ‡é’ˆæŒ‡å‘å…ƒç´ ï¼Œå†å°†å³æŒ‡é’ˆæŒ‡å‘å…ƒç´ åŠ å…¥é›†åˆï¼Œæœ€åå†åˆ¤æ–­å·¦å³æŒ‡é’ˆå½¢æˆçš„å­—ä¸²æ˜¯ä¸æ˜¯æœ€é•¿\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Set<Character> set = new HashSet<>();\n        int res = 0, l = 0, r = 0;\n        int len = s.length();\n        while (r < len) {\n            while (set.contains(s.charAt(r))) {\n                set.remove(s.charAt(l));\n                l++;\n            }\n            set.add(s.charAt(r));\n            res = Math.max(res, r - l + 1);\n            r++;\n        }\n        return res;\n    }\n}\n```\n```go\nfunc lengthOfLongestSubstring(s string) int {\n    res := 0\n    set := make(map[byte]struct{})\n    for l, r := 0, 0; r < len(s); r++ {\n        for {\n            if _, ok := set[s[r]]; !ok {\n                break\n            }\n            delete(set, s[l])\n            l++\n        }\n        set[s[r]] = struct{}{}\n        if len(set) > res {\n            res = len(set)\n        }\n    }\n    return res\n}\n```\n- time: O(n)\n- space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207236532","body":"## å“ˆå¸Œè¡¨ + æ»‘åŠ¨çª—å£\n- ç”¨å“ˆå¸Œè¡¨mapå­˜å‚¨å­—ç¬¦ä¸²å¹¶ç»Ÿè®¡åŠå…¶æ ¼æ•°ä»¥ä¾¿æŸ¥æ‰¾\n- ä¸¤é‡å¾ªç¯ï¼Œå¤–å¾ªç¯éå†å¯»æ‰¾å­ä¸²çš„èµ·ç‚¹ï¼Œæ¯æ¬¡å†…å¾ªç¯å‰ä½¿ç”¨å“ˆå¸Œè¡¨tmpå­˜å‚¨æ­¤æ¬¡å†…å¾ªç¯å•è¯æƒ…å†µï¼Œå†…å¾ªç¯éå†å•è¯åˆ¤æ–­å•è¯æ˜¯å¦å­˜åœ¨mapä¸­æˆ–tmpä¸­è¯¥å•è¯ä¸ªæ•°æ˜¯å¦ä¸è¶…è¿‡mapä¸­ä¸ªæ•°ï¼Œè‹¥å¦- - å†…å¾ªç¯å®Œæˆåï¼Œåˆ¤æ–­mapè¡¨å’Œtmpè¡¨æ˜¯å¦ç›¸åŒï¼ˆæˆ–è€…ç”¨countå­˜å‚¨ç¬¦åˆæ¡ä»¶çš„wordä¸ªæ•°åˆ¤æ–­æ˜¯å¦å’Œwordsçš„å•è¯ä¸ªæ•°ç›¸åŒï¼‰ï¼Œè‹¥æ˜¯åˆ™å°†å¤–å¾ªç¯èµ·ç‚¹ä¸‹æ ‡æ·»åŠ åˆ°ç­”æ¡ˆresä¸­\n```java\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        int len = s.length();\n        int wordsNum = words.length;\n        int wordLen = words[0].length();\n        Map<String, Integer> map = new HashMap<>();\n        List<Integer> res = new LinkedList<>();\n        for (int i = 0; i < wordsNum; i++) {\n            map.put(words[i], map.getOrDefault(words[i], 0) + 1);\n        }\n        for (int i = 0; i < len - wordLen * wordsNum + 1; i++) {\n            int left = i;\n            Map<String, Integer> tmp = new HashMap<>();\n            int count = 0;\n            while (left + wordLen <= len) {\n                String word = s.substring(left, left + wordLen);\n                if (!map.containsKey(word)) {\n                    break;\n                }\n                tmp.put(word, tmp.getOrDefault(word, 0) + 1);\n                if (tmp.get(word) > map.get(word)) {\n                    break;\n                }\n                count++;\n                left += wordLen;\n            }\n            if (count == wordsNum) {\n                res.add(i);\n            }\n        }\n        return res;\n    }\n}\n```\n- O(n * wordNum * wordLen)\n- O(wordNum)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckysq999":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185637894","body":"### æ€è·¯\nä¸¤æ•°ç›¸åŠ \nå½“å‰ä½ = (A çš„å½“å‰ä½ + B çš„å½“å‰ä½ + è¿›ä½carry) % 10\n\n### ä»£ç \n\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n = num.length;\n        List<Integer> res = new LinkedList<>();//LinkedListæ¯”ArrayListå¿«\n        int i = n - 1, sum = 0, carry = 0, x = 0, y = 0;\n        while (i >= 0 || k != 0) {\n            x = i >= 0 ? num[i] : 0;\n            y = k >= 0 ? k % 10 : 0;\n            sum = x + y + carry;\n            carry = sum / 10;\n            i--;\n            k = k / 10;\n            res.add(0, sum % 10);\n        }\n        if (carry != 0) res.add(0, carry);\n        return res;\n    }\n}\n\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186193656","body":"### æ€è·¯\ntaskï¼šæ±‚å½“å‰ä¸‹æ ‡å­—ç¬¦åˆ°æŒ‡å®šå­—ç¬¦çš„æœ€è¿‘è·ç¦»\n\naction:\néœ€è¦ä¸¤æ¬¡éå† \n\nå¯¹ s çš„æ¯ä¸ªä¸‹æ ‡ iï¼Œæ±‚ \n\nä»æœ€å·¦è¾¹å¼€å§‹ï¼Œæ‰¾åˆ° s[i] å·¦ä¾§æœ€è¿‘çš„å­—ç¬¦cçš„ä¸‹æ ‡ï¼Œå¹¶è®¡ç®— s[i] åˆ°å…¶ä¸‹æ ‡çš„è·ç¦»\n\nä»æœ€å³è¾¹å¼€å§‹ï¼Œæ‰¾åˆ° s[i] å³ä¾§æœ€è¿‘çš„å­—ç¬¦cçš„ä¸‹æ ‡ï¼Œå¹¶è®¡ç®— s[i] åˆ°å…¶ä¸‹æ ‡çš„è·ç¦»\n\n### ä»£ç \n\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n=s.length();\n        int[] answer=new int[n];\n\n        for(int i=0, index=-n;i<n;i++)\n        {\n            if(s.charAt(i)==c) index=i;\n            answer[i]=i-index;\n        }\n\n        for(int i=n-1, index=2*n-1;i>=0;i--)\n        {\n            if(s.charAt(i)==c) index=i;\n            answer[i]=Math.min(answer[i],index-i);\n        }\n        return answer;\n    }\n}\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186547707","body":"\n### æ€è·¯\n\nåˆ©ç”¨æ•°ç»„æ¨¡æ‹Ÿæ ˆ\n\n### ä»£ç \n\n\n```java\nclass CustomStack {\n\n    int[] stack;\n    int top;\n    public CustomStack(int maxSize) {\n        stack=new int[maxSize];\n        top=-1;\n    }\n    \n    public void push(int x) {\n        if(top<(stack.length-1))\n        {\n            top=top+1;\n            stack[top]=x;\n        }\n\n    }\n    \n    public int pop() {\n        if(top>-1)\n        {\n            int t=top;\n            top=top-1;\n            return stack[t];\n        }\n        else\n            return -1;\n    }\n    \n    public void increment(int k, int val) {\n    for(int i=0;i<Math.min(k,top+1);i++)\n    {\n        stack[i]+=val;\n    }\n    }\n}\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼špush:O(1) pop:O(1) increment: O(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187603841","body":"### æ€è·¯\n\néš¾ç‚¹ï¼šæ‹¬å·å†…åµŒå¥—æ‹¬å·ï¼Œä½¿ç”¨æ ˆè§£å†³é—®é¢˜ã€‚\n\nä¸€ä¸ªå­—æ¯æ ˆï¼Œä¸€ä¸ªæ•°å­—æ ˆ\n\n### ä»£ç \n\n\n```java\n\nclass Solution {\n    public String decodeString(String s) {\n        String res =new String();\n        StringBuffer ans=new StringBuffer();\n        Stack<Integer> multiStack=new Stack<>();\n        Stack<StringBuffer> ansStack=new Stack<>();\n        int multi=0;\n        for(char c:s.toCharArray()){\n            if(Character.isDigit(c))multi=multi*10+c-'0';\n            else if(c=='['){\n                ansStack.add(ans);\n                multiStack.add(multi);\n                ans=new StringBuffer();\n                multi=0;\n            }else if(Character.isAlphabetic(c)){\n                ans.append(c);\n            }else{\n                StringBuffer ansTmp=ansStack.pop();\n                int tmp=multiStack.pop();\n                for(int i=0;i<tmp;i++)ansTmp.append(ans);\n                ans=ansTmp;\n            }\n        }\n        return ans.toString();\n       \n    }\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189149227","body":"### æ€è·¯\nåŒæ ˆï¼šä¸€ä¸ªæ˜¯è¾“å…¥æ ˆï¼Œå¦ä¸€ä¸ªè¾…åŠ©ä½œä¸ºè¾“å‡ºæ ˆ\n\n### ä»£ç \n\n\n```java\nclass MyQueue {\n    Deque<Integer> deque1;\n    Deque<Integer> deque2;\n\n    public MyQueue() {\n        deque1 = new ArrayDeque<>();\n        deque2 = new ArrayDeque<>();\n    }\n\n    public void push(int x) {\n        deque1.push(x);\n    }\n\n    public int pop() {\n        if (deque2.isEmpty())\n            f();\n        return deque2.pop();\n    }\n\n    public int peek() {\n        if (deque2.isEmpty())\n            f();\n        return deque2.peek();\n    }\n\n    public boolean empty() {\n        if (deque1.isEmpty() & deque2.isEmpty())\n            return true;\n        else\n            return false;\n\n    }\n\n    public void f() {\n        while (!deque1.isEmpty())\n            deque2.push(deque1.pop());\n    }\n\n}\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼špush()å’Œempty()æ˜¯O(1)ï¼Œpop()å’Œpeek()æ˜¯O(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n),é¢å¤–çš„å†…å­˜æ¥å­˜å‚¨é˜Ÿåˆ—ä¸­çš„å…ƒç´ \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190343354","body":"### æ€è·¯\n\n\næ˜¯å¦æ˜¯æ’åºå—åªéœ€è¦ç”¨åˆ°è¯¥å—çš„ å…ƒç´ æœ€å¤§å€¼ head ã€‚\n\n### ä»£ç \n\n\n```java\n\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr) {\n            if(!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\n                stack.addLast(head);\n            }\n            else stack.addLast(num);\n        }\n        return stack.size();\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192591445","body":"### æ€è·¯\n\né€’å½’\n\n### ä»£ç \n\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode newHead = head.next;\n        head.next = swapPairs(newHead.next);\n        newHead.next = head;\n        return newHead;\n    }\n}\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194266565","body":"### æ€è·¯\næ€è·¯ä¸€ï¼šå“ˆå¸Œè¡¨\n\næ€è·¯äºŒï¼šåŒæŒ‡é’ˆ\n### ä»£ç \n\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode ptr=head;\n        Set<ListNode> l=new HashSet<ListNode>();\n        while(ptr!=null)\n        {\n            if(l.contains(ptr))\n                return ptr;\n            else\n                l.add(ptr);\n            ptr=ptr.next;\n        }\n        return null;\n    }\n}\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195565577","body":"### æ€è·¯\nLinkedHashMap\n\n### ä»£ç \n\n\n```java\nclass LRUCache {\n    private int capacity;\n\n    public LRUCache(int capacity) {\n        super(capacity, 0.75F, true);\n        this.capacity = capacity;\n    }\n\n    public int get(int key) {\n        return super.getOrDefault(key, -1);\n    }\n\n    public void put(int key, int value) {\n        super.put(key, value);\n    }\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\n        return size() > capacity;\n    }\n\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(1)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196409790","body":"### æ€è·¯\né€’å½’\n\n### ä»£ç \n\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n     if(root==null)\n         return 0;\n     return Math.max(maxDepth(root.left),maxDepth(root.right))+1;\n    }\n}\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(depth),æœ€å¥½çš„æƒ…å†µæ˜¯logn,æœ€åçš„æƒ…å†µæ˜¯n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198322822","body":"### æ€è·¯\n\né€’å½’\n\n### ä»£ç \n\n\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if(p==null || q==null) return false;\n        if(p.val!=q.val) return false;\n        return(isSameTree(p.left,q.left)&&(isSameTree(p.right,q.right)));\n    }\n}\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(min(m,n))ï¼Œå…¶ä¸­ m å’Œ n åˆ†åˆ«æ˜¯ä¸¤ä¸ªäºŒå‰æ ‘çš„èŠ‚ç‚¹æ•°ã€‚å¯¹ä¸¤ä¸ªäºŒå‰æ ‘åŒæ—¶è¿›è¡Œæ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œåªæœ‰å½“ä¸¤ä¸ªäºŒå‰æ ‘ä¸­çš„å¯¹åº”èŠ‚ç‚¹éƒ½ä¸ä¸ºç©ºæ—¶æ‰ä¼šè®¿é—®åˆ°è¯¥èŠ‚ç‚¹ï¼Œå› æ­¤è¢«è®¿é—®åˆ°çš„èŠ‚ç‚¹æ•°ä¸ä¼šè¶…è¿‡è¾ƒå°çš„äºŒå‰æ ‘çš„èŠ‚ç‚¹æ•°ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼šO(h) ç©ºé—´å¤æ‚åº¦å–å†³äºé€’å½’è°ƒç”¨çš„å±‚æ•°ï¼Œé€’å½’è°ƒç”¨çš„å±‚æ•°ä¸ä¼šè¶…è¿‡è¾ƒå°çš„äºŒå‰æ ‘çš„æœ€å¤§é«˜åº¦ï¼Œæœ€åæƒ…å†µä¸‹ï¼ŒäºŒå‰æ ‘çš„é«˜åº¦ç­‰äºèŠ‚ç‚¹æ•°ã€‚\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199460023","body":"### æ€è·¯\n\ndfs\n\n### ä»£ç \n\n\n```java\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n\n        return dfs(root, 0);\n\n    }\n\n    public int dfs(TreeNode root, int i) {\n        if (root == null) return 0;\n        int sum;\n        sum = i * 10 + root.val;\n        if (root.left == null && root.right == null)\n            return sum;\n        return dfs(root.left, sum) + dfs(root.right, sum);\n\n    }\n\n}\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œnæ˜¯æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°\n- ç©ºé—´å¤æ‚åº¦ï¼šO(h)ï¼Œé€’å½’è°ƒç”¨çš„æ ˆç©ºé—´ï¼Œæ ‘çš„é«˜åº¦","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201367353","body":"### ä»£ç \n\n\n```java\nclass Solution {\n    Map<TreeNode, int[]> map = new HashMap<>(); // col, row, val\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        map.put(root, new int[]{0, 0, root.val});\n        dfs(root);\n        List<int[]> list = new ArrayList<>(map.values());\n        Collections.sort(list, (a, b)->{\n            if (a[0] != b[0]) return a[0] - b[0];\n            if (a[1] != b[1]) return a[1] - b[1];\n            return a[2] - b[2];\n        });\n        int n = list.size();\n        List<List<Integer>> ans = new ArrayList<>();\n        for (int i = 0; i < n; ) {\n            int j = i;\n            List<Integer> tmp = new ArrayList<>();\n            while (j < n && list.get(j)[0] == list.get(i)[0]) tmp.add(list.get(j++)[2]);\n            ans.add(tmp);\n            i = j;\n        }\n        return ans;\n    }\n    void dfs(TreeNode root) {\n        if (root == null) return ;\n        int[] info = map.get(root);\n        int col = info[0], row = info[1], val = info[2];\n        if (root.left != null) {\n            map.put(root.left, new int[]{col - 1, row + 1, root.left.val});\n            dfs(root.left);\n        }\n        if (root.right != null) {\n            map.put(root.right, new int[]{col + 1, row + 1, root.right.val});\n            dfs(root.right);\n        }\n    }\n}\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(h)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202898402","body":"public class Solution {\n\n    public int[] twoSum(int[] nums, int target) {\n       \n       for(int i = 0; i < nums.length; i++)\n           for(int j = i + 1; j < nums.length; j++)\n               if(nums[i] + nums[j] == target)\n                   return new int[]{i, j};\n\n       return new int[]{-1, -1};\n    }\n}\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206582602","body":"class Solution {\n    \n    public int lengthOfLongestSubstring(String s) {\n\n        int left = 0;\n        int maxLen = 0;\n        Set<Character> set = new HashSet<>();\n\n        for (int i = 0; i < s.length(); i++) {\n\n            if (!set.add(s.charAt(i))) {\n                \n                maxLen = Math.max(maxLen, set.size());\n                while (s.charAt(left) != s.charAt(i)) {\n\n                    set.remove(s.charAt(left));\n                    left++;\n                }\n\n                left += 1;\n            }\n        }\n\n        return Math.max(maxLen, set.size());\n    }\n}\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208010089","body":"class Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        slow = fast = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        return slow","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dereklisdr":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185638851","body":"/* æ€è·¯ */\n- ä¸¤ä¸ªæ•°ç›¸åŠ ï¼šä»ä¸ªä½æ•°ç›¸åŠ (ä»å³å‘å·¦) è€ƒè™‘è¿›ä½ ä¸€ä¸ªä¸€ä¸ªåŠ å…¥ArrayListå…¥Listé¦–ä½\n\n/* ä»£ç  Java */\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = num.length-1; i >= 0; i--) {\n            int current = k%10 + num[i];\n            k /= 10;\n            \n            if (current >= 10) {\n                k += 1;\n            }\n            \n            result.add(0, current%10);\n        }\n        \n        while (k > 0) {\n            result.add(0, k%10);\n            k /= 10;\n        }\n        \n        return result;\n    }\n}\n\n/* æ—¶é—´å’Œç©ºé—´åˆ†æ\nTime  : O(n) - ä¸€æ¬¡å¾ªç¯\nSpace : O(n) - ä¸¤æ•°ç›¸åŠ çš„ä½æ•°\n*/","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186218643","body":"/* Idea\n- loop 1(left to right): compare the index with the first closet left c\n- loop 2(right to left): compare the index with the first closet right c\n- compare two loop indexs, and take the min value\n*/\n\n/* Code Java */\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] res = new int[len];\n        int prev = Integer.MIN_VALUE / 2;\n\n        for (int i = 0; i < len; ++i) {\n            if (s.charAt(i) == c) prev = i;\n            res[i] = i - prev;\n        }\n\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = len-1; i >= 0; --i) {\n            if (s.charAt(i) == c) prev = i;\n            res[i] = Math.min(res[i], prev - i);\n        }\n\n        return res;\n    }\n}\n\n/* Complexity Analysis\nTime  : O(n) : 2 n loops\nSpace : O(n) : return n int array\n*/","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186313748","body":"/* Idea\n-  Use int[] to simulate stack.\n*/\n\n/* Code Java */\nclass CustomStack {\n    private int[] items;\n    // size: count of current items occupied; pointer to next item.\n    private int size = 0;\n\n    public CustomStack(int maxSize) {\n        items = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (size == items.length)\n            return;\n        items[size++] = x;\n    }\n\n    public int pop() {\n        if (size == 0)\n            return -1;\n        return items[--size];\n    }\n\n    public void increment(int k, int val) {\n        for (int i = 0; i < Math.min(k, size); i++) {\n            items[i] += val;\n        }\n    }\n}\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n\n/* Complexity Analysis\nTime Complexity : O(n)\nspase Complexity: O(maxSize)\n*/","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186588234","body":"//æ²¡åšå‡ºæ¥ å‚è€ƒ\nclass Solution {\n    public String decodeString(String s) {\n        \n        int lastIndex = s.lastIndexOf('[');\n        if(lastIndex<0) return s;\n        int temp=lastIndex-1;\n        String repeatString=\"\";\n        while(temp>=0){\n            if(Character.isDigit(s.charAt(temp))){\n                temp--;\n            }\n            else break;\n        }\n        \n        int repeatNum=Integer.parseInt(s.substring(temp+1,lastIndex));\n        \n        String rpStr=s.substring(lastIndex+1, s.indexOf(']',lastIndex));\n        rpStr=rpStr.repeat(repeatNum);\n        s=s.replace((s.substring(temp+1,s.indexOf(']',temp+1)+1)),rpStr);\n        return decodeString(s);      \n        \n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189114277","body":"/* Idea\n-  ç¬¬1ä¸ªStackç”¨æ¥push, ç¬¬2ä¸ªStackç”¨æ¥pop and peek.\n- æŠŠç¬¬1ä¸ªstack popå‡ºæ¥çš„æ•°æ”¾åˆ°ç¬¬2ä¸ªStackä¸­ï¼Œç„¶åpopå°±æ˜¯æŒ‰ç…§queueçš„æ¬¡åºpop\n*/\n\n/* Code Java */\nclass MyQueue {\n    Stack<Integer> in = new Stack<Integer>();\n    Stack<Integer> out = new Stack<Integer>();\n    \n    public MyQueue() {\n        \n    }\n    \n    public void push(int x) {\n        in.push(x);\n    }\n    \n    public int pop() {\n        int res;\n        if (!out.empty()){\n            res = out.pop();\n        }else{\n            while(!in.empty()){\n                out.push(in.pop());\n            }\n            res = out.pop();\n        }\n        return res;\n    }\n    \n    public int peek() {\n        int res;\n        if (!out.empty()){\n            res = out.peek();\n        }else{\n            while(!in.empty()){\n                out.push(in.pop());\n            }\n            res = out.peek();\n        }\n        return res;\n    }\n    \n    public boolean empty() {\n        return (in.empty() && out.empty());\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n\n/* Complexity Analysis\nTime Complexity : push O(1), pop and peek: O(n)\nspase Complexity: O(n)\n*/","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189760137","body":"class Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int[] rightMin = new int[arr.length+1];\n        rightMin[arr.length] = Integer.MAX_VALUE;\n        for(int i = arr.length-1; i>=0; i--){\n            rightMin[i] = Math.min(rightMin[i+1], arr[i]);\n        }\n        \n        int leftMax = Integer.MIN_VALUE;;\n        int count = 0;\n        for(int i = 0; i<arr.length; i++){\n            leftMax = Math.max(leftMax, arr[i]);\n            if(leftMax<=rightMin[i+1]){\n                count++;\n            }\n        }\n        return count;\n        \n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191060774","body":"Idea\n- åˆ†ä¸¤ä¸ªcases 1. k>list size 2. k<list size æ¥è®¡ç®—æœ€åä¸€ä¸ªnode.next = nullçš„ä½ç½®\n- ç„¶åé¦–ä½è¿æ¥èµ·æ¥ è¿”å›head\n\nCode\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        \n        if(head == null) return null;\n        if(k == 0) return head;\n            \n        int size = 0;\n        ListNode cur = new ListNode();\n        cur = head;\n            \n        while(cur.next != null){\n            size++;\n            cur = cur.next;\n        }\n        size++;\n        \n        int steps = 0;\n        \n        //calculate the steps is the key!\n        if (k == size){\n            return head;\n        }else if (k < size){\n            steps = size - 1 - k;\n        }else if (k > size){\n            steps = size - 1 - (k % size); //trick here. should consider test cases\n        }\n        \n        cur = head;\n        for(int i = 0; i < steps; i++){\n            cur = cur.next;\n        }\n        \n        ListNode endNode = cur;\n        while(endNode.next != null)\n        {\n            endNode = endNode.next;\n        }\n        endNode.next = head;\n        head = cur.next;\n        cur.next = null;\n        \n        return head;\n    }\n}\n\nComplexity\nTime  complexity: O(n)\nSpace complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192716319","body":"Idea\n- åŒæŒ‡é’ˆ\n\nCode\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head==null || head.next==null)\n        {\n            return head;\n        }\n        ListNode p=head;\n        while(p!=null && p.next!=null)\n        {\n            int temp=p.val;\n            p.val=p.next.val;\n            p.next.val=temp;\n            p=p.next.next;\n        }\n        return head;\n    }\n}\n\n\nComplexity\nTime  complexity: O(n)\nSpace complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193139554","body":"æ€è·¯ BST\n\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head==null)\n            return null;\n        ListNode temp=head;int n=0;\n        while(temp.next!=null){\n            temp=temp.next;\n            n++;\n        }\n        return sortedListToBST(head, 0 ,n);\n    }\n     TreeNode sortedListToBST(ListNode head, int start, int end) {\n        \n        if(start > end){\n            return null;\n        }\n        \n        int middle = (end + start) / 2;\n        ListNode temp=head;\n        \n        for(int i=start;i<middle;i++){\n            temp=temp.next;\n        }\n        TreeNode node = new TreeNode(temp.val);\n        \n        node.left = sortedListToBST(head,start, middle-1);\n        node.right = sortedListToBST(temp.next, middle+1, end);\n        \n        return node;\n    }\n    \n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193342726","body":"Code\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        \n        while(headA!= null){\n            ListNode curr = headB;\n            while(curr!=null){\n                if(curr == headA){\n                    return headA;\n                }\n                else{\n                    curr = curr.next;\n                }\n            }\n            headA = headA.next;\n        }\n        \n        return null;\n    }\n}\n\n\nComplexity\nTime  complexity: O(m+n)\nSpace complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193569977","body":"Idea\n- åŒæŒ‡é’ˆ + æ•°å­¦é—®é¢˜\n\nCode\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null){//head.next is for only one node\n            return null;\n        }\n        \n        ListNode fast = head;\n        ListNode slow = head;\n        boolean hasCycle = false;\n        \n        while(fast != null && fast.next != null){\n            fast = fast.next.next;\n            slow = slow.next;\n            \n            if(fast == slow){\n                hasCycle = true;\n                break;\n            }\n        }\n        \n        if (hasCycle == false){\n            return null;\n        }\n        \n        slow = head;\n        \n        if (fast == slow){ //for the case, like the Example2\n            return slow;\n        }\n        \n        while(fast != null && fast.next != null){\n            fast = fast.next;\n            slow = slow.next;\n            if (fast == slow){\n                break;\n            }\n        }\n        return slow;\n    }\n}\n\nComplexity\nTime  complexity: O(n)\nSpace complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194823262","body":"Idea\n- Use LinkedHashMap\n\nCode\nclass LRUCache {\n    int cap;\n    LinkedHashMap<Integer, Integer> cache;\n    \n    public LRUCache(int capacity) {\n        this.cap = capacity;\n        this.cache = new LinkedHashMap<Integer, Integer>();\n    }\n    \n    public int get(int key) {\n        if(!cache.containsKey(key)){\n            return -1;\n        }\n        makeRecently(key);\n        return cache.get(key);\n    }\n    \n    public void put(int key, int value) {\n\n        if (cache.containsKey(key)) {\n            cache.put(key,value);\n            makeRecently(key);\n            return;\n        }\n        \n        if (cache.size() >= this.cap) {\n            int oldestKey = cache.keySet().iterator().next(); //the first one is the oldest\n            cache.remove(oldestKey);\n        }\n        \n        cache.put(key,value);\n        \n    }\n    \n    private void makeRecently(int key) {\n        int val = cache.get(key);\n        cache.remove(key);\n        cache.put(key, val);\n    }\n}\n\nComplexity\nTime  complexity: O(1)\nSpace complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196029131","body":"Idea\n- é€’å½’+å›æº¯\n\nclass Solution {\n    int depth = 0;\n    int res = 0;\n\n    public int maxDepth(TreeNode root) {\n        traverse(root);\n        return res;\n    }\n\n    void traverse(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n\n        depth++;\n        res = Math.max(res, depth);\n        traverse(root.left);\n        traverse(root.right);\n        depth--;\n    }\n}\n\nTime O(n)\nSpace O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198222074","body":"class Solution {\n  public boolean isSameTree(TreeNode p, TreeNode q) {\n    // p and q are both null\n    if (p == null && q == null) return true;\n    // one of p and q is null\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.right, q.right) &&\n            isSameTree(p.left, q.left);\n  }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198868292","body":"class Solution {\n  public int sumNumbers(TreeNode root) {\n    int rootToLeaf = 0, currNumber = 0;\n    Deque<Pair<TreeNode, Integer>> stack = new ArrayDeque();\n    stack.push(new Pair(root, 0));\n\n    while (!stack.isEmpty()) {\n      Pair<TreeNode, Integer> p = stack.pop();\n      root = p.getKey();\n      currNumber = p.getValue();\n\n      if (root != null) {\n        currNumber = currNumber * 10 + root.val;\n        // if it's a leaf, update root-to-leaf sum\n        if (root.left == null && root.right == null) {\n          rootToLeaf += currNumber;\n        } else {\n          stack.push(new Pair(root.right, currNumber));\n          stack.push(new Pair(root.left, currNumber));\n        }\n      }\n    }\n    return rootToLeaf;\n  }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1199989855","body":"æ€è·¯ï¼šäºŒå‰æ ‘ DFS\n\nclass Solution {\n\n    int maxDepth = 0;\n\n    int depth = 0;\n    TreeNode res = null;\n\n    public int findBottomLeftValue(TreeNode root) {\n        traverse(root);\n        return res.val;\n    }\n\n    void traverse(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n\n        depth++;\n        if (depth > maxDepth) {\n\n            maxDepth = depth;\n            res = root;\n        }\n        traverse(root.left);\n        traverse(root.right);\n\n        depth--;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200330097","body":"Idea: DFS + Binary serialization\n\npublic class Codec {\n    \n    public String serialize(TreeNode root) {\n        var bos = new ByteArrayOutputStream(1024 * 16);\n        serialize(root, bos);\n        return bos.toString(StandardCharsets.ISO_8859_1);\n    }\n\n    public TreeNode deserialize(String data) {\n        var bytes = data.getBytes(StandardCharsets.ISO_8859_1);\n        var bis = new ByteArrayInputStream(bytes);\n        return deserialize(bis);\n    }\n\n    static void serialize(TreeNode node, ByteArrayOutputStream bos) {\n        if (node == null) {\n            bos.write(0);\n        } else {\n            bos.write(1);\n            writeInt(bos, node.val);\n            serialize(node.left, bos);\n            serialize(node.right, bos);\n        }\n    }\n\n    static TreeNode deserialize(ByteArrayInputStream bis) {\n        if (bis.available() == 0 || bis.read() == 0) {\n            return null;\n        }\n        var n = new TreeNode(readInt(bis));\n        n.left = deserialize(bis);\n        n.right = deserialize(bis);\n        return n;\n    }\n\n    static void writeInt(ByteArrayOutputStream bos, int val) {\n        bos.write((val >>> 24) & 0xFF);\n        bos.write((val >>> 16) & 0xFF);\n        bos.write((val >>> 8) & 0xFF);\n        bos.write(val & 0xFF);\n    }\n\n    static int readInt(ByteArrayInputStream bis) {\n        int val = bis.read() << 24;\n        val |= bis.read() << 16;\n        val |= bis.read() << 8;\n        val |= bis.read();\n        return val;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200582974","body":"class Solution {\n   public static List> verticalTraversal(TreeNode root) {\n        List> ans = new ArrayList<>();\n        Map>> map = new TreeMap<>();\n        Queue q = new LinkedList<>();\n        q.add(new Three(0, 0, root));\n        while(!q.isEmpty()) {\n            Three curr = q.poll();\n            if (map.containsKey(curr.hd)) {\n                if (map.get(curr.hd).containsKey(curr.level)) {\n                    map.get(curr.hd).get(curr.level).add(curr.n.val);\n                }else {\n                    List ls = new ArrayList<>();\n                    ls.add(curr.n.val);\n                    map.get(curr.hd).put(curr.level, ls);\n                }\n            }else {\n                List ls = new ArrayList<>();\n                ls.add(curr.n.val);\n                Map> innermap = new TreeMap<>();\n                innermap.put(curr.level, ls);\n                map.put(curr.hd, innermap);\n            }\n            if (curr.n.left != null) {\n                q.add(new Three(curr.hd - 1, curr.level + 1, curr.n.left));\n            }\n            if (curr.n.right != null) {\n                q.add(new Three(curr.hd + 1, curr.level + 1, curr.n.right));\n            }\n        }\n        for(Map> m : map.values()) {\n            List inner = new ArrayList<>();\n            for(List l : m.values()) {\n                Collections.sort(l);\n                inner.addAll(l);\n            }\n            ans.add(inner);\n         }\n        return ans;\n    }\n}\nclass Three {\n    int hd;\n    int level;\n    TreeNode n;\n    public Three(int hd, int level, TreeNode n) {\n        this.hd = hd;\n        this.level = level;\n        this.n = n;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201978084","body":"class Solution {\n    public int[] twoSum(int[] nums, int target) {\n     \n        int[] rtn = new int[2];\n        rtn[0] = 0;\n        rtn[1] = 0;\n        \n        if (nums.length < 2){\n            return rtn;\n        }\n        \n        Arrays.sort(nums);\n        \n        int first = 0; \n        int second = nums.length - 1; \n        \n        while ((nums[first] + nums[second]) != target) {\n            if((nums[first] + nums[second]) > target){\n                second--;\n            }\n            else if ((nums[first] + nums[second]) < target) {\n                first++;\n            }\n        }\n        \n        rtn[0] = first;\n        rtn[1] = second;\n        \n        return rtn;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203338956","body":"class Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        HashMap<Integer,Integer> map = new HashMap<>();\n        for(int n:nums)\n        {\n            map.put(n,map.getOrDefault(n,0)+1);\n        }\n        List<Integer> list = new ArrayList<>(map.keySet());\n        Collections.sort(list,(a,b)->map.get(b)-map.get(a));\n        int[] res = new int[k];\n        for(int i=0;i<k;i++)\n        {\n            res[i]=list.get(i);\n        }\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204545901","body":"TC: O(n^2) \nSC: O(n)\n\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        \n        int answer = 0;\n        \n        for (int p=0; p<points.length;p++) {\n            \n            int[] i = points[p];\n            \n            HashMap<Double, Integer> hm = new HashMap<Double, Integer>();\n            \n            for (int q=0;q<points.length;q++) {\n                \n                if (q==p) {\n                    continue;\n                }\n                \n                int[] j = points[q];\n                \n                double distance = Math.sqrt(Math.pow(j[0]-i[0], 2) + Math.pow(j[1]-i[1], 2));\n                \n                if (distance > 0) {\n                    if (hm.containsKey(distance)) {\n                        hm.put(distance, hm.get(distance) + 1);\n                    } else {\n                        hm.put(distance, 1);\n                    }\n                }\n                \n            }\n            \n            for (Double dist : hm.keySet()) {\n                int occ = hm.get(dist);\n                if (occ > 1) {\n                    answer = answer + ((occ) * (occ - 1));\n                }\n            }\n        }\n        \n        return answer;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205876858","body":"class Solution {\n    public:\n    int lengthOfLongestSubstring(string s) {\n        unordered_map<char, int> window;\n\n        int left = 0, right = 0;\n        int res = 0; \n        while (right < s.size()) {\n            char c = s[right];\n            right++;\n\n            window[c]++;\n\n            while (window[c] > 1) {\n                char d = s[left];\n                left++;\n\n                window[d]--;\n            }\n\n            res = max(res, right - left);\n        }\n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207085537","body":"class Solution {\n\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList<>();\n        int n = words.length;\n        int wordLen = words[0].length();\n        int subStrLen = n * wordLen;\n        if (s.length() < subStrLen) {\n            return ans;\n        }\n\n        Map<String, Integer> map = new HashMap<>();\n        for (String word : words) {\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        }\n\n        for (int i = 0; i < wordLen; i++) {\n            Map<String, Integer> wordCount = new HashMap<>();\n            \n            int count = 0;\n\n            int p = i;\n            for (int q = p; q + wordLen <= s.length(); q += wordLen) {\n                String key = s.substring(q, q + wordLen);\n                int limit = map.getOrDefault(key, 0);\n                if (limit == 0) {\n                    wordCount.clear();\n                    count = 0;\n                    p = q + wordLen;\n                    continue;\n                }\n                count++;\n                int num = wordCount.getOrDefault(key, 0) + 1;\n                wordCount.put(key, num);\n                while (num > limit) {\n                    String str = s.substring(p, p + wordLen);\n                    wordCount.put(str, wordCount.get(str) - 1);\n                    count--;\n                    p += wordLen;\n                    if (str.equals(key)) {\n                        num--;\n                    }\n                }\n                if (count == words.length) {\n                    ans.add(p);\n                }\n            }\n        }\n\n\n        return ans;\n\n    }\n\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207323353","body":"class Solution {\n    public int solve(int[] nums, int k) {\n        int total = 0;\n        for (int n : nums) {\n            total += n;\n        }\n        int totalMod = Math.floorMod(total, k);\n\n        Map<Integer, Integer> map = new HashMap();\n        map.put(0, -1);\n        int prefix = 0;\n        int res = nums.length;\n        for (int i = 0; i < nums.length; i++) {\n            prefix += nums[i];\n            int curMod = Math.floorMod(prefix, k);\n            map.put(curMod, i);\n            int afterMod = Math.floorMod(prefix - totalMod, k);\n\n            if (map.containsKey(afterMod)) {\n                int len = i - map.get(afterMod);\n                System.out.println(i);\n                res = len < res ? len : res;\n            }\n        }\n        return res == nums.length ? -1 : res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207572315","body":"æ€è·¯ï¼šåŒæŒ‡é’ˆ\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n\n        ListNode slow = head, fast = head;\n\n        while (fast != null && fast.next != null) {\n\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        return slow;\n    }\n}\nTC O(n)\nSC O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208654379","body":"æ€è·¯ï¼šåŒæŒ‡é’ˆ\n\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        if (nums.length == 0) {\n            return 0;\n        }\n        int slow = 0, fast = 0;\n        while (fast < nums.length) {\n            if (nums[fast] != nums[slow]) {\n                slow++;\n\n                nums[slow] = nums[fast];\n            }\n            fast++;\n        }\n\n        return slow + 1;\n    }\n}\n\nTC - O(n)\nSC - O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/42#issuecomment-1210007034","body":"æ€è·¯ï¼šäºŒåˆ†æœç´¢\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        return left_bound(nums, target);\n    }\n\n    int left_bound(int[] nums, int target) {\n        if (nums.length == 0) return -1;\n        int left = 0;\n        int right = nums.length;\n\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                right = mid;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else if (nums[mid] > target) {\n                right = mid;\n            }\n        }\n        return left;\n    }\n}\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"perfqi":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185644120","body":"å¸¸è§„æ€è·¯ï¼š1.æ•°ç»„å’Œæ•°å­—ç›¸äº’è½¬æ¢ï¼›2.ä¸¤æ•°ç»„é€ä½ç›¸åŠ \nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            res.add(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186530094","body":"è€ƒå¯Ÿæ ˆçš„å­˜å‚¨ç»“æ„ï¼Œæ“ä½œ\n\n class CustomStack {\n\n    static class Node {\n        int val;\n        int delta;\n        Node(int val) {\n            this.val = val;\n            this.delta = 0;\n        }\n    }\n\n    Node[] stack = null;\n    int len = 0;\n\n    public CustomStack(int maxSize) {\n        stack = new Node[maxSize];\n    }\n    \n    public void push(int x) {\n        if (len < stack.length) {\n            stack[len++] = new Node(x);\n        }\n    }\n    \n    public int pop() {\n        if (len <= 0) return -1;\n        Node top = stack[len - 1];\n        if (len >= 2) {\n            stack[len - 2].delta += top.delta;\n        }\n        len--;\n        return top.val + top.delta;\n    }\n    \n    public void increment(int k, int val) {\n        if (len >= k && k >= 1) {\n            stack[k - 1].delta += val;\n        } else if (len > 0) {\n            stack[len - 1].delta += val;\n        }\n    }\n}\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193132640","body":"æ€è·¯ï¼šè¦ç†Ÿæ‚‰äºŒå‰æ ‘çš„éå†å’Œå­˜å‚¨ï¼Œæœ¬é¢˜æ˜¯è€ƒå¯Ÿä¸­åºéå†å­˜å‚¨ç»“æœè¿˜åŸäºŒå‰æ ‘ï¼Œé«˜åº¦å·®ä¸å¤§äº1æ ¹èŠ‚ç‚¹æ˜¯ä¸­é—´ä½ç½®ç”¨å¿«æ…¢æŒ‡é’ˆ\n\nä»£ç ï¼š\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n\n        if (head.next == null) {\n            return new TreeNode(head.val);\n        }\n\n        // å¿«æ…¢æŒ‡é’ˆæ‰¾ä¸­å¿ƒèŠ‚ç‚¹\n        ListNode p = head, q = head, pre = null;\n        while (q != null && q.next != null) {\n            pre = p;\n            p = p.next;\n            q = q.next.next;\n        }\n        pre.next = null;\n       \n        // ä»¥å‡åºé“¾è¡¨çš„ä¸­é—´å…ƒç´ ä½œä¸ºæ ¹èŠ‚ç‚¹ rootï¼Œé€’å½’çš„æ„å»º root çš„å·¦å­æ ‘ä¸å³å­æ ‘ã€‚\n        TreeNode root = new TreeNode(p.val);\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(p.next);\n        return root;\n    }\n\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193328183","body":"æ€è·¯ï¼š\n     å‚è€ƒäº†é¢˜è§£ï¼Œä¸¤ä¸ªå…¥å£åŒæŒ‡é’ˆåˆ†åˆ«ç§»åŠ¨éå†æ•´ä¸ªé“¾è¡¨ï¼Œå¿…ç„¶åœ¨æŒ‡é’ˆç§»åŠ¨æ¬¡æ•°==é“¾è¡¨é•¿åº¦çš„ä½ç½®ç›¸é‡ã€‚\nä»£ç ï¼š\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {\n            return null;\n        }\n        ListNode pA = headA, pB = headB;\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200196853","body":"å¹¿åº¦ä¼˜å…ˆéå†ï¼Œè®°ä¸‹æ¯ä¸€å±‚çš„ç¬¬ä¸€ä¸ªnode\n\npublic int findBottomLeftValue(TreeNode root) {\n        if (root == null){\n            return 0;\n        }\n        Queue<TreeNode> queue = new ArrayDeque<>();\n        queue.offer(root);\n        int ans = 0;\n        while (!queue.isEmpty()){\n            //å½“å‰å±‚çš„æ‰€æœ‰ç»“ç‚¹\n            int curSize = queue.size();\n            for (int i = 0; i < curSize; i++) {\n                TreeNode curNode = queue.poll();\n                if (curNode.left != null){\n                    queue.offer(curNode.left);\n                }\n                if (curNode.right != null){\n                    queue.offer(curNode.right);\n                }\n                //ç¬¬ä¸€ä¸ªç»“ç‚¹\n                if (i == 0){\n                    ans = curNode.val;\n                }\n            }\n        }\n        return ans;\n    }\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200432518","body":"è€ƒå¯Ÿbfs dfs\n\npublic class Codec {\n    int u;\n    String str;\n    StringBuilder sb = new StringBuilder();\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        dfsS(root);\n        return sb.toString();\n    }\n\n    void dfsS(TreeNode u) {\n        if (u == null) {\n            sb.append(\"#,\");\n            return;\n        }\n        sb.append(u.val).append(\",\");\n        dfsS(u.left);\n        dfsS(u.right);\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        str = data;\n        return dfsD();\n    }\n\n    TreeNode dfsD() {\n        if (str.charAt(u) == '#') {\n            u += 2;\n            return null;\n        }\n        int p = u;\n        while (str.charAt(u) != ',') {\n            ++u;\n        }\n        TreeNode node = new TreeNode(Integer.parseInt(str.substring(p, u++)));\n        node.left = dfsD();\n        node.right = dfsD();\n        return node;\n    }\n}\n\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207400335","body":"class Solution {\n    public int solve(int[] nums, int k) {\n        //(totalSUm - delete) % k == 0;\n        // totalSUm % k = delet%k\n        // let totalSum % k = totalMod\n        // totalMod % k = totalMod;\n        // delet%k = prefix[j] % k - prefix[i] %k = totalMod %k;\n        // pre[i] % k = (pre[j] - totalMod) % k;\n        int total = 0;\n        for (int n : nums) {\n            total += n;\n        }\n        int totalMod = Math.floorMod(total, k);\n\n        Map<Integer, Integer> map = new HashMap();\n        map.put(0, -1);\n        int prefix = 0;\n        int res = nums.length;\n        for (int i = 0; i < nums.length; i++) {\n            prefix += nums[i];\n            int curMod = Math.floorMod(prefix, k);\n            map.put(curMod, i);\n            int afterMod = Math.floorMod(prefix - totalMod, k);\n            // System.out.println(afterMod + \"total\" + totalMod +\"pre\" + prefix);\n            if (map.containsKey(afterMod)) {\n                int len = i - map.get(afterMod);\n                System.out.println(i);\n                res = len < res ? len : res;\n            }\n        }\n        return res == nums.length ? -1 : res;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mryao1":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185647007","body":"```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> sum = new ArrayList<Integer>();\n        int length = num.length;\n        num[length - 1] += k;\n        for (int i = length - 1; i > 0; i--) {\n            int curNum = num[i];\n            if (curNum > 9) {\n                num[i - 1] += curNum / 10;\n                num[i] %= 10;\n            }\n            sum.add(num[i]);\n        }\n        do {\n            sum.add(num[0] % 10);\n            num[0] /= 10;\n        } while (num[0] > 0);\n        Collections.reverse(sum);\n        return sum;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186516976","body":"```java\nclass CustomStack {\n\n    private final Integer maxSize;\n\n    private Integer top;\n\n    private final Integer[] arr;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        top = 0;\n        arr = new Integer[maxSize];\n    }\n\n    public void push(int x) {\n        if (top.equals(maxSize)){\n            return;\n        }\n        arr[top++] = x;\n    }\n\n    public int pop() {\n        if (top <= 0){\n            return -1;\n        }\n        return arr[--top];\n    }\n\n    public void increment(int k, int val) {\n        k = k<top? k : top;\n        for (int i = 0; i < k; i++) {\n            arr[i] += val;\n        }\n    }\n}\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187660017","body":"```java\npublic String decodeString(String s) {\n        char[] chars = s.toCharArray();\n        Stack<Object> stack = new Stack<>();\n        for (int i = 0; i < chars.length; i++) {\n            if (Character.isDigit(chars[i])) {\n                int repit = 0;\n                do {\n                    repit = 10 * repit + Integer.parseInt(String.valueOf(chars[i]));\n                    i++;\n                } while (Character.isDigit(chars[i]));\n//                i--;\n                stack.push(repit);\n            }\n            if (']' != chars[i]){\n                stack.push(chars[i]);\n            } else {\n                StringBuilder temp = new StringBuilder();\n                while (!String.valueOf(stack.peek()).equals(\"[\")){\n                    temp.insert(0, stack.pop());\n                }\n                stack.pop();\n                int count = Integer.parseInt(String.valueOf(stack.pop()));\n                String toString = temp.toString();\n                for (int j = 1; j < count; j++) {\n                    temp.append(toString);\n                }\n                stack.push(temp.toString());\n            }\n        }\n        StringBuilder rtn = new StringBuilder();\n        while (!stack.empty()){\n            rtn.insert(0, stack.pop());\n        }\n        return rtn.toString();\n\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189137456","body":"```java\nclass MyQueue {\n\n    private final Stack<Integer> inStack;\n\n    private final Stack<Integer> outStack;\n\n    public MyQueue() {\n        inStack = new Stack<>();\n        outStack = new Stack<>();\n    }\n\n    public void push(int x) {\n        inStack.push(x);\n    }\n\n    public int pop() {\n        if (!outStack.empty()){\n            return outStack.pop();\n        }\n        while (!inStack.empty()){\n            outStack.push(inStack.pop());\n        }\n        return pop();\n    }\n\n    public int peek() {\n        if (!outStack.empty()){\n            return outStack.peek();\n        }\n        while (!inStack.empty()){\n            outStack.push(inStack.pop());\n        }\n        return peek();\n    }\n\n    public boolean empty() {\n        return inStack.empty()&& outStack.empty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190400110","body":"```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int[] expect = Arrays.copyOf(arr, arr.length);\n        Arrays.sort(expect);\n        int count = 0;\n        int i = 0;\n        int sumL = 0;\n        int sumR = 0;\n        while (i < arr.length) {\n            sumL+=arr[i];\n            sumR+=expect[i];\n            if (sumL == sumR){\n                count++;\n                sumL = 0;\n                sumR = 0;\n            }\n            i++;\n        }\n        return count;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191639484","body":"```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(null == head || head.next == null){\n            return head;\n        }\n        ListNode left = head;\n        ListNode right = head;\n        int length = 0;\n        for (int i = 0; i < k; i++) {\n            if (null == right.next){\n                right = head;\n                length = i + 1;\n                break;\n            } else {\n                right = right.next;\n            }\n        }\n        if (0!= length){\n            k = k%length;\n            for (int i = 0; i < k; i++) {\n                right = right.next;\n            }\n        }\n        while (right.next!=null){\n            right = right.next;\n            left = left.next;\n        }\n        right.next = head;\n        right = left.next;\n        left.next = null;\n        return right;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192616956","body":"```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        for(ListNode p = dummy; p.next != null && p.next.next != null;)\n        {\n            ListNode a = p.next;\t//è™šæ‹Ÿå¤´èŠ‚ç‚¹\n            ListNode b = a.next;\n            p.next = b;\n            a.next = b.next;\n            b.next = a;\n            p = a;\n        }\n        return dummy.next;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193144588","body":"```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n     \n\n\n        if (head == null){\n            return null;\n        }else if(head.next == null){\n            return new TreeNode(head.val);\n        }\n        \n\n\n        ListNode slow = head, fast = head;\n        ListNode pre = null;\n        while( fast != null && fast.next != null){\n            pre = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        pre.next = null;\n\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(slow.next);\n        return root;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194085691","body":"```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null){\n            return null;\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n        do {\n            fast = fast.next.next;\n            slow = slow.next;\n        }while (fast != slow && fast != null && fast.next != null);\n\n        if (null == fast || fast.next == null){\n            return null;\n        }\n        ListNode rtn = head;\n        while (rtn != slow){\n            rtn = rtn.next;\n            slow = slow.next;\n        }\n        return rtn;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195639219","body":"```java\npublic class LRUCache {\n    class DLinkedNode {\n        int key;\n        int value;\n        DLinkedNode prev;\n        DLinkedNode next;\n        public DLinkedNode() {}\n        public DLinkedNode(int _key, int _value) {key = _key; value = _value;}\n    }\n\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size;\n    private int capacity;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity;\n\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            return -1;\n        }\n\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            cache.put(key, newNode);\n            addToHead(newNode);\n            ++size;\n            if (size > capacity) {\n                DLinkedNode tail = removeTail();\n                cache.remove(tail.key);\n                --size;\n            }\n        }\n        else {\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DLinkedNode node) {\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DLinkedNode node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail() {\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196943699","body":"```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) {\n            return 0;\n        } else {\n            int left = maxDepth(root.left);\n            int right = maxDepth(root.right);\n            return Math.max(left, right) + 1;\n        }\n    }\n}\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200450959","body":"```java\npublic class Codec {\n    public String serialize(TreeNode root) {\n        return rserialize(root, \"\");\n    }\n  \n    public TreeNode deserialize(String data) {\n        String[] dataArray = data.split(\",\");\n        List<String> dataList = new LinkedList<String>(Arrays.asList(dataArray));\n        return rdeserialize(dataList);\n    }\n\n    public String rserialize(TreeNode root, String str) {\n        if (root == null) {\n            str += \"None,\";\n        } else {\n            str += str.valueOf(root.val) + \",\";\n            str = rserialize(root.left, str);\n            str = rserialize(root.right, str);\n        }\n        return str;\n    }\n  \n    public TreeNode rdeserialize(List<String> dataList) {\n        if (dataList.get(0).equals(\"None\")) {\n            dataList.remove(0);\n            return null;\n        }\n  \n        TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0)));\n        dataList.remove(0);\n        root.left = rdeserialize(dataList);\n        root.right = rdeserialize(dataList);\n    \n        return root;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201391726","body":"```java\nclass Solution {\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<int[]> nodes = new ArrayList<int[]>();\n        dfs(root, 0, 0, nodes);\n        Collections.sort(nodes, new Comparator<int[]>() {\n            public int compare(int[] tuple1, int[] tuple2) {\n                if (tuple1[0] != tuple2[0]) {\n                    return tuple1[0] - tuple2[0];\n                } else if (tuple1[1] != tuple2[1]) {\n                    return tuple1[1] - tuple2[1];\n                } else {\n                    return tuple1[2] - tuple2[2];\n                }\n            }\n        });\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        int size = 0;\n        int lastcol = Integer.MIN_VALUE;\n        for (int[] tuple : nodes) {\n            int col = tuple[0], row = tuple[1], value = tuple[2];\n            if (col != lastcol) {\n                lastcol = col;\n                ans.add(new ArrayList<Integer>());\n                size++;\n            }\n            ans.get(size - 1).add(value);\n        }\n        return ans;\n    }\n\n    public void dfs(TreeNode node, int row, int col, List<int[]> nodes) {\n        if (node == null) {\n            return;\n        }\n        nodes.add(new int[]{col, row, node.val});\n        dfs(node.left, row + 1, col - 1, nodes);\n        dfs(node.right, row + 1, col + 1, nodes);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202896018","body":"```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int n = nums.length;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                if (nums[i] + nums[j] == target) {\n                    return new int[]{i, j};\n                }\n            }\n        }\n        return new int[0];\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1204124357","body":"```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> occurrences = new HashMap<Integer, Integer>();\n        for (int num : nums) {\n            occurrences.put(num, occurrences.getOrDefault(num, 0) + 1);\n        }\n\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {\n            public int compare(int[] m, int[] n) {\n                return m[1] - n[1];\n            }\n        });\n        for (Map.Entry<Integer, Integer> entry : occurrences.entrySet()) {\n            int num = entry.getKey(), count = entry.getValue();\n            if (queue.size() == k) {\n                if (queue.peek()[1] < count) {\n                    queue.poll();\n                    queue.offer(new int[]{num, count});\n                }\n            } else {\n                queue.offer(new int[]{num, count});\n            }\n        }\n        int[] ret = new int[k];\n        for (int i = 0; i < k; ++i) {\n            ret[i] = queue.poll()[0];\n        }\n        return ret;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205439283","body":"```java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int ans = 0;\n        for (int[] p : points) {\n            Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();\n            for (int[] q : points) {\n                int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n                cnt.put(dis, cnt.getOrDefault(dis, 0) + 1);\n            }\n            for (Map.Entry<Integer, Integer> entry : cnt.entrySet()) {\n                int m = entry.getValue();\n                ans += m * (m - 1);\n            }\n        }\n        return ans;\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207428700","body":"```java\nclass Solution {\n    public int solve(int[] nums, int k) {\n        int total = 0;\n        for (int n : nums) {\n            total += n;\n        }\n        int totalMod = Math.floorMod(total, k);\n\n        Map<Integer, Integer> map = new HashMap();\n        map.put(0, -1);\n        int prefix = 0;\n        int res = nums.length;\n        for (int i = 0; i < nums.length; i++) {\n            prefix += nums[i];\n            int curMod = Math.floorMod(prefix, k);\n            map.put(curMod, i);\n            int afterMod = Math.floorMod(prefix - totalMod, k);\n            // System.out.println(afterMod + \"total\" + totalMod +\"pre\" + prefix);\n            if (map.containsKey(afterMod)) {\n                int len = i - map.get(afterMod);\n                System.out.println(i);\n                res = len < res ? len : res;\n            }\n        }\n        return res == nums.length ? -1 : res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208149787","body":"```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode l = head;\n        ListNode r = head;\n        while(null != r && null != r.next){\n            l = l.next;\n            r = r.next.next;\n        }\n        return l;\n    }\n}\n``","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209435492","body":"```java\npublic class Q26RemoveDuplicatesFromSortedArray {\n    public int removeDuplicates(int[] nums) {\n        if(nums==null || nums.length==0){\n            return 0;\n        }\n        int len = nums.length;\n        int fast = 0;\n        int low = 0;\n        while(fast < len){\n            if(nums[fast] != nums[low]){\n                nums[++low] = nums[fast];\n            }\n            fast++;\n        }\n        return ++low;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"likeyousmile":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185652987","body":"class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        nstr = ''.join(map(str,num))\n        n = int(nstr)\n        res = n + k\n        return list(map(int,str(res)))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhg1992":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185656280","body":"```go\nfunc addToArrayForm(num []int, k int) []int {\n\tvar ans []int\n\tfor i := len(num) - 1; i >= 0; i-- {\n\t\tsum := num[i] + k%10\n\t\tk /= 10\n\t\tif sum >= 10 {\n\t\t\tk++\n\t\t\tsum -= 10\n\t\t}\n\t\tans = append(ans, sum)\n\t}\n\tfor ; k > 0; k /= 10 {\n\t\tans = append(ans, k%10)\n\t}\n\treverse(ans)\n\treturn ans\n}\nfunc reverse(num []int) {\n\tfor i, n := 0, len(num); i < n/2; i++ {\n\t\tnum[i], num[n-1-i] = num[n-1-i], num[i]\n\t}\n}\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191628584","body":"```go\n\n// golang\nfunc rotateRight(head *ListNode, k int) *ListNode {\n  if k == 0 || head == nil || head.Next == nil {\n    return head\n  }\n  n := 1\n  iter := head\n  for iter.Next != nil {\n    iter = iter.Next\n    n++\n  }\n  add := n - k%n\n  if add == n {\n    return head\n  }\n  iter.Next = head\n  for add > 0 {\n    iter = iter.Next\n    add--\n  }\n  ret := iter.Next\n  iter.Next = nil\n  return ret\n\n}\n\ntype ListNode struct {\n  Val int\n  Next *ListNode\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192453015","body":"```go\n//golang\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc swapPairs(head *ListNode) *ListNode {\n  if head == nil || head.Next == nil {\n    return head\n  }\n  newHead := head.Next\n  head.Next = swapPairs(newHead.Next)\n  newHead.Next = head\n  return newHead\n}\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199481275","body":"```go\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n\nfunc dfs(root *TreeNode, prevSum int) int {\n  if root == nil {\n    return 0\n  }\n\n  sum := prevSum * 10 + root.Val\n  if root.Left == nil && root.Right == nil {\n    return sum\n  }\n  return dfs(root.Left, sum) + dfs(root.Right, sum)\n}\n\nfunc sumNumbers(root *TreeNode) int {\n  return dfs(root, 0)\n}\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206605052","body":"```go\nfunc lengthOfLongestSubstring(s string) int {\n    // å“ˆå¸Œé›†åˆï¼Œè®°å½•æ¯ä¸ªå­—ç¬¦æ˜¯å¦å‡ºç°è¿‡\n    m := map[byte]int{}\n    n := len(s)\n    // å³æŒ‡é’ˆï¼Œåˆå§‹å€¼ä¸º -1ï¼Œç›¸å½“äºæˆ‘ä»¬åœ¨å­—ç¬¦ä¸²çš„å·¦è¾¹ç•Œçš„å·¦ä¾§ï¼Œè¿˜æ²¡æœ‰å¼€å§‹ç§»åŠ¨\n    rk, ans := -1, 0\n    for i := 0; i < n; i++ {\n        if i != 0 {\n            // å·¦æŒ‡é’ˆå‘å³ç§»åŠ¨ä¸€æ ¼ï¼Œç§»é™¤ä¸€ä¸ªå­—ç¬¦\n            delete(m, s[i-1])\n        }\n        for rk + 1 < n && m[s[rk+1]] == 0 {\n            // ä¸æ–­åœ°ç§»åŠ¨å³æŒ‡é’ˆ\n            m[s[rk+1]]++\n            rk++\n        }\n        // ç¬¬ i åˆ° rk ä¸ªå­—ç¬¦æ˜¯ä¸€ä¸ªæé•¿çš„æ— é‡å¤å­—ç¬¦å­ä¸²\n        ans = max(ans, rk - i + 1)\n    }\n    return ans\n}\n\nfunc max(x, y int) int {\n    if x < y {\n        return y\n    }\n    return x\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liquanluo":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185658739","body":"```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int increase = 0;\n        reverse(num.begin(), num.end());\n        int pos = 0;\n        vector<int> result;\n        while (k > 0 || pos < num.size() || increase > 0 ) {\n            auto digit = k % 10;\n            auto num_digit = pos < num.size() ? num[pos] : 0;\n            auto new_val = num_digit + digit + increase;\n            increase = new_val / 10;\n            new_val = new_val % 10;\n            result.push_back(new_val);\n            \n            ++pos;\n            k = k / 10;\n            // cout << new_val << endl;\n        }\n        \n        // cout << result.size() << endl;\n        reverse(result.begin(), result.end());\n        return result;\n        \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186213458","body":"### Solution:\n- 1. Initialize a result vector which has the same size as string, all the value is INF, [INF, INF....]  O(n)\n- 2. Find the c in the string, and mark the corresponding position as 0 [INF,..0... 0....INF]  O(n)\n- 3. Then for each c, update's left and right value incrementally, until it hits the boundary of the vector or 0 O(n)\n- Time complexity O(n)\n### Code:\n\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> results(s.size(), INT_MAX);\n        for (int i = 0; i < s.size(); ++i ) {\n            if (s[i] == c) {\n                results[i] = 0;\n            }\n        }\n        \n        for (int i = 0; i < s.size(); ++i ) {\n            if (results[i] == 0) {\n                update_left(results, i);\n                update_right(results, i);\n            }\n        }\n    \n        return results;\n    }\n    \n    \n    void update_left(vector<int>& results, int idx) {\n        auto distance = 0;\n        while (idx > 0) {\n            --idx;\n            ++distance;\n            if (distance < results[idx]) {\n                results[idx] = distance;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    \n    void update_right(vector<int>& results, int idx) {\n        auto distance = 0;\n        while (idx < results.size() - 1) {\n            ++idx;\n            ++distance;\n            if (distance < results[idx]) {\n                results[idx] = distance;\n            }\n            else {\n                break;\n            }\n            \n        }\n    }\n    \n    \n};\n\n```\n\n**complexity analysis**\n- Timeï¼šO(N)ï¼Œ\n- Spaceï¼šO(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186433116","body":"### Solution:\n1. use vector as underlying data structure\n2. push() -> vector.push_back()   O(1) or O(n)\n3. pop() -> vector.pop_back and return last element O(1)\n4. increment() -> increment elements at the bottom O(n)\n\n### Code:\n\n\n```c++\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) : _maxSize(maxSize){\n        \n        \n    }\n    \n    void push(int x) {\n        if (_v.size() < _maxSize) {\n            _v.push_back(x);\n        }\n    }\n    \n    int pop() {\n        if (_v.size() == 0) {\n            return -1;\n        }\n        else {\n            auto result = _v[_v.size() -1];\n            _v.pop_back();\n            return result;\n        }\n    }\n    \n    void increment(int k, int val) {\n        int i = 0;\n        while (k > 0 && i < _v.size()) {\n            _v[i] += val;\n            ++i;\n            --k;\n        }\n    }\n    \nprivate:\n    vector<int> _v;\n    int _maxSize;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n\n```\n\n**complexity analysis**\n- Timeï¼šO(N)ï¼Œ\n- Spaceï¼šO(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186725285","body":"### Solution:\ndata structure: stack to store\n1. loop whole string\\\n     1.1. if digit, letters or [ push to stack\\\n     1.2. if ] pop until find [, \\\n           &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; then find all the digit before, convert to int\\\n           &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int * [string], push back to stack\n2. when we running out of s,  pop out all the string from the stack and return\n\n### Code:\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<char> st;\n        for (auto c : s) {\n            if (c == ']') {\n                auto str = find_str(st);\n                auto repeat = find_num(st);\n                string repeated_str;\n                while (repeat > 0) {\n                    repeated_str += str;\n                    --repeat;\n                }\n                // cout << \"repeated_str\" << repeated_str << endl;\n                for (auto repeated_char : repeated_str) {\n                    st.push(repeated_char);\n                }\n            }\n            else {\n                st.push(c);\n            }\n        }\n        \n        string result;\n        while (!st.empty()) {\n            auto c = st.top();\n            result += c;\n            st.pop();\n        }\n        reverse(result.begin(), result.end());\n        \n        return result;\n        \n    }\n    \nprivate:\n    string find_str(stack<char>& st) {\n        string str;\n        while (!st.empty()) {\n            auto c = st.top();\n            if (c == '[') {\n                st.pop();\n                break;\n            }\n            else{\n                str += c;\n                st.pop();\n            }\n        }\n        \n        reverse(str.begin(), str.end());\n        // cout << \"find str\" << str << endl;\n        return str;\n    }\n    \n    int find_num(stack<char>& st) {\n        string num_str;\n        while (!st.empty()) {\n            auto c = st.top();\n            if (!isdigit(c)) {\n                break;\n            }\n            else{\n                num_str += c;\n                st.pop();\n            }\n        }\n        \n        reverse(num_str.begin(), num_str.end());\n        // cout << \"find num_str\" << num_str << endl;\n        int num = stoi(num_str);\n        return num;\n    }\n    \n};\n\n```\n\n**complexity analysis**\n- Timeï¼šO(N)ï¼Œ\n- Spaceï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188614107","body":"```c++\n/***\nData structure: push_stack, pop_stack\n1. push stack is used to push item into queue, like this:[a,b,c\n2. pop stack is used to pop item out of queue, like this: a,b,c]\n3. when we need to push item, we check if pop stack has items, \n    if it is, we put everything back to push stack, \n    then push to push stack\n4. when we need to peek or pop item, we check if push stack has items,\n    if it is, we put everything back to pop stack,\n    then do peek or pop\n5. empty(), both stacks are empty\n***/\n\n\nclass MyQueue {\npublic:\n    MyQueue() {\n        \n    }\n    \n    void push(int x) {\n        while (!pop_stack.empty()) {\n            auto val = pop_stack.top();\n            push_stack.push(val);\n            pop_stack.pop();\n        }\n        \n        push_stack.push(x);\n    }\n    \n    int pop() {\n        while (!push_stack.empty()) {\n            pop_stack.push(push_stack.top());\n            push_stack.pop();\n        }\n        \n        auto result = pop_stack.top();\n        pop_stack.pop();\n        return result;\n    }\n    \n    int peek() {\n        while (!push_stack.empty()) {\n            pop_stack.push(push_stack.top());\n            push_stack.pop();\n        }\n    \n        return pop_stack.top();  \n    }\n    \n    bool empty() {\n        return push_stack.empty() && pop_stack.empty();\n    }\n    \nprivate:\n    stack<int> push_stack;\n    stack<int> pop_stack;\n    \n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191035289","body":"```c++\n// 1. find the size of the list O(n)\n// 2. make the linked list become a circle O(1)\n// 3.  move the head to size - (k % size) O(n)\n// 4. cut the circle before the head O(1)\n// 5. return the head\n\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        \n        \n        ListNode* dummy = new ListNode(0);\n        dummy->next = head;\n        int size = 0;\n        auto cur = head;\n        auto pre = dummy;\n        while (cur != nullptr) {\n            ++size;\n            cur = cur->next;\n            pre = pre->next;    \n        }\n        \n        if (size == 0) {\n            return head;\n        }\n        \n        pre->next = dummy->next;\n        cur = head;\n        pre = dummy;\n        k = size - (k % size);\n        while (k > 0) {\n            cur = cur->next;\n            pre = pre->next;   \n            --k;\n        }\n        pre->next = nullptr;\n        return cur;\n        \n    }\n};\n```\n\nTime: O(n)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192082169","body":"```c++\n\n/***\nSolution:\noriginal: pre_pre -> pre -> cur -> tmp\ntarget: pre_pre -> cur -> pre -> tmp\n\ncur->next = pre;\npre->next = tmp;\npre_pre->next = cur;\n\nTime: O(n)\nSpace: O(1)\n\n***/\n\n\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == nullptr) {\n            return head;\n        }\n        \n        ListNode* dummy = new ListNode(0, head);\n        auto* pre_pre = dummy;\n        auto* pre = dummy->next;\n        auto* cur = dummy->next->next;\n        while (pre != nullptr && cur != nullptr) {\n            auto* tmp = cur->next;\n            cur->next = pre;\n            pre->next = tmp;\n            pre_pre->next = cur;\n            \n            pre_pre = pre;\n            pre = pre_pre->next;\n            if (pre != nullptr) {\n                cur = pre->next;\n            }\n            else {\n                break;\n            }\n            \n        }\n        \n        return dummy->next;\n        \n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193051555","body":"```c++\n\n/***\n1. if head = nullptr, return nullptr (nothing)  O(1)\n2. if head->next = nullptr, return TreeNode(head->val)  (single node) O(1)\n3. pre =  dummy->next = head, cur = head, fast = head O(1)\n4. Use slow and fast pointer to find the mid point of the linked list O(n)\n5. break the linked list [pre->next = nullptr, cur->next = nullptr, next] O(1)\n6. Recursion cur->left = sortedListToBST(dummy->next),  cur->right = sortedListToBST(next) O(n)\n7. return cur\n\n\n***/\n\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if (head == nullptr) {\n            return nullptr;\n        }\n        \n        if (head->next == nullptr) {\n            return new TreeNode(head->val);\n        }\n        \n        auto* dummy = new ListNode(0, head);\n        auto* pre = dummy;\n        auto* cur = head;\n        auto* fast = head;\n        while (fast != nullptr && fast->next != nullptr) {\n            pre = pre->next;\n            cur = cur->next;\n            fast = fast->next;\n            fast = fast->next;\n        }\n        \n        pre->next = nullptr;\n        auto* next_ptr = cur->next;\n        cur->next = nullptr;\n        auto* left = sortedListToBST(dummy->next);\n        auto* right = sortedListToBST(next_ptr);\n        auto result = new TreeNode(cur->val, left, right);\n        return result;\n\n    }\n};\n\nTime: O(n)\nSpace : O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193222924","body":"```c++\n/***\nSolution\n1. use hashmap to store all the nodes in A  time: O(A) Space: O(A)\n2. iterate through B, find if there is any common node time: O(B)\n\n\n\n***/\n\n\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        unordered_set<ListNode*> nodes;\n        auto cur = headA;\n        while(cur != nullptr) {\n            nodes.insert(cur);\n            cur = cur->next;\n        }\n        \n        cur = headB;\n        while (cur != nullptr) {\n            if (nodes.find(cur) != nodes.end()) {\n                return cur;\n            }\n            cur = cur->next;\n        }\n        \n        return nullptr;\n    }\n};\n```\n\nTime: O(A) + O(B)\nSpace: O(A)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193968016","body":"```c++\n/***\nslow and fast pointer\n\nfirst meet:\nNC [-> C -> D]\n\npath(slow) = NC + C\npath(fast) = NC + C + D + C = 2NC + 2C    => NC = D\n\nfast start from head AGAIN, and make it move like slow pointer\nsecond meet:\n\npath(slow) = D\npath(fast) = NC\nNC = D, then they will meet at the begining of the cycle\n\nTime: O(n)\nSpace: O(1)\n\n***/\n\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        auto* slow = head;\n        auto* fast = head;\n        while( fast != nullptr && fast->next != nullptr) {\n            slow = slow->next;\n            fast = fast->next->next;\n            if (slow == fast) {\n                fast = head;\n                while (slow != fast) {\n                    slow = slow->next;\n                    fast = fast->next;\n                }\n                return slow;\n            }\n        }\n        \n        return nullptr;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194990508","body":"```c++\n/***\nSolution 1:\nData strucutre:\n(1) HashMap: <int, preNode*>, so that get will be O(1)\n(2) Single Linked List: head->node1->node2->...-> so that push_back and pop_front will be O(1)\n(3) MyNode{next, key, value}: store the key, so when we need change the strcutre of single linked list, \n                              we can use key to update the map\n\n(1)  get\n    1.1 get latest node, do nothing\n    1.2 get non-latest node, put the node to the end\n        since its single linked list, we need to store the pre-node to move node around\n        we need to update the map of next node, since its pre node has changed\n(2) put\n    1.1 if key already exist, make use of get() to move the node to the end, then update the value of node\n    1.2 if key does not exist, but size == capacity, remove the dummy->next, update\n        a. erase map[old_node->key]\n        b. if old_node next node exist, update map[old_node->next->key] = dummy\n        c. if this node is the cur node, update cur pointer\n    1.3 create a new node, update\n        a. map\n        b. cur pointer\n        c. size\n    \n        \n        \n\n\n***/\n\nstruct MyListNode {\n    int key = 0;\n    int val = 0;\n    MyListNode* next = nullptr;\n    MyListNode (){}\n    MyListNode (int k, int v): key(k), val(v){}\n    // MyListNode (int k, int v, MyListNode* n): key(k), val(v), next(n){}\n};\n\nclass LRUCache {\npublic:\n    LRUCache(int capacity): _capacity(capacity) {\n        dummy = new MyListNode();\n        cur = dummy;\n    }\n    \n    int get(int key) {\n        if (nodes.find(key) != nodes.end()) {\n            auto pre_node = nodes[key];\n            auto node = pre_node->next;\n            auto v = node->val;\n            if (cur != node) {\n                pre_node->next= node->next;\n                nodes[node->next->key] = pre_node;  // update next node's map\n                cur->next= node;\n                node->next = nullptr;\n                nodes[key] = cur;\n                cur = node;\n            }\n\n            return v;\n        }\n       \n        \n        return -1;\n    }\n    \n    void printNode(MyListNode* head) {\n        cout << \"[\";\n        while (head != nullptr) {\n            cout << head->val << \"|\";\n            head = head->next;\n        }\n        cout << \"]\\n\";\n    }\n    \n    void put(int key, int value) {\n        // cout << \"put\" << key << value;\n        // printNode(dummy);\n        if (nodes.find(key) != nodes.end()) {\n            get(key);\n            nodes[key]->next->val = value;\n            return ;\n        }\n        \n        \n        if (_size >= _capacity) {\n            auto tmp = dummy->next;\n            dummy->next = tmp->next;\n            nodes.erase(tmp->key);\n            if (dummy->next != nullptr) {\n                nodes[dummy->next->key] = dummy;\n            }\n            \n            --_size;\n            if (cur == tmp) {\n                cur = dummy;\n            }\n            // printNode(dummy);\n        }\n        \n        auto node = new MyListNode(key, value);\n        cur->next = node;\n        nodes[key] = cur;\n        cur = cur->next;\n        ++_size;\n     \n        // printNode(dummy);\n    }\n    \nprivate:\n    int _capacity = 0;\n    int _size = 0;\n    MyListNode *dummy;\n    MyListNode *cur;\n    unordered_map<int, MyListNode*> nodes;\n    \n    \n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196515960","body":"```c++\n/***\nSolution:\n\nRecursion:\n\n1. if root = nullptr, depth = 0\n2. if root != nullptr, depth = max(left, right) + 1\n\nTime: O(n)\nSpace: O(1)\n\n***/\n\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (root == nullptr) {\n            return 0;\n        }\n        \n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\n        \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197513835","body":"```c++\n/***\nSolution\n1. if p=q=nullptr, return true  O(1)\n2. if p=nullptr, q!=nullptr or q=nullptr, p!=nullptr, return false O(1)\n3. if val = val && left=left && right=right return true O(n)\n4. return false\n\nTime: O(n)\nSpace: O(log(n))\n\n***/\n\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (p == nullptr && q == nullptr) {\n            return true;\n        }\n        \n        if ((p == nullptr && q != nullptr) || \n            (p != nullptr && q == nullptr) ) {\n            return false;\n        }\n        \n        \n        if (p->val == q->val &&\n           isSameTree(p->left, q->left) &&\n           isSameTree(p->right, q->right)  ) {\n            return true;\n        }\n        \n        return false;\n        \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198768243","body":"```c++\n/***\nSolution\n1. use DFS to get all numbers O(n)\n2. add all of them together  O(n)\n\nTime: O(n)\nSpace: O(n)\n\n***/\n\n\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        vector<int> nums;\n        int cur = 0;\n        dfs(root, cur, nums);\n        \n        // for(auto num : nums) {\n        //     cout << num << endl;\n        // }\n        int result = accumulate(nums.begin(), nums.end(), 0);\n        return result;\n        \n    }\n    \n    void dfs(TreeNode* root, int cur, vector<int>& nums) {\n        if (root == nullptr) {\n            return;\n        }        \n        \n        cur = cur*10 + root->val;\n        \n        if (root->left == nullptr &&\n            root->right == nullptr) {\n            nums.push_back(cur);\n            return;\n        }\n        \n        dfs(root->left, cur, nums);\n        dfs(root->right, cur, nums);\n        \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200098987","body":"```c++\n\n/***\nSolution 1\n1. use bfs to put the tree into vector<vector<int>>\n2. return the last vector's first element\n\nTime: O(n)\nSpace: O(n)\n\n\nSolution 2\n1. use dfs \n2. leftleftMostVal, left_depth = f( root->left)\n3. rightleftMostVal, right_depth = f(root->left)\n\n\n***/\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        if (root == nullptr) {\n            return 0;\n        }\n        auto nums  = bfs(root);\n        return nums[nums.size() - 1][0];\n    }\n    \n    vector<vector<int>> bfs (TreeNode* root) {\n        vector<vector<int>> results;\n        queue<TreeNode*> q;\n        q.push(root);\n        while (!q.empty()) {\n            vector<int> nums;\n            int level_len = q.size();\n            while (level_len > 0) {\n                auto* node = q.front();\n                nums.push_back(node->val);\n                q.pop();\n                if (node->left != nullptr) {\n                    q.push(node->left);\n                }\n                \n                if (node->right != nullptr) {\n                    q.push(node->right);\n                }\n                \n                --level_len;\n            }\n            results.push_back(nums);\n        }\n        \n        return results;\n    }\n    \n\n    \n};\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200370563","body":"```c++\n/***\nSolution:\n1. We can do the same thing as leetcode input,\nThen we can serialize the input by using BFS\n[1,2,3,null,null, 4, 5, null, null, null, null]\nTime: O(n)\nSpace: O(n)\n\n\ndeserialize:\nwe can use queue again, \nTime: O(n)\nSpace: O(n)\n\n***/\n\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Codec {\npublic:\n\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        string result = \"\";\n        queue<TreeNode*> q;\n        q.push(root);\n        \n        while(!q.empty()) {\n            auto node = q.front();\n            q.pop();\n            if (node == nullptr) {\n                result += \"N,\";\n                continue;\n            }\n            \n            result += to_string(node->val);\n            result += \",\";\n            q.push(node->left);\n            q.push(node->right);    \n        }\n        \n        \n        return result;\n        \n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        if (data == \"N,\") {\n            return nullptr;\n        }        \n        stringstream ss(data);\n        vector<string> nums;\n        queue<TreeNode*> q;\n        string tmp;\n        TreeNode* head;\n        if (getline(ss, tmp, ',')) {\n            head = new TreeNode(stoi(tmp));\n        }\n        else {\n            return nullptr;\n        }\n        q.push(head);\n        while (!q.empty()) {\n            auto node = q.front();\n            q.pop();\n            if (getline(ss, tmp, ',') && tmp != \"N\") {\n                node->left = new TreeNode(stoi(tmp));\n                q.push(node->left);\n            }\n            \n            if (getline(ss, tmp, ',') && tmp != \"N\") {\n                node->right = new TreeNode(stoi(tmp));\n                q.push(node->right);\n            }\n        }\n        \n        return head;\n    }\n    \n    \n    \n    \n};\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser, deser;\n// TreeNode* ans = deser.deserialize(ser.serialize(root));\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201250363","body":"```c++\n/***\nSolution:\n1. recursiely calculate the column and row O(n)\n2. use a map <column, <row, vector<int>>> \n3. aggregate the map into vector<vector>, for the same column, row, sort it first O(nlogn)\n\n\nTime: O(nlogn)\nSpace: O(n)\n***/\n\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        map<int, map<int, vector<int>>> m;\n        calCoord(root, 0, 0, m);\n        \n        vector<vector<int>> results;\n        for (auto m_iter : m) {\n            vector<int> nums;\n            for (auto v_iter : m_iter.second) {\n                auto v = v_iter.second;\n                sort(v.begin(), v.end());\n                nums.insert(nums.end(), v.begin(), v.end());\n            }\n            results.push_back(nums);\n        }\n        \n        return results;\n        \n    }\n    \n    void calCoord(TreeNode* root, int x, int y, map<int, map<int, vector<int>>>& m) {\n        if (root == nullptr)\n            return;\n        if (m.find(y) != m.end()) {\n            if (m[y].find(x) != m[y].end()) {\n                m[y][x].push_back(root->val);\n            }\n            else {\n                vector<int> nums{root->val};\n                m[y][x] = nums;\n            }\n        }\n        else {\n            map<int,vector<int>> newMap;\n            vector<int> nums{root->val};\n            m[y] = newMap;\n            m[y][x] = nums;\n        }\n        \n        calCoord(root->left, x + 1, y - 1, m);\n        calCoord(root->right, x + 1, y + 1, m);\n        \n    }\n    \n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202316499","body":"```c++\n/***\nSolution:\nDS: hash map\n1. for each num, check if target - num in the hash map Time O(n)\n2. if not, add this num in the hash map Space O(n)\n\n\nTime: O(n)\nSpace: O(n)\n\n***/\n\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        vector<int> results;\n        \n        unordered_map<int, int> m;\n        for (int i = 0; i < nums.size(); ++i) {\n            auto num = nums[i];\n            if (m.find(target - num) != m.end()) {\n                vector<int> r{m[target-num], i};\n                return r;\n            }\n            m[num] = i;\n        }\n                \n                \n        return results;       \n                \n                \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1204786274","body":"```c++\n/***\nSolution: \n1. count, Hash_map<num, count> O(n)\n\ncreate \nPriority Queue:\nNode {\n    int num\n    int count\n}\n\nTime: O(nlogn)\nSpace: O(n)\n\n***/\n\nstruct Node {\n    int num;\n    int count = 0;\n    Node(int n, int c):num(n), count(c){}\n};\n\nstruct Compare\n{    \n    bool operator()(const Node* a, const Node* b) {\n        return a->count < b->count;\n    }\n};\n\n\n\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int, Node*> counts;\n        for (auto num : nums) {\n            if (counts.find(num) != counts.end()) {\n                counts[num]->count += 1;\n            }\n            else {\n                counts[num] = new Node(num, 0);\n            }\n        }\n        \n        priority_queue<Node*, vector<Node*>, Compare> pq;\n        \n        for (auto iter : counts) {\n            pq.push(iter.second);\n        }\n        \n        vector<int> result;\n        while (k > 0) {\n            result.push_back(pq.top()->num);\n            pq.pop();\n            --k;\n        }\n        \n        \n        return result;\n        \n        \n    }\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204764524","body":"```c++\n/***\nSolution:\nDS: Hash_Map<distance, number>\n\nfor every point, we need to find this map, and calculate distance individually.\n\npair = 1  => 0\npair = 2 => 1*2 = (1 + pair -1 ) *(pair - 1) = pair * (pair -1) = \npair = 3 => (2 + 1) * 2 = 6 = 3 * 2\npair = 4 => (3 + 2 + 1) * 2 = 12 = 4 * 3\n\n\nTime: O(n^2)\nSpace:O(n)\n\n***/\n\n\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        if (points.size() < 3 ) {\n            return 0;\n        }\n        \n        int result = 0;\n        \n        for (int i = 0 ; i < points.size(); ++i) {\n            unordered_map<double, int> dist_map;\n            for (int j = 0; j < points.size(); ++j) {\n                if (i == j) {\n                    continue;\n                }\n                auto A = points[i];\n                auto B = points[j];\n                double tmp = pow((A[0]-B[0]),2)  + pow((A[1] -B[1]), 2);\n                // cout << tmp << endl;\n                double dist = sqrt(tmp);\n                if (dist_map.find(dist) == dist_map.end()) {\n                    dist_map[dist] = 1;\n                }\n                else {\n                    dist_map[dist] +=1;\n                }      \n            }\n            \n            for (auto iter: dist_map) {\n                // cout << iter.first << \"  \" << iter.second << endl;\n                int pair = iter.second;\n                result += pair * (pair - 1);\n            }\n            // cout << endl;\n        \n        }\n        \n        \n       \n        return result;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206309497","body":"```c++\n/***\n1. left <-- --->right\n2. hash_map <char, position>\n3. move right pointer\n    (1) if it is a new char, insert <char, pos>, update max(result, r - l + 1)\n    (2) if it already exisit, update <char, new_pos>, \n        update l = max (l, pos[s[r]] + 1), \n        some chars could occur twice, but once before l, once after l\n        like, c xxx l xxx c, we need to ignore the first one.\n        So it is max (l, pos[s[r]] + 1)\n\nTime: O(n)\nSpace: O(n) hash_map\n\n\n***/\n\n\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int result = 0;\n        int l = 0;\n        int r = 0;\n        unordered_map<int, int> pos;\n        for (; r < s.size(); ++r) {\n            if (pos.find(s[r]) == pos.end()) {\n                pos[s[r]] = r;\n                \n            }\n            else {\n                l = max(l, pos[s[r]] + 1);\n                pos[s[r]] = r;\n            }\n            result = max (result, r - l + 1);\n            // cout << r << \" \" << l << endl;\n        }\n        \n        return result;\n        \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207153035","body":"```c++\n/****\nSolution:\nl iterate through whole s.size()\nwe can divide this iteration into word_len parts\n0:  l = 0 + word_len * 0, 0 + word_len * 1, 0 + word_len * 2....\n1: l = 1 + word_len * 0, 1 + word_len * 1, 1 + word_len * 2....\n...\nword_len -1 : l = word_len-1, word_len - 1 + word_len * 1\n\nThen we can jump! make use of the sliding window to avoid duplication calculation\n\n\nsince len of target substring is fixed  = words.size()\nwe can track the words we have found, if  found == words.size() && no negative used, then\nwe found an answer\n\nSliding window:\nr = l\ncur = s[r, word_len]\nfor a new string:\n1. if cur in seen_map, \n   --seen_map[cur], ++wordused\n   \n   while seen_map[cur] < 0, move left\n   \n   if seen_map[cur] == 0, if wordused == targetword, \n        found ! move left to left+word_len, ++seen_map[leftword], --wordused\n    \n2. if cur not in seen_map, l = r + word_len, reset \n\nDONT COPY MAP!\n\ns.size() =  n\nwords.size() = a\nword length  = b\nconstruct seen map: Time a, Space a\nloop: Time b * sliding_window\nSliding_window: left and right pointer, n \nTime: O(a + n * b)\nSpace:O(a)\n***/\n\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        int target_len = words.size();\n        int word_len = words[0].size();\n        vector<int> results;\n        unordered_map<string, int> seen;\n        for (auto word : words) {\n            if (seen.find(word) != seen.end()) {\n                seen[word] += 1;\n            }\n            else {\n                seen[word] = 1;\n            }\n        }\n        \n        for (int l = 0; l < word_len; ++l) {\n            sliding_window(s, seen, target_len, word_len, results, l);\n        }\n        \n        return results;\n    }\n    \n    void sliding_window(const string& s, \n                        unordered_map<string, int> &count, \n                        int target_len, \n                        int word_len, \n                        vector<int> &results,\n                        int l) {\n        unordered_map<string, int> seen;\n        int word_used = 0;\n        for (int r = l; r  < s.size(); r += word_len) {\n            string cur = s.substr(r, word_len);\n            // cout << \"l: \" << l << \"r :\" << r << \" cur:\" << cur << endl; \n            if (count.find(cur) != count.end()) {\n                if (seen.find(cur) != seen.end()) {\n                    seen[cur] += 1;\n                }\n                else {\n                    seen[cur] = 1;\n                }\n                \n                ++word_used;\n                \n                while (seen[cur] > count[cur]) {\n                    string l_word = s.substr(l, word_len);\n                    seen[l_word] -= 1;\n                    l += word_len;\n                    --word_used;\n                }\n                \n                if (word_used == target_len) {\n                    results.push_back(l);\n                    string l_word = s.substr(l, word_len);\n                    seen[l_word] -= 1;\n                    l += word_len;\n                    --word_used;\n                    // cout << \"l \" << l << \"r\" << r << endl;\n                }\n                \n                while (word_used > target_len) {\n                    string l_word = s.substr(l, word_len);\n                    seen[l_word] -= 1;\n                    l += word_len;\n                    --word_used;\n                }\n                // cout << \"dddd\";\n                \n                // r = max (r, l);\n            }\n            else {\n                l = r + word_len;\n                r = l - word_len;\n                seen.clear();\n                word_used = 0;\n            }\n        }\n        \n        \n    }\n    \n    \n    \n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207303447","body":"```c++\r\n/***\r\nSolution:\r\nDS: hash_map<pre_sum_left, index>\r\n\r\nif (sum2 % k) - (sum1 % k) == a\r\n   (sum2 - sum1) % k == a\r\n   sum(1 to 2) % k == a\r\nif (sum2 % k) < (sum1 % k)\r\n   check if (sum2 % k) + k - (sum1 % k) == a\r\n\r\n\r\n1. get sum of nums, sum % k = a  O(n)\r\n2. find the shortest sublist whose sum % k = a\r\n3. iterate the whole list,\r\n   check if (pre_sum % k) - num_left in the hash_map\r\n   if (pre_sum % k) < num_left, \r\n      check if (pre_sum % k) + k - num_left in the hash_map\r\n   calculate the pre-sum % k, store <left, index>\r\n\r\nCorner case:\r\nk[0] = -1\r\nor \r\nif sum % k == 0, return 0\r\n\r\nTime: O(n)\r\nSpace: O(n)\r\n\r\n***/\r\n\r\n\r\nint solve(vector<int>& nums, int k) {\r\n    int sum_nums = accumulate(nums.begin(), nums.end(), 0);\r\n    int left = sum_nums % k;\r\n    if (left == 0) {\r\n        return 0;\r\n    }\r\n    // cout << sum_nums << \" \" << left << endl;\r\n    int result = nums.size();\r\n    unordered_map<int, int> m;\r\n    m[0] = -1;\r\n    int l = 0;\r\n    int r = 0;\r\n    int sum = 0;\r\n    for (; r < nums.size(); ++r) {\r\n        sum += nums[r];\r\n        int sum_left = sum % k;\r\n        int diff = sum_left < left ? sum_left + k - left : sum_left -left;\r\n        if (m.find(diff) != m.end()) {\r\n\r\n            result = min(result, r - m[diff] );\r\n        }\r\n        \r\n        m[sum_left] = r;\r\n        \r\n        // cout << \"sum_left \" << sum_left << \" diff \" << diff << \" result \" << result << endl;\r\n    }\r\n\r\n    if (result == nums.size()) {\r\n        return -1;\r\n    }\r\n\r\n    return result;\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207571501","body":"```c++\n/***\nSolution:\nTwo pointers\nslow ->      1 step/iteration\nfaster -> -> 2 steps/iteration\n\nwhen faster reaches the end\nslow reaches middle\n\nTime: O(n)\nSpace: O(1)\n***/\n\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        auto slow = head;\n        auto fast = head;\n        while (fast != nullptr && fast->next != nullptr) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        \n        return slow;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208896298","body":"```c++\n/***\nSolution 1:\nuse a set, Space: O(n)\nadd to the set, Time: O(nlog(n))\ncopy them to Time: O(n)\nTime: nlogn\nSpace: O(n)\n\nSolution2:\nl r\nl iterate through vector, \nmoving r until *r != *l\nremove l + 1 to r\nfor each l, we need to move O(n)\nSo the time could be: O(n ^ 2)\nTime: O(n^2)\nSpace: O(1)\n\n\n***/\n\n\nclass Solution {\npublic:\n//     int removeDuplicates(vector<int>& nums) {\n//         for (auto iter = nums.begin(); iter != nums.end(); ++iter) {\n//             auto iterr = iter;\n//             while (iterr != nums.end() && *iterr == *iter) {\n//                 ++iterr;\n//             }\n//             nums.erase(iter + 1, iterr);\n//         }\n        \n//         return nums.size();\n//     }\n    int removeDuplicates(vector<int>& nums) {\n        set<int> s;\n        for (auto num : nums) {\n            s.insert(num);\n        }\n        copy(s.begin(), s.end(), nums.begin());\n        \n        return s.size();\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aq666888":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185658990","body":"### è§£é¢˜æ€è·¯\n\nâ€‹\tå°†æ•°ç»„çš„æ¯ä¸€ä½å€’åºå–å‡ºç„¶åå’Œkè¿›è¡Œç›¸åŠ ï¼Œç¡®ä¿kæ¯æ¬¡æ˜¯ä¸ªä½æ•°ã€‚\n\nâ€‹\tå½“å‰ä½ = (A çš„å½“å‰ä½ + B çš„å½“å‰ä½ + è¿›ä½carry) % 10\n\nâ€‹\tæ³¨æ„ï¼ŒABä¸¤æ•°éƒ½åŠ å®Œåï¼Œæœ€ååˆ¤æ–­ä¸€ä¸‹è¿›ä½ carry, è¿›ä½ä¸ä¸º 0 çš„è¯åŠ åœ¨å‰é¢ã€‚\n\nâ€‹\tæœ€ååè½¬æ•°ç»„\n\n### ä»£ç å®ç°\n\n```java\nclass Solution {\npublic List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> res = new ArrayList<Integer>();  \n    int carry=0; //åˆ¤æ–­è¿›ä½\n    int i=num.length -1; //åˆ¤æ–­æ•°ç»„é‡Œçš„æ•´æ•°æ˜¯å¦éå†ç»“æŸ\n    // å¯ä»¥ç”¨ LinkeListï¼Œæˆ–è€… ArrayList å¾€ååŠ ï¼Œæœ€ååè½¬\n\n    while (i >= 0 || k!= 0) { \n        int x = i>= 0 ? num[i]: 0;\n        int y = k!= 0 ? k % 10 : 0;\n                    \n        int sum = x + y + carry;\n        res.add(sum % 10);\n        carry =sum/10;\n        i--;\n        k=k/10;\n    }\n        if(carry !=0)res.add(carry);\n        Collections.reverse(res);\n        return res;\n       \n\t}\n}    \n```\n\n\n\n### å¤æ‚åº¦ï¼š\n\n```md\næ—¶é—´å¤æ‚åº¦ : O(min(n,k)) \nç©ºé—´å¤æ‚åº¦: O(n)\n```\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186211456","body":"\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n\n int length=s.length();\n        List<Integer> list=new ArrayList<Integer>();\n        int[] res=new int[length];\n        for(int i=0;i<length;i++)\n        {\n            if(s.charAt(i)==c)\n            {\n                list.add(i);\n            }\n        }\n        int i=0;\n        int j=0;\n        while(i<length)\n        {\n            int min=Math.abs(list.get(j)-i);\n            while(j<list.size())\n            {\n                if(min>Math.abs(list.get(j)-i))\n                {\n                    min=Math.abs(list.get(j)-i);\n                }\n                j++;\n            }\n            res[i]=min;\n            j=0;\n            i++;\n        }\n        return res;\n\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186439547","body":"class CustomStack {\n        int[]stack;\n        int top;\n    public CustomStack(int maxSize) {\n        stack=new int [maxSize];\n        top=-1;\n\n    }\n    \n    public void push(int x) {\n        if(top!=stack.length-1)\n        {\n            top++;\n            stack[top]=x;\n        }\n    }\n    \n    public int pop() {\n          if(top==-1)\n        {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];   \n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; ++i)\n        {\n            stack[i] += val;\n        }\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187570040","body":" StringBuilder res = new StringBuilder();\n        int multi = 0;\n        // LinkedList<Integer> stack_multi = new LinkedList<>();\n        // LinkedList<String> stack_res = new LinkedList<>();\n        Stack<Integer> stack_multi = new Stack<>();\n        Stack<String> stack_res = new Stack<>();\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                stack_multi.push(multi);\n                stack_res.push(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            }\n            else if(c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = stack_multi.pop();\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\n                res = new StringBuilder(stack_res.pop() + tmp);\n            }\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c+\"\");\n            else res.append(c);\n        }\n        return res.toString();","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189132256","body":"class MyQueue {\n    Deque<Integer> inStack;\n    Deque<Integer> outStack;\n\n    public MyQueue() {\n        inStack = new ArrayDeque<Integer>();\n        outStack = new ArrayDeque<Integer>();\n    }\n\n    public void push(int x) {\n        inStack.push(x);\n    }\n\n    public int pop() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.pop();\n    }\n\n    public int peek() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.peek();\n    }\n\n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n\n    private void in2out() {\n        while (!inStack.isEmpty()) {\n            outStack.push(inStack.pop());\n        }\n    }\n}\n\næ—¶é—´å¤æ‚åº¦Oï¼ˆ1ï¼‰\nç©ºé—´å¤æ‚åº¦Oï¼ˆn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190337226","body":"class Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for (int num : arr) {\n            // é‡åˆ°ä¸€ä¸ªæ¯”æ ˆé¡¶å°çš„å…ƒç´ ï¼Œè€Œå‰é¢çš„å—ä¸åº”è¯¥æœ‰æ¯” a å°çš„\n            // è€Œæ ˆä¸­æ¯ä¸€ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªå—ï¼Œå¹¶ä¸”æ ˆçš„å­˜çš„æ˜¯å—çš„æœ€å¤§å€¼ï¼Œå› æ­¤æ ˆä¸­æ¯” a å°çš„å€¼éƒ½éœ€è¦ pop å‡ºæ¥\n            if (!stack.isEmpty() && num < stack.getLast()) {\n                // æˆ‘ä»¬éœ€è¦å°†èåˆåçš„åŒºå—çš„æœ€å¤§å€¼é‡æ–°æ”¾å›æ ˆ\n                // è€Œ stack æ˜¯é€’å¢çš„ï¼Œå› æ­¤ stack[-1] æ˜¯æœ€å¤§çš„\n                int cur = stack.removeLast();\n                // ç»´æŒæ ˆçš„å•è°ƒé€’å¢\n                while (!stack.isEmpty() && num < stack.getLast()) {\n                    stack.removeLast();\n                }\n                stack.addLast(cur);\n            } else {\n                stack.addLast(num);\n            }\n        }\n        // æ ˆå­˜çš„æ˜¯å—ä¿¡æ¯ï¼Œå› æ­¤æ ˆçš„å¤§å°å°±æ˜¯å—çš„æ•°é‡\n        return stack.size();\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191525255","body":"class Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null) return head;\n        int count = 0;\n        ListNode now = head;\n        while(now != null){\n            now = now.next;\n            count++;\n        }\n        k = k % count;\n        ListNode slow = head, fast = head;\n        while(fast.next != null){\n            if(k-- <= 0){\n                slow = slow.next;\n            }\n            fast = fast.next;\n        }\n        fast.next = head;\n        ListNode res = slow.next;\n        slow.next = null;\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192680813","body":"class Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null) return head;\n        ListNode preNode = new ListNode(-1, head), res;\n        preNode.next = head;\n        res = head.next;\n        ListNode firstNode = head, secondNode, nextNode;\n        while(firstNode != null && firstNode.next != null){\n            secondNode = firstNode.next;\n            nextNode = secondNode.next;\n\n            firstNode.next = nextNode;\n            secondNode.next = firstNode;\n            preNode.next = secondNode;\n\n            preNode = firstNode;\n            firstNode = nextNode;\n        }\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193130155","body":"class Solution {\n  public TreeNode sortedListToBST(ListNode head) {\n      if(head == null) return null;\n      return dfs(head,null);\n  }\n  private TreeNode dfs(ListNode head, ListNode tail){\n      if(head == tail) return null;\n      ListNode fast = head, slow = head;\n      while(fast != tail && fast.next != tail){\n          fast = fast.next.next;\n          slow = slow.next;\n      }\n      TreeNode root = new TreeNode(slow.val);\n      root.left = dfs(head, slow);\n      root.right = dfs(slow.next, tail);\n      return root;\n  }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193330319","body":"public class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode A = headA, B = headB;\n        while (A != B) {\n            A = A != null ? A.next : headB;\n            B = B != null ? B.next : headA;\n        }\n        return A;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1195558209","body":"public class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode pos = head;\n        Set<ListNode> visited = new HashSet<ListNode>();\n        while (pos != null) {\n            if (visited.contains(pos)) {\n                return pos;\n            } else {\n                visited.add(pos);\n            }\n            pos = pos.next;\n        }\n        return null;\n    }\n}\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195557209","body":"class LRUCache {\n    class DLinkedNode {\n        int key, value;\n        DLinkedNode prev, next;\n        public DLinkedNode() {}\n        public DLinkedNode(int _key, int _value) {\n            key = _key;\n            value = _value;\n        }\n    }\n\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size, cap;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        size = 0;\n        cap = capacity;\n        //add dummy head and dummyTail\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) return -1;\n        //if key exist, move it to head by using its location store in Hashmap\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            //made a newNode if it does not exist\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            cache.put(key, newNode);\n            addToHead(newNode);\n            ++size;\n            if (size > cap) {\n                DLinkedNode removedTail = removeTail();\n                cache.remove(removedTail.key);\n                --size;\n            }\n        } else {\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DLinkedNode node){\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node){\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DLinkedNode node){\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail(){\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196858363","body":"class Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null){\n            return 0;\n        }\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198217489","body":"class Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val != q.val) return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"samlu-ecnu":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185660112","body":"### æ€è·¯\n\næ•°å­—è¿˜åŸåç›¸åŠ ï¼Œå†è½¬æ¢ä¸ºæ•°å­—åˆ—è¡¨ã€‚\n\n### ä»£ç \n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        degit = 0\n        for d in num:\n            degit *= 10\n            degit += d\n        # print(degit)\n        k += degit\n        # print(k)\n\n        res = []\n        while k != 0:\n            res.append(k % 10)\n            # print(res)\n            k //= 10\n        return res[::-1]\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186223951","body":"### æ€è·¯\n\néå†ä¸€éå­—ç¬¦ä¸²ï¼Œå¾—åˆ°`id_list`å­˜å‚¨ç›¸ç­‰çš„ç´¢å¼•ï¼Œå¹¶ä¸”ç½®è¿”å›æ•°ç»„`ans`å¯¹åº”ä½ç½®ä¸º0ï¼›å†æ¬¡éå†æ•°ç»„ï¼Œå¯¹äºæ¯ä¸ªä¸ç›¸ç­‰çš„å­—ç¬¦ä½ç½®è®¡ç®—`id_list`ä¸­ï¼Œä¸ä¹‹æœ€è¿‘çš„ç´¢å¼•è·ç¦»ï¼Œå¹¶è®°å½•åœ¨è¿”å›æ•°ç»„`ans`å¯¹åº”ä½ç½®ã€‚\n\n### ä»£ç \n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = [-1] * len(s)\n        id_list = []\n        for i in range(len(s)):\n            if s[i] == c:\n                ans[i] = 0\n                id_list.append(i)\n        for i, ch in enumerate(s):\n            if ch != c:\n                min_dst = len(s)\n                for idx in id_list:\n                    min_dst = min(min_dst, abs(i - idx))\n                ans[i] = min_dst\n                \n        return ans\n```\n\n### å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼š$O(n^2)$\n\nç©ºé—´å¤æ‚åº¦ï¼š$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186541287","body":"### æ€è·¯\n\nä½¿ç”¨åˆ—è¡¨æ¨¡æ‹Ÿå †æ ˆï¼Œè°ƒç”¨åˆ—è¡¨æ–¹æ³•å®ç°åŠŸèƒ½ã€‚\n\n### ä»£ç \n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n\n\n    def push(self, x: int) -> None:\n        if self.maxSize > len(self.stack):\n            self.stack.append(x)\n\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        else:\n            return -1\n\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len(self.stack))):\n            self.stack[i] += val\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187675530","body":"### æ€è·¯\n\næ ¹æ®å­—ç¬¦ä¸²ä¸­ä¸åŒç§ç±»çš„å­—ç¬¦åˆ†æƒ…å†µè®¨è®ºï¼Œåˆ©ç”¨æ ˆå‚¨å­˜æ¯ä¸€æ¬¡çš„ä¹˜æ•°ä»¥åŠä¸­é—´ç»“æœã€‚\n\n### ä»£ç \n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack, res, num = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append([num, res])\n                res, num = \"\", 0\n            elif c == ']':\n                cur_num, last_res = stack.pop()\n                res = last_res + cur_num * res\n            elif '0' <= c <= '9':\n                num = num * 10 + int(c)            \n            else:\n                res += c\n        return res\n```\n\n### å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\n\næ—¶é—´å¤æ‚åº¦ï¼š$O(n^2)$\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189227283","body":"### æ€è·¯\n\nåˆ©ç”¨ä¸¤ä¸ªæ ˆä¹‹é—´æ¥å›å‚¨å­˜æ¯ä¸€ä¸ªå…ƒç´ ï¼Œå®ç°é˜Ÿåˆ—çš„ç›¸åº”åŠŸèƒ½ã€‚\n\n### ä»£ç \n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n\n    def pop(self) -> int:\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        res = self.stack2.pop()\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n        return res\n\n\n    def peek(self) -> int:\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        res = self.stack2[-1]\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n        return res\n\n\n    def empty(self) -> bool:\n        return self.stack1 == []\n```\n\n### å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\n\nç©ºé—´å¤æ‚åº¦ï¼š$O(n)$\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190434807","body":"### æ€è·¯\n\nè™šå‡çš„å›°éš¾ã€‚ã€‚è€ƒè™‘åˆ†å—éœ€è¦æ’åºï¼Œäºæ˜¯å¯ä»¥é€’å¢èŒƒå›´å’Œæ’åºå®Œçš„æ•°ç»„è¿›è¡Œå¯¹æ¯”ã€‚å¯¹æ¯”çš„æ–¹å¼è¿™é‡Œå¯ä»¥è®¡ç®—å‰ç¼€å’Œæ˜¯å¦ç›¸ç­‰ï¼Œå¦‚æœå‰ç¼€å’Œç›¸ç­‰ï¼Œå°±æ˜¯ä¸€ä¸ªåˆ†å—ã€‚\n\nè¿™é‡Œçš„å……è¦æ€§ä½“ç°åœ¨ï¼šåˆ†å—çš„èŒƒå›´ä¸æ’åºåçš„èŒƒå›´æ˜¯ä¸€è‡´çš„ï¼Œäºæ˜¯åˆ†å—åçš„æ“ä½œå°±æ˜¯å¯¹è¿™ä¸ªèŒƒå›´ä¹‹å†…çš„å…ƒç´ è¿›è¡Œåæ ‡æ”¹å˜ï¼Œè€Œå…ƒç´ æ•°å€¼ä¸ä¼šè¿›è¡Œæ”¹å˜ï¼Œä¸¤ä¸ªèŒƒå›´çš„æ•°å€¼å’Œç›¸åŒï¼Œè¯´æ˜å¯ä»¥é€šè¿‡å¯¹åˆ†å—çš„åæ ‡è¿›è¡ŒæŸç§æ”¹å˜æ¥å¾—åˆ°æ’åºåçš„æ•°ç»„ã€‚\n\n### ä»£ç \n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        sorted_arr = sorted(arr)\n\n        arr_sum = 0\n        sorted_sum = 0\n\n        res = 0\n\n        for x, y in zip(arr, sorted_arr):\n            arr_sum += x\n            sorted_sum += y\n\n            if arr_sum == sorted_sum:\n                res += 1\n        \n        return res\n```\n\n### å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼š$O(nlog(n))$\n\nç©ºé—´å¤æ‚åº¦ï¼š$O(n)$\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191178242","body":"### æ€è·¯\n\næ•´ä½“å³ç§»`k`ä¸ªä½ç½®ç­‰äºä»¥`n-k`ä½ç½®ä¹‹åçš„èŠ‚ç‚¹ä½œä¸ºå¤´èŠ‚ç‚¹ï¼Œå°†é“¾è¡¨æˆç¯ï¼Œå¹¶ä»¥`n-k`ä½ç½®ä¹‹åè¿›è¡Œæ–­è£‚ã€‚\n\n### ä»£ç \n\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if head is None or head.next is None or k == 0:\n            return head\n        cur = head\n        n = 1\n        while cur.next:\n            cur = cur.next\n            n += 1\n        \n        add = n - k % n\n\n        if add == n:\n            return head\n        \n        cur.next = head\n        \n        while add:\n            cur = cur.next\n            add -= 1\n        \n        ret = cur.next\n        cur.next = None\n        \n        return ret\n```\n\n### å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\n\nç©ºé—´å¤æ‚åº¦ï¼š$O(1)$\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192717843","body":"### æ€è·¯\n\nè¿­ä»£çš„æ–¹å¼ï¼Œåœ¨åŸæœ‰å¤´èŠ‚ç‚¹ä¹‹å‰å¢è®¾ä¸€ä¸ªç©ºèŠ‚ç‚¹ï¼Œå¯¹ä¸‰ä¸ªèŠ‚ç‚¹ä¹‹é—´è¿›è¡Œåä¸¤ä¸ªèŠ‚ç‚¹çš„äº¤æ¢æ“ä½œï¼Œç›´è‡³é“¾è¡¨åªå‰©ä¸€ä¸ªèŠ‚ç‚¹æˆ–è€…å®Œå…¨è¢«éå†ã€‚\n\n### ä»£ç \n\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        pre_head = ListNode()\n        pre_head.next = head\n        temp = pre_head\n        while temp.next and temp.next.next:\n            node1 = temp.next\n            node2 = temp.next.next \n\n            temp.next = node2\n            node1.next = node2.next\n            node2.next = node1\n            temp = node1\n        return pre_head.next\n```\n\n### å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\n\nç©ºé—´å¤æ‚åº¦ï¼š$O(1)$\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193143426","body":"### æ€è·¯\n\nä½¿ç”¨å¿«æ…¢æŒ‡é’ˆå¯»æ‰¾é“¾è¡¨çš„ä¸­é—´èŠ‚ç‚¹ï¼Œä»¤æ‰¾åˆ°çš„ä¸­é—´èŠ‚ç‚¹ä¸ºæ ¹ç»“ç‚¹ï¼Œå¹¶ä¸”é€šè¿‡é€’å½’çš„æ–¹å¼ä»é“¾è¡¨çš„å·¦å³éƒ¨åˆ†æ„å»ºå­æ ‘ã€‚\n\n### ä»£ç \n\n```python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        def getMedian(left, right):\n            fast = left\n            slow = left\n            while fast != right and fast.next != right:\n                fast = fast.next.next\n                slow = slow.next\n\n            return slow\n\n        def buildTree(left, right):\n            if left == right:\n                return None\n\n            mid = getMedian(left, right)\n            root = TreeNode(mid.val)\n            root.left = buildTree(left, mid)\n            root.right = buildTree(mid.next, right)\n\n            return root\n        \n        return buildTree(head, None)\n```\n\n### å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\n\nç©ºé—´å¤æ‚åº¦ï¼š$O(logn)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193309624","body":"### æ€è·¯\n\nä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«æŒ‰ç…§é¡ºåºABä¸BAåŒæ­¥éå†é“¾è¡¨ã€‚å¦‚æœä¸¤ä¸ªé“¾è¡¨å…·æœ‰äº¤å‰èŠ‚ç‚¹ï¼Œåˆ™ä¼šå‡ºç°ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘ç›¸åŒèŠ‚ç‚¹çš„æƒ…å†µï¼›å¦‚æœä¸¤ä¸ªé“¾è¡¨æ²¡æœ‰äº¤å‰èŠ‚ç‚¹ï¼Œåˆ™ä¼šå‡ºç°ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘`None`çš„æƒ…å†µã€‚äºæ˜¯ï¼Œè¿”å›ä¸¤ä¸ªæŒ‡é’ˆç›¸åŒæ—¶çš„å…ƒç´ å³å¯ã€‚\n\n### ä»£ç \n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        p1 = headA\n        p2 = headB\n        while p1 != p2:\n            if p1:\n                p1 = p1.next\n            else:\n                p1 = headB\n            if p2:\n                p2 = p2.next\n            else:\n                p2 = headA\n                \n        return p1\n```\n\n### å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\n\nç©ºé—´å¤æ‚åº¦ï¼š$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193815502","body":"### æ€è·¯\n\nä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆï¼Œåˆ†åˆ«æŒ‰ç…§1å’Œ2çš„é€Ÿåº¦è¿›è¡Œé“¾è¡¨éå†ã€‚å¦‚æœé“¾è¡¨å…·æœ‰ç¯ï¼Œåˆ™ä¼šå‡ºç°ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘ç›¸åŒèŠ‚ç‚¹çš„æƒ…å†µï¼›å¦‚æœä¸¤ä¸ªé“¾è¡¨æ²¡æœ‰äº¤å‰èŠ‚ç‚¹ï¼Œåˆ™ä¼šå‡ºç°å¿«æŒ‡é’ˆä¸º`None`æˆ–å¿«æŒ‡é’ˆæŒ‡å‘`None`çš„æƒ…å†µã€‚å¯¹äºè¿”å›çš„ç›¸åŒèŠ‚ç‚¹ï¼Œå†è®¾ç½®æ–°æŒ‡é’ˆä»å¤´èŠ‚ç‚¹ä½œä¸ºå¼€å§‹ä¸ä¹‹åŒæ—¶å‰è¿›ï¼Œå½“ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘ç›¸åŒçš„å…ƒç´ æ—¶ï¼Œå³ä¸ºé“¾è¡¨ç¯çš„å…¥å£ã€‚\n\n### ä»£ç \n\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        if not head:\n            return None\n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                break\n\n        if not fast or not fast.next:\n            return None\n        \n        res = head\n        while res != slow:\n            res = res.next\n            slow = slow.next\n\n        return res\n```\n\n### å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\n\nç©ºé—´å¤æ‚åº¦ï¼š$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195641392","body":"### æ€è·¯\n\né€šè¿‡å“ˆå¸Œè¡¨è¾…ä»¥åŒå‘é“¾è¡¨å®ç°\n\n### ä»£ç \n\n```python\nclass DLinkedNode:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cache = dict()\n        # ä½¿ç”¨ä¼ªå¤´éƒ¨å’Œä¼ªå°¾éƒ¨èŠ‚ç‚¹    \n        self.head = DLinkedNode()\n        self.tail = DLinkedNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.capacity = capacity\n        self.size = 0\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        # å¦‚æœ key å­˜åœ¨ï¼Œå…ˆé€šè¿‡å“ˆå¸Œè¡¨å®šä½ï¼Œå†ç§»åˆ°å¤´éƒ¨\n        node = self.cache[key]\n        self.moveToHead(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.cache:\n            # å¦‚æœ key ä¸å­˜åœ¨ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„èŠ‚ç‚¹\n            node = DLinkedNode(key, value)\n            # æ·»åŠ è¿›å“ˆå¸Œè¡¨\n            self.cache[key] = node\n            # æ·»åŠ è‡³åŒå‘é“¾è¡¨çš„å¤´éƒ¨\n            self.addToHead(node)\n            self.size += 1\n            if self.size > self.capacity:\n                # å¦‚æœè¶…å‡ºå®¹é‡ï¼Œåˆ é™¤åŒå‘é“¾è¡¨çš„å°¾éƒ¨èŠ‚ç‚¹\n                removed = self.removeTail()\n                # åˆ é™¤å“ˆå¸Œè¡¨ä¸­å¯¹åº”çš„é¡¹\n                self.cache.pop(removed.key)\n                self.size -= 1\n        else:\n            # å¦‚æœ key å­˜åœ¨ï¼Œå…ˆé€šè¿‡å“ˆå¸Œè¡¨å®šä½ï¼Œå†ä¿®æ”¹ valueï¼Œå¹¶ç§»åˆ°å¤´éƒ¨\n            node = self.cache[key]\n            node.value = value\n            self.moveToHead(node)\n    \n    def addToHead(self, node):\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n    \n    def removeNode(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def moveToHead(self, node):\n        self.removeNode(node)\n        self.addToHead(node)\n\n    def removeTail(self):\n        node = self.tail.prev\n        self.removeNode(node)\n        return node\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196923209","body":"### æ€è·¯\r\n\r\nå¯»æ‰¾å·¦å³å­æ ‘çš„æœ€å¤§æ·±åº¦ï¼Œå–æœ€å¤§æ·±åº¦è¿›è¡Œé€’å½’ã€‚\r\n\r\n### ä»£ç \r\n\r\n```\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root:\r\n            return 0\r\n        else:\r\n            left = self.maxDepth(root.left)\r\n            right = self.maxDepth(root.right)\r\n\r\n            return max(left, right) + 1\r\n```\r\n\r\n### å¤æ‚åº¦\r\n$O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197791745","body":"### æ€è·¯\n\næ ¹æ®èŠ‚ç‚¹å€¼ä½œä¸ºåˆ¤æ–­æ¡ä»¶ï¼Œåˆ†åˆ«é€’å½’åˆ¤æ–­å·¦å³å­æ ‘æ˜¯å¦ç›¸ç­‰\n\n### ä»£ç \n\n```python\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        elif (not p) ^ (not q):\n            return False\n        elif p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n\n### å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼š$O(\\text{min}(m, n))$ï¼Œå…¶ä¸­$m, n$åˆ†åˆ«æ˜¯ä¸¤æ£µæ ‘çš„èŠ‚ç‚¹æ•°ç›®\n\nç©ºé—´å¤æ‚åº¦ï¼š$O(\\text{min}(m, n))$ï¼Œå…¶ä¸­$m, n$åˆ†åˆ«æ˜¯ä¸¤æ£µæ ‘çš„èŠ‚ç‚¹æ•°ç›®\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199548973","body":"### æ€è·¯\n\næ ¹æ®ä¿å­˜è·¯å¾„ä¸Šçš„èŠ‚ç‚¹å€¼ï¼Œåˆ†åˆ«é€’å½’åˆ¤æ–­å·¦å³å­æ ‘ï¼Œæœ€åç´¯åŠ å¾—åˆ°ç­”æ¡ˆã€‚\n\n### ä»£ç \n\n```python\nclass Solution:\n    def __init__(self):\n        self.path_list = []\n\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        self.dfs(root, 0)\n        # print(self.path_list)\n\n        return sum(self.path_list)\n        \n    def dfs(self, root, pathSum):\n        if not root:\n            # self.path_list.append(pathSum)\n            return\n        if not root.left and not root.right:\n            self.path_list.append(pathSum*10+root.val)\n            return\n\n        self.dfs(root.left, pathSum*10+root.val)\n        self.dfs(root.right, pathSum*10+root.val)\n        return\n```\n\n### å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\n\nç©ºé—´å¤æ‚åº¦ï¼š$O(n)$\n\n\n\nI am Sam, a student from East China Normal University, Shanghai ,China. Now, I' m studying Software Engineering and it is my third year of master next semester. My student number is 51164500109, and edu email is 51164500109@stu.ecnu.edu.cn. However, I can not afford coursera's enrollment fee now since I do not earn any money these days. We need to pay tuition 8000 RMB per year to our university in addition. It is really a heavy burden for me. Every month, we can get a little subsidy from our university, however, that's not enough at all. So sometimes I need to take some part time job to maintain my life here. After all annually, I barely have any deposit. So I wish to have some financial aid from coursera temporary. After I find a decent job, I will recommend the platform to my colleagues and contribute my effort to make coursera better.\n\n\n\nThis course is a rather good support for me to enhance my basic knowledge in machine learning. I hope after getting through the curriculum, my practicing ability will boom up. In my further career life, this will also provide some intuition beforehand. I would like to require full access to this course because the video itself is not enough for a deep understanding of the whole concept. Only learning with the nicely designed quizzes as well as the programming exercises, can an ensuthiasim\nlearner achieve the goal of this class. In addition, finishing a project will make the learner feel fruitful, which stimulates an optimistic learning attitude. All in all, this is a very precious resource that can be found through massive data on the platform. I can not wait for learning new knowledge to equip myself. I would like to make an accomplishment for a better me in several weeks.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200204535","body":"### æ€è·¯\n\nä¾ç…§ä»å³å¾€å·¦çš„é¡ºåºæ ¹æ®äºŒå‰æ ‘çš„èŠ‚ç‚¹ï¼Œé€å±‚ä¾æ¬¡éå†ä¹‹åï¼Œå¾—åˆ°æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„å€¼å³ä¸ºç­”æ¡ˆã€‚\n\n### ä»£ç \n\n```python\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        q = deque([root])\n        while q:\n            node = q.popleft()\n            if node.right:\n                q.append(node.right)\n            if node.left:\n                q.append(node.left)\n            ans = node.val\n        return ans\n```\n\n### å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\n\nç©ºé—´å¤æ‚åº¦ï¼š$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200450200","body":"### æ€è·¯\n\nåºåˆ—åŒ–æ—¶ç”¨BFSéå†æ ‘ï¼Œä¸ç®¡nodeçš„å·¦å³å­èŠ‚ç‚¹æ˜¯å¦å­˜åœ¨ï¼Œç»Ÿç»ŸåŠ åˆ°é˜Ÿåˆ—ä¸­ï¼›åœ¨èŠ‚ç‚¹å‡ºé˜Ÿæ—¶ï¼Œå¦‚æœèŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œåœ¨è¿”å›å€¼ä¸­åŠ å…¥ä¸€ä¸ª`None`ï¼Œå¦‚æœèŠ‚ç‚¹å­˜åœ¨ï¼Œåˆ™åŠ å…¥èŠ‚ç‚¹å€¼çš„å­—ç¬¦ä¸²å½¢å¼ã€‚\nååºåˆ—åŒ–æ—¶ä½¿ç”¨BFSï¼Œåˆ©ç”¨é˜Ÿåˆ—æ–°å»ºäºŒå‰æ ‘ã€‚é¦–å…ˆè¦å°†æ•°æ®è½¬æ¢æˆåˆ—è¡¨ï¼Œç„¶åéå†ï¼Œåªè¦ä¸ä¸º`None`å°†èŠ‚ç‚¹æŒ‰é¡ºåºåŠ å…¥äºŒå‰æ ‘ä¸­ï¼›åŒæ—¶è¿˜è¦å°†èŠ‚ç‚¹å…¥é˜Ÿï¼Œé˜Ÿåˆ—ä¸ºç©ºæ—¶éå†å®Œæ¯•ï¼Œè¿”å›æ ¹èŠ‚ç‚¹ã€‚\n\n### ä»£ç \n\n```python\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root:\n            return \"\"\n        queue = collections.deque([root])\n        res = []\n        while queue:\n            node = queue.popleft()\n            if node:\n                res.append(str(node.val))\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                res.append('None')\n        return '[' + ','.join(res) + ']'\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        if not data:\n            return []\n        dataList = data[1:-1].split(',')\n        root = TreeNode(int(dataList[0]))\n        queue = collections.deque([root])\n        i = 1\n        while queue:\n            node = queue.popleft()\n            if dataList[i] != 'None':\n                node.left = TreeNode(int(dataList[i]))\n                queue.append(node.left)\n            i += 1\n            if dataList[i] != 'None':\n                node.right = TreeNode(int(dataList[i]))\n                queue.append(node.right)\n            i += 1\n        return root\n```\n\n### å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\n\nç©ºé—´å¤æ‚åº¦ï¼š$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201287967","body":"### æ€è·¯\n\né¦–å…ˆä½¿ç”¨dfsé€’å½’éå†äºŒå‰æ ‘ï¼Œä¾æ¬¡è®°å½•äºŒå‰æ ‘æ¯ä¸ªèŠ‚ç‚¹çš„åˆ—å·`col`ï¼Œè¡Œå·`row`ä»¥åŠæ•°å€¼`val`ï¼Œå­˜å…¥åˆ—è¡¨ã€‚éå†å®Œæˆåå¯¹è¯¥åˆ—è¡¨è¿›è¡Œæ’åºï¼Œå¯ä»¥å¾—åˆ°æ»¡è¶³é¢˜ç›®æ¡ä»¶çš„èŠ‚ç‚¹é¡ºåºã€‚æ­¤æ—¶ï¼Œå¯ä»¥å¯¹è¿™ä¸ªæ–°åˆ—è¡¨è¿›è¡Œéå†ï¼Œå°†ä¸åŒåˆ—å·çš„å…ƒç´ å­˜åœ¨ä¸€ä¸ªå­åˆ—è¡¨ä¸­ï¼Œè¿”å›è£…è½½è¿™äº›åˆ—è¡¨çš„å¤§åˆ—è¡¨ã€‚\n\n### ä»£ç \n\n```python\nclass Solution:\n    def __init__(self):\n        self.traverse_list = []\n    \n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        self.traverse(root, 0, 0)\n\n        traverse_list_ = self.traverse_list\n\n        # print(traverse_list, sorted(traverse_list))\n        last_col = float('-inf')\n        res = list()\n\n        for col, row, val in sorted(traverse_list_):\n            if col != last_col:\n                res.append(list())\n                last_col = col\n            res[-1].append(val)\n        \n        return res\n\n    def traverse(self, root, col, row):\n        if not root:\n            return\n        self.traverse_list.append([col, row, root.val])\n\n        self.traverse(root.left, col-1, row+1)\n        self.traverse(root.right, col+1, row+1)\n        return\n```\n\n### å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼š$O(n\\text{log}(n))$\n\nç©ºé—´å¤æ‚åº¦ï¼š$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202820156","body":"### æ€è·¯\n\nä¸€æ¬¡éå†ï¼Œä½¿ç”¨å“ˆå¸Œè¡¨è®°å½•å‡ºç°è¿‡æ•°å­—åŠå…¶ä¸‹æ ‡ã€‚å¯¹äºæ–°æ•°å­—æŸ¥æ‰¾ä¸`target`ä¹‹å·®æ˜¯å¦å‡ºç°åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œå³å¯ã€‚\n\n### ä»£ç \n\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        hash_map = dict()\n        for i, num in enumerate(nums):\n            if target - num in hash_map:\n                return [hash_map[target - num], i]\n            hash_map[num] = i\n        return []\n```\n\n### å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\n\nç©ºé—´å¤æ‚åº¦ï¼š$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1204053498","body":"### æ€è·¯\r\n\r\néœ€è¦åˆç†åˆ©ç”¨Pythonä¸­`queue.PriorityQueue()`çš„APIã€‚é¦–å…ˆå»ºç«‹å“ˆå¸Œè¡¨è·å¾—æ•°ç»„`nums`çš„å…ƒç´ å‡ºç°æ¬¡æ•°ï¼Œå»ºç«‹ä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—æ¥å¯¹å“ˆå¸Œè¡¨ä¸­çš„æ•°å€¼è¿›è¡Œå­˜å‚¨ã€‚è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯è¿™ä¸ªä¼˜å…ˆé˜Ÿåˆ—çš„å¤§å°æ§åˆ¶åœ¨`k`ï¼Œå› æ­¤å¯ä»¥æ»¡è¶³é¢˜ç›®ä¸­å°äº`nlog(n)`çš„æ—¶é—´å¤æ‚åº¦ã€‚éœ€è¦æ³¨æ„çš„ç‚¹æ˜¯ï¼ŒPythonè‡ªå¸¦çš„ä¼˜å…ˆé˜Ÿåˆ—é»˜è®¤å°é¡¶å †ï¼Œè€Œä¸”æ²¡åŠæ³•ä¹‹é—´æŒ‡å®šå †çš„å¤§å°ã€‚æ­¤æ—¶ï¼Œå¯ä»¥åœ¨éå†å“ˆå¸Œè¡¨æ—¶ï¼Œåˆ©ç”¨å°é¡¶å †çš„æ€§è´¨ï¼ŒæŠŠæœ€å°å…ƒç´ å¼¹å‡ºä¸å½“å‰çš„`value`æ¯”è¾ƒï¼Œç»´æŠ¤ä¸€ä¸ªåˆ°éå†ä½ç½®ä¸ºæ­¢çš„æœ€å¤§`k`ä¸ªé«˜é¢‘å…ƒç´ ã€‚æœ€åï¼Œå°†ä¼˜å…ˆé˜Ÿåˆ—ä¸­çš„æ‰€æœ‰å…ƒç´ ä¾æ¬¡å–å‡ºå³å¯ã€‚\r\n\r\n### ä»£ç \r\n\r\n```python\r\nimport queue\r\n\r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        count_map = dict()\r\n\r\n        for num in nums:\r\n            if num in count_map:\r\n                count_map[num] += 1\r\n            else:\r\n                count_map[num] = 1\r\n\r\n        pq = queue.PriorityQueue()\r\n        for key, value in count_map.items():\r\n            if pq.qsize() == k:\r\n                temp = pq.get()\r\n                if temp[0] < value:\r\n                    pq.put((value, key))\r\n                else:\r\n                    pq.put(temp)\r\n            else:\r\n                pq.put((value, key))\r\n        res = []\r\n        while not pq.empty():\r\n            temp = pq.get()\r\n            res.append(temp[1])\r\n            \r\n        return res\r\n```\r\n\r\n### å¤æ‚åº¦\r\n\r\næ—¶é—´å¤æ‚åº¦ï¼š$O(n\\text{log}(k))$\r\n\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205439013","body":"### æ€è·¯\n\næ’åˆ—å…¬å¼ï¼Œé€‰å‡ºä¸¤ä¸ªå…ƒç´ ã€‚\n\n### ä»£ç \n\n```python\nimport queue\n\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ans = 0\n        for p in points:\n            cnt = defaultdict(int)\n            for q in points:\n                dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1])\n                cnt[dis] += 1\n            for m in cnt.values():\n                ans += m * (m - 1)\n        return ans\n```\n\n### å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼š$O(n^2)$\n\nç©ºé—´å¤æ‚åº¦ï¼š$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206531046","body":"### æ€è·¯\r\n\r\nä½¿ç”¨å¿«æ…¢æŒ‡é’ˆå¯¹å­—ç¬¦ä¸²è¿›è¡Œéå†ï¼Œå¹¶ä¸”åˆ©ç”¨å“ˆå¸Œè¡¨è®°å½•å¿«æ…¢æŒ‡é’ˆå½¢æˆçš„çª—å£ä¸­ï¼Œå­—ç¬¦å‡ºç°çš„æ¬¡æ•°ã€‚å³ç§»æ…¢æŒ‡é’ˆçš„æ¡ä»¶æ˜¯å“ˆå¸Œè¡¨å‡ºç°æ¬¡æ•°ç»Ÿè®¡å¤§äº1çš„å­—ç¬¦ï¼Œéœ€è¦å°†æ…¢æŒ‡é’ˆç§»åŠ¨åˆ°è¯¥å­—ç¬¦å‡ºç°æ¬¡æ•°ä¸º1ã€‚æ›´æ–°ç­”æ¡ˆéœ€è¦åœ¨å½“å‰çª—å£åˆæ³•çš„æ—¶æœºï¼Œå› æ­¤æ”¾åœ¨å‡ºå³ç§»æ…¢æŒ‡é’ˆçš„å¾ªç¯ä¹‹åã€‚\r\n\r\n### ä»£ç \r\n\r\n```python\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        left = 0\r\n        right = 0\r\n        max_len = 0\r\n        window = defaultdict(int)\r\n\r\n        while right < len(s):\r\n            ch = s[right]\r\n            window[ch] += 1\r\n            right += 1\r\n            while window[ch] > 1:\r\n                c = s[left]\r\n                left += 1\r\n                window[c] -= 1\r\n\r\n            max_len = max(max_len, right - left)\r\n        return max_len\r\n```\r\n\r\n### å¤æ‚åº¦\r\n\r\næ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\n\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207235799","body":"### æ€è·¯\n\næƒ³ç”¨æ»‘åŠ¨çª—å£åšï¼Œæš‚æ—¶è¿˜æ²¡å†™å‡ºæ¥ï¼Œæ‰¾äº†ä¸€ä¸ªæ–¹æ³•ã€‚\n\n### ä»£ç \n\n```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        from collections import Counter\n        if not s or not words:return []\n        one_word = len(words[0])\n        word_num = len(words)\n        n = len(s)\n        if n < one_word:return []\n        words = Counter(words)\n        res = []\n        for i in range(0, one_word):\n            cur_cnt = 0\n            left = i\n            right = i\n            cur_Counter = Counter()\n            while right + one_word <= n:\n                w = s[right:right + one_word]\n                right += one_word\n                if w not in words:\n                    left = right\n                    cur_Counter.clear()\n                    cur_cnt = 0\n                else:\n                    cur_Counter[w] += 1\n                    cur_cnt += 1\n                    while cur_Counter[w] > words[w]:\n                        left_w = s[left:left+one_word]\n                        left += one_word\n                        cur_Counter[left_w] -= 1\n                        cur_cnt -= 1\n                    if cur_cnt == word_num :\n                        res.append(left)\n        return res\n```\n\n### å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\n\nç©ºé—´å¤æ‚åº¦ï¼š$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207429011","body":"### æ€è·¯\n\nåŒä½™å®šç†ï¼Œä¸æ˜¯å¾ˆæ“…é•¿ã€‚\n\n### ä»£ç \n\n```python\nclass Solution:\n    def solve(self, nums, k):\n        total = (sum(nums) + k) % k\n        prefix_sum = 0\n        hashmap = {0: -1}\n        res = len(nums)\n        for i, num in enumerate(nums):\n            prefix_sum += num\n            mod = (prefix_sum + k) % k\n            hashmap[mod] = i\n            if (mod - total + k) % k in hashmap:\n                res = min(res, i - hashmap[(mod - total + k) % k])\n        return res if res != len(nums) else -1\n```\n\n### å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\n\nç©ºé—´å¤æ‚åº¦ï¼š$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207729318","body":"### æ€è·¯\n\nä½¿ç”¨å¿«æ…¢æŒ‡é’ˆï¼Œå¿«æŒ‡é’ˆæ— æ³•å‰è¿›æ—¶è¿”å›æ…¢æŒ‡é’ˆçš„ä½ç½®å³å¯ã€‚\n\n### ä»£ç \n\n```python\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n```\n\n### å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\n\nç©ºé—´å¤æ‚åº¦ï¼š$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209548003","body":"### æ€è·¯\n\nä½¿ç”¨å¿«æ…¢æŒ‡é’ˆï¼Œä¸¤ä¸ªæŒ‡é’ˆçš„æŒ‡å‘çš„å…ƒç´ æ•°å€¼ä¸ä¸€æ ·æ—¶ï¼Œæ…¢æŒ‡é’ˆå³ç§»ï¼Œå¿«æŒ‡é’ˆæ— æ³•å‰è¿›æ—¶è¿”å›æ…¢æŒ‡é’ˆçš„ä½ç½®åŠ 1å³å¯ã€‚\n\n### ä»£ç \n\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        slow = 0\n        fast = 0\n        while fast < len(nums):\n            if nums[slow] != nums[fast]:\n                slow += 1\n                nums[slow] = nums[fast]\n            \n            fast += 1\n        return slow + 1\n```\n\n### å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\n\nç©ºé—´å¤æ‚åº¦ï¼š$O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhongxiangxiang":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185660258","body":"## æ€è·¯\r\nå°†numå’Œkéƒ½è½¬æˆæ•°ç»„ï¼ˆå¢åŠ äº†é¢å¤–ç©ºé—´ï¼Œå‘œå‘œï½ï½ï¼‰å¹¶å€’åºï¼Œæ¯ä¸ªå…ƒç´ å› æ­¤ç›¸åŠ ï¼Œè‹¥å¤§äºç­‰äº10ï¼Œä¸‹ä¸€æ¬¡ç›¸åŠ å¦å¤–å†åŠ 1\r\n\r\n## ä»£ç \r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    let arr1 = num.reverse()\r\n    let arr2 = String(k).split('').reverse().map(item => Number(item))\r\n    let i = 0\r\n    let arr = []\r\n    let extra = 0\r\n    while(i < arr1.length || i < arr2.length) {\r\n        let sum = (arr1[i] || 0) + (arr2[i] || 0) + extra\r\n        if (sum >= 10) {\r\n            arr.push(sum - 10)\r\n            extra = 1\r\n        } else {\r\n            arr.push(sum)\r\n            extra = 0\r\n        }\r\n        i++\r\n    }\r\n    if (extra === 1) {\r\n        arr.push(1)\r\n    }\r\n    \r\n    return arr.reverse()\r\n};\r\n```\r\n\r\n## å¤æ‚åº¦\r\næ—¶é—´ï¼šO(n), æ•°ç»„çš„reverseä¸çŸ¥é“å¤æ‚åº¦å¤šå°‘\r\nç©ºé—´ï¼šO(n),","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189180166","body":"```js\r\nvar MyQueue = function() {\r\n    this.arr = []\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.arr.push(x)\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    return this.arr.shift()\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.arr[0]\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.arr.length === 0\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190460802","body":"## ä»£ç \r\n```js\r\nvar maxChunksToSorted = function(arr) {\r\n    // å•è°ƒé€’å¢æ ˆ\r\n    let stack = [arr[0]] // å­˜æ¯ä¸ªåˆ†å—çš„æœ€å¤§å€¼\r\n    for (let i = 1; i < arr.length; i++) {\r\n        if (arr[i] >= stack[stack.length - 1]) {\r\n            // arr[i]å¤§äºç­‰äºå‰é¢åˆ†å—çš„æœ€å¤§å€¼ï¼Œå¯ä»¥ç‹¬ç«‹åˆ†ä¸€ä¸ªå—\r\n            stack.push(arr[i])\r\n        } else {\r\n            // å°äºï¼Œå°±åˆåˆ°ä¸Šä¸€ä¸ªåˆ†å—\r\n            let temp = stack.pop() // ä¸Šä¸€åˆ†å—çš„æœ€å¤§å€¼\r\n            while (arr[i] < stack[stack.length - 1]) {\r\n                // å°†å°äºä¸Šä¸€åˆ†å—çš„popæ‰ï¼Œåˆå¹¶ä¸ºä¸€ä¸ªåˆ†å—\r\n                stack.pop()\r\n            }\r\n            // åˆå¹¶ä¹‹åçš„åˆ†å—pushå›å»\r\n            stack.push(temp)\r\n        }\r\n    }\r\n    return stack.length\r\n};\r\n```\r\n## å¤æ‚åº¦\r\næ—¶é—´ï¼šO(n)\r\nç©ºé—´ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191646702","body":"## æ€è·¯\r\nå…ˆéå†ä¸€éé“¾è¡¨ï¼Œè®¡ç®—å‡ºé“¾è¡¨çš„é•¿åº¦ï¼›ç§»åŠ¨kä½ï¼Œå³éå†åˆ°ç¬¬kä¸ªèŠ‚ç‚¹ï¼Œå…¶nextèŠ‚ç‚¹ä¸ºæ–°çš„å¤´èŠ‚ç‚¹ï¼›æœ€åæŠŠå°¾èŠ‚ç‚¹çš„nextæŒ‡å‘é“¾è¡¨åŸå…ˆçš„head\r\n\r\n## ä»£ç \r\n```js\r\nvar rotateRight = function(head, k) {\r\n    if (!head) {\r\n        return head\r\n    }\r\n    let count = 0\r\n    let node = head\r\n    // è®¡ç®—èŠ‚ç‚¹æ•°\r\n    while (node.next) {\r\n        count++\r\n        node = node.next\r\n    }\r\n    count++\r\n    let tail = node\r\n    node = head\r\n    let newHead = null\r\n    // éœ€ç§»åŠ¨çš„ä½æ•°\r\n    const moveStep = k % count\r\n    if (moveStep === 0) {\r\n        // ä¸éœ€ç§»åŠ¨ï¼Œç›´æ¥è¿”å›\r\n        return head\r\n    }\r\n    while(count > moveStep) {\r\n        count--\r\n        if (count === moveStep) {\r\n            // ç§»åŠ¨å®Œåçš„èŠ‚ç‚¹ä¸ºæ–°å¤´èŠ‚ç‚¹\r\n            newHead = node.next\r\n            node.next = null\r\n        } else {\r\n            node = node.next\r\n        }\r\n    }\r\n    tail.next = head\r\n    return newHead\r\n};\r\n```\r\n## å¤æ‚åº¦\r\næ—¶é—´ï¼šO(n)\r\nç©ºé—´ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192649548","body":"## ä»£ç \r\n```js\r\n */\r\nvar swapPairs = function(head) {\r\n    if (!head || !head.next) {\r\n        return head\r\n    }\r\n    let pre = head.next\r\n    let next = head\r\n    let tmp = pre.next\r\n    head = head.next\r\n    while (next.next) {\r\n        // pre=2æŒ‡å‘next=1, nextå†æŒ‡å‘tmp=3çš„next=4,\r\n        // ç„¶åé‡æ–°èµ‹å€¼ï¼Œæ–°ä¸€è½®é‡æ–°æŒ‡å‘\r\n        // console.log(pre, next, tmp)\r\n        pre.next = next\r\n        next.next = tmp ? (tmp.next || tmp) : null\r\n        if (tmp) {\r\n            pre = tmp.next\r\n            next = tmp\r\n            tmp = pre ? pre.next : null\r\n        }\r\n    }\r\n    return head\r\n};\r\n```\r\n## å¤æ‚åº¦\r\næ—¶é—´ï¼šO(n)\r\nç©ºé—´ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193128560","body":"## æ€è·¯\r\nå…ˆéå†ä¸€éï¼Œè·å–èŠ‚ç‚¹æ•°ï¼›æ‰¾åˆ°ä¸­é—´å€¼ä½œä¸ºæ ¹èŠ‚ç‚¹ï¼Œä¸­é—´èŠ‚ç‚¹çš„å·¦è¾¹é“¾è¡¨ä½œä¸ºå·¦å­æ ‘ï¼Œå³è¾¹é“¾è¡¨ä¸ºå³å­æ ‘ï¼Œé€’å½’\r\n\r\n## ä»£ç \r\n```js\r\nvar sortedListToBST = function(head) {\r\n    let num = 0\r\n    let node = head\r\n    while (node) {\r\n        num++\r\n        node = node.next\r\n    }\r\n\r\n    const buildTree = (head, num) => {\r\n        // console.log(head, num)\r\n        if (!head) {\r\n            return head\r\n        }\r\n        if (!head.next) {\r\n            return new TreeNode(head.val)\r\n        }\r\n        let mid = (num >> 1) + 1\r\n        let midNode = null\r\n        let left = head\r\n        let right = head\r\n        let i = 1\r\n        \r\n        while (i < mid) {\r\n            let temp = right.next\r\n            if (i === mid - 1) {\r\n                temp = right.next.next\r\n                // ä¸­é—´èŠ‚ç‚¹\r\n                midNode = new TreeNode(right.next.val)\r\n                // console.log(11, midNode)\r\n                // åˆ°æ­¤ä¸ºå·¦è¾¹é“¾è¡¨\r\n                right.next = null\r\n            }\r\n            right = temp\r\n            i++\r\n        }\r\n        // console.log(333, midNode, left, right,num, mid)\r\n        midNode.left = buildTree(left, mid - 1)\r\n        midNode.right = buildTree(right, num - mid)\r\n        return midNode\r\n    }\r\n    return buildTree(head, num)\r\n    \r\n};\r\n```\r\n## å¤æ‚åº¦\r\næ—¶é—´ï¼šO(nlogn) - æ¯å±‚æ ‘æ˜¯n/2, lognå±‚æ•°\r\nç©ºé—´ï¼šO(n) - æ•´æ£µæ ‘çš„èŠ‚ç‚¹nï¼Œåº”è¯¥æ˜¯O(n)å§","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193324818","body":"## æ€è·¯\r\nçœ‹äº†å®˜æ–¹ç­”æ¡ˆï¼ŒåŒæŒ‡é’ˆ\r\n\r\n## ä»£ç \r\n```js\r\nvar getIntersectionNode = function(headA, headB) {\r\n    if (!headA || !headB) {\r\n        return null\r\n    }\r\n    // åŒæŒ‡é’ˆ\r\n    let pA = headA\r\n    let pB = headB\r\n    while(pA !== pB) {\r\n        // éå†ä¸¤ä¸ªé“¾è¡¨\r\n        pA = pA === null ? headB : pA.next\r\n        pB = pB === null ? headA : pB.next\r\n    }\r\n    return pA\r\n};\r\n```\r\n## å¤æ‚åº¦\r\næ—¶é—´ï¼šO(m + n) - éå†é“¾è¡¨Aå’Œé“¾è¡¨B\r\nç©ºé—´ï¼šO(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196891059","body":"## ä»£ç \r\n```js\r\nvar maxDepth = function(root) {\r\n    let max = 0\r\n    const dfs = (node, path) => {\r\n        if (!node) {\r\n            return\r\n        }\r\n\r\n        path.push(node.val)\r\n        max = Math.max(max, path.length) // ä¿å­˜æœ€å¤§çš„æ·±åº¦\r\n        dfs(node.left, path)\r\n        dfs(node.right, path)\r\n        path.pop() // å›æº¯\r\n    }\r\n    dfs(root, [])\r\n    return max\r\n};\r\n```\r\n## å¤æ‚åº¦\r\næ—¶é—´ï¼šO(n) n-èŠ‚ç‚¹æ•°\r\nç©ºé—´ï¼šO(height)-æ ‘ç‚¹é«˜åº¦ï¼Œå³é€’å½’éœ€è¦ä½¿ç”¨çš„è°ƒç”¨æ ˆç©ºé—´","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198315783","body":"## ä»£ç \r\n```js\r\nvar isSameTree = function(p, q) {\r\n    let isSame = true\r\n    const dfs = (node1, node2) => {\r\n        if (!node1 && !node2) {\r\n            return\r\n        }\r\n        if ((!node1 && node2) || (node1 && !node2) || node1.val !== node2.val) {\r\n            isSame = false\r\n            return\r\n        }\r\n        dfs(node1.left, node2.left)\r\n        dfs(node1.right, node2.right)\r\n    }\r\n    dfs(p, q)\r\n    return isSame\r\n};\r\n```\r\n## å¤æ‚åº¦\r\næ—¶é—´ï¼šO(n)\r\nç©ºé—´ï¼šO(h) - hä¸ºæ ‘é«˜ï¼Œé€’å½’è°ƒç”¨æ ˆ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198352003","body":"## ä»£ç \r\n```js\r\nvar sumNumbers = function(root) {\r\n    let res = 0\r\n    let nums = []\r\n    const dfs = (node) => {\r\n        if (!node) {\r\n            return\r\n        }\r\n        nums.push(node.val)\r\n        if (!node.left && !node.right) {\r\n            // èµ°åˆ°å¶å­èŠ‚ç‚¹ï¼Œç´¯åŠ \r\n            const num = nums.join('')\r\n            // console.log(num)\r\n            res += Number(num)\r\n        }\r\n        \r\n        dfs(node.left)\r\n        dfs(node.right)\r\n        nums.pop()\r\n    }\r\n    dfs(root)\r\n    return res\r\n};\r\n```\r\n## å¤æ‚åº¦\r\næ—¶é—´ï¼šO(n) éå†æ¯ä¸ªèŠ‚ç‚¹\r\nç©ºé—´ï¼šO(h) æ ‘é«˜ï¼Œå–å†³äºé€’å½’æ·±åº¦ç­‰äºäºŒå‰æ ‘çš„é«˜åº¦ï¼Œæœ€åä¸ºn","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1199687326","body":"## ä»£ç \r\n```js\r\n// bfs\r\nvar findBottomLeftValue = function(root) {\r\n    let res = root.val\r\n    let queue = [root]\r\n    while (queue.length) {\r\n        let curLevel = queue\r\n        res = curLevel[0].val\r\n        queue = []\r\n        for (let i = 0; i < curLevel.length; i++) {\r\n            if (curLevel[i].left) {\r\n                queue.push(curLevel[i].left)\r\n            }\r\n            if (curLevel[i].right) {\r\n                queue.push(curLevel[i].right)\r\n            }\r\n        }\r\n    }\r\n    return res\r\n};\r\n```\r\n## å¤æ‚åº¦\r\næ—¶é—´ï¼šO(n) éå†æ¯ä¸ªæ ‘èŠ‚ç‚¹\r\nç©ºé—´ï¼šO(n) è‹¥æ˜¯æ»¡å®Œå…¨äºŒå‰æ ‘ï¼Œé˜Ÿåˆ—queueæœ€å¤šæ”¾n/2ä¸ªèŠ‚ç‚¹ï¼ˆå®˜æ–¹é¢˜è§£ï¼‰","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200448272","body":"## æ€è·¯\r\ndfs\r\n\r\n## ä»£ç \r\n```js\r\n/**\r\n * Encodes a tree to a single string.\r\n *\r\n * @param {TreeNode} root\r\n * @return {string}\r\n */\r\nvar serialize = function(root) {\r\n    if (root === null) {\r\n        return 'x'\r\n    }\r\n    let str = root.val\r\n    str += ',' + serialize(root.left)\r\n    str += ',' + serialize(root.right)\r\n    return str\r\n};\r\n\r\n/**\r\n * Decodes your encoded data to tree.\r\n *\r\n * @param {string} data\r\n * @return {TreeNode}\r\n */\r\nvar deserialize = function(data) {\r\n    let list = data.split(',')\r\n    const buildTree = (list) => {\r\n        if (list[0] === 'x') {\r\n            list.shift()\r\n            return null\r\n        }\r\n        let node = new TreeNode(list[0])\r\n        list.shift()\r\n        node.left = buildTree(list)\r\n        node.right = buildTree(list)\r\n        return node\r\n    }\r\n    return buildTree(list)\r\n};\r\n```\r\n## å¤æ‚åº¦\r\næ—¶é—´ï¼šO(n)\r\nç©ºé—´ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1202002119","body":"## æ€è·¯\r\nå‚è€ƒäº†ç­”æ¡ˆ\r\nå…ˆdfsæ”¶é›†æ¯ä¸ªèŠ‚ç‚¹çš„ä¿¡æ¯ï¼Œç„¶åæ’åº\r\n\r\n## ä»£ç \r\n```js\r\nvar verticalTraversal = function(root) {\r\n    let map = {}\r\n    const dfs = (node, row, col) => {\r\n        if (!node) {\r\n            return\r\n        }\r\n        if (!map[col]) {\r\n            map[col] = []\r\n        }\r\n        map[col].push([row, col, node.val])\r\n        dfs(node.left, row + 1, col - 1)\r\n        dfs(node.right, row + 1, col + 1)\r\n    }\r\n    dfs(root, 0, 0)\r\n    let res = []\r\n    Object.keys(map).sort((a, b) => a - b).forEach(col => {\r\n        const sortedCol = map[col].sort(sortCol).map(item => item[2])\r\n        res.push(sortedCol)\r\n    })\r\n    return res\r\n};\r\n\r\nfunction sortCol (a, b) {\r\n    // â€œåˆ—å·ä»å°åˆ°å¤§â€ï¼Œå¯¹äºåŒåˆ—èŠ‚ç‚¹ï¼Œâ€œè¡Œå·ä»å°åˆ°å¤§â€ï¼Œå¯¹äºåŒåˆ—åŒè¡Œå…ƒç´ ï¼Œâ€œèŠ‚ç‚¹å€¼ä»å°åˆ°å¤§â€\r\n    if (a[1] !== b[1]) {\r\n        return a[1] - b[1]\r\n    } else if (a[0] !== b[0]) {\r\n        // åŒåˆ—\r\n        return a[0] - b[0]\r\n    } else {\r\n        // åŒåˆ— åŒè¡Œ\r\n        return a[2] - b[2]\r\n    }\r\n}\r\n```\r\n## å¤æ‚åº¦\r\næ—¶é—´ï¼šO(nlogn), O(n)çš„dfsï¼ŒO(nlogn)çš„sortæ’åº\r\nç©ºé—´ï¼šO(n), O(n)çš„dfsé€’å½’è°ƒç”¨æ ˆï¼ŒO(n)ä¿å­˜æ¯ä¸ªèŠ‚ç‚¹çš„ä¿¡æ¯","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202120544","body":"## æ€è·¯\r\nå“ˆå¸Œå­˜å‚¨éœ€è¦çš„å¦ä¸€æ•´æ•°å’Œå½“å‰æ•´æ•°çš„ä¸‹æ ‡ï¼Œéå†åˆ°å¦ä¸€æ•´æ•°ï¼Œè‹¥åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œåˆ™ä»–ä»¬çš„å’Œä¸ºç›®æ ‡å€¼ï¼Œè¿”å›ä»–ä»¬çš„ä¸‹æ ‡\r\n\r\n## ä»£ç \r\n```js\r\nvar twoSum = function(nums, target) {\r\n    let map = {}\r\n    for (let i = 0; i < nums.length; i++) {\r\n        if (map[nums[i]] !== undefined) {\r\n            return [map[nums[i]], i]\r\n        } else {\r\n            map[target - nums[i]] = i\r\n        }\r\n    }\r\n};\r\n```\r\n## å¤æ‚åº¦\r\næ—¶é—´ï¼šO(n), éå†ä¸€éæ•°ç»„\r\nç©ºé—´ï¼šO(n), å“ˆå¸Œè¡¨å­˜å‚¨æ•´æ•°åŠä¸‹æ ‡\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1204051140","body":"## æ€è·¯\r\nç”¨å“ˆå¸Œè¡¨å¯¹å…ƒç´ è®¡æ•°ï¼Œç„¶åæ’åºï¼Œå–å‰kå¤§çš„å…ƒç´ \r\n```js\r\nvar topKFrequent = function(nums, k) {\r\n    let map = {}\r\n    for (let i = 0; i < nums.length; i++) {\r\n        if (map[nums[i]]) {\r\n            map[nums[i]]++\r\n        } else {\r\n            map[nums[i]] = 1\r\n        }\r\n    }\r\n    return Object.entries(map).sort((a, b) => b[1] - a[1]).slice(0, k).map(item => item[0])\r\n};\r\n\r\n```\r\n## å¤æ‚åº¦\r\næ—¶é—´ï¼šO(nlogn)-éå†ä¸€éO(n)ï¼Œsortæ’åºO(nlogn)\r\nç©ºé—´ï¼šO(n)-å“ˆå¸Œè¡¨","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205402142","body":"## æ€è·¯\r\nçœ‹äº†å®˜æ–¹ç­”æ¡ˆ\r\nå¤–å±‚éå†pointer[i], å¯¹æ¯ä¸€ä¸ªpointer[i]åœ¨å†…å±‚å†éå†ä¸€éï¼Œè®¡ç®—åˆ°pointer[i]çš„è·ç¦»ç›¸åŒçš„æœ‰å¤šå°‘ä¸ªï¼Œç„¶åæ’åˆ—ç»„åˆï¼Œå¦‚æœ‰nä¸ªï¼Œåˆ™ç¬¬äºŒä¸ªç‚¹æœ‰nç§æ–¹æ¡ˆï¼Œç¬¬ä¸‰ä¸ªç‚¹æœ‰n-1ç§ï¼Œæ€»å…±n*(n - 1)ç§\r\n## ä»£ç \r\n```js\r\nvar numberOfBoomerangs = function(points) {\r\n    let num = 0\r\n    for (let i = 0; i < points.length; i++) {\r\n        let hashMap = {}\r\n        for (let j = 0; j < points.length; j++) {\r\n            if (i === j) {\r\n                continue\r\n            }\r\n            const x = points[i][0] - points[j][0]\r\n            const y = points[i][1] - points[j][1]\r\n            const distance = x * x + y * y\r\n            hashMap[distance] = (hashMap[distance] || 0) + 1\r\n        }\r\n        Object.values(hashMap).forEach(item => {\r\n            num += item * (item - 1)\r\n        })\r\n    }\r\n    return num\r\n};\r\n```\r\n## å¤æ‚åº¦ï¼š\r\næ—¶é—´ï¼šO(n2)\r\nç©ºé—´ï¼šO(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1207231973","body":"## æ€è·¯\r\n\r\n## ä»£ç \r\n```js\r\nvar lengthOfLongestSubstring = function(s) {\r\n    let max = 0\r\n    for (let i = 0; i < s.length; i++) {\r\n        let map = {}\r\n        let k = i\r\n        while (k < s.length && !map[s[k]]) {\r\n            map[s[k]] = 1\r\n            k++\r\n        }\r\n        max = Math.max(max, k - i)\r\n    }\r\n    return max\r\n};\r\n```\r\n## å¤æ‚åº¦\r\næ—¶é—´ï¼šO(kn), éå†å­—ç¬¦ä¸²O(n), å†…éƒ¨å¾ªç¯O(k),kä¸ºæœ€å¤§æ— é‡å¤æœ€é•¿å­ä¸²\r\nç©ºé—´ï¼šO(k)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207217002","body":"## æ€è·¯\r\nå…ˆç”¨å“ˆå¸Œè¡¨å­˜å‚¨æ¯ä¸ªå•è¯çš„æ•°é‡ï¼›éå†ä¸€éå­—ç¬¦ä¸²ï¼Œç„¶åå†…éƒ¨whileå¾ªç¯æ¯ä¸€æ®µå•è¯é•¿åº¦çš„å­—ç¬¦ä¸²æ˜¯å¦åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œè‹¥åŒ¹é…åˆ°å“ˆå¸Œè¡¨ä¸­çš„å•è¯ï¼Œè¯¥å•è¯çš„ç†Ÿç»ƒå‡ä¸€ï¼Œç›´åˆ°å¾ªç¯åˆ°çš„å­—ç¬¦ä¸²ä¸åœ¨å“ˆå¸Œè¡¨ä¸­æˆ–å¯¹åº”å•è¯æ•°é‡éƒ½ä¸º0ï¼›è‹¥æœ€åå†…éƒ¨å¾ªç¯ç»“æŸï¼Œèµ°è¿‡çš„å­—ç¬¦ä¸²é•¿åº¦ç­‰äºæ‰€æœ‰å•è¯å¯¹é•¿åº¦å’Œï¼Œåˆ™è¯´æ˜å½“å‰whileå¾ªç¯åˆ°çš„å­—ç¬¦ä¸²æ˜¯æ‰€æœ‰å•è¯çš„ä¸²è”ã€‚\r\n## ä»£ç \r\n```js\r\nvar findSubstring = function(s, words) {\r\n    const wordsNum = words.length\r\n    const len = words[0].length\r\n    let map = {}\r\n    let res = []\r\n    words.forEach(item => {\r\n        map[item] = (map[item] || 0) + 1\r\n    })\r\n\r\n    let i = 0\r\n    while (i < s.length) {\r\n        let k = i\r\n        let word = s.slice(k, k + len)\r\n        while (map[word]) {\r\n            map[word]--\r\n            k += len\r\n            word = s.slice(k, k + len)\r\n        }\r\n        // éœ€è¦æŠŠmapå¤åŸ\r\n        map = {}\r\n        words.forEach(item => {\r\n            map[item] = (map[item] || 0) + 1\r\n        })\r\n        if (k === i + wordsNum * len) {\r\n            res.push(i)\r\n        }\r\n        i++\r\n    }\r\n    return res\r\n};\r\n```\r\n## å¤æ‚åº¦\r\næ—¶é—´ï¼šO(nm), å­—ç¬¦ä¸²éå†O(n), å†…éƒ¨å¾ªç¯å•è¯æ•°ç»„O(m)\r\nç©ºé—´ï¼šO(n + m), ç»“æœå­˜å‚¨ç©ºé—´ï¼Œæœ€åä¸ºå­˜æ‰€æœ‰å­—ç¬¦ä¸²çš„ä¸‹æ ‡O(n), å“ˆå¸Œè¡¨O(m)\r\n(åˆ†æåº”è¯¥ä¸æ˜¯å¾ˆå¯¹ï¼‰","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207428214","body":"## ä»£ç \r\n// ä¸ä¼šã€‚ã€‚çœ‹äº†é¢˜è§£ä»ä¸æ˜¯å¾ˆæ‡‚ã€‚ã€‚\r\n```js\r\nvar floorMod = function (a, b) {\r\n  return ((a % b) + b) % b;\r\n};\r\n\r\nclass Solution {\r\n    solve(nums, k) {\r\n        var map = new Map();\r\n        map.set(0, -1);\r\n        var res = nums.length;\r\n        var target = 0;\r\n        var currSum = 0;\r\n        for (let i = 0; i < nums.length; i++) {\r\n            target += nums[i];\r\n        }\r\n        target = target % k;\r\n        console.log(target)\r\n        for (let i = 0; i < nums.length; i++) {\r\n            currSum = (nums[i] + currSum) % k;\r\n            map.set(currSum, i);\r\n            var prevSum = floorMod(currSum - target, k);\r\n            if (map.has(prevSum)) {\r\n                res = Math.min(res, i - map.get(prevSum));\r\n            }\r\n        }\r\n        return res === nums.length ? -1 : res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207622035","body":"## æ€è·¯\r\nå¿«æ…¢æŒ‡é’ˆï¼Œæ…¢æŒ‡é’ˆæ¯æ¬¡èµ°ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆæ¯æ¬¡èµ°ä¸¤æ­¥ï¼Œå½“å¿«æŒ‡é’ˆèµ°åˆ°å°¾æ—¶ï¼Œæ…¢æŒ‡é’ˆèµ°åˆ°ä¸­é—´\r\n## ä»£ç \r\n```js\r\nvar middleNode = function(head) {\r\n    let slow = head\r\n    let fast = head\r\n    while (fast && fast.next) {\r\n        slow = slow.next\r\n        fast = fast.next.next\r\n    }\r\n\r\n    return slow\r\n};\r\n```\r\n## å¤æ‚åº¦\r\næ—¶é—´ï¼šO(n)ï¼Œåªéœ€éå†é“¾è¡¨çš„ä¸€åŠO(n / 2)\r\nç©ºé—´ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208906191","body":"## æ€è·¯\r\nå¿«æ…¢æŒ‡é’ˆï¼Œæ…¢æŒ‡é’ˆä¸ç­‰äºå¿«æŒ‡é’ˆæŒ‡å‘çš„å€¼æ—¶ï¼Œæ…¢æŒ‡é’ˆæ‰å¾€åèµ°ä¸€æ­¥ï¼Œå¹¶æŠŠå¿«æŒ‡é’ˆçš„å€¼èµ‹å€¼ç»™æ…¢æŒ‡é’ˆæŒ‡å‘çš„å€¼\r\n## ä»£ç \r\n```js\r\nvar removeDuplicates = function(nums) {\r\n    let fast = 0\r\n    let slow = 0\r\n    for (let i = 0; i < nums.length; i++) {\r\n        fast++\r\n        if (nums[slow] !== nums[fast]) {\r\n            slow++\r\n            nums[slow] = nums[fast]\r\n        }\r\n    }\r\n    return slow\r\n};\r\n```\r\n## å¤æ‚åº¦\r\næ—¶é—´ï¼šO(n)\r\nç©ºé—´ï¼šO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hatorimain":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185660712","body":"## æ€è·¯\nè¿™é¢˜å¦‚æœç”¨é“¾è¡¨åšå¯ä»¥é€šè¿‡ä½¿ç”¨addFirstè¿™ä¸ªæ–¹æ³•æ¥é™ä½å¤æ‚åº¦ï¼Œå‚è€ƒäº†leetcode è®¨è®ºåŒºjavaçš„solutionã€‚\nå°†kåŠ ä¸Šæ•°ç»„çš„æ¯ä½ï¼Œç„¶åmod10ï¼Œå¾—åˆ°çš„å€¼æ”¾åœ¨linkedlisté‡Œã€‚\nç„¶åå°†k /= 10åå°†è¿™ä¸ªå€¼åŠ åˆ°ä¸‹ä¸€ä½ã€‚\n\n## ä»£ç \n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> res = new LinkedList<>();\n        int len = num.length - 1;\n        while(len >= 0 || k != 0){\n            if(len >= 0)  k += num[len--];\n            res.addFirst(k % 10);\n            k = k /10;\n        }\n        \n        return res;\n    }\n}\n```\n\n## å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦ï¼š O(max(n, log10(k)))\nç©ºé—´å¤æ‚åº¦ï¼šO(max(n, log10(k)))\n\næ—¶é—´å¤æ‚åº¦ä¸æ˜¯æ•°ç»„çš„é•¿åº¦å°±æ˜¯log10kï¼Œç©ºé—´å¤æ‚åº¦æ˜¯å› ä¸ºæˆ‘ä»¬éœ€è¦å¼€æ–°çš„ç©ºé—´æ¥æŠŠç»“æœå­˜åˆ°linkedlisté‡Œé¢ã€‚\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186210190","body":"## æ€è·¯\nç›´æ¥å‚è€ƒäº†åŠ›æ‰£çš„æœ€ä¼˜è§£ï¼Œç”¨ä¸€ä¸ªæ•°ç»„å‚¨å­˜ç»“æœã€‚\næœ€è¿‘çš„cçš„ç´¢å¼•å…ˆè®¾æˆæ— ç©·å°ã€‚\nå…ˆä»å·¦è¾¹æ‰«æä¸€æ¬¡æ•°ç»„æ¯”è¾ƒæ¯ä¸ªindexå’Œæœ€è¿‘çš„cçš„indexçš„è·ç¦»ã€‚ç„¶åå­˜è¿›æ•°ç»„å¯¹åº”çš„indexã€‚\næœ€è¿‘çš„cçš„ç´¢å¼•è®¾æˆæ— ç©·å¤§ã€‚\nå†ä»å³è¾¹æ‰«æä¸€æ¬¡æ•°ç»„æ¯”è¾ƒæ¯ä¸ªindexå’Œæœ€è¿‘çš„cçš„indexçš„è·ç¦»ï¼Œç„¶åä¸ä¹‹å‰çš„æ•°ç»„çš„å€¼æ¯”è¾ƒï¼Œå–å°çš„é‚£ä¸ªã€‚\n\n## ä»£ç \n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int prev = Integer.MIN_VALUE / 2;\n        int[] ans = new int[n];\n        for(int i = 0; i < n; i++) {\n            if(s.charAt(i) == c) prev = i;\n            ans[i] = i - prev;\n        }\n        \n        prev = Integer.MAX_VALUE / 2;\n        for(int i = n - 1; i >= 0; i--) {\n            if(s.charAt(i) == c) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n        return ans;\n    }\n}\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼š O(N)\nå› ä¸ºå°±æ˜¯éå†äº†ä¸¤éæ•°ç»„\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)\nåˆ›å»ºäº†ä¸€ä¸ªè·ŸåŸæ¥nä¸€æ ·é•¿åº¦çš„æ•°ç»„æ¥å‚¨å­˜ç»“æœã€‚","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186549032","body":"## æ€è·¯\n- çœ‹äº†æœ€ä½³é¢˜è§£çš„å‰ç¼€å’Œï¼Œä½†æ˜¯ä¸çŸ¥é“å°±æ˜¯ä¼˜åŒ–çš„ä»£ç æ˜¯ä¸æ˜¯å¯ä»¥ç”¨javaå®ç°\n- ç®€å•æ¥è¯´å°±æ˜¯ç”¨ä¸€ä¸ªincrementæ•°ç»„æ¥å®ç°incrementæ“ä½œã€‚\n- å¦‚æœincrementäº†ï¼Œä¸”k < stack.sizeï¼Œé‚£ä¹ˆincrement[k]ç›¸å½“äºè¦åŠ çš„valã€‚å¦‚æœè¦popäº†ï¼Œé‚£ä¹ˆè¿™ä¸ªinc[k-1]çš„åœ°æ–¹ä¼šåŠ ä¸ŠåŸæ¥inc[k]çš„å€¼ã€‚\n- pushåªè¦ç¡®è®¤ä¸‹è¾¹ç•Œæ²¡æœ‰è¶…å°±è¡Œï¼Œ\n\n## ä»£ç \n\n```java\nclass CustomStack {\n    \n    int n;\n    int[] inc;\n    Stack<Integer> stack;\n\n    public CustomStack(int maxSize) {\n        n = maxSize;\n        inc = new int[n];\n        stack = new Stack<>();\n        \n    }\n    \n    public void push(int x) {\n        if(stack.size() < n)\n            stack.push(x);\n    }\n    \n    public int pop() {\n        int i = stack.size() - 1;\n        if(i < 0) return -1;\n        if(i > 0) inc[i - 1] += inc[i];\n        int res = stack.pop() + inc[i];\n        inc[i] = 0;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        int i = Math.min(k, stack.size()) - 1;\n        if(i >= 0)\n            inc[i] += val;\n    }\n}\n\n\n```\næ—¶é—´å¤æ‚åº¦ï¼šO(1)\nç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186572599","body":"##æ€è·¯\n- å°±æ˜¯åˆ©ç”¨æ ˆçš„ç‰¹æ€§ï¼Œå…ˆæŠŠæ‰€æœ‰å­—ç¬¦éƒ½å‹å…¥æ ˆä¸­ï¼Œé‡åˆ°\"]\"æ—¶è¯´æ˜æ‰¾åˆ°åŒ¹é…ã€‚è¿™ä¸ªæ—¶å€™å…ˆå°†[]å†…çš„stringå­˜åˆ°ä¸€ä¸ªåœ°æ–¹ã€‚\nåœ¨è¯»å®Œstringåï¼Œå¼€å§‹è¯»æ•°å­—kï¼Œæ•°å­—æœ‰å¯èƒ½ä¸æ˜¯1ä½ï¼Œæ‰€ä»¥è¦ç”¨ä¸€ä¸ªbaseå’Œå¾ªç¯æ¥è¯»æ•°å­—ã€‚\næœ€åå°† k * stringå‹å›æ ˆä¸­ã€‚ç»§ç»­åŒ¹é…ã€‚æœ€ç»ˆæ ˆå†…çš„å­—ç¬¦ä¸²å› ä¸ºæ˜¯åç€çš„ï¼ˆå‡ºæ ˆçš„æ—¶å€™é¡ºåºç›¸åï¼‰ï¼Œæ‰€ä»¥resultè®°å¾—åç€å°†æ ˆä¸­æ‰€æœ‰å­—æ¯å¼¹å‡ºæ¥ã€‚\n\n\n## ä»£ç \n```code \nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n        \n        \n        for(int i = 0; i < s.length(); i++) {\n            if(s.charAt(i) == ']'){\n                List<Character> decodedString = new ArrayList<>();\n                while(stack.peek() != '['){\n                    decodedString.add(stack.pop());\n                }\n                stack.pop();\n                int k = 0;\n                int base = 1;\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\n                    k = k + (stack.pop() - '0') * base;\n                    base *= 10;\n                }\n                while(k != 0){\n                    for(int j = decodedString.size() - 1; j >= 0; j--){\n                        stack.push(decodedString.get(j));\n                    }\n                    k--;\n                }\n            }\n            else{\n                stack.push(s.charAt(i));\n            }\n        }\n       \n        char[] result = new char[stack.size()];\n        for(int i = result.length - 1; i >= 0; i--){\n            result[i] = stack.pop();\n        }\n        return new String(result);\n    }\n}\n```\næ—¶é—´å¤æ‚åº¦ï¼šO(maxK^(countK)â‹…n).\nç©ºé—´å¤æ‚åº¦ï¼šO(sum(maxK^(countK) â‹…n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189224462","body":"## æ€è·¯\nç”¨ä¸¤ä¸ªæ ˆæ¥å®ç°é˜Ÿåˆ—ï¼Œä¸€ä¸ªæ ˆç”¨æ¥ä¿å­˜é™¤äº†åº•éƒ¨çš„æ‰€æœ‰æ•°æ®ã€‚\n\n## ä»£ç \n\n```java\nclass MyQueue {\n\n    Stack<Integer> input = new Stack();\n    Stack<Integer> output = new Stack();\n    \n    public void push(int x) {\n        input.push(x);\n    }\n\n    public int pop() {\n        peek();\n        return output.pop();\n    }\n\n    public int peek() {\n        if (output.empty())\n            while (!input.empty())\n                output.push(input.pop());\n        return output.peek();\n    }\n\n    public boolean empty() {\n        return input.empty() && output.empty();\n    }\n}\n\n```\n\næ—¶é—´å¤æ‚åº¦ï¼šO(1)\nç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190461363","body":"## æ€è·¯\nç”¨æ’åºè®¡æ•°çš„æ–¹æ³•æ‰¾åˆ°æœ€å°å—\nä»Šå¤©ç­”æ¡ˆç›´æ¥æŠ„å®˜æ–¹é¢˜è§£äº†\n\n\n## ä»£ç \n```java\n\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0;\n        int nonzero = 0;\n        \n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n        \n        for(int i = 0; i < arr.length; ++i) {\n            int x = arr[i];\n            int y = expect[i];\n            \n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if(count.get(x) == 0){\n                nonzero--;\n            }\n            if(count.get(x) == 1){\n                nonzero++;\n            }\n            \n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if(count.get(y) == -1){\n                nonzero++;\n            }\n            if(count.get(y) == 0){\n                nonzero--;\n            }\n            if(nonzero == 0){\n                ans++;\n            }\n        }\n        \n        return ans;\n        \n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191542246","body":"## æ€è·¯\n\n- å°†é“¾è¡¨è¿æˆç¯ï¼Œç„¶åæ–­å¼€å¤„äºn-k-1ä½ç½®çš„æŒ‡é’ˆ\n    - å…ˆéå†é“¾è¡¨æ‰¾åˆ°å°¾èŠ‚ç‚¹è¿ç€å¤´\n    - éå†æ‰¾åˆ°n-k-1çš„ä½ç½®ï¼Œæ–­å¼€èŠ‚ç‚¹\n\n## ä»£ç \n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        \n        if(head == null) return null;\n        if(head.next == null) return head;\n        \n        ListNode old_tail = head;\n        int length = 1;\n        while (old_tail.next != null) {\n            length++;\n            old_tail = old_tail.next;\n        }\n        k = k % length;\n        old_tail.next = head;\n        int i = 0;\n        ListNode new_tail = head;\n        while (i < length - k - 1){\n            new_tail = new_tail.next;\n            i++;\n        }\n        ListNode new_head = new_tail.next;\n        new_tail.next = null;\n        return new_head;\n    }\n}\n\n```\n\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\nç©ºé—´å¤æ‚åº¦ï¼šO(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192708036","body":"# æ€è·¯\nä»Šå¤©ç›´æ¥æŠ„äº†é¢˜è§£å‘œå‘œå‘œï¼Œå…ˆåŠ ä¸€ä¸ªä¼ªèŠ‚ç‚¹ï¼Œç„¶åè¯•ç€æ¨¡æ‹Ÿä¸€ç»„èŠ‚ç‚¹rotateæ˜¯ä»€ä¹ˆæƒ…å†µï¼Œä¹‹åéå†æ‰€æœ‰èŠ‚ç‚¹ã€‚\n\n\n## ä»£ç \n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null) return head;\n        ListNode preNode = new ListNode(-1, head);\n        ListNode res;\n        preNode.next = head;\n        res = head.next;\n        ListNode firstNode = head;\n        ListNode secondNode;\n        ListNode nextNode;\n        while(firstNode != null && firstNode.next != null) {\n            secondNode = firstNode.next;\n            nextNode = secondNode.next;\n            \n            firstNode.next = nextNode;\n            secondNode.next = firstNode;\n            preNode.next = secondNode;\n            \n            preNode = firstNode;\n            firstNode = nextNode;\n        }\n        return res;\n    }\n}\n\n```\n\næ—¶é—´å¤æ‚åº¦:O(n)\nç©ºé—´å¤æ‚åº¦:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193111916","body":"## æ€è·¯\n- å…ˆé€šè¿‡å¿«æ…¢æŒ‡é’ˆæ³•æ‰¾åˆ°nodeçš„ä¸­ç‚¹ï¼Œç„¶åæŠŠå®ƒæ’å…¥äºŒå‰æ ‘ã€‚\n- ä¹‹åé€’å½’å®ç°è¿™ä¸ªå‡½æ•°\n\n\n## ä»£ç \n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null) return null;\n        return dfs(head, null);\n    }\n    \n    private TreeNode dfs(ListNode head, ListNode tail){\n        if(head == tail) return null;\n        ListNode fast = head, slow = head;\n        while(fast != tail && fast.next != tail){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        root.left = dfs(head, slow);\n        root.right = dfs(slow.next, tail);\n        return root;\n    }\n}\n```\n\næ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)\nç©ºé—´å¤æ‚åº¦ï¼šO(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193345783","body":"## æ€è·¯\næŠŠé“¾è¡¨Açš„æ‰€æœ‰èŠ‚ç‚¹éƒ½åŠ å…¥åœ¨å“ˆå¸Œè¡¨ï¼Œçœ‹é“¾è¡¨Bä¸­æœ‰æ²¡æœ‰containï¼Œå¦‚æœæ²¡æœ‰å°±è¿”å›nullã€‚\n\n## ä»£ç \n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Set<ListNode> nodesInB = new HashSet<ListNode>();\n        \n        while(headB != null) {\n            nodesInB.add(headB);\n            headB = headB.next;\n        }\n        \n        while(headA != null) {\n            if(nodesInB.contains(headA)) {\n                return headA;\n            }\n            headA = headA.next;\n        }\n        \n        return null;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194239460","body":"## æ€è·¯\nç”¨å“ˆå¸Œéå†é“¾è¡¨çš„æ‰€æœ‰èŠ‚ç‚¹ï¼ŒæŠŠä»–ä»¬åŠ å…¥å“ˆå¸Œè¡¨ï¼Œå¦‚æœä¹‹å‰å“ˆå¸Œè¡¨ä¸­æœ‰è¿‡ä¸€æ ·çš„èŠ‚ç‚¹ï¼Œé‚£ä¹ˆè¿™ä¸ªèŠ‚ç‚¹å°±æ˜¯ç¯ç›¸äº¤çš„èŠ‚ç‚¹ï¼Œå¦‚æœæ²¡æœ‰å°±ç»§ç»­éå†åˆ°é˜Ÿå°¾ã€‚\nå¦‚æœä¸æ˜¯ç¯è‚¯å®šä¼šéå†ç»“æŸã€‚\n\n## ä»£ç \n\n```Java\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode pos = head;\n        Set<ListNode> visited = new HashSet<ListNode>();\n        while(pos != null) {\n            if(visited.contains(pos)){\n                return pos;\n            }else {\n                visited.add(pos);\n            }\n            pos = pos.next;\n        }\n        return null;\n    }\n}\n```\n\n## å¤æ‚åº¦\n æ—¶é—´å¤æ‚åº¦ï¼šO(N)\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195665563","body":"## æ€è·¯\n\nç”¨äº†åŒå‘é“¾è¡¨å’Œå“ˆå¸Œè¡¨ï¼Œå› ä¸ºç”¨äº†å“ˆå¸Œè¡¨æ‰€ä»¥getçš„å¤æ‚åº¦æ˜¯O(1)ï¼Œç”¨äº†åŒå‘é“¾è¡¨å°±å¯ä»¥ç”¨O(1)æ”¹å˜å¤´å’Œå°¾ã€‚\n\n## ä»£ç \n\n\n```Java\n\nclass LRUCache {\n    class DLinkedNode {\n        int key, value;\n        DLinkedNode prev, next;\n        public DLinkedNode() {}\n        public DLinkedNode(int _key, int _value) {\n            key = _key;\n            value = _value;\n        }\n    }\n\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size, cap;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        size = 0;\n        cap = capacity;\n        //add dummy head and dummyTail\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) return -1;\n        //if key exist, move it to head by using its location store in Hashmap\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            //made a newNode if it does not exist\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            cache.put(key, newNode);\n            addToHead(newNode);\n            ++size;\n            if (size > cap) {\n                DLinkedNode removedTail = removeTail();\n                cache.remove(removedTail.key);\n                --size;\n            }\n        } else {\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DLinkedNode node){\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node){\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DLinkedNode node){\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail(){\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n\n```\n\næ—¶é—´å¤æ‚åº¦ï¼šOï¼ˆ1ï¼‰\nç©ºé—´å¤æ‚åº¦ï¼šOï¼ˆNï¼‰","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196940392","body":"## æ€è·¯\né€’å½’æ±‚äºŒå‰æ ‘æ·±åº¦\n\n## ä»£ç \n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) {\n            return 0;\n        }\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n    }\n}\n\n```\n\n## å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\nç©ºé—´å¤æ‚åº¦ï¼šO(h)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198121795","body":"## æ€è·¯\né€’å½’å·¦å­æ ‘å’Œå³å­æ ‘ç›¸ç­‰ä¸ç›¸ç­‰ï¼Œç»ˆæ­¢æ¡ä»¶æ˜¯å¶èŠ‚ç‚¹ã€‚\n\n## ä»£ç \n\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null) return true;\n        if(p == null || q == null) return false;\n        if(p.val != q.val) return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);       \n    }\n}\n```\n\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\nç©ºé—´å¤æ‚åº¦ï¼šO(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199296833","body":"## æ€è·¯\nç”¨å‰åºéå†éå†æ ‘ï¼Œdfsæ±‚æ¯ä¸ªåˆ†æ”¯èŠ‚ç‚¹çš„å’Œã€‚\n\n## ä»£ç \n```java\nclass Solution {\n    public int ans;\n    public int sumNumbers(TreeNode root) {\n        dfs(root, 0);\n        return ans;\n    }\n    \n    public void dfs(TreeNode root, int last) {\n        if(root == null) return;\n        if(root.left == null && root.right == null) {\n            ans += last * 10 + root.val;\n            return;\n        }\n        dfs(root.left, last * 10 + root.val);\n        dfs(root.right, last * 10 + root.val);\n    }\n}\n\n```\n## å¤æ‚åº¦ï¼š\næ—¶é—´å¤æ‚åº¦ï¼šO(n)\nç©ºé—´å¤æ‚åº¦ï¼šO(h)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"neado":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185661466","body":"### æ€è·¯\n\næœ€åä¸€ä¸ªå…ƒç´ å¼€å§‹éå†ï¼Œéå†åˆ°æœ€åä¸€ä¸ªå…ƒç´ è‹¥æ˜¯ç´¢å¼•åˆ°äº†å°½å¤´ï¼Œè€Œè¿˜æœ‰è¿›ä½å°±ä¾æ® || k>0é€»è¾‘å†æ¬¡è¿ç®—ä¸€é\nç»´æŠ¤ä¸€ä¸ªç›¸åŠ æ•°k\nå¹¶å­˜å‚¨è®¡ç®—ä¹‹åçš„ç»“æœ\næœ€åè¿”å›ç»“æœæ•°ç»„\n### ä»£ç \n\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n=num.length;\n        LinkedList<Integer> res=new LinkedList<>();\n        for(int i=n-1;i>-1|| k>0;i--){\n            if(i>-1 ){\n                k=k+num[i];\n            }\n            Integer r=k%10;\n            res.addFirst(r);\n            k=k/10;\n        }\n        return res;\n    }\n}\n\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦(Time)ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦(Space)ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186225868","body":"## æ€è·¯\nå…ˆéå†å­—ç¬¦ï¼Œå­˜ä¸‹æ ‡\nå†bfs\n## ä»£ç \n```java\nclass Solution {\n    int[] dirs = new int[]{-1, 1};\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] res = new int[n];\n\n        //å¡«å…¥-1 ï¼Œç”¨äºåˆ¤æ–­æ˜¯å¦ç›®æ ‡å­—ç¬¦\n        Arrays.fill(res, -1);\n\n        Deque<Integer> d = new ArrayDeque<>();\n\n        //ç›®æ ‡å­—ç¬¦ å…¥é˜Ÿï¼Œç»“æœæ•°ç»„ç½®ä¸º0\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == c) {\n                d.addLast(i);\n                res[i] = 0;\n            }\n        }\n        //bfs éå†æ•°æ®ï¼Œä»å·¦åˆ°å³ï¼Œéå†ç›®æ ‡å­—ç¬¦ä¸‹æ ‡\n        while (!d.isEmpty()) {\n            int t = d.pollFirst();\n            //å‰åæœç´¢\n            for (int dir : dirs) {\n                //ç§»åŠ¨åä¸‹æ ‡\n                int index = t + dir;\n                //åªå¤„ç†éç›®æ ‡å­—ç¬¦\n                if (index >= 0 && index < n && res[index] == -1) {\n                    //æ— è®ºå‘å“ªä¸ªæ–¹å‘ç§»åŠ¨ï¼Œè·ç¦»éƒ½ä¼šåŠ 1\n                    res[index] = res[t] + 1;\n                    d.addLast(index);\n                }\n            }\n        }\n        return res;\n    }\n}\n\n```\n## å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦ï¼š O(n)\nç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186552368","body":"## æ€è·¯\r\n\r\n## ä»£ç \r\n\r\n```java\r\nclass CustomStack {\r\n    int[] arr;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        arr = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != arr.length - 1) {\r\n            arr[++top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        return arr[--top + 1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int m = Math.min(k, top + 1);\r\n        for (int i = 0; i < m; ++i) {\r\n            arr[i] += val;\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187677968","body":"## æ€è·¯\r\nä¸¤ä¸ªæ ˆåˆ†åˆ«å­˜ é‡å¤æ¬¡æ•° å’Œè¦é‡å¤çš„å­—ç¬¦\r\n\r\n- å­—ç¬¦å’Œæ•°å­—åˆ†åˆ«èµ‹å€¼\r\n- é‡åˆ° å·¦æ‹¬å· `[` å°±å­˜å…¥æ ˆï¼Œå¹¶æ¸…é™¤å­—ç¬¦ä¸´æ—¶å­˜å‚¨å˜é‡å€¼\r\n- é‡åˆ°å³æ‹¬å· `[`  å°±å–å‡ºç›¸åº”å­—ç¬¦ä¸²ï¼Œå¹¶å¾ªç¯æ‹¼æ¥ç›¸åº”æ¬¡æ•°\r\n\r\n## ä»£ç \r\n```java\r\n class Solution {\r\n    int mulN = 0;\r\n    public String decodeString(String s) {\r\n        StringBuilder res = new StringBuilder();\r\n        LinkedList<Integer> muS = new LinkedList<>();\r\n        LinkedList<String> chS = new LinkedList<>();\r\n        for(char c : s.toCharArray()) {\r\n            //å…¥æ ˆ æ•°å­—å’Œå­—ç¬¦\r\n            if(c == '[') {\r\n                muS.addLast(mulN);\r\n                chS.addLast(res.toString());\r\n                mulN = 0;\r\n                res = new StringBuilder();\r\n            }else if(c == ']') {\r\n                StringBuilder midT = new StringBuilder();\r\n                int n = muS.removeLast();\r\n                for(int i = 0; i < n; i++) {\r\n                    midT.append(res);\r\n                }\r\n                res = new StringBuilder(chS.removeLast() + midT);\r\n                //å‡ºæ ˆ\r\n            }else if(c >= '0' && c <= '9') {\r\n                //èµ‹å€¼æ•°å­—\r\n                mulN = mulN * 10 + Integer.parseInt(c + \"\");\r\n            }else{\r\n                //èµ‹å€¼å­—ç¬¦\r\n                 res.append(c);\r\n            }\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189235609","body":"```java\nclass MyQueue {\n\n     Stack<Integer> inStack;\n     Stack<Integer> outStack;\n    public MyQueue() {\n        inStack=new Stack<>();\n        outStack=new Stack<>();\n    }\n    \n    public void push(int x) {\n        inStack.push(x);\n    }\n    \n    public int pop() {\n        moveToOut();\n        return outStack.pop();\n    }\n    \n    public int peek() {\n        moveToOut();\n        return outStack.peek();\n    }\n    \n    public boolean empty() {\n        return inStack.isEmpty() &&outStack.isEmpty();\n    }\n\n    public void moveToOut(){\n        if(outStack.isEmpty()){\n                while(!inStack.isEmpty()){\n                    outStack.push(inStack.pop());\n                }\n        }\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191664970","body":"```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null) {\n            return head;\n        }\n        int c = 0;\n        ListNode cur = head;\n        //è®¡èŠ‚ç‚¹æ•°\n        while(cur != null){\n            cur = cur.next;\n            c++;\n        }\n        //è·å–å®é™…è¿åŠ¨æ­¥æ•°\n        k = k % c;\n        //å¿«æ…¢æŒ‡é’ˆ\n        ListNode s = head, f = head;\n        while(f.next != null){\n            //å¿«æŒ‡é’ˆå…ˆèµ°kæ­¥ æ­¤å¤„æ…¢æŒ‡é’ˆèµ°äº† c-k æ­¥\n            if(k-- <= 0){\n                s = s.next;\n            }\n            f = f.next;\n        }\n        //è¿æ¥æˆç¯\n        f.next = head;\n\n        //æ–°é“¾è¡¨é¦–èŠ‚ç‚¹\n        ListNode res = s.next;\n        s.next = null;\n        return res;\n    }\n}\n\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192719833","body":"### æ€è·¯\r\nå®šä¹‰ä¸€ä¸ªè™šæ‹Ÿå¤´èŠ‚ç‚¹ï¼Œä»¥æ­¤ä¸ºåŸºå‡†è¿›è¡Œä¸€ç³»åˆ—æ“ä½œ\r\n*  è™šæ‹Ÿå¤´èŠ‚ç‚¹ï¼Œéå†\r\n*  éœ€è¦ä¹‹åæœ‰ä¸¤ä¸ªèŠ‚ç‚¹éç©ºæ‰èƒ½ç»§ç»­æ“ä½œ\r\n*  ç„¶åæ˜“è™šæ‹Ÿå¤´èŠ‚ç‚¹ä¸ºå‰èŠ‚ç‚¹è¿›è¡Œæ“ä½œ\r\n\r\n### ä»£ç \r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        ListNode du = new ListNode(0);\r\n        du.next = head;\r\n        ListNode temp = du;\r\n        while (temp.next != null && temp.next.next != null) {\r\n            ListNode cur = temp.next;\r\n            ListNode tnext = temp.next.next;\r\n            temp.next = tnext;\r\n            cur.next = tnext.next;\r\n            tnext.next = cur;\r\n            temp = cur;\r\n        }\r\n        return du.next;\r\n    }\r\n}\r\n```\r\næ—¶é—´å¤æ‚åº¦ï¼ˆTIMEï¼‰O(n)\r\nç©ºé—´å¤æ‚åº¦ï¼ˆSPACEï¼‰O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193145072","body":"## æ€è·¯\nä½¿ç”¨å¿«æ…¢æŒ‡é’ˆæ‰¾åˆ°ä¸­ç‚¹\nç„¶åä»¥ä¸­ç‚¹ä¸ºä¸­å¿ƒåˆ›å»ºå¹³è¡¡äºŒå‰æ ‘\n\n## ä»£ç \n```java\nclass Solution {\n  public TreeNode sortedListToBST(ListNode head) {\n      if(head == null){\n           return null;\n      }\n      return dfs(head,null);\n  }\n  private TreeNode dfs(ListNode head, ListNode tail){\n      if(head == tail){\n           return null;\n      }\n      ListNode fast = head;\n      ListNode slow = head;\n      //å¿«æ…¢æŒ‡é’ˆæ‰¾åˆ°ä¸­ç‚¹\n      while(fast != tail && fast.next != tail){\n          fast = fast.next.next;\n          slow = slow.next;\n      }\n      //ä¸­ç‚¹ä¸ºæ ¹èŠ‚ç‚¹åˆ›å»ºå¹³è¡¡äºŒå‰æ ‘\n      TreeNode root = new TreeNode(slow.val);\n      root.left = dfs(head, slow);\n      root.right = dfs(slow.next, tail);\n      return root;\n  }\n}\n```\næ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)\nç©ºé—´å¤æ‚åº¦ï¼šO(nlogn)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193346499","body":"```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA ==null || headB==null)return null;\n\n        ListNode pa=headA,pb=headB;\n\n        while(pa !=pb){\n            pa=pa==null ?headB:pa.next;\n            pb=pb==null ?headA:pb.next;\n        }\n        return pa;\n    }\n}\n\n```\nT:o(n)\ns:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194278417","body":"## æ€è·¯\r\n\r\nå¿«æ…¢æŒ‡é’ˆï¼Œç¬¬ä¸€æ¬¡ç›¸äº¤åå†é‡ç½®å¿«æŒ‡é’ˆåˆ°headï¼Œå†ä¸€èµ·è¿­ä»£ï¼Œç›´åˆ°ç¬¬äºŒæ¬¡ç›¸äº¤\r\n\r\n## ä»£ç \r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if(head==null) return null;\r\n        ListNode f=head;\r\n        ListNode s=head;\r\n\r\n        while(f !=null){\r\n            s=s.next;\r\n            if(f.next!=null){\r\n                f=f.next.next;\r\n            }else{\r\n                return null;\r\n            }\r\n            \r\n            //æŒ‡é’ˆäº¤ç‚¹å¤„\r\n            if(f==s){\r\n\r\n                //é‡ç½®å¿«æŒ‡é’ˆåˆ°headå¤„ï¼Œå¿«æ…¢æŒ‡é’ˆåŒæ—¶ç§»åŠ¨ä¸€æ­¥è¿­ä»£ï¼Œç›´åˆ°å†æ¬¡ç›¸äº¤\r\n                ListNode t=head;\r\n\r\n                while(t!= s){\r\n                    s=s.next;\r\n                    t=t.next;\r\n                }\r\n                return t;\r\n\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\nT:O(N)\r\nS:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195669776","body":"```java\nclass LRUCache {\n    class DLinkedNode {\n        int key;\n        int value;\n        DLinkedNode pre, next;\n        public DLinkedNode() {}\n        public DLinkedNode(int _key, int _value) {\n            key = _key;\n            value = _value;\n        }\n    }\n\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size, cap;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        size = 0;\n        cap = capacity;\n        //æ·»åŠ è™šæ‹ŸèŠ‚ç‚¹\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.pre = head;\n    }\n\n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) return -1;\n        //è‹¥kå­˜åœ¨ç§»åŠ¨å…¶åˆ°å¤´èŠ‚ç‚¹ å¹¶å­˜å‚¨\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            //è‹¥ä¸å­˜åœ¨å°±åˆ›å»º\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            cache.put(key, newNode);\n            addToHead(newNode);\n            ++size;\n            if (size > cap) {\n                DLinkedNode removedTail = removeTail();\n                cache.remove(removedTail.key);\n                --size;\n            }\n        } else {\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DLinkedNode node){\n        node.pre = head;\n        node.next = head.next;\n        head.next.pre = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node){\n        node.pre.next = node.next;\n        node.next.pre = node.pre;\n    }\n\n    private void moveToHead(DLinkedNode node){\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail(){\n        DLinkedNode res = tail.pre;\n        removeNode(res);\n        return res;\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196898999","body":"\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        } else {\n            int l = maxDepth(root.left);\n            int r = maxDepth(root.right);\n            return Math.max(l, r) + 1;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198313622","body":"# æ€è·¯\nå…ˆæŸ¥è¯¢èŠ‚ç‚¹åˆ¤æ–­\nåˆ›å»ºä¸¤ä¸ªæ ˆ\nç„¶ååˆ†åˆ«å…¥æ ˆ\nå†bfs å…¥æ ˆ å‡ºæ ˆ å¯¹æ¯”\n\n# ä»£ç \n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\n\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        Queue<TreeNode> queue = new LinkedList<>();\n         //two node all null return true;\n        if (p == null && q == null){\n             return true;\n        }\n        //just p or q is null return false\n        if (p == null || q == null){\n             return false;\n        }\n        queue.offer(p);\n        queue.offer(q);\n        //BFS\n        while (!queue.isEmpty()) {\n            TreeNode first = queue.poll();\n            TreeNode second = queue.poll();\n            if (first == null && second == null) continue;\n            //not equals return false\n            if (first == null || second == null) return false;\n            if (first.val != second.val) return false;\n            //Stack corresponding nodes of two trees\n            queue.offer(first.left);\n            queue.offer(second.left);\n            queue.offer(first.right);\n            queue.offer(second.right);\n        }\n        return true;\n    }\n}\n```\nT:O(N)\nS:O(Q)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199610089","body":"## æ€è·¯\nä½¿ç”¨æ ˆ è¿­ä»£\n\n##ä»£ç \n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        Deque<TreeNode> qu=new LinkedList<>();\n        qu.offer(root);\n        int s=0;\n\n\n        //bfs\n        while(!qu.isEmpty()){\n            int n=qu.size();\n        //éå†ä¸€å±‚\n            for(int i=0;i<n;i++){\n                TreeNode top=qu.poll();\n\n                //æ— å­èŠ‚ç‚¹å°±ç›´æ¥ç›¸åŠ \n                if(top.left== null && top.right==null){\n                    s += top.val;\n                }\n                if(top.left !=null){\n                    top.left.val = top.val *10 + top.left.val;\n                    qu.offer(top.left);\n\n                }\n\n                if(top.right !=null){\n                    top.right.val = top.val *10 + top.right.val;\n                    qu.offer(top.right);\n                    \n                }\n            }\n        }\n        return s;\n    }\n}\n\n```\n\nTime:O(n)\nSpace:O(H)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200242515","body":"```java\nclass Solution {\n    Map<Integer,Integer> map = new HashMap<>();\n    int maxLevel = 0;\n    public int findBottomLeftValue(TreeNode root) {\n        if (root == null) return 0;\n        LinkedList<TreeNode> deque = new LinkedList<>();\n        deque.add(root);\n        int res = 0;\n        while(!deque.isEmpty()) {\n            int size = deque.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode node = deque.pollFirst();\n                if (i == 0) {\n                    res = node.val;\n                }\n                if (node.left != null)deque.addLast(node.left);\n                if (node.right != null)deque.addLast(node.right);\n            }\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200455046","body":"# å¾…è¡¥é¢˜\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode(int x) { val = x; }\r\n * }\r\n */\r\npublic class Codec {\r\n    public String serialize(TreeNode root) {\r\n        return rserialize(root, \"\");\r\n    }\r\n  \r\n    public TreeNode deserialize(String data) {\r\n        String[] dataArray = data.split(\",\");\r\n        List<String> dataList = new LinkedList<String>(Arrays.asList(dataArray));\r\n        return rdeserialize(dataList);\r\n    }\r\n\r\n    public String rserialize(TreeNode root, String str) {\r\n        if (root == null) {\r\n            str += \"None,\";\r\n        } else {\r\n            str += str.valueOf(root.val) + \",\";\r\n            str = rserialize(root.left, str);\r\n            str = rserialize(root.right, str);\r\n        }\r\n        return str;\r\n    }\r\n  \r\n    public TreeNode rdeserialize(List<String> dataList) {\r\n        if (dataList.get(0).equals(\"None\")) {\r\n            dataList.remove(0);\r\n            return null;\r\n        }\r\n  \r\n        TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0)));\r\n        dataList.remove(0);\r\n        root.left = rdeserialize(dataList);\r\n        root.right = rdeserialize(dataList);\r\n    \r\n        return root;\r\n    }\r\n}\r\n\r\n// Your Codec object will be instantiated and called as such:\r\n// Codec ser = new Codec();\r\n// Codec deser = new Codec();\r\n// TreeNode ans = deser.deserialize(ser.serialize(root));\r\n\r\n```\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201388937","body":"## æ€è·¯\r\ndfs+ä¼˜å…ˆé˜Ÿåˆ—\r\n\r\n## ä»£ç \r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    PriorityQueue<int[]> q = new PriorityQueue<>((a, b)->{ // col, row, val\r\n        if (a[0] != b[0]) return a[0] - b[0];\r\n        if (a[1] != b[1]) return a[1] - b[1];\r\n        return a[2] - b[2];\r\n    });\r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n        int[] info = new int[]{0, 0, root.val};\r\n        q.add(info);\r\n        dfs(root, info);\r\n        List<List<Integer>> ans = new ArrayList<>();\r\n        while (!q.isEmpty()) {\r\n            List<Integer> tmp = new ArrayList<>();\r\n            int[] poll = q.peek();\r\n            while (!q.isEmpty() && q.peek()[0] == poll[0]) tmp.add(q.poll()[2]);\r\n            ans.add(tmp);\r\n        }\r\n        return ans;\r\n    }\r\n    void dfs(TreeNode root, int[] fa) {\r\n        if (root.left != null) {\r\n            int[] linfo = new int[]{fa[0] - 1, fa[1] + 1, root.left.val};\r\n            q.add(linfo);\r\n            dfs(root.left, linfo);\r\n        }\r\n        if (root.right != null) {\r\n            int[] rinfo = new int[]{fa[0] + 1, fa[1] + 1, root.right.val};\r\n            q.add(rinfo);\r\n            dfs(root.right, rinfo);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202878151","body":"\n\n## ä»£ç \n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        //å®šä¹‰map\n        unordered_map <int,int> mapt;\n        for(int i = 0; i < nums.size(); i++) {\n            // å–key å½“å‰æ•°çš„ è¡¥æ•° æ˜¯å¦å­˜åœ¨\n            // è¿™é‡Œvectorå°±ç›¸å½“äºjavaä¸­çš„Listæ•°ç»„\n            if(mapt.count(target-nums[i])) return vector<int>{mapt[target-nums[i]],i};\n            // ä¸å­˜åœ¨å°±å°†å½“å‰å…ƒç´ å­˜å…¥mapé‡Œé¢ï¼Œc++å¯ä»¥å°†ä¹‹ç›´æ¥è§†ä¸ºæ•°ç»„æ“ä½œï¼Œkeyæ˜¯ä¸‹æ ‡ï¼Œvalueæ˜¯æ•°ç»„å€¼\n            else mapt[nums[i]]=i;\n        }\n        // ä¸ç„¶è¿”å›ç©ºå€¼æ•°ç»„ï¼Œè¿™é‡Œvectorå°±ç›¸å½“äºjavaä¸­çš„Listæ•°ç»„\n        return vector<int>{};\n    }\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1204147952","body":"```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> occurrences = new HashMap<Integer, Integer>();\n        for (int num : nums) {\n            occurrences.put(num, occurrences.getOrDefault(num, 0) + 1);\n        }\n\n        // int[] çš„ç¬¬ä¸€ä¸ªå…ƒç´ ä»£è¡¨æ•°ç»„çš„å€¼ï¼Œç¬¬äºŒä¸ªå…ƒç´ ä»£è¡¨äº†è¯¥å€¼å‡ºç°çš„æ¬¡æ•°\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {\n            public int compare(int[] m, int[] n) {\n                return m[1] - n[1];\n            }\n        });\n        for (Map.Entry<Integer, Integer> entry : occurrences.entrySet()) {\n            int num = entry.getKey(), count = entry.getValue();\n            if (queue.size() == k) {\n                if (queue.peek()[1] < count) {\n                    queue.poll();\n                    queue.offer(new int[]{num, count});\n                }\n            } else {\n                queue.offer(new int[]{num, count});\n            }\n        }\n        int[] ret = new int[k];\n        for (int i = 0; i < k; ++i) {\n            ret[i] = queue.poll()[0];\n        }\n        return ret;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205363129","body":"```java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int n = points.length;\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            Map<Integer, Integer> map = new HashMap<>();\n            for (int j = 0; j < n; j++) {\n                if (i == j){\n                     continue;\n                }\n                int x = points[i][0] - points[j][0];\n                int y = points[i][1] - points[j][1];\n                int d = x * x + y * y;\n                map.put(d, map.getOrDefault(d, 0) + 1);\n            }\n            for (int d : map.keySet()) {\n                int c = map.get(d);\n                res += c * (c - 1);\n            }\n        }\n        return res;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207235363","body":"## ä»£ç \n\n```java\nclass Solution {\n\n    public List<Integer> findSubstring(String s, String[] words) {\n\n        List<Integer> res = new ArrayList<>();\n\n        Map<String, Integer> map = new HashMap<>();\n\n        if (words == null || words.length == 0)\n            return res;\n\n        for (String word : words)\n            map.put(word, map.getOrDefault(word, 0) + 1);\n\n        int sLen = s.length(), wordLen = words[0].length(), count = words.length;\n\n        int match = 0;\n\n        for (int i = 0; i < sLen - wordLen * count + 1; i++) {\n\n            //å¾—åˆ°å½“å‰çª—å£å­—ç¬¦ä¸²\n            String cur = s.substring(i, i + wordLen * count);\n            Map<String, Integer> temp = new HashMap<>();\n            int j = 0;\n\n            for (; j < cur.length(); j += wordLen) {\n\n                String word = cur.substring(j, j + wordLen);\n                // å‰ªæ\n                if (!map.containsKey(word))\n                    break;\n\n                temp.put(word, temp.getOrDefault(word, 0) + 1);\n                // å‰ªæ\n                if (temp.get(word) > map.get(word))\n                    break;\n            }\n\n            if (j == cur.length())\n                res.add(i);\n        }\n\n        return res;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207435737","body":"```java\nimport java.util.*;\n\nclass Solution {\n    public int solve(int[] nums, int k) {\n        int len = nums.length;\n        int res = len;\n        int re = 0;\n        int cur = 0;\n        for (int i : nums){\n            re = (re + i) % k;\n        }\n        //è®°å½•å€¼åŠå¯¹åº”ä¸‹æ ‡\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, -1);\n        //éå†æ•°ç»„\n        for (int i = 0; i < len;  i ++) {\n            cur = (cur + nums[i]) % k;\n            map.put(cur, i);\n            int r = (cur - re + k) % k;\n            res = Math.min(res, i - map.getOrDefault(r, -len));\n        }\n        if(res < len){\n            return res;\n        }\n        return -1;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208283321","body":"## æ€è·¯\nå¿«æ…¢æŒ‡é’ˆ\nå¿«æŒ‡é’ˆèµ°ä¸¤æ­¥ï¼Œæ…¢æŒ‡é’ˆèµ°ä¸€æ¬¡\n## ä»£ç \n```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode low = head,fast = head;\n        while(fast!=null && fast.next!=null){\n            fast=fast.next.next;\n            low=low.next;\n        }\n        return low;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209546518","body":"## æ€è·¯\n\n\n## ä»£ç \n\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int n = nums.length;\n        int j = 0;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] != nums[j]) {\n                nums[++j] = nums[i];\n            }\n        }\n        return j + 1;\n    }\n}\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaojunjun1110":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185663624","body":"#  æ€è·¯\r\nä»åå¾€å‰ç´¯åŠ ï¼Œæœ‰å¾ˆå¤šè¾¹ç•Œè¦å¤„ç†ï¼Œå‚è€ƒäº†å®˜æ–¹é¢˜è§£\r\n# Code\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int len = num.length;\r\n        int sum;\r\n        for(int i = len - 1; i >= 0; i--){\r\n            sum = num[i] + k % 10;\r\n            k = k /10;\r\n            if(sum >= 10){\r\n                k++;\r\n                sum -= 10;\r\n            }\r\n            res.add(sum);\r\n        }\r\n       for (; k > 0; k /= 10) {\r\n           res.add(k % 10);\r\n       }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n> + æ—¶é—´å¤æ‚åº¦: O(n)\r\n> + ç©ºé—´å¤æ‚åº¦:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186210463","body":"## æ€è·¯\r\n\r\n> + æš´åŠ›æ³•ï¼Œåˆ†åˆ«å·¦å³éå†å–æœ€å°,çœ‹é¢˜è§£åŸæ¥åŒå‘éå†å°±å¥½äº†ã€‚ã€‚ã€‚\r\n\r\n##ä»£ç \r\n\r\n```java\r\n#ä»£ç \r\n\r\n```class Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int j, k;\r\n        int res[] = new int[s.length()];\r\n        for(int i = 0; i < s.length(); i++){\r\n            j = i -1;\r\n            k = i + 1;\r\n            int minLen = Integer.MAX_VALUE;\r\n            if(s.charAt(i) == c){\r\n                res[i] = 0;\r\n            } else {\r\n                while(j >= 0 || k < s.length()){\r\n                    if(j >= 0 && s.charAt(j) == c){\r\n                        minLen = Math.min(minLen, i - j);\r\n                    }\r\n                    if(k < s.length() && s.charAt(k) == c){\r\n                        minLen = Math.min(minLen, k - i);\r\n                    }\r\n                    j--;\r\n                    k++;\r\n                }\r\n                res[i] = minLen;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n## å¤æ‚åº¦\r\n\r\n> + æ—¶é—´å¤æ‚åº¦: O(n2)\r\n> + ç©ºé—´å¤æ‚åº¦: O(n)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193128461","body":"# æ€è·¯\r\n  ç”¨å¿«æ…¢æŒ‡é’ˆæ‰¾åˆ°é‡ç‚¹ï¼Œç„¶åé€’å½’ \r\n\r\n# ä»£ç  \r\n```\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if (head == null){\r\n            return null;\r\n        }else if(head.next == null){\r\n            return new TreeNode(head.val);\r\n        }\r\n        //find mid\r\n        ListNode slowPtr = head, fastPtr = head;\r\n        ListNode pre = null;\r\n        while( fastPtr != null && fastPtr.next != null){\r\n            pre = slowPtr;\r\n            slowPtr = slowPtr.next;\r\n            fastPtr = fastPtr.next.next;\r\n        }\r\n\r\n        TreeNode root = new TreeNode(slowPtr.val);\r\n        pre.next = null;\r\n\r\n        //é€’å½’\r\n        root.left = sortedListToBST(head);\r\n        root.right = sortedListToBST(slowPtr.next);\r\n        return root;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wxleah":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185664303","body":"### æ€è·¯\r\n1. å°†æ•´æ•°åŠ åˆ°æ•°ç»„æœ€åä¸€ä½å³ä¸ªä½ï¼Œå–ä½™ä½œä¸ºä¸ªä½\r\n2. åŠ å’Œç»“æœçš„æ•´é™¤ç»“æœè¿›ä½ï¼ŒåŠ åˆ°æ•°ç»„ä¸‹ä¸€ä½\r\n\r\n### ä»£ç \r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        n = len(num)\r\n        i = n - 1\r\n        while i >= 0 or k > 0:\r\n            if i >= 0:\r\n                k += num[i]\r\n            res.append(k % 10)\r\n            i -= 1\r\n            k //= 10\r\n        res.reverse()\r\n        return res\r\n```\r\n\r\n### å¤æ‚åº¦åˆ†æ\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(max(n, logk)ï¼Œå…¶ä¸­ nÂ ä¸ºæ•°ç»„é•¿åº¦ã€‚ï¼ˆkæœ‰logkä½æ•°ï¼‰\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186211008","body":"## é¢˜ç›®\r\n[821](https://leetcode.cn/problems/shortest-distance-to-a-character/)\r\nGiven a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the distance from index i to the closest occurrence of character c in s.\r\n\r\nThe distance between two indices i and j is abs(i - j), where abs is the absolute value function.\r\n\r\n## å·¦å³åˆ†åˆ«æ‰¾\r\n### æ€è·¯\r\n?\r\n**_å·¦è¾¹æœ€è¿‘_**----ä»å·¦å¾€å³éå†, å½“æ‰¾åˆ°å­—ç¬¦æ—¶, æ›´æ–°å­—ç¬¦ä½ç½®loc, å­—ç¬¦ä½ç½®åœ¨éå†åˆ°çš„ä½ç½®iå·¦è¾¹, distance = i-loc\r\n**_å³è¾¹æœ€è¿‘_**----ä»å³å¾€å·¦éå†, å­—ç¬¦ä½ç½®locåœ¨éå†åˆ°çš„ä½ç½®iå³è¾¹, distance = loc-i\r\n**_æ¯”å¤§å°_**----å°†æ›´å°çš„å€¼å­˜åˆ°ç»“æœé‡Œ\r\n\r\n### ä»£ç \r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n =len(s)\r\n        res = [] \r\n\r\n        # ä»å·¦å¾€å³, è·ç¦»ä¸ºi-loc\r\n        loc = - n # è‹¥å·¦è¾¹æœªæ‰¾åˆ°c, ç¡®ä¿è·ç¦»>=n\r\n        for i, ch in enumerate(s) :\r\n            if ch == c:\r\n                loc = i\r\n            res.append(i - loc)\r\n        \r\n        # ä»å³å¾€å·¦, è·ç¦»ä¸ºloc-i\r\n        loc = 2*n # è‹¥å³è¾¹æœªæ‰¾åˆ°c, ç¡®ä¿è·ç¦»>=n\r\n        for i in range(n - 1, -1, -1):\r\n            if s[i] == c:\r\n                loc = i\r\n            res[i] = min(loc - i, res[i])\r\n        \r\n        return res\r\n```\r\n\r\n### å¤æ‚åº¦åˆ†æ\r\n?\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œå…¶ä¸­ nÂ ä¸ºæ•°ç»„é•¿åº¦ã€‚éå†ä¸¤é\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1) \r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186552453","body":"### ä»£ç \n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.count = 0\n        self.size = maxSize\n        self.add = [0] * self.size\n\n    def push(self, x: int) -> None:\n        if self.size > self.count:\n            self.stack.append(x)\n            self.count += 1\n\n    def pop(self) -> int:\n        if self.count == 0: \n            return -1\n        if self.count >= 2:\n            self.add[self.count-2] += self.add[self.count-1]\n        res = self.stack[self.count - 1] + self.add[self.count - 1]\n        self.add[self.count - 1] = 0\n        self.count -= 1\n        return res\n\n\n    def increment(self, k: int, val: int) -> None:\n        if self.count: \n            self.add[min(k - 1, self.count - 1)] += val\n","onTime":false},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193141840","body":"### ä»£ç \r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head):\r\n        def getMedian(left, right):\r\n            fast = slow = left\r\n            while fast != right and fast.next != right:\r\n                fast = fast.next.next\r\n                slow = slow.next\r\n            return slow\r\n        \r\n        def buildTree(left, right):\r\n            if left == right:\r\n                return None\r\n            mid = getMedian(left, right)\r\n            root = TreeNode(mid.val)\r\n            root.left = buildTree(left, mid)\r\n            root.right = buildTree(mid.next, right)\r\n            return root\r\n        \r\n        return buildTree(head, None)\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunl1ght":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185665340","body":"# æ€è·¯\n\néå†æ•°ç»„ï¼Œæ¯æ¬¡éƒ½è®©æ•°ç»„çš„æœ€åä¸€ä½å’Œæ•°å­—çš„ä¸ªä½æ±‚å’Œï¼Œä»£ç å¦‚ä¸‹ï¼š\n\n- æ—¶é—´å¤æ‚åº¦O(N)ï¼Œ\n\n- ç©ºé—´å¤æ‚åº¦O(N)\n\n# ä»£ç \n```Java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] A, int K) {\n        List<Integer> res = new ArrayList<>();\n        int i = A.length - 1, sum = 0, carry = 0;\n        // å¾ªç¯éå†æ•°ç»„Aï¼Œæ¯æ¬¡éƒ½å°†æ•°ç»„æœ«å°¾å’Œæ•°å­—Kçš„ä¸ªä½è¿›è¡Œæ±‚å’Œ\n        while (i >= 0 || K != 0) {  \n            int x = i >= 0 ? A[i]: 0;\n            int y = K != 0 ? K % 10 : 0;\n            sum = x + y + carry;\n            carry = sum / 10;\n            K /= 10;\n            i--;\n            res.add(0, sum % 10);\n        }\n        if (carry != 0) res.add(0, carry);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186213449","body":"## æ€è·¯\nå…ˆç»Ÿè®¡å­—ç¬¦ä¸²sä¸­å‡ºç°çš„cçš„ä½ç½®å­˜å…¥ä¸€åˆ—è¡¨ï¼Œå†å°†å­—ç¬¦ä¸²å„ä½ç½®ä¸åˆ—è¡¨ä¸­å€¼ä¾æ¬¡å¯¹æ¯”ï¼Œæ¯”è¾ƒå¾—å‡ºæœ€å°çš„å­˜å…¥è¾“å‡ºæ•°ç»„ä¸­ã€‚\n\n## ä»£ç \n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        char[] chs = s.toCharArray();\n        int[] res = new int[chs.length];\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < chs.length; i++) {\n            if (chs[i] == c){\n                list.add(i);\n            }\n        }\n        for (int i = 0; i < chs.length; i++) {\n            int min = Integer.MAX_VALUE;\n            for (int j = 0; j < list.size(); j++) {\n                if (Math.abs(i - list.get(j)) < min) {\n                    min = Math.abs(i - list.get(j));\n                } \n            }\n            res[i] = min;\n        }\n        return res;\n    }\n}\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦O(N^2)\n- ç©ºé—´å¤æ‚åº¦O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186503503","body":"## æ€è·¯\næ•°ç»„æ¨¡æ‹Ÿæ ˆï¼ŒåŒæ•°ç»„ï¼Œä¸€ä¸ªç”¨äºè®°å½•æ•°æ®ï¼Œä¸€ä¸ªç”¨äºè®°å½•å¢åŠ çš„å€¼ã€‚\n\n## ä»£ç \n```java\nclass CustomStack {\n        int maxSize;\n        int size;\n        int[] data;\n        int[] inc;\n        public CustomStack(int maxSize) {\n            this.maxSize=maxSize;\n            data=new int[maxSize];\n            inc=new int[maxSize];\n        }\n\n        public void push(int x) {\n            if(size<maxSize){\n                data[size++]=x;\n            }\n        }\n\n        public int pop() {\n            if(size==0) return -1;\n            int res=data[size-1]+inc[size-1];\n            if(size>1){\n                inc[size-2]+=inc[size-1];\n            }\n            inc[size-1]=0;\n            size--;\n            return res;\n        }\n\n        public void increment(int k, int val) {\n            int min=Math.min(k,size);\n            if(min>0)\n                inc[min-1]+=val;\n        }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189198055","body":"## æ€è·¯\n\næ¨¡æ‹Ÿé¢˜\n\né˜Ÿåˆ—-å…ˆè¿›å…ˆå‡ºï¼Œæ ˆ-å…ˆè¿›åå‡ºï¼Œå› æ­¤ï¼Œéœ€è¦ç”¨åˆ°ä¸¤ä¸ªæ ˆæ¨¡æ‹Ÿé˜Ÿåˆ—\n\n## ä»£ç \n```java\nclass MyQueue {\n\n    Stack<Integer> stack_in;\n    Stack<Integer> stack_out;\n\n    public MyQueue() {\n        stack_in = new Stack<>();\n        stack_out =  new Stack<>();\n    }\n    \n    public void push(int x) {\n        stack_in.push(x);\n    }\n    \n    public int pop() {\n        check_stack_in();\n        return stack_out.pop();\n    }\n    \n    public int peek() {\n        check_stack_in();\n        return stack_out.peek();\n    }\n    \n    public boolean empty() {\n        return stack_in.isEmpty() && stack_out.isEmpty();\n    }\n\n    public void check_stack_in() {\n        if (!stack_out.isEmpty()) {\n            return;\n        }\n        while (!stack_in.isEmpty()) {\n            stack_out.push(stack_in.pop());\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190412380","body":"## æ€è·¯\né‡‡ç”¨æ ˆæ“ä½œï¼Œå¯ä»¥å‘ç°å‡åºçš„é€’å¢ç‰¹å¾ï¼Œæ¯éƒ¨åˆ†æ„æˆé€’å¢ã€‚é¦–å…ˆéå†åŸæ•°ç»„ï¼Œæ ˆç©ºç›´æ¥å­˜å…¥æ ˆä¸­ï¼Œ\n- æ ˆhead > æ•°ç»„å½“å‰å€¼ï¼Œç›´æ¥popå‡ºæ ˆï¼Œç›´åˆ° >= æ ˆheadé¡¹å‡ºç°ï¼›\n- æ ˆhead <= æ•°ç»„å½“å‰å€¼ï¼Œå…¥æ ˆï¼›\næœ€åè¿”å›æ ˆçš„å¤§å°å³ä¸ºæœ€å¤§å—æ•°ã€‚\n\n## ä»£ç \n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        // æ ˆæ–¹æ³•\n        // åˆ¤æ–­æ ˆä¸­æ•°æ®\n        Stack<Integer> stack = new Stack<>();\n        for (int num : arr) {\n            if (!stack.isEmpty() && num < stack.peek()) {\n                int head = stack.pop();\n                while (!stack.isEmpty() && num < stack.peek()) {\n                    stack.pop();\n                }\n                stack.push(head);\n            } else {\n                stack.push(num);\n            }\n        }\n        return stack.size();\n    }\n}\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191556366","body":"## æ€è·¯\né¦–å…ˆéå†é“¾è¡¨ï¼Œå¾—åˆ°å°¾èŠ‚ç‚¹å’Œé“¾è¡¨é•¿åº¦ï¼Œå†k%lengthæ±‚å¾—æ—‹è½¬åçš„èµ·å§‹ä½ç½®ï¼Œæœ€åæ‹¼æ¥é“¾è¡¨ã€‚\n\n## ä»£ç \n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || k == 0) return head;\n        int listnodeLength = 0;\n        // éå†é“¾è¡¨\n        ListNode tail = null;\n        for (ListNode p = head; p != null; p = p.next) {\n            tail = p;\n            listnodeLength++;\n        }\n        // æ‰¾æ—‹è½¬åçš„å¤´èŠ‚ç‚¹\n        k %= listnodeLength;\n        ListNode p = head;\n        for (int i = 0; i < listnodeLength - k - 1; i++) {\n            p = p.next;\n        }\n        // å°†é“¾è¡¨çš„åkä¸ªèŠ‚ç‚¹å’Œn-kä¸ªèŠ‚ç‚¹æ‹¼æ¥\n        tail.next = head;\n        head = p.next;\n        p.next = null;\n        return head;\n    }\n}\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192529068","body":"## æ€è·¯\né€’å½’æ³•äº¤æ¢ä¸¤ä¸¤èŠ‚ç‚¹ï¼Œæ¯æ¬¡å°†å½“å‰å¤´èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå’Œä¸‹ä¸‹ä¸ªèŠ‚ç‚¹è¿›è¡Œäº¤æ¢ï¼›\n\n## ä»£ç \n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null)\n            return head;\n\n        ListNode subResult = swapPairs(head.next.next);\n        ListNode headNext = head.next;\n        headNext.next = head;\n        head.next = subResult;\n        return headNext;\n    }\n}\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(1)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193139608","body":"## æ€è·¯\nåŒæŒ‡é’ˆ + é€’å½’\n\n## ä»£ç \n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return buildBST(head, null);\n    }\n\n    private TreeNode buildBST(ListNode head, ListNode stopNode) {\n        if (head == stopNode){\n            return null;\n        }\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != stopNode && fast.next != stopNode){\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return new TreeNode(slow.val, buildBST(head, slow), buildBST(slow.next, stopNode));\n    }\n\n\n    public TreeNode sortedListToBST1(ListNode head) {\n        if (head == null){\n            return null;\n        }\n\n        if (head.next == null){\n            return new TreeNode(head.val);\n        }\n        ListNode slow = head;\n        ListNode fast = head;\n        ListNode slowPre = slow;\n        while (fast != null && fast.next != null){\n            slowPre = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        slowPre.next = null;\n        return new TreeNode(slow.val, sortedListToBST(head), sortedListToBST(slow.next));\n    }\n}\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ ï¼šO(NlogN)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193341807","body":"## æ€è·¯\néå†Aé“¾è¡¨ï¼Œå­˜åœ¨Setä¸­ï¼Œå†éå†Bé“¾è¡¨ï¼Œè‹¥Setä¸­å­˜åœ¨ï¼Œåˆ™è¿”å›è¯¥èŠ‚ç‚¹ï¼Œå¦åˆ™ä¸ç›¸äº¤ã€‚\n## ä»£ç \n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Set<ListNode> visited = new HashSet<ListNode>();\n        ListNode temp = headA;\n        while (temp != null) {\n            visited.add(temp);\n            temp = temp.next;\n        }\n        temp = headB;\n        while (temp != null) {\n            if (visited.contains(temp)) {\n                return temp;\n            }\n            temp = temp.next;\n        }\n        return null;\n    }\n}\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦O(m+n)\n- ç©ºé—´å¤æ‚åº¦O(m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194187435","body":"## æ€è·¯\nå¿«æ…¢æŒ‡é’ˆåˆ¤æ–­ç¯å½¢é“¾è¡¨ï¼Œåœ¨é€šè¿‡ç›¸é‡è·å¾—å…¥å£\n\n## ä»£ç \n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) {\n                ListNode index1 = fast;\n                ListNode index2 = head;\n                \n                while (index1 != index2) {\n                    index1 = index1.next;\n                    index2 = index2.next;\n                }\n                return index1;\n            }\n        }\n        return null;\n    }\n}\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195625761","body":"## ä»£ç \n```java\nclass LRUCache {\n    int cap;\n    LinkedHashMap<Integer, Integer> cache = new LinkedHashMap<>();\n    public LRUCache(int capacity) { \n        this.cap = capacity;\n    }\n\n    public int get(int key) {\n        if (!cache.containsKey(key)) {\n            return -1;\n        }\n        makeRecently(key);\n        return cache.get(key);\n    }\n    \n    public void put(int key, int value) {\n        if (cache.containsKey(key)) {\n            cache.put(key, value);\n            makeRecently(key);\n            return;\n        }\n        if (cache.size() >= this.cap) {\n            int oldKey = cache.keySet().iterator().next();\n            cache.remove(oldKey);\n        }\n        cache.put(key, value);\n    }\n\n    private void makeRecently(int key) {\n        int value = cache.get(key);\n        cache.remove(key);\n        cache.put(key, value);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196928125","body":"## ä»£ç \n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        // èŠ‚ç‚¹ä¸ºç©ºï¼Œé«˜åº¦ä¸º 0\n        if(root == null){\n            return 0;\n        }\n        // é€’å½’è®¡ç®—å·¦å­æ ‘çš„æœ€å¤§æ·±åº¦\n        int leftHeight = maxDepth(root.left);\n        // é€’å½’è®¡ç®—å³å­æ ‘çš„æœ€å¤§æ·±åº¦\n        int rightHeight = maxDepth(root.right);\n        // äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ = å­æ ‘çš„æœ€å¤§æ·±åº¦ + 1ï¼ˆ1 æ˜¯æ ¹èŠ‚ç‚¹ï¼‰\n        return Math.max(leftHeight, rightHeight) + 1;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198282674","body":"## æ€è·¯\né€’å½’\n## ä»£ç \n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        }\n\n        return process(p, q);\n    }\n\n    private boolean process(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        }\n        if (p == null || q == null) {\n            return false;\n        }\n        if (p.val != q.val) {\n            return false;\n        }\n        boolean leftEq = process(p.left, q.left);\n        boolean rightEq = process(p.right, q.right);\n        \n        return leftEq && rightEq;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199254283","body":"## æ€è·¯\ndfséå†ï¼Œé€’å½’æ±‚å’Œ\n\n## ä»£ç \n```java\nclass Solution {\n\n    int res = 0;\n    public int sumNumbers(TreeNode root) {\n        dfs(root, 0);\n        return res;\n    }\n    public void dfs(TreeNode root, int number)\n    {\n        number = number * 10 + root.val;\n        if(root.left == null && root.right == null)  res += number; \n        if(root.left != null)  dfs(root.left,number);\t\t\t\t\n        if(root.right != null) dfs(root.right,number);\t\t\t\t\n    }\n}\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200163460","body":"## æ€è·¯\nDFSä¼˜å…ˆéå†å·¦å­æ ‘ï¼Œæ¯æ¬¡è®°å½•å½“å‰ç¬¬ä¸€æ¬¡æœç´¢åˆ°çš„å€¼\n## ä»£ç \n```java\nclass Solution {\n    int max, res;\n    public int findBottomLeftValue(TreeNode root) {\n        dfs(root, 1);\n        return res;\n    }\n    void dfs(TreeNode root, int depth) {\n        if (root == null) return ;\n        if (depth > max) {\n            max = depth; ans = root.val;\n        }\n        dfs(root.left, depth + 1);\n        dfs(root.right, depth + 1);\n    }\n}\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200437301","body":"## æ€è·¯\nDFSå‰åºéå†ï¼Œååºåˆ—åŒ–åˆ©ç”¨é˜Ÿåˆ—å®ç°ï¼Œé‡åˆ°nullåˆ™ç›´æ¥è¿”å›ç©º\n\n## ä»£ç \n```java\npublic class Codec {\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        if (root == null) {\n            return \"null\";\n        }\n        String left = serialize(root.left);\n        String right = serialize(root.right);\n        return root.val + \",\" + left + \",\" + right;\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        String[] nodes = data.split(\",\");\n        Queue<String> queue = new ArrayDeque<>(Arrays.asList(nodes));\n        return buildTree(queue);\n    }\n\n    private TreeNode buildTree(Queue<String> queue) {\n        String value = queue.poll();\n        if (value.equals(\"null\")) {\n            return null;\n        }\n        TreeNode root = new TreeNode(Integer.parseInt(value));\n        root.left = buildTree(queue);\n        root.right = buildTree(queue);\n        return root;\n    }\n}\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201190198","body":"## æ€è·¯\nå“ˆå¸Œé…åˆæ·±æœ\n\n## ä»£ç \n```java\nclass Solution {\n    Map<TreeNode, int[]> map = new HashMap<>();\n    \n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        map.put(root, new int[]{0, 0, root.val});\n        dfs(root);\n        List<int[]> list = new ArrayList<>(map.values());\n        Collections.sort(list, (a, b)->{\n            if (a[0] != b[0]) return a[0] - b[0];\n            if (a[1] != b[1]) return a[1] - b[1];\n            return a[2] - b[2];\n        });\n        int n = list.size();\n        List<List<Integer>> ans = new ArrayList<>();\n        for (int i = 0; i < n; ) {\n            int j = i;\n            List<Integer> tmp = new ArrayList<>();\n            while (j < n && list.get(j)[0] == list.get(i)[0]) tmp.add(list.get(j++)[2]);\n            ans.add(tmp);\n            i = j;\n        }\n        return ans;\n    }\n    void dfs(TreeNode root) {\n        if (root == null) return ;\n        int[] info = map.get(root);\n        int col = info[0], row = info[1], val = info[2];\n        if (root.left != null) {\n            map.put(root.left, new int[]{col - 1, row + 1, root.left.val});\n            dfs(root.left);\n        }\n        if (root.right != null) {\n            map.put(root.right, new int[]{col + 1, row + 1, root.right.val});\n            dfs(root.right);\n        }\n    }\n}\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(NlogN)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202889207","body":"## æ€è·¯\nHashMapå­˜æ”¾ç»“æœ\n\n## ä»£ç \n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        if(nums == null || nums.length == 0){\n            return new int[0];\n        }\n        int[] res = new int[2];\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i = 0; i < nums.length; i++){\n            int temp = target - nums[i];\n            if(map.containsKey(temp)){\n                res[0] = map.get(temp);\n                res[1] = i;\n            }\n            map.put(nums[i], i);\n        }\n        return res;\n    }\n}\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1204071524","body":"## æ€è·¯\nå“ˆå¸Œè¡¨å…ˆç»Ÿè®¡å‡ºç°é¢‘ç‡ï¼Œå†ä½¿ç”¨å°æ ¹æ¨è§£å†³TOPKé—®é¢˜\n\n## ä»£ç \n```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        // TOPKé—®é¢˜ï¼šä½¿ç”¨å°é¡¶å †\n        // åˆ›å»ºå°é¡¶å †ï¼Œsizeä¸ºK\n        // æ»¡äº†å°±æŠŠæ ˆé¡¶å¼¹å‡º\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for (int num : nums) {\n            if (map.containsKey(num)) {\n                map.put(num, map.get(num) + 1);\n            } else {\n                map.put(num, 1);\n            }\n        }\n\n        PriorityQueue<Integer> queue = new PriorityQueue<>(new Comparator<Integer>(){\n            @Override\n            public int compare(Integer a, Integer b) {\n                return map.get(a) - map.get(b);\n            }\n        });\n\n        for (Integer key : map.keySet()) {\n            if (queue.size() < k) {\n                queue.add(key);\n            } else if (map.get(key) > map.get(queue.peek())) {\n                queue.remove();\n                queue.add(key);\n            }\n        }\n        int[] res = new int[k];\n        for (int i = 0; i < k; i++) {\n            res[i] = queue.remove();\n        }\n        return res;\n    }\n}\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(NlogK)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205429246","body":"## ä»£ç \n```java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int n = points.length;\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            Map<Integer, Integer> map = new HashMap<>();\n            for (int j = 0; j < n; j++) {\n                if (i == j) continue;\n                int x = points[i][0] - points[j][0], y = points[i][1] - points[j][1];\n                int dist = x * x + y * y;\n                map.put(dist, map.getOrDefault(dist, 0) + 1);\n            }\n            for (int dist : map.keySet()) {\n                int cnt = map.get(dist);\n                ans += cnt * (cnt - 1);\n            }\n        }\n        return ans;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207234428","body":"## æ€è·¯\nåˆ©ç”¨å“ˆå¸Œè¡¨æ¥å¯¹æ¯”wordså‡ºç°å•è¯çš„ä¸ªæ•°å’Œå­—ç¬¦ä¸²ä¸­å­å­—ç¬¦ä¸²å‡ºç°çš„ä¸ªæ•°ï¼Œè‹¥ç›¸åŒåˆ™è®°å½•å½“å‰èµ·å§‹ä½ç½®ã€‚\n\n## ä»£ç \n```java\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        int n = s.length();\n        int m = words.length;\n        int w = words[0].length();\n\n        Map<String, Integer> map = new HashMap<>();\n\n        for (String  word : words) {\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        }\n        List<Integer> ans = new ArrayList<>();\n\n        for (int i = 0; i + m * w <= n; i++) {\n            Map<String, Integer> cur = new HashMap<>();\n            String sub = s.substring(i, i + m * w);\n            for (int j = 0; j < sub.length(); j+=w) {\n                String item = sub.substring(j, j + w);\n                cur.put(item, cur.getOrDefault(item, 0) + 1);\n            }\n            if (cur.equals(map)) {\n                ans.add(i);\n            }\n        }\n        return ans;\n    }\n}\n```\n\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N * words.length * s.length())\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N * s.length())","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207428279","body":"## æ€è·¯\nå‰ç¼€å’Œé…åˆå“ˆå¸Œè¡¨éå†ï¼Œæœ€åæ¯”è¾ƒå–å‡ºæœ€çŸ­çš„å­æ•°ç»„é•¿åº¦ã€‚\n## ä»£ç \n```java\nclass Solution {\n        private int removeSubArrayLength(int[] nums, int k) {\n\t\tint n = nums.length;\n\t\tint[] mod_arr = new int[n];\n\t\tint total_sum = 0;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmod_arr[i] = (nums[i] + k) % k;\n\t\t\ttotal_sum += nums[i];\n\t\t}\n\n\t\tint target_remainder = total_sum % k;\n\t\tif (target_remainder == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\tmap.put(0, -1);\n\t\tint curr_reminder = 0;\n\t\tint res = Integer.MAX_VALUE;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcurr_reminder = (curr_reminder + nums[i] + k) % k;\n\n\t\t\tmap.put(curr_reminder, i);\n\t\t\tint mod = (curr_reminder - target_remainder + k) % k;\n\t\t\tif (map.containsKey(mod)) {\n\t\t\t\tres = Math.min(res, i - map.get(mod));\n\t\t\t}\n\t\t}\n\n\t\tif (res == Integer.MAX_VALUE || res == n) {\n\t\t\tres = -1;\n\t\t}\n\t\treturn res;\n\t}\n}\n\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208263035","body":"## æ€è·¯\nå¿«æ…¢æŒ‡é’ˆ\n\n## ä»£ç \n```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode node1 = head;\n        ListNode node2 = head;\n\n        while (node2 != null && node2.next != null) {\n            node1 = node1.next;\n            node2 = node2.next.next;\n        }\n\n        return node1;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209557560","body":"## æ€è·¯\nåŒæŒ‡é’ˆ\n## ä»£ç \n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int len = nums.length;\n        int j = 0;\n        for (int i = 0; i < len; i++) {\n            if (nums[i] != nums[j]) {\n                nums[++j] = nums[i];\n            }\n        }\n        return j + 1;\n    }\n}\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kerrhl":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185667597","body":"### æ€è·¯\nå‚è€ƒäº†åšçš„ï¼Œå€’ç€å–å–æ¯ä¸ªä½æ•°ç›¸åŠ ï¼Œå•ç‹¬è€ƒè™‘è¿›ä½ï¼ˆæ²¡å¤ªçœ‹æ‡‚é‚£ç§ä¸‰ä¸ªæ”¾åœ¨ä¸€èµ·åŠ çš„ï¼‰\n\n### ä»£ç \n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        ans = []\n        \n        for i in range(len(num)-1, -1, -1):\n            all = num[i] + k % 10\n            k = k // 10\n            if all >= 10:\n                k = k + 1\n            ans.append(all % 10)\n            \n        while k > 0:\n            ans.append(k % 10)\n            k = k // 10\n        return ans[::-1]\n```\n### å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦: O(n)\n\nç©ºé—´å¤æ‚åº¦: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"orangejuz":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185667727","body":"## æ€è·¯\r\nå€’å™æ— è„‘åŠ æ•´æ•°k\r\n## ä»£ç \r\n```python3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        i = 0\r\n        length = len(num)\r\n        carry = k\r\n        while(carry>0):\r\n            if i < length:\r\n                sum = num[-i-1] + carry\r\n                num[-i-1] = sum % 10\r\n                carry = sum // 10\r\n            else:\r\n                num = [carry%10] + num\r\n                carry = carry // 10\r\n            i+=1\r\n        return num\r\n```\r\n### æ—¶é—´å¤æ‚åº¦: O(n)\r\n### ç©ºé—´å¤æ‚åº¦:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186197767","body":"```python3\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        l = r = 0\r\n        n = len(s)\r\n        res = [n] * n\r\n        flag = False  \r\n        while r <= n - 1:\r\n            if s[r] == c:\r\n                res[r] = 0\r\n                while l <= r:\r\n                    res[l] = min(res[l], r - l)\r\n                    l += 1\r\n                r += 1\r\n                flag = True\r\n            else:\r\n                if flag:\r\n                    res[r] = res[r-1] + 1\r\n                r += 1\r\n        return res\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186531817","body":"```python3\r\n\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        self.len = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.len < self.maxSize:\r\n            self.stack.append(x)\r\n            self.len += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.len == 0:\r\n            return -1\r\n        else:\r\n            self.len -= 1\r\n            return self.stack.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(k):\r\n            if i < self.len:\r\n                self.stack[i] += val\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187567839","body":"```python3\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        \r\n        stack, res = [], \"\"\r\n        \r\n        for i in s:\r\n            if i != \"]\":\r\n                stack.append(i)\r\n\r\n            else:\r\n                word = stack.pop()\r\n                words = \"\"\r\n                while word != \"[\":\r\n                    words = word+words\r\n                    word = stack.pop()\r\n                \r\n                multi = stack.pop()\r\n                multi_times = \"\"\r\n                while multi.isnumeric():\r\n                    multi_times = multi + multi_times\r\n                    print(multi_times)\r\n                    if stack and stack[-1].isnumeric(): multi = stack.pop()\r\n                    else: break\r\n\r\n                stack.append(words*int(multi_times))\r\n        \r\n        \r\n        for i in stack: res += i\r\n        return(res)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188968558","body":"```python3\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.L = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.L.append(x)\r\n\r\n    def pop(self) -> int:\r\n        print(self.L)\r\n        return self.L.pop(0)\r\n\r\n    def peek(self) -> int:\r\n        return self.L[0]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        if(len(self.L) == 0):\r\n            return True\r\n        else:\r\n            return False\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191134572","body":"### æ€æƒ³\r\né“¾è¡¨æˆç¯\r\n\r\n```python3\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        tail = head\r\n        if not head or not head.next:\r\n            return head\r\n        count = 1\r\n\r\n        while(tail.next):\r\n            tail = tail.next\r\n            count += 1\r\n    \r\n        if k % count == 0:\r\n            return head\r\n\r\n        #é¦–å°¾ç›¸è¿\r\n        tail.next = head\r\n        k %= count\r\n        for i in range(count - k):\r\n            tail = tail.next\r\n        head = tail.next\r\n        tail.next = None\r\n        return head\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192095418","body":"```python3\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        newNode = head.next\r\n        head.next = self.swapPairs(newNode.next)\r\n        newNode.next = head\r\n        return newNode\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193135979","body":"### æ€æƒ³\r\nå¿«æ…¢æŒ‡é’ˆ\r\n\r\n```python3\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        fast = head\r\n        slow = head\r\n        pre = head\r\n\r\n        if not head:\r\n            return head\r\n        while(fast and fast.next):\r\n            fast = fast.next.next\r\n            pre = slow\r\n            slow = slow.next\r\n        root = TreeNode(slow.val)\r\n        if slow == fast:\r\n            return root\r\n        pre.next = None\r\n        next_head = slow.next\r\n        root.left = self.sortedListToBST(head)\r\n        root.right = self.sortedListToBST(next_head)\r\n        return root\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193284391","body":"```python3\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        if not headA or not headB:\r\n            return None\r\n        \r\n        pointA,pointB = headA,headB\r\n        \r\n        while pointA != pointB:\r\n            if pointA != None:\r\n                pointA = pointA.next\r\n            else:\r\n                pointA = headB\r\n            if pointB != None:\r\n                pointB = pointB.next\r\n            else:\r\n                pointB = headA\r\n        \r\n        return pointA\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194119303","body":"### æ€è·¯\r\nå¿«æ…¢æŒ‡é’ˆ\r\n\r\n```python3\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        fast,slow = head,head\r\n\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            if slow == fast:\r\n                p = head\r\n                q = fast\r\n                while p != q:\r\n                    p = p.next\r\n                    q = q.next\r\n                return p\r\n        return None\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195389537","body":"```python3\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.dic = {}\r\n        self.stack = []\r\n        self.capacity = capacity\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.dic:\r\n            if self.stack:\r\n                self.stack.remove(key)\r\n                self.stack.append(key)\r\n            return self.dic[key]\r\n        else: \r\n            return -1\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.dic: \r\n            self.dic[key] = value\r\n            if self.stack:\r\n                self.stack.remove(key)\r\n                self.stack.append(key)\r\n            return \r\n        if len(self.dic) == self.capacity:\r\n            t = self.stack[0]\r\n            self.dic.pop(t)\r\n            self.stack = self.stack[1:]\r\n            self.dic[key] = value\r\n            self.stack.append(key)\r\n        else:\r\n            self.dic[key] = value\r\n            self.stack.append(key)\r\n\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200149944","body":"```python3\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        stack = [root]\r\n        ans = root.val\r\n        while stack:\r\n            ans = stack[0].val\r\n            n = len(stack)\r\n            for i in range(n):\r\n                node = stack[0]\r\n                del stack[0]\r\n                if node.left:\r\n                    stack.append(node.left)\r\n                if node.right:\r\n                    stack.append(node.right)\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200431159","body":"```python3\r\n# Definition for a binary tree node.\r\n# class TreeNode(object):\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\nclass Codec:\r\n\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        stack = [root]\r\n        res = []\r\n        if not root:\r\n            return \"\"\r\n        Max = 10001\r\n        res.append(root.val)\r\n        while(stack):\r\n            if stack[0].left:\r\n                stack.append(stack[0].left)\r\n                res.append(stack[0].left.val)\r\n            else:\r\n                res.append(Max)\r\n            if stack[0].right:\r\n                stack.append(stack[0].right)\r\n                res.append(stack[0].right.val)\r\n            else:\r\n                res.append(Max)\r\n            stack.pop(0)\r\n        return ','.join([str(i) for i in res])\r\n\r\n        \r\n        \r\n         \r\n        \r\n\r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        if data == \"\":\r\n            return None\r\n        lis = [int(i) for i in data.split(\",\")]\r\n        node = TreeNode(lis[0])\r\n        index = node\r\n        que = [index]\r\n        lis = lis[1:]\r\n        while que:\r\n            if lis[0] != 10001:\r\n                que[0].left = TreeNode(lis[0])\r\n                que.append(que[0].left)\r\n            if lis[1] != 10001:\r\n                que[0].right = TreeNode(lis[1])\r\n                que.append(que[0].right)\r\n            lis = lis[2:]\r\n            que = que[1:]\r\n        return node\r\n\r\n\r\n# Your Codec object will be instantiated and called as such:\r\n# ser = Codec()\r\n# deser = Codec()\r\n# ans = deser.deserialize(ser.serialize(root))\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201107691","body":"```python3\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\r\n        dic = collections.defaultdict(list)\r\n\r\n        queue = [(0, 0, root)]\r\n        while queue:\r\n            n_q = len(queue)\r\n            for _ in range(n_q):\r\n                i, j, node = queue.pop(0)\r\n                dic[j].append((i, node.val))\r\n                if node.left:\r\n                    queue.append((i + 1, j - 1, node.left))\r\n                if node.right:\r\n                    queue.append((i + 1, j + 1, node.right))\r\n            \r\n        res = []\r\n        arr = sorted(dic.keys())\r\n        for k in arr:\r\n            tmp = sorted(dic[k])\r\n            res.append([v[1] for v in tmp])\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202417708","body":"```python3\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        dic = {}\r\n        for i, n in enumerate(nums):\r\n            temp = target - n\r\n            if temp in dic:\r\n                return [dic[temp], i]\r\n            else:\r\n                dic[n] = i\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203800581","body":"```python3\r\nclass Solution(object):\r\n    def topKFrequent(self, nums, k):\r\n        if len(nums) == 1:\r\n            return [k]\r\n        v1_dict = {}\r\n        for i in nums:\r\n            v1_dict[i] = v1_dict.get(i, 0) + 1\r\n        data = (sorted(v1_dict.items(), key = lambda x:x[1], reverse=True))[:k]\r\n        return [v[0] for v in data]\r\n\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207384749","body":"```python3\r\nclass Solution:\r\n    def solve(self, nums, k):\r\n        target = sum(nums)%k\r\n        \r\n        if target == 0:\r\n            return 0\r\n        \r\n        dict1, running_sum, min_len = {0:-1}, 0, len(nums)\r\n        \r\n        for i in range(len(nums)):\r\n            running_sum += nums[i]\r\n            \r\n            if (running_sum - target)%k in dict1:\r\n                min_len = min(min_len, i - dict1[(running_sum - target)%k])\r\n                \r\n            dict1[running_sum%k] = i\r\n            \r\n        return min_len if min_len != len(nums) else -1\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207794956","body":"```python3\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def middleNode(self, head: ListNode) -> ListNode:\r\n        if head.next == None:\r\n            return  head\r\n        fast = head\r\n        slow = head\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n        return slow\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209242197","body":"```python3\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        n = len(nums)\r\n        j = 0\r\n        for i in range(n):\r\n            if nums[i] != nums[j]:\r\n                j += 1\r\n                nums[j] = nums[i]\r\n        return j + 1\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flyzenr":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185668901","body":"```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        l = len(num)\r\n        list_num = 0\r\n        for i in range(l):\r\n            list_num = list_num + num[i]*10^(l-(i-1))\r\n            print(num[i]*10^(l-(i-1)))\r\n        list2_num = list_num + k\r\n        str1 = str(list2_num)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186216337","body":"### Code\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        l = len(s)\n        cIndex = []\n        for i in range(l):\n            if s[i] == c:\n                cIndex.append(i)\n        lenlist = [[] for i in range(l)]\n        for index, j in enumerate(s):\n            if j == c:\n                lenlist[index] = 0\n            else:\n                short = l\n                for k in range(len(cIndex)):\n                    short = min(short, abs(index-cIndex[k]))\n                lenlist[index] = short\n        return lenlist\n\n```\n### å¤æ‚åº¦\n- æ—¶é—´ï¼šO(l*k), læ˜¯sçš„é•¿åº¦ï¼Œkæ˜¯cçš„å‡ºç°çš„æ¬¡æ•°\n- ç©ºé—´ï¼šO(l)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186549624","body":"### æ€è·¯\r\nincrementå¹¶ä¸æå‰é€ å¥½maxSizeé•¿åº¦ï¼Œè€Œæ˜¯æ ¹å½“å‰æ ˆé•¿åº¦åŒæ­¥å¢åŠ é•¿åº¦ï¼Œçœä¸€ç‚¹ç©ºé—´ã€‚\r\n\r\n### Code\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        self.size = 0\r\n        self.incrementals = []\r\n        \r\n    def push(self, x: int) -> None:\r\n        if(self.size < self.maxSize):\r\n            self.stack.append(x)\r\n            self.incrementals.append(0)\r\n            self.size += 1\r\n\r\n    def pop(self) -> int:\r\n        if(self.size == 0):\r\n            return -1\r\n        self.size -= 1\r\n        if(self.size >= 1):\r\n            self.incrementals[-2] += self.incrementals[-1]\r\n        return self.stack.pop() + self.incrementals.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if self.incrementals:\r\n            self.incrementals[min(k, self.size) - 1] += val\r\n```\r\n### å¤æ‚åº¦åˆ†æ\r\n- æ—¶é—´å¤æ‚åº¦ï¼šå‡ä¸ºO(1)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(size)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187659729","body":"### æ€è·¯\nè¿™ä¸ªè§£ç ä¸­æ¶‰åŠåˆ°äº† [[]]ä¸­æ‹¬å·åµŒå¥—ï¼Œæ­£å¥½å¯ä»¥åˆ©ç”¨æ ˆä¸­å…ˆè¿›åå‡ºï¼Œåè¿›å…ˆå‡ºçš„ç‰¹ç‚¹ã€‚\n### Code\n```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        l = len(s)\n        stack,res,multi = [],\"\",0\n        for c in s:\n            if c == '[':\n                stack.append([res,multi])\n                res,multi = \"\",0\n            elif c == ']':\n                last_res,cur_multi = stack.pop()\n                res = last_res + cur_multi*res\n            elif '0' <= c <= '9':\n                multi = multi*10 + int(c)\n            else:\n                res += c\n        return res\n```\n### å¤æ‚åº¦\n- æ—¶é—´ï¼šO(n)\n- ç©ºé—´ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189217061","body":"### Code\n```\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x):\n        self.stack1.append(x)\n\n    def pop(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self):\n        return not self.stack1 and not self.stack2\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190459002","body":"### Code\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            # é€’å¢æ ˆ\r\n            if not stack or stack[-1] <= num:\r\n                stack.append(num)\r\n            else:\r\n                cur_max = stack.pop()\r\n                while stack and stack[-1] > num:\r\n                    stack.pop()\r\n                stack.append(cur_max)\r\n        return len(stack)\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191640245","body":"### Code\r\n```\r\nclass Solution:\r\n    def rotateRight(self, head, k):\r\n        if not head or not head.next: return head\r\n        # æ±‚é“¾è¡¨é•¿åº¦\r\n        _len = 0\r\n        cur = head\r\n        while cur:\r\n            _len += 1\r\n            cur = cur.next\r\n        # å¯¹é•¿åº¦å–æ¨¡\r\n        k %= _len\r\n        if k == 0: return head\r\n        # è®© fast å…ˆå‘åèµ° k æ­¥\r\n        fast, slow = head, head\r\n        while k:\r\n            fast = fast.next\r\n            k -= 1\r\n        # æ­¤æ—¶ slow å’Œ fast ä¹‹é—´çš„è·ç¦»æ˜¯ kï¼›fast æŒ‡å‘ç¬¬ k+1 ä¸ªèŠ‚ç‚¹\r\n        # å½“ fast.next ä¸ºç©ºæ—¶ï¼Œfast æŒ‡å‘é“¾è¡¨æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œslow æŒ‡å‘å€’æ•°ç¬¬ k + 1 ä¸ªèŠ‚ç‚¹\r\n        while fast.next:\r\n            fast = fast.next\r\n            slow = slow.next\r\n        # newHead æ˜¯å€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹ï¼Œå³æ–°é“¾è¡¨çš„å¤´\r\n        newHead = slow.next\r\n        # è®©å€’æ•°ç¬¬ k + 1 ä¸ªèŠ‚ç‚¹ å’Œ å€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹æ–­å¼€\r\n        slow.next = None\r\n        # è®©æœ€åä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘åŸå§‹é“¾è¡¨çš„å¤´\r\n        fast.next = head\r\n        return newHead\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192794192","body":"### Code\r\n```\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        thead = ListNode(-1)\r\n        thead.next = head\r\n        c = thead\r\n        while c.next and c.next.next:\r\n            a, b=c.next, c.next.next\r\n            c.next, a.next = b, b.next\r\n            b.next = a\r\n            c = c.next.next\r\n        return thead.next\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1196931086","body":"### Code\r\n```\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        def findmid(head, tail):\r\n            slow = head\r\n            fast = head\r\n            while fast != tail and fast.next!= tail :\r\n                slow = slow.next\r\n                fast = fast.next.next\r\n            return slow\r\n        \r\n        def helper(head, tail):\r\n            if  head == tail: return \r\n            node = findmid(head, tail)\r\n            root = TreeNode(node.val)\r\n            root.left = helper(head, node)\r\n            root.right = helper(node.next, tail)\r\n            return root\r\n            \r\n        return helper(head, None)\r\n            \r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1196935783","body":"### Code \r\n```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        A, B = headA, headB\r\n        while A != B:\r\n            A = A.next if A else headB\r\n            B = B.next if B else headA\r\n        return A\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1196939806","body":"### Code\r\n```\r\nclass Solution(object):\r\n    def detectCycle(self, head):\r\n        fast, slow = head, head\r\n        while True:\r\n            if not (fast and fast.next): return\r\n            fast, slow = fast.next.next, slow.next\r\n            if fast == slow: break\r\n        fast = head\r\n        while fast != slow:\r\n            fast, slow = fast.next, slow.next\r\n        return fast\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1196942499","body":"### Code\r\n```\r\nclass ListNode:\r\n    def __init__(self, key=None, value=None):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = None\r\n        self.next = None\r\n\r\n\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.hashmap = {}\r\n        # æ–°å»ºä¸¤ä¸ªèŠ‚ç‚¹ head å’Œ tail\r\n        self.head = ListNode()\r\n        self.tail = ListNode()\r\n        # åˆå§‹åŒ–é“¾è¡¨ä¸º head <-> tail\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n\r\n    # å› ä¸ºgetä¸putæ“ä½œéƒ½å¯èƒ½éœ€è¦å°†åŒå‘é“¾è¡¨ä¸­çš„æŸä¸ªèŠ‚ç‚¹ç§»åˆ°æœ«å°¾ï¼Œæ‰€ä»¥å®šä¹‰ä¸€ä¸ªæ–¹æ³•\r\n    def move_node_to_tail(self, key):\r\n            # å…ˆå°†å“ˆå¸Œè¡¨keyæŒ‡å‘çš„èŠ‚ç‚¹æ‹å‡ºæ¥ï¼Œä¸ºäº†ç®€æ´èµ·ånode\r\n            #      hashmap[key]                               hashmap[key]\r\n            #           |                                          |\r\n            #           V              -->                         V\r\n            # prev <-> node <-> next         pre <-> next   ...   node\r\n            node = self.hashmap[key]\r\n            node.prev.next = node.next\r\n            node.next.prev = node.prev\r\n            # ä¹‹åå°†nodeæ’å…¥åˆ°å°¾èŠ‚ç‚¹å‰\r\n            #                 hashmap[key]                 hashmap[key]\r\n            #                      |                            |\r\n            #                      V        -->                 V\r\n            # prev <-> tail  ...  node                prev <-> node <-> tail\r\n            node.prev = self.tail.prev\r\n            node.next = self.tail\r\n            self.tail.prev.next = node\r\n            self.tail.prev = node\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.hashmap:\r\n            # å¦‚æœå·²ç»åœ¨é“¾è¡¨ä¸­äº†ä¹…æŠŠå®ƒç§»åˆ°æœ«å°¾ï¼ˆå˜æˆæœ€æ–°è®¿é—®çš„ï¼‰\r\n            self.move_node_to_tail(key)\r\n        res = self.hashmap.get(key, -1)\r\n        if res == -1:\r\n            return res\r\n        else:\r\n            return res.value\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.hashmap:\r\n            # å¦‚æœkeyæœ¬èº«å·²ç»åœ¨å“ˆå¸Œè¡¨ä¸­äº†å°±ä¸éœ€è¦åœ¨é“¾è¡¨ä¸­åŠ å…¥æ–°çš„èŠ‚ç‚¹\r\n            # ä½†æ˜¯éœ€è¦æ›´æ–°å­—å…¸è¯¥å€¼å¯¹åº”èŠ‚ç‚¹çš„value\r\n            self.hashmap[key].value = value\r\n            # ä¹‹åå°†è¯¥èŠ‚ç‚¹ç§»åˆ°æœ«å°¾\r\n            self.move_node_to_tail(key)\r\n        else:\r\n            if len(self.hashmap) == self.capacity:\r\n                # å»æ‰å“ˆå¸Œè¡¨å¯¹åº”é¡¹\r\n                self.hashmap.pop(self.head.next.key)\r\n                # å»æ‰æœ€ä¹…æ²¡æœ‰è¢«è®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼Œå³å¤´èŠ‚ç‚¹ä¹‹åçš„èŠ‚ç‚¹\r\n                self.head.next = self.head.next.next\r\n                self.head.next.prev = self.head\r\n            # å¦‚æœä¸åœ¨çš„è¯å°±æ’å…¥åˆ°å°¾èŠ‚ç‚¹å‰\r\n            new = ListNode(key, value)\r\n            self.hashmap[key] = new\r\n            new.prev = self.tail.prev\r\n            new.next = self.tail\r\n            self.tail.prev.next = new\r\n            self.tail.prev = new\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196927093","body":"### Code\r\n```\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        # èŠ‚ç‚¹ä¸ºç©ºï¼Œé«˜åº¦ä¸º 0\r\n        if root == None:\r\n            return 0\r\n\r\n        # é€’å½’è®¡ç®—å·¦å­æ ‘çš„æœ€å¤§æ·±åº¦\r\n        leftHeight = self.maxDepth(root.left)\r\n        # é€’å½’è®¡ç®—å³å­æ ‘çš„æœ€å¤§æ·±åº¦\r\n        rightHeight = self.maxDepth(root.right)\r\n\r\n        # äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ = å­æ ‘çš„æœ€å¤§æ·±åº¦ + 1ï¼ˆ1 æ˜¯æ ¹èŠ‚ç‚¹ï¼‰\r\n        return max(leftHeight, rightHeight) + 1\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200238197","body":"```\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        curVal = curHeight = 0\r\n        def dfs(node: Optional[TreeNode], height: int) -> None:\r\n            if node is None:\r\n                return\r\n            height += 1\r\n            dfs(node.left, height)\r\n            dfs(node.right, height)\r\n            nonlocal curVal, curHeight\r\n            if height > curHeight:\r\n                curHeight = height\r\n                curVal = node.val\r\n        dfs(root, 0)\r\n        return curVal\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200451048","body":"```\r\npublic class Codec {\r\n\r\n    // Encodes a tree to a single string.\r\n    public String serialize(TreeNode root) {\r\n        if(root == null){\r\n            return \"\";\r\n        }\r\n        StringBuilder res = new StringBuilder();\r\n        res.append(\"[\");\r\n        Queue<TreeNode> queue = new LinkedList<>();\r\n        queue.offer(root);\r\n        while(!queue.isEmpty()){\r\n            TreeNode node = queue.poll();\r\n            if(node != null){\r\n                res.append(\"\" + node.val);\r\n                queue.offer(node.left);\r\n                queue.offer(node.right);\r\n            }else{\r\n                res.append(\"null\");\r\n            }\r\n            res.append(\",\");\r\n        }\r\n        res.append(\"]\");\r\n        return res.toString();\r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    public TreeNode deserialize(String data) {\r\n        if(data == \"\"){\r\n            return null;\r\n        }\r\n        String[] dataList = data.substring(1, data.length() - 1).split(\",\");\r\n        TreeNode root = new TreeNode(Integer.parseInt(dataList[0]));\r\n        Queue<TreeNode> queue = new LinkedList<>();\r\n        queue.offer(root);\r\n        int i = 1;\r\n        while(!queue.isEmpty()){\r\n            TreeNode node = queue.poll();\r\n            if(!\"null\".equals(dataList[i])){\r\n                node.left = new TreeNode(Integer.parseInt(dataList[i]));\r\n                queue.offer(node.left);\r\n            }\r\n            i++;\r\n            if(!\"null\".equals(dataList[i])){\r\n                node.right = new TreeNode(Integer.parseInt(dataList[i]));\r\n                queue.offer(node.right);\r\n            }\r\n            i++;\r\n        }\r\n        return root;\r\n    }\r\n}\r\n\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202866091","body":"\n```\ndef twoSum(nums, target):\n    lens = len(nums)\n    j=-1\n    for i in range(lens):\n        if (target - nums[i]) in nums:\n            if (nums.count(target - nums[i]) == 1)&(target - nums[i] == nums[i]):#å¦‚æœnum2=num1,ä¸”numsä¸­åªå‡ºç°äº†ä¸€æ¬¡ï¼Œè¯´æ˜æ‰¾åˆ°æ˜¯num1æœ¬èº«ã€‚\n                continue\n            else:\n                j = nums.index(target - nums[i],i+1) #index(x,i+1)æ˜¯ä»num1åçš„åºåˆ—åæ‰¾num2                \n                break\n    if j>0:\n        return [i,j]\n    else:\n        return []\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"c1f2h3":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185673058","body":"# æ€è·¯\n\nå†™äº†ä¸€ä¸‹ï¼Œæäº¤ä¸å¯¹ï¼Œåº”è¯¥æ˜¯æ•°æ®æº¢å‡ºäº†ï¼Œç›´æ¥å˜ä¸ºä¸¤ä¸ªæ•°ç›¸åŠ çš„åŠæ³•ä¸å¤ªè¡Œ\nè€ƒè™‘ä¸€ç§åšæ³•ï¼Œå°†å…¶å˜ä¸º num æ•°ç»„ä¸­çš„å…ƒç´ ä¾æ¬¡ä¸ k ç›¸åŠ ï¼Œç¬¬ä¸€æ­¥å…ˆæœ«ä½ä¸ k ç›¸åŠ ï¼Œç»“æœå¯¹ 10 å–ä½™ä¸ä¸‹ä¸€ä½ç›¸åŠ ï¼Œå½“å‰ä½ç½®ä¿ç•™å¯¹ 10 å–ä½™\næœ€åè€ƒè™‘æ˜¯å¦æœ‰æº¢å‡ºä½ï¼Œç„¶åæ·»åŠ åˆ° 0 ä½ç½®ä¸Š\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186212302","body":"# æ•°ç»„çš„éå†\næ ¹æ®é¢˜æ„ï¼Œå•è¯ä¸­ä»»ä¸€å­—ç¬¦ä¸ç›®æ ‡å­—ç¬¦ target è·ç¦»çš„æœ€å°å€¼å¿…ç„¶ä¸ºå…¶ä¸å‰ 1 ä¸ª target å’Œåä¸€ä¸ª target ä¸­è¾ƒå°çš„å­˜åœ¨  \nå› æ­¤é€šè¿‡ç®€åŒ–é¢˜æ„ï¼Œå¯ä»¥å‰åå„éå†ä¸€æ¬¡æ±‚è§£  \nç¬¬ä¸€æ¬¡ä»å·¦è‡³å³ï¼Œç›®æ ‡æ˜¯æ‰¾åˆ°è·ç¦»å·¦è¾¹ target çš„æœ€å°è·ç¦»\nç¬¬äºŒæ¬¡ä»å³è‡³å·¦ï¼Œç›®æ ‡æ˜¯æ‰¾åˆ°è·ç¦»å³è¾¹ target çš„æœ€å°è·ç¦»\n\nä»£ç å¦‚ä¸‹ï¼š\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] dist = new int[len];\n        Arrays.fill(dist, len+1);\n        for(int i=0, j=-1; i<len; ++i){\n            if(s.charAt(i)==c) j=i;\n            if(j!=-1) dist[i]= i-j;\n        }\n        for(int i=len-1, j=-1; i>=0; i--){\n            if(s.charAt(i)==c) j=i;\n            if(j!=-1) dist[i] = Math.min(dist[i], j-i);\n        }\n        return dist;\n    }\n}\n```\næ—¶é—´å¤æ‚åº¦ï¼šéå†ä¸¤æ¬¡æ•°ç»„ï¼Œæ•…ä¸º O(N) \nç©ºé—´å¤æ‚åº¦ï¼šè¾…åŠ©ç©ºé—´ä½¿ç”¨æ•°ç»„é•¿åº¦ä¸ºå•è¯é•¿åº¦ï¼Œæ•…ä¸º O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186541483","body":"ç®€å•æ¨¡æ‹Ÿé¢˜ï¼Œé€‰æ‹©ç”¨ List æ¥å®ç°ï¼Œå…¶å®ç”¨æ•°ç»„åº”è¯¥ä¹Ÿä¸€æ ·ï¼Œåšé•¿åº¦åˆ¤æ–­å³å¯\n```java\nclass CustomStack {\n\n    int maxSize;\n    List<Integer> stack = new ArrayList<>();\n    public CustomStack(int _maxSize) {\n        maxSize = _maxSize;\n    }\n    \n    public void push(int x) {\n        if(stack.size()==maxSize) return;\n        stack.add(x);\n    }\n    \n    public int pop() {\n        if(stack.size()==0) return -1;\n        int res = stack.get(stack.size()-1);\n        stack.remove(stack.size()-1);\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        int n = k>stack.size()?stack.size():k;\n        for(int i=0; i<n; ++i)\n            stack.set(i, stack.get(i)+val);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187637907","body":"ä½¿ç”¨ä¸¤ä¸ªæ ˆï¼Œä¸€ä¸ªè®°å½•æ•°å­—ï¼Œä¸€ä¸ªè®°å½•å­—ç¬¦\nå½“æ£€æµ‹åˆ°\"[\"æ—¶ï¼Œå°†æ•°å­—å…¥æ ˆ\nå½“æ£€æµ‹åˆ°â€œ]â€æ—¶ï¼Œå°†æ•°å­—å‡ºæ ˆï¼Œå¹¶ä¸å½“å‰è®°å½•çš„ str è¿›è¡Œç»„åˆè¿½åŠ å³å¯\n```java\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        LinkedList<Integer> stack_multi = new LinkedList<>();\n        LinkedList<String> stack_res = new LinkedList<>();\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                // åˆç†çš„å­—ç¬¦ä¸²å‰å¿…ç„¶æ˜¯æ•°å­—ï¼Œå› æ­¤æ­¤å¤„å°†æ•°å­—å…¥æ ˆ\n                stack_multi.addLast(multi);\n                // å°†ä¹‹å‰çš„å­—ç¬¦å…¥æ ˆå­˜å‚¨\n                stack_res.addLast(res.toString());\n                // é‡æ–°è®°å½•\n                multi = 0;\n                res = new StringBuilder();\n            }\n            else if(c == ']') {\n                // å­—ç¬¦ä¸²ç»“æŸï¼Œéœ€è¦æ ¹æ®æ•°å­—æ ˆå’Œ res ç»„åˆæˆç»“æœ\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = stack_multi.removeLast();\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\n                // å°†å­—ç¬¦è¿½åŠ \n                res = new StringBuilder(stack_res.removeLast() + tmp);\n            }\n            // åˆ¤æ–­æ•°å­—éƒ¨åˆ†\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\n            else res.append(c);\n        }\n        return res.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189180325","body":"æ€è·¯ï¼šç±»ä¼¼ä¸¤ä¸ªç«¹ç­’å€’è±†å­ï¼Œæ–°æ¥çš„åŠ å…¥åˆ°stack1é‡Œï¼Œæƒ³å–ç¬¬ä¸€ä¸ªå°±æŠŠstack1çš„å€’è¿›stack2é‡Œï¼Œå°±å¯ä»¥å–åˆ°ç¬¬ä¸€ä¸ªï¼Œç„¶åæ”¾å›å»\n```java\nclass MyQueue {\n\n    Stack q1, q2;\n\n    public MyQueue() {\n        q1 = new Stack();\n        q2 = new Stack();\n    }\n    \n    public void push(int x) {\n        q1.push(x);\n    }\n    \n    public int pop() {\n        while(!q1.empty())\n            q2.push(q1.pop());\n        int res = (int)q2.pop();\n        while(!q2.empty())\n            q1.push(q2.pop());\n        return res;\n    }\n    \n    public int peek() {\n        while(!q1.empty())\n            q2.push(q1.pop());\n        int res = (int)q2.peek();\n        while(!q2.empty())\n            q1.push(q2.pop());\n        return res;\n    }\n    \n    public boolean empty() {\n        return q1.empty();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190443684","body":"è‡ªå·±æ²¡åšå‡ºæ¥ï¼Œçœ‹äº†é¢˜è§£ç†è§£äº†\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr) {\n            if(!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\n                stack.addLast(head);\n            }\n            else stack.addLast(num);\n        }\n        return stack.size();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191602282","body":"å·æ‡’å†™äº†ä¸ªç¬¨æ–¹æ³•ï¼Œæ²¡å»åŠ¨é“¾è¡¨ï¼ŒæŠŠæ•°å­—ä¾æ¬¡å¾€åç§»åŠ¨äº†\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        int cnt = 0;\n        ListNode cur = head;\n        List<Integer> nums = new ArrayList<>();\n        while(cur!=null){\n            cnt++;\n            nums.add(cur.val);\n            cur = cur.next;\n        }\n        if(cnt==0||k==0) return head;\n        int move = k % cnt;\n        for(int i=0; i<move; ++i){\n            int temp = nums.get(cnt-1);\n            nums.remove(cnt-1);\n            nums.add(0, temp);\n        }\n        ListNode pre = new ListNode(0, head);\n        for(int i=0; i<cnt; ++i){\n            head.val = nums.get(i);\n            head = head.next;\n        }\n\n        return pre.next;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192673247","body":"ç”»ä¸€ä¸ªè¾…åŠ©å›¾ï¼Œå…¶å®å¾ˆå¥½ç†è§£çš„\n```java\nclass Solution {\n    public static ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null)\n            return head;\n        ListNode newHead = new ListNode(0);\n        newHead.next = head;\n        ListNode pre = newHead;\n        ListNode mid = head;\n        ListNode end = head.next;\n        while (mid != null && end != null) {\n            // æ”¹å˜èŠ‚ç‚¹è¿æ¥å…³ç³»\n            pre.next = end;\n            mid.next = end.next;\n            end.next = mid;\n\n            // å‡†å¤‡ä¸‹ä¸€è½®\n            pre = mid;\n            mid = (mid.next != null) ? mid.next : null;\n            end = (mid != null && mid.next != null) ? mid.next : null;\n        }\n        return newHead.next;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193145266","body":"```java\nclass Solution {\n    private ListNode inOrderNode = null;\n    public TreeNode sortedListToBST(ListNode head) {\n        //è§£é¢˜æ€è·¯ï¼šå‡åºé“¾è¡¨æ˜¯ä¸­åºéå†çš„ç»“æœï¼›ä¸­åºæ˜¯å·¦æ ¹å³ï¼Œé¢˜ç›®è¦æ±‚å¹³è¡¡äºŒå‰æ ‘ï¼Œé‚£ä¹ˆæ ¹èŠ‚ç‚¹è¦é€‰æ‹©ä¸­é—´ä½ç½®ï¼›\n        inOrderNode = head;\n        int n = 0;\n        while(inOrderNode != null){\n            inOrderNode = inOrderNode.next;\n            n++;\n        }\n        inOrderNode = head;\n        return toBst(0, n - 1);\n    }\n\n    private TreeNode toBst(int start, int end){\n        if(start > end){\n            return null;\n        }\n        //æ‰¾åˆ°æ ¹èŠ‚ç‚¹ä¸ºæ­¢\n        int mid = (start + end)>>1;\n        TreeNode root = new TreeNode();\n        //å·¦å­æ ‘\n        root.left = toBst(start, mid - 1);\n        //ä¸­åºéå†ï¼Œæ ¹èŠ‚ç‚¹å€¼å¡«å……å½“å‰é“¾è¡¨å€¼\n        root.val = inOrderNode.val;\n        inOrderNode = inOrderNode.next;\n        //å³å­æ ‘\n        root.right = toBst(mid + 1, end);\n        return root;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193346142","body":"ä½¿ç”¨äº†æœ€ç®€å•çš„æ–¹æ³•\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Set<ListNode> visited = new HashSet<ListNode>();\n        ListNode temp = headA;\n        while (temp != null) {\n            visited.add(temp);\n            temp = temp.next;\n        }\n        temp = headB;\n        while (temp != null) {\n            if (visited.contains(temp)) {\n                return temp;\n            }\n            temp = temp.next;\n        }\n        return null;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194188246","body":"```java\npublic class Solution {\n    /*\n     *  å‰‘æŒ‡offeré‡Œé¢çš„ç»å…¸é¢˜ç›®ï¼Œå®šä¹‰ä¸¤ä¸ªæŒ‡é’ˆï¼Œä¸€å¿«ä¸€æ…¢ï¼Œå¿«æŒ‡é’ˆæ¯æ¬¡èµ°2æ­¥ï¼Œæ…¢æŒ‡é’ˆæ¯æ¬¡èµ°1æ­¥\n     *  å¦‚æœå­˜åœ¨ç¯ï¼Œåˆ™ä¸¤æŒ‡é’ˆå¿…ç„¶ç›¸é‡ï¼Œå›°éš¾ç‚¹åœ¨äºè¯æ˜ç¯çš„å­˜åœ¨åï¼Œå¦‚ä½•æ±‚è§£ç¯çš„å…¥å£\n     */\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while(fast!=null && fast.next!=null){\n            slow = slow.next;\n            fast = fast.next.next;\n            if(slow == fast){\n                ListNode l1 = head;\n                ListNode l2 = slow;\n                while(l1!=l2){\n                    l1 = l1.next;\n                    l2 = l2.next;\n                }\n                return l2;\n            }\n        }\n        return null;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195652555","body":"O(1)æ—¶é—´å¤æ‚åº¦çš„æš‚æ—¶åšä¸å‡ºæ¥ï¼Œå…ˆå†™ä¸€ä¸ªå¤æ‚çš„æäº¤ï¼Œåç»­åœ¨è¿‡Oï¼ˆ1ï¼‰çš„\n```java\nclass LRUCache {\n    int capacity;\n    int cur;\n    Map<Integer, Integer> map;\n    List<Integer> list;\n    public LRUCache(int _capacity) {\n        // ä½¿ç”¨HashMapæ¥è®°å½•é”®å€¼å¯¹ï¼Œä½¿ç”¨Listæ¥è®°å½•ä½¿ç”¨é¢‘ç‡\n        capacity = _capacity;\n        cur = 0;\n        map = new HashMap<>();\n        list = new ArrayList<>();\n    }\n    \n    public int get(int key) {\n        int value = map.getOrDefault(key, -1);\n        if(value != -1){\n            for(int i=0; i<list.size(); ++i){\n                // è‹¥è¢«ä½¿ç”¨åˆ™æ›´æ–°ä½ç½®åˆ°åé¢\n                if(list.get(i)==value){\n                    list.remove(i);\n                    list.add(value);\n                    break;\n                }\n            }\n        }\n        return value;\n    }\n    \n    public void put(int key, int value) {\n        // è‹¥ç¼“å­˜å·²æ»¡\n        if(cur>=capacity){\n            // åˆ é™¤listä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼ŒåŠå…¶å¯¹åº”çš„é”®å€¼å¯¹\n            map.remove(list.get(0));\n            list.remove(0);\n        }else{\n            cur++;\n        }\n        if(!map.containsKey(key))\n            list.add(key);\n        map.put(key, value);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196904678","body":"```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root==null)\n            return 0;\n        int left = 1 + maxDepth(root.left);\n        int right = 1 + maxDepth(root.right);\n        \n        return Math.max(left, right);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198311386","body":"```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null) \n            return true;\n        if(p == null || q == null) \n            return false;\n        if(p.val != q.val) \n            return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200449753","body":"```java\npublic class Codec {\n\n    public String serialize(TreeNode root) {      //ç”¨StringBuilder\n        StringBuilder res = ser_help(root, new StringBuilder());\n        return res.toString();\n    }\n    \n    public StringBuilder ser_help(TreeNode root, StringBuilder str){\n        if(null == root){\n            str.append(\"null,\");\n            return str;\n        }\n        str.append(root.val); \n        str.append(\",\");\n        str = ser_help(root.left, str);\n        str = ser_help(root.right, str);\n        return str;\n    }\n\n    public TreeNode deserialize(String data) {\n        String[] str_word = data.split(\",\");\n        List<String> list_word = new LinkedList<String>(Arrays.asList(str_word));\n        return deser_help(list_word);\n    }\n    \n    public TreeNode deser_help(List<String> li){\n        if(li.get(0).equals(\"null\")){\n            li.remove(0);\n            return null;\n        }\n        TreeNode res = new TreeNode(Integer.valueOf(li.get(0)));\n        li.remove(0);\n        res.left = deser_help(li);\n        res.right = deser_help(li);\n        return res;\n    }\n}\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205441442","body":"```java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int n = points.length;\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            Map<Integer, Integer> map = new HashMap<>();\n            for (int j = 0; j < n; j++) {\n                if (i == j) continue;\n                int x = points[i][0] - points[j][0], y = points[i][1] - points[j][1];\n                int dist = x * x + y * y;\n                map.put(dist, map.getOrDefault(dist, 0) + 1);\n            }\n            for (int dist : map.keySet()) {\n                int cnt = map.get(dist);\n                ans += cnt * (cnt - 1);\n            }\n        }\n        return ans;\n    }\n}\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208312365","body":"æ€è·¯ï¼šå®šä¹‰ä¸¤ä¸ªæŒ‡é’ˆï¼Œ1å¿«1æ…¢ï¼Œå¿«æŒ‡é’ˆæ¯æ¬¡èµ°ä¸¤æ­¥ï¼Œæ…¢æŒ‡é’ˆæ¯æ¬¡èµ°ä¸€æ­¥\nå½“Nä¸ºå¶æ•°æ—¶ï¼šfastæŒ‡é’ˆèµ°åˆ°æœ€åä¸€æ­¥æ—¶æŒ‡å‘ç»“å°¾çš„nullï¼ŒslowæŒ‡é’ˆä¸ºç¬¬äºŒä¸ªä¸­é—´èŠ‚ç‚¹\nå½“Nä¸ºå¥‡æ•°æ—¶ï¼šfastæŒ‡é’ˆèµ°åˆ°é“¾è¡¨çš„å°¾éƒ¨ï¼Œslowä½äºä¸­é—´\n```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while(fast!=null && fast.next!=null){\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209548659","body":"```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int n = nums.length;\n        int len = 1;\n        int first = 0;\n        int second = 1;\n        while(first<n&&second<n){\n            // åœ¨ä¸è¶Šç•Œçš„æƒ…å†µä¸‹ï¼Œä¸æ–­å¯»æ‰¾ä¸‹ä¸€ä¸ªä¸é‡å¤æ•°æ®\n            while(second<n&&nums[first]==nums[second])\n                ++second;\n            // è‹¥æ‰¾åˆ°\n            if(second<n){\n                // æ›´æ–°æ•°æ®\n                nums[++first] = nums[second];\n                ++len;\n            }else {\n                break;\n            }\n        }\n        return len;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dlm001128":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185673085","body":"class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> tmp;\n        while(k){\n            tmp.push_back(k % 10);\n            k /= 10;\n        }\n        reverse(num.begin(), num.end());\n        vector<int> res;\n        int t = 0;\n        int i = 0, j = 0;\n        for(; i < num.size() && j < tmp.size(); i++, j++){\n            res.push_back((num[i] + tmp[j] + t) % 10);\n            t = (num[i] + tmp[j] + t) / 10;\n        }\n        while(i < num.size()){\n            res.push_back((num[i] + t) % 10);\n            t = (num[i] + t) / 10;\n            i++;\n        }\n        while(j < tmp.size()){\n            res.push_back((tmp[j] + t) % 10);\n            t = (tmp[j] + t) / 10;\n            j++;\n        }\n        if(1 == t){\n            res.push_back(t);\n        }\n        int n = res.size() - 1;\n        while(0 == res[n--]){\n            res.pop_back();\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuxy94":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185673838","body":"## æ€è·¯\r\nä»ä½ä½åˆ°é«˜ä½ç›¸åŠ ï¼Œ åˆ©ç”¨carryè¿›ä½\r\n\r\n## ä»£ç \r\n```python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        carry = 0\r\n        for i in range(len(num) - 1, -1, -1):\r\n            num[i], carry = (carry + num[i] + k % 10) % 10, (carry + num[i] + k % 10) // 10\r\n            k //= 10\r\n        B = []\r\n        carry = carry + k\r\n        while carry:\r\n            B = [(carry) % 10] + B\r\n            carry //= 10\r\n        return B + num\r\n```\r\n\r\n## å¤æ‚åº¦åˆ†æ\r\næ—¶é—´å¤æ‚åº¦ï¼š O(n)\r\nç©ºé—´å¤æ‚åº¦ï¼š O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186224694","body":"## æ€è·¯\nè´ªå¿ƒç®—æ³•ï¼šå…ˆä»å·¦å¾€å³ï¼Œå†ä»å³å¾€å·¦ï¼Œæœ€åè®¡ç®—æœ€çŸ­è·ç¦»ã€‚\n\n## ä»£ç \n```python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        n = len(s)\n        res = [0 if s[i] == c else None for i in range(n)]\n\n        for i in range(1, n):\n            if res[i] != 0 and res[i - 1] is not None:\n                res[i] = res[i - 1] + 1\n\n        for i in range(n - 2, -1, -1):\n            if res[i] is None or res[i + 1] + 1 < res[i]:\n                res[i] = res[i + 1] + 1\n        return res\n```\n\n## å¤æ‚åº¦åˆ†æ\næ—¶é—´ï¼šO(n)\nç©ºé—´ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186358345","body":"## æ€è·¯\nç¬¬ä¸€ååº”æ˜¯ç›´è§‚å®ç°ï¼Œçœ‹äº†é¢˜è§£å‘ç°å¯ä»¥ç”¨å‰ç¼€å’Œå®ç°\n## ä»£ç \n``` python\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.max = maxSize\n        self.stack = []\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.stack) < self.max:\n            self.stack.append(x)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.stack) == 0:\n            return -1\n        else:\n            return self.stack.pop()\n\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        for i in range(min(len(self.stack),k)):\n            self.stack[i] += val\n```\n\n## å¤æ‚åº¦åˆ†æ\næ—¶é—´ï¼šO(1)\nç©ºé—´ï¼šO(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186593772","body":"## æ€è·¯\n\nåˆ©ç”¨stackå®ç°ï¼Œ'['å‡ºå‘å…¥æ ˆã€‚\n\n## ä»£ç \n```python\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        for i in s:\n            if i == ']':\n                strs = ''\n                repeat = ''\n                while stack[-1] != '[':\n                    strs = stack.pop() + strs\n                stack.pop()\n                while stack and stack[-1].isdigit():\n                    repeat = stack.pop() + repeat\n                stack.append(int(repeat) * strs)\n                continue\n            stack.append(i)\n        return ''.join(stack)\n```\n\n##  å¤æ‚åº¦åˆ†æ\næ—¶é—´ï¼šO(n)\nç©ºé—´ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189200907","body":"## æ€è·¯\nä¸€ä¸ªinStack ä¸€ä¸ªoutStackã€‚inputæŠŠæ•°æ®pushåˆ°outStackã€‚å»¶å±•é˜…è¯»å¥½è¯„ï¼ŒçŸ¥é“äº†ä½¿ç”¨åœºæ™¯ã€‚\n\n## ä»£ç \n```python\nclass MyQueue(object):\n\n    def __init__(self):\n        self.inStack = []\n        self.outStack = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.inStack.append(x)\n\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if not self.outStack:\n          while self.inStack:\n              self.outStack.append(self.inStack.pop())\n\n        return self.outStack.pop()\n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.inStack:\n            return self.inStack[0]\n        else:\n            return self.outStack[-1]\n\n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        if not self.inStack and not self.outStack:\n            return True\n        else:\n            return False\n```\n\n## å¤æ‚åº¦åˆ†æ\næ—¶é—´ï¼šO(n)\nç©ºé—´ï¼šO(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194165004","body":"## æ€è·¯\nå¿«æ…¢æŒ‡é’ˆ\n\n## ä»£ç \n```python\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast=head\n        slow=head\n        while True:\n            if not fast or not fast.next:\n                return None\n            fast=fast.next.next\n            slow=slow.next\n            if slow==fast:\n                break\n        fast=head\n        while fast!=slow:\n            fast=fast.next\n            slow=slow.next\n        return slow\n```\n\n## å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦ï¼š O(N)\nç©ºé—´å¤æ‚åº¦ï¼š O(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198867189","body":"## æ€è·¯\nDFS \n\n## ä»£ç \n```python\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        def dfs(root, cur):\n            if not root: return 0\n            if not root.left and not root.right: return cur * 10 + root.val\n            return dfs(root.left, cur * 10 + root.val) + dfs(root.right, cur * 10 + root.val)\n        return dfs(root, 0)\n```\n\n## å¤æ‚åº¦\næ—¶é—´ï¼š O(n)\nç©ºé—´ï¼š O(h)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204982095","body":"## æ€è·¯\nå“ˆå¸Œè¡¨ä¼˜åŒ–\n\n## ä»£ç \n```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        n = len(points)\n        ans = 0\n        for i in range(n):\n            m = collections.defaultdict(int)\n            for j in range(n):\n                dist = abs(points[i][0] - points[j][0]) ** 2 + abs(points[i][1] - points[j][1]) ** 2\n                m[dist] += 1\n            for count in m.values():\n                ans += count * (count-1)\n        return ans\n```\n\n## å¤æ‚åº¦åˆ†æ\næ—¶é—´ O(n^2)\nç©ºé—´ O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/42#issuecomment-1209990822","body":"## æ€è·¯\näºŒåˆ†æ³•\n\n## ä»£ç \n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        l = 0\n        r = len(nums) - 1\n\n        while(l<=r):\n            mid = (l+r)//2\n            if nums[mid] == target:\n                return mid\n            if nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return l\n```\n## å¤æ‚åº¦\næ—¶é—´: O(n)\nç©ºé—´: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aconcert":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185674070","body":"```typescript\nfunction addToArrayForm(num: number[], k: number): number[] {\n\n    let pow = 0;\n    let val = 0;\n    let result = []\n\n    for(let i = num.length-1; i >= 0; i++){\n        val += num[i] * Math.pow(10,pow);\n    }\n\n    val+=k;\n    \n    for(let i = 0; i < num.length -1; i++){\n        result.push(val / (Math.pow(10, num.length)));\n        num.shift();\n    }\n\n    return result;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186212745","body":"```typescript\nfunction shortestToChar(s: string, c: string): number[] {\n\n  let cSet = new Set();\n  let result: number[] = [];\n\n  for (let index = 0; index < s.length; index++) {\n    const str = s[index];\n    if (str === c) {\n      cSet.add(index);\n    }\n  }\n\n  for (let index = 0; index < s.length; index++) {\n    let position = s.length;\n    cSet.forEach((ind) => {\n      if (Math.abs(Number(ind)-index) < position) {\n        position = Math.abs(Number(ind)-index);\n      }\n    })\n    result.push(position);\n  }\n\n  return result;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186543378","body":"```typescript\nclass CustomStack {\n    customStack: number[] = [];\n    maxSize: number;\n    constructor(maxSize: number) {\n        this.maxSize = maxSize;\n    }\n\n    push(x: number): void {\n        const len = this.customStack.length;\n        if(len < this.maxSize){\n            this.customStack[len] = x;\n        }\n    }\n\n    pop(): number {\n        const len = this.customStack.length;\n        if(len > 0){\n            const lastOne = this.customStack[len-1];\n            delete this.customStack[len-1];\n            this.customStack.length--;\n            return lastOne;\n        }\n        return -1;\n    }\n\n    increment(k: number, val: number): void {\n        if(this.customStack.length < k){\n            k = this.customStack.length;\n        }\n        for(let i = 0; i < k ; i++){\n            this.customStack[i]+=val;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187653669","body":"```typescript\nvar decodeString = function (s) {\n    let s_array = s.split('');\n\n    if (isNaN(Number(s_array[0]))) {\n        s_array.unshift('[');\n        s_array.unshift('1');\n        s_array.push(']')\n    }\n\n    return strdecode(s_array, 1);\n\n};\n\nfunction strdecode(k, repeat) {\n    let str_val = '';\n    let result_val = '';\n    let number_str = Number(k.shift());\n    let k_value = k.shift();\n\n    if (k.length === 0) {\n        return;\n    }\n\n    while (isNaN(k_value)) {\n        str_val += k_value;\n        k_value = k.shift();\n    }\n    if (!isNaN(k_value)) {\n        k.unshift(k_value);\n    }\n\n    for (let index = 0; index < repeat; index++) {\n        result_val += str_val;\n    }\n\n    return result_val + strdecode(k, k_value);\n\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189134913","body":"```typescript\nclass MyQueue {\n    stack: number[] = [];\n    mockQueue: number[] = [];\n    constructor() {\n    }\n\n    push(x: number): void {\n        this.stack.push(x);\n    }\n\n    pop(): number {\n        if (this.mockQueue.length === 0) {\n            while(this.stack.length>0){\n                this.mockQueue.push(this.stack.pop()!);\n            }\n        }\n        return this.mockQueue.pop()!;\n    }\n\n    peek(): number {\n        if (this.mockQueue.length === 0) {\n            while(this.stack.length>0){\n                this.mockQueue.push(this.stack.pop()!);\n            }\n        }\n        return this.mockQueue[this.mockQueue.length-1];\n    }\n\n    empty(): boolean {\n        return this.stack.length === 0 && this.mockQueue.length ===0\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191616812","body":"```typescript\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n\n    if(!head)   {return head}\n    let len: number = 1;\n    let tail: ListNode = head;\n    let count: number = 0;\n    let previous = head;\n    \n    while(tail.next){\n        len++;\n        tail = tail.next;\n    }\n    tail.next = head;\n    count = len - k%len;\n\n    while(count>0){\n        previous = head!;\n        head = head!.next;\n        count--;\n    }\n\n    previous.next = null;\n    return head;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192694305","body":"```ts\nfunction swapPairs(head: ListNode | null): ListNode | null {\n\n    if (head === null || head.next === null) {\n        return head;\n    }\n\n    let point: ListNode = head;\n    let newHead: ListNode = point.next;\n    point.next = newHead.next;\n    newHead.next = point;\n\n    let pre: ListNode = point;\n    point = pre.next;\n\n    let len: number = 1;\n    head = newHead;\n    while (head.next) {\n        head = head.next;\n        len++;\n    }\n\n    let odd: boolean = len % 2 === 0 ? false : true;\n    let loopCount: number = odd ? Math.floor(len / 2) - 1 : Math.floor(len / 2) - 2;\n\n    while (loopCount > 0) {\n        pre.next = point.next;\n        point.next = point.next.next;\n        pre.next.next = point;\n\n        pre = point;\n        point = pre.next;\n        loopCount--;\n    }\n\n    if (!odd && point !== null) {\n        pre.next = point.next;\n        pre.next.next = point;\n        point.next = null;\n    }\n\n    return newHead;\n};\n\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195645074","body":"```ts\nclass LRUCache {\n    capacity: number;\n    map: Map<number, number>;\n\n    constructor(capacity: number) {\n        this.capacity = capacity;\n        this.map = new Map();\n    }\n\n    get(key: number): number {\n        if(this.map.has(key)){\n            const result = this.map.get(key)!;\n            this.map.delete(key);\n            this.map.set(key, result);\n            return result;\n        }\n        return -1;\n    }\n\n    put(key: number, value: number): void {\n        if(this.map.has(key)) {\n            this.map.delete(key);\n        }\n        if(this.map.size >= this.capacity) {\n            this.map.delete(this.map.keys().next().value);\n        }\n        this.map.set(key,value);\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linjunhe":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185675036","body":"```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        i = len(num) - 1\r\n        c = 0\r\n        while i >= 0 or k != 0:\r\n            a = num[i] if i >= 0 else 0\r\n            b = k % 10\r\n            sum = a + b + c\r\n            c   = sum // 10\r\n            res.append(sum % 10)\r\n            i = i - 1\r\n            k = k // 10\r\n        if c != 0:\r\n            res.append(c)\r\n        return res[::-1]\r\n```\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186219163","body":"```python\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        n = len(S)\r\n        res = [0 if c == C else n for c in S]\r\n        for i in range(1, n):\r\n           res[i] = min(res[i], res[i - 1] + 1)\r\n        for i in range(n - 2, -1, -1):\r\n            res[i] = min(res[i], res[i + 1] + 1)\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186551539","body":"```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        self.len = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.len < self.maxSize:\r\n            self.stack.append(x)\r\n            self.len += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.len == 0:\r\n            return -1\r\n        else:\r\n            self.len -= 1\r\n            return self.stack.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(k):\r\n            if i < self.len:\r\n                self.stack[i] += val\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187622566","body":"```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        num = 0\r\n        res = \"\"\r\n        for c in s:\r\n            if c.isdigit():\r\n                num = num * 10 + int(c)\r\n            elif c == \"[\":\r\n                stack.append((res, num))\r\n                res, num = \"\", 0\r\n            elif c == \"]\":\r\n                top = stack.pop()\r\n                res = top[0] + res * top[1]\r\n            else:\r\n                res += c\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189185010","body":"```java\r\nclass MyQueue {\r\n    private Stack<Integer> s1, s2;\r\n\r\n    public MyQueue() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n\r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n\r\n    public int pop() {\r\n        // å…ˆè°ƒç”¨ peek ä¿è¯ s2 éç©º\r\n        peek();\r\n        return s2.pop();\r\n    }\r\n\r\n    public int peek() {\r\n        if (s2.isEmpty())\r\n            // æŠŠ s1 å…ƒç´ å‹å…¥ s2\r\n            while (!s1.isEmpty())\r\n                s2.push(s1.pop());\r\n        return s2.peek();\r\n    }\r\n\r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190410948","body":"```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        res = [arr[0]]\r\n        for i in range(1, len(arr)):\r\n            if arr[i] >= res[-1]:\r\n                res.append(arr[i])\r\n            else:\r\n                index = -1\r\n                for j in range(len(res) - 2, -1, -1):\r\n                    if res[j] <= arr[i]:\r\n                        index = j\r\n                        break\r\n                res = res[0:index + 1] + [res[-1]]\r\n        return len(res)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191648376","body":"```python\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null || k == 0) {\r\n\t\t\treturn head;\r\n\t\t}\r\n\t\tListNode pre = head;\r\n\t\tListNode end = head.next;\r\n\t\tint len = 1;\r\n\t\twhile (end != null) {\r\n\t\t\tpre = end;\r\n\t\t\tend = end.next;\r\n\t\t\tlen ++;\r\n\t\t}\r\n\t\t// å¤´å°¾ç›¸è¿å½¢æˆæ­»é“¾\r\n\t\tpre.next = head;\r\n\t\tend = head;\r\n\t\t\r\n\t\tk = k % len;\r\n\t\tint count = len - k;\r\n\t\twhile (count -- > 0) {\r\n\t\t\tpre = end;\r\n\t\t\tend = end.next;\r\n\t\t}\r\n\t\t\r\n\t\tpre.next = null;\r\n\t\t\r\n\t\treturn end;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyqqq22":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185675275","body":"### æ€è·¯\r\né€†åºéå†æ•°ç»„è¿›è¡Œç›¸åŠ ï¼Œæœ‰ä¸¤ç§æƒ…å†µï¼š\r\n1. numæ•°ç»„é•¿åº¦å¤§äºkä½æ•°ï¼›éå†å®Œnumåkä¸º0ï¼Œç›¸åŠ ç»“æœä¸€è‡´\r\n2. numæ•°ç»„é•¿åº¦å°äºkä½æ•°ï¼›éå†å®Œåkä¸ä¸º0ï¼Œåˆ™ç»§ç»­å°†kå‰©ä½™æ•°å­—é€ä¸ªåŠ ä¸Š\r\n\r\næ³¨æ„è¿›ä½ï¼Œè‹¥éœ€è¦è¿›ä½åˆ™åœ¨kå‰è¿›ä¸€ä½ååŠ ä¸€\r\n\r\n### ä»£ç \r\n\r\n\r\n```python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        res=[]\r\n        for i in range(len(num)):\r\n            sum=num[-i-1]+k%10\r\n            k/=10\r\n            if sum>=10:\r\n                k+=1\r\n                sum-=10\r\n            res.append(sum)\r\n        while k:\r\n            res.append(k%10)\r\n            k/=10\r\n        return res[::-1]\r\n```\r\n### å¤æ‚åº¦åˆ†æ\r\næ—¶é—´å¤æ‚åº¦: O(max(n,k))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185758533","body":"### æ€è·¯\r\nä¸¤æ¬¡éå†ï¼Œåˆ†åˆ«å¯»æ‰¾å­—ç¬¦ä¸å·¦è¾¹cå­—ç¬¦çš„æœ€å°è·ç¦»å’Œä¸å³è¾¹cå­—ç¬¦çš„æœ€å°è·ç¦»ï¼Œå–ä¸¤è€…æœ€å°å€¼\r\n\r\n### ä»£ç \r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n=len(s)\r\n        res=[n]*n\r\n        cidex=-n\r\n        for i,ch in enumerate(s):\r\n            if ch==c:\r\n                cidex=i\r\n            res[i]=i-cidex\r\n        cidex=n\r\n        for i in range(-1,-len(s)-1,-1):\r\n            if s[i]==c:\r\n                cidex=i\r\n            res[i]=min(res[i],cidex-i)\r\n        return res\r\n```\r\n\r\n### å¤æ‚åº¦åˆ†æ\r\næ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œnä¸ºå­—ç¬¦ä¸²sçš„é•¿åº¦\r\nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186547537","body":"ç”¨topè®°å½•æ ˆé¡¶ä½ç½®\r\n```python\r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.stack=[0]*maxSize\r\n        self.top=-1\r\n\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if self.top<len(self.stack)-1:\r\n            self.top+=1\r\n            self.stack[self.top]=x\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if self.top==-1:\r\n            popout=-1\r\n        else:\r\n            popout=self.stack[self.top]\r\n            self.top-=1\r\n        return popout\r\n\r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if len(self.stack)<k:\r\n            self.stack=[x+val for x in self.stack]\r\n        else:\r\n            for i in range(k):\r\n                self.stack[i]+=val\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192234366","body":"### ä»£ç \r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        dummy=ListNode()\r\n        dummy.next=head\r\n        cur=dummy\r\n        while(cur.next and cur.next.next):\r\n            node1=cur.next\r\n            node2=cur.next.next\r\n            cur.next=node2\r\n            node1.next=node2.next\r\n            node2.next=node1\r\n            cur=node1\r\n        return dummy.next\r\n```\r\n### å¤æ‚åº¦åˆ†æ\r\næ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œå…¶ä¸­næ˜¯é“¾è¡¨çš„èŠ‚ç‚¹æ•°é‡ã€‚\r\nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195572338","body":"### ä»£ç \r\n```python\r\nclass DLinkedNode:\r\n    def __init__(self, key=0, value=0):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = None\r\n        self.next = None\r\n\r\n\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.cache = dict()\r\n        self.head = DLinkedNode()\r\n        self.tail = DLinkedNode()\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n        self.capacity = capacity\r\n        self.size = 0\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.cache:\r\n            return -1\r\n        node = self.cache[key]\r\n        self.moveToHead(node)\r\n        return node.value\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key not in self.cache:\r\n            node = DLinkedNode(key, value)\r\n            self.cache[key] = node\r\n            self.addToHead(node)\r\n            self.size += 1\r\n            if self.size > self.capacity:\r\n                removed = self.removeTail()\r\n                self.cache.pop(removed.key)\r\n                self.size -= 1\r\n        else:\r\n            node = self.cache[key]\r\n            node.value = value\r\n            self.moveToHead(node)\r\n    \r\n    def addToHead(self, node):\r\n        node.prev = self.head\r\n        node.next = self.head.next\r\n        self.head.next.prev = node\r\n        self.head.next = node\r\n    \r\n    def removeNode(self, node):\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n\r\n    def moveToHead(self, node):\r\n        self.removeNode(node)\r\n        self.addToHead(node)\r\n\r\n    def removeTail(self):\r\n        node = self.tail.prev\r\n        self.removeNode(node)\r\n        return node\r\n\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n```\r\n### å¤æ‚åº¦åˆ†æ\r\næ—¶é—´å¤æ‚åº¦ï¼šO(1)\r\nç©ºé—´å¤æ‚åº¦ï¼šO(capacity)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1201974129","body":"### æ€è·¯\r\né€’å½’ï¼Œå½“å‰æ ‘çš„æœ€å¤§æ·±åº¦å°±æ˜¯å·¦å­æ ‘æœ€å¤§æ·±åº¦å’Œå³å­æ ‘æœ€å¤§æ·±åº¦äºŒè€…çš„æœ€å¤§å€¼+1(åŠ ä¸Šæ ¹èŠ‚ç‚¹)ï¼Œé€’å½’ç»ˆæ­¢æ¡ä»¶ï¼šrootä¸ºç©ºèŠ‚ç‚¹\r\n### ä»£ç \r\n```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root:\r\n            return 0\r\n        return max(self.maxDepth(root.left),self.maxDepth(root.right))+1\r\n```\r\n### å¤æ‚åº¦åˆ†æ\r\næ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œnä¸ºäºŒå‰æ ‘èŠ‚ç‚¹ä¸ªæ•°\r\nç©ºé—´å¤æ‚åº¦ï¼šO(height)ï¼ŒäºŒå‰æ ‘é«˜åº¦","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1201985013","body":"### æ€è·¯\r\né€’å½’ï¼Œåˆ¤æ–­ä¸¤ä¸ªäºŒå‰æ ‘çš„å·¦å­æ ‘å’Œå³å­æ ‘æ˜¯å¦éƒ½åˆ†åˆ«ç›¸åŒã€‚\r\nç»ˆæ­¢æ¡ä»¶æœ‰ä¸‰ç§æƒ…å†µï¼š\r\n1. ä¸¤æ ¹èŠ‚ç‚¹éƒ½ä¸ºç©ºï¼Œåˆ™ç›¸åŒ\r\n2. åªæœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹ä¸ºç©ºï¼Œåˆ™ä¸åŒ\r\n3. ä¸¤æ ¹èŠ‚ç‚¹éƒ½éç©ºä½†å€¼ä¸åŒï¼Œåˆ™ä¸¤æ ‘ä¸åŒ(è‹¥æ ¹èŠ‚ç‚¹å€¼ç›¸åŒåˆ™é€’å½’åˆ¤æ–­å·¦å³å­æ ‘)\r\n### ä»£ç \r\n```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        elif not q or not p:\r\n            return False\r\n        elif p.val!=q.val:\r\n            return False\r\n        return self.isSameTree(p.left,q.left)&self.isSameTree(p.right,q.right)\r\n```\r\n### å¤æ‚åº¦åˆ†æ\r\næ—¶é—´å¤æ‚åº¦ï¼šO(min(m,n))ï¼Œå³ä¸¤ä¸ªäºŒå‰æ ‘èŠ‚ç‚¹æ•°æœ€å°å€¼\r\nç©ºé—´å¤æ‚åº¦ï¼šO(min(m,n))","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1202108673","body":"### æ€è·¯\r\né€’å½’ï¼Œå¦‚æœèŠ‚ç‚¹ä¸ºç©ºåˆ™å’Œä¸º0ï¼ŒèŠ‚ç‚¹ä¸ºå¶å­èŠ‚ç‚¹åˆ™å°†å¯¹åº”æ•°å­—åŠ åˆ°æ•°å­—ä¹‹å’Œï¼Œå¦‚æœä¸æ˜¯å¶å­èŠ‚ç‚¹åˆ™é€’å½’è®¡ç®—å­èŠ‚ç‚¹çš„æ•°å­—ä¹‹å’Œã€‚\r\nè®¡ç®—æ–¹å¼ä¸ºå·²æœ‰æ•°å­—ä¹‹å’Œ*10+å½“å‰èŠ‚ç‚¹å¯¹åº”æ•°å­—\r\n### ä»£ç \r\n```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\r\n        def dfs(root,sum):\r\n            if not root:\r\n                return 0\r\n            sum=10*sum+root.val\r\n            if not root.left and not root.right:\r\n                return sum\r\n            else:\r\n                return dfs(root.left,sum)+dfs(root.right,sum)\r\n        return dfs(root,0)\r\n```\r\n### å¤æ‚åº¦åˆ†æ\r\næ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œå…¶ä¸­næ˜¯äºŒå‰æ ‘èŠ‚ç‚¹ä¸ªæ•°\r\nç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1203672056","body":"```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        nodes=[]\r\n        def dfs(node,row,col):\r\n            if not node:\r\n                return\r\n            nodes.append((row,col,node.val))\r\n            dfs(node.left,row-1,col+1)\r\n            dfs(node.right,row+1,col+1)\r\n        dfs(root,0,0)\r\n        nodes.sort(key=lambda x:[-x[1],x[0]])\r\n        return nodes[0][2]\r\n```","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200705477","body":"### æ€è·¯\r\nå…ˆå¯¹æ ‘è¿›è¡Œéå†ï¼Œè®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„åæ ‡å’Œå€¼ï¼Œé¢˜ä¸­çš„éå†è§„åˆ™äº‹å®ä¸Šå°±æ˜¯è‡ªå®šä¹‰è§„åˆ™æ’åºï¼šå…ˆåæŒ‰ç…§col,raw,valå‡åºæ’åº\r\næ’åºå®Œæˆåå°†åŒä¸€åˆ—èŠ‚ç‚¹æ”¾å…¥åŒä¸€æ•°ç»„ä¸­\r\n### ä»£ç \r\n```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\r\n        nodes=[]\r\n        def dfs(node,row,col):\r\n            if not node:\r\n                return\r\n            nodes.append((col,row,node.val))\r\n            dfs(node.left,row+1,col-1)\r\n            dfs(node.right,row+1,col+1)\r\n\r\n        dfs(root,0,0)\r\n        nodes.sort()\r\n        ans=[]\r\n        precol=-inf\r\n        for i in range(len(nodes)):\r\n            if nodes[i][0]!=precol:\r\n                ans.append([])\r\n                precol=nodes[i][0]\r\n            ans[-1].append(nodes[i][2])\r\n        return ans\r\n```\r\n### å¤æ‚åº¦åˆ†æ\r\næ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)\r\nç©ºé—´è´Ÿè´£åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201964919","body":"æ–¹æ³•ï¼šå“ˆå¸Œè¡¨\r\n```python\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        # æ— é‡å¤å…ƒç´ \r\n        hashtable={}\r\n        for i,n in enumerate(nums):\r\n            if target-n in hashtable:\r\n                return [hashtable[target-n],i]\r\n            else:\r\n                hashtable[n]=i\r\n        return []\r\n```\r\næ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼ŒNä¸ºæ•°ç»„é•¿åº¦ï¼Œå¯¹æ¯ä¸ªå…ƒç´ è¿›è¡ŒO(1)çš„æŸ¥æ‰¾\r\nç©ºé—´å¤æ‚åº¦ï¼šO(N)ï¼Œå“ˆå¸Œè¡¨æ¶ˆè€—","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203659949","body":"### æ€è·¯\r\nç”¨å“ˆå¸Œè¡¨(è¿™é‡Œç”¨collectionsçº¯å±ä¸ºäº†ä»£ç å¥½çœ‹)è®°å½•æ‰€æœ‰å­—æ¯å‡ºç°æ¬¡æ•°ï¼Œå†åŸºäºå¿«é€Ÿæ’åº/å †æ’åºé€‰å‡ºå‰kä¸ª\r\n### ä»£ç \r\nå¿«é€Ÿæ’åºï¼šæ—¶é—´å¤æ‚åº¦O(n^2)ï¼Œç©ºé—´å¤æ‚åº¦O(n)\r\n```python\r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        import collections\r\n        Frequent=list(collections.Counter(nums).items())\r\n        n=len(Frequent)\r\n        # å¿«é€Ÿæ’åº\r\n        import random\r\n        def rabdomPartition(arr,left,right):\r\n            tmp=random.randint(left,right)\r\n            pivot=arr[tmp]\r\n            arr[tmp],arr[left]=arr[left],arr[tmp]\r\n            while left<right:\r\n                while left<right and arr[right][1]>=pivot[1]:\r\n                    right-=1\r\n                arr[left]=arr[right]\r\n                while left<right and arr[left][1]<=pivot[1]:\r\n                    left+=1\r\n                arr[right]=arr[left]\r\n            arr[left]=pivot\r\n            return left\r\n        def quickselect(arr,left,right,k):\r\n            if left<right:\r\n                index=rabdomPartition(arr,left,right)\r\n                num=index-left+1\r\n                if k<num:\r\n                    quickselect(arr,left,index-1,k)\r\n                elif k>num:\r\n                    quickselect(arr,index+1,right,k-num)\r\n                    \r\n        quickselect(Frequent,0,n-1,n-k)\r\n        return [x[0] for x in Frequent[n-k:]]\r\n```\r\nå †æ’åºï¼šæ—¶é—´å¤æ‚åº¦O(nlogk)ï¼Œç©ºé—´å¤æ‚åº¦O(n)\r\n```python\r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        import collections,heapq\r\n        Frequent=list(collections.Counter(nums).items())\r\n        # å †æ’åº\r\n        queue=[]\r\n        for key,freq in Frequent:\r\n            heapq.heappush(queue,(freq,key))\r\n            if len(queue) > k:\r\n                heapq.heappop(queue)\r\n        result = [0] * k\r\n        for i in range(k - 1, -1, -1):\r\n            result[i] = heapq.heappop(queue)[1]\r\n        return result\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204670268","body":"### æ€è·¯\r\nå“ˆå¸Œè¡¨+æšä¸¾+æ’åˆ—ç»„åˆ\r\nå¯¹äºæ¯ä¸ªpointsä¸­çš„ç‚¹(å½“ä½œé¢˜ä¸­çš„ç‚¹i)ï¼Œè®¡ç®—å…¶ä»–ç‚¹ä¸ä¹‹è·ç¦»å¹¶é€šè¿‡å“ˆå¸Œè¡¨è®°å½•ï¼Œå½“æœ‰nä¸ªç›¸åŒè·ç¦»æ—¶å›æ—‹é•–æ•°é‡ä¸ºn(n-1)\r\nå½“n=1æ—¶n(n-1)=0ï¼ŒåŒæ ·ç¬¦åˆè¦æ±‚\r\n### ä»£ç \r\n```python\r\nclass Solution:\r\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\r\n        ans=0\r\n        for p in points:\r\n            hashdict=defaultdict(int) # é¿å…KeyErrorå¼‚å¸¸\r\n            for q in points:\r\n                dis=(p[0]-q[0])**2+(p[1]-q[1])**2\r\n                hashdict[dis]+=1\r\n            for n in hashdict.values():\r\n                # è·ç¦»ç›¸åŒçš„ç‚¹æœ‰nä¸ªï¼Œè€ƒè™‘é¡ºåºæ’åˆ—ç»„åˆæœ‰n(n-1)ç§æƒ…å†µ\r\n                ans+=n*(n-1)\r\n        return ans\r\n```\r\n### å¤æ‚åº¦åˆ†æ\r\næ—¶é—´å¤æ‚åº¦ï¼šO(n^2)ï¼Œå…¶ä¸­næ˜¯pointsçš„é•¿åº¦\r\nç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206114252","body":"### æ€è·¯\r\nåŒæŒ‡é’ˆï¼Œé¢˜ç›®è¦æ±‚ä¸ºå­ä¸²è€Œä¸æ˜¯å­åºåˆ—ï¼Œç›´æ¥è®°å½•ç´¢å¼•è€Œä¸ç”¨å“ˆå¸Œè¡¨\r\n### ä»£ç \r\n```python\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        left,right=0,0\r\n        maxlen=0\r\n        while right<len(s):\r\n            while s[right] in s[left:right]:\r\n                left+=1\r\n            right+=1\r\n            maxlen=max(maxlen,right-left)\r\n        return maxlen\r\n```\r\n### å¤æ‚åº¦åˆ†æ\r\næ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œnä¸ºå­—ç¬¦ä¸²é•¿åº¦ï¼Œå·¦å³æŒ‡é’ˆåˆ†åˆ«éå†å­—ç¬¦ä¸²ä¸€æ¬¡\r\nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207561829","body":"### æ€è·¯å’Œä»£ç \r\nå•æŒ‡é’ˆï¼šæ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(1)\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def middleNode(self, head: ListNode) -> ListNode:\r\n        node=head\r\n        length=0\r\n        while node:\r\n            length+=1\r\n            node=node.next\r\n        tmp=0\r\n        node=head\r\n        while tmp!=math.floor(length/2):\r\n            tmp+=1\r\n            node=node.next\r\n        return node\r\n```\r\nå¿«æ…¢æŒ‡é’ˆï¼šæ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(1)\r\n```python\r\nclass Solution:\r\n    def middleNode(self, head: ListNode) -> ListNode:\r\n        slow=head\r\n        fast=head\r\n        while fast and fast.next:\r\n            slow=slow.next\r\n            fast=fast.next.next\r\n        return slow\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208820050","body":"### æ€è·¯\r\nåŒæŒ‡é’ˆ\r\n### ä»£ç \r\n```python\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        slow,fast=0,0\r\n        if not nums:\r\n            return 0\r\n        while fast<len(nums):\r\n            if nums[fast]!=nums[slow]:\r\n                slow+=1\r\n                nums[slow]=nums[fast]\r\n            fast+=1\r\n        return slow+1\r\n```\r\n### å¤æ‚åº¦åˆ†æ\r\næ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yibenxiao":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185677632","body":"# ã€Day 1ã€‘989. æ•°ç»„å½¢å¼çš„æ•´æ•°åŠ æ³•\n\n## ä»£ç \n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```\n\n## å¤æ‚åº¦\n**æ—¶é—´å¤æ‚åº¦**ï¼šO(max(n,log k))ï¼Œå…¶ä¸­nä¸ºæ•°ç»„çš„é•¿åº¦\n\n**ç©ºé—´å¤æ‚åº¦**ï¼šO(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186225383","body":"# ã€Day 2ã€‘821. å­—ç¬¦çš„æœ€çŸ­è·ç¦»\n\n## ä»£ç \n\n```C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.length();\n        vector<int> ans(n);\n\n        for (int i = 0, idx = -n; i < n; ++i) {\n            if (s[i] == c) {\n                idx = i;\n            }\n            ans[i] = i - idx;\n        }\n\n        for (int i = n - 1, idx = 2 * n; i >= 0; --i) {\n            if (s[i] == c) {\n                idx = i;\n            }\n            ans[i] = min(ans[i], idx - i);\n        }\n        return ans;\n    }\n};\n```\n\n## å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186551813","body":"# ã€Day 3ã€‘1381. è®¾è®¡ä¸€ä¸ªæ”¯æŒå¢é‡æ“ä½œçš„æ ˆ\n\n## ä»£ç \n\n```c++\nclass CustomStack {\npublic:\n\tint maxSize;\n\tvector<int>tmp;\n\tCustomStack(int maxSize) {\n\t\tthis->maxSize = maxSize;\n\t}\n\n\tvoid push(int x) {\n\t\tif (tmp.size() >= maxSize)\n\t\t{\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmp.emplace_back(x);\n\t\t}\n\t}\n\n\tint pop() {\n\t\tif (tmp.size() == 0)\n\t\t\treturn -1;\n\t\telse\n\t\t{\n\t\t\tint x = tmp.back();\n\t\t\ttmp.pop_back();\n\t\t}\n\t}\n\n\tvoid increment(int k, int val) {\n\t\tfor (int i = 0; i < tmp.size() && i < k; i++)\n\t\t{\n\t\t\ttmp[i] += k;\n\t\t}\n\t}\n};\n```\n\n## å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187675016","body":"# ã€Day 4ã€‘394. å­—ç¬¦ä¸²è§£ç \n\n## ä»£ç \n\n```C++\nclass Solution {\npublic:\n    string getDigits(string &s, size_t &ptr) {\n        string ret = \"\";\n        while (isdigit(s[ptr])) {\n            ret.push_back(s[ptr++]);\n        }\n        return ret;\n    }\n\n    string getString(vector <string> &v) {\n        string ret;\n        for (const auto &s: v) {\n            ret += s;\n        }\n        return ret;\n    }\n\n    string decodeString(string s) {\n        vector <string> stk;\n        size_t ptr = 0;\n\n        while (ptr < s.size()) {\n            char cur = s[ptr];\n            if (isdigit(cur)) {\n                // è·å–ä¸€ä¸ªæ•°å­—å¹¶è¿›æ ˆ\n                string digits = getDigits(s, ptr);\n                stk.push_back(digits);\n            } else if (isalpha(cur) || cur == '[') {\n                // è·å–ä¸€ä¸ªå­—æ¯å¹¶è¿›æ ˆ\n                stk.push_back(string(1, s[ptr++])); \n            } else {\n                ++ptr;\n                vector <string> sub;\n                while (stk.back() != \"[\") {\n                    sub.push_back(stk.back());\n                    stk.pop_back();\n                }\n                reverse(sub.begin(), sub.end());\n                // å·¦æ‹¬å·å‡ºæ ˆ\n                stk.pop_back();\n                // æ­¤æ—¶æ ˆé¡¶ä¸ºå½“å‰ sub å¯¹åº”çš„å­—ç¬¦ä¸²åº”è¯¥å‡ºç°çš„æ¬¡æ•°\n                int repTime = stoi(stk.back()); \n                stk.pop_back();\n                string t, o = getString(sub);\n                // æ„é€ å­—ç¬¦ä¸²\n                while (repTime--) t += o; \n                // å°†æ„é€ å¥½çš„å­—ç¬¦ä¸²å…¥æ ˆ\n                stk.push_back(t);\n            }\n        }\n\n        return getString(stk);\n    }\n};\n```\n\n## å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189153792","body":"# ã€Day 5ã€‘232. ç”¨æ ˆå®ç°é˜Ÿåˆ—\n\n## ä»£ç \n\n```C++\nclass MyQueue {\npublic:\n    stack<int> stIn;        //è¾“å…¥æ ˆ\n    stack<int> stOut;        //è¾“å‡ºæ ˆ\n\n    //å…¥æ ˆæ— è¿”å›ï¼Œæœ‰å‚æ•°\n    void push(int x){\n        stIn.push(x);//å…ˆåŠ å…¥è¾“å…¥æ ˆ\n    }\n    //å‡ºæ ˆæœ‰è¿”å›ï¼Œè¿”å›å‡ºæ ˆçš„å…ƒç´ \n    int pop(){\n        //åªæœ‰å½“stOutä¸ºç©ºçš„æ—¶å€™ï¼Œå†ä»stIné‡Œé¢å¯¼å…¥å…¨éƒ¨æ•°\n        if(stOut.empty()){\n            //ä»stInå¯¼å…¥æ•°æ®ç›´åˆ°stInä¸ºç©º\n            while(!stIn.empty()){\n                stOut.push(stIn.top());\n                stIn.pop();\n            }\n        }\n        //å‡ºæ ˆçš„æœ‰å…ƒç´ ï¼Œå¯ä»¥å‡ºæ ˆï¼Œä¸´æ—¶ä¿å­˜æ ˆé¡¶\n        int front = stOut.top();\n        stOut.pop();\n        return front;\n    }\n\n    int peek(){\n        int res = this->pop();  //ç›´æ¥ä½¿ç”¨å·²æœ‰çš„popå‡½æ•°\n        stOut.push(res);    //å› ä¸ºpopå‡½æ•°å¼¹å‡ºäº†å…ƒç´ resï¼Œæ‰€ä»¥åœ¨æ·»åŠ å›å»\n        return res;\n    }\n\n\n    bool empty(){\n        return stOut.empty()&&stIn.empty();\n    }\n};\n\n```\n\n## å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼šO(1)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190450446","body":"# ã€Day 6ã€‘768. æœ€å¤šèƒ½å®Œæˆæ’åºçš„å— II\n\n## ä»£ç \n\n```C++\n// å®˜æ–¹é¢˜è§£\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> stack;\n        for(int i =0;i<arr.size();i++){\n            // é‡åˆ°ä¸€ä¸ªæ¯”æ ˆé¡¶å°çš„å…ƒç´ ï¼Œè€Œå‰é¢çš„å—ä¸åº”è¯¥æœ‰æ¯” a å°çš„\n            // è€Œæ ˆä¸­æ¯ä¸€ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªå—ï¼Œå¹¶ä¸”æ ˆçš„å­˜çš„æ˜¯å—çš„æœ€å¤§å€¼ï¼Œå› æ­¤æ ˆä¸­æ¯” a å°çš„å€¼éƒ½éœ€è¦ pop å‡ºæ¥\n            if(!stack.empty()&&stack.top()>arr[i]){\n                // æˆ‘ä»¬éœ€è¦å°†èåˆåçš„åŒºå—çš„æœ€å¤§å€¼é‡æ–°æ”¾å›æ ˆ\n                // è€Œ stack æ˜¯é€’å¢çš„ï¼Œå› æ­¤ stack[-1] æ˜¯æœ€å¤§çš„\n                int cur = stack.top();\n                // ç»´æŒæ ˆçš„å•è°ƒé€’å¢\n                while(!stack.empty()&&stack.top()>arr[i]){\n                    stack.pop();\n                }\n                stack.push(cur);\n            }else{\n                stack.push(arr[i]);\n            }\n        }\n        // æ ˆå­˜çš„æ˜¯å—ä¿¡æ¯ï¼Œå› æ­¤æ ˆçš„å¤§å°å°±æ˜¯å—çš„æ•°é‡\n        return stack.size();\n    }\n};\n\n//Lee åªèƒ½é€šè¿‡ä¸€éƒ¨åˆ†ç”¨ä¾‹\nclass Solution {\npublic:\n\tint maxChunksToSorted(vector<int>& arr) {\n\t\tint ans = 0;\n\t\tint i = arr.size();\n\t\twhile (i != 0)\n\t\t{\n\t\t\tint j = max_element(arr.begin(), arr.begin() + i) - arr.begin();\n\t\t\twhile (j + 1 < arr.size() && arr[j] == arr[j + 1] && j < i-1)\n\t\t\t\tj += 1;\n\t\t\ti = j;\n\t\t\tans += 1;\n\t\t}\n\t\treturn ans;\n\t}\n};\n```\n\n## å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191642131","body":"# ã€Day 7ã€‘61. æ—‹è½¬é“¾è¡¨\n\n## ä»£ç \n\n```C++\nclass Solution {\npublic:\n\tListNode* rotateRight(ListNode* head, int k) {\n\t\tif (head == NULL || head->next == NULL || k == 0)\n\t\t\treturn head;\n\t\tListNode * tmp = head;\n\t\tint len = 1;\n        //è®¡ç®—é•¿åº¦\n\t\twhile (tmp->next != NULL)\n\t\t{\n\t\t\tlen += 1;\n\t\t\ttmp = tmp->next;\n\t\t}\n\t\t\n\t\tint add = len - k % len;\n\t\tif (len == add)\n\t\t{\n\t\t\treturn head;\n\t\t}\n\t\ttmp->next = head;\n\t\twhile (add--)\n\t\t{\n\t\t\ttmp = tmp->next;\n\t\t}\n\n\t\thead = tmp->next;\n\t\ttmp->next = NULL;\n\t\t\n\t\t\n\t\treturn head;\n\n\t}\n};\n```\n\n## å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192508232","body":"# ã€Day 8ã€‘24. ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹\n\n## ä»£ç \n\n```C++\nclass Solution {\npublic:\n\tListNode* swapPairs(ListNode* head) {\n\t\tif (head == NULL || head->next == NULL)\n\t\t\treturn head;\n\t\tListNode * p1 = head;\n\t\tListNode * p2 = head->next;\n\t\tListNode * ans = head->next; \\\n\t\t\tListNode *pre = NULL;\n\t\twhile (1)\n\t\t{\n\t\t\tListNode * tmp = p2->next;\n\t\t\tp2->next = p1;\n\t\t\tp1->next = tmp;\n\t\t\tif(pre)\n\t\t\t\tpre->next = p2;\n\n\t\t\tif (p1->next && p1->next->next)\n\t\t\t{\n\t\t\t\tpre = p1;\n\t\t\t\tp1 = p1->next;\n\t\t\t\tp2 = p1->next;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ans;\n\t}\n};\n```\n\n## å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193141039","body":"# ã€Day 9ã€‘109. æœ‰åºé“¾è¡¨è½¬æ¢äºŒå‰æœç´¢æ ‘\n\n## ä»£ç \n\n```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n// å®˜æ–¹\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if (head == nullptr) return nullptr;\n        return sortedListToBST(head, nullptr);\n    }\n    TreeNode* sortedListToBST(ListNode* head, ListNode* tail) {\n        if (head == tail) return nullptr;\n\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while (fast != tail && fast->next != tail) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n\n        TreeNode* root = new TreeNode(slow->val);\n        root->left = sortedListToBST(head, slow);\n        root->right = sortedListToBST(slow->next, tail);\n        return root;\n    }\n};\n\n// å®˜æ–¹ ä»¥æ—¶é—´æ¢ç©ºé—´ æ—¶é—´å¤æ‚åº¦ç©ºé—´å¤æ‚åº¦éƒ½æ˜¯O(N)\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        vector<int> nodes;\n        while (head != nullptr) {\n            nodes.push_back(head->val);\n            head = head->next;\n        }\n        return sortedListToBST(nodes, 0, nodes.size());\n    }\n    TreeNode* sortedListToBST(vector<int>& nodes, int start, int end) {\n        if (start >= end) return nullptr;\n\n        int mid = (end - start) / 2 + start;\n        TreeNode* root = new TreeNode(nodes[mid]);\n        root->left = sortedListToBST(nodes, start, mid);\n        root->right = sortedListToBST(nodes, mid + 1, end);\n        return root;\n    }\n};\n\n```\n\n## å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼šO(NLogN)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(LogN)\n\n\n\n\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193290697","body":"# ã€Day 10ã€‘160. ç›¸äº¤é“¾è¡¨\n\n## ä»£ç \n\n```C++\n//V1 å“ˆå¸Œ\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n    if (headA == NULL || headB == NULL) return NULL;\n\n    map<ListNode*, bool> seen;\n    while (headA) {\n        seen.insert(pair<ListNode*, bool>(headA, true));\n        headA = headA->next;\n    }\n    while (headB) {\n        if (seen.find(headB) != seen.end()) return headB;\n        headB = headB->next;\n    }\n    return NULL;\n}\n\n//V2 åŒæŒ‡é’ˆ æ—¶é—´å¤æ‚åº¦ï¼šO(N);ç©ºé—´å¤æ‚åº¦ï¼šO(1)ï¼›\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n    if (headA == NULL || headB == NULL) return NULL;\n\n    ListNode* pA = headA;\n    ListNode* pB = headB;\n    while (pA != pB) {\n        pA = pA == NULL ? headB : pA->next;\n        pB = pB == NULL ? headA : pB->next;\n    }\n\n    return pA;\n}\n\n//Lee æ—¶é—´å¤æ‚åº¦ï¼šO(N*N);ç©ºé—´å¤æ‚åº¦ï¼šO(1)ï¼›\nclass Solution {\npublic:\n\tListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n\t\twhile (headA && headB)\n\t\t{\n\t\t\tListNode *tmp = headB;\n\t\t\twhile (tmp)\n\t\t\t{\n\t\t\t\tif (tmp == headA)\n\t\t\t\t\treturn tmp;\n\t\t\t\ttmp = tmp->next;\n\t\t\t}\n\t\t\theadA = headA->next;\n\t\t}\n\t\treturn NULL;\n\t}\n};\n```\n\n## å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194123442","body":"# ã€Day 11ã€‘142. ç¯å½¢é“¾è¡¨ II\n\n## ä»£ç \n\n```C++\nListNode *detectCycle(ListNode *head) {\n    ListNode *slow = head;\n    ListNode *fast = head;\n\n    while (fast && fast->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n        if (slow == fast) {\n            fast = head;\n            while (slow != fast) {\n                slow = slow->next;\n                fast = fast->next;\n            }\n            return slow;\n        }\n    }\n    return NULL;\n}\n```\n\n## å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195665858","body":"# ã€Day 12ã€‘146. LRU ç¼“å­˜æœºåˆ¶\n\n## ä»£ç \n\n```c++\n// æ„å»ºé“¾è¡¨\nclass DLinkedListNode {\npublic:\n    int key;\n    int value;\n    DLinkedListNode *prev;\n    DLinkedListNode *next;\n    DLinkedListNode() : key(0), value(0), prev(NULL), next(NULL) {};\n    DLinkedListNode(int k, int val) : key(k), value(val), prev(NULL), next(NULL) {};\n};\n\nclass LRUCache {\npublic:\n    LRUCache(int capacity) : capacity_(capacity) {\n        // åˆ›å»ºä¸¤ä¸ª dummy èŠ‚ç‚¹æ¥ç®€åŒ–æ“ä½œï¼Œè¿™æ ·å°±ä¸ç”¨ç‰¹æ®Šå¯¹å¾…å¤´å°¾èŠ‚ç‚¹äº†\n        dummy_head_ = new DLinkedListNode();\n        dummy_tail_ = new DLinkedListNode();\n        dummy_head_->next = dummy_tail_;\n        dummy_tail_->prev = dummy_head_;\n    }\n    \n    int get(int key) {\n        if (!key_exists_(key)) {\n            return -1;\n        }\n        // 1. é€šè¿‡å“ˆå¸Œè¡¨æ‰¾åˆ° key å¯¹åº”çš„èŠ‚ç‚¹\n        // 2. å°†èŠ‚ç‚¹ç§»åˆ°é“¾è¡¨å¤´éƒ¨\n        // 3. è¿”å›èŠ‚ç‚¹å€¼\n        DLinkedListNode *node = key_node_map_[key];\n        move_to_head_(node);\n        return node->value;\n    }\n    \n    void put(int key, int value) {\n        if (key_exists_(key)) {\n            // key å­˜åœ¨çš„æƒ…å†µ\n            DLinkedListNode *node = key_node_map_[key];\n            node->value = value;\n            move_to_head_(node);\n        } else {\n            // key ä¸å­˜åœ¨çš„æƒ…å†µï¼š\n            // 1. å¦‚æœç¼“å­˜ç©ºé—´æ»¡äº†ï¼Œå…ˆåˆ é™¤å°¾èŠ‚ç‚¹ï¼Œå†æ–°å»ºèŠ‚ç‚¹\n            // 2. å¦åˆ™ç›´æ¥æ–°å»ºèŠ‚ç‚¹\n            if (is_full_()) {\n                DLinkedListNode *tail = dummy_tail_->prev;\n                remove_node_(tail);\n                key_node_map_.erase(tail->key);\n            }\n\n            DLinkedListNode *new_node = new DLinkedListNode(key, value);\n            add_to_head_(new_node);\n            key_node_map_[key] = new_node;\n        }\n    }\nprivate:\n    unordered_map<int, DLinkedListNode*> key_node_map_;\n    DLinkedListNode *dummy_head_;\n    DLinkedListNode *dummy_tail_;\n    int capacity_;\n\n    void move_to_head_(DLinkedListNode *node) {\n        remove_node_(node);\n        add_to_head_(node);\n    };\n\n    void add_to_head_(DLinkedListNode *node) {\n        DLinkedListNode *prev_head = dummy_head_->next;\n\n        dummy_head_->next = node;\n        node->prev = dummy_head_;\n\n        node->next = prev_head;\n        prev_head->prev = node;\n    };\n\n    void remove_node_(DLinkedListNode *node) {\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n        node->prev = node->next = NULL;\n    };\n\n    bool key_exists_(int key) {\n        return key_node_map_.count(key) > 0;\n    };\n\n    bool is_full_() {\n        return key_node_map_.size() == capacity_;\n    };\n};\n\n```\n\n## å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦:O(1)\n\nç©ºé—´å¤æ‚åº¦:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196920804","body":"# ã€Day 13ã€‘104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦\n\n## ä»£ç \n\n```C++\nclass Solution {\npublic:\n\tint maxDepth(TreeNode* root) {\n\t\tif (!root)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\treturn max(1 + maxDepth(root->left), 1 + maxDepth(root->right));\n\t}\n};\n```\n\n## å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(H)ï¼ŒHä¸ºäºŒå‰æ ‘çš„é«˜åº¦","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198262873","body":"# ã€Day 14ã€‘100. ç›¸åŒçš„æ ‘\n\n## ä»£ç \n\n```C++\n// Definition for a binary tree node.\nstruct TreeNode {\n\tint val;\n\tTreeNode *left;\n\tTreeNode *right;\n\tTreeNode() : val(0), left(nullptr), right(nullptr) {}\n\tTreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n\tTreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n\t\n};\n\nclass Solution {\npublic:\n\tbool isSameTree(TreeNode* p, TreeNode* q) {\n\t\tif (p == NULL && q == NULL)\n\t\t\treturn true;\n\t\tif (p && q && p->val == q->val)\n\t\t{\n\t\t\treturn isSameTree(q->left, p->left) && isSameTree(p->right, q->right);\n\t\t}\n\t\treturn false;\n\t}\n};\n```\n\n## å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(H)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199292034","body":"# ã€Day 15ã€‘129. æ±‚æ ¹åˆ°å¶å­èŠ‚ç‚¹æ•°å­—ä¹‹å’Œ\n\n## ä»£ç \n\n```C++\nclass Solution {\npublic:\n\tint sumNumbers(TreeNode* root) {\n\t\treturn sumNumbers(root, 0);\n\t}\n\tint sumNumbers(TreeNode* root, int sum)\n\t{\n\t\tif (root)\n\t\t{\n\t\t\tsum = sum * 10 + root->val;\n\t\t\t\n\t\t\tif(root->left && root->right)\n\t\t\t\treturn sumNumbers(root->left, sum) + sumNumbers(root->right, sum);\n\t\t\tif (root->left)\n\t\t\t\treturn sumNumbers(root->left, sum);\n\t\t\tif (root->right)\n\t\t\t\treturn sumNumbers(root->right, sum);\n\t\t}\n\t\treturn sum;\n\t\t\t\n\t}\n};\n```\n\n## å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(H)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1199781818","body":"# ã€Day 16ã€‘513. æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼\n\n## ä»£ç \n\n```C++\n// Lee å±‚æ¬¡éå† BFS\nclass Solution {\n\tint ans;\npublic:\n\tint findBottomLeftValue(TreeNode* root) {\n\t\tqueue<TreeNode*>qt;\n\t\tqt.push(root);\n\t\tint ans = 0;\n\t\twhile (!qt.empty())\n\t\t{\n\t\t\tint size = qt.size();\n\t\t\tTreeNode* tmp = qt.front();\n\t\t\tans = tmp->val;\n\t\t\twhile (size--)\n\t\t\t{\n\t\t\t\tTreeNode* node = qt.front();\n\t\t\t\tqt.pop();\n\n\t\t\t\tif (node->left) \n\t\t\t\t{\n\t\t\t\t\tqt.push(node->left);\n\t\t\t\t}\n\n\t\t\t\tif (node->right) \n\t\t\t\t{\n\t\t\t\t\tqt.push(node->right);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n};\n```\n\n## å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(Q)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200426623","body":"// Definition for a binary tree node.\nstruct TreeNode {\n\tint val;\n\tTreeNode *left;\n\tTreeNode *right;\n\tTreeNode() : val(0), left(nullptr), right(nullptr) {}\n\tTreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n\tTreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n\t\n};\n\n// Error\nclass Codec {\npublic:\n\tvector<string> sroot;\n\n\t// Encodes a tree to a single string.\n\tstring serialize(TreeNode* root) \n\t{\n\t\tstring ans = dfs(root);\n\t\tans.pop_back();\n\t\treturn ans;\n\t}\n\tstring dfs(TreeNode* root)\n\t{\n\t\tif (!root)\n\t\t\treturn \"NULL,\";\n\t\treturn to_string(root->val) + dfs(root->left) + dfs(root->right);\n\n\t}\n\n\t// Decodes your encoded data to tree.\n\tTreeNode* deserialize(string data) \n\t{\n\t\tint i = 0;\n\t\tstring tmp = \"\";\n\t\twhile (i<data.size())\n\t\t{\n\t\t\tif(data[i]!=',')\n\t\t\t\ttmp += data[i];\n\t\t\telse\n\t\t\t{\n\t\t\t\tsroot.emplace_back(tmp);\n\t\t\t\ttmp.clear();\n\t\t\t}\n\t\t\ti += 1;\n\t\t}\n\t\tsroot.emplace_back(tmp);\n\t\treturn dfs(1);\n\t}\n\tTreeNode* dfs(int index)\n\t{\n\t\tif (index >= sroot.size() || sroot[index] == \"NULL\")\n\t\t\treturn NULL;\n\t\tTreeNode* tmp = new TreeNode(stoi(sroot[index]));\n\t\ttmp->left = dfs(2 * index - 1);\n\t\ttmp->right = dfs(2 * index);\n\t\treturn tmp;\n\t}\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201346328","body":"# ã€Day 18ã€‘987. äºŒå‰æ ‘çš„å‚åºéå†\n\n```C++\nclass Solution {\npublic:\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        vector<tuple<int, int, int>> nodes;\n\n        function<void(TreeNode*, int, int)> dfs = [&](TreeNode* node, int row, int col) {\n            if (!node) {\n                return;\n            }\n            nodes.emplace_back(col, row, node->val);\n            dfs(node->left, row + 1, col - 1);\n            dfs(node->right, row + 1, col + 1);\n        };\n\n        dfs(root, 0, 0);\n        sort(nodes.begin(), nodes.end());\n        vector<vector<int>> ans;\n        int lastcol = INT_MIN;\n        for (const auto& [col, row, value]: nodes) {\n            if (col != lastcol) {\n                lastcol = col;\n                ans.emplace_back();\n            }\n            ans.back().push_back(value);\n        }\n        return ans;\n    }\n};\n\n\n```\n\n## å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦:O(NLogN)\n\nç©ºé—´å¤æ‚åº¦:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202894614","body":"# ã€Day 19ã€‘ä¸¤æ•°ä¹‹å’Œ\n\n## ä»£ç \n\n```C++\n// å“ˆå¸Œ\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> map;\n\n        for (int i = 0; i < nums.size(); i++) {\n            int x = nums[i];\n            if (map.count(target - x)) {\n                int index = map[target - x];\n                return {i, index};\n            }\n            map[x] = i;\n        }\n\n        return {};\n    }\n```\n\n## æ—¶å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1204147857","body":"# ã€Day 20ã€‘347. å‰ K ä¸ªé«˜é¢‘å…ƒç´ \n\n## ä»£ç \n\n```c++\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int,int> counts;\n        // è®¡ç®—é¢‘æ¬¡\n        for(int i : nums) counts[i]++;\n        // æœ€å°å †\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> q;\n        // å †ä¸­å…ƒç´ ä¸º [é¢‘æ¬¡ï¼Œæ•°å€¼] å…ƒç»„ï¼Œå¹¶æ ¹æ®é¢‘æ¬¡ç»´æŠ¤å°é¡¶å †ç‰¹æ€§\n        for(auto it : counts) {\n            if (q.size() != k) {\n                q.push(make_pair(it.second, it.first));\n            } else {\n                if (it.second > q.top().first) {\n                    q.pop();\n                    q.push(make_pair(it.second, it.first));\n                }\n            }\n        }\n        vector<int> res;\n        while(q.size()) {\n            res.push_back(q.top().second);\n            q.pop();\n        }\n        return vector<int>(res.rbegin(), res.rend());\n    }\n};\n```\n\n## å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼šO(NLogK)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1207404428","body":"# ã€Day 21ã€‘447. å›æ—‹é•–çš„æ•°é‡\r\n\r\n## ä»£ç \r\n\r\n```C++\r\n// å›ºå®šä¸€ä¸ªç‚¹\r\nclass Solution {\r\npublic:\r\n    int numberOfBoomerangs(vector<vector<int>> &points) {\r\n        int ans = 0;\r\n        for (auto &p : points) {\r\n            unordered_map<int, int> cnt;\r\n            for (auto &q : points) {\r\n                int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\r\n                ++cnt[dis];\r\n            }\r\n            for (auto &[_, m] : cnt) {\r\n                ans += m * (m - 1);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\næ—¶é—´å¤æ‚åº¦ï¼šO(N*N)\r\n\r\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206606570","body":"# ã€Day 22ã€‘3. æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²\n\n## ä»£ç \n\n```C++\n// Error\nclass Solution {\npublic:\n\tint lengthOfLongestSubstring(string s) {\n\t\tunordered_map<char, int> tmp;\n\t\tint ans = 0;\n\t\tint index = 0;\n\t\tfor (int i = 0; i < s.size(); i++)\n\t\t{\n\t\t\tif (tmp.count(s[i]) > 0)\n\t\t\t{\n\t\t\t\tint left = tmp[s[i]] - index;\n\t\t\t\tint right = i - tmp[s[i]];\n\t\t\t\tans = max(ans, max(left, right));\n\t\t\t\tindex = tmp[s[i]];\n\t\t\t\ttmp[s[i]] = i;\n\t\t\t}\n\t\t\telse\n\t\t\t\ttmp[s[i]] = i;\n\t\t}\n\t\tans = max(ans, int(s.size() - index) -1 );\n\t\treturn ans;\n\t}\n};\n```\n\n\n\n## å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207228194","body":"# ã€Day 23ã€‘30. ä¸²è”æ‰€æœ‰å•è¯çš„å­ä¸²\n\n## ä»£ç \n\n```c++\n// Lee Error some examples paased\nclass Solution {\npublic:\n\tvector<int> findSubstring(string s, vector<string>& words) {\n\t\tunordered_map<string, int>judge;\n\t\tvector<int>ans;\n\t\tint len = 0;\n\t\tint wordsLen = words.size();\n\t\tif(words.size())\n\t\t\tlen = words[0].size();\n\t\telse return{};\n\n\t\tfor (int i = 0; i < wordsLen; i++)\n\t\t{\n\t\t\tjudge[words[i]] = 1;\n\t\t}\n\n\t\twordsLen = 0;\n\t\tfor (auto k = judge.begin(); k != judge.end(); k++)\n\t\t\twordsLen += 1;\n\n\t\tfor (int i = 0; i < s.size() - len + 1; i++)\n\t\t{\n\t\t\tint flag = 1;\n\t\t\tfor (int j = i, k = 0; j < s.size() - len + 1 && k <wordsLen; j += len, k+=1)\n\t\t\t{\n\t\t\t\tstring tmp = s.substr(j, len);\n\t\t\t\tif (judge.count(tmp) > 0 && judge[tmp])\n\t\t\t\t{\n\t\t\t\t\t//judge[tmp] = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tflag = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t\tans.emplace_back(i);\n\t\t\tfor (auto k = judge.begin(); k != judge.end(); k++)\n\t\t\t\tk->second = 1;\n\t\t\t\n\t\t}\n\t\treturn ans;\n\t}\n};\n```\n\n## å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼šO(N*N)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207339450","body":"# ã€Day 24ã€‘Delete Sublist to Make Sum Divisible By K\n\nhttps://binarysearch.com/problems/Delete-Sublist-to-Make-Sum-Divisible-By-K\n\n## ä»£ç \n\n```C++\n// å‰ç¼€å’Œï¼ŒåŒä½™å®šç†\nint floorMod(const int& a, const int& b)\n{\n    return (a % b + b) % b;\n}\nint solve(vector<int>& nums, int k) {\n    int allSum = 0;\n    for (int& num : nums)\n        allSum += num;\n\n    allSum = floorMod(allSum, k);\n    unordered_map<int, int> dict;\n    dict[0] = -1;\n\n    int preSum = 0;\n    int minLen = nums.size();\n    for (int i = 0; i < nums.size(); i++) {\n        preSum += nums[i];\n        int mod = floorMod(preSum, k);\n        dict[mod] = i;\n\n        if (dict.count(floorMod(preSum - allSum, k)))\n            minLen = min(minLen, i - dict[floorMod(preSum - allSum, k)]);\n    }\n    return minLen == nums.size() ? -1 : minLen;\n}\n```\n\n## å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(min(N,K))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208296054","body":"# ã€Day 25ã€‘876. é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹\n\n## ä»£ç \n\n```c++\n// Definition for singly-linked list.\n// å¿«æ…¢æŒ‡é’ˆ\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n \nclass Solution {\npublic:\n\tListNode* middleNode(ListNode* head) {\n\t\tListNode* slow = head;\n\t\tListNode* fast = head;\n\t\twhile (fast != NULL && fast->next != NULL) {\n\t\t\tslow = slow->next;\n\t\t\tfast = fast->next->next;\n\t\t}\n\t\treturn slow;\n\t}\n};\n```\n\n## å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209572522","body":"# ã€Day 26ã€‘26.åˆ é™¤æ’åºæ•°ç»„ä¸­çš„é‡å¤é¡¹\n\n## ä»£ç \n\n```C++\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int n = nums.size();\n        if (n == 0) {\n            return 0;\n        }\n        int fast = 1, slow = 1;\n        while (fast < n) {\n            if (nums[fast] != nums[fast - 1]) {\n                nums[slow] = nums[fast];\n                ++slow;\n            }\n            ++fast;\n        }\n        return slow;\n    }\n};\n```\n\n## å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elon-lau":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185677997","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°\n\n##ä»£ç \n\n```python\n#ä»£ç \nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        temp = \"\"\n        for i in num:\n            temp += str(i)\n        temp = int(temp) + k\n        print([i for i in str(temp)])\n        return [int(i) for i in str(temp)]\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: O(n)\n> + ç©ºé—´å¤æ‚åº¦: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186222102","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°\n\n##ä»£ç \n\n```python\n#ä»£ç \nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        temp_list = []\n        for i in range(len(s)):\n            temp_int = 0\n            while True:\n                if i - temp_int >= 0:\n                    if s[i-temp_int] == c:\n                        break\n                if i + temp_int <= len(s) - 1:\n                    if s[i+temp_int] == c:\n                        break\n                temp_int += 1\n            temp_list.append(temp_int)\n        return temp_list\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: O(n^2)\n> + ç©ºé—´å¤æ‚åº¦: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186522716","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°\n\n## ä»£ç \n\n```python\n# ä»£ç \nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if len(self.stack) > 0:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack) >= k:\n            for i in range(k):\n                self.stack[i] += val\n        else:\n            for i in range(len(self.stack)):\n                self.stack[i] += val\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: \n> + ç©ºé—´å¤æ‚åº¦:\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187670227","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°\n\n## ä»£ç \n\n```python\n# ä»£ç \nclass Solution:\n    def decodeString(self, s: str) -> str:\n\n        stack = []\n        nums = 0\n        for char in s:\n            if char.isdigit(): \n                nums = nums*10 + int(char)\n            elif char != ']':  \n                if nums!=0:\n                    stack.append(nums)\n                    nums = 0\n                stack.append(char)\n            else:  \n                tmp_s = ''\n                while stack[-1]!='[':\n                    tmp_s = stack.pop(-1) + tmp_s\n                stack.pop(-1)\n                num = stack.pop(-1) \n                stack.append(num * tmp_s)\n\n        return ''.join(stack)  \n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: \n> + ç©ºé—´å¤æ‚åº¦:\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189048751","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°\nç”¨åŒæ ˆæ¨¡æ‹Ÿé˜Ÿåˆ—ã€‚\n\n## ä»£ç \n\n```python\nclass MyQueue(object):\n\n    def __init__(self):\n        self.instack = []\n        self.outstack = []\n\n    def push(self, x):\n        self.instack.append(x)\n\n    def pop(self):\n        if len(self.outstack) == 0:\n            while self.instack:\n                self.outstack.append(self.instack.pop())\n        return self.outstack.pop()\n\n    def peek(self):\n        if len(self.outstack) == 0:\n            while self.instack:\n                self.outstack.append(self.instack.pop())\n        return self.outstack[-1]\n    def empty(self):\n        return len(self.instack) == 0 and len(self.outstack) == 0\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: \n> + ç©ºé—´å¤æ‚åº¦:\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190128976","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°\n\n## ä»£ç \n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: [int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]: \n                head = stack.pop()\n                while stack and num < stack[-1]: \n                    stack.pop()\n                stack.append(head)\n            else: \n                stack.append(num)\n        return len(stack)\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: \n> + ç©ºé—´å¤æ‚åº¦:\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191605086","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°\n\n## ä»£ç \n\n```python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if k == 0 or not head or not head.next:\n            return head\n        \n        n = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            n += 1\n        \n        if (add := n - k % n) == n:\n            return head\n        \n        cur.next = head\n        while add:\n            cur = cur.next\n            add -= 1\n        \n        ret = cur.next\n        cur.next = None\n        return ret\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: \n> + ç©ºé—´å¤æ‚åº¦:\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192687822","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°\n\n## ä»£ç \n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        newHead = head.next\n        head.next = self.swapPairs(newHead.next)\n        newHead.next = head\n        return newHead\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: \n> + ç©ºé—´å¤æ‚åº¦:\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193274569","body":"## æ€è·¯\n\nåˆ†æ²»ç®—æ³•\n\n> + æ€è·¯æè¿°\n\n## ä»£ç \n\n```python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def getMedian(left: ListNode, right: ListNode) -> ListNode:\n            fast = slow = left\n            while fast != right and fast.next != right:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n        \n        def buildTree(left: ListNode, right: ListNode) -> TreeNode:\n            if left == right:\n                return None\n            mid = getMedian(left, right)\n            root = TreeNode(mid.val)\n            root.left = buildTree(left, mid)\n            root.right = buildTree(mid.next, right)\n            return root\n        \n        return buildTree(head, None)\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: O(nlogn)\n> + ç©ºé—´å¤æ‚åº¦: O(logn)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193314975","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°\nåŒæŒ‡é’ˆ\n## ä»£ç \n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        if not headA or not headB:\n            return None\n        \n        pointer1, pointer2 = headA, headB\n\n        while pointer1 != pointer2:\n            if pointer1 != None:\n                pointer1 = pointer1.next\n            else:\n                pointer1 = headB\n            if pointer2 != None:\n                pointer2 = pointer2.next\n            else:\n                pointer2 = headA\n\n        return pointer1\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: \n> + ç©ºé—´å¤æ‚åº¦:\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194105778","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°\n\n## ä»£ç \n\n```python\nclass Solution(object):\n    def detectCycle(self, head):\n        fast, slow = head, head\n        while True:\n            if not (fast and fast.next): return\n            fast, slow = fast.next.next, slow.next\n            if fast == slow: break\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: O(N)\n> + ç©ºé—´å¤æ‚åº¦: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195643054","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°\n\n## ä»£ç \n\n```python\nclass LRUCache(collections.OrderedDict):\n\n    def __init__(self, capacity: int):\n        super().__init__()\n        self.capacity = capacity\n\n\n    def get(self, key: int) -> int:\n        if key not in self:\n            return -1\n        self.move_to_end(key)\n        return self[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self:\n            self.move_to_end(key)\n        self[key] = value\n        if len(self) > self.capacity:\n            self.popitem(last=False)\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: \n> + ç©ºé—´å¤æ‚åº¦:\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196941657","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°\n\n## ä»£ç \n\n```python\nclass Solution:\n    def maxDepth(self, root):\n        if root is None: \n            return 0 \n        else: \n            left_height = self.maxDepth(root.left) \n            right_height = self.maxDepth(root.right) \n            return max(left_height, right_height) + 1 \n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: \n> + ç©ºé—´å¤æ‚åº¦:\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198038332","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°\n\n## ä»£ç \n\n```python\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: \n> + ç©ºé—´å¤æ‚åº¦:\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199568989","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°\n\n## ä»£ç \n\n```python\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        def dfs(root: TreeNode, prevTotal: int) -> int:\n            if not root:\n                return 0\n            total = prevTotal * 10 + root.val\n            if not root.left and not root.right:\n                return total\n            else:\n                return dfs(root.left, total) + dfs(root.right, total)\n\n        return dfs(root, 0)\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: \n> + ç©ºé—´å¤æ‚åº¦:\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200174320","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°\n\n## ä»£ç \n\n```python\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        curVal = curHeight = 0\n        def dfs(node: Optional[TreeNode], height: int) -> None:\n            if node is None:\n                return\n            height += 1\n            dfs(node.left, height)\n            dfs(node.right, height)\n            nonlocal curVal, curHeight\n            if height > curHeight:\n                curHeight = height\n                curVal = node.val\n        dfs(root, 0)\n        return curVal\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: \n> + ç©ºé—´å¤æ‚åº¦:\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200449677","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°\n\n## ä»£ç \n\n```python\nclass Codec:\n\n    def serialize(self, root):\n        if not root:return \"null,\"\n        left=self.serialize(root.left)\n        right=self.serialize(root.right)\n        return str(root.val)+','+left+right\n        \n\n    def deserialize(self, data):\n        data=data.split(',')\n        root=self.helper(data)\n        return root\n\n    def helper(self,data):\n        val=data.pop(0)\n        if val=='null':return None\n        node=TreeNode(val)\n        node.left=self.helper(data)\n        node.right=self.helper(data)\n        return node\n\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: \n> + ç©ºé—´å¤æ‚åº¦:\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201385018","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°\n\n## ä»£ç \n\n```python\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        nodes = list()\n\n        def dfs(node: TreeNode, row: int, col: int) -> None:\n            if not node:\n                return\n\n            nodes.append((col, row, node.val))\n            dfs(node.left, row + 1, col - 1)\n            dfs(node.right, row + 1, col + 1)\n\n        dfs(root, 0, 0)\n        nodes.sort()\n        ans, lastcol = list(), float(\"-inf\")\n\n        for col, row, value in nodes:\n            if col != lastcol:\n                lastcol = col\n                ans.append(list())\n            ans[-1].append(value)\n        \n        return ans\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: \n> + ç©ºé—´å¤æ‚åº¦:\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202371021","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°\n\n## ä»£ç \n\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[i] + nums[j] == target:\n                    return [i, j]\n        \n        return []\n\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: \n> + ç©ºé—´å¤æ‚åº¦:\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203848843","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°\n\n## ä»£ç \n\n```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        if len(nums) <= k:\n            return list(set(nums))\n        from collections import defaultdict\n        result = defaultdict(int)\n        for i in nums:\n            result[i] += 1\n        ans = []\n        for key,value in result.items():\n            ans.append([key,value])\n        ans.sort(key=lambda x:x[1],reverse = True)\n        temp = []\n        for i in range(k):\n            temp.append(ans[i][0])\n        return temp\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: \n> + ç©ºé—´å¤æ‚åº¦:\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206601584","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°\n\n## ä»£ç \n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        # å“ˆå¸Œé›†åˆï¼Œè®°å½•æ¯ä¸ªå­—ç¬¦æ˜¯å¦å‡ºç°è¿‡\n        occ = set()\n        n = len(s)\n        # å³æŒ‡é’ˆï¼Œåˆå§‹å€¼ä¸º -1ï¼Œç›¸å½“äºæˆ‘ä»¬åœ¨å­—ç¬¦ä¸²çš„å·¦è¾¹ç•Œçš„å·¦ä¾§ï¼Œè¿˜æ²¡æœ‰å¼€å§‹ç§»åŠ¨\n        rk, ans = -1, 0\n        for i in range(n):\n            if i != 0:\n                # å·¦æŒ‡é’ˆå‘å³ç§»åŠ¨ä¸€æ ¼ï¼Œç§»é™¤ä¸€ä¸ªå­—ç¬¦\n                occ.remove(s[i - 1])\n            while rk + 1 < n and s[rk + 1] not in occ:\n                # ä¸æ–­åœ°ç§»åŠ¨å³æŒ‡é’ˆ\n                occ.add(s[rk + 1])\n                rk += 1\n            # ç¬¬ i åˆ° rk ä¸ªå­—ç¬¦æ˜¯ä¸€ä¸ªæé•¿çš„æ— é‡å¤å­—ç¬¦å­ä¸²\n            ans = max(ans, rk - i + 1)\n        return ans\n\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: \n> + ç©ºé—´å¤æ‚åº¦:\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207225223","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°\n\n## ä»£ç \n\n```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        res = []\n        m, n, ls = len(words), len(words[0]), len(s)\n        for i in range(n):\n            if i + m * n > ls:\n                break\n            differ = Counter()\n            for j in range(m):\n                word = s[i + j * n: i + (j + 1) * n]\n                differ[word] += 1\n            for word in words:\n                differ[word] -= 1\n                if differ[word] == 0:\n                    del differ[word]\n            for start in range(i, ls - m * n + 1, n):\n                if start != i:\n                    word = s[start + (m - 1) * n: start + m * n]\n                    differ[word] += 1\n                    if differ[word] == 0:\n                        del differ[word]\n                    word = s[start - n: start]\n                    differ[word] -= 1\n                    if differ[word] == 0:\n                        del differ[word]\n                if len(differ) == 0:\n                    res.append(start)\n        return res\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: \n> + ç©ºé—´å¤æ‚åº¦:\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207387866","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°\n\n## ä»£ç \n\n```python\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        res = n = len(nums)\n        mod = sum(nums) % p\n        if mod == 0: \n            return 0\n        hashmap = {0: -1}\n        sub_mod = 0\n        for i, num in enumerate(nums):\n            sub_mod = (sub_mod + num) % p\n            target = (sub_mod - mod + p) % p\n            if target in hashmap:\n                res = min(res, i - hashmap[target])\n                if res == 1 and res != n:\n                    return res\n            hashmap[sub_mod] = i\n        if res == n:\n            res = -1\n        return res\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: \n> + ç©ºé—´å¤æ‚åº¦:\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208285035","body":"## æ€è·¯\n\n> + æ€è·¯æè¿°\n\nå¿«æ…¢æŒ‡é’ˆæ³•ã€‚\n\n## ä»£ç \n\n```python\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n\n```\n\n## å¤æ‚åº¦\n\n> + æ—¶é—´å¤æ‚åº¦: O(N)\n> + ç©ºé—´å¤æ‚åº¦: O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nowkizzz":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185679498","body":"var addToArrayForm = function(num, k) {\n    const res = [];\n    const nLen = num.length;\n    for (let i = nLen  - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1191420794","body":"## æ€è·¯\n1. è®°å½•cåœ¨sçš„æ‰€æœ‰ç´¢å¼•ï¼Œå½¢æˆç´¢å¼•åˆ—è¡¨\n2. éå†sï¼Œå¹¶æ¯æ¬¡å¯¹ç´¢å¼•åˆ—è¡¨çš„æ•°å€¼è¿›è¡Œæ¯”è¾ƒï¼Œå¾—å‡ºç»å¯¹å€¼çš„æœ€å°å€¼\n\n## ä»£ç \n```js\nvar shortestToChar = function(s, c) {\n   var cIndexList = []\n    for(var i = 0, len = s.length; i < len; i++) {\n        if (s[i] === c) {\n        cIndexList.push(i)\n        }\n    }\n    var arr = []\n    for(var i = 0, len = s.length; i < len; i++) {\n        var distance = Math.abs(cIndexList[0] - i);\n        for(var j = 1; j < cIndexList.length;j++) {\n        distance = Math.min(Math.abs(cIndexList[j] -i), distance)\n        }\n        arr.push(distance)\n    }\n    return arr;\n};\n```\n\n##  å¤æ‚åº¦\n- æ—¶é—´ O(n)\n- ç©ºé—´ O(n)\n\n\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1200105457","body":"## æ€è·¯\næŒ‰ç…§æ•°ç»„åŸºæœ¬çš„pushï¼Œpopçš„æ€è·¯è¿›è¡Œè§£ç­”ã€JavaScriptã€‘\n\n## ä»£ç \n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize;\n    this.stack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.stack.length >= this.maxSize) return;\n    this.stack.push(x)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (this.stack.length === 0) return -1;\n    return this.stack.pop()\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    const length = Math.min(this.stack.length, k)\n    for(let i = 0; i < length; i++) {\n        this.stack[i] += val;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n## å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦ O(1ï¼‰\n- ç©ºé—´å¤æ‚åº¦ O(n)\n","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gsgtgyb":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185681120","body":"### æ€è·¯\nè€ƒè™‘åˆ°æ•°ç»„é•¿åº¦è¿‡é•¿ï¼Œä¸èƒ½è¿›è¡Œç´¯åŠ åè½¬æ¢ï¼Œé‡‡å–é€ä½ç´¯åŠ çš„æ–¹å¼ï¼Œæ•°ç»„æœ«å°¾ç´¯åŠ ä¹‹kä¸Šï¼Œå–ä½™ã€‚æœ¬äººé‡‡å–çš„æ˜¯arraylistï¼Œå‚è€ƒç­”æ¡ˆåæ”¹ä¸ºlinkedlist\n### ä»£ç \n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n       int j = k;\n        int i = num.length -1;\n        LinkedList list = new LinkedList();\n        while (i >= 0 || j > 0) {\n            if (i>=0) {\n                j = j + num[i];\n            }\n            list.addFirst(j%10);\n            j = j / 10;\n            i--;\n        }\n        return list;\n    }\n}\n```\n### å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦ï¼šO(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191564683","body":"### æ€è·¯\n1. æ„å»ºå¾ªç¯é“¾è¡¨\n2. å¯»æ‰¾ç ´åœˆèŠ‚ç‚¹\n3.ç ´åœˆ\n### ä»£ç \n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head,int k) {\n        if (Objects.equals(head,null)) {\n            return head;\n        }\n        ListNode trailNode = getTrailNode(head);\n        ListNode top = head;\n        int length = getLength(head);\n        int pos = 0;\n        if(length == 0) {\n            pos = 0;\n        } else {\n            pos = length - k % length - 1;\n        }\n        int count = 0;\n        trailNode.next = top;\n        while (!top.next.equals(null)) {\n            if (count == pos) {\n                head = top.next;\n                top.next = null;\n                break;\n            } else {\n                count++;\n                top = top.next;\n            }\n        }\n        return head;\n    }\n    public int getLength(ListNode head) {\n        if (Objects.equals(head,null)) {\n            return 0;\n        }\n        int length = 1;\n        while (!Objects.equals(head.next,null)) {\n            length++;\n            head = head.next;\n        }\n        return length;\n    }\n    public ListNode getTrailNode(ListNode head) {\n        if (Objects.equals(head,null)) {\n            return head;\n        }\n        while (!Objects.equals(head.next,null)) {\n            head = head.next;\n        }\n        return head;\n    }\n}\n```\n### å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦ï¼šO(n)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198307502","body":"### æ€è·¯\næ„å»ºå®Œå…¨äºŒå‰æ ‘ï¼Œå…ˆåºéå†äºŒå‰æ ‘ï¼Œå› ä¸ºç›¸åŒçš„å…ˆåºéå†äºŒå‰æ ‘ä¸ä¸€å®šä¸€æ ·ï¼Œæ•…ç”±ç©ºèŠ‚ç‚¹æ„å»ºå®Œå…¨äºŒå‰æ ‘\n### ä»£ç \n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p,TreeNode q) {\n        String treeNodeList1 = getTreeNodeList(p);\n        String treeNodeList2 = getTreeNodeList(q);\n        if (Objects.equals(treeNodeList1,treeNodeList2)) {\n            return true;\n        }\n        return false;\n    }\n    public String getTreeNodeList(TreeNode t) {\n        if (Objects.equals(t,null)) {\n            return null;\n        }\n        return t.val + \",\" + getTreeNodeList(t.left) + \",\" + getTreeNodeList(t.right);\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"irenia111":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185681843","body":"var addToArrayForm = function(A, K) {\n        const res = [];\n        const n = A.length;\n        for (let i = n - 1; i >= 0; --i) {\n        let sum = A[i] + K % 10;\n        K = Math.floor(K / 10);\n        if (sum >= 10) {\n          K++;\n            sum -= 10;\n        }\n        res.push(sum);\n      }\n        for (; K > 0; K = Math.floor(K / 10)) {\n        res.push(K % 10);\n      }\n        res.reverse();\n        return res;\n      };","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186188832","body":"```\r\nvar shortestToChar = function(S, C) {\r\n    let res = [];\r\n    const sArr = S.split('');\r\n    for(let i=0;i<sArr.length;i++){\r\n        let leftArr;\r\n        let rightArr;\r\n        const curChar = sArr[i];\r\n        if(curChar === C){\r\n            res.push(0)\r\n        }else{\r\n            leftArr = sArr.slice(0, i).reverse();\r\n            rightArr = sArr.slice(i+1);\r\n            const leftDis = leftArr.indexOf(C) + 1;\r\n            const rightDis = rightArr.indexOf(C) + 1;\r\n            if(leftDis === 0){\r\n                res.push(rightDis)\r\n            }\r\n            if(rightDis === 0){\r\n                res.push(leftDis);\r\n            }\r\n            if(leftDis > 0 && rightDis > 0){\r\n                res.push(Math.min(leftDis, rightDis));\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186552331","body":"```\r\nvar CustomStack = function (maxSize) {\r\n    this.top = 0;\r\n    this.add = new Array(maxSize).fill(0);\r\n    this.stack = new Array(maxSize).fill(0);\r\n};\r\nCustomStack.prototype.push = function (val) {\r\n    if (this.top === this.stack.length) return;\r\n    this.stack[this.top] = val;\r\n    this.add[this.top] = 0;\r\n    this.top += 1;\r\n};\r\nCustomStack.prototype.pop = function () {\r\n    if (this.top === 0) return -1;\r\n    this.top -= 1;\r\n    if (this.top > 0)\r\n        this.add[this.top - 1] += this.add[this.top];\r\n    return this.stack[this.top] + this.add[this.top];\r\n};\r\nCustomStack.prototype.increment = function (k, val) {\r\n    let len = Math.min(k, this.top);\r\n    if (len === 0) return;\r\n    this.add[len - 1] += val;\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187671696","body":"```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        if (s == null || s.length() == 0) {\r\n            return \"\";\r\n        }\r\n        Deque<Integer> times = new ArrayDeque<>();\r\n        Deque<StringBuilder> dq = new ArrayDeque<>();\r\n        StringBuilder sb = new StringBuilder();\r\n        int index = 0;                               // index:å·²ç»å¤„ç†å¥½çš„å­—æ®µ\r\n        char ch = s.charAt(0);\r\n        OUT:\r\n        while (true) {\r\n            int i = index;\r\n            if (ch >= '0' && ch <= '9') {\r\n                while (ch >= '0' && ch <= '9') {\r\n                    ch = s.charAt(++i);\r\n                }\r\n                times.push(Integer.parseInt(s.substring(index, i)));\r\n                index = ++i;                            // è·³è¿‡'['\r\n                ch = s.charAt(i);\r\n            }\r\n            dq.push(sb);                               // æ‹¿åˆ°æ–°æ•°å­—ï¼Œè¦å¦èµ·ç‚‰ç¶\r\n            sb = new StringBuilder();\r\n            while (ch < '0' || ch > '9') {\r\n                if (ch == ']') {\r\n                    int time = times.pop();              // å­—ç¬¦ä¸²å¤åˆ¶\r\n                    String str = sb.toString();\r\n                    for (int j = 1;j < time;j++) {\r\n                        sb.append(str);\r\n                    }\r\n                    sb = dq.pop().append(sb);       // è¿æ¥åˆ°ä¸Šä¸€æ®µæœ«å°¾\r\n                } else {\r\n                    sb.append(ch);\r\n                }\r\n                index = ++i;                                // è·³è¿‡']'\r\n                if (i == s.length()) {\r\n                    break OUT;\r\n                }\r\n                ch = s.charAt(i);\r\n            }\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189187847","body":"```\r\nclass MyQueue {\r\n    private Stack<Integer> a;// è¾“å…¥æ ˆ\r\n    private Stack<Integer> b;// è¾“å‡ºæ ˆ\r\n    \r\n    public MyQueue() {\r\n        a = new Stack<>();\r\n        b = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        a.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        // å¦‚æœbæ ˆä¸ºç©ºï¼Œåˆ™å°†aæ ˆå…¨éƒ¨å¼¹å‡ºå¹¶å‹å…¥bæ ˆä¸­ï¼Œç„¶åb.pop()\r\n        if(b.isEmpty()){\r\n            while(!a.isEmpty()){\r\n                b.push(a.pop());\r\n            }\r\n        }\r\n        return b.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if(b.isEmpty()){\r\n            while(!a.isEmpty()){\r\n                b.push(a.pop());\r\n            }\r\n        }\r\n        return b.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return a.isEmpty() && b.isEmpty();\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190443778","body":"```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> s = new Stack<>();\r\n        for(int i=0;i<arr.length;i++){\r\n            int v = -1;\r\n            while(!s.isEmpty() && s.peek()>arr[i]){\r\n                v=Math.max(v,s.pop());\r\n            }\r\n            if(v!=-1)\r\n                s.push(v);\r\n            else\r\n                s.push(arr[i]);\r\n        }\r\n        return s.size();\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191619861","body":"```\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null){\r\n            return head;\r\n        }\r\n        int len = 1;\r\n        ListNode p = head;\r\n        while(p.next!=null){\r\n            p=p.next;\r\n            len++;\r\n        }\r\n        k = k%len;\r\n        if(k==0){\r\n            return head;\r\n        }\r\n        p.next = head;\r\n        int cnt = len-k;\r\n        while(cnt>1){\r\n            head = head.next;\r\n            cnt--;\r\n        }\r\n        p=head;\r\n        head = head.next;\r\n        p.next = null;\r\n        return head;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192689553","body":"```\r\nvar swapPairs = function (head) {\r\n  let ret = new ListNode(0, head), temp = ret;\r\n  while (temp.next && temp.next.next) {\r\n    let cur = temp.next.next, pre = temp.next;\r\n    pre.next = cur.next;\r\n    cur.next = pre;\r\n    temp.next = cur;\r\n    temp = pre;\r\n  }\r\n  return ret.next;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193144366","body":"```\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if(head == null) return null;\r\n        if(head.next == null) return new TreeNode(head.val);\r\n\r\n        // lowæ˜¯ä¸­ç‚¹ï¼Œpreæ˜¯lowçš„å‰ä¸€ä¸ªç»“ç‚¹ï¼Œå› ä¸ºæ–­å¼€éœ€è¦ç½®ç©º\r\n        ListNode pre = null;\r\n        ListNode fast = head;\r\n        ListNode low = head;\r\n\r\n        while(fast != null && fast.next != null){\r\n            fast = fast.next.next;\r\n            pre = low;\r\n            low = low.next;\r\n        }\r\n        pre.next = null;\r\n        TreeNode root = new TreeNode(low.val, sortedListToBST(head), sortedListToBST(low.next));\r\n\r\n        return root;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193327432","body":"```\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode curA = headA;\r\n        ListNode curB = headB;\r\n        int lenA = 0, lenB = 0;\r\n        while (curA != null) { // æ±‚é“¾è¡¨Açš„é•¿åº¦\r\n            lenA++;\r\n            curA = curA.next;\r\n        }\r\n        while (curB != null) { // æ±‚é“¾è¡¨Bçš„é•¿åº¦\r\n            lenB++;\r\n            curB = curB.next;\r\n        }\r\n        curA = headA;\r\n        curB = headB;\r\n        // è®©curAä¸ºæœ€é•¿é“¾è¡¨çš„å¤´ï¼ŒlenAä¸ºå…¶é•¿åº¦\r\n        if (lenB > lenA) {\r\n            //1. swap (lenA, lenB);\r\n            int tmpLen = lenA;\r\n            lenA = lenB;\r\n            lenB = tmpLen;\r\n            //2. swap (curA, curB);\r\n            ListNode tmpNode = curA;\r\n            curA = curB;\r\n            curB = tmpNode;\r\n        }\r\n        // æ±‚é•¿åº¦å·®\r\n        int gap = lenA - lenB;\r\n        // è®©curAå’ŒcurBåœ¨åŒä¸€èµ·ç‚¹ä¸Šï¼ˆæœ«å°¾ä½ç½®å¯¹é½ï¼‰\r\n        while (gap-- > 0) {\r\n            curA = curA.next;\r\n        }\r\n        // éå†curA å’Œ curBï¼Œé‡åˆ°ç›¸åŒåˆ™ç›´æ¥è¿”å›\r\n        while (curA != null) {\r\n            if (curA == curB) {\r\n                return curA;\r\n            }\r\n            curA = curA.next;\r\n            curB = curB.next;\r\n        }\r\n        return null;\r\n    }\r\n    \r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194215586","body":"```\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        HashSet<ListNode> hashSet=new HashSet<>();\r\n        ListNode cur=new ListNode(0);\r\n        cur.next=head;\r\n        \r\n        while(hashSet.add(cur)!=false){\r\n            if(cur==null){\r\n                return null;\r\n            }\r\n            cur=cur.next;\r\n        }\r\n        \r\n        return cur;\r\n\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1196171150","body":"```\r\nclass LRUCache1465 {\r\n    int capacity;\r\n    LinkedHashMap<Integer, Integer> cache;\r\n\r\n    public LRUCache1465(int capacity) {\r\n        this.capacity = capacity;\r\n\r\n        //é‡ç‚¹åœ¨è¿™é‡Œï¼ï¼\r\n        cache = new LinkedHashMap<Integer, Integer>(capacity, 0.75f, true) {\r\n            @Override\r\n            protected boolean removeEldestEntry(Map.Entry eldest) {\r\n                return cache.size() > capacity;\r\n            }\r\n        };\r\n    }\r\n\r\n    public int get(int key) {\r\n        return cache.getOrDefault(key, -1);\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        cache.put(key, value);\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196171408","body":"```\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        int lay=0;                //è®°å½•å±‚æ•°\r\n        queue<TreeNode *> QT;\r\n        if(root==nullptr)\r\n            return 0;\r\n        QT.push(root);       //å¤´ç»“ç‚¹å…¥é˜Ÿ\r\n        while(!QT.empty()){     //å¦‚æœé˜Ÿåˆ—ä¸ä¸ºç©º\r\n            int len=QT.size();  //è®°å½•æœ¬å±‚ç»“ç‚¹ä¸ªæ•°\r\n            lay++;\r\n            for(int i=0;i<len;i++){\r\n                TreeNode *node=QT.front();\r\n                QT.pop();    //æœ€å‰ç»“ç‚¹å‡ºé˜Ÿ\r\n                if(node->left!=nullptr)\r\n                    QT.push(node->left);//å…¶å·¦å³å­ç»“ç‚¹å…¥é˜Ÿ\r\n                if(node->right!=nullptr)\r\n                    QT.push(node->right);\r\n            }\r\n        }\r\n        return lay;             //è¿”å›å±‚æ•°\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198326639","body":"```\r\n  public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if(p == null && q == null) return true;//å‡å¦‚ä¸¤ä¸ªç»“ç‚¹éƒ½ä¸ºç©ºè¯´æ˜ä¸¤ä¸ªç»“ç‚¹ç›¸ç­‰\r\n        if(p == null&& q!= null || p != null && q == null) return false;\r\n        //å‡å¦‚ä¸€ä¸ªç»“ç‚¹ä¸ºç©º å¦å¤–ä¸€ä¸ªä¸ä¸ºç©ºè¯´æ˜ä¸ç›¸ç­‰\r\n        if(p.val != q.val) return false;\r\n        //å‡å¦‚ä¸¤ä¸ªç»“ç‚¹çš„å€¼ä¸ä¸€æ ·é‚£ä¹ˆä¹Ÿæ˜¯é”™è¯¯çš„\r\n        //ä¸‰ä¸ªæ¡ä»¶ä¸€æ­¥ä¸€æ­¥èµ°ä¸€æ­¥ä¸€æ­¥åˆ¤æ–­\r\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\r\n        //æœ€åä¸€æ­¥é€’å½’ å‡å¦‚å·¦å­æ ‘å’Œå³å­æ ‘éƒ½ä¸ºtrueè¯´æ˜å·¦å³å­æ ‘éƒ½ç›¸ç­‰,è¿”å›true å¦åˆ™false;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199517017","body":"\r\n```\r\nclass Solution {\r\n    static int sum;\r\n    public int sumNumbers(TreeNode root) {\r\n        sum = 0;\r\n        childSum(0, root);\r\n        return sum;\r\n    }\r\n    public static void  childSum(int val, TreeNode root) {\r\n        if(root == null) return;\r\n        int k = (val * 10 + root.val) ;\r\n        if(root.left == null && root.right == null) {\r\n            sum += k;\r\n        }\r\n        childSum(k, root.left);\r\n        childSum(k, root.right);\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200225034","body":"```\r\nclass Solution {\r\n    public int findBottomLeftValue(TreeNode root) {\r\n        Queue<TreeNode> queue = new LinkedList<>();\r\n        queue.offer(root);\r\n        while(!queue.isEmpty()){\r\n            root = queue.poll();\r\n            if (root.right != null) queue.offer(root.right);\r\n            if (root.left != null) queue.offer(root.left);\r\n        }\r\n        return root.val;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200427894","body":"```\r\npublic class Codec {\r\n\r\n    public String serialize(TreeNode root) {      //ç”¨StringBuilder\r\n        StringBuilder res = ser_help(root, new StringBuilder());\r\n        return res.toString();\r\n    }\r\n    \r\n    public StringBuilder ser_help(TreeNode root, StringBuilder str){\r\n        if(null == root){\r\n            str.append(\"null,\");\r\n            return str;\r\n        }\r\n        str.append(root.val); \r\n        str.append(\",\");\r\n        str = ser_help(root.left, str);\r\n        str = ser_help(root.right, str);\r\n        return str;\r\n    }\r\n\r\n    public TreeNode deserialize(String data) {\r\n        String[] str_word = data.split(\",\");\r\n        List<String> list_word = new LinkedList<String>(Arrays.asList(str_word));\r\n        return deser_help(list_word);\r\n    }\r\n    \r\n    public TreeNode deser_help(List<String> li){\r\n        if(li.get(0).equals(\"null\")){\r\n            li.remove(0);\r\n            return null;\r\n        }\r\n        TreeNode res = new TreeNode(Integer.valueOf(li.get(0)));\r\n        li.remove(0);\r\n        res.left = deser_help(li);\r\n        res.right = deser_help(li);\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201303632","body":"```\r\nclass Solution {\r\n    public List<Tuple> list;\r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n        list = new ArrayList<>();\r\n        dfs(root,0,0);\r\n\r\n        list.sort((t1,t2)->{\r\n            int num1 = t1.y-t2.y;\r\n            int num2 = num1==0? t1.x-t2.x:num1;\r\n            int num3 = num2==0? t1.val-t2.val:num2;\r\n            return num3;\r\n        });\r\n\r\n        List<List<Integer>> res = new ArrayList<>();\r\n        int last = Integer.MIN_VALUE;\r\n        for(Tuple tuple:list){\r\n            if(tuple.y!=last){\r\n                last = tuple.y;\r\n                List<Integer> temp = new ArrayList<>();\r\n                temp.add(tuple.val);\r\n                res.add(temp);\r\n            }\r\n            else{\r\n                res.get(res.size()-1).add(tuple.val);\r\n            }\r\n        }\r\n        return res;\r\n\r\n    }\r\n\r\n    public void dfs(TreeNode root,int x,int y){\r\n        if(root == null) return;\r\n        dfs(root.left,x+1,y-1);\r\n        list.add(new Tuple(root.val,x,y));\r\n        dfs(root.right,x+1,y+1);\r\n    }\r\n\r\n    public class Tuple{\r\n        int val;\r\n        int x;\r\n        int y;\r\n        public Tuple(int val,int x,int y){\r\n            this.val = val;\r\n            this.x = x;\r\n            this.y = y;\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202971814","body":"```\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int target) {\r\n        int[] indexs = new int[2];\r\n        \r\n        // å»ºç«‹k-v ï¼Œä¸€ä¸€å¯¹åº”çš„å“ˆå¸Œè¡¨\r\n        HashMap<Integer,Integer> hash = new HashMap<Integer,Integer>();\r\n        for(int i = 0; i < nums.length; i++){\r\n            if(hash.containsKey(nums[i])){\r\n                indexs[0] = i;\r\n                indexs[1] = hash.get(nums[i]);\r\n                return indexs;\r\n            }\r\n            // å°†æ•°æ®å­˜å…¥ keyä¸ºè¡¥æ•° ï¼Œvalueä¸ºä¸‹æ ‡\r\n            hash.put(target-nums[i],i);\r\n        }\r\n        // // åŒé‡å¾ªç¯ å¾ªç¯æé™ä¸º(n^2-n)/2 \r\n        // for(int i = 0; i < nums.length; i++){\r\n        //     for(int j = nums.length - 1; j > i; j --){\r\n        //         if(nums[i]+nums[j] == target){\r\n        //            indexs[0] = i;\r\n        //            indexs[1] = j; \r\n        //            return indexs;\r\n        //         }\r\n        //     }\r\n        // }\r\n        return indexs;\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1204183222","body":"```\r\nclass Solution {\r\n    public int[] topKFrequent(int[] nums, int k) {\r\n        int[] result = new int[k];\r\n        HashMap<Integer, Integer> map = new HashMap<>();\r\n        for (int num : nums) {\r\n            map.put(num, map.getOrDefault(num, 0) + 1);\r\n        }\r\n\r\n        Set<Map.Entry<Integer, Integer>> entries = map.entrySet();\r\n        // æ ¹æ®mapçš„valueå€¼æ­£åºæ’ï¼Œç›¸å½“äºä¸€ä¸ªå°é¡¶å †\r\n        PriorityQueue<Map.Entry<Integer, Integer>> queue = new PriorityQueue<>((o1, o2) -> o1.getValue() - o2.getValue());\r\n        for (Map.Entry<Integer, Integer> entry : entries) {\r\n            queue.offer(entry);\r\n            if (queue.size() > k) {\r\n                queue.poll();\r\n            }\r\n        }\r\n        for (int i = k - 1; i >= 0; i--) {\r\n            result[i] = queue.poll().getKey();\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205502187","body":"```\r\nclass Solution {\r\n    public int numberOfBoomerangs(int[][] points) {\r\n        int len = points.length;\r\n\tint ans = 0;\r\n\tHashMap<Double, Integer> map = new HashMap<Double, Integer>();\r\n\tfor(int i = 0; i < len; i++){\r\n\t     for(int j = 0; j < len; j++){\r\n\t\tif(i != j){\r\n\t\t    double dis = Math.pow(points[i][0] - points[j][0], 2)\r\n\t\t\t\t+ Math.pow(points[i][1] - points[j][1], 2);\r\n\t\t    if(!map.containsKey(dis)){\r\n\t\t\tmap.put(dis, 1);\r\n\t\t    }else{\r\n\t\t\tint n = map.get(dis);\r\n\t\t\tans += 2 * n;\r\n\t\t\tmap.put(dis, 1+n);\r\n\t\t    }\r\n\t\t}\r\n\t    }\r\n\t    map.clear();\r\n\t}\t\r\n\treturn ans;\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206610778","body":"```\r\nclass Solution {\r\n    public int lengthOfLongestSubstring(String s) {\r\n       //å¦‚æœsä¸ºç©ºï¼Œlengthä¸å¤§äº0ï¼Œæ˜¯ä¸€ä¸ªç©ºä¸²ï¼Œå°±æ²¡æœ‰å‘ä¸‹æ‰§è¡Œçš„å¿…è¦äº†\r\n        if(s != null && s.length() > 0 && s != \"\"){\r\n            //String -> char[]\r\n            char[] strChar = s.toCharArray();\r\n            // å­˜å‚¨æœ€é•¿å­—ä¸² key:charå€¼ï¼Œvalue:indexä¸‹æ ‡\r\n            ArrayList<String> maxStr = new ArrayList<>();\r\n            //ä¸´æ—¶çš„å­—ä¸²å­˜å‚¨ç©ºé—´\r\n            ArrayList<String> tempStr = new ArrayList<>();\r\n            //å¾ªç¯\r\n            for(int i=0; i<strChar.length; i++){\r\n                //char -> String\r\n                String str = new String(new char[]{strChar[i]});\r\n                //åˆ¤æ–­stræ˜¯å¦å­˜åœ¨äºtempSträ¸­\r\n                if(tempStr.contains(str)){\r\n                    //å…ˆåˆ¤æ–­tempStrçš„é•¿åº¦æ˜¯å¦å¤§äºç­‰äºmaxStrçš„é•¿åº¦,å¤§äºï¼Œæ‰èƒ½å°†æœ€é•¿å­—ä¸²è¦†ç›–\r\n                    if(tempStr.size() > maxStr.size()){\r\n                        maxStr = new ArrayList<>(tempStr);\r\n                    }\r\n                    //å­˜å‚¨é‡å¤å­—ç¬¦\r\n                    int reIndex = tempStr.indexOf(str);\r\n                    // åˆ é™¤tempSträ¸­çš„é‡å¤å­—èŠ‚åŠå…¶ä¹‹å‰çš„å­—ç¬¦\r\n                    for(int j=0;j<=reIndex;j++){\r\n                        tempStr.remove(0);\r\n                    }\r\n                }\r\n                //å°†å½“å‰å­—ç¬¦å­˜å…¥tempSträ¸­\r\n                tempStr.add(str);\r\n            }\r\n            //æœ€ç»ˆåˆ¤æ–­\r\n            if(tempStr.size() > maxStr.size()){\r\n                maxStr = tempStr;\r\n            }\r\n            //è¿”å›æœ€é•¿å­—ä¸²çš„é•¿åº¦\r\n            return maxStr.size();\r\n        }\r\n        return 0;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207432752","body":"```\r\npublic static List<Integer> findSubstring(String s, String... words) {\r\n`List<Integer> list = new ArrayList<>();\r\n\tif (s.length() == 0 || words.length == 0)\r\n\t\treturn list;\r\n\tint len = words[0].length();\r\n\tif (s.length() < words.length * len)\r\n\t\treturn list;\r\n\tint idx = -1;\r\n\tchar[] sCharS = s.toCharArray();\r\n\tSet<Integer> allSet = new HashSet<Integer>();// å­˜å‚¨åœ¨å­—ç¬¦ä¸²Sæ‰€æœ‰åŒ¹é…çš„ä¸‹æ ‡ å»é‡ æ’åº\r\n\tMap<String, Integer> wordMap = new HashMap<>();// å­˜å‚¨ wordä¸­å„ä¸ªå•è¯çš„ä¸ªæ•°\r\n\tMap<Integer, String> idxMap = new HashMap<>();// å­˜å‚¨å­—ç¬¦ä¸²så„ä¸‹æ ‡å¯¹åº”çš„å•è¯\r\n\tfor (String word : words) {\r\n\t\tif (wordMap.containsKey(word)) {\r\n\t\t\twordMap.put(word, wordMap.get(word) + 1);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tchar[] tem = word.toCharArray();\r\n\t\twhile ((idx = indexOf(sCharS, sCharS.length, tem, len, idx + 1)) > -1) {\r\n\t\t\tidxMap.put(idx, word);\r\n\t\t\tallSet.add(idx);\r\n\t\t}\r\n\t\twordMap.put(word, 1);\r\n\t}\r\n\r\n\tString word;\r\n\tint slideLen = len * words.length;// æ»‘å—é•¿åº¦\r\n\tint n;// ä¸´æ—¶å˜é‡\r\n\tMap<String, Integer> temWordMap = new HashMap<>();\r\n\tfor (int k = 0; k < len; k++) {\r\n\t\tint flagNum = 0;// è¡¨ç¤ºæ»‘å—ä¸­æœ‰æ•ˆçš„å•è¯ä¸ªæ•°\r\n\t\tfor (int i = -1, j = k; j <= sCharS.length - len; j += len) {\r\n\t\t\tif (allSet.contains(j)) {\r\n\t\t\t\tif (i == -1) {// åˆå§‹åŒ–æ»‘å—\r\n\t\t\t\t\ti = j;\r\n\t\t\t\t\tflagNum = 0;\r\n\t\t\t\t\ttemWordMap.clear();\r\n\t\t\t\t\ttemWordMap.putAll(wordMap);\r\n\t\t\t\t}\r\n\t\t\t\t// æ»‘å—é•¿åº¦å¢åŠ  åœ¨å°¾éƒ¨æ·»åŠ \r\n\t\t\t\tword = idxMap.get(j);\r\n\t\t\t\tn = temWordMap.get(word) - 1;\r\n\t\t\t\ttemWordMap.put(word, n);\r\n\t\t\t\tif (n >= 0)\r\n\t\t\t\t\tflagNum++;\r\n\t\t\t\tif (j - i >= slideLen) {// æ»‘å—é•¿åº¦å‡å° åå‡ºå¤´éƒ¨æ•°æ®\r\n\t\t\t\t\tword = idxMap.get(i);\r\n\t\t\t\t\tn = temWordMap.get(word) + 1;\r\n\t\t\t\t\ttemWordMap.put(word, n);\r\n\t\t\t\t\tif (n > 0)\r\n\t\t\t\t\t\tflagNum--;\r\n\t\t\t\t\ti += len;\r\n\t\t\t\t}\r\n\t\t\t\tif (flagNum == words.length)\r\n\t\t\t\t\tlist.add(i);\r\n\t\t\t} else {\r\n\t\t\t\ti = -1;// jæ‰€åœ¨çš„ä½ç½®ä¸æ˜¯ç»™å®šçš„å•è¯ ï¼Œé”€æ¯æ»‘å—\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn list;\r\n\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207432883","body":"```\r\nclass Solution {\r\n    public int solve(int[] nums, int p) {\r\n        int r0 = 0;\r\n        for (int num : nums) {\r\n            // total += num;\r\n            // overflow: nums = [1000000000,1000000000,1000000000], p = 3\r\n            r0 = (r0 + num) % p;\r\n        }\r\n        if (r0 == 0) return 0;\r\n        HashMap<Integer, Integer> map = new HashMap();\r\n        map.put(0, -1);\r\n        int prefixR =  0;\r\n        int res = Integer.MAX_VALUE;\r\n\r\n        for (int b = 0; b < nums.length; b++) {\r\n            prefixR = (prefixR + nums[b]) % p;\r\n            map.put(prefixR, b);\r\n            int pR_r0 = (prefixR - r0 + p) % p;\r\n            if (map.containsKey(pR_r0)) {\r\n                int a = map.get(pR_r0);\r\n                res = Math.min(res, b - a);\r\n            }\r\n        }\r\n        return res >= nums.length ? -1 : res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208915661","body":"```\r\npublic ListNode middleNode(ListNode head) {\r\n    int length = getLength(head, 0);\r\n    int index = (length / 2) + 1;\r\n    return getIndexNode(head,index);\r\n}\r\n\r\n/**\r\n * éå†é“¾è¡¨ è·å–èŠ‚ç‚¹é•¿åº¦\r\n */\r\nprivate int getLength(ListNode node, int len) {\r\n    return node == null ? len : getLength(node.next, ++len);\r\n}\r\n\r\n/**\r\n * éå†é“¾è¡¨ è·å–æŒ‡å®šèŠ‚ç‚¹\r\n */\r\nprivate ListNode getIndexNode(ListNode node, int index) {\r\n    index--;\r\n    return index == 0 ? node : getIndexNode(node.next, index);\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208915446","body":"```\r\nclass Solution {\r\n    public int removeDuplicates(int[] nums) {\r\n        // ä½¿ç”¨åŒæŒ‡é’ˆ\r\n        if(nums==null || nums.length == 1){\r\n            return nums.length;\r\n        }\r\n        int i = 0,j =1;\r\n        while(j<nums.length){\r\n            if(nums[i]==nums[j]){\r\n                j++;\r\n            }else{\r\n                i++;\r\n                nums[i]=nums[j];\r\n                j++;\r\n            }\r\n        }\r\n        return i+1;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suiyi8760":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185684032","body":"æ­£å‘æ€ç»´çš„æš´åŠ›è§£æ³•ï¼Œreverseå’Œkçš„åˆ†è§£æ–¹å¼è¿˜å¯ä»¥ä¼˜åŒ–ï¼Œæ²¡æ—¶é—´äº†å…ˆäº¤å·\n```typescript\nfunction addToArrayForm(num: number[], k: number): number[] {\n    const numArrReverse = num.reverse()\n    const kArrReverse = String(k).split('').map(item=>Number(item)).reverse()\n    let needCarry:boolean = false\n    const mapObject = (numArrReverse.length>kArrReverse.length?numArrReverse:kArrReverse)\n    return mapObject.reduce<number[]>((pre,cur,index)=>{\n       const sum = (numArrReverse[index]??0)+(kArrReverse[index]??0)+(needCarry?1:0)\n       console.log(sum)\n       if(sum>=10) {\n           needCarry = true\n       } else{\n           needCarry = false\n       }\n        return [...pre,sum%10,...(mapObject.length-1===index&&needCarry?[1]:[])]\n    },[]).reverse()\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186225083","body":"```typescript\nfunction shortestToChar(s: string, c: string): number[] {\n    const stringLength = s.length\n    const returnArr:number[] = new Array(stringLength).fill(0)\n    for(let i = 0,cPos = -stringLength;i<stringLength;i++){\n        if(s[i]===c){\n            cPos = i\n        }\n        returnArr[i] = i - cPos\n    }\n    console.log(returnArr)\n    for(let j = stringLength - 1,cPosRight = 2*stringLength;j>=0;j--){\n        if(s[j]===c){\n            cPosRight = j\n        }\n        returnArr[j] = Math.min(returnArr[j],cPosRight - j)\n    }\n    console.log(returnArr)\n    return returnArr\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186460622","body":"```typescript\n/*\n * @lc app=leetcode.cn id=1381 lang=typescript\n *\n * [1381] è®¾è®¡ä¸€ä¸ªæ”¯æŒå¢é‡æ“ä½œçš„æ ˆ\n */\n\n// @lc code=start\nclass CustomStack {\n\n    stack: number[] = []\n\n    constructor(public maxSize: number = 0) {\n\n    }\n\n    push(x: number): void {\n        if (this.stack.length < this.maxSize) {\n            this.stack.push(x)\n        }\n    }\n\n    pop(): number {\n        return this.stack.pop() ?? -1\n    }\n\n    increment(k: number, val: number): void {\n        for (let i = 0; i < this.stack.length; i++) {\n            if (i < k) {\n                this.stack[i] = this.stack[i] + val\n            }\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n// @lc code=end\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1189337623","body":"è¡¥å¡ ä¸€ä¸ªæ ˆç»“æ„è§£å†³\n```typescript\nfunction decodeString(s: string): string {\n    const stack:string[] = []\n    for (let i = 0; i < s.length; i++) {\n      const element = s[i]\n      if(s[i]!==']'){\n        stack.push(element)\n      } else {\n        let repeatStr = '',\n        repeatCount = ''\n        while(stack[stack.length-1]!=='['){\n          repeatStr = stack.pop() + repeatStr\n        }\n        stack.pop()\n        while(/^[0-9]+.?[0-9]*/.test(stack[stack.length-1])){\n          repeatCount = stack.pop() + repeatCount\n        }\n        stack.push(repeatStr.repeat(Number(repeatCount)))\n        console.log(stack)\n      }\n    }\n    return stack.join('')\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1190348699","body":"åŸç”Ÿapié»˜ç§’å…¨ï¼ˆğŸ¶.jpgï¼‰\n```typescript\nclass MyQueue {\n    queue: number[] = []\n    constructor() {\n        \n    }\n\n    push(x: number): void {\n        this.queue.push(x)\n    }\n\n    pop(): number {\n        return this.queue.splice(0,1)[0]\n    }\n\n    peek(): number {\n        return this.queue[0]\n    }\n\n    empty(): boolean {\n        return this.queue.length === 0\n    }\n}\n```\næ­£å¼ç”¨æ ˆè§£ä¸€ä¸‹\n```typescript\nclass MyQueue {\n    inStack: number[] = []\n    outStack: number[] = []\n    constructor() {\n\n    }\n\n    push(x: number): void {\n        this.inStack.push(x)\n    }\n\n    pop(): number {\n        if (!this.outStack.length) {\n            this.in2out()\n        }\n        return this.outStack.pop() as number\n    }\n\n    peek(): number {\n        if (!this.outStack.length) {\n            this.in2out()\n        }\n        return this.outStack[this.outStack.length - 1]\n    }\n\n    empty(): boolean {\n        return this.inStack.length === 0 && this.outStack.length === 0\n    }\n\n    in2out(): void {\n        while (this.inStack.length) {\n            this.outStack.push(this.inStack.pop() as number)\n        }\n    }\n}\n```","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192192528","body":"```javascript\nvar swapPairs = function(head) {\n    var fateHead = new ListNode(-1);\n    fateHead.next = head;\n    var cur = fateHead;\n    \n    while(cur.next&&cur.next.next){\n        var originNode_1 = cur.next;\n        var originNode_2 = cur.next.next;\n        cur.next = originNode_2;\n        originNode_1.next = originNode_2.next;\n        originNode_2.next = originNode_1;\n        cur = originNode_1;\n    }\n    \n    return fateHead.next;\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1196745411","body":"åŒæŒ‡é’ˆèµ›è·‘\n```typescript\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {\n    if(headA!==null&&headB!==null){\n        let pA = headA\n        let pB = headB\n        while(pA!==pB){\n            pA = pA!==null?pA.next:headB\n            pB = pB!==null?pB.next:headA\n        }\n        return pA\n    }\n    return null\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1196274236","body":"æ€è·¯ï¼šåŒé“¾è¡¨èµ›è·‘(å¿«æ…¢æŒ‡é’ˆ)\r\n```\r\nvar detectCycle = function(head) {\r\n    var snowNode = head,\r\n        fastNode = head;\r\n    if(!head||!head.next) return null;\r\n    while(snowNode.next!==null){\r\n        if(fastNode.next===null||fastNode.next.next===null){\r\n            return null;\r\n        }\r\n        \r\n        snowNode = snowNode.next;\r\n        fastNode = fastNode.next.next;\r\n    \r\n        if(snowNode===fastNode){\r\n            fastNode = head;\r\n            while(fastNode!==snowNode){\r\n                fastNode = fastNode.next;\r\n                snowNode = snowNode.next;\r\n            }\r\n            return fastNode;\r\n        }\r\n     }   \r\n};\r\n```","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198322737","body":"é€’å½’ï¼šç®€å•ç²—æš´\n```typescript\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\n    if (p == null && q == null )return true\n    if (p == null || q == null ) return false\n    if (p.val != q.val ) return false\n    return isSameTree(p.left,q.left) && isSameTree(p.right,q.right)\n};\n```\nO(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1202099543","body":"æ€è·¯ï¼šæ¯”è¾ƒæ˜æ˜¾çš„bfsè§£æ³•\n```typescript\nfunction findBottomLeftValue(root: TreeNode | null): number {\n  if (root === null) return 0\n  let topLeft = root.val\n  let queue: TreeNode[] = [root]\n  while (queue.length) {\n    const currentFloor = queue\n    // æ¸…ç©º å‡†å¤‡ä¸‹ä¸€å±‚çš„é˜Ÿåˆ—\n    queue = []\n    topLeft = currentFloor[0].val\n    for (let i = 0; i < currentFloor.length; i++) {\n      const node = currentFloor[i]\n      if (node.left) {\n        queue.push(node.left)\n      }\n      if (node.right) {\n        queue.push(node.right)\n      }\n    }\n  }\n  return topLeft\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1201493396","body":"BFSåºåˆ—åŒ–é—®é¢˜ä¸å¤§ï¼Œååºåˆ—åŒ–èµ°äº†äº›å¼¯è·¯\n```typescript\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n/*\n * Encodes a tree to a single string.\n */\nfunction serialize(root: TreeNode | null): string {\n  const returnArr: (number | null)[] = []\n  let queue: (TreeNode | null)[] = [root]\n  while (queue.length) {\n    const currentLevel = queue.shift()\n    if (currentLevel) {\n      returnArr.push(currentLevel.val)\n      queue.push(currentLevel.left)\n      queue.push(currentLevel.right)\n    } else {\n      returnArr.push(null)\n    }\n  }\n  console.log(returnArr)\n  return returnArr.join(',')\n};\n\n/*\n * Decodes your encoded data to tree.\n */\nfunction deserialize(data: string): TreeNode | null {\n  if (!data) return null\n  const nums: string[] = data.split(',')\n  console.log(nums)\n  const root = new TreeNode(Number(nums[0]))\n  const queue: TreeNode[] = [root]\n  let i = 1\n  while (i < nums.length) {\n    const currentLevel = queue.shift() as TreeNode\n    const left = nums[i]\n    const right = nums[i + 1]\n    if (left) {\n      const leftNode = new TreeNode(Number(left))\n      currentLevel.left = leftNode\n      queue.push(leftNode)\n    }\n    if (right) {\n      const rightNode = new TreeNode(Number(right))\n      currentLevel.right = rightNode\n      queue.push(rightNode)\n    }\n    i += 2\n  }\n  return root\n};\n\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n```","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1203504991","body":"ä»¥å‰ç”¨æš´åŠ›ç©·ä¸¾æäº¤è¿‡ä¸€æ¬¡ï¼Œæ¢mapå†å®ç°ä¸€ä¸‹ï¼Œæ—¶é—´å¤æ‚åº¦O(n)\n```typescript\nfunction twoSum(nums: number[], target: number): number[] {\n  const map = new Map<number, number>()\n  for (let i = 0; i < nums.length; i++) {\n    const element = nums[i];\n    if (map.has(target - element)) {\n      return [map.get(target - element), i]\n    }\n    map.set(element, i)\n  }\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203646043","body":"map+æ¡¶æ’åº æ—¶é—´å¤æ‚åº¦O(n)\n```typescript\nfunction topKFrequent(nums: number[], k: number): number[] {\n  const map = new Map<number, number>();\n  for (let i = 0; i < nums.length; i++) {\n    const num = nums[i];\n    if (!map.has(num)) {\n      map.set(num, 1)\n    } else {\n      map.set(num, (map.get(num) ?? 0) + 1)\n    }\n  }\n  const buckets = new Array<number[]>()\n  const returnArr: number[] = []\n  map.forEach((v, k) => buckets[v] ? buckets[v].push(k) : buckets[v] = [k])\n  let j = buckets.length - 1\n  while(returnArr.length<k){\n    if(buckets[j]){\n      returnArr.push(...buckets[j])\n    }\n    j--\n  }\n  return returnArr\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1207379073","body":"å“ˆå¸Œè¡¨+ç›¸åŒè·ç¦»èŠ‚ç‚¹çš„æ¬¡æ•°è§„å¾‹\r\n```typescript\r\nfunction numberOfBoomerangs(points: number[][]): number {\r\n    let returnNumber = 0\r\n    for(let i = 0;i<points.length;i++){\r\n        let distanceMap = new Map<number,number>()\r\n        for(let j = 0;j < points.length;j++){\r\n            const distance = compare(points[i],points[j])\r\n            distanceMap.set(distance,(distanceMap.get(distance)??0)+1)\r\n        }\r\n        distanceMap.forEach(v=>returnNumber += v*(v-1))\r\n    }\r\n    return returnNumber\r\n};\r\n\r\nfunction compare(a:number[],b:number[]):number{\r\n    const xDis = b[0] - a[0]\r\n    const yDis = b[1] - a[1]\r\n    return xDis*xDis + yDis*yDis\r\n}\r\n```","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"saltychess":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185691220","body":"æ€è·¯\n---\n1ã€ä»æœ«å°¾é€ä½å–æ•°å‘å‰åšåŠ æ³•  \n2ã€è®¾ç½®ä¸€ä¸ªå˜é‡FLAGæ ‡è¯†æ˜¯å¦æœ‰è¿›ä½ï¼Œè‹¥æœ‰åˆ™è®¾ç½®FLAG=1ï¼Œåä¹‹ä¸º0    \n3ã€æ³¨æ„kå’Œnumé•¿åº¦è¾¹ç•Œå€¼çš„åˆ¤æ–­  \n\nä»£ç \n---\n``` JAVA\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int len=num.length-1;\n        int flag=0,tmp_k=0,tmp_num=0,sum=0;\n        List<Integer> res=new ArrayList<Integer>();\n        while(k>0||len>=0){\n            tmp_num = len>=0?num[len]:0;\n            tmp_k = k>0?k:0;\n            sum=flag+tmp_num+(tmp_k%10);\n            if(sum>=10){\n                flag=1;\n                sum=sum%10;\n            }else {\n                flag = 0;\n            }\n            k=k>0?k/10:0;\n            len--;\n            res.add(0,sum);\n        }\n        if(flag==1){\n            res.add(0,flag);\n        }\n        return res;\n    }\n}\n```\nå¤æ‚åº¦\n---\næ—¶é—´å¤æ‚åº¦ï¼šOï¼ˆnï¼‰  \nç©ºé—´å¤æ‚åº¦ï¼šOï¼ˆnï¼‰","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186138233","body":"æ€è·¯\n---  \n1ã€ä»å·¦ä»å³å„å¾ªç¯ä¸€æ¬¡ï¼Œä»å·¦å¾ªç¯æ—¶æ‰¾ç¬¬iä¸ªå­—ç¬¦å·¦è¾¹æœ€è¿‘çš„cï¼Œä»å³å¾ªç¯æ—¶æ‰¾ç¬¬iä¸ªå­—ç¬¦å³è¾¹æœ€è¿‘çš„c  \n2ã€resè®°å½•æœ€çŸ­è·ç¦»å¹¶è¾“å‡º\n\n```Java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        if (s.length()==1) return new int[]{0};\n        int[] res =new int[s.length()];\n        Arrays.fill(res,s.length()+1);\n        for(int i=0,index=-1;i<s.length();i++){\n            if(s.charAt(i)==c) index=i;\n            if(index!=-1) res[i]=i-index;\n        }\n        for(int i=s.length()-1,index=-1;i>=0;i--){\n            if(s.charAt(i)==c) index=i;\n            if(index!=-1) res[i]=Math.min(res[i],index-i);\n        }\n        return res;\n    }\n}\n```\nå¤æ‚åº¦åˆ†æ\n---\næ—¶é—´å¤æ‚åº¦ï¼šOï¼ˆnï¼‰  \nç©ºé—´å¤æ‚åº¦ï¼šOï¼ˆnï¼‰","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186437794","body":"æ€è·¯\n---\nç”¨ArrayListæ¨¡æ‹Ÿæ ˆï¼Œè¦æ³¨æ„è¾¹ç•Œå€¼çš„å¤„ç†ï¼Œå³popå’Œpushæ“ä½œä¹‹å‰åˆ¤æ–­å½“å‰Arrayé•¿åº¦æ˜¯å¦è¶…å‡ºæœ€å¤§é•¿åº¦\n\nä»£ç \n---\n```Java\nclass CustomStack {\n    List<Integer> stack ;\n    int maxSize;\n    public CustomStack(int maxSize) {\n        this.stack = new ArrayList<Integer>();\n        this.maxSize = maxSize;\n    }\n\n    public void push(int x) {\n        if(stack.size()<maxSize){\n            stack.add(x);\n        }\n    }\n    public int pop() {\n        if(stack.size()==0){\n            return -1;\n        }\n        int index=stack.size()-1;\n        int res=stack.get(index);\n        stack.remove(index);\n        return res;\n    }\n    public void increment(int k, int val) {\n        int size = k<stack.size()?k:stack.size();\n        for(int i=0;i<size;i++){\n            int tmp=stack.get(i)+val;\n            stack.set(i,tmp);\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187625321","body":"æ€è·¯\n---\né¦–å…ˆå°†å­—ç¬¦ä¸²éå†ä¸€éï¼ŒæŠŠå­—æ¯å’Œæ•°å­—åˆ†åˆ«å­˜åœ¨ä¸¤ä¸ªæ ˆå†…ã€‚  \nä¸»è¦æ³¨æ„ï¼šå½“å­—ç¬¦ç­‰äºâ€˜[â€™æ—¶ï¼Œè¯æ˜éœ€è¦è®°å½•æ–°çš„å­—ç¬¦å­ä¸²ï¼›  \nå½“å­—ç¬¦ç­‰äºâ€˜]â€™æ—¶ï¼Œè¯æ˜ä¸€ä¸ªå­ä¸²çš„ä¿¡æ¯å·²ç»å…¨éƒ¨ç»™å‡ºï¼Œå¼€å§‹æ„é€ è¿™ä¸ªå­ä¸²ã€‚\n\nä»£ç \n---\n``` JAVA\nclass Solution {\n    public String decodeString(String s) {\n        Stack<String> stack_str = new Stack<String>();\n        Stack<Integer> stack_num = new Stack<Integer>();\n        String res=\"\";\n        int mul=0;\n        for(char c:s.toCharArray()){\n            if(Character.isDigit(c)){\n                mul=mul*10+(c-'0');\n            }else if(Character.isAlphabetic(c)){\n                res = res+c;\n            }else if(c=='['){\n                stack_str.push(res);\n                res=\"\";\n                stack_num.push(mul);\n                mul=0;\n            }else{\n                String str_tmp = stack_str.pop();\n                int num_tmp = stack_num.pop();\n                String res_tmp=\"\";\n                while(num_tmp>0){\n                    res_tmp += res;\n                    num_tmp--;\n                }\n                res = str_tmp+res_tmp;\n            }\n        }\n        return res;\n    }\n}\n```\nå¤æ‚åº¦\n---\næ—¶é—´å¤æ‚åº¦ï¼šO(n)  \nç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189168066","body":"æ€è·¯\n---\nä½¿ç”¨ä¸¤ä¸ªlistï¼Œstackå’Œstack_tmp  \n1ã€å…¥æ ˆæ—¶ï¼Œå…ˆå°†stackå†…å…ƒç´ æŒ‰é¡ºåºpopåˆ°stack_tmp   \n2ã€å°†ç›®æ ‡å…ƒç´ å­˜å…¥stackå†…  \n3ã€æœ€åå°†stack_tmpå†…çš„å…¨éƒ¨å…ƒç´ popåˆ°stackä¸­\n\nä»£ç \n---\n``` python3\nclass MyQueue:\n\n    def __init__(self):\n        self.stack = []\n        self.stack_tmp = []\n\n    def push(self, x: int) -> None:\n        while self.stack:\n            self.stack_tmp.append(self.stack.pop())\n        self.stack.append(x)\n        while self.stack_tmp:\n            self.stack.append(self.stack_tmp.pop())\n\n    def pop(self) -> int:\n        return self.stack.pop()\n\n    def peek(self) -> int:\n        length = len(self.stack)\n        return self.stack[length-1];\n\n    def empty(self) -> bool:\n        if not self.stack:\n            return True\n        return False\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191623931","body":"æ€è·¯\n---\n1ã€è®°å½•é“¾è¡¨é•¿åº¦size  \n2ã€é“¾è¡¨ç§»åŠ¨å‘å³kæ¬¡ï¼Œç­‰äºå‘å³ç§»åŠ¨k mod sizeï¼Œé‚£ä¹ˆç§»åŠ¨åçš„å°¾éƒ¨èŠ‚ç‚¹åˆ™æ˜¯ ç¬¬size - k mod sizeä¸ªèŠ‚ç‚¹  \n3ã€å°†é“¾è¡¨è¿æ¥æˆç¯ï¼Œå†å°†ç¬¬size - k mod sizeä¸ªèŠ‚ç‚¹çš„next=None  \n\nä»£ç \n---\n``` python3\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if k==0 or head == None : return head\n        tail = head\n        size = 1\n        while tail.next:\n            size += 1\n            tail = tail.next\n        index = size - (k%size) \n        if index == size :return head\n        tail.next = head\n        cur = tail\n        while index:\n            cur = cur.next\n            index -= 1\n        res = cur.next\n        cur.next = None\n        return res\n```\nå¤æ‚åº¦\n---\næ—¶é—´å¤æ‚åº¦ï¼šOï¼ˆNï¼‰  \nç©ºé—´å¤æ‚åº¦ï¼šOï¼ˆ1ï¼‰","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193146044","body":"è¯­è¨€ï¼špython3\n``` python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return head\n        pre,slow,fast = None,head,head\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if fast == slow :\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193301167","body":"æ€è·¯\n---\nåˆ›å»ºä¸¤ä¸ªæŒ‡é’ˆa,bï¼Œåˆå§‹æ—¶åˆ†åˆ«æŒ‡å‘é“¾è¡¨Aå’Œé“¾è¡¨Bçš„å¤´éƒ¨ï¼Œä»¥ç›¸åŒçš„é€Ÿåº¦è¿›è¡Œéå†ã€‚è‹¥aä¸ºç©ºï¼Œåˆ™å°†aæŒ‡å‘é“¾è¡¨Bçš„å¤´éƒ¨ï¼Œåä¹‹äº¦ç„¶ã€‚  \n1ã€å½“é“¾è¡¨Aã€Bç›¸äº¤æ—¶ï¼Œç”±äºä¸¤ä¸ªæŒ‡é’ˆéå†çš„é•¿åº¦æ˜¯ä¸€æ ·çš„ï¼Œæ‰€ä»¥ä¸€å®šä¼šæ‰¾åˆ°ç›¸äº¤çš„èŠ‚ç‚¹ï¼›  \n2ã€å½“é“¾è¡¨Aã€Bä¸ç›¸äº¤æ—¶ï¼Œä¸¤ä¸ªæŒ‡é’ˆæœ€ç»ˆéƒ½ä¼šæŒ‡å‘nullï¼Œæœ€åè¿”å›ç»“æœ  \n\nä»£ç \n---\n``` python\ndef getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        if headA == headB :\n            return headA\n        nodeA = headA\n        nodeB = headB\n        while nodeA != nodeB:\n            if nodeA:\n                nodeA=nodeA.next\n            else:\n                nodeA = headB\n            \n            if nodeB:\n                nodeB=nodeB.next\n            else:\n                nodeB = headA\n\n        return nodeA\n```\n\nå¤æ‚åº¦\n---\næ—¶é—´å¤æ‚åº¦ï¼šOï¼ˆm+nï¼‰(mã€nåˆ†åˆ«ä¸ºé“¾è¡¨é•¿åº¦)  \nç©ºé—´å¤æ‚åº¦ï¼šOï¼ˆ1ï¼‰","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196908910","body":"æ€è·¯\n---\né€’å½’  \né¦–å…ˆè®¾ç½®é€’å½’å‡ºå£ï¼Œå½“ç›®å‰èŠ‚ç‚¹ä¸ºç©ºæ—¶è¿”å›0ã€‚è‹¥èŠ‚ç‚¹ä¸ä¸ºç©ºåˆ™è¿”å›æœ€å¤§å­æ ‘é«˜åº¦+1\n\nä»£ç ï¼š\n---\n```python\nclass Solution:\n     def maxDepth(self, root: TreeNode) -> int:\n        if root == None :\n            return 0\n        return max(self.maxDepth(root.left),self.maxDepth(root.right))+1\n```\nå¤æ‚åº¦\n---\næ—¶é—´å¤æ‚åº¦ï¼šOï¼ˆNï¼‰ï¼Œå…¶ä¸­Nä¸ºäºŒå‰æ ‘èŠ‚ç‚¹ä¸ªæ•°  \nç©ºé—´å¤æ‚åº¦ï¼šOï¼ˆheightï¼‰","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1200151565","body":"æ€è·¯\n---\nBFS  \n1ã€ä½¿ç”¨æ ˆcur_levelä¿å­˜å½“å‰å±‚çš„èŠ‚ç‚¹ï¼Œå…ˆä¿å­˜å³èŠ‚ç‚¹å†ä¿å­˜å·¦èŠ‚ç‚¹ï¼ˆä¿è¯å·¦èŠ‚ç‚¹åœ¨æ ˆé¡¶ï¼‰  \n2ã€ç”¨resè®°å½•æ ˆé¡¶èŠ‚ç‚¹çš„å€¼  \n\nä»£ç \n---\n```python\nclass Solution:\n    def findBottomLeftValue(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        cur_level=[]\n        res = 0\n        if root:\n            cur_level.append(root)\n        while cur_level:\n            next_level=[]\n            for node in cur_level:\n                if not node:\n                    continue\n                next_level.append(node.right)\n                next_level.append(node.left)\n                res = node.val\n            cur_level = next_level\n        return res\n```\n\nå¤æ‚åº¦\n---\næ—¶é—´å¤æ‚åº¦ï¼šOï¼ˆNï¼‰  \nç©ºé—´å¤æ‚åº¦ï¼šOï¼ˆNï¼‰","onTime":false},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202722659","body":"æ€è·¯\n---\nHashMapåŒ¹é…  \nåˆ¤æ–­target - xæ˜¯å¦åœ¨mapä¸­ï¼Œè‹¥ä¸å­˜åœ¨åˆ™å°†(x,i)å­˜å…¥HashMapä¸­  \nè‹¥å­˜åœ¨ï¼Œå³ä»£è¡¨å­˜åœ¨ä¸€å¯¹æ•°åŠ èµ·æ¥ç­‰äºtargetï¼Œtarget-x+x=target,åˆ™è¿”å›xå’Œtarget - xçš„ä¸‹æ ‡  \n\nä»£ç \n---\n```python3\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        if len(nums) == 2:\n            return [0,1]\n        hashtable = dict()\n        for i in range(len(nums)):\n            if target - nums[i] in hashtable:\n                return [hashtable.get(target - nums[i]),i]\n            else:\n                hashtable[nums[i]] = i\n        return []\n```\nå¤æ‚åº¦\n---\næ—¶é—´å¤æ‚åº¦ï¼šO(N)  \nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1207247697","body":"```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        from collections import Counter\n        counter = Counter(nums)\n        bucket = dict()\n        res,max_len = [],0\n        if len(counter) == 1: return [nums[0]]\n        for i in counter:\n            value = counter.get(i)\n            if value > max_len:max_len = value\n            if value not in bucket:\n                bucket[value] = []\n            bucket[value].append(i)\n        for i in range(1,max_len+1):\n            if bucket.get(i) != None:\n                for j in bucket[i]:\n                    res.append(j)\n        ans = []\n        for i in range(len(res)-1,len(res)-1-k,-1):\n            ans.append(res[i])\n        return ans\n```","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207235350","body":"ä»£ç \n---\n``` python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        from collections import Counter\n        if not s or not words:\n            return []\n        sLen= len(s)\n        word_sum = len(words)*len(words[0])\n        word_counter = Counter(words)\n        res = []\n        for i in range(sLen-word_sum+1):\n            flag = True\n            temp_str,j = s[i:word_sum+i],0\n            temp_dict = dict()\n            while(j<len(temp_str)):\n                word = temp_str[j:j+len(words[0])]\n                if word not in word_counter:\n                    flag = False\n                    break\n                if word not in temp_dict:\n                    temp_dict[word] = 1\n                else:\n                    temp_dict[word] = temp_dict[word] + 1\n                if word_counter[word] < temp_dict[word] :\n                    flag = False\n                    break\n                j += len(words[0])\n            if flag:res.append(i)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1208209057","body":"æ€è·¯\n---\nåŒä½™å®šç†  \n\nä»£ç \n---\n```python\nclass Solution:\n    def solve(self, nums, k):\n        total = sum(nums)\n        mod = total%k\n        if mod == 0:\n            return 0\n        pres = 0\n        ans = len(nums)\n        dic = {0:-1}\n        for i in range(len(nums)):\n            pres += nums[i]\n            cur_mod = pres % k\n            need_mod = (cur_mod+k-mod)%k\n            if need_mod in dic:\n                ans = min(ans,i-dic[need_mod])\n            dic[cur_mod] = i\n        if ans == len(nums):\n            return -1\n        return ans\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208273507","body":"æ€è·¯\n---  \nå¿«æ…¢æŒ‡é’ˆï¼Œå¿«æŒ‡é’ˆæ¯æ¬¡ç§»åŠ¨ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œæ…¢æŒ‡é’ˆæ¯æ¬¡ç§»åŠ¨ä¸€æ¬¡  \nå½“èŠ‚ç‚¹æ•°ä¸ºå¥‡æ•°æ—¶ï¼Œå¿«æŒ‡é’ˆç§»åŠ¨åˆ°æœ€åä¸€ä¸ªèŠ‚ç‚¹æ—¶ï¼Œæ…¢æŒ‡é’ˆåˆšå¥½åœ¨ä¸­é—´èŠ‚ç‚¹ï¼›  \nå½“èŠ‚ç‚¹æ•°ä¸ºå¶æ•°æ—¶ï¼Œå¿«æŒ‡é’ˆç§»åŠ¨åˆ°æœ€åä¸€ä¸ªèŠ‚ç‚¹æ—¶ï¼Œæ…¢æŒ‡é’ˆåˆšå¥½åœ¨ä¸­é—´åå³çš„èŠ‚ç‚¹  \n\nä»£ç \n---\n```python\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        if not head:\n            return head\n        slow,fast=head,head\n        while fast and fast.next:\n            fast=fast.next.next\n            slow = slow.next\n        return slow\n```\nå¤æ‚åº¦\n---\næ—¶é—´å¤æ‚åº¦ï¼šOï¼ˆNï¼‰  \nç©ºé—´å¤æ‚åº¦ï¼šOï¼ˆ1ï¼‰","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209381876","body":"æ€è·¯\n---\nåŒæŒ‡é’ˆ\n\nä»£ç \n---\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if len(nums) == 1:\n            return 1\n        index = 0\n        for i in range(len(nums)):\n            if nums[i] == nums[index]:\n                continue\n            index += 1\n            nums[index] = nums[i]   \n        return index+1\n```\nå¤æ‚åº¦\n---\nç©ºé—´å¤æ‚åº¦ï¼šO(1)  \næ—¶é—´å¤æ‚åº¦ï¼šO(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rabbit2010520":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185806802","body":"# Idea\n###### Traverse S from left to the right and find shortest distance from each element  in S to C.\n###### Traverse S from right to the left and find shortest distance  rom each element  in S to C.\n###### Then find the minimum value.\n\n# Code\n```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int [] arr = new int[len];\n        for(int i = 0, index = -len; i < len; i++){\n            if(s.charAt(i) == c){\n                index = i;\n            }\n            arr[i] = i - index;\n        }\n        \n        for(int i = len-1, index = 2 * len; i >= 0; i--){\n            if(s.charAt(i) == c){\n                index = i;\n            }\n            arr[i] = Math.min(arr[i], index - i);\n        }\n        return arr;\n    }\n}\n```\n# Complexity\n###### Time complexity: O(N)\n###### Space complexity: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ellie-wu05":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186024434","body":"## ç”¨pointerè®°ä½å‰ä¸€ä¸ªå€¼å’Œåä¸€ä¸ªå€¼ï¼Œæ±‚min\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        pre,nex,k = -1,-1,0\n        ans = [None] * len(s)\n        \n        while k < len(s) and s[k] != c:  k+=1\n        nex = k\n        \n        for i in range(len(s)):\n            if pre == -1:\n                dis = nex -i\n            elif nex == -1:\n                dis = i - pre\n            else:\n                dis = min((nex -i),(i-pre))\n            ans[i] = dis\n            \n            if s[i] ==c:\n                pre = nex\n                k = i+1\n                while k < len(s) and s[k] !=c: k+=1\n                nex = k\n                if nex == len(s): nex = -1\n                \n        return ans\n```\n## å¤æ‚åº¦ï¼š\næ—¶é—´ï¼šOn\nç©ºé—´ï¼šOn","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186385024","body":"'''\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.max_size = maxSize\n        self.inc = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.max_size:\n            self.stack.append(x)\n            self.inc.append(0)\n\n    def pop(self) -> int:\n        if not self.stack: return -1\n        if len(self.stack) >=2:\n            self.inc[-2] += self.inc[-1]\n        \n        return self.stack.pop() + self.inc.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if self.inc:\n            self.inc[min(k,len(self.stack))-1] += val\n        \n\n\n\n'''\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187677476","body":"class Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        \n        for c in s:\n            if c != ']':\n                stack.append(c)\n                continue\n            else:\n                string =''\n                num = ''\n                while stack and stack[-1] !='[':\n                    string = stack.pop() + string\n                stack.pop()\n                while stack and stack[-1].isdigit():\n                    num = stack.pop() + num\n                stack.append(int(num) * string)\n        return ''.join(stack)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189813017","body":"class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        # [1,1,2,1,1,3,4,5,1,6]\n        # [1,1,5,6]\n        \n        stack = []\n        \n        for num in arr:\n            # é‡åˆ°ä¸€ä¸ªæ¯”æ ˆé¡¶å°çš„å…ƒç´ ï¼Œè€Œå‰é¢çš„å—ä¸åº”è¯¥æœ‰æ¯” a å°çš„\n            # è€Œæ ˆä¸­æ¯ä¸€ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªå—ï¼Œå¹¶ä¸”æ ˆçš„å­˜çš„æ˜¯å—çš„æœ€å¤§å€¼ï¼Œå› æ­¤æ ˆä¸­æ¯” a å°çš„å€¼éƒ½éœ€è¦ pop å‡ºæ¥\n            if stack and stack[-1] > num:\n                curr_max = stack[-1]\n                # æˆ‘ä»¬éœ€è¦å°†èåˆåçš„åŒºå—çš„æœ€å¤§å€¼é‡æ–°æ”¾å›æ ˆ\n                # è€Œ stack æ˜¯é€’å¢çš„ï¼Œå› æ­¤ stack[-1] æ˜¯æœ€å¤§çš„\n                while stack and stack[-1]>num:\n                    stack.pop()\n                # ç»´æŒæ ˆçš„å•è°ƒé€’å¢\n                stack.append(curr_max)\n            else:\n                stack.append(num)\n        # æ ˆå­˜çš„æ˜¯å—ä¿¡æ¯ï¼Œå› æ­¤æ ˆçš„å¤§å°å°±æ˜¯å—çš„æ•°é‡\n        return len(stack)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191592348","body":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \n\n        \n        if not head:\n            return None\n        if not head.next:\n            return head\n        \n        tail = head \n        n = 1\n        \n        while tail.next:\n            tail = tail.next\n            n+=1 # æ‰¾åˆ°å°¾ç»“ç‚¹\n        \n        # å°¾ç»“ç‚¹è¿åˆ°å¤´éƒ¨\n        tail.next = head\n        \n        # æ¥ä¸‹æ¥æ‰¾æ–°çš„æ–­ç‚¹\n        \n        cut_off = head\n        for i in range(n-k%n-1):\n            cut_off = cut_off.next\n            \n        # æ–­æ‰ä¹‹å‰è®°å½•ä¸‹æ–°headçš„å€¼\n        head = cut_off.next\n        \n        cut_off.next = None\n            \n        return head\n        \n        ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192666045","body":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n\n        # [1] [2] [3] [4]\n        # [2] [1] [4] [3]\n        dummy = ListNode(0,head)\n        \n        # [dummy]   [1]   [2]   [3]   [4]\n        #  temp    node1 node2\n        temp = dummy\n        \n        # å› ä¸ºæ˜¯ä¸¤ä¸¤äº¤æ¢ï¼Œæ‰€ä»¥æ˜¯ while temp.next and temp.next.next:\n        while temp.next and temp.next.next:\n            \n            #[dummy] æŒ‡å‘[2]çš„æ—¶å€™ï¼Œä¼šä¸¢æ‰[1]çš„ä½ç½®ï¼Œæ‰€ä»¥è¦è®°ä½\n            # node_1 ä¸º [1]\n            node_1 = temp.next\n            # node_2 ä¸º [2]\n            node_2 = temp.next.next\n            \n            # [temp] æŒ‡å‘ [2]\n            temp.next = node_2\n            # [2] æŒ‡å‘ [1] çš„æ—¶å€™ï¼Œ ä¼šä¸¢æ‰ [3] çš„ä½ç½®ï¼Œæ‰€ä»¥è¦å…ˆè®©[1] æŒ‡å‘ [3]\n            node_1.next = node_2.next\n            # æŠŠ [2] æŒ‡å‘ [1]\n            node_2.next = node_1\n            \n            # ç°åœ¨æ˜¯è¿™æ ·\n            #[dummy] [2] [1] [3] [4]\n            \n            # æŠŠ temp ç§»åŠ¨åˆ° [1]\n            # [dummy] [2] [1]   [3]     [4]\n            #             temp node1 node2\n            temp = node_1\n            \n        return dummy.next\n            \n            \n            \n            ","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194223557","body":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \n        if not head or not head.next:\n            return None\n        \n        slow = head\n        fast = head\n        \n        while fast is not None and fast.next is not None:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                break\n        else:\n            return None\n            \n        fast = head\n        \n        while fast != slow:\n            fast = fast.next\n            slow = slow.next\n        \n        return fast\n            \n        \n                \n                \n        \n        ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194969693","body":"class DoubleLinkedNode:\n    def __init__(self,key=None,val=None):\n        self.key = key\n        self.val = val\n        self.pre = None\n        self.next = None\n\nclass LRUCache:\n    # head ä¸ºæœ€å°‘ä½¿ç”¨çš„\n    # tail ä¸ºæœ€è¿‘ä½¿ç”¨çš„\n\n    def __init__(self, capacity: int):\n        # initialize linked list\n        self.capacity = capacity\n        self.hashmap ={}\n        \n        self.head = DoubleLinkedNode()\n        self.tail = DoubleLinkedNode()\n        self.head.next = self.tail\n        self.tail.pre = self.head\n        \n    def remove_node(self,node):\n        node.pre.next = node.next\n        node.next.pre = node.pre\n        \n    def add_node_to_last(self,node):\n        self.tail.pre.next = node\n        node.pre = self.tail.pre\n        node.next = self.tail\n        self.tail.pre  = node\n        \n    def move_node_to_last(self,node):\n        self.remove_node(node)\n        self.add_node_to_last(node)\n        \n    def get(self, key: int) -> int:\n        if key not in self.hashmap:\n            return -1\n        node = self.hashmap[key]\n        self.move_node_to_last(node)\n        return node.val\n        \n\n    def put(self, key: int, value: int) -> None:\n        if key in self.hashmap:\n            node = self.hashmap[key]\n            node.val = value\n            self.move_node_to_last(node)\n            return \n        if len(self.hashmap) == self.capacity:\n            del self.hashmap[self.head.next.key]\n            self.remove_node(self.head.next)\n        node = DoubleLinkedNode(key,value)\n        self.hashmap[key] = node\n        self.add_node_to_last(node)\n                \n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196929807","body":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        \n        if not root:\n            return 0\n        left_max = self.maxDepth(root.left)\n        right_max= self.maxDepth(root.right)\n        max_depth = max(left_max,right_max) +1\n        \n        return max_depth","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198839131","body":"## DFS preorder\næ±‚ä»æ ¹åˆ°å¶å­çš„è·¯å¾„ä¹‹å’Œï¼Œé‚£æˆ‘ä»¬åªéœ€è¦æŠŠæ¯æ¡æ ¹åˆ°å¶å­çš„è·¯å¾„æ‰¾å‡ºæ¥ï¼Œå¹¶æ±‚å’Œå³å¯ï¼Œè¿™é‡Œç”¨ DFS å»è§£ï¼ŒDFS ä¹Ÿæ˜¯æœ€å®¹æ˜“æƒ³åˆ°çš„ã€‚\n## ä»£ç \n```\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        \n        def dfs(root,cur):\n            if not root: return 0\n            if not root.left and not root.right: return cur*10 + root.val\n            return dfs(root.left, cur*10 + root.val) + dfs(root.right, cur*10 + root.val)\n        \n        return dfs(root,0)\n```\n\n---\n```\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        \n        if not root:\n            return 0\n        total = 0\n        \n        \n        def dfs(node,num):\n            \n            nonlocal total\n            num = num*10 + node.val\n            \n            if node.left is None and node.right is None:\n                total += num\n                return\n            if node.left is not None:\n                dfs(node.left,num)\n            if node.right is not None:\n                dfs(node.right,num)\n                \n        dfs(root,total)\n        return total\n```\n\n---\n```\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        total = 0\n        stack = [(root,0)]\n        \n        while stack:\n            root, curr_num = stack.pop()\n            if root is not None:\n                curr_num = curr_num * 10 + root.val\n                if root.left is None and root.right is None:\n                    total += curr_num\n                else:\n                    stack.append((root.left, curr_num))\n                    stack.append((root.right,curr_num))\n        return total\n```\n\n## å¤æ‚åº¦\n\nä»¤ n ä¸ºèŠ‚ç‚¹æ€»æ•°ï¼Œ h ä¸ºæ ‘çš„é«˜åº¦ã€‚\n\næ—¶é—´å¤æ‚åº¦ï¼šO(n)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(h)\n\n## BFS\nè¦æ±‚æ ¹åˆ°çš„å¶å­çš„è·¯å¾„çš„å’Œï¼Œé‚£æˆ‘ä»¬æŠŠä¸­é—´æ¯ä¸€å±‚å¯¹åº”çš„å€¼éƒ½æ±‚å‡ºæ¥ï¼Œå½“å‰å±‚çš„èŠ‚ç‚¹æ˜¯å¶å­èŠ‚ç‚¹ï¼ŒæŠŠå¯¹åº”å€¼ç›¸åŠ å³å¯ã€‚\n## ä»£ç \n```\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        \n        res= 0\n        q = deque()\n        q.append((root,0))\n        \n        while q:\n            node,value = q.popleft()\n            if node.left:\n                q.append((node.left,value*10+node.val))\n            if node.right:\n                q.append((node.right,value*10 + node.val))\n            if not node.left and not node.right:\n                res += value*10 +node.val\n        return res\n```\n## å¤æ‚åº¦\nä»¤ n ä¸ºèŠ‚ç‚¹æ€»æ•°ï¼Œ q ä¸ºé˜Ÿåˆ—é•¿åº¦ã€‚\n\næ—¶é—´å¤æ‚åº¦ï¼šO(n)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(q)ã€‚æœ€åçš„æƒ…å†µæ˜¯æ»¡äºŒå‰æ ‘ï¼Œæ­¤æ—¶å’Œ n åŒé˜¶ã€‚\n\nä¸ºä»€ä¹ˆç©ºé—´å¤æ‚åº¦å’Œ nåŒé˜¶å‘¢ï¼Ÿè¿™æ˜¯å› ä¸ºå¶å­èŠ‚ç‚¹çš„æ•°ç›®åœ¨æç«¯æƒ…å†µä¸‹æ˜¯å®Œå…¨äºŒå‰æ ‘ï¼Œæ­¤æ—¶çš„å¶å­èŠ‚ç‚¹çš„æ•°ç›®å·®ä¸å¤šå’Œ n/2 ç›¸ç­‰ã€‚","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200225858","body":"â€™â€˜â€™\n\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return None\n        \n        queue = []\n            \n        heapq.heappush(queue,(1,1,root))\n        ans = None\n        \n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                level, i ,node  = heapq.heappop(queue)\n                ans  = node\n                if node.right:\n                    heapq.heappush(queue,(level+1,i*2+1,node.right))\n                if node.left:\n                    heapq.heappush(queue,(level+1,i*2+2,node.left))\n        return ans.val\n\nâ€˜â€™â€˜","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201973532","body":"'''\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        memo = {}\n \n        \n        for i, val in enumerate(nums):\n            other = target - val\n            if other in memo:\n                return [i,memo[other]]\n            memo[val] = i\n            \n        return None\n                \n\n'''","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yopming":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1191779377","body":"### æ€è·¯\næŠŠkæœ¬èº«ä½œä¸ºcarry numberã€‚å¯¹numè¿›è¡Œå¾ªç¯ï¼Œä»å³åˆ°å·¦å¯¹numçš„æ¯ä¸€ä½ä¸kç›¸åŠ ï¼ˆkåœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ä¼šå»æ‰æœ€å³çš„ä¸€ä½ï¼‰ï¼Œå¦‚æœç›¸åŠ ä¹‹åå¤§äº10ï¼Œåªä¿ç•™ä¸ªä½æ•°ï¼Œå…¶ä½™çš„æ•°assignç»™kï¼Œå¸¦ç»™å‰é¢ã€‚ä¹‹åkå¯èƒ½è¿˜ä¼šå¤§äº0ï¼Œå°±æ’å…¥åˆ°numçš„å‰éƒ¨ã€‚\n\n### ä»£ç \n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n      for (int i = num.size() - 1; i >= 0 && k > 0; i--) {\n        num[i] += k;\n        k = num[i] / 10;\n        num[i] %= 10;\n      }\n      \n      while (k > 0) {\n        num.insert(num.begin(), k % 10);\n        k /= 10;\n      }\n      \n      return num;\n    }\n};\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ $O(n)$\n- ç©ºé—´å¤æ‚åº¦ $O(1)$","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186049958","body":"### æ€è·¯\nåŒå‘éå†ã€‚ä¸€ä¸ªcharacterç¦»cæœ€è¿‘è·ç¦»åªæœ‰ä¸¤ç§æƒ…å†µï¼Œè¦ä¹ˆåˆ°å·¦è¾¹çš„cï¼Œè¦ä¹ˆåˆ°å³è¾¹çš„cã€‚ç¬¬ä¸€æ¬¡éå†å¾—å‡ºæ¥æ¯ä¸ªcharacterä¸å…¶å·¦è¾¹çš„cçš„è·ç¦»ï¼ˆè‹¥å‡ºç°åœ¨cä¹‹å‰ï¼Œè·ç¦»ä¸ºs.size()ï¼‰ï¼›ç¬¬äºŒæ¬¡éå†å¾—å‡ºæ¥æ¯ä¸ªcharacterä¸å…¶å³è¾¹çš„cçš„è·ç¦»ï¼Œå–è¾ƒå°çš„é‚£ä¸ªã€‚\n\n### ä»£ç \n```lang-c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n      std::vector<int> distances(s.size());\n      if (s.size() <= 0) {\n        return distances;\n      }\n      \n      int len = s.size();\n      int curr = len;\n      \n      // left traversal\n      for (int i = 0; i < s.size(); i++) {\n        if (s[i] == c) {\n          curr = i;\n          distances[i] = 0;\n        } else {\n          distances[i] = std::min(len, std::abs(i - curr));\n        }\n      }\n      \n      // right traversal\n      for (int i = s.size() - 1; i >= 0; i--) {\n        if (s[i] == c) {\n          curr = i;\n        } else {\n          distances[i] = std::min(distances[i], std::abs(i - curr));\n        }\n      }\n      \n      return distances;\n    }\n};\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n) in which n is the size of string s.\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1) if the return vector is not counted.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186258412","body":"### æ€è·¯\r\nä½¿ç”¨vectoræ¥å­˜å‚¨æ•°æ®ï¼Œä½¿ç”¨å•ç‹¬ä¸€ä¸ªå˜é‡æ¥å­˜å‚¨stackçš„sizeã€‚\r\npushçš„æ—¶å€™ï¼Œå…ˆæ£€æŸ¥å½“å‰vectorçš„sizeæ˜¯å¦å°äºstack size limitã€‚ç„¶åæŠŠè¦æ’å…¥çš„æ•°æ”¾åœ¨vectorçš„å°¾éƒ¨ã€‚\r\npopçš„æ—¶å€™ï¼Œå…ˆæ£€æŸ¥å½“å‰vectoræ˜¯å¦ä¸ºç©ºï¼Œè¿”å›-1å¦‚æœä¸ºç©ºã€‚å…ˆæš‚å­˜vectorçš„back()ï¼Œç„¶åpop_back()ï¼Œæ¥ç€è¿”å›æš‚å­˜çš„back()å€¼ï¼Œä¹Ÿå°±æ˜¯stackåè¿›å…ˆå‡ºï¼ˆåè¿›çš„æ•°åœ¨vectorå°¾éƒ¨ï¼‰ã€‚\r\nincrementçš„forå¾ªç¯è¦æ£€æŸ¥ä¸¤ä¸ªè¾¹ç•Œï¼Œä¸€ä¸ªæ˜¯kï¼Œä¸€ä¸ªæ˜¯vectorçš„å¤§å°ã€‚\r\n\r\n### ä»£ç \r\n```c++\r\nclass CustomStack {\r\nprivate:\r\n  std::vector<int> arr;\r\n  int stack_limit_;\r\n\r\npublic:\r\n    CustomStack(int maxSize) {\r\n      this->stack_limit_ = maxSize;\r\n    }\r\n    \r\n    void push(int x) {\r\n      if (arr.size() < this->stack_limit_) {\r\n        arr.push_back(x);\r\n      }\r\n    }\r\n    \r\n    int pop() {\r\n      if (arr.size() <= 0) {\r\n        return -1;\r\n      }\r\n      int back = arr.back();\r\n      arr.pop_back();\r\n      return back;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n      for (int i = 0; i < k; i++) {\r\n        if (i == arr.size()) {\r\n          break;\r\n        }\r\n        \r\n        arr[i] += val;\r\n      }\r\n    }\r\n};\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šConstructor $O(1)$, push $O(1)$, pop() $O(1)$, increment $O(k)$ in which k stands for the number of elements need to increase.\r\n- ç©ºé—´å¤æ‚åº¦ï¼šOne vector and one int usedï¼Œtherefore $O(n)$ in which $n$ stands for stack size.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186668073","body":"### æ€è·¯\nä½¿ç”¨ä¸¤ä¸ªstackï¼Œä¸€ä¸ªå­˜æ•°å­—ï¼Œä¸€ä¸ªå­˜ä¹‹å‰å·²ç»decodeå®Œæˆçš„éƒ¨åˆ†ã€‚\nç”±äºinputæ˜¯validï¼Œåªå­˜åœ¨å¦‚ä¸‹4ä¸­æƒ…å†µ\n* digit: å­˜å…¥stack1ã€‚éœ€è¦æ³¨æ„è¶…è¿‡9çš„æ•°å­—ï¼Œéœ€è¦å…ˆæš‚å­˜ã€‚\n* alphabet: æ‹¼æ¥åˆ°å±€éƒ¨å˜é‡\n* `[`: æŠŠæ•°å­—å’Œå·²ç»ä¹‹å‰å·²ç»deocdeçš„stringæ”¾å…¥å„è‡ªstack\n* `]`: æ­¤æ—¶å½“å‰æ‹¬å·å†…çš„stringè¿˜æ²¡æœ‰è¢«pushåˆ°stack2ï¼Œè€Œéœ€è¦é‡å¤çš„æ•°å­—å·²ç»è¢«pushäº†ï¼Œæ‰€ä»¥è¦ä»stack1å–topå€¼ã€‚ç„¶åéœ€è¦æŠŠä¹‹å‰decodeå®Œæˆçš„éƒ¨åˆ†å–å‡ºæ¥ï¼Œæ‹¼æ¥å½“å‰æ‹¬å·çš„å†…å®¹ã€‚æœ€åè¦æŠŠæ‹¼æ¥å¥½çš„stringèµ‹äºˆå±€éƒ¨å˜é‡ï¼Œä»¥å¤‡ä¸‹ä¸€æ¬¡pushæ—¶å€™æ‰€ç”¨ã€‚\n\n### ä»£ç \n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n      if (s.empty()) {\n        return s;\n      }\n      \n      std::string k;    // temp\n      std::string str;  // temp\n      std::stack<int> countStack;\n      std::stack<std::string> stringStack;\n      \n      for (auto& ch: s) {\n        if (isdigit(ch)) {\n          k += ch;\n        } else if (isalpha(ch)) {\n          str += ch;\n        } else if (ch == '[') {\n          countStack.push(std::stoi(k));\n          stringStack.push(str);\n          k = \"\";\n          str = \"\";\n        } else if (ch == ']') {\n          // get previously decoded, such as in 3[a]2[bc]\n          // second '[' push 'aaa' to stack, get them now\n          std::string decodedString = stringStack.top();\n          stringStack.pop();\n          \n          // str is not pushed to stack yet, but times is already pushed\n          for (int i = 0; i < countStack.top(); i++) {\n            decodedString += str;\n          }\n          countStack.pop();\n          \n          // remember the local variable\n          str = decodedString;\n        }\n      }\n      \n      return str;\n    }\n};\n```\n\n**å¤æ‚åº¦åˆ†æ**\nAssume $N$ is the length of input string.\n- æ—¶é—´å¤æ‚åº¦ $O(kN)$ such that $k$ is the maximum of digits in the input string.\n- ç©ºé—´å¤æ‚åº¦ $O(N)$ or $O(m+n)$ such that $m$ is the number of digits, $n$ is the number of alphabets and $m+n <= N$ since the existence of brackets.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188059775","body":"### æ€è·¯\nä¸¤ä¸ªstackï¼Œä¸€ä¸ªâ€œæ­£åºâ€ï¼Œä¸€ä¸ªâ€œé€†åºâ€ï¼Œè¿™æ ·pushçš„æ—¶å€™pushåˆ°æ­£åºï¼Œpopçš„æ—¶å€™ä»é€†åºpopï¼Œè¿™æ ·å°±å¯ä»¥å®ç°FIFOï¼Œä¸¤ä¸ªstackå„å®ç°ä¸€åŠã€‚\n\n### ä»£ç \n```c++\nclass MyQueue {\n  std::stack<int> stack0;\n  std::stack<int> stackQ;\n  \npublic:\n    MyQueue() {}\n    \n    void push(int x) {\n      // move everything from stackQ to stack0\n      while (!stackQ.empty()) {\n        stack0.push(stackQ.top());\n        stackQ.pop();\n      }\n      \n      stack0.push(x);\n      \n      // move from stack0 to stackQ\n      while (!stack0.empty()) {\n        stackQ.push(stack0.top());\n        stack0.pop();\n      }\n    }\n    \n    int pop() {\n      if (stackQ.empty()) {\n        return -1;\n      }\n      \n      int ele = stackQ.top();\n      stackQ.pop();\n      return ele;\n    }\n    \n    int peek() {\n      if (stackQ.empty()) {\n        return -1;\n      }\n      \n      return stackQ.top();\n    }\n    \n    bool empty() {\n      return stackQ.empty();\n    }\n};\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ $O(1)$ for pop(), peek(), and empty(), $O(n)$ for push()\n- ç©ºé—´å¤æ‚åº¦ $O(n)$ since two stacks are used","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189460643","body":"### æ€è·¯\næ‰¾æœ€å¤§å—çš„æ•°é‡ä¹Ÿå°±æ˜¯æ‰¾å•è°ƒå‡è¿ç»­æ•°å­—çš„æ•°é‡ã€‚æ¯”å¦‚ 21355 å°±æ˜¯ 21 3 5 5ï¼Œä½†å¦‚æœæ˜¯ 213554 çš„è¯ï¼Œå°±å˜æˆäº† 21 3 554ï¼Œä¸¤ä¸ªç›¸åŒçš„æ•°èƒ½ä¸èƒ½åˆ†å‰²å–å†³äºä¹‹åæœ‰æ²¡æœ‰æ•°å­—ã€‚\n\né‡åˆ°ä¸€ä¸ªå¤§äºæ ˆé¡¶çš„æ•°å­—ï¼Œå°±å°†å…¶å‹å…¥æ ˆï¼Œå½“ä½œæ˜¯ä¸€ä¸ªæ–°chunkçš„å¼€å¤´ï¼Œä½†æ˜¯ä¸€æ—¦åé¢é‡åˆ°å°çš„æ•°å­—äº†ï¼Œå°±è¦åè¿‡æ¥æ£€æŸ¥å‰é¢çš„æ•°å­—ï¼Œä¸åœçš„popæ ˆé¡¶ï¼Œçœ‹çœ‹è¿™ä¸ªæ›´å°çš„æ•°å­—åˆ°åº•æ˜¯å°äºé‚£ä¸€ä¸ªchunkçš„å¼€å¤´ã€‚\n\næœ€åstackçš„sizeå°±æ˜¯chunkçš„æ•°é‡ã€‚\n\n### ä»£ç \n```c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n      std::stack<int> chunk;\n      for (auto ele: arr) {\n        int max = chunk.empty() ? ele : std::max(chunk.top(), ele);\n        while (!chunk.empty() && (chunk.top() > ele)) {\n          chunk.pop();\n        }\n        chunk.push(max);\n      }\n      \n      return chunk.size();\n    }\n};\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ $O(n)$\n- ç©ºé—´å¤æ‚åº¦ $O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191092435","body":"### æ€è·¯\nç”±äºkæœ‰å¯èƒ½å¤§äºlinked listçš„é•¿åº¦ï¼Œæ‰€ä»¥å…ˆéå†ä¸€élinked listæ¥å¾—åˆ°é•¿åº¦ï¼Œé¡ºä¾¿æŠŠå¤´å°¾ç›¸è¿ã€‚\nä¹‹åä»å¤´å¼€å§‹èµ°ï¼Œèµ°n-(k%n)æ­¥ï¼Œæ­¤æ—¶ä¸‹ä¸€ä¸ªèŠ‚ç‚¹å°±æ˜¯headï¼Œç„¶åæ–­å¼€è¿æ¥å³å¯ã€‚\n\n\n### ä»£ç \n```c++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n      if (!head || !head->next) {\n        return head;\n      }\n      \n      ListNode* curr = head;\n      ListNode* res;\n      int n = 1;\n      \n      // get linked list length\n      while (curr->next != nullptr) {\n        n++;\n        curr = curr->next;\n      }\n      \n      k = n - (k % n);\n      curr->next = head; // circular\n      while (k--) {\n        curr = curr->next;\n      }\n      \n      res = curr->next;\n      curr->next = nullptr;\n      return res;\n    }\n};\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ $O(n)$\n- ç©ºé—´å¤æ‚åº¦ $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1191809683","body":"### æ€è·¯\nå¯recursiveï¼Œä¹Ÿå¯iterativeã€‚  \niterativeæ–¹æ³•ä¸­ï¼Œä½¿ç”¨prevæŒ‡é’ˆæ¥æŒ‡å‘è¦swapçš„ä¹‹å‰çš„nodeã€‚ä½¿ç”¨firstå’Œsecondä¸¤ä¸ªæŒ‡é’ˆä»£æŒ‡è¦swapçš„nodesï¼Œå¯ä»¥é¿å…å‡ºç°head->next->nextè¿™ç§å¾ˆé•¿çš„æ“ä½œï¼Œè€Œä¸”å¯ä»¥æ›´å¥½ç†è§£ã€‚äº¤æ¢å®Œfirstå’Œsecondä¹‹åï¼ŒprevæŒ‡å‘swapå‰çš„firstï¼ˆä¹Ÿå°±æ˜¯swapä¹‹åçš„ç¬¬äºŒä¸ªï¼‰ï¼ŒheadæŒ‡å‘swapå‰çš„firstçš„ä¸‹ä¸€ä¸ªï¼ˆä¹Ÿå°±æ˜¯swapä¹‹åçš„ç¬¬äºŒä¸ªçš„nextï¼‰ã€‚\n\n\n### ä»£ç \n```c++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n      ListNode dummy(-1);\n      dummy.next = head;\n      ListNode* prev = &dummy;\n      \n      while (head != nullptr && head->next != nullptr) {\n        ListNode* first = head;\n        ListNode* second = head->next;\n        \n        prev->next = second;\n        first->next = second->next;\n        second->next = first;\n        \n        // reset var\n        prev = first;\n        head = first->next;\n      }\n      \n      return dummy.next;\n    }\n};\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ $O(n)$\n- ç©ºé—´å¤æ‚åº¦ $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193053243","body":"### æ€è·¯\nå…ˆæ‰¾ä¸­é—´èŠ‚ç‚¹\n\n### ä»£ç \n```c++\nclass Solution {\npublic:\n  ListNode* findMiddle(ListNode* head) {\n    ListNode* slow = head;\n    ListNode* fast = head;\n    ListNode* prev = nullptr;\n    \n    while (slow && fast && fast->next) {\n      prev = slow;\n      slow = slow->next;\n      fast = fast->next->next;\n    }\n    \n    return prev;\n  }\n  \n    TreeNode* sortedListToBST(ListNode* head) {\n      if (!head) return nullptr;\n      if (!head->next) return new TreeNode(head->val);\n      \n      // find the middle node, use it as the end of first list\n      ListNode* mid = findMiddle(head);\n      TreeNode* root = new TreeNode(mid->next->val);\n      \n      ListNode* second_head = (mid->next)->next;\n      mid->next = nullptr;\n      \n      root->left = sortedListToBST(head);\n      root->right = sortedListToBST(second_head);\n      \n      return root;\n    }\n};\n```\n\n### å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ $O(nlogn)$\n- ç©ºé—´å¤æ‚åº¦ $O(logn)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193172895","body":"### æ€è·¯\n- Two pointer: ä¸¤ä¸ªpointeræ¥éå†ä¸¤ä¸ªlinked listï¼Œå½“pointerä¸ºç©ºçš„æ—¶å€™ï¼ŒæŒ‡å‘å¦ä¸€ä¸ªlinked listçš„å¤´éƒ¨ï¼Œè¿™æ ·ä¸¤ä¸ªpointeræ€»ä¼šç›¸é‡\n- Hash tableï¼šhash tableå­˜å‚¨nodeçš„æŒ‡é’ˆï¼Œå…ˆæŠŠä¸€ä¸ªlinked listçš„æ‰€æœ‰nodeéƒ½å­˜å…¥ï¼Œç„¶åæ£€æŸ¥å¦ä¸€ä¸ªlinked listä¸­ç¬¬ä¸€ä¸ªå·²åœ¨hash tableçš„nodeï¼Œè¿™å°±æ˜¯intersection\n\n### ä»£ç \n```c++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n      ListNode* ptrA = headA;\n      ListNode* ptrB = headB;\n      \n      while (ptrA != ptrB) {\n        ptrA = (ptrA == nullptr) ? headB : ptrA->next;\n        ptrB = (ptrB == nullptr) ? headA : ptrB->next;\n      }\n      \n      return ptrA;\n    }\n};\n```\n\n```c++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n      ListNode* ptrA = headA;\n      ListNode* ptrB = headB;\n      std::unordered_map<ListNode*, int> map;\n      while (ptrA != nullptr) {\n        map[ptrA]++;\n        ptrA = ptrA->next;\n      }\n      \n      while (ptrB != nullptr) {\n        if (map[ptrB] > 0) {\n          return ptrB;\n        }\n        ptrB = ptrB->next;\n      }\n      \n      return nullptr;\n    }\n};\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ $O(m+n)$ such that $m$ and $n$ are the length of two linked lists\n- ç©ºé—´å¤æ‚åº¦ $O(1)$ for two pointers method, and $O(m)$ for hash table method such that $m$ is the length of one linked list","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193382264","body":"### æ€è·¯\nä½¿ç”¨hash tableæ¥å­˜å‚¨æ¯ä¸ªnodeçš„æŒ‡é’ˆã€‚\n\n### ä»£ç \n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n * Â  Â  int val;\n * Â  Â  ListNode *next;\n * Â  Â  ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n Â  Â ListNode *detectCycle(ListNode *head) {\n Â  Â  Â if (head == nullptr || head->next == nullptr) {\n Â  Â  Â  Â return nullptr;\n Â  Â   }\n Â  Â  Â \n Â  Â  Â ListNode* ptr = head;\n Â  Â  Â std::unordered_map<ListNode*, int> map;\n Â  Â  Â int i = 1;\n Â  Â  Â while (ptr != nullptr) {\n Â  Â  Â  Â if (map[ptr] > 0) {\n Â  Â  Â  Â  Â return ptr;\n Â  Â  Â   }\n Â  Â  Â  Â map[ptr] = i++;\n Â  Â  Â  Â ptr = ptr->next;\n Â  Â   }\n Â  Â  Â \n Â  Â  Â return nullptr;\n Â   }\n};\n```\n\n### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦ $O(n)$\n- ç©ºé—´å¤æ‚åº¦ $O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194492427","body":"### æ€è·¯\nä½¿ç”¨doubly-linked listæ¥è®°å½•orderå’Œvalueï¼Œä½¿ç”¨hash mapæ¥è®°å½•keyå’Œlinked listçš„iteratorã€‚  \nput()æ—¶å€™ï¼Œå…ˆæ£€æŸ¥keyæ˜¯å¦å­˜åœ¨ï¼Œè‹¥å­˜åœ¨å°±ç›´æ¥æ›´æ–°orderå’Œvalueï¼Œè‹¥ä¸å­˜åœ¨å…ˆæ£€æŸ¥å½“å‰hash mapçš„é•¿åº¦ã€‚å¦‚æœLRUå·²ç»æ»¡äº†ï¼Œå°±åˆ é™¤listçš„å°¾éƒ¨å’Œhash mapå¯¹åº”çš„å…ƒç´ ï¼ˆlistçš„å°¾éƒ¨æ˜¯key value pairï¼Œkeyå¯ä»¥æ‹¿æ¥ç»™hash mapï¼‰ï¼›å¦‚æœä¸æ»¡ç›´æ¥æ’å…¥åˆ°listçš„å¤´éƒ¨ï¼Œç„¶åæŠŠlist.begin()è®°å½•åˆ°hash mapä¸­ã€‚  \nget()æ—¶å€™ï¼Œå…ˆæ£€æŸ¥keyæ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨å°±æ›´æ–°orderï¼Œè¿”å›valueï¼Œå¦‚æœä¸å­˜åœ¨ï¼Œç›´æ¥è¿”å›-1ã€‚\ntouch()å¯ä»¥æ›´æ–°orderå’Œvalueï¼Œæœ¬è´¨ä¸Šå°±æ˜¯é€šè¿‡keyæ¥æ‰¾åˆ°hash mapä¸­çš„iteratorï¼Œç„¶ååˆ é™¤listä¸­çš„é‚£ä¸ªå…ƒç´ ï¼Œå†æ’å…¥åˆ°listå¤´éƒ¨ï¼ˆè¿™é‡Œå¯ä»¥æ›´æ–°valueï¼‰ï¼Œå°†æ–°çš„iteratorè®°å½•åˆ°hash mapä¸­ã€‚\n\n### ä»£ç \n\n```c++\nclass LRUCache {\n Â int size;\n Â std::list<std::pair<int, int>> list0; // maintaining used order\n Â std::unordered_map<int, std::list<std::pair<int, int>>::iterator> map;\n Â \npublic:\n Â  Â LRUCache(int capacity) {\n Â  Â  Â this->size = capacity;\n Â   }\n Â \n Â  Â /// update value and order. (remove it from tail, put it to head)\n Â  Â void touch(int key, int value) {\n Â  Â  Â auto it = map[key];\n Â  Â  Â list0.erase(it);\n Â  Â  Â list0.push_front({key, value});\n Â  Â  Â map[key] = list0.begin();\n Â   }\n Â  Â \n Â  Â int get(int key) {\n Â  Â  Â if (map.find(key) != map.end()) {\n Â  Â  Â  Â int value = map[key]->second;\n Â  Â  Â  Â touch(key, value);\n Â  Â  Â  Â return value;\n Â  Â   }\n Â  Â  Â return -1;\n Â   }\n Â  Â \n Â  Â void put(int key, int value) {\n Â  Â  Â if (map.find(key) != map.end()) {\n Â  Â  Â  Â // key exist, touch it\n Â  Â  Â  Â touch(key, value);\n Â  Â  Â  Â return;\n Â  Â   }\n Â  Â  Â \n Â  Â  Â if (map.size() == this->size) {\n Â  Â  Â  Â int key = list0.back().first;\n Â  Â  Â  Â map.erase(key);\n Â  Â  Â  Â list0.pop_back();\n Â  Â   }\n Â  Â  Â list0.push_front({key, value});\n Â  Â  Â map[key] = list0.begin();\n Â   }\n};\nâ€‹\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n```\n\n### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦ $O(1)$ for get() and put() since hash map records iterator, no need to traverse the linked list to find specific element.\n- ç©ºé—´å¤æ‚åº¦ $O(n)$ such that $n$ is the capacity of LRU (both linked list and hash map are of size $n$)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1195995677","body":"### æ€è·¯\né€’å½’ã€‚å½“å‰nodeä¸ºä¸€å±‚ï¼Œå–left childå’Œright childçš„å±‚æ•°åŠ ä¸€ã€‚é€’å½’å‡½æ•°çš„è¿”å›ç‚¹ä¸ºå½“å‰nodeä¸ºnullptrï¼Œåˆ™return 0\n\n### ä»£ç \n```c++\nclass Solution {\npublic:\n Â  Â int maxDepth(TreeNode* root) {\n Â  Â  Â if (root == nullptr) {\n Â  Â  Â  Â return 0;\n Â  Â   }\n Â  Â  Â \n Â  Â  Â return 1 + std::max(maxDepth(root->left), maxDepth(root->right));\n Â   }\n};\n```\n\n### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦ O(n)\n- ç©ºé—´å¤æ‚åº¦ O(log n)ï¼Œé€’å½’æœ¬èº«æ¶ˆè€—å­˜å‚¨ç©ºé—´ï¼Œé€’å½’æ¬¡æ•°ä¸ºtreeçš„é«˜åº¦ï¼Œå³log n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197289845","body":"### æ€è·¯\nè·ŸDay 13ç±»ä¼¼ï¼Œè‹¥å½“å‰nodeéƒ½ä¸ºç©ºï¼Œç›´æ¥è¿”å›trueï¼ˆreturné€»è¾‘ï¼‰ï¼Œè‹¥éƒ½ä¸ä¸ºç©ºå¹¶ä¸”valueç›¸åŒï¼Œå­˜å‚¨å½“å‰åˆ¤å®šï¼Œä¸å„è‡ªleftå’Œrightçš„åˆ¤æ–­è¿›è¡ŒANDè¿ç®—ã€‚\n\n### ä»£ç \n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n * Â  Â  int val;\n * Â  Â  TreeNode *left;\n * Â  Â  TreeNode *right;\n * Â  Â  TreeNode() : val(0), left(nullptr), right(nullptr) {}\n * Â  Â  TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n * Â  Â  TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n Â  Â bool isSameTree(TreeNode* p, TreeNode* q) {\n Â  Â  Â if (p == nullptr && q == nullptr) {\n Â  Â  Â  Â return true;\n Â  Â   }\n Â  Â  Â \n Â  Â  Â bool cmp_current = false;\n Â  Â  Â if (p != nullptr && q != nullptr && p->val == q->val) {\n Â  Â  Â  Â cmp_current = true;\n Â  Â   }\n Â  Â  Â  Â \n Â  Â  Â return cmp_current && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n Â   }\n};\n```\n\n### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦ $O(n)$\n- ç©ºé—´å¤æ‚åº¦ $O(log n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198807274","body":"### æ€è·¯\nä½¿ç”¨DFSæ–¹æ³•ã€‚ä»ä¾‹å­ä¸­å¯ä»¥æ³¨æ„åˆ°ï¼Œå½“pushåˆ°stackæ—¶å€™ï¼Œæ­¤æ—¶baseè¦ä¹˜ä»¥10åŠ ä¸Šå½“å‰nodeçš„å€¼ï¼›è€Œå½“popçš„æ—¶å€™ï¼Œå¦‚æœnodeçš„leftå’Œrightéƒ½ä¸ºç©ºï¼ˆå¶å­ï¼‰ï¼Œåˆ™æŠŠç´¯ç§¯çš„å€¼åŠ åˆ°sumé‡Œé¢ã€‚\n\n### ä»£ç \n\n```c++\nclass Solution {\npublic:\n Â  Â int sumNumbers(TreeNode* root) {\n Â  Â  Â if (root == nullptr) return 0;\n Â  Â  Â \n Â  Â  Â int sum = 0;\n Â  Â  Â \n Â  Â  Â TreeNode* ptr = root;\n Â  Â  Â std::stack<std::pair<TreeNode*, int>> stk;\n Â  Â  Â stk.emplace(ptr, ptr->val);\n Â  Â  Â \n Â  Â  Â while (!stk.empty()) {\n Â  Â  Â  Â auto [node, val] = stk.top();\n Â  Â  Â  Â stk.pop();\n Â  Â  Â  Â \n Â  Â  Â  Â // node is leaf, add accumulative value to sum\n Â  Â  Â  Â if (node->left == nullptr && node->right == nullptr) {\n Â  Â  Â  Â  Â sum += val;\n Â  Â  Â   }\n Â  Â  Â  Â \n Â  Â  Â  Â // node is not leaf, base * 10 + current value\n Â  Â  Â  Â if (node->left != nullptr) {\n Â  Â  Â  Â  Â stk.emplace(node->left, val * 10 + node->left->val);\n Â  Â  Â   }\n Â  Â  Â  Â if (node->right != nullptr) {\n Â  Â  Â  Â  Â stk.emplace(node->right, val * 10 + node->right->val);\n Â  Â  Â   }\n Â  Â   }\n Â  Â  Â \n Â  Â  Â return sum;\n Â   }\n};\n```\n\n### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦ $O(n)$ æ¯ä¸ªèŠ‚ç‚¹éƒ½éå†åˆ°\n- ç©ºé—´å¤æ‚åº¦ $O(n)$ stackçš„sizeä¸ºèŠ‚ç‚¹æ•°é‡","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1199835874","body":"### æ€è·¯\nä½¿ç”¨DFSï¼Œstackä¸­è®°å½•å½“å‰æ·±åº¦ï¼Œä½¿ç”¨hash mapæ¥è®°å½•æ¯å±‚æœ€å·¦çš„å€¼ã€‚\n\nç”±äºæ˜¯stack FILOï¼Œæ‰€ä»¥å…ˆæŠŠright childå­˜å…¥ï¼Œè¿™æ ·popçš„æ—¶å€™å¯ä»¥ä¿è¯bottom leftæ˜¯æœ¬å±‚æœ€åpopçš„é‚£ä¸ªèŠ‚ç‚¹ï¼Œhash mapä¸­ä¹Ÿå°±è¢«ä¸€ç›´æ›´æ–°ã€‚\n\nä¸€ä¸ªå•ç‹¬å˜é‡å­˜å‚¨æœ€æ·±çš„å±‚æ•°ï¼Œæœ€åè¿”å›hash mapçš„å¯¹åº”å€¼å³å¯ã€‚\n\n### ä»£ç \n```c++\nclass Solution {\npublic:\n Â  Â int findBottomLeftValue(TreeNode* root) {\n Â  Â  Â if (root == nullptr) return -1;\n Â  Â  Â if (root->left == nullptr && root->right == nullptr) return root->val;\n Â  Â  Â \n Â  Â  Â int deep = 0;\n Â  Â  Â TreeNode* ptr = root;\n Â  Â  Â std::unordered_map<int, int> map;\n Â  Â  Â std::stack<std::pair<TreeNode*, int>> stk;\n Â  Â  Â stk.emplace(ptr, 0);\n Â  Â  Â map[0] = ptr->val;\n Â  Â  Â \n Â  Â  Â while (!stk.empty()) {\n Â  Â  Â  Â auto [node, level] = stk.top();\n Â  Â  Â  Â stk.pop();\n Â  Â  Â  Â map[level] = node->val;\n Â  Â  Â  Â deep = std::max(deep, level);\n Â  Â  Â  Â \n Â  Â  Â  Â if (node->left != nullptr) {\n Â  Â  Â  Â  Â stk.emplace(node->left, level+1);\n Â  Â  Â   }\n Â  Â  Â  Â if (node->right != nullptr) {\n Â  Â  Â  Â  Â stk.emplace(node->right, level+1);\n Â  Â  Â   }\n Â  Â   }\n Â  Â  Â \n Â  Â  Â return map[deep];\n Â   }\n};\n```\n\n### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦ $O(n)$ æ¯ä¸ªèŠ‚ç‚¹éƒ½éå†åˆ°ä¸€éäº†\n- ç©ºé—´å¤æ‚åº¦ $O(n)$ hash mapé•¿åº¦æœ€å¤§æ˜¯èŠ‚ç‚¹æ•°ï¼ˆæ¯å±‚éƒ½æ˜¯å•å­æ ‘ï¼‰ï¼Œstacké•¿åº¦æ˜¯èŠ‚ç‚¹æ•°","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200318570","body":"### æ€è·¯\nSerialize(): ä½¿ç”¨queueï¼Œä¸€å±‚ä¸€å±‚å¾€ä¸‹pushåˆ°queueï¼Œç„¶åpopçš„æ—¶å€™appendåˆ°stringã€‚  \nDeseriaize(): å› ä¸ºSerialize()ä½¿ç”¨queueï¼Œè¿™é‡Œä¹Ÿè¦ä½¿ç”¨queueã€‚å› C++ä¸­æ²¡æœ‰splitå‡½æ•°ï¼Œä½¿ç”¨getlineå‡½æ•°è¯»stringstreamä¸€ç›´åˆ°é€—å·ï¼Œè¿™æ ·å°±å¾—åˆ°äº†æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„å€¼ã€‚ä¹Ÿæ˜¯æŒ‰å±‚æ¥æ„å»ºæ ‘ï¼Œqueueé‡Œé¢æ¯ä¸€ä¸ªå¾ªç¯çš„æ—¶å€™ï¼Œéƒ½getlineè¯»ä¸¤æ¬¡è·å¾—leftå’Œrightã€‚\n\n### ä»£ç \n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n * Â  Â  int val;\n * Â  Â  TreeNode *left;\n * Â  Â  TreeNode *right;\n * Â  Â  TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Codec {\npublic:\nâ€‹\n Â  Â // Encodes a tree to a single string.\n Â  Â string serialize(TreeNode* root) {\n Â  Â  Â std::string str = \"\";\n Â  Â  Â if (root == nullptr) {\n Â  Â  Â  Â return str;\n Â  Â   }\n Â  Â  Â \n Â  Â  Â std::queue<TreeNode*> q;\n Â  Â  Â q.push(root);\n Â  Â  Â while (!q.empty()) {\n Â  Â  Â  Â TreeNode* node = q.front();\n Â  Â  Â  Â q.pop();\n Â  Â  Â  Â \n Â  Â  Â  Â if (node == nullptr) {\n Â  Â  Â  Â  Â str.append(\"null,\");\n Â  Â  Â   } else {\n Â  Â  Â  Â  Â str.append(std::to_string(node->val) + \",\");\n Â  Â  Â  Â  Â q.push(node->left);\n Â  Â  Â  Â  Â q.push(node->right);\n Â  Â  Â   }\n Â  Â   }\n Â  Â  Â return str;\n Â   }\nâ€‹\n Â  Â // Decodes your encoded data to tree.\n Â  Â TreeNode* deserialize(string data) {\n Â  Â  Â if (data.size() == 0) {\n Â  Â  Â  Â return nullptr;\n Â  Â   }\n Â  Â  Â \n Â  Â  Â std::queue<TreeNode*> q;\n Â  Â  Â std::stringstream stream(data);\n Â  Â  Â std::string item;\n Â  Â  Â char del = ',';\n Â  Â  Â \n Â  Â  Â std::getline(stream, item, del);\n Â  Â  Â TreeNode* head = new TreeNode(std::stoi(item));\n Â  Â  Â q.push(head);\n Â  Â  Â \n Â  Â  Â while (!q.empty()) {\n Â  Â  Â  Â TreeNode* node = q.front();\n Â  Â  Â  Â q.pop();\n Â  Â  Â  Â \n Â  Â  Â  Â // left child\n Â  Â  Â  Â std::getline(stream, item, del);\n Â  Â  Â  Â if (item == \"null\") {\n Â  Â  Â  Â  Â node->left = nullptr;\n Â  Â  Â   } else {\n Â  Â  Â  Â  Â TreeNode* child_left = new TreeNode(std::stoi(item));\n Â  Â  Â  Â  Â node->left = child_left;\n Â  Â  Â  Â  Â q.push(child_left);\n Â  Â  Â   }\n Â  Â  Â  Â \n Â  Â  Â  Â // right child\n Â  Â  Â  Â std::getline(stream, item, del);\n Â  Â  Â  Â if (item == \"null\") {\n Â  Â  Â  Â  Â node->right = nullptr;\n Â  Â  Â   } else {\n Â  Â  Â  Â  Â TreeNode* child_right = new TreeNode(std::stoi(item));\n Â  Â  Â  Â  Â node->right = child_right;\n Â  Â  Â  Â  Â q.push(child_right);\n Â  Â  Â   }\n Â  Â   }\n Â  Â  Â \n Â  Â  Â return head;\n Â   }\n};\nâ€‹\n// Your Codec object will be instantiated and called as such:\n// Codec ser, deser;\n// TreeNode* ans = deser.deserialize(ser.serialize(root));\n```\n\n### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦ $O(n)$\n- ç©ºé—´å¤æ‚åº¦ $O(n)$ queueä¸­æœ€å¤šä¸ä¼šè·Ÿtreeçš„nodeæ•°é‡ä¸€æ ·","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200496795","body":"### æ€è·¯\nä¸­å¿ƒæ€æƒ³è¿˜æ˜¯DFSï¼Œéå†çš„æ—¶å€™æŠŠx y å’Œ valéƒ½è®°å½•åœ¨stackä¸­ï¼Œæ–¹ä¾¿æœ€åçš„æ¯”è¾ƒã€‚æ‰€ä»¥è¿™é‡Œæ„å»ºäº†ä¸€ä¸ªstructæ¥è®°å½•x y ä¸ valï¼ŒåŒæ—¶è¿˜æœ‰ä¸€ä¸ªsortçš„æ–¹æ³•ï¼Œå…ˆæ¯”è¾ƒxï¼Œå†æ¯”è¾ƒyï¼Œæœ€åæ‰æ˜¯valå¦‚æœä¸¤ä¸ªèŠ‚ç‚¹çš„xå’Œyéƒ½ç›¸ç­‰çš„è¯ã€‚\n\nä½¿ç”¨ä¸€ä¸ªhashmapæ¥æŒ‰ç…§yä¹Ÿå°±æ˜¯vertical orderä½œä¸ºhashå­˜å‚¨nodeçš„vectorï¼ˆåº”ç”¨è‡ªå®šä¹‰sortæ–¹æ³•çš„åœ°æ–¹ï¼‰ï¼Œä¹Ÿå°±æ˜¯æ‰€æœ‰vertical orderä¸º0çš„åœ¨ä¸€ä¸ªvectorä¸­ï¼Œvectical orderä¸º1çš„åœ¨ä¸€ä¸ªvectorä¸­ï¼Œä»¥æ­¤ç±»æ¨ã€‚\n\nåŒæ—¶ï¼Œhashmapä¸­ä¸èƒ½ä¿è¯keyæ˜¯sortedçš„ï¼Œå¯ä»¥æ ¹æ®é¢˜ç›®çš„ç»™å‡ºçš„èŠ‚ç‚¹æ•°é‡é™åˆ¶[0-1000]æ¥åšä¸€ä¸ªå¤§çš„hashmapï¼Œä½†æ›´é€šç”¨çš„åšæ³•æ˜¯æŠŠvertical orderä¿å­˜åœ¨ä¸€ä¸ªsetä¸­ï¼Œè¿™æ ·å°±å¯ä»¥ä»setä¸­ä¸€ä¸ªä¸€ä¸ªæ‹¿vertical orderï¼Œç„¶åç”¨è¿™ä¸ªvertical orderä»hashmapä¸­å–nodeçš„vectorï¼ˆæ’åºè¿‡çš„ï¼‰ï¼Œç„¶åç”ŸæˆäºŒç»´vectorè¿”å›ã€‚\n\n### ä»£ç \n\n```c++\nclass Solution {\npublic:\n Â struct Node {\n Â  Â int x;\n Â  Â int y;\n Â  Â int val;\n Â  Â \n Â  Â Node(int x_, int y_, int val_): x(x_), y(y_), val(val_) {}\n Â };\n Â \n Â // sort by row, column, value\n Â static bool cmp(Node a, Node b) {\n Â  Â if (a.x ^ b.x) {\n Â  Â  Â return a.x < b.x;\n Â   }\n Â  Â if (a.y ^ b.y) {\n Â  Â  Â return a.y < b.y;\n Â   }\n Â  Â return a.val < b.val;\n  }\n Â \n Â vector<vector<int>> verticalTraversal(TreeNode* root) {\n Â  Â std::vector<std::vector<int>> results;\n Â  Â if (root == nullptr) return results;\nâ€‹\n Â  Â Node node_root = {0, 0, root->val};\n Â  Â \n Â  Â std::set<int> orders;\n Â  Â std::unordered_map<int, std::vector<Node>> map;\n Â  Â std::stack<std::pair<TreeNode*, Node>> stk;\n Â  Â \n Â  Â stk.emplace(root, node_root);\n Â  Â while (!stk.empty()) {\n Â  Â  Â auto top = stk.top();\n Â  Â  Â stk.pop();\n Â  Â  Â \n Â  Â  Â TreeNode* top_node = top.first;\n Â  Â  Â int order_x = top.second.x;\n Â  Â  Â int order_y = top.second.y;\n Â  Â  Â map[order_y].push_back(top.second);\n Â  Â  Â if (orders.count(order_y) == 0) {\n Â  Â  Â  Â orders.insert(order_y);\n Â  Â   }\n Â  Â  Â \n Â  Â  Â if (top_node->left) {\n Â  Â  Â  Â Node left = {order_x + 1, order_y - 1, top_node->left->val};\n Â  Â  Â  Â stk.emplace(top_node->left, left);\n Â  Â   }\n Â  Â  Â if (top_node->right) {\n Â  Â  Â  Â Node right = {order_x + 1, order_y + 1, top_node->right->val};\n Â  Â  Â  Â stk.emplace(top_node->right, right);\n Â  Â   }\n Â  Â }\nâ€‹\n Â  Â for (auto order: orders) {\n Â  Â  Â std::vector<Node> nodes = map[order];\n Â  Â  Â std::sort(nodes.begin(), nodes.end(), cmp);\n Â  Â  Â std::vector<int> result;\n Â  Â  Â for (auto node: nodes) {\n Â  Â  Â  Â result.push_back(node.val);\n Â  Â   }\n Â  Â  Â results.push_back(result);\n Â   }\nâ€‹\n Â  Â return results;\n  }\n};\n```\n\n### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦ O(n logn). log næ˜¯æ’åºçš„æ—¶é—´å¤æ‚åº¦ï¼Œå› ä¸ºæ’åºåœ¨forå¾ªç¯ä¸­ï¼Œå¾ªç¯æœ€å¤§æ•°é‡æ˜¯ nï¼Œä¹Ÿå°±æ˜¯èŠ‚ç‚¹æ•°é‡ã€‚è™½ç„¶æœ‰ç¬¬äºŒå±‚forå¾ªç¯ï¼Œä½†è¿™ä¸¤å±‚æœ€å¤šä¹Ÿå°±æ˜¯éå†næ¬¡ï¼Œæ‰€ä»¥ä»ç„¶æ˜¯O(n logn)\n- ç©ºé—´å¤æ‚åº¦ O(n). ä¸è®ºæ˜¯setè¿˜æ˜¯hashmapè¿˜æ˜¯stackï¼Œæœ€å¤§é•¿åº¦å‡ä¸ºn","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201573853","body":"\n```c++\n// ä½¿ç”¨hashmapæ¥å­˜å‚¨valueå’Œkeyã€‚éå†æ¯ä¸ªæ•°çš„æ—¶å€™æ£€æŸ¥hashmapä¸­æ˜¯å¦å·²ç»æœ‰äº†deltaï¼ˆæ¯ä¸ªæ•°ä¸targetçš„å·®ï¼‰ã€‚\n// ä¸å¿…è¦æŠŠæ‰€æœ‰æ•°å…ˆå­˜ä¸€éï¼Œåœ¨å­˜çš„æ—¶å€™åŒæ—¶æ£€æŸ¥å³å¯\n// å› ä¸ºè‹¥å­˜åœ¨ä¸¤ä¸ªæ•°å’Œä¸ºtargetï¼Œå¿…ç„¶é‡åˆ°ç¬¬äºŒä¸ªæ•°çš„æ—¶å€™ç¬¬ä¸€ä¸ªå·²ç»åœ¨hashmapä¸­äº†ã€‚\n// Time: O(n)\n// Space: O(n)\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        std::vector<int> values;\n        \n        std::unordered_map<int, int> nums_map; // <value, index>\n        for (int i=0; i<nums.size(); i++) {\n            int complement = target - nums[i];\n            if (nums_map.count(complement) > 0) {\n                values.push_back(i);\n                values.push_back(nums_map.at(complement));\n            } else {\n                nums_map[nums[i]] = i; \n            }\n        }\n        \n        return values;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203076092","body":"ä½¿ç”¨bucket sortæ€æƒ³ã€‚  \nå…ˆæŠŠæ‰€æœ‰çš„æ•°countä¸€éï¼Œç„¶åæ ¹æ®å‡ºç°æ¬¡æ•°å­˜å…¥ä¸€ä¸ªäºŒç»´æ•°ç»„ï¼›æ¯”å¦‚å‡ºç°1æ¬¡ï¼Œæ”¾åœ¨bucket[0]ï¼Œå‡ºç°3æ¬¡æ”¾åœ¨bucket[2]ä¸­ã€‚  \nç„¶åå¯¹è¿™ä¸ªbucketä»å¤§åˆ°å°éå†ï¼Œåœæ­¢æ¡ä»¶æ˜¯éå†å®Œæˆæˆ–è€…å·²ç»æ‹¿åˆ°kä¸ªmost frequentã€‚å› ä¸ºä½¿ç”¨çš„vectorï¼Œæ‰€ä»¥å‡ºç°æ¬¡æ•°å¯ä»¥ç†è§£ä¸ºæ’åºå®Œæˆçš„ï¼Œæ‰€ä»¥ä¸éœ€è¦é¢å¤–å¯¹å‡ºç°æ¬¡æ•°è¿›è¡Œæ’åºã€‚\n\n* Time: $O(n)$\n* Space: $O(n + m + k)$ such that $n$ is vector size, $m$ is number of unique elemnts, and $k$ is return size\n\n```c++\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        if (nums.size() == 0) return nums;\n        \n        int max_count; // how many time the number (occurs most time) appears\n        std::unordered_map<int, int> counts;\n        for (auto& num: nums) {\n            // must be ++counts[num], not counts[num]++\n            max_count = std::max(max_count, ++counts[num]);\n        }\n        \n        // max_count + 1 (+1 for bucket 0)\n        // otherwise index-1 when storing number into buckets\n        std::vector<std::vector<int>> buckets(max_count + 1);\n        for (auto it = counts.begin(); it != counts.end(); ++it) {\n            // it.first => num\n            // it.second => occur times\n            buckets[it->second].push_back(it->first);\n        }\n        \n        std::vector<int> result;\n        for (int i = max_count; i >= 0 && result.size() < k; i--) {\n            for (auto num: buckets[i]) {\n                result.push_back(num);\n                if (result.size() >= k) break;\n            }\n        }\n        \n        return result;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204419594","body":"æ¯ä¸€ä¸ªç‚¹éƒ½è®¡ç®—ä¸å…¶ä»–ç‚¹çš„è·ç¦»ï¼Œç”¨hashmap<distance, number_of_points>æ¥å­˜å‚¨è¿™äº›è·ç¦»ã€‚ä¸€æ—¦å‘ç°å­˜åœ¨ç›¸åŒè·ç¦»çš„ç‚¹ï¼Œå°±åœ¨æ€»æ•°ä¸ŠåŠ ä¸Š 2*map[distance]å³ 2*number_of_pointsï¼Œå› ä¸ºæ¯æ–°å¢ä¸€ä¸ªç‚¹ï¼Œéƒ½å¯ä»è¿™ä¸ªç‚¹è¿æ¥åˆ°å…¶ä»–å·²å­˜åœ¨çš„ç‚¹ã€‚æˆ–è€…ä½¿ç”¨æ’åˆ—ç»„åˆï¼ˆé€Ÿåº¦ä¼šå¿«ä¸€ä¸¢ä¸¢ï¼‰ã€‚\n\n```c++\n// Time: O(N^2)\n// Space: O(N)\n\nclass Solution {\npublic:\n Â int get_distance(std::vector<int>& pointA, std::vector<int>& pointB) {\n Â  Â int dx = pointB[0] - pointA[0];\n Â  Â int dy = pointB[1] - pointA[1];\n Â  Â return dx * dx + dy * dy;\n  }\n Â \n Â int numberOfBoomerangs(vector<vector<int>>& points) {\n Â  Â if (points.size() < 3) return 0;\nâ€‹\n Â  Â int num = 0;\n Â  Â std::unordered_map<int, int> map;\n Â  Â for (auto base: points) {\n Â  Â  Â for (auto point: points) {\n Â  Â  Â  Â int distance = get_distance(base, point);\n Â  Â  Â  Â if (distance == 0) {\n Â  Â  Â  Â  Â continue;\n Â  Â  Â   }\n Â  Â  Â  Â \n Â  Â  Â  Â if (map[distance] > 0) {\n Â  Â  Â  Â  Â num += (2 * map[distance]);\n Â  Â  Â  Â }\n Â  Â  Â  Â map[distance]++;\n Â  Â   }\n Â  Â  Â map.clear();\n Â   }\n Â  Â \n Â  Â return num;\n  }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205605941","body":"ä½¿ç”¨hash setå’Œsliding windowã€‚hash setä¿å­˜å½“å‰sliding windowé‡Œé¢çš„charactersï¼Œå¯ä»¥constantlyæ£€æŸ¥å½“å‰ä½ç½®çš„charæ˜¯å¦å·²ç»åœ¨sliding windowé‡Œé¢äº†ã€‚\n\nä»å¤´åˆ°å°¾éå†stringï¼Œå¦‚æœå½“å‰çš„charå·²ç»åœ¨sliding windowé‡Œé¢äº†ï¼Œä»sliding windowçš„æœ€å·¦è¾¹å¼€å§‹ä¸€ä¸ªä¸€ä¸ªå‰”é™¤ï¼ˆå·¦è¾¹ç•Œè¦æ›´æ–°ï¼‰ï¼ŒçŸ¥é“å½“å‰çš„charå¯ä»¥è¢«æ’å…¥åˆ°hash setä¸­ã€‚\n\næ¯æ¬¡æ’å…¥æ–°charåˆ°hash setçš„æ—¶å€™éƒ½è¦æ›´æ–°æœ€å¤§é•¿åº¦ï¼Œä½¿ç”¨ä¸€ä¸ªå˜é‡æ¥è®°å½•sliding windowçš„æœ€å¤§é•¿åº¦ã€‚\n\n```c++\n// Time: O(n), even while loop is inside for loop, but total times of while loop in all 'for loop' is less than the size of string s.\n// Space: O(n), std::set<char> won't be longger than given string s.\n\nclass Solution {\npublic:\n Â  Â int lengthOfLongestSubstring(string s) {\n Â  Â  Â  Â std::set<char> charset;\n Â  Â  Â  Â int l = 0;\n Â  Â  Â  Â int result = 0;\n Â  Â  Â  Â \n Â  Â  Â  Â for (int i=0; i<s.size(); i++) {\n Â  Â  Â  Â  Â  Â while (charset.count(s[i]) > 0) {\n                // order matters, remove first, then increase l\n Â  Â  Â  Â  Â  Â  Â  Â charset.erase(s[l]);\n Â  Â  Â  Â  Â  Â  Â  Â l++;\n Â  Â  Â  Â  Â   }\n Â  Â  Â  Â  Â  Â charset.insert(s[i]);\n            // i - l + 1\n Â  Â  Â  Â  Â  Â result = std::max(result, i-l+1);\n Â  Â  Â   }\n Â  Â  Â  Â \n Â  Â  Â  Â return result;\n Â   }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1206794834","body":"å…ˆæŠŠwordså½“ä½œä¸€ä¸ªwordï¼ˆéœ€è¦wordsæ‹¼æ¥åçš„sizeï¼‰åœ¨sä¸­éå†ï¼Œæ€»å…±æœ‰s.size() - words.size() * words[0].size() + 1ç§å¯èƒ½ï¼Œæ¯æ¬¡å¯å¾—åˆ°ä¸€ä¸ªsubstringã€‚ \nä¸¤ä¸ªhashmapï¼Œä¸€ä¸ªå«mapå­˜wordsä¸­å…ƒç´ çš„æ¬¡æ•°ï¼Œä¸€ä¸ªå«countså­˜ä¸Šé¢å¾ªç¯å®é™…å¾—åˆ°çš„wordçš„å‡ºç°æ¬¡æ•°ï¼Œè¿›è¡Œå¯¹æ¯”ã€‚\nç”±äºwordsé‡Œé¢wordçš„sizeä¸€è‡´ï¼Œæ‰€ä»¥éœ€è¦è¿›è¡Œwords.size()æ¬¡å¾ªç¯ï¼Œæ¯æ¬¡å–ä¸€ä¸ªwordã€‚\nå¦‚æœmapä¸­æ²¡æœ‰è¿™ä¸ªwordï¼Œè¯´æ˜ä¸å¯¹ï¼Œbreakåè¿›è¡Œä¸‹ä¸€æ¬¡å¤–å¾ªç¯ï¼Œè®°å¾—æ¸…ç©ºcountsï¼›\nå¦‚æœmapä¸­æœ‰è¿™ä¸ªwordï¼ŒæŠŠè¿™ä¸ªwordæ”¾åˆ°countsé‡Œé¢ï¼Œæ”¾å…¥ä¹‹åå¯¹æ¯”æ¬¡æ•°ï¼Œå¦‚æœcountsé‡Œé¢è¿™ä¸ªwordçš„æ¬¡æ•°å¤§äºè¿™ä¸ªwordåœ¨mapä¸­çš„æ¬¡æ•°ï¼Œä¹Ÿæ˜¯ä¸å¯¹çš„ï¼Œbreakç„¶åè¿›è¡Œä¸‹ä¸€æ¬¡å¤–å¾ªç¯ã€‚  \nå†…å±‚å¾ªç¯æ­£å¸¸ç»“æŸï¼ˆè¯´æ˜å†…å±‚å¾ªç¯è¿›è¡Œäº†words.size()æ¬¡ï¼‰ï¼Œå°±æŠŠå½“å‰å¤–å¾ªç¯çš„indexå€¼æ”¾å…¥ç»“æœã€‚\n\n```c++\n// Complexity. n = s.size(), m = words.size(), k = words[0].size();\n// Time: O(n * m). Outer loop runs at most n times, acutally n - m*k times, inner loop runs exactly m times.\n// Space: O(n), max size of two hashmaps is s.size() + words.size(), for example s = \"abcd\", words = [\"a\",\"b\",\"c\",\"d\"],\n// then both hashmaps should be {<\"a\", 1>,  <\"b\", 1>,  <\"c\", 1>, <\"d\", 1>}.\n\nclass Solution {\npublic:\n Â  Â vector<int> findSubstring(string s, vector<string>& words) {\n Â  Â  Â std::vector<int> result;\n Â  Â  Â if(s.size() == 0 || words.size() == 0) return result;\n Â  Â  Â \n Â  Â  Â int str_len = s.size();\n Â  Â  Â int word_num = words.size();\n Â  Â  Â int word_len = words[0].size();\n Â  Â  Â int concate_len = word_num * word_len;\n Â  Â  Â std::unordered_map<std::string, int> map;\n Â  Â  Â std::unordered_map<std::string, int> counts;\n Â  Â  Â \n Â  Â  Â for (auto word: words) {\n Â  Â  Â  Â map[word]++;\n Â  Â   }\n Â  Â  Â \n Â  Â  Â for (int i = 0; i < str_len - concate_len + 1; i++) {\n Â  Â  Â  Â counts.clear();\n Â  Â  Â  Â int j;\n Â  Â  Â  Â for (j = 0; j < word_num; j++) {\n Â  Â  Â  Â  Â std::string temp = s.substr(i + j * word_len, word_len);\n Â  Â  Â  Â  Â if (map.count(temp) == 0) break;\n Â  Â  Â  Â  Â counts[temp]++;\n Â  Â  Â  Â  Â if (counts[temp] > map[temp]) break;\n Â  Â  Â   }\n Â  Â  Â  Â if (j == word_num)  result.push_back(i);\n Â  Â   }\n Â  Â  Â \n Â  Â  Â return result;\n Â   }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207342068","body":"```c++\nint floorMod(const int& a, const int& b)\n{\n    return (a % b + b) % b;\n}\nint solve(vector<int>& nums, int k) {\n    int allSum = 0;\n    for (int& num : nums)\n        allSum += num;\n\n    allSum = floorMod(allSum, k);\n    unordered_map<int, int> dict;\n    dict[0] = -1;\n\n    int preSum = 0;\n    int minLen = nums.size();\n    for (int i = 0; i < nums.size(); i++) {\n        preSum += nums[i];\n        int mod = floorMod(preSum, k);\n        dict[mod] = i;\n\n        if (dict.count(floorMod(preSum - allSum, k)))\n            minLen = min(minLen, i - dict[floorMod(preSum - allSum, k)]);\n    }\n    return minLen == nums.size() ? -1 : minLen;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207458554","body":"```c++\n// åŒæŒ‡é’ˆï¼Œåˆå§‹èµ·ç‚¹ä¸ºheadï¼Œåˆ¤æ–­æ¡ä»¶ä¸ºfastå’Œfast->next éƒ½ä¸ä¸ºnullptrï¼Œæ­¤æ—¶slowæ­£å¥½åœåœ¨middleæˆ–è€…second middle\n// Time: O(n)\n// Space: O(1)\n\nclass Solution {\npublic:\n Â  Â ListNode* middleNode(ListNode* head) {\n Â  Â  Â  Â ListNode *slow = head;\n Â  Â  Â  Â ListNode *fast = head;\n Â  Â  Â  Â \n Â  Â  Â  Â while (fast != nullptr && fast->next != nullptr) {\n Â  Â  Â  Â  Â  Â slow = slow->next;\n Â  Â  Â  Â  Â  Â fast = fast->next->next;\n Â  Â  Â   }\n Â  Â  Â  Â \n Â  Â  Â  Â return slow;\n Â   }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208412694","body":"åŒæŒ‡é’ˆï¼Œéƒ½ä»0å¼€å§‹ã€‚å½“å¿«æŒ‡é’ˆä¸æ…¢æŒ‡é’ˆç›¸åŒæ—¶å€™ï¼Œå¿«æŒ‡é’ˆè‡ªå¢ã€‚å½“ä¸åŒçš„æ—¶å€™ï¼Œå°±æŠŠå¿«æŒ‡é’ˆçš„å€¼è¦†ç›–æ…¢æŒ‡é’ˆï¼Œæ…¢æŒ‡é’ˆä¹Ÿè‡ªå¢ã€‚æœ€åæ…¢æŒ‡é’ˆæ‰€åœ¨ä½ç½®å°±æ˜¯ç»“æœæ•°ç»„çš„è¾¹ç•Œã€‚\n\n```c++\n// Time: O(n)\n// Space: O(1)\n\nclass Solution {\npublic:\n Â  Â int removeDuplicates(vector<int>& nums) {\n Â  Â  Â  Â if (nums.size() == 0) return 0;\n Â  Â  Â  Â \n Â  Â  Â  Â int index = 0;\n Â  Â  Â  Â for (int i=0; i<nums.size(); i++) {\n Â  Â  Â  Â  Â  Â if (nums[i] > nums[index]) {\n Â  Â  Â  Â  Â  Â  Â  Â nums[++index] = nums[i];\n Â  Â  Â  Â  Â   }\n Â  Â  Â   }\n Â  Â  Â  Â \n Â  Â  Â  Â return index+1;\n Â   }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/42#issuecomment-1209773998","body":"```c++\n// å› ä¸ºæ˜¯distinct integersï¼Œæ‰€ä»¥å¦‚æœæ‰¾åˆ°ç›¸åŒçš„æ•°ï¼Œç›´æ¥è¿”å›å³å¯ï¼Œä¸ç”¨è€ƒè™‘ç¬¬å‡ ä¸ªã€‚\n// å¦‚æœtargetæ¯”midé‚£ä¸ªæ•°å¤§ï¼Œå·¦è¾¹ç•Œä¸éœ€è¦ä¿ç•™ï¼Œmid+1\n// å¦‚æœtargetæ›´å°ï¼ŒåŒæ ·å³è¾¹ç•Œä¹Ÿä¸è¦ä¿ç•™ï¼Œmid-1\n\n// Time: O(logn)\n// Space: O(1)\n\nclass Solution {\npublic:\n Â  Â int searchInsert(vector<int>& nums, int target) {\n Â  Â  Â  Â int left = 0, right = nums.size() - 1;\n Â  Â  Â  Â while (left <= right) {\n Â  Â  Â  Â  Â  Â int mid = left + (right-left)/2;\n Â  Â  Â  Â  Â  Â if (nums[mid] == target) {\n Â  Â  Â  Â  Â  Â  Â  Â return mid;\n Â  Â  Â  Â  Â   } else if (nums[mid] < target) {\n Â  Â  Â  Â  Â  Â  Â  Â left = mid+1;\n Â  Â  Â  Â  Â   } else {\n Â  Â  Â  Â  Â  Â  Â  Â right = mid-1; // mid-1, otherwise dead loop\n Â  Â  Â  Â  Â   }\n Â  Â  Â   }\n Â  Â  Â  Â \n Â  Â  Â  Â return left;\n Â   }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckytwj":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186080707","body":"##  æ€è·¯\n### æ‰«æå­—ç¬¦ä¸²å­—ç¬¦ é‡åˆ°ç­‰äºcçš„ è®¡ç®—å¹¶è®¾ç½®cå·¦è¾¹çš„è·ç¦» res[left],\n### åŒæ—¶è®¾ç½®cå³è¾¹çš„è·ç¦»(åœ¨é‡åˆ°ä¸‹ä¸€ä¸ªcä¹‹å‰çš„)res[right]\n### å–æœ€çŸ­è·ç¦»\n```Java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        \n        int[] res = new int[s.length()];\n        Arrays.fill(res,Integer.MAX_VALUE);\n        int start = 0;\n        for(int i = 0;i<s.length();i++){\n            if(s.charAt(i)==c){\n                res[i]=0;\n                int left = i-1;\n                while(left>=start){\n                    res[left]=Math.min(Math.abs(i-left),res[left]);\n                    left--;\n                }\n                int right = i+1;\n                while(right<s.length()&&s.charAt(right)!=c){\n                    res[right]=Math.abs(right-i);\n                    right++;\n                }                \n                start=i+1;\n            }\n                \n        }\n        return res;\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186388835","body":"#### æ€è·¯\n##### æ•°ç»„å®ç°\n```Java\nclass CustomStack {\n    int maxSize;  //å®šå€¼\n    int size;\n    int[] arr;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        size = 0;        \n        arr = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (size > 0 && size >= maxSize) return;\n        arr[size++]=x;\n    }\n\n    public int pop() {\n        if (size > 0) {\n            int t = arr[size-1];\n            arr[size-1]=0;\n            size--;\n            return t;\n        }\n        return -1;\n    }\n\n    public void increment(int k, int val) {\n        for(int i = 0;i<size && i<k; i++){\n            arr[i]=arr[i]+val;\n        }\n    }\n}\n```\nå¤æ‚åº¦ incrementæ—¶é—´O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186731570","body":"### æ€è·¯\r\n### é€’å½’æœç´¢  \r\n```java\r\nclass Solution {\r\n     int i  = 0;\r\n    public String decodeString(String s) {\r\n        \r\n        return dfs(s,0);\r\n    }\r\n   String dfs(String s, int curr) {\r\n\r\n        StringBuilder sb = new StringBuilder();\r\n        //iè®¾ç½®æˆå…¨å±€å˜é‡\r\n        for ( i = curr; i < s.length(); i++) {\r\n            if (Character.isDigit(s.charAt(i))) {\r\n                int num = 0, k = i;\r\n                //æ‹¼æ•°å­—\r\n                while (k < s.length() && Character.isDigit(s.charAt(k))) {\r\n                    num = 10 * num + (s.charAt(k) - '0');\r\n                    k++;\r\n                }\r\n                i = k;\r\n                if (s.charAt(i) == '[') {\r\n                    //è¿™é‡Œdfsè¿”å›æ—¶ iå·²ç»æ›´æ–°äº†ï¼ˆæ¥åˆ°äº†â€˜]â€™çš„ä½ç½®äº†ï¼‰ï¼Œ\r\n                    //å¦‚æœè¿˜ä½¿ç”¨å½“å‰å±€éƒ¨å˜é‡ä¼šé€ æˆé‡å¤ï¼Œæ‰€ä»¥éœ€è¦å…¨å±€å˜é‡ è·³å‡ºå½“å‰å¾ªç¯\r\n                    String a = dfs(s, i + 1);\r\n                    //æ‹¼ä¸²\r\n                    for (int b = 0; b < num; b++)\r\n                            sb.append(a);\r\n                }\r\n\r\n            } else if (s.charAt(i) == ']') { \r\n                return sb.toString();\r\n            } else\r\n                sb.append(s.charAt(i));\r\n        }\r\n        return sb.toString();\r\n\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188496223","body":"### æ€è·¯\r\n#### æ¨¡æ‹Ÿ\r\n```java\r\nclass MyQueue {\r\n    Stack<Integer> first;\r\n    Stack<Integer> second;\r\n    int size ;\r\n\r\n    public MyQueue() {\r\n        first = new Stack<>();\r\n        second = new Stack<>();\r\n        size = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        first.push(x);\r\n        size++;\r\n    }\r\n    \r\n    public int pop() {\r\n        int res = -1;\r\n        if(!empty()){\r\n            while(!first.isEmpty()){\r\n                second.push(first.pop());                \r\n            }\r\n            res = second.pop();            \r\n            while(!second.isEmpty()){\r\n                first.push(second.pop());\r\n            }\r\n            size--;\r\n            return res;            \r\n        }\r\n        return res;\r\n    }\r\n    \r\n    public int peek() {\r\n        int res = -1;\r\n        if(!empty()){\r\n            while(!first.isEmpty()){\r\n                second.push(first.pop());                \r\n            }\r\n            res = second.peek();            \r\n            while(!second.isEmpty()){\r\n                first.push(second.pop());\r\n            }\r\n            \r\n            return res;            \r\n        }\r\n        return res;\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return size>0?false:true;\r\n    }\r\n}\r\n```\r\n### æ—¶é—´å¤æ‚åº¦ O(nï¼‰","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189929060","body":"```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int[] sortArr = arr.clone();\r\n        Arrays.sort(sortArr);\r\n        int tmpSub = 0;\r\n        int ans = 0;\r\n        for (int i = 0; i < arr.length; i++) {\r\n            tmpSub += arr[i] - sortArr[i];\r\n            if (tmpSub == 0) {\r\n                ans++;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190990311","body":"### æ€è·¯\r\n#### é¦–å°¾è¿æ¥æ‰¾åˆ†å‰²ç‚¹\r\n```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null) return head;\r\n        int len = 0;\r\n        ListNode curr = head, pre = curr;\r\n        while (curr != null) {\r\n            len++;\r\n            pre = curr;\r\n            curr = curr.next;\r\n        }\r\n\r\n        int start = k % len;\r\n        if (start == 0) return head;\r\n        //é¦–å°¾è¿æ¥\r\n        pre.next = head;\r\n        //åˆ†å‰²ä½ç½®\r\n        int split = len - start;        \r\n        pre = head;\r\n        ListNode startNode = head;\r\n        while (split-- > 0) {\r\n            pre = startNode;\r\n            startNode = startNode.next;\r\n        }\r\n        //åˆ†å‰²\r\n        pre.next = null;\r\n        return startNode;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192234467","body":"### è§£é¢˜æ€è·¯\r\n#### åˆ›å»ºè™šèŠ‚ç‚¹æŒ‡å‘head ï¼Œç§»åŠ¨æŒ‡é’ˆcurr æŒ‡å‘è™šèŠ‚ç‚¹ å¯¹æ¥ä¸‹æ¥ä¸¤ä¸ªèŠ‚ç‚¹äº¤æ¢\r\n### ä»£ç \r\n\r\n```java\r\n\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head==null||head.next==null) return head;\r\n        ListNode dummy = new ListNode(-1,head);\r\n        ListNode curr  =dummy;\r\n        while(curr.next!=null&&curr.next.next!=null){\r\n           ListNode n1 = curr.next,n2 = n1.next;\r\n           curr.next = n2;\r\n           n1.next = n2.next;\r\n           curr = n1;\r\n           n2.next = n1; \r\n        }\r\n        return dummy.next;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193056747","body":"### è§£é¢˜æ€è·¯\r\nä½¿ç”¨å¿«æ…¢æŒ‡é’ˆæ‰¾åˆ°ä¸­ç‚¹ è¯¥ç‚¹å³ä¸ºrootèŠ‚ç‚¹ ç»§ç»­åˆ†ä¸ºä¸¤éƒ¨åˆ†é€’å½’\r\n\r\n### ä»£ç \r\n\r\n```java\r\n\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if (head == null) return null;\r\n        return getTreeNode(head, null);\r\n    }\r\n    TreeNode getTreeNode(ListNode head, ListNode tail) {\r\n        if(head==tail) return null;\r\n        ListNode low = head, fast = head;\r\n        while (fast != tail && fast.next != tail) {\r\n            fast = fast.next;\r\n            fast = fast.next;\r\n            low = low.next;\r\n        }\r\n\r\n        TreeNode root = new TreeNode(low.val);\r\n        root.left = getTreeNode(head, low);\r\n        root.right = getTreeNode(low.next, tail);\r\n        return root;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193236423","body":"### è§£é¢˜æ€è·¯\r\na+c+b  = b+c+a;\r\n\r\n### ä»£ç \r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode a = headA,b = headB;\r\n        int count =0;\r\n        while(a != b){\r\n            if(a.next==null){\r\n                a=headB;\r\n                count++;\r\n            }else\r\n                a= a.next;                \r\n            if(b.next==null){\r\n                b=headA;\r\n                count++;\r\n            }else\r\n                b= b.next;\r\n            if(count>2) return null;\r\n        }\r\n        return a;\r\n    }\r\n}\r\n```\r\næ—¶é—´å¤æ‚åº¦ï¼šO(n+m)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193997390","body":"### è§£é¢˜æ€è·¯\r\nç”¨setè¿‡æ»¤\r\n\r\n### ä»£ç \r\n\r\n```java\r\n\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        Set<ListNode> set = new HashSet<>();\r\n        ListNode tmp = head;\r\n        if(tmp==null) return null;\r\n        while(tmp.next != null){\r\n            if(!set.add(tmp)) return tmp;\r\n            tmp=tmp.next;            \r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\nç©ºé—´å¤æ‚åº¦O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1197598833","body":"### è§£é¢˜æ€è·¯\r\nåŒé“¾è¡¨å’Œ mapç¼“å­˜\r\nåŒé“¾è¡¨å¤´éƒ¨æ˜¯æœ€æ–°å€¼ å°¾éƒ¨æ˜¯æœ€è€å€¼ï¼Œmapç”¨äºå®šä½keyï¼Œç»´æŠ¤head å’Œtailä¸¤ä¸ªæŒ‡é’ˆèŠ‚ç‚¹ï¼Œæ–¹ä¾¿åˆ é™¤æ·»åŠ \r\n\r\n### ä»£ç \r\n\r\n```java\r\nclass LRUCache {\r\n    //head tail èŠ‚ç‚¹åªä½œä¸ºæŒ‡é’ˆä½¿ç”¨ï¼Œä¸ä½œä¸ºæ“ä½œèŠ‚ç‚¹ä½¿ç”¨\r\n    DoubleNode head, tail;\r\n    int capacity;\r\n    Map<Integer, DoubleNode> cache = new HashMap<>();\r\n\r\n    public LRUCache(int capacity) {\r\n        this.capacity = capacity;\r\n        head = null;\r\n        tail = null;\r\n    }\r\n\r\n    public int get(int key) {\r\n        DoubleNode node = cache.get(key);\r\n        if (cache.size() == 0 || node == null) {\r\n            return -1;\r\n        } else {\r\n//            åŒé“¾è¡¨ä¸­å–å‡ºåŠ å…¥åˆ°å¤´ç»“ç‚¹\r\n            delAndAddToHead(node);\r\n            return node.val;\r\n        }\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        DoubleNode node = cache.get(key);\r\n        if (node != null) {//å­˜åœ¨çš„å€¼ï¼Œæ›´æ–°åˆ°å¤´ç»“ç‚¹ä½ç½®\r\n            node.val = value;\r\n            delAndAddToHead(node);\r\n        } else {// æ–°å€¼\r\n            node = new DoubleNode(key, value);\r\n            addToHead(node);\r\n            cache.put(key, node);\r\n        }\r\n        if (cache.size() > capacity) {\r\n            DoubleNode t = deleteTail();\r\n            cache.remove(t.key);\r\n        }\r\n\r\n    }\r\n\r\n    private void delAndAddToHead(DoubleNode node) {\r\n        //æŒ‡å‘å¤´éƒ¨ ç›´æ¥è¿”å›\r\n        if (node == head || (node == head && node == tail)) return;\r\n        // è¯¥èŠ‚ç‚¹æ˜¯å°¾éƒ¨\r\n        if (node == tail) {\r\n            tail = node.pre;\r\n            node.pre.next = null;\r\n            node.pre = null;\r\n        } else {//ä¸­é—´èŠ‚ç‚¹\r\n            DoubleNode pre = node.pre;\r\n            pre.next = node.next;\r\n            node.next.pre = pre;\r\n        }\r\n        addToHead(node);\r\n    }\r\n\r\n    void addToHead(DoubleNode node) {\r\n        if (head == null) {\r\n            head = node;\r\n            tail = node;\r\n        } else {\r\n            node.next = head;\r\n            head.pre = node;\r\n            head = node;\r\n        }\r\n    }\r\n\r\n    DoubleNode deleteTail() {\r\n        DoubleNode node = tail;\r\n        tail = node.pre;\r\n        node.pre.next = null;\r\n        node.pre = null;\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     * åŒå‘é“¾è¡¨\r\n     */\r\n    class DoubleNode {\r\n        DoubleNode pre;\r\n        DoubleNode next;\r\n        int key;\r\n        int val;\r\n\r\n        DoubleNode(int key, int val) {\r\n            this.key = key;\r\n            this.val = val;\r\n        }\r\n    }\r\n}\r\n```\r\næ—¶é—´å¤æ‚åº¦Oï¼ˆ1ï¼‰","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198791078","body":"### è§£é¢˜æ€è·¯\r\né€’å½’ dfs\r\n\r\n### ä»£ç \r\n\r\n```java\r\n\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n            if(p!=null && q!=null&&p.val==q.val){\r\n                return isSameTree(p.left, q.left) &&\r\n            isSameTree(p.right, q.right);\r\n            }\r\n            if(p==null&&q==null) return true;\r\n            if(p==null&&q!=null||(p!=null&&q==null)||(p!=null && q!=null&&p.val!=q.val))\r\n            return false;\r\n            return true;\r\n            \r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1200421537","body":"### è§£é¢˜æ€è·¯\r\ndfséå†\r\n\r\n### ä»£ç \r\n\r\n```java\r\n\r\nclass Solution {\r\n    \r\n    public int sumNumbers(TreeNode root) {         \r\n         return sumNumber(root,0);\r\n    }\r\n\r\n    int sumNumber(TreeNode node,int k){\r\n        if(node==null){\r\n            return 0;\r\n        }\r\n        //å¶å­èŠ‚ç‚¹è¿”å›ç«¯ç‚¹æ•°æ® \r\n        if(node.left==null&&node.right==null){\r\n            return 10*k+node.val;\r\n        }\r\n        //éå¶å­èŠ‚ç‚¹\r\n        return sumNumber(node.left,10*k+node.val)+\r\n        sumNumber(node.right,10*k+node.val);\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200068519","body":"### è§£é¢˜æ€è·¯\r\næ·±åº¦éå†\r\n\r\n### ä»£ç \r\n\r\n```java\r\nclass Solution {\r\n    int curVal, curHeight;\r\n    public int findBottomLeftValue(TreeNode root) {\r\n        curHeight=0;\r\n        deep(root, 0);\r\n        return curVal;\r\n    }\r\n\r\n    void deep(TreeNode root, int height) {\r\n        if (root == null) return;\r\n        height++;\r\n        deep(root.left, height);\r\n        deep(root.right, height);\r\n        if (height > curHeight) {\r\n            curVal = root.val;\r\n            curHeight = height;\r\n        }\r\n    }\r\n\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200353349","body":"### è§£é¢˜æ€è·¯\r\nä½¿ç”¨é˜Ÿåˆ—æœ€bfséå†\r\n\r\n### ä»£ç \r\n\r\n```java\r\n\r\npublic class Codec {\r\n\r\n    // Encodes a tree to a single string.\r\n    public String serialize(TreeNode root) {\r\n       if (root == null) return null;\r\n        Queue<TreeNode> queue = new LinkedList<>();\r\n        StringBuilder sb = new StringBuilder();\r\n        queue.add(root);\r\n        while (!queue.isEmpty()) {\r\n            TreeNode poll = queue.poll();\r\n            if (poll != null) {\r\n                sb.append(poll.val).append(' ');\r\n                queue.add(poll.left);\r\n                queue.add(poll.right);\r\n            } else\r\n                sb.append(10000).append(' ');\r\n        }\r\n        return sb.toString().trim();    \r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    public TreeNode deserialize(String data) {\r\n        if (data == null) return null;\r\n        String[] s = data.split(\" \");\r\n        TreeNode root = new TreeNode(Integer.parseInt(s[0]));\r\n        int i = 1;\r\n        Queue<TreeNode> queue = new LinkedList<>();\r\n        //åŠ rootèŠ‚ç‚¹åˆ°é˜Ÿåˆ—\r\n        queue.add(root);\r\n        while ( i < s.length) {\r\n            TreeNode poll = queue.poll();\r\n            //æ¯æ¬¡å–å·¦å³ä¸¤ä¸ª\r\n            int left = Integer.parseInt(s[i]);\r\n            int right = Integer.parseInt(s[i+1]);\r\n            if (left != 10000) {\r\n                poll.left = new TreeNode(left);\r\n                queue.add(poll.left);\r\n            }\r\n            if (right != 10000) {\r\n                poll.right = new TreeNode(right);\r\n                queue.add(poll.right);\r\n            }\r\n            i+=2;\r\n\r\n        }\r\n        return root;\r\n    }\r\n}\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203359805","body":"### è§£é¢˜æ€è·¯\r\nmapè®¡æ•°ï¼Œè½¬ä¸ºlistæ’åº\r\n\r\n### ä»£ç \r\n\r\n```java\r\nclass Solution {\r\n    public int[] topKFrequent(int[] nums, int k) {\r\n       Map<Integer, Integer> map = new LinkedHashMap<>();\r\n        for (int i = 0; i < nums.length; i++) {\r\n            Integer orDefault = map.getOrDefault(nums[i], 0);\r\n            map.put(nums[i], ++orDefault);\r\n        }\r\n        Set<Integer> set = map.keySet();\r\n        List<int[]> list = new ArrayList<>();\r\n        for (Integer key :\r\n                set) {\r\n            list.add(new int[]{key, map.get(key)});\r\n        }\r\n        list.sort(new Comparator<int[]>() {\r\n            @Override\r\n            public int compare(int[] o1, int[] o2) {\r\n                return o2[1] - o1[1];\r\n            }\r\n        });\r\n        int[] res = new int[k];\r\n        for (int i = 0; i < k; i++) {\r\n            res[i] = list.get(i)[0];\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205930936","body":"### è§£é¢˜æ€è·¯\r\næš´åŠ› ä½¿ç”¨ä¸¤å±‚å¾ªç¯ setè¿‡æ»¤ countè®¡æ•°\r\n\r\n### ä»£ç \r\n\r\n```java\r\nclass Solution {\r\n    public int lengthOfLongestSubstring(String s) {\r\n        Set<Character> set = new HashSet<>();\r\n        int max = 0;\r\n        for(int i = 0;i<s.length();i++){\r\n            int count = 0;\r\n            for(int j=i;j<s.length();j++){\r\n                    if(set.add(s.charAt(j))){\r\n                        count++;\r\n                    }else{\r\n                        max = Math.max(max,count);\r\n                        set.clear();\r\n                        break;\r\n                    }\r\n            }\r\n            max = Math.max(max,count);\r\n        }\r\n        return max;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207160690","body":"### è§£é¢˜æ€è·¯\r\næ»‘åŠ¨çª—å£ ç”¨ä¸€ä¸ªmapä¿å­˜æºæ•°ç»„ä¸­çš„å•è¯é¢‘ç‡ ä¸´æ—¶mapç»Ÿè®¡æ»‘åŠ¨çª—å£ä¸­çš„ å•è¯é¢‘ç‡ï¼Œç„¶åä¸¤ä¸ªmapä½œæ¯”è¾ƒ\r\n\r\n### ä»£ç \r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> findSubstring(String s, String[] words) {\r\n                int len = 0;\r\n        Map<String, Integer> map = new HashMap<>();\r\n//        ç»Ÿè®¡å•è¯é¢‘ç‡ æ€»é•¿åº¦\r\n        for (int i = 0; i < words.length; i++) {\r\n            len += words[i].length();\r\n            map.put(words[i], map.getOrDefault(words[i], 0) + 1);\r\n        }\r\n//        å•ä¸ªå­—ç¬¦ä¸²é•¿åº¦\r\n        int wLen = words[0].length();\r\n        List<Integer> list = new ArrayList<>();\r\n        for (int i = 0; i <= s.length() - len; i++) {\r\n//            æ€»é•¿åº¦lençš„ä¸² ä»ä½ç½®0å¼€å§‹å‘å³æ»‘åŠ¨ \r\n            String sub = s.substring(i, i + len);\r\n            Map<String, Integer> curMap = new HashMap<>();\r\n            boolean f = true;\r\n            for (int j = 0; j < sub.length(); j += wLen) {\r\n//                è®°å½•å½“å‰æ»‘åŠ¨çš„ä¸² å•è¯å‡ºç°çš„é¢‘ç‡ æ”¾åœ¨ä¸´æ—¶mapä¸­\r\n                String r = sub.substring(j, j + wLen);\r\n                curMap.put(r, curMap.getOrDefault(r, 0) + 1);\r\n            }\r\n//          æ¯”è¾ƒä¸´æ—¶mapä¸­çš„å•è¯é¢‘ç‡ å’ŒåŸå§‹mapä¸­çš„å¯¹æ¯” ä¸ç¬¦åˆå°±ç›´æ¥æ·˜æ±°\r\n            Set<String> set1 = map.keySet();\r\n            for (String key : set1) {\r\n                Integer cv = curMap.get(key);\r\n                Integer v = map.get(key);\r\n                if (cv == null || (cv - v != 0)) {\r\n                    f = false;\r\n                    break;\r\n                }\r\n            }\r\n//            ç¬¦åˆå°±å°±åŠ å…¥\r\n            if (f) list.add(i);\r\n        }\r\n        return list;\r\n    }\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207520242","body":"### è§£é¢˜æ€è·¯\r\nå¿«æ…¢æŒ‡é’ˆ\r\n\r\n### ä»£ç \r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode middleNode(ListNode head) {\r\n        ListNode s = head,f = head;\r\n        while(f != null&& f.next != null){\r\n            f=f.next.next;\r\n            s = s.next;\r\n        }\r\n\r\n        return s ;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208773817","body":"### è§£é¢˜æ€è·¯\r\næ”¶é›†ä¸ç›¸ç­‰çš„å€¼ï¼Œå¦åˆ™è·³è¿‡\r\n\r\n### ä»£ç \r\n\r\n```java\r\nclass Solution {\r\n    public int removeDuplicates(int[] nums) {\r\n        int f  = 1;\r\n       for(int i = 0;i<nums.length-1;i++){\r\n           if(nums[i]!=nums[i+1]){\r\n               nums[f]=nums[i+1];\r\n               f++;\r\n           }\r\n        }\r\n        return f;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/42#issuecomment-1210029624","body":"### è§£é¢˜æ€è·¯\r\näºŒåˆ†\r\n\r\n### ä»£ç \r\n\r\n```java\r\nclass Solution {\r\n    public int searchInsert(int[] nums, int target) {\r\n        int l = 0,r = nums.length-1;\r\n        if(target>nums[r]) return r+1;\r\n        while(l<r){\r\n            int m = (r-l)/2+l;\r\n            if(nums[m]== target) return m;\r\n            else if(nums[m]>target){\r\n                r=m;\r\n            }else {\r\n                l=m+1;\r\n            }\r\n        }\r\n        return r;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzz607":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1192658695","body":"# æ€è·¯ \n\nå°†Kæ¯æ¬¡é™¤ä»¥10ï¼Œä»å³å¾€å·¦ä¾æ¬¡ç›¸åŠ å³å¯ã€‚éœ€è¦æ³¨æ„çš„å‡ ç§æƒ…å†µæœ‰ï¼š \n\n1. æ— è®ºæ˜¯kçš„æœ€é«˜ä½ï¼Œè¿˜æ˜¯numæ•°ç»„çš„ç¬¬0ä½ï¼Œç›¸åŠ åäº§ç”Ÿè¿›ä½\n2. kçš„ä½æ•°å¤§äºnum\n\n# ä»£ç \n\n```Go\n\nfunc addToArrayForm(num []int, k int) []int {\n    var n = -1\n    var c = 0\n    var i = len(num) - 1\n    var ret = make([]int, 0, len(num))\n\n    for k != 0 || c != 0{\n        n = k % 10\n        k /= 10\n\n        n += c\n        c = 0\n        if i >= 0 {\n            num[i] += n\n            c = num[i] / 10\n            num[i] %= 10\n            i--\n        } else {\n            c = n / 10\n            n %= 10\n            ret = append([]int{n}, ret...)\n        }\n    }\n\n    if c != 0 {\n        ret = append([]int{c}, ret...)\n    }\n\n    if len(ret) == 0 {\n        return num\n    }\n    return append(ret, num...)\n}\n\n```\n\n# å¤æ‚åº¦  \n\n1. æ—¶é—´å¤æ‚åº¦ï¼šä»å³å¾€å·¦ä¾æ¬¡ç›¸åŠ ï¼Œæ¯ä¸ªä½æ•°å¤„ç†ä¸€æ¬¡ï¼Œå› æ­¤æ€»æ—¶é—´å¤æ‚åº¦ä¸ºO(n)ã€‚ä»£ç ä¸­ï¼Œä¹Ÿå¯ä»¥æŠŠè¶…å‡ºnumä½æ•°çš„æ•°å­—ç›´æ¥æ·»åŠ åˆ°æ•°ç»„ä¸­ï¼Œæœ€åå†äº¤æ¢ä¸€ä¸‹é¡ºåºï¼Œè¿™æ ·æ—¶é—´å¤æ‚åº¦è‚¯å®šå°±æ˜¯O(n)äº†\n2. ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186102380","body":"# æ€è·¯ \næš´åŠ›æ±‚è§£ï¼Œå…ˆæ‰¾å‡ºæ‰€æœ‰çš„cåœ¨sä¸­çš„ç´¢å¼•ï¼Œç„¶åä¾æ¬¡è®¡ç®—sä¸­æ¯ä¸ªå­—ç¬¦ä¸cçš„è·ç¦»  \n\n# ä»£ç \n```Go\nfunc shortestToChar(s string, c byte) []int {\n\tvar cIdx []int\n\tvar ret []int\n\n\tinitCIdx := func() {\n\t\tfor i := 0; i < len(s); i++ {\n\t\t\tif s[i] == c {\n\t\t\t\tcIdx = append(cIdx, i)\n\t\t\t}\n\t\t}\n\t}\n\n\tgetDistance := func(idx int) int {\n\t\tmin := math.MaxInt32\n\t\tfor _, ii := range cIdx {\n\t\t\ttmp := int(math.Abs(float64(ii - idx)))\n\t\t\tif tmp < min {\n\t\t\t\tmin = tmp\n\t\t\t}\n\t\t}\n\t\treturn min\n\t}\n\n\tinitCIdx()\n\tfor i := 0; i < len(s); i++ {\n\t\tret = append(ret, getDistance(i))\n\t}\n\n\treturn ret\n}\n``` \n\n# å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(NK)ï¼ŒKä¸ºcåœ¨sä¸­çš„ä¸ªæ•°ï¼ŒNä¸ºsçš„é•¿åº¦  \n- ç©ºé—´å¤æ‚åº¦ï¼šO(K)ï¼ŒKä¸ºcåœ¨sä¸­çš„ä¸ªæ•°","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1191456606","body":"### æ€è·¯\n\nè‹¥æ¯æ¬¡è°ƒç”¨Incrementå‡½æ•°çš„æ—¶å€™ï¼Œéƒ½ç›´æ¥æŠŠvalåŠ åˆ°æ ˆä¸­çš„å…ƒç´ ï¼Œåˆ™æ—¶é—´å¤æ‚åº¦ä¸ºO(MN)ï¼Œ\nMä¸ºè°ƒç”¨æ¬¡æ•°ï¼ŒNä¸ºæ ˆé•¿åº¦ã€‚å› æ­¤ï¼Œä¸ºäº†ä¼˜åŒ–Incrementçš„æ•ˆç‡ï¼Œå°±éœ€è¦é¿å…æ­¤æ“ä½œã€‚  \n\nå®é™…ä¸Šï¼Œæˆ‘ä»¬å¹¶ä¸éœ€è¦æ¯æ¬¡éƒ½æŠŠvalåŠ åˆ°æ ˆä¸­å…ƒç´ ä¸­ï¼Œå› ä¸ºåªæœ‰æ‰§è¡Œå‡ºæ ˆæ“ä½œæ—¶ï¼Œæ‰éœ€è¦\nçŸ¥é“æ ˆå…ƒç´ çš„æœ€ç»ˆå€¼æ˜¯å¤šå°‘ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¢åŠ ä¸€ä¸ªè¾…åŠ©æ•°ç»„ï¼Œç”¨äºè®°å½•æ¯æ¬¡æ‰§è¡ŒIncrement\nå‡½æ•°æ—¶ä¼ å…¥çš„valï¼Œå½“å‡ºæ ˆæ“ä½œæ—¶ï¼Œå°†æ ˆé¡¶å…ƒç´ åŠ ä¸Šè¾…åŠ©æ•°ç»„ä¸­å¯¹åº”ä½ç½®çš„å€¼ï¼Œå³å¾—åˆ°æœ€\nç»ˆçš„ç»“æœã€‚\n\n\n### ä»£ç \n\n\n```Go\ntype CustomStack struct {\n\tdata []int\n\tadd  []int\n\tidx  int\n}\n\nfunc Constructor(maxSize int) CustomStack {\n\treturn CustomStack{data: make([]int, maxSize), add: make([]int, maxSize), idx: 0}\n}\n\nfunc (this *CustomStack) Push(x int) {\n\tif this.hasSpace() {\n\t\tthis.data[this.idx] = x\n\t\tthis.idx++\n\t}\n}\n\nfunc (this *CustomStack) Pop() int {\n\tif !this.hasElement() {\n\t\treturn -1\n\t}\n\n\tthis.idx--\n\telement := this.data[this.idx] + this.add[this.idx]\n\n\tif this.idx > 0 {\n\t\tthis.add[this.idx-1] += this.add[this.idx]\n\t}\n\tthis.add[this.idx] = 0\n\n\treturn element\n}\n\nfunc (this *CustomStack) Increment(k int, val int) {\n\t// for i := 0; i < this.idx && i < k; i++ {\n\t// this.data[i] += val\n\t// }\n\tif !this.hasElement() {\n\t\treturn\n\t}\n\n\tif k >= this.idx {\n\t\tthis.add[this.idx-1] += val\n\t} else {\n\t\tthis.add[k-1] += val\n\t}\n}\n\nfunc (this *CustomStack) hasSpace() bool {\n\treturn this.idx < cap(this.data)\n}\n\nfunc (this *CustomStack) hasElement() bool {\n\treturn this.idx > 0\n}\n\n\n```\n\n**å¤æ‚åº¦åˆ†æ**  \n- æ—¶é—´å¤æ‚åº¦ï¼šO(1)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1190361693","body":"### æ€è·¯\n\nåŒæ ˆå®ç°ï¼Œå…¶ä¸­ä¸€ä¸ªæ ˆç”¨äºå‡ºé˜Ÿæ“ä½œæ—¶çš„è¾…åŠ©æ“ä½œ\n\n### ä»£ç \n\n```Go\ntype MyQueue struct {\n\tinput *MyStack\n\toutput *MyStack\n}\n\n\nfunc Constructor() MyQueue {\n\treturn MyQueue{\n\t\tinput: new(MyStack),\n\t\toutput: new(MyStack),\n\t}\n}\n\n\nfunc (this *MyQueue) Push(x int)  {\n\tthis.input.Push(x)\n}\n\n\nfunc (this *MyQueue) Pop() int {\n\t// é¢˜ç›®ä¿è¯ä¸ä¼šåœ¨ç©ºçš„æ ˆä¸Šé¢è°ƒç”¨pop/peek\n\tif this.output.IsEmpty() {\n\t\tthis.inputToOutput()\n\t}\n\treturn this.output.Pop()\n}\n\n\nfunc (this *MyQueue) Peek() int {\n\tif this.output.IsEmpty() {\n\t\tthis.inputToOutput()\n\t}\n\treturn this.output.Peek()\n}\n\n\nfunc (this *MyQueue) Empty() bool {\n\tif this.input.Size() != 0 || this.output.Size() != 0 {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (this *MyQueue) inputToOutput() {\n\tfor !this.input.IsEmpty() {\n\t\tthis.output.Push(this.input.Pop())\n\t}\n}\n\ntype MyStack struct {\n\tdata []int\n}\n\nfunc (receiver *MyStack) Pop() int {\n\tif receiver.IsEmpty() {\n\t\treturn -1\n\t}\n\t\n\tv := receiver.data[len(receiver.data) - 1]\n\treceiver.data = receiver.data[:len(receiver.data) - 1]\n\treturn v\n}\n\nfunc (receiver *MyStack) Peek() int {\n\tif receiver.IsEmpty() {\n\t\treturn -1\n\t}\n\t\n\treturn receiver.data[len(receiver.data) - 1]\n}\n\nfunc (receiver *MyStack) Push(v int) {\n\treceiver.data = append(receiver.data, v)\n}\n\nfunc (receiver *MyStack) Size() int {\n\treturn len(receiver.data)\n}\n\nfunc (receiver *MyStack) IsEmpty() bool {\n\treturn len(receiver.data) == 0\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(1)ã€‚å‡ºæ ˆæ—¶ï¼Œæœ€åæƒ…å†µä¸‹æ˜¯O(n)ï¼Œä½†æ˜¯ä¹‹åçš„nä¸ªå…ƒç´ å‡ºæ ˆæ˜¯O(1)ï¼Œä»è€Œå¹³æ‘Šä¸‹æ¥æ˜¯O(1)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190353117","body":"### æ€è·¯\n\næƒ³è¦åˆ†å—æ’åºåçš„åºåˆ—ä¸ç›´æ¥æ’åºåçš„åºåˆ—ä¸€è‡´ï¼Œé‚£ä¹ˆå¿…é¡»æ»¡è¶³æ¡ä»¶ï¼š \n>**ä»å·¦å¾€å³çœ‹ï¼Œåé¢çš„å—çš„æœ€å°å€¼ï¼Œè¦å¤§äºç­‰äºå‰é¢å—çš„æœ€å¤§å€¼**  \n\né‚£ä¹ˆï¼Œç¬¬ä¸€ä¸ªå—çš„æœ€å¤§å€¼åœ¨å“ªé‡Œå‘¢ï¼Ÿ å¯ä»¥è®¾å®šä¸ºæ•°ç»„0å·ä½ç½®çš„å€¼ã€‚æ®æ­¤ï¼Œå¯ä»¥ä»1å·ä½ç½®å¾€å³éå†ï¼Œæ‰¾åˆ°æœ€åä¸€ä¸ªå°äº0å·ä½ç½®çš„å€¼çš„ä½ç½®ï¼Œä»è€Œå¾—åˆ°ç¬¬ä¸€ä¸ªå—çš„èµ·æ­¢åŒºé—´ã€‚\n\nä»¥æ­¤ç±»æ¨ï¼Œå°±å¯ä»¥å¾—åˆ°æ‰€æœ‰å—ã€‚  \n\nä»¥ä¸Šç®—æ³•æœ‰ä¸€ä¸ªæœ€å¤§çš„é—®é¢˜å°±æ˜¯ï¼šæ¯ä¸ªå—çš„æœ€åä¸€ä¸ªä½ç½®ï¼Œä¸éå†æ•´ä¸ªæ•°ç»„å°±æ— æ³•å¾—åˆ°ã€‚æ‰€ä»¥ï¼Œè¦æƒ³å¾—åˆ°ä¸€ä¸ªæ—¶é—´å¤æ‚åº¦æ¯”è¾ƒåˆç†çš„ç®—æ³•ï¼Œå°±å¿…é¡»è§£å†³æ­¤é—®é¢˜ã€‚  \n\næ ¹æ®é¢˜ç›®çš„æ ‡ç­¾ï¼Œå¯ä»¥ä½¿ç”¨å•è°ƒæ ˆæ¥è§£å†³ï¼Œå…·ä½“æ¥è®²ï¼Œæ˜¯å•è°ƒé€’å¢æ ˆï¼Œç®—æ³•å¦‚ä¸‹ï¼š\n\n1. åˆå§‹æ—¶ï¼Œå°†0å·ä½ç½®çš„å€¼å…¥æ ˆï¼Œå¹¶ä»1å·ä½ç½®å¼€å§‹å¾€å³éå† \n2. åˆ¤æ–­å½“å‰éå†å¾—åˆ°çš„å…ƒç´ ï¼Œè‹¥è¯¥å€¼å¤§äºç­‰äºæ ˆé¡¶å…ƒç´ ï¼Œåˆ™ç›´æ¥å…¥æ ˆï¼Œå¦åˆ™è½¬ç¬¬3æ­¥\n3. æ ˆå†…å…ƒç´ ä¾æ¬¡å‡ºæ ˆï¼Œç›´åˆ°æ–°çš„æ ˆé¡¶å…ƒç´ çš„å€¼å¤§äºç­‰äºè¯¥å€¼\n4. å–ä¸‹ä¸€ä¸ªå€¼å¹¶è½¬2å¤„ç†\n\n### ä»£ç \n\n\n```Go\nfunc maxChunksToSorted(arr []int) int {\n\tvar cache []int\n\tfor _, item := range arr {\n\t\tlastIdx := len(cache) - 1\n\t\tif len(cache) != 0 && cache[lastIdx] > item {\n\t\t\tmax := cache[lastIdx]\n\t\t\tfor ; lastIdx >= 0; lastIdx-- {\n\t\t\t\tif cache[lastIdx] <= item {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tcache = append(cache[:lastIdx + 1], []int{max}...)\n\t\t} else {\n\t\t\tcache = append(cache, item)\n\t\t}\n\t}\n\treturn len(cache)\n}\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)ï¼Œå‡ºç°åœ¨é¡ºåºé€’å¢åºåˆ—æ—¶","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191410520","body":"### æ€è·¯\n\nå½“æ—‹è½¬çš„æ¬¡æ•°ä¸é“¾æ¥é•¿åº¦ç›¸ç­‰æ—¶ï¼Œæ•ˆæœç­‰åŒäºæœªæ—‹è½¬ã€‚å› æ­¤ï¼Œæ—‹è½¬çš„æ¬¡æ•°éœ€è¦å¯¹é“¾è¡¨é•¿åº¦å–ä½™ï¼Œç„¶åå†æ—‹è½¬å³å¯ \n\n\n### ä»£ç \n\n\n```Go\nfunc rotateRight(head *ListNode, k int) *ListNode {\n\tif head == nil {return head}\n\n\tvar listLen int\n\tvar p1 = head\n\tfor p1 != nil {\n\t\tlistLen++\n\t\tp1 = p1.Next\n\t}\n\n\tdiff := k % listLen\n\tif diff == 0 {\n\t\treturn head\n\t}\n\tp2 := head\n\tp1 = head\n\tfor i := 0; i < diff; i++ {\n\t\tp1 = p1.Next\n\t}\n\tfor p1.Next != nil {\n\t\tp1 = p1.Next\n\t\tp2 = p2.Next\n\t}\n\n\tnewHead := p2.Next\n\tp2.Next = nil\n\tp1.Next = head\n\treturn newHead\n}\n\n\n```\n\n**å¤æ‚åº¦åˆ†æ**  \n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192616321","body":"# ç®—æ³•\né€’å½’\n\n# ä»£ç  \n\n```Go  \n\nfunc swapPairs(head *ListNode) *ListNode {\n\t// 1 -> 2 -> 3 -> 4\n\t// 1 -> 2 -> 3\n\t// 1 -> 2\n\tif head == nil || head.Next == nil {\n\t\treturn head\n\t}\n\n\tp := head.Next\n\thead.Next = swapPairs(p.Next)\n\tp.Next = head\n\treturn p\n}\n\n```\n\n# å¤æ‚åº¦  \n\n- æ—¶é—´å¤æ‚åº¦O(n)  \n- ç©ºé—´å¤æ‚åº¦O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193048220","body":"# æ€è·¯  \n\nBSTåœ¨å‚ç›´æ–¹å‘ä¸Šçš„æŠ•å½±åˆšå¥½æ˜¯ä¸€ä¸ªæœ‰åºçš„æ•°ç»„ï¼Œè€Œé¢˜ç›®ç»™å®šçš„ä¹Ÿæ˜¯ä¸€ä¸ªæœ‰åºçš„æ•°ç»„ã€‚å› æ­¤ï¼Œåœ¨ç»™å®šæ•°ç»„æ—¶ï¼Œåªéœ€è¦å–æ•°ç»„ä¸­é—´çš„å€¼ï¼Œå³å¾—åˆ°æ ¹èŠ‚ç‚¹ï¼Œè¿›è€Œä¹Ÿå¾—åˆ°å·¦å­æ ‘å’Œå³å­æ ‘ã€‚å†å¯¹å·¦å­æ ‘å’Œå³å­æ ‘è¿›è¡ŒåŒæ ·çš„æ“ä½œï¼Œå°±å¾—åˆ°æœ€ç»ˆçš„ç»“æœã€‚\n\n# ä»£ç   \n\n```Go\n\nfunc sortedListToBST(head *ListNode) *TreeNode {\n\tvar buildBST func([]int) *TreeNode\n\tbuildBST = func(data []int) *TreeNode {\n\t\tif data == nil || len(data) == 0 {return nil}\n\n\t\trootIdx := len(data) / 2\n\t\troot := &TreeNode{Val: data[rootIdx]}\n\t\tif rootIdx > 0 {\n\t\t\troot.Left = buildBST(data[:rootIdx])\n\t\t}\n\t\tif rootIdx < len(data) - 1 {\n\t\t\troot.Right = buildBST(data[rootIdx + 1:])\n\t\t}\n\n\t\treturn root\n\t}\n\n\tvar arr []int\n\tfor head != nil {\n\t\tarr = append(arr, head.Val)\n\t\thead = head.Next\n\t}\n\treturn buildBST(arr)\n}\n\n```\n\n# å¤æ‚åº¦  \n\n1. æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n2. ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193243327","body":"# æ€è·¯  \n\nè¿™ä¸ªé—®é¢˜çš„æ ¸å¿ƒåœ¨äºï¼šç›¸é‡æ—¶ï¼Œä¸¤ä¸ªæŒ‡é’ˆèµ°è¿‡çš„è·¯å¾„é•¿åº¦æ˜¯ç›¸ç­‰çš„ã€‚é‚£ä¹ˆï¼Œå› ä¸ºä¸¤ä¸ªé“¾æ¥é•¿åº¦ä¸ç›¸ç­‰ï¼Œé‚£ä¹ˆï¼Œè¦å¦‚ä½•æ‰èƒ½ä¿è¯æŒ‡é’ˆèµ°è¿‡çš„è·¯å¾„ç›¸ç­‰å‘¢ï¼Ÿç­”æ¡ˆå°±æ˜¯å½“æŸä¸ªæŒ‡é’ˆèµ°åˆ°æœ€åä¸€ä¸ªèŠ‚ç‚¹ä¹‹åï¼Œå†ç»§ç»­ä»å¦å¤–çš„é‚£ä¸ªé“¾æ¥ç»§ç»­éå†ã€‚è¿™æ ·ï¼Œå¦‚æœä¸¤ä¸ªé“¾æ¥ç›¸äº¤ï¼Œè‚¯å®šå°±ä¼šåœ¨ç›¸äº¤çš„é‚£ä¸ªèŠ‚ç›¸é‡ã€‚\n\n# ä»£ç   \n\n```Go\n\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\n    aa := headA\n    bb := headB\n    aaChg := false\n    bbChg := false\n\n    for {\n        for aa != nil && bb != nil {\n            if aa == bb {\n                return aa\n            }\n\n            aa = aa.Next\n            bb = bb.Next\n        }\n\n        if aaChg && bbChg {return nil}\n\n        if aa == nil {\n            aaChg = true\n            aa = headB\n        }\n        if bb == nil {\n            bbChg = true\n            bb = headA\n        }\n    }\n    return nil\n}\n\n```\n\n# å¤æ‚åº¦  \n\n1. æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n2. ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194155707","body":"# æ€è·¯  \n\nè¿™ä¸ªé¢˜ç›®æ€»æ˜¯çœ‹åˆ°ï¼Œä¹Ÿæ˜¯ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆï¼Œå½“ä¸¤æŒ‡é’ˆç¬¬ä¸€æ¬¡ç›¸é‡æ—¶è®©å¿«æŒ‡é’ˆå†ä»å¤´å¼€å§‹ï¼Œæ­¥é•¿ä¸º1ï¼Œå’Œæ…¢æŒ‡é’ˆåŒæ—¶å‰è¿›ï¼Œç›¸é‡æ—¶å³ä¸ºå…¥å£èŠ‚ç‚¹ã€‚å…¶å®è¿™ä¸ªè¯æ˜ä¸€ç›´ä¹Ÿæ²¡æœ‰çœ‹å¤ªæ˜ç™½  \n\n# ä»£ç   \n\n```Go\n\nfunc detectCycle(head *ListNode) *ListNode {\n    if head == nil {return nil}\n\n    slow, fast := head, head\n    for slow != nil && fast != nil {\n        slow = slow.Next\n        fast = fast.Next \n        if fast != nil {\n            fast = fast.Next\n        }\n\n        if slow == fast {\n            break\n        }\n    }\n\n    if slow != fast || fast == nil { return nil }\n\n    fast = head\n    for slow != fast {\n        slow = slow.Next\n        fast = fast.Next\n    }\n    return fast\n}\n\n```\n\n# å¤æ‚åº¦  \n1. æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n2. ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195614351","body":"# æ€è·¯  \n\nLRUé€šå¸¸éœ€è¦æœ‰ä¸€ä¸ªç¼“å­˜ç”¨æ¥ä¿å­˜æ•°æ®ï¼Œä¸€ä¸ªé“¾è¡¨ç”¨æ¥ä¿å­˜æ•°æ®çš„æ–°é²œåº¦ï¼Œé“¾è¡¨å¤´è¡¨ç¤ºæœ€è¿‘è®¿é—®çš„å…ƒç´ ï¼Œå°¾è¡¨ç¤ºæœ€ä¹…è¿œæ—¶é—´è®¿é—®çš„å…ƒç´ ã€‚\n\næ ¹æ®é¢˜ç›®çš„å®é™…æƒ…å†µï¼Œå¯ä»¥ä½¿ç”¨æ•´æ•°æ•°ç»„æ¥åšä¸ºç¼“å­˜ï¼Œä¸‹æ ‡å³ä¸ºkeyï¼Œæ‰€ä»¥ï¼ŒæŸ¥æ‰¾åˆ°æ•°æ®æ˜¯å¾ˆå®¹æ˜“çš„ã€‚æŸ¥æ‰¾åˆ°æ•°æ®ä¹‹åï¼Œè¿˜éœ€è¦æŠŠè¯¥æ•°æ®ä»é“¾è¡¨çš„æŸä¸ªä½ç½®ç§»åˆ°é“¾è¡¨å¤´ï¼Œè¿™æ¶‰åŠåˆ°é“¾è¡¨çš„æŸ¥æ‰¾æ“ä½œã€‚è€Œé“¾è¡¨çš„æŸ¥æ‰¾æ“ä½œï¼Œä¸€èˆ¬æ˜¯O(n)çš„ï¼Œæƒ³è¦è¾¾åˆ°O(1)çš„æ—¶é—´å¤æ‚åº¦ï¼Œéœ€è¦ä¸€ä¸ªè¾…åŠ©çš„æ•°æ®ç»“æ„ï¼Œèƒ½å¤Ÿæ ¹æ®æ•°æ®çš„keyå€¼ï¼Œåœ¨O(1)çš„æ—¶é—´å†…æŸ¥æ‰¾åˆ°è¯¥æ•°æ®åœ¨é“¾è¡¨ä¸­çš„ä½ç½®ã€‚åœ¨å¯é€‰çš„æ•°æ®ç»“æ„ä¸­ï¼Œmapå¯ä»¥è¾¾åˆ°è¿™ç§æ•ˆç‡ã€‚  \n\n# ä»£ç   \n\n```Go\n\ntype LRUCache struct {\n\tcache []int\n\tused *list.List\n\ttoUsed map[int]*list.Element\n\tcap int\n\tlen int\n}\n\nconst MaxCacheNum = 10000\nconst NotFound = -1\n\nfunc Constructor(capacity int) LRUCache {\n\tcache := LRUCache{\n\t\tcache: make([]int, MaxCacheNum),\n\t\tused:  list.New(),\n\t\ttoUsed: make(map[int]*list.Element, 0),\n\t\tcap: capacity,\n\t\tlen: 0,\n\t}\n\tfor i := 0; i < MaxCacheNum; i++ {\n\t\tcache.cache[i] = -1\n\t}\n\treturn cache\n}\n\nfunc (this *LRUCache) Get(key int) int {\n\tvalue := this.cache[key]\n\tif value != NotFound {\n\t\tthis.access(key)\n\t}\n\treturn value\n}\n\nfunc (this *LRUCache) Put(key int, value int)  {\n\texist := this.cache[key]\n\tif exist != NotFound {\n\t\tthis.cache[key] = value\n\t\tthis.access(key)\n\t\treturn\n\t}\n\t // ä¸å­˜åœ¨ï¼Œéœ€è¦åˆ¤æ–­æ˜¯å¦æº¢å‡º\n\tif this.len + 1 > this.cap {\n\t\tr := this.used.Remove(this.used.Back()).(int)\n\t\tdelete(this.toUsed, r)\n\t\tthis.cache[r] = -1\n\t\tthis.len--\n\t}\n\n\tthis.cache[key] = value\n\tthis.len++\n\tthis.access(key)\n\treturn\n}\n\nfunc (this *LRUCache) access(key int) {\n\tptr, ok := this.toUsed[key]\n\tif ok {\n        this.used.MoveToFront(ptr)\n\t\treturn\n\t}\n\tthis.used.PushFront(key)\n\tthis.toUsed[key] = this.used.Front()\n}\n\n```\n\n# å¤æ‚åº¦  \n1. æ—¶é—´å¤æ‚åº¦ï¼šO(1)\n2. ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196860535","body":"# æ€è·¯  \n\nç›´æ¥é€’å½’å³å¯\n\n# ä»£ç \n\n```Go\n\nfunc maxDepth(root *TreeNode) int {\n    if root == nil {return 0}\n    return 1 + max(maxDepth(root.Left), maxDepth(root.Right))\n}\n\nfunc max(i, j int) int {\n    if i >= j {return i}\n    return j\n}\n\n```\n\n# å¤æ‚åº¦  \n1. æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n2. ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198033537","body":"# æ€è·¯  \n\né€’å½’å³å¯\n\n# ä»£ç   \n\n```Go\n\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\n    if p == nil && q == nil { return true }\n    if p != nil && q != nil && p.Val == q.Val { return isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right) }\n    return false\n}\n\n```\n\n# å¤æ‚åº¦  \n1. æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n2. ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199401452","body":"# æ€è·¯  \n\nç›´æ¥é€’å½’\n\n# ä»£ç   \n\n```Go\n\nfunc sumNumbers(root *TreeNode) int {\n    var total int\n\n    var sum func(*TreeNode, int)\n    sum = func(node *TreeNode, pathSum int) {\n        if node.Left == nil && node.Right == nil {\n            total += pathSum * 10 + node.Val\n            return\n        }\n\n        pathSum = pathSum * 10 + node.Val\n        if node.Left != nil { sum(node.Left, pathSum) }\n        if node.Right != nil { sum(node.Right, pathSum) }\n    }\n\n    sum(root, 0)\n    return total\n}\n\n```\n\n# å¤æ‚åº¦  \n1. æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œæ¯ä¸ªèŠ‚ç‚¹è®¡ç®—ä¸€æ¬¡\n2. ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200098876","body":"# æ€è·¯  \n\né€’å½’\n\n# ä»£ç   \n\n```Go\n\nfunc findBottomLeftValue(root *TreeNode) int {\n    var height, value int\n\n    var search func(*TreeNode, int)\n    search = func(node *TreeNode, hh int) {\n        hh++\n        if node.Left == nil && node.Right == nil {\n            if hh > height {\n                height = hh\n                value = node.Val\n            }\n            return\n        }\n\n        if node.Left != nil { search(node.Left, hh) }\n        if node.Right != nil { search(node.Right, hh) }\n    }\n\n    search(root, 0)\n    return value\n}\n\n```\n\n# å¤æ‚åº¦  \n1. æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n2. ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200406573","body":"# æ€è·¯  \n\nå±‚åºéå†\n\n# ä»£ç \n\n```Go\n\ntype Codec struct {\n    \n}\n\nfunc Constructor() Codec {\n    return Codec{}\n}\n\n// Serializes a tree to a single string.\nfunc (this *Codec) serialize(root *TreeNode) string {\n    if root == nil {return \"\"}\n\n\tret := strings.Builder{}\n\tqueue := list.New()\n\tqueue.PushBack(root)\n\tfor queue.Len() != 0 {\n\t\tnode := queue.Remove(queue.Front()).(*TreeNode)\n\t\tif node != nil {\n\t\t\t// ret = append(ret, strconv.Itoa(node.Val))\n            ret.WriteString(strconv.Itoa(node.Val))\n            ret.WriteString(\",\")\n\t\t} else {\n\t\t\t// ret = append(ret, \",\")\n            ret.WriteString(\",\")\n\t\t\tcontinue\n\t\t}\n\n\t\tqueue.PushBack(node.Left)\n\t\tqueue.PushBack(node.Right)\n\t}\n\n\t//var i int\n\t//for i = len(ret) - 1; i >= 0; i-- {\n\t\t// if ret[i] != \"\" {\n\t\t\t// break\n\t\t// }\n\t// }\n\treturn strings.Trim(ret.String(), \",\")\n}\n\n// Deserializes your encoded data to tree.\nfunc (this *Codec) deserialize(data string) *TreeNode {   \n    fmt.Printf(\"deserialize: %v\", data)\n    if data == \"\" {return nil}\n\t\n    var cache []*TreeNode\n\tnodes := strings.Split(data, \",\")\n\tnodeVal, _ := strconv.Atoi(nodes[0])\n\troot := &TreeNode{Val: nodeVal}\n\tcache = append(cache, root)\n    cacheIdx := 0\n    cur := cache[cacheIdx]\n    left := true\n\tfor i := 1; i < len(nodes); i++ {\n        if nodes[i] == \"\" {\n            if left {\n                left = false\n            } else {\n                left = true\n                cacheIdx++\n                cur = cache[cacheIdx]\n            }\n            continue\n        }\n\n\t    nodeVal, _ := strconv.Atoi(nodes[i])\n        node := &TreeNode{Val: nodeVal}\n        cache = append(cache, node)\n\n        if left {\n            cur.Left = node\n            left = false\n        } else {\n            cur.Right = node\n            left = true\n            cacheIdx++\n            cur = cache[cacheIdx]\n        }\n\t}\n\t\n\treturn root\n}\n\n```\n\n# å¤æ‚åº¦  \n1. æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n2. ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201343179","body":"# æ€è·¯  \n\nè¿™ä¸ªé¢˜ç›®çš„æ€è·¯æ˜¯ç›¸å½“ç›´æ¥çš„ï¼Œé¦–å…ˆéå†å¾—åˆ°å„ä¸ªèŠ‚ç‚¹çš„åæ ‡ï¼Œç„¶åæŒ‰åæ ‡æ’åºå³å¯\n\n# ä»£ç   \n\n```Go\n\ntype newNode struct {\n\tcol int\n\trow int\n\tval int\n}\n\nfunc verticalTraversal(root *TreeNode) [][]int {\n\tvar nodes = make([]*newNode, 0)\n\n\tvar travel func(node *TreeNode, row, col int)\n\ttravel = func(node *TreeNode, row, col int) {\n\t\tif node == nil {\n\t\t\treturn\n\t\t}\n\t\tnodes = append(nodes, &newNode{col: col, row: row, val: node.Val})\n\t\ttravel(node.Left, row+1, col-1)\n\t\ttravel(node.Right, row+1, col+1)\n\t}\n\ttravel(root, 0, 0)\n\t// fmt.Printf(\"nodes: %+v\\n\", nodes)\n\n\tret := make([][]int, 0)\n\n\tsort.Slice(nodes, func(i, j int) bool {\n\t\ta, b := nodes[i], nodes[j]\n\t\treturn a.col < b.col || a.col == b.col && (a.row < b.row || a.row == b.row && a.val < b.val)\n\t})\n\n\tlastCol := math.MinInt32\n\tfor _, node := range nodes {\n\t\tif node.col != lastCol {\n\t\t\tlastCol = node.col\n\t\t\tret = append(ret, nil)\n\t\t}\n\t\tret[len(ret)-1] = append(ret[len(ret)-1], node.val)\n\t}\n\n\treturn ret\n}\n\n```\n\n# å¤æ‚åº¦  \n1. æ—¶é—´å¤æ‚åº¦ï¼šO(n) + O(nlogn) + O(n) = O(nlogn)\n2. ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202615087","body":"# æ€è·¯  \n\nä½¿ç”¨mapï¼Œkeyä¸ºä½™æ•°ï¼Œvalä¸ºç´¢å¼•\n\n# ä»£ç   \n\n```Go\n\nfunc twoSum(nums []int, target int) []int {\n    record := make(map[int]int, 0)\n\n    for idx, i := range nums {\n        if last, ok := record[i]; ok {\n            return []int{last, idx}\n        }\n        record[target - i] = idx\n    }\n\n    return nil\n}\n\n```\n\n# å¤æ‚åº¦  \n1. æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n2. ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1204036096","body":"# æ€è·¯  \n\nå…ˆç»Ÿè®¡å‡ºç°çš„é¢‘ç‡ï¼Œç„¶åç»´æŒä¸€ä¸ªå¤§å°ä¸ºkçš„æœ€å°å †\n\n# ä»£ç   \n\n```Go\n\nfunc topKFrequent(nums []int, k int) []int {\n    countMap := make(map[int]int)\n    for _, word := range nums {\n        countMap[word]++\n    }\n\n    h := &ItemHeap{}\n    for w, v := range countMap {\n        heap.Push(h, Item{\n            word:  w,\n            count: v,\n        })\n\n        if h.Len() > k {\n            heap.Pop(h)\n        }\n    }\n\n    res := make([]int, h.Len())\n    for i := h.Len() - 1; i >= 0; i-- {\n        item := heap.Pop(h).(Item)\n        res[i] = item.word\n    }\n    return res\n}\n\ntype Item struct {\n    word  int\n    count int\n}\n\ntype ItemHeap []Item\n\nfunc (h ItemHeap) Len() int { return len(h) }\n\nfunc (h ItemHeap) Less(i, j int) bool {\n    if h[i].count != h[j].count {\n        return h[i].count < h[j].count\n    } else {\n        return h[i].word > h[j].word\n    }\n}\n\nfunc (h ItemHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }\n\nfunc (h *ItemHeap) Push(val interface{}) {\n    *h = append(*h, val.(Item))\n}\n\nfunc (h *ItemHeap) Pop() interface{} {\n    old := *h\n    n := len(old)\n    x := old[n-1]\n    *h = old[0 : n-1]\n    return x\n}\n\n```\n\n# å¤æ‚åº¦  \n1. æ—¶é—´å¤æ‚åº¦ï¼šO(nlogk)\n2. ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1207185511","body":"# æ€è·¯  \n\nåŒæŒ‡é’ˆåŠ å“ˆå¸Œè¡¨ï¼Œå…¶ä¸­å“ˆå¸Œè¡¨å¯ä»¥ä½¿ç”¨æ•°ç»„æ¥ä»£æ›¿\n\n# ä»£ç   \n\n```Go\n\nfunc lengthOfLongestSubstring(s string) int {\n\tvar cache [256]bool\n\tmaxLen := 0\n\tbegin, end := 0, 0\n\n\tfor end < len(s) {\n\t\tif !cache[s[end]] {\n\t\t\tcache[s[end]] = true\n\t\t\tend++\n\t\t\tcontinue\n\t\t}\n\n\t\ttmp := end - begin\n\t\tif tmp > maxLen {\n\t\t\tmaxLen = tmp\n\t\t}\n\n\t\t// beginéœ€è¦å‰è¿›åˆ°s[end]çš„ä¸‹ä¸€ä¸ªå­—ç¬¦\n\t\tfor begin <= end {\n\t\t\tcache[s[begin]] = false\n\t\t\tif s[begin] == s[end] {\n\t\t\t\tbegin++\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tbegin++\n\t\t}\n\t}\n\ttmp := end - begin\n\tif tmp > maxLen {\n\t\tmaxLen = tmp\n\t}\n\n\treturn maxLen\n}\n\n```\n\n# å¤æ‚åº¦  \n1. æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n2. ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207185019","body":"# æ€è·¯  \n\nå…ˆç»Ÿè®¡wordsæ•°ç»„ä¸­æ¯ä¸ªå•è¯å‡ºç°çš„æ¬¡æ•°ï¼Œç„¶åå†å°†så­—ç¬¦ä¸²è¿›è¡Œåˆ‡åˆ†ï¼Œæ¯æ¬¡åˆ‡å‡ºæ¥çš„é•¿åº¦ä¸ºlen(words[0])*len(word)çš„é•¿åº¦ï¼Œæ¯”è¾ƒè¿™ä¸ªå­—ä¸²ä¸­çš„å•è¯æ˜¯å¦ä¸wordsä¸­å•è¯å‡ºç°çš„æ¬¡æ•°ä¸€æ ·å³æ¥ã€‚\nè‹¥ä¸æ»¡è¶³ï¼Œåˆ™å°†så‘å‰æ»‘åŠ¨ä¸€ä¸ªä½ç½®ï¼Œåˆ‡åˆ†å‡ºä¸€ä¸ªæ–°çš„å­ä¸²ï¼Œå¦‚æ­¤å¾ªç¯ã€‚\n\n# ä»£ç   \n\n```Go\n\nfunc findSubstring(s string, words []string) []int {\n    wordNum := len(words)\n    wordLen := len(words[0])\n    allWorkLen := wordNum * wordLen\n    wordsCount := make(map[string]int, len(words))\n    for _, word := range words {\n        if _, ok := wordsCount[word]; ok {\n            wordsCount[word] += 1\n        } else {\n            wordsCount[word] = 1\n        }\n    }\n\n    var match func(ss string) bool\n    match = func(ss string) bool {\n        num := 0\n        hasCount := make(map[string]int, len(words))\n        for i := 0; i < len(ss); i += wordLen {\n            word := ss[i:i+wordLen]\n            if _, ok := wordsCount[word]; !ok {\n                return false\n            }\n\n            num++\n\n            if _, ok := hasCount[word]; !ok {\n                hasCount[word] = 1\n                continue\n            }\n\n            hasCount[word]++\n            if hasCount[word] > wordsCount[word] {\n                return false\n            }\n        }\n\n        return num == wordNum\n    }\n\n    ret := make([]int, 0)\n    for i := 0; i <= len(s) - allWorkLen; i++ {\n        if match(s[i:i+allWorkLen]) {\n            ret = append(ret, i)\n        }\n    }\n    return ret\n}\n\n```\n\n# å¤æ‚åº¦  \n1. æ—¶é—´å¤æ‚åº¦ï¼šå¤–å±‚å¾ªç¯ä¸ºO(n)ï¼Œå†…å±‚å¾ªç¯ä¸ºï¼šO(len(words)*len(words[0])ï¼Œåˆèµ·æ¥å³ä¸ºO(nm)\n2. ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208123210","body":"# æ€è·¯  \n\nå¿«æ…¢æŒ‡é’ˆ\n\n# ä»£ç   \n\n```Go\n\nfunc middleNode(head *ListNode) *ListNode {\n    slow, fast := head, head\n    for {\n        if fast.Next != nil {\n            fast = fast.Next\n            slow = slow.Next\n        }\n        if fast.Next == nil {\n            break\n        }\n        fast = fast.Next\n    }\n\n    return slow\n}\n\n```\n\n# å¤æ‚åº¦  \n1. æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n2. ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zoulufeng":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1189813947","body":"\r\n\r\n\r\n\r\n\r\n```python\r\ndef list_number(a_list, k):\r\n    a_num = []\r\n    for i in a_list:\r\n        a_num.append(str(i))\r\n    b_num = \"\".join(a_num)\r\n    a_number = int(b_num)\r\n    a_k = a_number + k\r\n    c_num = []\r\n    while(a_k > 10):\r\n        c_num.append(a_k % 10)\r\n        a_k = a_k // 10\r\n    c_num.append(a_k)\r\n    c_num.reverse()\r\n    return c_num\r\n```\r\næ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(n)$","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186121556","body":"# Day02\r\n---\r\n## \tSolution1\r\n---\r\n### ä½¿ç”¨è¯­è¨€ Python\r\n---\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        index_list = []\r\n        for index, value in enumerate(s):\r\n            if value == c:\r\n                index_list.append(index)\r\n        # print(index_list)\r\n        distance_list = []\r\n        for index, value in enumerate(s):\r\n            temp_list = []\r\n            for i in index_list:\r\n                temp_list.append(abs(index - i))\r\n            # print(temp_list)\r\n            distance_list.append(min(temp_list))\r\n            # print(distance_list)\r\n        return distance_list\r\n```\r\næ—¶é—´å¤æ‚åº¦ï¼šO(n^2)\r\nç©ºé—´å¤æ‚åº¦ï¼šO(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186390157","body":"# Day03\r\n---\r\n## ä½¿ç”¨è¯­è¨€ï¼š Python\r\n---\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.a_list = [] * self.maxSize\r\n        self.numPop = 0\r\n        self.len_a = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        self.len_a = len(self.a_list)\r\n        if self.len_a < self.maxSize:\r\n            self.a_list.append(x)\r\n\r\n    def pop(self) -> int:\r\n        self.len_a = len(self.a_list)\r\n        if len(self.a_list) == 0:\r\n            return -1\r\n        return self.a_list.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        self.len_a = len(self.a_list)\r\n        if k > self.len_a:\r\n            for i in range(self.len_a):\r\n                self.a_list[i] += val\r\n        else:\r\n            for i in range(k):\r\n                self.a_list[i] += val\r\n```\r\n---\r\næ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1188648564","body":"# day 04\r\n---\r\n## ä½¿ç”¨è¯­è¨€ï¼š Python\r\n---\r\n```python\r\nclass Solution:  \r\n  def decodeString(self, s: str) -> str:  \r\n  s_list = list(s)  \r\n  \r\n  a_list = []  \r\n  for index, value in enumerate(s_list):  \r\n  if value != ']':  \r\n  a_list.append(value)  \r\n  else:  \r\n  right = len(a_list)  \r\n  left = \"\".join(a_list).rfind('[')  \r\n  left_left = left - 2  \r\n  num_left_left = a_list[left_left]  \r\n  \r\n  while(48 <= ord(num_left_left) <= 57):  \r\n  if left_left != 0:  \r\n  left_left -= 1  \r\n  num_left_left = a_list[left_left]  \r\n  else:  \r\n  left_left -= 1  \r\n  break  \r\n  int_num = 1  \r\n  int_num = \"\".join(a_list[left_left+1:left])  \r\n  ss = a_list[left + 1:right] * int(int_num)  \r\n  a_list[left_left+1:right + 1] = \"\"  \r\n  # print(a_list)  \r\n  for i in ss:  \r\n  a_list.append(i)  \r\n  s_list = s_list[:left - 1] + s_list[right + 1:]  \r\n  # print(s_list)  \r\n  \r\n  return \"\".join(a_list)\r\n```\r\næ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(3n)$\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188646161","body":"# day 05\r\n---\r\n## ä½¿ç”¨è¯­è¨€ï¼š Python\r\n---\r\n```python\r\nclass MyQueue:  \r\n  \r\n  def __init__(self):  \r\n  self.myQue = list()  \r\n  \r\n  def push(self, x: int) -> None:  \r\n  self.myQue.append(x)  \r\n  # print(self.myQue)  \r\n  \r\n  def pop(self) -> int:  \r\n  temp = self.myQue[0]  \r\n  del self.myQue[0]  \r\n  return temp  \r\n  \r\n    def peek(self) -> int:  \r\n  return self.myQue[0]  \r\n  \r\n  def empty(self) -> bool:  \r\n  return False if len(self.myQue) else True\r\n```\r\næ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190089322","body":"# day06\r\n---\r\n## ä½¿ç”¨è¯­è¨€ï¼š Python\r\n---\r\n```python\r\nclass Solution:  \r\n\tdef maxChunksToSorted(self, arr: List[int]) -> int:  \r\n\t\tstart_index, max_index, end_index = 0, 0, 0  \r\n\t\tc_list = []  \r\n\t    len_arr = len(arr)  \r\n\t    while start_index <= len_arr-1:  \r\n\t\t\tend_index = start_index  \r\n            max_index = start_index  \r\n            if start_index == (len_arr-1):  \r\n\t\t\t\tc_list.append(arr[start_index])  \r\n\t\t\t\tbreak  \r\n\t\t    for index, value in enumerate(arr[start_index+1:]):  \r\n\t\t\t\tif arr[start_index] > value:  \r\n\t\t\t\t\tend_index = index+start_index+1  \r\n            max_number = max(arr[start_index:end_index + 1])  \r\n            max_index_temp = arr[start_index:end_index + 1].index(max_number)+ start_index  \r\n            while max_index != max_index_temp:  \r\n\t\t\t\tmax_index = max_index_temp  \r\n                end_index_temp = end_index  \r\n                for iindex, ivalue in enumerate(arr[(end_index+1):]):  \r\n\t\t\t\t\tif arr[max_index_temp] > ivalue:  \r\n\t\t\t\t\t\tend_index_temp = iindex + end_index+1  \r\n\t\t\t\t\tend_index = end_index_temp  \r\n\t\t\t        max_index_temp = arr[start_index:end_index + 1].index(max(arr[start_index:end_index + 1]))  \r\n\t\t\tif end_index == start_index:  \r\n\t\t\t\tc_list.append(arr[start_index])  \r\n\t\t\telse:  \r\n\t\t\t\tc_list.append(arr[start_index:end_index + 1])  \r\n\t\t\tstart_index = end_index + 1  \r\n\t\t# print(c_list)  \r\n\t\treturn(len(c_list))\r\n```\r\næ—¶é—´å¤æ‚åº¦ï¼š$O(n^3)$\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191080530","body":"# day07\r\n---\r\n## ä½¿ç”¨è¯­è¨€ï¼šPython\r\n> æ²¡æœ‰æŠ€å·§ï¼Œå…¨æ˜¯æ„Ÿæƒ…\r\n---\r\n```python\r\nfrom typing import Optional\r\n# Definition for singly-linked list.\r\n\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\n\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if head:\r\n            a_list = []\r\n            len_head = 1\r\n            real_k = 0\r\n            next_point = head.next\r\n            a_list.append(head.val)\r\n            while next_point:\r\n                a_list.append(next_point.val)\r\n                len_head += 1\r\n                next_point = next_point.next\r\n            real_k = k % len_head\r\n            # print(a_list)\r\n            b_list = [0 for i in range(len_head)]\r\n            for index, value in enumerate(a_list):\r\n                real_index = (real_k + index) % len_head\r\n                b_list[real_index] = value\r\n            # print(b_list)\r\n            L_head = ListNode(b_list[0])\r\n            cur = L_head\r\n            for i in range(1, len_head):\r\n                temp = ListNode(b_list[i])\r\n                cur.next = temp\r\n                cur = temp\r\n                if i == len_head - 1:\r\n                    cur.next = None\r\n\r\n            return L_head\r\n```\r\n---\r\næ—¶é—´å¤æ‚åº¦ï¼š$O(3n)$\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(2n)$\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1193260880","body":"# day08\r\n---\r\n## ä½¿ç”¨è¯­è¨€ï¼špython\r\n---\r\n> ä½¿ç”¨é€’å½’çš„æ–¹æ³•è§£å†³é—®é¢˜\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        newHead = head.next\r\n        head.next = self.swapPairs(newHead.next)\r\n        newHead.next = head\r\n        return newHead\r\n```\r\n---\r\næ—¶é—´å¤æ‚åº¦:$O(n)$\r\nç©ºé—´å¤æ‚åº¦:$O(1)$\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193146224","body":"# day09\r\n---\r\n## ä½¿ç”¨è¯­è¨€ï¼š python\r\n---\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        return self.helper(head,None)\r\n\r\n    def helper(self,head,tail):\r\n        if head==tail:\r\n            return\r\n        slow=head\r\n        fast=head\r\n        while fast!=tail and fast.next!=tail:\r\n            slow=slow.next\r\n            fast=fast.next.next\r\n        root=TreeNode(slow.val)\r\n        root.left=self.helper(head,slow)\r\n        root.right=self.helper(slow.next,tail)\r\n        return root\r\n```\r\næ—¶é—´å¤æ‚åº¦ï¼š $O(n)$\r\nç©ºé—´å¤æ‚åº¦ï¼š $O(n)$\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193319102","body":"# day10\r\n---\r\n## ä½¿ç”¨è¯­è¨€ï¼špython\r\n---\r\n> åšé¢˜æ€è·¯ï¼šåˆ©ç”¨äº¤å‰é“¾è¡¨æœ€åå‡ ä¸ªä¸€å®šä¸€æ ·çš„ç‰¹æ€§ï¼ŒæŠŠheadAå’ŒheadBå¯¹é½ä¹‹åï¼ŒåŒæ—¶å¤„ç†ã€‚\r\n---\r\n> åšé¢˜æ—¶é•¿ï¼šä¸€ä¸ªåŠå°æ—¶\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> None:\r\n        len_headA = 0\r\n        len_headB = 0\r\n        temp_headA = headA\r\n        while temp_headA:\r\n            len_headA += 1\r\n            temp_headA = temp_headA.next\r\n\r\n        temp_headB = headB\r\n        while temp_headB:\r\n            len_headB += 1\r\n            temp_headB = temp_headB.next\r\n\r\n        # print(len_headA)\r\n        # print(len_headB)\r\n        temp_headA = ListNode(0, headA)\r\n        temp_headB = ListNode(0, headB)\r\n        if not len_headA or not len_headB:\r\n            return None\r\n        else:\r\n            do_len = len_headA - len_headB if len_headA > len_headB else len_headB - len_headA\r\n            for i in range(do_len):\r\n                if len_headA < len_headB:\r\n                    temp_headB = temp_headB.next\r\n                else:\r\n                    temp_headA = temp_headA.next\r\n            do_circle = min(len_headB, len_headA)\r\n            for i in range(do_circle):\r\n                if temp_headB.next == temp_headA.next:\r\n                    return temp_headA.next\r\n                temp_headB = temp_headB.next\r\n                temp_headA = temp_headA.next\r\n        return None\r\n```\r\næ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193463553","body":"# day11\r\n---\r\n## ä½¿ç”¨è¯­è¨€ï¼š Python\r\n---\r\n> åšé¢˜æ€è·¯ï¼šæŠŠæŒ‡é’ˆè£…è¿›æ•°ç»„ä¸­ï¼Œå¦‚æœæœ‰é‡å¤çš„æŒ‡é’ˆå°±è¿”å›è¿™ä¸ªæŒ‡é’ˆ\r\n---\r\n\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        \r\n        fast_point  = head\r\n        \r\n        new_point = ListNode(0, head)\r\n        \r\n        fast_point = new_point \r\n        \r\n        a_list = []\r\n        while fast_point.next:\r\n            if fast_point.next in a_list:\r\n                return fast_point.next\r\n            a_list.append(fast_point.next)\r\n            fast_point = fast_point.next\r\n```\r\næ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195449844","body":"class ListNode:\r\n    def __init__(self, key=None, value=None):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = None\r\n        self.next = None\r\n\r\n\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.hashmap = {}\r\n        # æ–°å»ºä¸¤ä¸ªèŠ‚ç‚¹ head å’Œ tail\r\n        self.head = ListNode()\r\n        self.tail = ListNode()\r\n        # åˆå§‹åŒ–é“¾è¡¨ä¸º head <-> tail\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n\r\n    # å› ä¸ºgetä¸putæ“ä½œéƒ½å¯èƒ½éœ€è¦å°†åŒå‘é“¾è¡¨ä¸­çš„æŸä¸ªèŠ‚ç‚¹ç§»åˆ°æœ«å°¾ï¼Œæ‰€ä»¥å®šä¹‰ä¸€ä¸ªæ–¹æ³•\r\n    def move_node_to_tail(self, key):\r\n            # å…ˆå°†å“ˆå¸Œè¡¨keyæŒ‡å‘çš„èŠ‚ç‚¹æ‹å‡ºæ¥ï¼Œä¸ºäº†ç®€æ´èµ·ånode\r\n            #      hashmap[key]                               hashmap[key]\r\n            #           |                                          |\r\n            #           V              -->                         V\r\n            # prev <-> node <-> next         pre <-> next   ...   node\r\n            node = self.hashmap[key]\r\n            node.prev.next = node.next\r\n            node.next.prev = node.prev\r\n            # ä¹‹åå°†nodeæ’å…¥åˆ°å°¾èŠ‚ç‚¹å‰\r\n            #                 hashmap[key]                 hashmap[key]\r\n            #                      |                            |\r\n            #                      V        -->                 V\r\n            # prev <-> tail  ...  node                prev <-> node <-> tail\r\n            node.prev = self.tail.prev\r\n            node.next = self.tail\r\n            self.tail.prev.next = node\r\n            self.tail.prev = node\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.hashmap:\r\n            # å¦‚æœå·²ç»åœ¨é“¾è¡¨ä¸­äº†ä¹…æŠŠå®ƒç§»åˆ°æœ«å°¾ï¼ˆå˜æˆæœ€æ–°è®¿é—®çš„ï¼‰\r\n            self.move_node_to_tail(key)\r\n        res = self.hashmap.get(key, -1)\r\n        if res == -1:\r\n            return res\r\n        else:\r\n            return res.value\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.hashmap:\r\n            # å¦‚æœkeyæœ¬èº«å·²ç»åœ¨å“ˆå¸Œè¡¨ä¸­äº†å°±ä¸éœ€è¦åœ¨é“¾è¡¨ä¸­åŠ å…¥æ–°çš„èŠ‚ç‚¹\r\n            # ä½†æ˜¯éœ€è¦æ›´æ–°å­—å…¸è¯¥å€¼å¯¹åº”èŠ‚ç‚¹çš„value\r\n            self.hashmap[key].value = value\r\n            # ä¹‹åå°†è¯¥èŠ‚ç‚¹ç§»åˆ°æœ«å°¾\r\n            self.move_node_to_tail(key)\r\n        else:\r\n            if len(self.hashmap) == self.capacity:\r\n                # å»æ‰å“ˆå¸Œè¡¨å¯¹åº”é¡¹\r\n                self.hashmap.pop(self.head.next.key)\r\n                # å»æ‰æœ€ä¹…æ²¡æœ‰è¢«è®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼Œå³å¤´èŠ‚ç‚¹ä¹‹åçš„èŠ‚ç‚¹\r\n                self.head.next = self.head.next.next\r\n                self.head.next.prev = self.head\r\n            # å¦‚æœä¸åœ¨çš„è¯å°±æ’å…¥åˆ°å°¾èŠ‚ç‚¹å‰\r\n            new = ListNode(key, value)\r\n            self.hashmap[key] = new\r\n            new.prev = self.tail.prev\r\n            new.next = self.tail\r\n            self.tail.prev.next = new\r\n            self.tail.prev = new\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196174306","body":"# day13\r\n---\r\n## ä½¿ç”¨è¯­è¨€ï¼š python\r\n---\r\n> è¿˜æ˜¯ä¸æ€ä¹ˆä¼šé€’å½’\r\n> æœ€åå‹‰å‹‰å¼ºå¼ºæŠŠé€’å½’ç†è§£æˆå¤§é—®é¢˜çœ‹æˆå°é—®é¢˜ç»„åˆçš„æ€è·¯åšå‡ºæ¥çš„ã€‚\r\n> ä½†æ˜¯ç”¨é€’å½’éå†çš„é‚£ç§æ€è·¯ï¼Œè¿˜æ˜¯ä¸æ‡‚\r\n```python\r\nclass  Solution:\r\n\tdef  maxDepth(self, root: Optional[TreeNode]) -> int:\r\n\t\tif root is  None:\r\n\t\t\treturn  0\r\n\t\tleft_num = self.maxDepth(root.left)\r\n\t\tright_num = self.maxDepth(root.right)\r\n\t\tres = max(left_num, right_num) + 1\r\n\treturn res\r\n```\r\n---\r\næ—¶é—´å¤æ‚åº¦ï¼š$O()$\r\nç©ºé—´å¤æ‚åº¦ï¼š$O()$\r\n\r\n---\r\né€’å½’çš„è¿™ä¸¤ä¸ªå¤æ‚åº¦ä¸ä¼šè®¡ç®—","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197505372","body":"# day14\r\n---\r\n## ä½¿ç”¨è¯­è¨€ï¼špython\r\n---\r\n> ä½¿ç”¨åˆ†è§£æ¨¡å¼çš„é€’å½’æ€è·¯è§£å†³é—®é¢˜\r\n```python\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not q and not p:\r\n            return True\r\n        elif not q or not p:\r\n            return False\r\n        \r\n        return q.val==p.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```\r\næ—¶é—´å¤æ‚åº¦:$O()$\r\nç©ºé—´å¤æ‚åº¦:$O()$\r\n> æ¶‰åŠåˆ°é€’å½’ä¹‹åçš„è¿™ä¸¤ä¸ªå¤æ‚åº¦æˆ‘è¿˜æ˜¯ä¸ä¼šåˆ†æ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199517772","body":"# day15\r\n---\r\n##  ä½¿ç”¨è¯­è¨€ï¼špython\r\n---\r\n```PYTHON\r\nclass Solution:  \r\n\tdef sumNumbers(self, root: Optional[TreeNode]) -> int: \r\n\t\tself.num = 0  \r\n\t\tif  not root: \r\n\t\t\treturn self.root \r\n\t\tdef dfs(num, root): \r\n\t\t\tnum = num * 10 + root.val \r\n\t\t\tif  not root.right and  not root.left: \r\n\t\t\t\tself.num += num \r\n\t\t\tif root.left: \r\n\t\t\t\tdfs(num, root.left) \r\n\t\t\tif root.right: \r\n\t\t\t\tdfs(num, root.right) \r\n\t\tdfs(0, root) \r\n\t\treturn self.num\r\n```\r\næ—¶é—´å¤æ‚åº¦ï¼š$O()$\r\nç©ºé—´å¤æ‚åº¦ï¼š$O()$\r\n\r\n---\r\næ¶‰åŠåˆ°é€’å½’çš„ç¨‹åºè¿˜æ˜¯ä¸ä¼šåˆ†æå¤æ‚åº¦","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200047752","body":"# day16\r\n---\r\n## ä½¿ç”¨è¯­è¨€ï¼špython\r\n---\r\n```python\r\nclass Solution:  \r\n\tdef __init__(self): \r\n\t\tself.max_depth = 0 \r\n\t\tself.depth = 0 \r\n\t\tself.res = TreeNode() \r\n\t\tdef traverse(self, root: Optional[TreeNode]) -> None:  \r\n\t\t\tif  not root: return \r\n\t\t\tself.depth += 1  \r\n\t\t\tif self.depth > self.max_depth: \r\n\t\t\t\tself.max_depth = self.depth \r\n\t\t\t\tself.res = root \r\n\t\t\tself.traverse(root.left) \r\n\t\t\tself.traverse(root.right) \r\n\t\t\tself.depth -= 1  \r\n\tdef findBottomLeftValue(self, root: Optional[TreeNode]) -> int:   \r\n\t    self.traverse(root) \r\n\t\treturn self.res.val\r\n```\r\næ—¶é—´å¤æ‚åº¦:$O()$\r\nç©ºé—´å¤æ‚åº¦:$O()$\r\n\r\n---\r\nå¯¹äºé€’å½’çš„è§£æ³•è¿˜æ˜¯ä¸çŸ¥é“æ€ä¹ˆç®—è¿™ä¸¤ä¸ªå¤æ‚åº¦","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200342781","body":"# day17\r\n---\r\n## ä½¿ç”¨è¯­è¨€ï¼špython\r\n---\r\n> åšé¢˜æ—¶é—´ï¼š1h49min\r\n---\r\n```python\r\nclass Codec:\r\n22 \r\n23     def __init__(self):\r\n24         self.a_str = \"\"\r\n25 \r\n26     def serialize(self, root):\r\n27         \"\"\"Encodes a tree to a single string. \r\n28  \r\n29         :type root: TreeNode \r\n30         :rtype: str \r\n31         \"\"\"\r\n32         self.traverse(root)\r\n33         return self.a_str\r\n34 \r\n35     def traverse(self, root):\r\n36         if not root:\r\n37             self.a_str += \"#,\"\r\n38             return None\r\n39         self.a_str += str(root.val)\r\n40         self.a_str += ','\r\n41         self.serialize(root.left)\r\n42         self.serialize(root.right)\r\n43 \r\n44     def deserialize(self, data):\r\n45         \"\"\"Decodes your encoded data to tree. \r\n46  \r\n47         :type data: str \r\n48         :rtype: TreeNode \r\n49         \"\"\"\r\n50         print(data)\r\n51         a_list = data.split(',')\r\n52         print(a_list)\r\n53         return self.traverse_de(a_list)\r\n54 \r\n55     def traverse_de(self, a_list):\r\n56 \r\n57         if not a_list:\r\n58             return None\r\n59 \r\n60         num = a_list.pop(0)\r\n61         if num == '#':\r\n62             return None\r\n63 \r\n64         if num == '-':\r\n65             tnum = a_list.pop(0)\r\n66             root = TreeNode(-int(tnum))\r\n67         else:\r\n68             root = TreeNode(int(num))\r\n69 \r\n70         root.left = self.traverse_de(a_list)\r\n71         root.right = self.traverse_de(a_list)\r\n72 \r\n73         return root\r\n```\r\næ—¶é—´å¤æ‚åº¦ï¼š$O()$\r\nç©ºé—´å¤æ‚åº¦ï¼š$O()$\r\n\r\n---\r\nè®¾è®¡é€’å½’è§£æ³•çš„ä¸¤ä¸ªå¤æ‚åº¦ï¼Œæˆ‘è¿˜æ˜¯ä¸ä¼šè®¡ç®— ï¼šï¼‰","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200638591","body":"# day18\r\n---\r\n## ä½¿ç”¨è¯­è¨€ï¼špython\r\n---\r\n> ä½¿ç”¨æ—¶é—´2h10min\r\n---\r\n> æ²¡æœ‰ä»»ä½•æŠ€å·§ï¼Œå…¨æ˜¯é™·åœ¨ç»†èŠ‚ä¸­æŠ ç»†èŠ‚ã€‚\r\n> å­¦ä¼šäº†æ€ä¹ˆä½¿ç”¨lambdaåšå‡½æ•°çš„å‚æ•°è¿›è¡Œå¤šæ¡ä»¶æ’åº\r\n```python\r\n9 class Solution:\r\n10     def __init__(self):\r\n11         self.a_list = []\r\n12         self.b_list = []\r\n13         self.c_list = []\r\n14 \r\n15     def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\r\n16         self.traverse(root, 0, 0)\r\n17         return self.devide_grope(self.a_list)\r\n18 \r\n19         # print(self.b_list)\r\n20 \r\n21     def traverse(self, root, row, col):\r\n22         if not root:\r\n23             return None\r\n24         self.a_list.append([row, col, root.val])\r\n25         self.traverse(root.left, row + 1, col - 1)\r\n26         self.traverse(root.right, row + 1, col + 1)\r\n27 \r\n28     def devide_grope(self, data):\r\n29         self.b_list = sorted(data, key=lambda x: (x[1], x[0], x[2]))\r\n30         b_list = []\r\n31         c_list = []\r\n32 \r\n33         for i in self.b_list:\r\n34             if i[1] not in c_list:\r\n35                 c_list.append(i[1])\r\n36                 b_list.append('#')\r\n37 \r\n38             b_list.append(i[2])\r\n39 \r\n40         row = b_list.count('#')\r\n41         a_list = [[] for _ in range(row)]\r\n42         print(b_list)\r\n43 \r\n44         num = -1\r\n45         for i in b_list:\r\n46             if i == '#':\r\n47                 num += 1\r\n48             else:\r\n49                 a_list[num].append(i)\r\n50         return a_list\r\n```\r\næ—¶é—´å¤æ‚åº¦ï¼š$O()$\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(n)$\r\n\r\n---\r\næ¶‰åŠé€’å½’çš„ä¸¤ä¸ªå¤æ‚åº¦è¿˜æ˜¯ä¸ä¼šè®¡ç®—","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201920330","body":"# day19\r\n---\r\n## ä½¿ç”¨è¯­è¨€ï¼špython\r\n---\r\n> è¿™æ¬¡ä½¿ç”¨å“ˆå¸ŒæŸ¥æ‰¾æ³•åšçš„è¿™é“é¢˜\r\n> æ•ˆæœè¿˜å¯ä»¥\r\n```python\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        a_dict = {}\r\n        for index, value in enumerate(nums):\r\n            m = target - value\r\n            if m in a_dict:\r\n                return [a_dict[m], index]\r\n            else:\r\n                a_dict[value] = index\r\n```\r\næ—¶é—´å¤æ‚åº¦:$O(n)$\r\nç©ºé—´å¤æ‚åº¦:$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203455367","body":"# day20\r\n---\r\n## ä½¿ç”¨è¯­è¨€ï¼špython\r\n---\r\n> ç”¨æ—¶ï¼š1h\r\n\r\n> ä½¿ç”¨æŠ€å·§ï¼š\r\n>  * ä½¿ç”¨å­—å…¸å®ç°å“ˆå¸Œå­˜å‚¨\r\n>  * ä½¿ç”¨sortedå‡½æ•°å¯¹å­—å…¸æ’åº\r\n>  * ä½¿ç”¨åˆ‡ç‰‡[:k]é€‰æ‹©å‰kå…ƒç´ \r\n```python\r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        a_list = []\r\n        a_dict = {}\r\n        for i in nums:\r\n            if i not in a_dict:\r\n                a_dict[i] = 1\r\n            else:\r\n                a_dict[i] += 1\r\n\r\n        b_dict = sorted(a_dict.items(), key=lambda x: x[1], reverse=True)[:k]\r\n        for i in b_dict:\r\n            a_list.append(i[0])\r\n        return a_list\r\n```\r\næ—¶é—´å¤æ‚åº¦:$O()$\r\nç©ºé—´å¤æ‚åº¦:$O(n)$\r\n* æ—¶é—´å¤æ‚åº¦ä¸ä¼šè®¡ç®—ï¼Œå› ä¸ºæ¶‰åŠåˆ°sortedçš„æ—¶é—´å¤æ‚åº¦ï¼Œå¦‚æœsortedæ—¶é—´å¤æ‚åº¦æ˜¯$nlog$çš„è¯ï¼Œé‚£è¿™é“é¢˜çš„æ—¶é—´å¤æ‚åº¦å°±æ˜¯$nlog$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204927229","body":"# day21\r\n---\r\n## ä½¿ç”¨è¯­è¨€ï¼š python\r\n---\r\n> åšé¢˜æ—¶é—´ï¼š 1h\r\n```python\r\nfrom collections import defaultdict\r\nfrom typing import List\r\n\r\nclass Solution:\r\n    def calc_distance(self, list1, list2):\r\n        return (list1[0] - list2[0]) ** 2 + (list1[1] - list2[1]) ** 2\r\n\r\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\r\n        ans = 0\r\n        for list1 in points:\r\n            cnt = defaultdict(int)\r\n            for list2 in points:\r\n                dis = self.calc_distance(list1, list2)\r\n                cnt[dis] += 1\r\n            for i in cnt.values():\r\n                ans += i * (i - 1)\r\n        return ans\r\n```\r\næ—¶é—´å¤æ‚åº¦ï¼š$O(n^2)$\r\nç©ºé—´å¤æ‚åº¦ï¼š$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206600304","body":"# day22\r\n---\r\n## ä½¿ç”¨è¯­è¨€ï¼š python\r\n---\r\n> åšé¢˜æ—¶é—´:41min\r\n> åšé¢˜ç»è¿‡ï¼šæ€è€ƒé—®é¢˜ä¹‹åå‘ç°è‡ªå·±å¹¶æ²¡æœ‰æ¸…æ™°çš„æ€è·¯ï¼Œå°±ç¿»çœ‹åˆ«äººçš„é¢˜è§£\r\n> ä¹‹åç”¨è‡ªå·±çš„pythonç†è§£çš„å†™äº†ä¸€ä¸‹\r\n---\r\n```python\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        res = 0\r\n        len_s  = len(s)\r\n        left, right = 0, 0\r\n        windows = {}\r\n        while right < len_s:\r\n            char = s[right]\r\n            right += 1\r\n            if char in windows.keys():\r\n                windows[char] += 1\r\n            else:\r\n                windows[char] = 1\r\n\r\n            while windows[char] > 1:\r\n                w_char = s[left]\r\n                left += 1\r\n                windows[w_char] -= 1\r\n\r\n            res = max(res, right - left)\r\n        return res\r\n```\r\n\r\næ—¶é—´å¤æ‚åº¦:$O(n)$\r\nç©ºé—´å¤æ‚åº¦:$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207238004","body":"```python\r\nclass Solution:\r\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\r\n        flag = True\r\n        a_list = []\r\n        len_words = len(words)\r\n        len_words_let = len(words[0])\r\n        s_len = len(s)\r\n        words_dict = {}\r\n        win_dict = {}\r\n        if len_words == 0:\r\n            return None\r\n        for word in words:\r\n            words_dict[word] = words_dict.get(word, 0) + 1\r\n\r\n        left, right = 0, 0\r\n        while right < s_len:\r\n\r\n            char = s[right]\r\n            win_dict[char] = win_dict.get(char, 0) + 1\r\n            right += 1\r\n\r\n            if char not in words_dict.keys() or win_dict[char] > words_dict[char]:\r\n                left += 1\r\n\r\n            for i in words_dict.keys():\r\n                if win_dict[i] == words_dict[i]:\r\n                    flag = True\r\n                else:\r\n                    flag = False\r\n                    break\r\n            if flag:\r\n                a_list.append(left)\r\n\r\n        return a_list\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1208240656","body":"# day24\r\n---\r\n## ä½¿ç”¨è¯­è¨€ï¼špython\r\n---\r\n> åšé¢˜æƒ…å†µï¼šä¸ä¼šåšï¼Œå­¦ä¹ äº†å‚è€ƒç­”æ¡ˆçš„åšæ³•åšå‡ºè¿™é“é¢˜\r\n> é€šè¿‡è¿™é“é¢˜å­¦ä¼šäº†ä¸¤ä¸ªçŸ¥è¯†ç‚¹\r\n> * å‰ç¼€å’Œï¼šç±»ä¼¼äºæ•°ç»„çš„å‰né¡¹å’Œçš„æ¦‚å¿µ\r\n> * åŒä½™å®šç†ï¼šä¸¤é¡¹åšå·®ä½™æ•°ä¸º0ï¼Œå°±æ„å‘³ç€è¿™ä¸¤ä¸ªçš„ä½™æ•°ç›¸åŒã€‚\r\n\r\n> è¿˜å¼ºåŒ–äº†ä¸€ä¸ªæ¦‚å¿µï¼šæ¶‰åŠåˆ°æŸ¥æ‰¾çš„é¢˜ï¼Œå¯ä»¥è€ƒè™‘ä¸€ä¸‹å“ˆå¸ŒæŸ¥æ‰¾æ³•\r\n```python\r\nclass Solution:\r\n\r\n    def solve(self, nums, k):\r\n        tar_remainder = (sum(nums)+k) % k\r\n        if tar_remainder == 0:\r\n            return 0\r\n        n, presum = len(nums), 0\r\n\r\n        res = n\r\n        a_dict = {}\r\n        for index, value in enumerate(nums):\r\n\r\n            presum += value\r\n            endindex = (presum+k) % k\r\n            a_dict[endindex] = index\r\n            preindex = (endindex - tar_remainder + k) % k\r\n            if preindex in a_dict:\r\n                res = min(res, index - a_dict[preindex])\r\n\r\n        return res if res < n else -1\r\n\r\n\r\n\r\n\r\n\r\n```\r\næ—¶é—´å¤æ‚åº¦:$O(n)$\r\nç©ºé—´å¤æ‚åº¦:$O(n)$","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208271097","body":"# day25\r\n---\r\n## ä½¿ç”¨è¯­è¨€ï¼špython\r\n---\r\n> ä¸çŸ¥é“åº”è¯¥ä½¿ç”¨å“ªä¸ªæ•°æ®ä¸ç®—æ³•çš„æŠ€å·§\r\n\r\n```python\r\nclass Solution:\r\n    def middleNode(self, head: ListNode) -> ListNode:\r\n\r\n        if not head:\r\n            return None\r\n\r\n        num = 0\r\n        temp_head = head\r\n        while temp_head:\r\n            num += 1\r\n            temp_head = temp_head.next\r\n\r\n        mid_index = num // 2\r\n\r\n        for i in range(mid_index):\r\n            head = head.next\r\n\r\n        return head\r\n```\r\næ—¶é—´å¤æ‚åº¦:$O(n)$\r\nç©ºé—´å¤æ‚åº¦:$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208843778","body":"# day26\r\n---\r\n## ä½¿ç”¨è¯­è¨€ï¼špython\r\n---\r\n> å¦™å•Šï¼Œè‡ªå·±æœ¬æ¥æƒ³ç”¨countæ¥å†™ï¼Œåæ¥çœ‹åˆ°æ ‡é¢˜æ˜¯å¿«æ…¢æŒ‡é’ˆï¼Œå°±ç”¨äº†ä¸‹å¿«æ…¢æŒ‡é’ˆï¼Œæ²¡æƒ³åˆ°å¿«æ…¢æŒ‡é’ˆè¿˜æœ‰è¿™æ ·çš„æ•ˆæœã€‚\r\n```python\r\nfrom typing import List\r\n\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        len_nums = len(nums)\r\n        temp_len_nums = len_nums\r\n        if len_nums < 2:\r\n            return len_nums\r\n        first, last = 1, 0\r\n        while first < temp_len_nums:\r\n            if nums[first] == nums[last]:\r\n                del nums[first]\r\n                temp_len_nums -= 1\r\n            else:\r\n                first += 1\r\n                last += 1\r\n\r\n        return temp_len_nums\r\n```\r\næ—¶é—´å¤æ‚åº¦:$O(n)$\r\nç©ºé—´å¤æ‚åº¦:$O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxoojs":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1198826774","body":"## ä»£ç \r\n```\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n*/\r\nvar addToArrayForm = function(num, k) {\r\n    k += '';\r\n    let nLen = num.length,\r\n        kLen = k.length,\r\n        len = Math.max(nLen, kLen);\r\n    \r\n    if (len === kLen) {\r\n        num = [...new Array(len - nLen).fill(0), ...num];\r\n    } else {\r\n        k = k.padStart(len, '0');\r\n    }\r\n\r\n    let left = 0;\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        let sum = (num[i] || 0) + (Number(k[i]) || 0) + left;\r\n        if (sum >= 10) {\r\n            sum -= 10;\r\n            left = 1;\r\n        } else {\r\n            left = 0;\r\n        }\r\n\r\n        num[i] = sum;\r\n    }\r\n\r\n    if (left > 0) {\r\n        num.unshift(1);\r\n    }\r\n\r\n    return num;\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186160050","body":"## ä»£ç \n---\n```\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n*/\nvar shortestToChar = function(s, c) {\n    let len = s.length,\n        answer = new Array(len),\n        i = 0,\n        pre = -Infinity;\n\n    while (i < len) {\n        if (s[i] === c) {\n            answer[i] = 0;\n            pre = i;\n        } else {\n            let nextIdx = s.indexOf(c, i);\n            if (~nextIdx) {\n                while (i <= nextIdx) {\n                    answer[i] = Math.min(i - pre, nextIdx - i);\n                    ++i;\n                }\n                --i;\n                pre = i;\n            } else {\n                answer[i] = i - pre;\n            }\n        }\n        ++i;\n    }\n\n    return answer;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186441698","body":"## ä»£ç \n---\n```\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.stack.length < this.maxSize) {\n        this.stack.push(x);\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (this.stack.length) {\n        return this.stack.pop();\n    }\n    return -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    const max = Math.min(this.stack.length, k);\n    for (let i = 0; i < max; i++) {\n        this.stack[i] += val;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186722440","body":"## ä»£ç \n---\n```\n/**\n * @param {string} s\n * @return {string}\n*/\nconst numReg = /[0-9]/;\nconst charReg = /[a-z]/;\nvar decodeString = function(s) {\n    let i = 0,\n        len = s.length,\n        stack = [],\n        times = '',\n        ret = '';\n    while (i < len) {\n        const char = s[i];\n        if (charReg.test(char)) {\n            const last = stack[stack.length - 1];\n            if (last) {\n                last.letters += char;\n            } else {\n                ret += char;\n            }\n        }\n        if (numReg.test(char)) {\n            times += char;\n        }\n        if (char === '[') {\n            stack.push({\n                times,\n                letters: ''\n            });\n            times = '';\n        }\n        if (char === ']') {\n            let fragment = stack.pop();\n            let _times = Number(fragment.times) || 1;\n            fragment = fragment.letters.repeat(_times);\n\n            const last = stack[stack.length - 1];\n            if (last) {\n                last.letters += fragment;\n            } else {\n                ret += fragment;\n            }\n        }\n        ++i;\n    }\n    return ret;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188769819","body":"## ä»£ç  \r\n---\r\n```\r\nvar MyQueue = function() {\r\n    this.queue = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    return this.queue.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    return this.queue.shift();\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.queue[0];\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.queue.length <= 0;\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189903866","body":"## ä»£ç \n---\n```\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    let stack = [];\n    for (let i = 0; i < arr.length; i++) {\n        const cur = arr[i];\n        const top = stack[stack.length - 1];\n        if (!stack.length || cur >= top) {\n            stack.push(cur);\n        } else if (cur < top) {\n            while (stack.length && cur < stack[stack.length - 1]) {\n                stack.pop();\n            }\n            stack.push(top);\n        }\n    }\n    return stack.length;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191084844","body":"## ä»£ç \n---\n```\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n*/\nvar rotateRight = function(head, k) {\n    if (!head || !k) return head;\n    let nodes = [];\n\n    while (head) {\n        nodes.push(head);\n        let prev = head;\n        head = head.next;\n        if (head) {\n            head.prev = prev;\n        }\n    }\n    const len = nodes.length;\n    let idx = (len - k % len) % len;\n    \n    const node = nodes[idx];\n    if (node.prev) {\n        node.prev.next = null;\n        nodes[len - 1].next = nodes[0];\n    }\n    \n    return node;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192135949","body":"## ä»£ç \n---\n```\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n*/\nvar swapPairs = function(head) {\n    let slow = head, fast = head?.next;\n    head = fast || slow;\n\n    let prev = null;\n    while (slow && fast) {\n        const next = fast.next;\n        // ç»´æŠ¤ä¸¤ä¸ªèŠ‚ç‚¹\n        slow.next = null;\n        fast.next = slow;\n\n        if (prev) {\n            prev.next = fast;\n        }\n\n        prev = slow;\n        slow = next;\n        fast = next?.next;\n    }\n\n    if (slow && !fast && prev) {\n        prev.next = slow;\n    }\n\n    return head;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193129263","body":"## ä»£ç \n---\n```\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n*/\nvar transferSortedArrayToTreeNode = (nodes) => {\n    if (!nodes || !nodes.length) return null;\n    let midIdx = nodes.length >> 1;\n    let midNode = new TreeNode(nodes[midIdx]);\n\n    const leftNodes = nodes.slice(0, midIdx);\n    const rightNodes = nodes.slice(midIdx + 1);\n\n    midNode.left = transferSortedArrayToTreeNode(leftNodes);\n    midNode.right = transferSortedArrayToTreeNode(rightNodes);\n\n    return midNode;\n}\nvar sortedListToBST = function(head) {\n    let nodes = [];\n    while (head) {\n        nodes.push(head.val);\n        head = head.next;\n    }\n    return transferSortedArrayToTreeNode(nodes);\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193316305","body":"## ä»£ç \n---\n```\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n*/\nvar getIntersectionNode = function(headA, headB) {\n    while (headA || headB) {\n        if (headA) {\n            if (headA?.isPassed) {\n                return headA;\n            }\n            headA.isPassed = true;\n            headA = headA?.next;\n        }\n        if (headB) {\n            if (headB?.isPassed) {\n                return headB;\n            }\n            headB.isPassed = true;\n            headB = headB?.next;\n        }\n    }\n    return null;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193503642","body":"## ä»£ç \r\n---\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n    while (head) {\r\n        if (head.isPassed) {\r\n            return head\r\n        }\r\n        head.isPassed = true;\r\n        head = head.next;\r\n    }\r\n    return head;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1196403619","body":"## ä»£ç \r\n```\r\n/**\r\n * @param {number} capacity\r\n*/\r\nvar LRUCache = function(capacity) {\r\n    this.cache = [];\r\n    this.capacity = capacity;\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n    let index = this.find(key);\r\n    if (~index) {\r\n        const item = this.cache.splice(index, 1)[0];\r\n        this.cache.push(item);\r\n        index = item.value;\r\n    }\r\n    return index;\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.find = function(key) {\r\n    return this.cache.findIndex(item => item.key === key);\r\n}\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n    const index = this.find(key);\r\n    if (~index) {\r\n        const item = this.cache.splice(index, 1)[0];\r\n        this.cache.push(item);\r\n        item.value = value;\r\n    } else {\r\n        if (this.cache.length === this.capacity) {\r\n            this.cache.shift();\r\n        }\r\n        this.cache.push({ key, value });\r\n    }\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * var obj = new LRUCache(capacity)\r\n * var param_1 = obj.get(key)\r\n * obj.put(key,value)\r\n */\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196202020","body":"## ä»£ç \r\n---\r\n```\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n*/\r\nvar maxDepth = function(root) {\r\n    let dep = 0;\r\n    if (!root) return dep;\r\n    let length, stack = [root];\r\n    while (length = stack.length) {\r\n        let i = 0;\r\n        while (i < length) {\r\n            const node = stack.shift();\r\n            node?.left && stack.push(node.left);\r\n            node?.right && stack.push(node.right);\r\n            ++i;\r\n        }\r\n\r\n        dep++;\r\n    }\r\n\r\n    return dep;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197738554","body":"## ä»£ç \n```\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n*/\nvar isSameTree = function(p, q) {\n    if ((p && !q) || (!p && q)) return false;\n    if (!p && !q) return true;\n    return p?.val === q?.val && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right);\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198826395","body":"## ä»£ç \n```\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n*/\nvar sumNumbers = function(root) {\n    let sum = 0;\n    function traverse (node, num) {\n        if (!node) return;\n\n        num += node.val;\n        if (!node.left && !node.right) {\n            sum += Number(num);\n        } else {\n            traverse(node.left, num);\n            traverse(node.right, num);\n        }\n    }\n    traverse(root, '');\n\n    return sum;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200077096","body":"## æ€è·¯\nå±‚åºéå†\n## ä»£ç \n```\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n*/\nvar findBottomLeftValue = function(root) {\n    let len,\n        stack = [root];\n    while (len = stack.length) {\n        let firstNode = null;\n        for (let i = 0; i < len; i++) {\n            let node = stack.shift();\n            if (!firstNode) {\n                firstNode = node;\n            }\n            node?.left && stack.push(node?.left);\n            node?.right && stack.push(node?.right);\n        }\n        if (stack.length === 0) {\n            return firstNode?.val;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200341698","body":"## ä»£ç \n```\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n*/\nvar serialize = function(root) {\n    return JSON.stringify(root);\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n*/\nvar deserialize = function(data) {\n    return JSON.parse(data);\n};\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201313622","body":"## ä»£ç \n```\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar verticalTraversal = function(root) {\n    let minCol = 0, maxCol = 0, map = {};\n    function traverse (node, row, col) {\n        if (!node) return;\n        if (col < minCol) {\n            minCol = col;\n        }\n        if (col > maxCol) {\n            maxCol = col;\n        }\n        if (!map[col]) {\n            map[col] = {};\n        }\n        if (!map[col][row]) {\n            map[col][row] = [];\n        }\n        map[col][row].push(node.val);\n        traverse(node.left, row + 1, col - 1);\n        traverse(node.right, row + 1, col + 1);\n    }\n    traverse(root, 0, 0);\n\n    let ret = [];\n    for (let i = minCol; i <= maxCol; i++) {\n        const rows = Object.keys(map[i]);\n        let nums = [];\n        for (let row of rows) {\n            nums = [...nums, ...map[i][row].sort((a, b) => a - b)];\n        }\n        ret.push(nums);\n    }\n    return ret;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201966047","body":"## ä»£ç \n```\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n*/\nvar twoSum = function(nums, target) {\n    const map = new Map();\n    for (let i = 0, len = nums.length; i < len; i++) {\n        if (map.has(target - nums[i])) {\n            return [map.get(target - nums[i]), i]\n        }\n        map.set(nums[i], i)\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203436059","body":"## ä»£ç \n```\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n*/\nvar topKFrequent = function(nums, k) {\n    let map = new Map();\n    for (let num of nums) {\n        map.set(num, (map.has(num) ? map.get(num) : 0) + 1);\n    }\n    \n    return Array.from(map.entries()).sort((a, b) => b[1] - a[1]).map(item => item[0]).slice(0, k);\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204803511","body":"## ä»£ç \n```\n\n/**\n * @param {number[][]} points\n * @return {number}\n*/\nconst distance = (a, b) => Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2));\nvar numberOfBoomerangs = function(points) {\n    let len = points.length, ret = 0;\n    for (let i = 0; i < len; i++) {\n        for (let j = 0; j < len; j++) {\n            for (let k = 0; k < len; k++) {\n                if (i !== j && j !== k && i !== k) {\n                    if (distance(points[i], points[j]) === distance(points[j], points[k])) {\n                        ret += 1;\n                    }\n                }\n            }\n        }\n    }\n    return ret;\n};\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206227480","body":"## ä»£ç \n```\n/**\n * @param {string} s\n * @return {number}\n*/\nvar lengthOfLongestSubstring = function(s) {\n    let i = 0, len = s.length, fragment = '', ret = 0;\n    while (i < len) {\n        const char = s[i];\n        const index = fragment.indexOf(char);\n        if (~index) {\n            fragment = fragment.slice(index + 1) + char;\n        } else {\n            fragment += char;\n            const length = fragment.length;\n            if (length > ret) {\n                ret = length;\n            }\n        }\n        ++i;\n    }\n    return ret;\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1209275175","body":"## ä»£ç \r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar middleNode = function(head) {\r\n    const nodes = [];\r\n    while (head) {\r\n        nodes.push(head);\r\n        head = head.next;\r\n    }\r\n\r\n    return nodes[nodes.length >> 1];\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209263238","body":"## ä»£ç \n\n```\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    const map = {};\n    let i = 0,\n        len = nums.length;\n    while (i < len) {\n        const item = nums.pop();\n        if (!map[item]) {\n            map[item] = true;\n            nums.unshift(item);\n        }\n        ++i;\n    }\n    return nums.length;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"okkband":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1186183254","body":"```CPP\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int n = num.size();\r\n        vector<int> res;\r\n        for(int i=n-1; i>=0; i--){\r\n            int sum = num[i]  + k % 10;\r\n            k = k / 10;\r\n            if (sum >= 10){\r\n                k++;\r\n            }\r\n            res.push_back(sum % 10);\r\n        }\r\n        for(;k>0; k/=10){\r\n            res.push_back(k%10);\r\n        }\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n#### æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n#### ç©ºé—´å¤æ‚åº¦ï¼š O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186169287","body":"```CPP\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.size();\r\n        vector<int> ret;\r\n        int pre_idx = -10000;\r\n        for(int i=0; i<n; i++){\r\n            if (s[i] == c){\r\n                pre_idx = i;\r\n            }\r\n            ret.push_back(i - pre_idx);\r\n        }\r\n        pre_idx = 10001;\r\n        for (int i=n-1; i>=0; i--){\r\n            if (s[i] == c){\r\n                pre_idx = i;\r\n            }\r\n            ret[i] = min(pre_idx - i, ret[i]);\r\n        }\r\n        return ret;\r\n    }\r\n};\r\n```\r\n### æ—¶é—´å¤æ‚åº¦ï¼šO(N);\r\n### ç©ºé—´å¤æ‚åº¦ï¼šO(1);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186270513","body":"```CPP\r\nclass CustomStack {\r\npublic:\r\n    vector<int> stk;\r\n    vector<int> add;\r\n    int top;\r\n    CustomStack(int maxSize) {\r\n        stk.resize(maxSize);\r\n        add = vector<int> (maxSize, 0);\r\n        top = -1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (top!=stk.size()-1){\r\n            top++;\r\n            stk[top] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (top == -1){\r\n            return -1;\r\n        } \r\n        int ret = stk[top] + add[top];\r\n        if (top != 0){\r\n            add[top-1] += add[top];\r\n        }\r\n        add[top] = 0;\r\n        top--;\r\n        return ret;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int num = min(k-1, top);\r\n        if (num >= 0){\r\n            add[num] += val;\r\n        }\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186601192","body":"```CPP\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string res = \"\";\r\n        int n = s.size();\r\n        int count = 0;\r\n        stack<int> nums;\r\n        stack<string> str_stk;\r\n        for(int i=0;i<n; i++){\r\n            char ch = s[i];\r\n            if (ch >= '0' && ch <= '9'){\r\n                count = count * 10 + (ch - '0');\r\n            } else if (ch == '['){\r\n                nums.push(count);\r\n                str_stk.push(res);\r\n                count = 0;\r\n                res = \"\";\r\n            } else if (ch == ']'){\r\n                for(int j=0; j<nums.top(); j++){\r\n                    str_stk.top() += res;\r\n                }\r\n                nums.pop();\r\n                res = str_stk.top();\r\n                str_stk.pop();\r\n            } else {\r\n                res += ch;\r\n            }\r\n        }\r\n        return res;\r\n\r\n    }\r\n};\r\n```\r\næ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\nç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189024707","body":"```CPP\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> inStack, outStack;\r\n    void in2out(){\r\n        while(!inStack.empty()){\r\n            outStack.push(inStack.top());\r\n            inStack.pop();\r\n        }\r\n    }\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        if (outStack.empty()){\r\n            in2out();\r\n        }\r\n        int x = outStack.top();\r\n        outStack.pop();\r\n        return x;\r\n        \r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        if (outStack.empty()){\r\n            in2out();\r\n        }\r\n        return outStack.top();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return (outStack.empty() && inStack.empty());\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193115529","body":"```CPP\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int len_list(ListNode* head){\r\n        int len = 0;\r\n        while(head!=nullptr){\r\n            len++;\r\n            head = head->next;\r\n        }\r\n        return len;\r\n    }\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        TreeNode* ret = construct_tree(head, 0, len_list(head));\r\n        return ret;\r\n    }\r\n    TreeNode* construct_tree(ListNode*& node, int start, int end){\r\n        if (end <= start) return nullptr;\r\n        int mid = start + (end - start) / 2;\r\n        TreeNode* root = new TreeNode();\r\n        root->left = construct_tree(node, start, mid);\r\n        root->val = node->val;\r\n        node = node->next;\r\n        root->right = construct_tree(node, mid+1, end);\r\n        return root;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wyz999":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186177862","body":"### æ€è·¯\r\nå…ˆä»å·¦åˆ°å³éå†ï¼Œè®°å½•å·¦ä¾§åˆ°æœ€è¿‘cçš„è·ç¦»\r\n\r\nä»å³åˆ°å·¦ï¼Œ1ï¼Œè®°å½•ä»å³ä¾§åˆ°æœ€è¿‘cçš„è·ç¦»,2ï¼Œæ¯”è¾ƒä¸¤ä¸ªè·ç¦»ï¼Œå–æœ€å°å€¼\r\n\r\n### ä»£ç \r\n\r\n```golang\r\nfunc shortestToChar(s string, c byte) []int {\r\n    n:=len(s)\r\n    num :=make([]int, n)\r\n    idx:=-n\r\n    // ä»å·¦åˆ°å³\r\n  for k,v:=range s{\r\n      if byte(v)==c{\r\n        idx=k\r\n      }\r\n    num[k]=k-idx\r\n  }\r\n    // ä»å³åˆ°å·¦\r\n   idx=2*n\r\n  for i:=n-1;i>=0;i--{\r\n    if  s[i]== c{\r\n      idx=i\r\n    }\r\n    num[i]=min(num[i],idx-i)\r\n  }\r\n  return num\r\n}\r\n\r\nfunc min(a,b int) int{\r\n  if a>b {\r\n    return b\r\n  }\r\n  return a\r\n}\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186396294","body":"### æ€è·¯\r\nç”¨åˆ‡ç‰‡æ¨¡æ‹Ÿæ ˆæ“ä½œ\r\n\r\n### ä»£ç \r\n```golang\r\n\r\ntype CustomStack struct {\r\n    maxSize int\r\n    stackLen int\r\n    val []int\r\n}\r\n\r\n\r\nfunc Constructor(maxSize int) CustomStack {\r\n    var num []int\r\n    customStack:=CustomStack{\r\n        maxSize: maxSize,\r\n        stackLen: 0,\r\n        val: num,\r\n    }\r\n    return  customStack\r\n    \r\n}\r\n\r\n\r\nfunc (this *CustomStack) Push(x int)  {\r\n    if this.maxSize>this.stackLen{\r\n        // this.val[this.stackLen]=x\r\n      this.val= append(this.val,x)\r\n        this.stackLen++\r\n    }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Pop() int {\r\n    if this.stackLen==0{\r\n        return -1\r\n    }\r\n    last:=this.val[this.stackLen-1]\r\n    this.val=this.val[:this.stackLen-1]\r\n     this.stackLen--\r\n    return last\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Increment(k int, val int)  {\r\n    if k>=this.stackLen{\r\n        k=this.stackLen\r\n    }\r\n    for i:=0;i<k;i++{\r\n        this.val[i]+=val\r\n    }\r\n}\r\n\r\n```\r\n### æ—¶ç©ºå¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦: push,pop ä¸ºO(1)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(k)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189224374","body":"## æ€è·¯\r\nä½¿ç”¨åŒæ ˆï¼Œæ¨¡æ‹Ÿé˜Ÿåˆ—å¢åˆ æ”¹\r\n\r\n## ä»£ç \r\n\r\n```golang\r\ngolang\r\n\r\ntype MyQueue struct {\r\n     inStack ,outStack []int\r\n}\r\n\r\n\r\nfunc Constructor() MyQueue {\r\n    return MyQueue{}\r\n}\r\n\r\n\r\nfunc (this *MyQueue) Push(x int)  {\r\n    this.inStack =append(this.inStack,x)\r\n}\r\n\r\nfunc (this *MyQueue)inToOut(){\r\n    for len(this.inStack)>0{\r\n        this.outStack = append(this.outStack,this.inStack[len(this.inStack)-1])\r\n        this.inStack = this.inStack[:len(this.inStack)-1]\r\n    }\r\n}\r\n\r\nfunc (this *MyQueue) Pop() int {\r\n    if len(this.outStack)==0{\r\n        this.inToOut()\r\n    }\r\n    op := this.outStack[len(this.outStack)-1]\r\n    this.outStack = this.outStack[:len(this.outStack)-1]\r\n    return op\r\n}\r\n\r\n\r\nfunc (this *MyQueue) Peek() int {\r\n    if len(this.outStack)==0{\r\n        this.inToOut()\r\n    }\r\n    return this.outStack[len(this.outStack)-1]\r\n}\r\n\r\n\r\nfunc (this *MyQueue) Empty() bool {\r\n   return len(this.outStack)==0&&len(this.inStack)==0\r\n}\r\n\r\n\r\n```\r\n\r\n## æ—¶ç©ºå¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ï¼š O(1)\r\n- ç©ºé—´å¤æ‚åº¦ï¼š O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192618445","body":"### æ€è·¯\r\n\r\né€’å½’èŠ‚ç‚¹ï¼Œäº®äº®äº¤æ¢\r\n\r\n### ä»£ç \r\n ```golang\r\ngolang\r\n\r\nfunc swapPairs(head *ListNode) *ListNode {\r\n    if head==nil||head.Next==nil{\r\n        return head\r\n    }\r\n    nextNode := head.Next\r\n    head.Next = swapPairs(nextNode.Next)\r\n    nextNode.Next = head\r\n    return nextNode\r\n\r\n}\r\n\r\n```\r\n### æ—¶ç©ºå¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n- ç©ºé—´å¤æ‚åº¦; O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193281130","body":"### æ€è·¯\r\néå†é“¾è¡¨Aï¼Œä½¿ç”¨å“ˆå¸Œå­˜å‚¨ã€‚éå†é“¾è¡¨Bï¼ŒæŸ¥è¯¢å“ˆå¸Œè¡¨ä¸­æ˜¯å¦å­˜åœ¨\r\n\r\n### ä»£ç \r\n```\r\ngolang\r\n\r\n\r\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\r\n    var nodeMap = make(map[*ListNode]int)\r\n    for temp:=headA;temp!=nil;temp=temp.Next {\r\n        nodeMap[temp] = 1\r\n    } \r\n    for arg:=headB;arg!=nil;arg=arg.Next{\r\n        if nodeMap[arg]>0{\r\n            return arg\r\n        } \r\n    }\r\n    return nil\r\n}\r\n```\r\n\r\n### æ—¶ç©ºå¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦; O(n)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196558134","body":"### æ€è·¯\r\n\r\né‡‡ç”¨é€’å½’å‡ºæ ‘çš„æ·±åº¦\r\n\r\n###  ä»£ç \r\n\r\n```\r\ngolang\r\n\r\nfunc maxDepth(root *TreeNode) int {\r\n    if root!=nil{\r\n        left:=maxDepth(root.Left)\r\n        right:=maxDepth(root.Right)\r\n        nodeLen:=right\r\n        if left>right{\r\n            nodeLen=left\r\n        }\r\n        return  nodeLen+1\r\n    } else{\r\n        return 0\r\n    }\r\n}\r\n```\r\n### æ—¶ç©ºå¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(height)ï¼Œå…¶ä¸­ \\textit{height}height è¡¨ç¤ºäºŒå‰æ ‘çš„é«˜åº¦","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197721566","body":"### æ€è·¯\r\n\r\næ·±åº¦ä¼˜å…ˆæœç´¢\r\n\r\n### ä»£ç \r\n```\r\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\r\n    if p==nil&&q==nil{\r\n        return true\r\n    }\r\n    if p==nil||q==nil{\r\n        return false\r\n    }\r\n    if p.Val!=q.Val{\r\n        return false\r\n    } \r\n    return isSameTree(p.Left,q.Left)&&isSameTree(p.Right,q.Right)\r\n}\r\n```\r\n### æ—¶ç©ºå¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ï¼š  O(min(m,n))\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(min(m,n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199065486","body":"```\r\nfunc sumNumbers(root *TreeNode) int {\r\n   return dfs(root,0)\r\n}\r\n\r\nfunc dfs(root *TreeNode,prevSum int) int{\r\n    if root==nil{\r\n        return 0\r\n    }\r\n    sum := prevSum*10 + root.Val\r\n\r\n    if root.Left==nil&&root.Right==nil{\r\n        return sum\r\n    }\r\n\r\n    return dfs(root.Right,sum)+dfs(root.Left,sum)\r\n}\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202294738","body":"### æ€è·¯\r\nä½¿ç”¨å“ˆå¸Œè¡¨ï¼ŒæŸ¥æ‰¾å¯»æ‰¾ target - xï¼Œæ²¡æ‰¾åˆ°å°±æ’å…¥åˆ°å“ˆå¸Œè¡¨ä¸­\r\n\r\n### æ€è·¯\r\n```\r\nfunc twoSum(nums []int, target int) []int {\r\n   \r\n    var mapNums = map[int]int{}\r\n    for k,v := range nums{\r\n        if p,ok := mapNums[target-v];ok{\r\n            return []int{k,p}\r\n        }\r\n        mapNums[v]=k\r\n    }\r\n    return nil\r\n\r\n\r\n\r\n}\r\n\r\n```\r\n\r\n### æ—¶ç©ºå¤æ‚åº¦\r\n\r\n- æ—¶é—´å¤æ‚åº¦: O(n)\r\n-  ç©ºé—´å¤æ‚åº¦ï¼š O(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207431596","body":"```\r\nfunc solve(nums []int,k int) int {\r\n  numsLen := len(nums)\r\n  target := 0\r\n numsMap:=make(map[int]int)\r\n\r\n  for _,v := range nums{\r\n    target  = (target+v)%k\r\n  }\r\n  if target == 0{\r\n    return 0\r\n  }\r\n  numsMap[0] = 0\r\n  now,pos,ans:=0,0,numsLen\r\n  for _, v:= range nums{\r\n    pos++\r\n    now = (now+v)%k\r\n    if numsMap[(now+k-target)%k]>=0{\r\n      ans = min(ans,pos-numsMap[(now+k-target)%k])\r\n      numsMap[now] = pos\r\n    }\r\n  }\r\n  if ans == numsLen {\r\n    return -1\r\n  }\r\n  return ans\r\n}\r\n\r\nfunc min (a,b int) int {\r\n  if a>b{\r\n    return b\r\n  }\r\n  return a\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207598952","body":"### æ€è·¯\r\nä½¿ç”¨å¿«æ…¢æŒ‡é’ˆï¼Œå¿«çš„èµ°ä¸¤æ­¥ï¼Œæ…¢çš„èµ°ä¸€æ­¥\r\n\r\n### ä»£ç \r\n\r\n```\r\nfunc middleNode(head *ListNode) *ListNode {\r\n    if head==nil||head.Next==nil{\r\n        return head\r\n    }\r\n    fastNode := head\r\n    slowNode := head\r\n    for fastNode!=nil&&fastNode.Next!=nil{\r\n        fastNode = fastNode.Next.Next\r\n        slowNode = slowNode.Next\r\n    }\r\n    return slowNode\r\n\r\n}\r\n```\r\n\r\n### æ—¶ç©ºå¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ï¼š O(n)\r\n- ç©ºé—´å¤æ‚åº¦ï¼š O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208961087","body":"### æ€è·¯\r\n å¿«æ…¢æŒ‡é’ˆ\r\n\r\n### ä»£ç \r\n```\r\nfunc removeDuplicates(nums []int) int {\r\n    numsLun := len(nums)\r\n    if numsLun == 0{\r\n        return 0\r\n    }\r\n    slow := 1\r\n    for fast:=1;fast<numsLun;fast++{\r\n        if nums[fast]!=nums[fast-1]{\r\n            nums[slow] = nums[fast]\r\n            slow++\r\n        }\r\n    }\r\n    return slow\r\n}\r\n\r\n```\r\n###  æ—¶ç©ºå¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hacker90":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186181472","body":"class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.length();\n        vector<int> ans(n);\n\n        for (int i = 0, idx = -n; i < n; ++i) {\n            if (s[i] == c) {\n                idx = i;\n            }\n            ans[i] = i - idx;\n        }\n\n        for (int i = n - 1, idx = 2 * n; i >= 0; --i) {\n            if (s[i] == c) {\n                idx = i;\n            }\n            ans[i] = min(ans[i], idx - i);\n        }\n        return ans;\n    }\n};\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186481890","body":"class CustomStack {\npublic:\n    int cnt = 0;\n    int maxsize = 0;\n    vector<int> s;\n    CustomStack(int maxSize) {\n        maxsize = maxSize;\n        cnt = 0;\n    }\n    \n    void push(int x) {\n        if (cnt < maxsize ) {\n            s.push_back(x);\n            cnt++;\n        }\n    }\n    \n    int pop() {\n        if (cnt == 0)return -1;\n        int t = s[cnt-1];\n        s.pop_back();\n        cnt--;\n        return t;\n        \n    }\n    \n    void increment(int k, int val) {\n        if (cnt < k) k = cnt;\n        for (int i = 0;i < k;i++) {\n            s[i] += val;\n        }  \n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187515123","body":"class Solution {\npublic:\n    string decodeString(string s) {\n        int i = 0;\n        return decode(s, i);\n    }\n    string decode(string s, int& i) {\n        string res = \"\";\n        int n = s.size();\n        while (i < n && s[i] != ']') {\n            if (s[i] < '0' || s[i] > '9') {\n                res += s[i++];\n            } else {\n                int cnt = 0;\n                while (s[i] >= '0' && s[i] <= '9') {\n                    cnt = cnt * 10 + s[i++] - '0';\n                }\n                ++i;\n                string t = decode(s, i);\n                ++i;\n                while (cnt-- > 0) {\n                    res += t;\n                }\n            }\n        }\n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188974416","body":"class MyQueue {\npublic:\n    stack<int>out;\n    stack<int>in;\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        in.push(x);\n    }\n    \n    int pop() {\n        while (out.empty()) {\n            while (!in.empty()) {\n                int x = in.top();\n                in.pop();\n                out.push(x);\n            }\n        }\n        int t = out.top();\n        out.pop();\n        return t;\n    }\n    \n    int peek() {\n        int t = this->pop();\n        out.push(t);\n        return t;\n    }\n    \n    bool empty() {\n        return in.empty()&&out.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190400807","body":"var maxChunksToSorted = function (arr) {\n  let sum1 = 0;\n  let sum2 = 0;\n  let ans = 0;\n  let arr2 = [...arr].sort((a, b) => a - b);\n  for (let i in arr) {\n    sum1 = sum1 + arr[i];\n    sum2 = sum2 + arr2[i];\n    if (sum1 == sum2) {\n      ans += 1;\n      sum1 = 0;\n      sum2 = 0;\n    }\n  }\n  return ans;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191604619","body":"class Solution {\n public ListNode rotateRight(ListNode head, int k) {\n if(head == null || head.next == null) return head;\n int count = 0;\n ListNode now = head;\n while(now != null){\n now = now.next;\n count++;\n }\n k = k % count;\n ListNode slow = head, fast = head;\n while(fast.next != null){\n if(k-- <= 0){\n slow = slow.next;\n }\n fast = fast.next;\n }\n fast.next = head;\n ListNode res = slow.next;\n slow.next = null;\n return res;\n }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192158113","body":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == nullptr)return head;\n        ListNode* dumpHead = new ListNode(-1);\n        dumpHead->next = head;\n        ListNode* p1 = nullptr;\n        ListNode* p3 = nullptr;\n        ListNode* pcur = dumpHead;\n        while (pcur && pcur->next&& pcur->next->next) {\n            p3 = pcur->next->next->next;\n            p1 = pcur->next;\n            pcur->next = pcur->next->next;//1\n            pcur->next->next = p1;//2\n            pcur->next->next->next = p3;//3\n            pcur = pcur->next->next;\n        }\n        return dumpHead->next;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193129324","body":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* findM(ListNode* head) {\n        ListNode* pre = head, *slow = head,*fast = head->next;\n        while (fast && fast->next) {\n            pre = slow;\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n        return pre;\n    }\n    TreeNode* sortedListToBST(ListNode* head) {\n        if (head == nullptr)return nullptr;\n        if (head->next == nullptr) {\n            return new TreeNode(head->val);\n        }\n        ListNode* pre = findM(head);\n        ListNode* mid = pre->next;\n        pre->next = nullptr;\n        TreeNode* root = new TreeNode(mid->val);\n        root->left = sortedListToBST(head);\n        root->right = sortedListToBST(mid->next);\n        return root;\n    }\n};\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193226104","body":"\n\n\n\n\n\næ€è·¯ï¼šä¸¤æ¡è·¯å¾„éƒ½èµ°ä¸€æ¬¡çš„è·¯å¾„ç›¸åŒï¼Œå“ªæ€•ä¸¤ä¸ªè·¯å¾„ä¸ç›¸äº¤ï¼Œï¼ˆä¸ç›¸äº¤çš„ï¼Œæœ€ååˆ°NULL) \n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* pa = headA;\n        ListNode* pb = headB;\n        while (pa != pb) {\n            pa = (pa == NULL)?headB:pa->next;\n            pb = (pb == NULL)?headA:pb->next;\n        }\n        return pa;\n        \n    }\n};\næ—¶é—´å¤æ‚åº¦ï¼šO(M+N)\nç©ºéŸ³å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193582607","body":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *slow = head;\n        ListNode *fast = head;\n        while ( fast && fast->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n            if (slow == fast) {\n                ListNode* px = fast;\n                ListNode* py = head;\n                while (px != py) {\n                    py = py->next;\n                    px = px->next;\n                }\n                return px;\n            }\n        }\n        return nullptr;\n    }\n};\næ—¶é—´å¤æ‚åº¦ï¼šOï¼ˆnï¼‰\nç©ºé—´å¤æ‚åº¦ï¼šOï¼ˆ1ï¼‰","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196179033","body":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (root == nullptr)return 0;\n        int left = maxDepth(root->left);\n        int right = maxDepth(root->right);\n        return max(left,right)+1;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197493975","body":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (p == nullptr && q == nullptr) return true;\n        else if (p == nullptr && q)return false;\n        else if (p &&  q== nullptr)return false;\n        else if  (p->val != q->val) return false;\n        \n        bool left = isSameTree(p->left,q->left);\n        bool right = isSameTree(p->right,q->right);\n        return left && right;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199521978","body":"class Solution {\n    public int sumNumbers(TreeNode root) {\n        List<TreeNode> treeNodeList = new LinkedList<>();\n        int ans = 0;\n        treeNodeList.add(root);\n        while(treeNodeList.size()>0){\n            int len = treeNodeList.size();\n            for(int i=0;i<len;i++){\n                TreeNode temp = treeNodeList.remove(0);\n                if(temp.right ==null && temp.left==null){\n                    ans += temp.val;\n                }\n                if(temp.left!=null){\n                    temp.left.val += temp.val*10;\n                    treeNodeList.add(temp.left);\n                }\n                if(temp.right!=null){\n                    temp.right.val += temp.val*10;\n                    treeNodeList.add(temp.right);\n                }\n            }\n        }\n        return ans;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200103876","body":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int leftVal = 0;\n    int leftdep = INT_MIN;\n    void traversal(TreeNode* root,int left) {\n        if (root == nullptr)return ;\n        if (root->left == nullptr && root->right == nullptr) {\n            if (leftdep < left) {\n                leftdep = left;\n                leftVal = root->val;\n            }\n            return;\n        }\n        if (root->left)traversal(root->left,left+1);\n        if (root->right)traversal(root->right,left+1);\n        return ;\n    }\n    int findBottomLeftValue(TreeNode* root) {\n        // if (root == nullptr)return 0\n        traversal(root,0);\n        return leftVal;\n    }\n};\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200438418","body":"ç ï¼š\n\n\nclass Codec {\npublic:\n\n    // Encodes a tree to a single string.\n    void rserialize(TreeNode* root, string& str) {\n        // å‰åºéå†ï¼ˆä¸­å·¦å³ï¼Œé‡åˆ°ç©ºèŠ‚ç‚¹è¾“å…¥Noneï¼‰ï¼Œç”¨é€—å·éš”å¼€\n        if (root == NULL) str += \"None,\";\n        else {\n            str += to_string(root->val) + \",\";\n            rserialize(root->left, str);\n            rserialize(root->right, str);\n        }      \n    }\n    string serialize(TreeNode* root) {\n        string ret;\n        rserialize(root, ret);\n        return ret;\n    }\n\n    // Decodes your encoded data to tree.\n\n    TreeNode* rdeserialize(list<string>& dataArray) {\n        if(dataArray.front() == \"None\") {\n            dataArray.erase(dataArray.begin());\n            return NULL;\n        }\n        // å‰åºéå†ï¼ˆä¸­å·¦å³ï¼‰æ¢å¤æ ‘ç»“æ„\n        TreeNode* root = new TreeNode(stoi(dataArray.front()));\n        dataArray.erase(dataArray.begin());\n        root->left = rdeserialize(dataArray);\n        root->right = rdeserialize(dataArray);\n        return root;\n    }\n\n    TreeNode* deserialize(string data) {\n        list<string> dataArray;\n        string str;\n        // æ·»åŠ å„èŠ‚ç‚¹val\n        // æŒ‰å¼•ç”¨ä¼ é€’ï¼ŒæŒ‰å€¼ä¼ é€’ä¼šå¢åŠ è€—æ—¶\n        for (auto& c : data) {\n            if (c == ',') {\n                // ä»¥é€—å·ä½œä¸ºèŠ‚ç‚¹åˆ†å‰²\n                dataArray.push_back(str);\n                str.clear();\n            } else {\n                str.push_back(c);\n            }\n        }\n        // æ·»åŠ å°¾éƒ¨èŠ‚ç‚¹val\n        if (!str.empty()) {\n            dataArray.push_back(str);\n            str.clear();\n        }\n        return rdeserialize(dataArray);\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201217307","body":"class Solution {\npublic:\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        vector<tuple<int, int, int>> nodes;\n\n        function<void(TreeNode*, int, int)> dfs = [&](TreeNode* node, int row, int col) {\n            if (!node) {\n                return;\n            }\n            nodes.emplace_back(col, row, node->val);\n            dfs(node->left, row + 1, col - 1);\n            dfs(node->right, row + 1, col + 1);\n        };\n\n        dfs(root, 0, 0);\n        sort(nodes.begin(), nodes.end());\n        vector<vector<int>> ans;\n        int lastcol = INT_MIN;\n        for (const auto& [col, row, value]: nodes) {\n            if (col != lastcol) {\n                lastcol = col;\n                ans.emplace_back();\n            }\n            ans.back().push_back(value);\n        }\n        return ans;\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202605156","body":"class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int,int> map;\n        for (int i = 0;i< nums.size();i++) {\n            if (map.find(target-nums[i]) != map.end()) {\n                return {map[target-nums[i]],i};\n            }\n            map[nums[i]] = i;\n        }\n        return {};\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1204054018","body":"class Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        if(nums.length == 0) return nums;\n        Map<Integer,Integer> map = new HashMap<>();\n        for(int num : nums){\n            map.put(num,map.getOrDefault(num,0)+1);\n        }\n        Queue<Integer> heap = new PriorityQueue<>((n1,n2)->map.get(n1)-map.get(n2));\n        for(int key : map.keySet()){\n            heap.add(key);\n            if(heap.size()>k){\n                heap.poll();\n            }\n        }\n        int[] res = new int[k];\n        for(int i = k-1; i >=0; i--){\n            res[i] = heap.poll();\n        }\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205343961","body":"class Solution:\n    def distance(self, p1, p2):\n        return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2\n    \n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n <= 2:\n            return 0\n        result = 0\n        for p1 in points:\n            distances = collections.defaultdict(int)\n            \n            for p2 in points:\n                current_distance = self.distance(p1,p2)\n                distances[current_distance] += 1\n                \n            for value in distances.values():\n                result += value * (value - 1)\n        \n        return result\næ—¶é—´å¤æ‚åº¦ï¼šO(N^2)\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207231319","body":" from collections import Counter\n        from collections import defaultdict\n        c = Counter(words)\n        m = len(words)\n        n = len(words[0])\n        ret = []\n        total_length = m * n            \n   \n        #Loop over word length\n        for k in xrange(n):\n            left = k\n            subd = defaultdict(int)\n            count = 0\n            for j in xrange(k, len(s) - n + 1, n):\n                word = s[j:j+n]\n                if word in c:\n                    subd[word] += 1\n                    count += 1\n                    while subd[word] > c[word]:\n                        subd[s[left:left+n]] -= 1\n                        left += n\n                        count -= 1\n                    if count == m:\n                        ret.append(left)\n                else:\n                    left = j + n\n                    subd = defaultdict(int)\n                    count = 0\n        return ret","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207431263","body":"class Solution {\n    public int solve(int[] nums, int k) {\n        int total = 0;\n        for (int n : nums)\n            total += n;\n        total = Math.floorMod(total, k);\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, -1);\n        int prefix = 0, res = nums.length;\n        for (int i = 0; i < nums.length; i++) {\n            prefix += nums[i];\n            int mod = Math.floorMod(prefix, k);\n            map.put(mod, i);\n            if (map.containsKey(Math.floorMod(prefix - total, k)))\n                res = Math.min(res, i - map.get(Math.floorMod(prefix - total, k)));\n        }\n        return res == nums.length ? -1 : res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208252785","body":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        if (head == nullptr)return head;\n        ListNode* dumpHead = new ListNode();\n        dumpHead->next = head;\n        ListNode* fast = head;\n        ListNode* slow = head;\n        while (fast && fast->next != nullptr){\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n        return slow;\n\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209409024","body":"class Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        unsigned int l = 0;\n        unsigned int r = 0;\n        for (r = 0;r<nums.size();r++) {\n            if (nums[l] != nums[r]) {\n                nums[++l] = nums[r];\n            }\n\n        }\n        cout<<\"l:\"<<l<<endl;\n        return l+1;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ricjli":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186183393","body":"### Two times iteration:\n\niterate the string from left will calculate the distance to target `c` from the left. \n\niterate the string from right will calculate the distance to target `c` from the right. \n\nthen for each index, we have two lengths, then we can take the minimum value â€” this is the answer\n\n<aside>\nğŸ’¡ **Default value for the distance:** \nwe need to set default value to -n, so that in this case, at the first left iteration, when we didnâ€™t come across a target `character`. we can set the distance to `(i-n)` this is large enough for the second round iteration to overwrite it.\n\n</aside>\n\n<aside>\nğŸ’¡ **Optimization:**\n in the second round iteration. we can start from the first round latest target index, \nsince thereâ€™s no target occurred after this index.\n\n</aside>\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length(); \n        int targetIndex = -n; \n        int [] res = new int [n];\n        for(int i = 0; i< n; i++){\n            if(s.charAt(i) == c){\n                targetIndex = i;\n            }\n            res[i] =  i - targetIndex;\n        }\n        for(int i = targetIndex; i >= 0 ; i--){\n            if(s.charAt(i) == c){\n                targetIndex = i;\n            }\n            res[i] = Math.min(res[i], Math.abs(i - targetIndex));\n        }\n        return res;\n    }\n}\n```\n\n### Complexity Analysis:\n\nTime : O(n)\n\nspace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186525625","body":"class CustomStack {\n    int maxSize;\n    int pointer;\n    int [] stack;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        this.pointer = 0;\n        this.stack = new int [maxSize]; \n    }\n    \n    public void push(int x) {\n        if(pointer < maxSize){\n            stack[pointer] = x;\n            pointer ++;\n        } \n    }\n    \n    public int pop() {\n        if(pointer==0){\n            return -1;\n        }\n        int res = stack[pointer - 1];\n        pointer--;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        for(int i = 0; i < k && i < pointer; i++){\n            stack[i] += val;\n        }\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187583121","body":"### Simulation - 2 stacks\r\n\r\n```java\r\nclass Solution {\r\n\tpublic String decodeString(String s){\r\n\t\tStack<String> strStack = new Stack<>();\r\n\t\tStack<Integer> numStack = new Stack<>(); \r\n\t\tStringBuilder tail = new StringBuilder(); \r\n\t\t\r\n\t\tint len = s.length();\r\n\t\tfor(int i = 0; i <len; i++){\r\n\t\t\tchar c = s.chatAt(i);\r\n\t\t\tif(Character.isDigit(c)){\r\n\t\t\t\t // c - '0'  calculates the integer \r\n\t\t\t\tint num = c - '0';\r\n\t\t\t\twhile(i < len - 1 && Character.isDigit(s.charAt(i+1))){\r\n\t\t\t\t\tnum*= 10;\r\n\t\t\t\t\tnum += s.charAt(++i) - '0';\r\n\t\t\t\t}\r\n\t\t\t\tnumStack.push(num);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// save the last string \r\n\t\t\telse if (c == '['){\r\n\t\t\t\tstrStack.push(tail.toString());\r\n\t\t\t\ttail = new StringBuilder(); \r\n\t\t\t}\r\n\r\n\t\t\t// calculate the current string with the previous saving one\r\n\t\t\telse if (c == ']'){\r\n\t\t\t\tStringBuilder temp = new StringBuilder(); \r\n\t\t\t\ttemp.append(strStack.pop());\r\n\t\t\t\tint times = numStack.pop();\r\n\t\t\t\tfor(int i = 0; i < times; i++){\r\n\t\t\t\t\ttemp.append(tail);\r\n\t\t\t\t}\r\n\t\t\t\ttail = temp; \r\n\t\t\t}\r\n\t\t\t\r\n\t\t\telse {\r\n\t\t\t\ttail.append(c);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn tail.toString(); \r\n\t}\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188983886","body":"class MyQueue {\n    \n    Stack<Integer> inStack;\n    Stack<Integer> outStack;\n\n    public MyQueue() {\n        inStack = new Stack<>();\n        outStack = new Stack<>();\n    }\n    \n    public void push(int x) {\n        inStack.push(x);\n    }\n    \n    public int pop() {\n        if(outStack.isEmpty()){\n            while(!inStack.isEmpty()){\n                outStack.push(inStack.pop());\n            }\n        }\n        return outStack.pop();\n    }\n    \n    public int peek() {\n        if(outStack.isEmpty()){\n            while(!inStack.isEmpty()){\n                outStack.push(inStack.pop());\n            }\n        }\n        return outStack.peek();\n    }\n    \n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190364483","body":"### Double iteration\n\nFor each element, we can say, if all the elements at its right is greater than all the elements at its left, there will be a new trunk. Since in this way, we can sort the trunk w/o interrupting the original order. \n`[2,1,3,4,4]`\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int len = arr.length; \n        int [] leftMax = new int[len];\n        int [] rightMin = new int [len];\n\n        leftMax[0] = arr[0];\n        for(int i = 1; i<len; i++){\n            leftMax[i] = Math.max(leftMax[i-1], arr[i]);\n        }\n        rightMin[len-1] = arr[len-1];\n        for(int i = len-2; i >= 0; i--){\n            rightMin[i] = Math.min(rightMin[i+1], arr[i]); \n        }\n\n        int res = 0;\n        for (int i = 1; i<len; i++ ){\n            if(leftMax[i-1] <= rightMin[i]){\n                res++;\n            }\n        }\n        return res + 1;\n    }\n}\n```\n\n<aside>\nğŸ’¡ the final comparison cannot be `leftMax[i] â†’ rightMin[i]` \nshould be `leftMax[i] - rightMin[i+1]`\n\n</aside>","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191483576","body":"### Fast-Slow Pointers\n\n- First, get the length of the linked list. ( by iterating it with a counter)\n- Then, calculate the actual moving offset â€” `actualK`\n- then use fast/slow pointers to find out the place to break - reconnect\n- return the new linked list\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null) return null;\n        if(k == 0) return head;\n        int len = 0;\n        ListNode copy = head;\n        while(copy!=null){\n            copy= copy.next;\n            len++;\n        }\n        int actualK = k % len;\n        if(actualK == 0) return head;\n\n        ListNode fast = head; \n        ListNode slow = head;\n        while(fast.next != null){\n            fast = fast.next;\n            if(actualK>0){\n                actualK--;\n            } else {\n                slow = slow.next;\n            }\n        }\n        ListNode res = slow.next;\n        slow.next = null;\n        fast.next = head; \n\n        return res;\n    }\n}\n```\n\nComplexity: \n\nTime `O(n)`\nSpace `O(1)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192542870","body":"### Simulation:\n\nâ€” é“¾è¡¨é—®é¢˜ - åªè¦ä¸è¦åå•¬ç”¨æŒ‡é’ˆ, å¹¶ä¸”ç”»å›¾æ“ä½œ å°±æ²¡æœ‰é—®é¢˜!!! \n\nâ€” In order to swap a pair of nodes in a linked list, we need to get 4 pointers. \n    `prev`, `a`, `b`, `after`. After we got all the pointers, we just need to link them by the order. \n\n<aside>\nğŸ’¡ We should store the `dummy` head â†’ in order to return the swapped linked list.\n\n</aside>\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(-1, head);\n        ListNode ptr = dummy; \n        while(ptr.next != null && ptr.next.next != null){\n            \n            ListNode a = ptr.next;\n            ListNode b = ptr.next.next;\n            ListNode after = ptr.next.next.next; \n            ptr.next = b;\n            b.next = a;\n            a.next = after;\n\n            ptr = ptr.next.next;\n        }\n\n        return dummy.next; \n    }\n}\n```\n\n### Complexity:\n\nTime: O(n) \n\nSpace: O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194000817","body":"### Simulation - Fast / Slow pointers\r\n\r\n**Use two pointers  - fast and slow**  \r\n\r\n- fast moves 2 nodes per round, while slow moves 1 node per round.\r\n- when they meets. it proves that the linked list contains a cycle.\r\n- if fast touch the end (`fast == null || fast.next == null`) then proves the list doesnâ€™t contains a cycle.\r\n- after to pointers meet, put the fast pointer back to the head. move fast and slow one node forward on each round.\r\n- when they meet, it reaches the beginning of the cycle.\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if(head == null || head.next == null){\r\n            return null;\r\n        }\r\n        ListNode fast = head; \r\n        ListNode slow = head;\r\n        while(fast != null && fast.next != null){\r\n            fast = fast.next.next; \r\n            slow = slow.next;\r\n            if(fast == slow){\r\n                break;\r\n            }\r\n        }\r\n        if(fast != slow){\r\n            return null;\r\n        }\r\n        fast = head; \r\n        while(fast != slow){\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return fast; \r\n    }  \r\n}\r\n```\r\n\r\n### Complexity\r\n\r\ntime: O(n)\r\n\r\nspace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195439771","body":"### Simulation: Use a me-defined DoubleLinkedList and a hashmap\n\n```java\nclass LRUCache {\n    // use a hashmap to record the key-value pair (O(1) get)\n    // use a doubleLinkedList to do the put / resize in O(1) \n    class DListNode {\n        int val; \n        int key;\n        DListNode prev; \n        DListNode next;\n\n        public DListNode(){}\n\n        public DListNode(int key, int val){\n            this.key = key;\n            this.val = val;\n        }\n    }\n\n    private Map<Integer, DListNode> cache = new HashMap<>();\n    private int size; \n    private int capacity; \n    private DListNode head;\n    private DListNode tail;\n\n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity; \n        head = new DListNode();\n        tail = new DListNode();\n        head.next = tail; \n        tail.prev = head; \n    }\n\n    public void removeNode(DListNode cur){\n        cur.prev.next = cur.next;\n        cur.next.prev = cur.prev; \n    }\n\n    public void addToHead(DListNode cur){\n        cur.prev = head; \n        cur.next = head.next; \n        head.next.prev = cur;\n        head.next = cur; \n    }\n    \n    public void moveToHead(DListNode cur){\n        removeNode(cur);\n        addToHead(cur);\n    }\n\n    public DListNode removeTail(){\n        DListNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n\n    public int get(int key) {\n        DListNode node = cache.get(key);\n        if(node == null){\n            return -1; \n        }\n        moveToHead(node);\n        return node.val; \n    }\n\n    public void put(int key, int value) {\n        DListNode node = cache.get(key);\n        if(node == null){\n            DListNode cur = new DListNode(key, value);\n            cache.put(key, cur);\n            addToHead(cur);\n            size++; \n            if(size > capacity){\n                DListNode tail = removeTail();\n                cache.remove(tail.key);\n                size--;\n            }\n        } else {\n            node.val = value;\n            moveToHead(node);\n        }\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196670920","body":"### Recursion:\n\nFor a TreeNode, the height of itself =  max (left height , right height) + 1\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) return 0; \n        int leftDepth = maxDepth(root.left);\n        int rightDepth = maxDepth(root.right);\n        return Math.max(leftDepth, rightDepth) + 1; \n    }\n}\n```\n\n### No backtracking recursion\n\n```java\nclass Solution {\n    int maxDepth = 0;\n    public int maxDepth(TreeNode root) {\n        if(root == null) return maxDepth; \n        dfs(root, 1);\n        return maxDepth;\n    }\n\n    public void dfs(TreeNode root, int level){\n        if (root == null) return; \n        maxDepth = Math.max(maxDepth, level);\n        dfs(root.left, level+1);\n        dfs(root.right, level+1);\n    }\n}\n```\n\n### Complexity:\n\ntime: O(n)\n\nspace: O(log n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198143118","body":"```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null) return true;\n        if(p == null || q == null) return false;\n        boolean leftSame = isSameTree(p.left, q.left);\n        boolean rightSame = isSameTree(p.right, q.right);\n        boolean curSame = p.val == q.val;\n        return (leftSame && rightSame && curSame);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199243342","body":"### DFS  - Recursion\n\n```java\nclass Solution {\n    int res = 0; \n    public int sumNumbers(TreeNode root) {\n        dfsFindPathNumber(0, root);\n        return res;\n    }\n\n    public void dfsFindPathNumber(int num, TreeNode root){\n        if(root.left == null && root.right == null){\n            res += num*10 + root.val;\n            return;\n        }\n        if(root.left != null){\n            dfsFindPathNumber(num*10+root.val, root.left);\n        }\n        if(root.right != null){\n            dfsFindPathNumber(num*10+root.val, root.right);\n        }\n    }\n}\n```\n\nComplexity \n\nTime : O(n)\n\nSpace: O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201282147","body":"class Solution {\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<int[]> nodes = new ArrayList<int[]>();\n        dfs(root, 0, 0, nodes);\n        Collections.sort(nodes, new Comparator<int[]>() {\n            public int compare(int[] tuple1, int[] tuple2) {\n                if (tuple1[0] != tuple2[0]) {\n                    return tuple1[0] - tuple2[0];\n                } else if (tuple1[1] != tuple2[1]) {\n                    return tuple1[1] - tuple2[1];\n                } else {\n                    return tuple1[2] - tuple2[2];\n                }\n            }\n        });\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        int size = 0;\n        int lastcol = Integer.MIN_VALUE;\n        for (int[] tuple : nodes) {\n            int col = tuple[0], row = tuple[1], value = tuple[2];\n            if (col != lastcol) {\n                lastcol = col;\n                ans.add(new ArrayList<Integer>());\n                size++;\n            }\n            ans.get(size - 1).add(value);\n        }\n        return ans;\n    }\n\n    public void dfs(TreeNode node, int row, int col, List<int[]> nodes) {\n        if (node == null) {\n            return;\n        }\n        nodes.add(new int[]{col, row, node.val});\n        dfs(node.left, row + 1, col - 1, nodes);\n        dfs(node.right, row + 1, col + 1, nodes);\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202542480","body":"### HashMap\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        HashMap<Integer, Integer> map = new HashMap<>(); \n        int [] res = new int [2];\n        for(int i = 0; i < nums.length; i++){\n            map.put(nums[i], i);\n        }\n        for(int i = 0; i < nums.length; i++){\n            int difference = target - nums[i];\n            if(map.containsKey(difference) && map.get(difference) != i){\n                res[0] = i;\n                res[1] = map.get(difference);\n                break;\n            }\n        }\n        return res; \n    }\n}\n```\n\n2 loops â†’ slow. \n\nOptimization: \n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for( int i = 0 ; i< nums.length; i++){\n            int complement = target - nums[i];\n            if(map.containsKey(complement)){\n                return new int[]{i, map.get(complement)};\n            }\n            map.put(nums[i], i);\n        }\n        return null;\n    }\n}\n```\n\nuse single loop to complete the task â†’ \n`calculate â†’ check â†’ update map`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203966681","body":"ç»´æŠ¤å°é¡¶å † - size â‰¤ k  å½“ size æ¯” kå¤§æ—¶, å¼¹å‡ºå…ƒç´ , è¿™æ ·pqå†…åªæœ‰æœ€å¤§çš„Nä¸ªå…ƒç´ \n\n```java\nclass Solution{\n\tpublic int[] topKFrequent (int [] nums, int k){\n\t\tint [] res = new int[k];\n\t\tHashMap<Integer, Integer> map = new HashMap<>();\n\t\tfor(int num : nums){\n      //HashMap â€” getOrDefault( ) æ–¹æ³•ç”¨çš„å¦™\n\t\t\tmap.put(num, map.getOrDefault(num,0) + 1);\n\t\t}\n\t\t// EntrySet ç”¨çš„å¦™\n\t\tSet<Map.Entry<Integer,Integer>> entrySet = map.entrySet();\n\t\tPriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>(\n(o1, o2) -> o1.getValue() - o2.getValue());\n\t\t\n\t\tfor (Map.Entry<Integer, Integer> entry : entrySet){\n\t\t\tpq.offer(entry);\n\t\t\tif(pq.size > k){\n\t\t\t\tpq.poll();\n\t\t\t}\n\t\t}\n\t\n\t\tfor(int i = k-1 ; i >= 0; i--){\n\t\t\tres[i] = pq.poll().getKey();\n\t\t}\n\t\treturn res;\n\t}\n}\n```\n\n- HashMapÂ ç›¸å…³æ“ä½œ\n    \n    ```jsx\n    map.getOrDefault(key, defaultValue);\n    Set<Map.Entry<Integer, Integer>> entrySet = map.entrySet();\n    for(Map.Entry<Integer, Integer> entry : entrySet){\n    \tentry.getKey();\n    \tentry.getValue();\n    }\n    ```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205246466","body":"class Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int ans = 0; \n        for(int [] point : points){\n            HashMap<Integer, Integer> count = new HashMap<>(); \n            for(int [] curPoint : points){\n                int distance = (point[0]-curPoint[0])*(point[0]-curPoint[0]) + (point[1]-curPoint[1])*(point[1]-curPoint[1]);\n                count.put(distance, count.getOrDefault(distance,0)+1);\n            }\n            for(Map.Entry<Integer, Integer> entry : count.entrySet()){\n                int m = entry.getValue();\n                ans += m * (m - 1);\n            }\n        }\n        return ans;\n    }\n}\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208087330","body":"### Fast Slow pointers\n\n```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        if(head == null) {\n            return null;\n        }\n        // if(head.next == null || head.next.next == null) {\n        //     return head;\n        // }\n        ListNode fast = head; \n        ListNode slow = head; \n        while(fast != null && fast.next != null){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209312534","body":"### Double Pointers\n\nWe can use one pointer recording the next needed to be written place. \n\nAnother pointer recording the read index. \n\nif the read index is different from the write place, write.\n\nelse, we just move the read pointer. \n\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        if(nums == null || nums.length == 1){\n            return nums.length;\n        }\n        int i = 0, j = 1; \n        while(j < nums.length){\n            if(nums[i] != nums[j]){\n                i++;\n                nums[i] = nums[j];\n            }\n            j++;\n        }\n        return i+1;\n    }\n}\n```\n\nComplexity: \n\nTime: O(N)\n\nSpace: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luhaoling":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1186189241","body":"è§£é¢˜\r\n\r\n## Idea:\r\n\r\nå¼•å…¥BigIntegerç±»ï¼Œç›¸åŠ è½¬åŒ–ä¸ºlistã€‚\r\n\r\n## Code:\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> result=new ArrayList<>();\r\n        String s=\"\";\r\n       for(int i=0;i<num.length;i++){\r\n           s+=num[i];\r\n       }\r\n       java.math.BigInteger a=new java.math.BigInteger(s);\r\n       java.math.BigInteger b=new java.math.BigInteger(String.valueOf(k));\r\n       java.math.BigInteger c;\r\n        c=a.add(b);\r\n        String d=String.valueOf(c);\r\n        for (int i=0;i<d.length();i++){\r\n            result.add(Integer.valueOf(d.charAt(i))-48);\r\n        }\r\n        return result;\r\n    }\r\n\r\n\r\n}\r\n```\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186188719","body":"Idea\r\n\r\n```\r\nä»å·¦åˆ°å³å’Œä»å³åˆ°å·¦è¿›è¡Œä¸¤æ¬¡éå†è®¡ç®—å„å…ƒç´ åˆ°ç›®æ ‡å­—ç¬¦çš„è·ç¦»ã€‚\r\n```\r\n\r\nCode\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len=s.length();\r\n        int[] result=new int[len];\r\n        for(int i=0;i<len;i++){\r\n            result[i]=Integer.MAX_VALUE;\r\n        }\r\n        for (int i=0;i<len;i++){\r\n            if(s.charAt(i)==c){\r\n                for (int j=0;j<len;j++){\r\n                    if (Math.abs(i-j)<result[j]){\r\n                        result[j]=Math.abs(i-j);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        for (int i=len-1;i>0;i--){\r\n            if (s.charAt(i)==c){\r\n                for(int j=len-1;j>0;j--){\r\n                    if (Math.abs(i-j)<result[j]){\r\n                        result[j]=Math.abs(i-j);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186546899","body":"Code\r\n\r\n```java\r\nclass CustomStack {\r\n    int[] stack;\r\n    int[] add;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        add = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != stack.length - 1) {\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        int ret = stack[top] + add[top];\r\n        if (top != 0) {\r\n            add[top - 1] += add[top];\r\n        }\r\n        add[top] = 0;\r\n        --top;\r\n        return ret;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k - 1, top);\r\n        if (limit >= 0) {\r\n            add[limit] += val;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189074697","body":"Idea\r\n\r\n```\r\nä½¿ç”¨ä¸¤ä¸ªæ¨ªå‘æ‘†æ”¾ç›¸å¯¹å¼€å£çš„æ ˆæ¨¡æ‹Ÿé˜Ÿåˆ—ï¼Œå³è¾¹æ ˆå‚¨å­˜å…ƒç´ ï¼Œå·¦è¾¹æ ˆå¼¹å‡ºå…ƒç´ ã€‚\r\n```\r\n\r\nCode\r\n\r\n```java\r\nclass MyQueue {\r\n    private Stack<Integer> s1,s2;\r\n    public MyQueue() {\r\n        s1=new Stack<>();\r\n        s2=new Stack<>();\r\n    }\r\n\r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n\r\n    public int pop() {\r\n        int temp=peek();\r\n        s2.pop();\r\n        return temp;\r\n    }\r\n\r\n    public int peek() {\r\n        if (!s2.isEmpty()){\r\n            return s2.peek();\r\n        }\r\n        while(!s1.isEmpty()){\r\n            s2.push(s1.pop());\r\n        }\r\n        return s2.peek();\r\n\r\n    }\r\n\r\n    public boolean empty() {\r\n        if (s1.isEmpty()&& s2.isEmpty()){\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190461353","body":"class Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Map<Integer, Integer> count = new HashMap();\r\n        int ans = 0, nonzero = 0;\r\n\r\n        int[] expect = arr.clone();\r\n        Arrays.sort(expect);\r\n\r\n        for (int i = 0; i < arr.length; ++i) {\r\n            int x = arr[i], y = expect[i];\r\n\r\n            count.put(x, count.getOrDefault(x, 0) + 1);\r\n            if (count.get(x) == 0) nonzero--;\r\n            if (count.get(x) == 1) nonzero++;\r\n\r\n            count.put(y, count.getOrDefault(y, 0) - 1);\r\n            if (count.get(y) == -1) nonzero++;\r\n            if (count.get(y) == 0) nonzero--;\r\n\r\n            if (nonzero == 0) ans++;\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192703418","body":"Idea\r\n\r\n```\r\nç¡®è®¤å¤´æŒ‡é’ˆï¼Œä¿è¯é“¾è¡¨è¿æ¥ï¼Œå¯¹ç›®æ ‡è¿›è¡Œæ“ä½œ\r\n```\r\n\r\nCode\r\n\r\n```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n           ListNode before=new ListNode(0);\r\n           before.next=head;\r\n            ListNode temp=before;\r\n            while(temp.next!=null&&temp.next.next!=null){\r\n                ListNode node1=temp.next;\r\n                ListNode node2=temp.next.next;\r\n                temp.next=node2;\r\n                node1.next=node2.next;\r\n                node2.next=node1;\r\n                temp=node1;\r\n            }\r\n            return before.next;\r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193137575","body":"Idea\r\n\r\n```\r\né“¾è¡¨è½¬äºŒå‰æœç´¢æ ‘ã€‚å…¶æœ¬è´¨æ˜¯ä¸€ä¸ªå¿«æ…¢æŒ‡é’ˆçš„é€’å½’è¿‡ç¨‹ã€‚\r\n```\r\n\r\nCode\r\n\r\n```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if (head==null)return null;\r\n        return dfs(head,null);\r\n    }\r\n    private TreeNode dfs(ListNode head, ListNode tail){//tail==null\r\n        if (head==tail)return null;\r\n        ListNode fast=head,slow=head;\r\n        while(fast!=tail &&fast.next!=tail){\r\n            fast=fast.next.next;\r\n            slow=slow.next;\r\n        }\r\n        TreeNode root=new TreeNode(slow.val);\r\n        root.left=dfs(head,slow);\r\n        root.right=dfs(slow.next,tail);\r\n        return root;\r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193318029","body":"\r\n\r\nIdea\r\n\r\n```\r\nå°†ä¸¤æ¡é“¾è¡¨è¿èµ·æ¥éå†ï¼Œå¦‚æœæœ‰äº¤ç‚¹çš„è¯ï¼Œåˆ™è¯æ˜è¿™ä¸¤æ¡é“¾è¡¨æ˜¯è¿åœ¨ä¸€èµ·çš„ï¼›å¦‚æœæ²¡æœ‰äº¤ç‚¹ï¼Œåˆ™è¯æ˜è¿™ä¸¤æ¡é“¾è¡¨æ˜¯ç‹¬ç«‹çš„ã€‚ï¼ˆæœ‰äº¤ç‚¹çš„è¯ï¼Œåˆ™æœ‰é“¾è¡¨A+é“¾è¡¨B=é“¾è¡¨B+é“¾è¡¨Aï¼‰\r\n```\r\n\r\nCode\r\n\r\n```Java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n         ListNode first=headA,second=headB;\r\n        while(first!=second){\r\n            if (first==null)\r\n                first=headB;\r\n            else \r\n                first=first.next;\r\n            if (second==null)\r\n                second=headA;\r\n            else\r\n                second=second.next;\r\n        }\r\n        return first;\r\n    }\r\n}\t\t\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194139991","body":"Idea\r\n\r\n```\r\nä½¿ç”¨å¿«æ…¢æŒ‡é’ˆï¼Œå½“ä¸¤è€…ç›¸é‡æ—¶ï¼Œè¯´æ˜å­˜åœ¨ç¯ï¼Œç„¶åæŠŠå¿«æŒ‡é’ˆæŒ‡å‘é“¾è¡¨çš„å¤´èŠ‚ç‚¹ï¼Œæ¥ç€ä¸¤æŒ‡é’ˆä¸€èµ·å‰è¡Œï¼Œå½“ä¸¤æŒ‡é’ˆé‡æ–°ç›¸é‡æ—¶ï¼Œç›¸é‡ç»“ç‚¹å³ä¸ºç¯å¼€å§‹èŠ‚ç‚¹ã€‚\r\n```\r\n\r\nCode\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n      ListNode slow=head,fast=head;\r\n        while (fast!=null&&fast.next!=null){\r\n            slow=slow.next;\r\n            fast=fast.next.next;\r\n            if (fast==slow){\r\n                break;\r\n            }\r\n        }\r\n        if (fast==null||fast.next==null){\r\n            return null;\r\n        }\r\n        fast=head;\r\n        while (slow!=fast){\r\n            slow=slow.next;\r\n            fast=fast.next;\r\n        }\r\n        return fast;\r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195195558","body":"Idea\r\n\r\n```\r\nå…·ä½“é€»è¾‘å¦‚ä¸‹ï¼š\r\nputï¼š\r\nè‹¥keyå·²å­˜åœ¨ï¼Œå°†å…¶æƒé™æå‡è‡³æœ€è¿‘ä½¿ç”¨\r\nè‹¥keyä¸å­˜åœ¨ï¼Œéœ€è¦æ–°æ’å…¥keyï¼Œè‹¥å®¹é‡å·²æ»¡ï¼Œæ·˜æ±°æœ€ä¹…æœªä½¿ç”¨çš„keyï¼Œæ’å…¥keyå’Œvalï¼›è‹¥å®¹é‡æœªæ»¡åˆ™ç›´æ¥æ’å…¥keyå’Œvalï¼Œæœ€åå°†å…¶æƒé™æå‡è‡³æœ€è¿‘ä½¿ç”¨\r\n```\r\n\r\nCode\r\n\r\n```java\r\nclass LRUCache {\r\n\r\n    int cap;\r\n    LinkedHashMap<Integer,Integer>cache=new LinkedHashMap<>();\r\n    public LRUCache(int capacity){\r\n        this.cap=capacity;\r\n    }\r\n    \r\n    public int get(int key){\r\n        if (!cache.containsKey(key)){\r\n            return -1;\r\n        }\r\n        makeRecently(key);\r\n        return cache.get(key);\r\n    }\r\n    \r\n    public void put(int key,int val){\r\n        if(cache.containsKey(key)){\r\n            cache.put(key,val);\r\n            makeRecently(key);\r\n            return;\r\n        }\r\n        \r\n        if(cache.size()>=this.cap){\r\n            int oldestKey=cache.keySet().iterator().next();//é“¾è¡¨å¤´æŒ‡é’ˆ\r\n            cache.remove(oldestKey);\r\n        }\r\n        cache.put(key,val);\r\n    }\r\n    private void makeRecently(int key){\r\n        int val=cache.get(key);\r\n        cache.remove(key);\r\n        cache.put(key,val);\r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1207589206","body":"**Idea**\r\n\r\n```\r\näºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ä¸€é¢˜ï¼Œå¯ç”¨äºŒå‰æ ‘éå†æ³•å’ŒåŠ¨æ€è§„åˆ’æ³•ï¼š\r\näºŒå‰æ ‘éå†æ³•ï¼š\r\nå…ˆéå†å·¦èŠ‚ç‚¹ï¼Œç„¶åéå†å³èŠ‚ç‚¹ï¼Œåœ¨éå†è¿‡ç¨‹ä¸­éœ€è¦å‚¨å­˜æ¯”è¾ƒäºŒå‰æ ‘å„åˆ†æ”¯çš„æ·±åº¦å¤§å°ç„¶åå–æœ€å¤§å€¼\r\nåŠ¨æ€è§„åˆ’æ³•ï¼š\r\nä»æ•´ä½“å‡ºå‘ï¼Œæ±‚å‡ºå·¦å³å­æ ‘æœ€å¤§äºŒå‰æ ‘æ·±åº¦ï¼Œæœ€åå†æ¯”è¾ƒã€‚\r\n```\r\n\r\n**code**\r\n\r\n```java\r\n\r\npublic class day13 {\r\n    public class TreeNode {\r\n      int val;\r\n      TreeNode left;\r\n      TreeNode right;\r\n      TreeNode() {}\r\n      TreeNode(int val) { this.val = val; }\r\n      TreeNode(int val, TreeNode left, TreeNode right) {\r\n          this.val = val;\r\n          this.left = left;\r\n          this.right = right;\r\n      }\r\n    }\r\n    //äºŒå‰æ ‘éå†æ³•\r\n    int depth=0;//å‚¨å­˜å†å²äºŒå‰æ ‘æ·±åº¦\r\n    int res=0;//å‚¨å­˜ä¸´æ—¶äºŒå‰æ ‘æ·±åº¦\r\n    public int maxDepth(TreeNode root) {\r\n        traverse(root);\r\n        return res;\r\n        }\r\n        void traverse(TreeNode root){\r\n        if (root==null){\r\n            return ;\r\n        }\r\n        depth++;//æ·±åº¦åŠ åŠ \r\n            res=Math.max(res,depth);//å½“å‰æ·±åº¦ä¸å†å²æ·±åº¦æ¯”è¾ƒï¼Œå–æœ€å¤§å€¼\r\n        traverse(root.left);\r\n        traverse(root.right);\r\n        depth--;//éå†å®Œåéœ€è¦å‡å»å·¦ç»“ç‚¹é‚£è¾¹åŠ çš„1\r\n    }\r\n    //åŠ¨æ€è§„åˆ’æ³•\r\n    public int maxDepth1(TreeNode root) {\r\n        if(root==null)\r\n            return 0;\r\n        int leftMax=maxDepth1(root.left);//å·¦å­æ ‘æœ€å¤§æ·±åº¦\r\n        int rightMax=maxDepth1(root.right);//å³å­æ ‘æœ€å¤§æ·±åº¦\r\n        return 1+Math.max(leftMax,rightMax);//æ¯”è¾ƒä¸¤å­æ ‘æ·±åº¦ï¼Œå–æœ€å¤§å€¼ï¼›æ·±åº¦èŠ‚ç‚¹ç´¯åŠ \r\n    }\r\n}\r\n\r\n```\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1209013431","body":"**Idea**\r\n\r\n```\r\nä½¿ç”¨é€’å½’ï¼Œä¾æ¬¡åˆ¤æ–­ä»å·¦å­æ ‘åˆ°å³å­æ ‘ï¼Œä¾æ¬¡åˆ¤æ–­æ¯ä¸ªèŠ‚ç‚¹æ˜¯å¦ä¸€ä¸€å¯¹åº”ã€‚\r\n```\r\n\r\nCode\r\n\r\n```java\r\nåˆå§‹ç¼–å†™ä»£ç ï¼š\r\n      boolean flag=true;\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n       if(p==null&&q==null){\r\n            return flag;\r\n            \r\n        }\r\n        if((p!=null&&q==null)||(p==null&&q!=null)){\r\n            flag=false;\r\n           \r\n            return flag;\r\n        }\r\n        if (p.val!=q.val){\r\n            flag=false;\r\n            return flag;\r\n        }\r\n        isSameTree(p.left,q.left);\r\n        isSameTree(p.right,q.right);\r\n        return flag;\r\n    }\r\n}\r\næ€è·¯ï¼šä½¿ç”¨flagè®°å½•çŠ¶æ€ï¼Œå¦‚æœå‘ç°æœ‰åœ°æ–¹ä¸åŒï¼Œåˆ™è¯´æ˜è¿™ä¸¤æ£µæ ‘ä¸ç›¸åŒï¼Œç„¶åç”¨flagè®°å½•ã€‚\r\nä¸è¶³ï¼šæœ‰è¿”å›å€¼çš„isSameTree()å‡½æ•°æ²¡æœ‰å¾—åˆ°å®Œå…¨åˆ©ç”¨ã€‚\r\nä¿®æ”¹ç‰ˆä»£ç ï¼š\r\n      public boolean isSameTree(TreeNode p, TreeNode q) {\r\n         if(p==null&&q==null)\r\n            return true;\r\n        if(p==null||q==null){\r\n            return false;\r\n        }\r\n        if (p.val!=q.val){\r\n            return false;\r\n        }\r\n        return isSameTree(p.left,q.left)&& isSameTree(p.right,q.right);\r\n    }\r\næ€»ç»“:åˆ¤æ–­ç©ºçš„æƒ…å†µï¼Œå…¨ç©ºå’Œå…¶ä¸­ä¸€æ£µäºŒå‰æ ‘æœ‰ç©ºã€‚è°ƒç”¨isSameTree()å‡½æ•°åï¼Œæ¯æ¬¡é€’å½’å¾ªç¯çš„ç»“æœéƒ½ä¼šè¿”å›åˆ°returnä¸Šé¢ï¼Œæœ€åæ±‡æ€»åœ¨æ ¹ç»“ç‚¹æ‰€åœ¨çš„å¾ªç¯å¾ªç¯ä¸­ã€‚ä»¥æ­¤æ¥åˆ¤æ–­è¿™ä¸¤æ£µæ ‘æ˜¯å¦ç›¸åŒã€‚\r\n```\r\n\r\n","onTime":false},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1205977979","body":"Idea\r\n\r\n```\r\nä½¿ç”¨HashMapæ¥å‚¨å­˜ç»“æœå€¼ï¼Œç„¶åç”¨forå¾ªç¯ä¸æ–­å‘ä¸‹éå†ï¼Œå¦‚æœHashMapä¸­å­˜åœ¨ç›¸åº”çš„å€¼ï¼Œåˆ™è¿”å›è¿™ä¸ªå€¼æ‰€å¯¹åº”çš„ä¸‹æ ‡ä»¥åŠforå¾ªç¯æ‰€å¯¹åº”çš„å…ƒç´ ä½œä¸ºç»“æœã€‚\r\n```\r\n\r\nCode\r\n\r\n```java\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int target) {\r\n         HashMap<Integer,Integer> hash=new HashMap<>();\r\n        int[] arr=new int[2];\r\n        for(int i=0;i<nums.length;i++){\r\n            int temp=target-nums[i];\r\n            if(hash.containsKey(temp)){\r\n                arr[0]=i;\r\n                arr[1]=hash.get(temp);\r\n                return arr;\r\n            }\r\n            hash.put(nums[i],i);\r\n        }\r\n        return arr;\r\n    }\r\n}\r\n```\r\n\r\n","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205272118","body":"Idea\r\n\r\n```\r\nå…ˆç”¨åŒforå¾ªç¯åˆ—ä¸¾å¯èƒ½æ€§ï¼Œç„¶åç”¨hashmapå‚¨å­˜ç»“æœï¼Œæ¥ç€å¯¹ç¬¦åˆæ¡ä»¶çš„ç»“æœè¿›è¡Œæ’åˆ—ï¼Œç„¶åç´¯åŠ \r\n```\r\n\r\nCode\r\n\r\n```java\r\nclass Solution {\r\n   public int numberOfBoomerangs(int[][] points) {\r\n        int res=0;\r\n        //åˆ¤æ–­æ˜¯å¦æ»¡è¶³æœ€ä½æ¡ä»¶\r\n        if (points==null||points.length<3){\r\n            return res;\r\n        }\r\n        //å¼•å…¥hashmapä»¥ç©ºé—´æ¢æ—¶é—´\r\n        HashMap<Integer,Integer>equalCount=new HashMap<>();\r\n        for(int i=0;i<points.length;i++){\r\n            for(int j=0;j<points.length;j++){\r\n                //å­˜ï¼Œè‹¥æ»¡è¶³æ¡ä»¶åˆ™ç´¯åŠ \r\n                int distant=getDistant(points[i],points[j]);\r\n                equalCount.put(distant,equalCount.getOrDefault(distant,0)+1);\r\n            }\r\n            //è®¡æ•°\r\n            for(int count:equalCount.values()){\r\n                res+=count*(count-1);\r\n            }\r\n             equalCount.clear();\r\n        }\r\n        return res;\r\n    }\r\n    //è®¡ç®—è·ç¦»\r\n    public int getDistant(int[] x,int[] y){\r\n        int a=x[0]-y[0];\r\n        int b=x[1]-y[1];\r\n        return a*a+b*b;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205533918","body":"Idea\r\n\r\n```\r\nä¸»è¦æ˜¯ä½¿ç”¨æ»‘åŠ¨çª—å£ã€‚å³çª—å£å…ˆå‘å‰ç§»åŠ¨ï¼Œç„¶åç”¨HashMapå¯¹å­—ç¬¦è®¡æ•°ï¼Œè‹¥æœ‰å­—ç¬¦ä¸ªæ•°è¶…è¿‡1ï¼Œåˆ™å·¦çª—å£+1ï¼Œç›´è‡³å­—ç¬¦ä¸ªæ•°é‡æ–°ç­‰äº1ï¼Œç„¶åå³çª—å£å†å‘å‰ç§»åŠ¨ï¼Œç”±æ­¤å¾ªç¯å¾€å¤ã€‚\r\n```\r\n\r\nCode\r\n\r\n```java\r\nclass Solution {\r\n    public int lengthOfLongestSubstring(String s) {\r\n           HashMap<Character,Integer> window=new HashMap<>();\r\n        int left=0,right=0;\r\n        int res=0;\r\n        while(right<s.length()){\r\n            char c=s.charAt(right);\r\n            right++;\r\n            window.put(c,window.getOrDefault(c,0)+1);\r\n            while (window.get(c)>1){\r\n                char d=s.charAt(left);\r\n                left++;\r\n                window.put(d,window.get(d)-1);\r\n            }\r\n            res=Math.max(res,right-left);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207232570","body":"Idea\r\n\r\n```\r\nä»…è€ƒè™‘éå†è¿‡ç¨‹ï¼Œ éå† s ä¸²çš„æ—¶é—´å¤æ‚åº¦ä¸º O(n - m + 1)O(nâˆ’m+1), å…¶ä¸­ n ä¸º s å­—ç¬¦ä¸²é•¿åº¦, m ä¸º words[0].length * words.lengthï¼Œä¹Ÿå°±æ˜¯ words çš„å­—ç¬¦æ€»æ•°ã€‚é—®é¢˜å…³é”®åœ¨äºå¦‚ä½•åˆ¤æ–­ s çš„å­ä¸² Y æ˜¯å¦å¯ä»¥ç”± words æ•°ç»„çš„æ„æˆï¼Œç”±äº words ä¸­å•è¯é•¿åº¦å›ºå®šï¼Œæˆ‘ä»¬å¯ä»¥å°† Y æ‹†åˆ†æˆå¯¹åº” words[0]é•¿åº¦çš„ä¸€ä¸ªä¸ªå­ä¸² parts, åªéœ€è¦åˆ¤æ–­ words å’Œ parts ä¸­çš„å•è¯æ˜¯å¦ä¸€ä¸€åŒ¹é…å³å¯ï¼Œè¿™é‡Œç”¨ä¸¤ä¸ªå“ˆå¸Œè¡¨è¡¨æ¯”å¯¹å‡ºç°æ¬¡æ•°å³å¯ã€‚ä¸€æ—¦ä¸€ä¸ªå¯¹åº”ä¸ä¸Šï¼Œæ„å‘³ç€æ­¤ç§åˆ†å‰²æ–¹æ³•ä¸æ­£ç¡®ï¼Œç»§ç»­å°è¯•ä¸‹ä¸€ç§å³å¯ã€‚\r\n```\r\n\r\nCode\r\n\r\n```Java\r\nclass Solution {\r\n    public List<Integer> findSubstring(String s, String[] words) {\r\n         List<Integer> res = new ArrayList<>();\r\n        Map<String, Integer> map = new HashMap<>();\r\n        if (words == null || words.length == 0)\r\n            return res;\r\n\r\n        for (String word : words) {\r\n            map.put(word, map.getOrDefault(word, 0) + 1);\r\n        }\r\n        int sLen = s.length(), wordLen = words[0].length(), count = words.length;\r\n        for (int i = 0; i < sLen - wordLen * count + 1; i++) {\r\n            String cur = s.substring(i, i + wordLen * count);\r\n            Map<String, Integer> temp = new HashMap<>();\r\n            int j = 0;\r\n\r\n            for (; j < cur.length(); j += wordLen) {\r\n                String word = cur.substring(j, j + wordLen);\r\n\r\n                if (!map.containsKey(word))\r\n                    break;\r\n                temp.put(word,temp.getOrDefault(word,0)+1);\r\n                if (temp.get(word)>map.get(word))\r\n                    break;\r\n            }\r\n            if (j == cur.length())\r\n                res.add(i);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207324374","body":"Idea\r\n\r\n```latex\r\n  åŒä½™å®šç†+å‰ç¼€å’Œçš„å·§å¦™ç»“åˆã€‚\r\n  åŒä½™å®šç†(ä¸¤æ•´æ•°é™¤ä»¥åŒä¸€ä¸ªæ•´æ•°ï¼Œè‹¥å¯å¾—ç›¸åŒä½™æ•°ï¼Œåˆ™äºŒæ•´æ•°åŒä½™)\r\n  ç”±åŒä½™å®šç†å¾—ï¼š\r\n ï¼ˆtotal-delete)%k=0,å…¶ä¸­totalä¸ºæ•°ç»„å…ƒç´ å’Œ\r\n->total%k=delete%k,\r\n  è®¾total%kä¸ºtargetï¼Œå…¶ä¸­deleteä¸ºå¾…åˆ é™¤å­æ•°ç»„\r\n  ç”±å‰ç¼€å’Œå¯å¾—ï¼šdelete%k=(pre[j]-pre[i-1])%k\r\n->(pre[j]-pre[i-1])%k=target\r\n  å› ä¸ºtargetç”±total%kå¾—ï¼Œå› æ­¤target=tatget%k\r\n->(pre[j]-pre[i-1])%k=target%k\r\n->(pre[j]-pre[i-1]-target)%k=0\r\n->(pre[j]-target)%k=pre[i-1]%k\r\n  \r\n  å¦‚ä½•åˆ¤å®šå¯ä»¥é‡‡ç”¨åŒä½™å®šç†+å‰ç¼€å’Œæ–¹æ³•ï¼š\r\n  çœ‹åˆ°è¢«xæ•´é™¤->å¯è€ƒè™‘æ—¶å€™å¯ä»¥é‡‡ç”¨æ•°å­¦ä¸­å¾—åŒä½™å®šç†\r\n  è¿ç»­å­æ•°ç»„->å¯è€ƒè™‘ç”¨å‰ç¼€å’Œè¿›è¡Œä¼˜åŒ–\r\n      \r\n  æ€»ä½“ä»£ç æ€è·¯ï¼š\r\n  å¦‚ä½•æ‰¾åˆ°æœ€çŸ­è¿ç»­å­æ•°ç»„:\r\n  å°†å‰ç¼€å’Œå’Œæ¨¡kçš„ä½™æ•°xæ”¾åˆ°å“ˆå¸Œè¡¨ä¸­ï¼Œè¿™ä¸ªå“ˆå¸Œè¡¨å……å½“å‰ç¼€å’Œçš„è§’è‰²ï¼Œç”¨æ¥è®°å½•æœ€æ–°çš„ä½™æ•°xå¯¹åº”çš„   ä¸‹æ ‡ï¼Œè®°å½•æœ€æ–°çš„ç›®çš„æ˜¯ä¸ºäº†æ‰¾å‡ºç¬¦åˆè¦æ±‚çš„æœ€çŸ­çš„è¿ç»­å­æ•°ç»„ã€‚\r\n  ç®—æ³•æ ¸å¿ƒä»£ç å®ç°:\r\n  å…ˆè®¡ç®—å‡ºæ€»ä½“æ•°æ®å’Œtotalæ¨¡kçš„ä½™æ•°ï¼Œè®°ä¸ºtargetï¼Œç„¶åç›®æ ‡å°±å˜æˆäº†æ‰¾åˆ°ä¸€æ®µæ¨¡kç­‰äºtargetçš„   å­æ•°ç»„\r\n  ç®—æ³•å…·ä½“å®ç°ï¼š\r\n  å…ˆè®¡ç®—å‡ºtotalå€¼ï¼Œç„¶åæ¨¡kèµ‹ç»™tarï¼Œæ¥ç€å¾€å“ˆå¸Œè¡¨ä¸­æå‰å‚¨å­˜(0,1),ä»¥å¯¹åº”ä»æ•°ç»„ç´¢å¼•0å¤„å¼€å§‹å–   å­æ•°ç»„çš„æƒ…å†µ(ä¹Ÿå°±æ˜¯ä¸ç”¨åˆ é™¤ä»»ä½•å…ƒç´ ï¼Œæ•°ç»„æ€»å€¼æ¨¡kå·²ç­‰äº0)ï¼›ç„¶åè®¡ç®—å‰ç¼€å’Œï¼Œå¹¶æ¨¡kå­˜è¿›å“ˆå¸Œ   è¡¨ä¸­ï¼›æ¥ç€åˆ¤æ–­å“ˆå¸Œè¡¨ä¸­æ˜¯å¦å­˜æœ‰ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„å­æ•°ç»„ï¼Œç„¶åç”¨Math.minåˆ¤æ–­æ˜¯å¦ç¬¦åˆæ¡ä»¶ã€‚ç”±   ä¸æ–­è¿›è¡Œåˆ¤æ–­\r\n```\r\n\r\nCode\r\n\r\n```java\r\nSolution{\r\n     public int solve(int[] nums,int k){\r\n        int tar=0;\r\n        //æ±‚æ€»å’Œ\r\n        for(int n:nums){\r\n            tar+=n;\r\n        }\r\n        //æ€»å’Œæ±‚æ¨¡\r\n        tar=Math.floorMod(tar,k);\r\n        Map<Integer,Integer> map=new HashMap<>();\r\n        //æå‰å­˜è¿›(0,-1),ä»¥å¯¹åº”ä¸ç”¨åˆ é™¤å…ƒç´ çš„æƒ…å†µ\r\n        map.put(0,-1);\r\n\r\n        int prefix=0,res=nums.length;\r\n\r\n        for(int i=0;i<nums.length;i++){\r\n            //æ±‚å‰ç¼€å’Œ\r\n            prefix+=nums[i];\r\n            //å‰ç¼€å’Œæ±‚ä½™\r\n            int mod=Math.floorMod(prefix,k);\r\n            map.put(mod,i);\r\n            //åˆ¤æ–­æ˜¯å¦æ»¡è¶³æ¡ä»¶\r\n            if(map.containsKey(Math.floorMod(prefix-tar,k)))\r\n                res=Math.min(res,i-map.get(Math.floorMod(prefix-tar,k)));\r\n        }\r\n        return res==nums.length?-1:res;\r\n    }\r\n}\r\n```\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207589542","body":"**Idea**\r\n\r\n```\r\nä½¿ç”¨å¿«æ…¢æŒ‡é’ˆï¼Œå½“å¿«æŒ‡é’ˆèµ°åˆ°é“¾è¡¨æœ«å°¾æ—¶ï¼Œæ…¢æŒ‡é’ˆåˆšå¥½èµ°åˆ°é“¾è¡¨ä¸­é—´ã€‚\r\n```\r\n\r\n**Code**\r\n\r\n```java\r\nclass Solution {\r\n    public ListNode middleNode(ListNode head) {\r\n         ListNode slow = head, fast = head;\r\n            while (fast != null&&fast.next!=null) {\r\n                //fast!=nullæ˜¯åˆ¤æ–­å¶æ•°ä¸ªå…ƒç´ ç»„ï¼›fast.next!=nullæ˜¯åˆ¤æ–­å¥‡æ•°ä¸ªå…ƒç´ ç»„\r\n                slow = slow.next;\r\n                fast = fast.next.next;\r\n            }\r\n            return slow;\r\n    }\r\n}\r\n```\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208861524","body":"**Idea**\r\n\r\n```\r\nä½¿ç”¨åŒæŒ‡é’ˆï¼Œå®šä¹‰ä¸¤ä¸ªåŒèµ·ç‚¹çš„è¯»å†™æŒ‡é’ˆï¼Œç„¶åç”¨fast(è¯»æŒ‡é’ˆ)æ‰¾ä¸åŒå…ƒç´ ï¼Œslow(å†™æŒ‡é’ˆ)å†™å…¥å…ƒç´ ã€‚\r\nè¯¥é¢˜ä¸»è¦è§£é¢˜æ€è·¯ï¼šä»ä¸€ä¸ªæ•°ç»„ä¸­ï¼Œå‰”é™¤é‡å¤å…ƒç´ ï¼ŒæŒ‰é¡ºåºåªä¿ç•™ä¸é‡å¤çš„å…ƒç´ ã€‚\r\nå¼€å§‹æ—¶ï¼Œä¸çŸ¥é“é‚£äº›å…ƒç´ æ˜¯ä¸é‡å¤çš„ï¼Œç„¶åç”¨è¯»æŒ‡é’ˆå»è¯•æ¢ï¼Œæ‰¾å‡ºä¸åŒçš„å…ƒç´ ï¼›æ‰¾åˆ°ä¸åŒå…ƒç´ åï¼Œå†™æŒ‡é’ˆå‘å‰ç§»åŠ¨ä¸€æ­¥ï¼Œä»¥å†™å…¥è¿™ä¸ªå…ƒç´ ã€‚\r\n```\r\n\r\n**Code**\r\n\r\n```java\r\nclass Solution {\r\n    public int removeDuplicates(int[] nums) {\r\n        int slow=0,fast=1;\r\n            if(nums[slow]==nums[fast]) {\r\n                while (nums[slow] == nums[fast]) {\r\n                    fast++;\r\n                }\r\n                slow++;\r\n                int temp=slow;\r\n                while(temp<=fast) {\r\n                    nums[temp] = nums[fast];\r\n                }\r\n            }\r\n            if(nums[slow]!=nums[fast]&&fast<nums.length){\r\n                slow++;\r\n                fast++;\r\n            }\r\n            return slow+1; \r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flaming-cl":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186206888","body":"```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\n// two pointers (i: read pointer; j: write pointer)\r\n// 1. when i points to c, handle all elements between i -> j\r\n//      i - j < j - lastJ ? i - j : j - lastJ\r\n//      if (j === i) lastJ = j;\r\n// 2. if c is not the last element of s, add the rest of elements for res (there is no fore j, only back j)\r\n//      while (res.length !== s.length) { res.push(res.length - lastJ); }\r\n\r\nvar shortestToChar = function(s, c) {\r\n    if (s.length === 1) return [0];\r\n    let res = [];\r\n    let j = 0;\r\n    let lastJ = null;\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === c) {\r\n            while (j <= i) {\r\n                res[j] = lastJ === null || (i - j < j - lastJ) ? i - j : j - lastJ;\r\n                if (j === i) lastJ = j;\r\n                j++;\r\n            }\r\n        }\r\n    }\r\n    while (res.length !== s.length) {\r\n        res.push(res.length - lastJ);\r\n    }\r\n    return res;\r\n};\r\n```\r\nT: O(N)   \r\nS: O(1)   ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186531186","body":"```java\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    // O(1)\r\n    public void push(int x) {\r\n        if (top != stack.length - 1) {\r\n            stack[++top] = x;\r\n        }\r\n    }\r\n    \r\n    // O(1)\r\n    public int pop() {\r\n        if (top == -1) return -1;\r\n        return stack[top--];\r\n    }\r\n    \r\n    // O(N)\r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186604001","body":"Java\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Stack<Integer> tStack = new Stack<>();\r\n        Stack<String> sStack = new Stack<>();\r\n        String temp = \"\";\r\n        int times = 0;\r\n\r\n        for (int i = 0; i < s.length(); i++) {\r\n            char c = s.charAt(i);\r\n            if (Character.isDigit(c)) {\r\n                times = times * 10 + c - '0';\r\n                continue;\r\n            }\r\n            if (c == '[') {\r\n                sStack.push(temp);\r\n                tStack.push(times);\r\n                temp = \"\";\r\n                times = 0;\r\n                continue;\r\n            }\r\n            if (c == ']') {\r\n                temp = sStack.pop() + temp.repeat(tStack.pop());\r\n                continue;\r\n            }\r\n            temp += c;\r\n        }\r\n        return temp;\r\n    }\r\n}\r\n```\r\nT: O(N)\r\nS: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188474959","body":"Java\r\n```java\r\n// stack1: æ’å…¥ç”¨\r\n// stack2: åˆ é™¤ç”¨ï¼ˆstack2 å³å€’è¿‡æ¥çš„ stack1ï¼Œéœ€è¦å–å‡ºæ•°å­—æ—¶ï¼Œè°ƒç”¨ stack2ï¼‰\r\n// ä½•æ—¶åœ¨ stack2 ä¸­æ’å…¥å€¼ï¼Ÿ\r\n// æœ‰è¿™ä¹ˆä¸€ç§æƒ…å†µï¼šæœ‰å¤§é‡çš„æ’å…¥æ“ä½œï¼Œå´åªæœ‰å¾ˆå°‘çš„åˆ é™¤/å–æ•°æ“ä½œ\r\n// æ‰€ä»¥ push çš„æ—¶å€™ï¼Œä¸å¿…ç»™ stack2 åŠ å…¥æ•°å­—\r\n// è€Œæ˜¯åœ¨ã€Œåˆ é™¤æˆ–å–æ•°æ—¶ï¼Œä¸” stack2 ä¸ºç©ºæ—¶ã€ï¼Œä» stack1 ä¸­é€ä¸€ popï¼Œå…¥æ ˆ stack2\r\nclass MyQueue {\r\n    Stack<Integer> stack1 = new Stack<>();\r\n    Stack<Integer> stack2 = new Stack<>();\r\n    \r\n    public void push(int x) {\r\n        stack1.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        this.cleanQ1();\r\n        return stack2.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        this.cleanQ1();\r\n        return stack2.get(stack2.size() - 1);\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return stack1.size() == 0 && stack2.size() == 0;\r\n    }\r\n\r\n    private void cleanQ1() {\r\n        if (stack2.size() == 0) {\r\n            int q1Len = stack1.size();\r\n            for (int i = 0; i < q1Len; i++) {\r\n                stack2.push(stack1.pop());\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```\r\n- ç©ºé—´å¤æ‚åº¦ O(N)\r\n- æ—¶é—´å¤æ‚åº¦\r\n  - æ‘Šè¿˜æ—¶é—´å¤æ‚åº¦ O(1) \r\n     - æœ€åæƒ…å†µ O(N)ï¼šæ ˆ 2 ä¸ºç©ºï¼Œéœ€è¦ for loop æŒ¤å‹æ ˆ 1 æ—¶\r\n     - æœ€å¥½æƒ…å†µ O(1)     \r\n\r\næ‘Šè¿˜å¤æ‚åº¦ï¼šé«˜é¢‘æ¬¡æ“ä½œçš„æ—¶é—´å¤æ‚åº¦å° + ä½é¢‘æ¬¡æ“ä½œçš„æ—¶é—´å¤æ‚åº¦é«˜ï¼ŒäºŒè€…å‡æ‘Šäº†æ¯æ¬¡æ“ä½œçš„ä»£ä»·","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189493717","body":"Java\r\n```java\r\n//æ‰¾åˆ°æ‰€æœ‰å­é›†çš„æœ€å¤§å€¼ï¼Œè¿™äº›æœ€å¤§å€¼å¦‚æœèƒ½æŒ‰å‡åºæ’åˆ—ï¼Œé‚£ä¹ˆè¿™äº›å­é›†ä¹Ÿå¯ä»¥æŒ‰å‡åºæ’åˆ—    \r\n\r\n// å…·ä½“åšæ³•ï¼š   \r\n// - ç»´æŠ¤ä¸€ä¸ªå•è°ƒæ ˆï¼ˆå•è°ƒæ ˆé‡Œï¼Œè£…ç€æ‰€æœ‰ target å­é›†çš„æœ€å¤§å€¼ï¼‰   \r\n// - éå†æ•°ç»„   \r\n//  - å¦‚æœå½“å‰æ•°å­— >= å•è°ƒæ ˆæ ˆé¡¶ï¼ˆå‰ä¸€ä¸ª target å­é›†çš„æœ€å¤§å€¼ï¼‰ï¼Œå½“å‰æ•°å­—å…¥æ ˆ   \r\n//  - å¦‚æœå½“å‰æ•°å­— < å•è°ƒæ ˆæ ˆé¡¶ï¼Œè¯´æ˜å‰é¢æ‰¾å¥½çš„å­é›†æœ€å¤§å€¼å’Œå½“å‰æ•°å­—â€”â€”æ— æ³•æ»¡è¶³å‡åºæ’åˆ—æ¡ä»¶ï¼Œé‚£å°±æŠŠå½“å‰æ ˆä¸­æ‰¾å¥½çš„å­é›†æœ€å¤§å€¼ä»¬ï¼Œä¸€ä¸ªä¸ªè¸¢å‡ºå•è°ƒæ ˆï¼Œç›´åˆ°å½“å‰æ•°å­— < æ ˆé¡¶å…ƒç´ ï¼Œè¸¢å®ŒåæŠŠä¸Šä¸€ä¸ªæ ˆé¡¶å…ƒç´ åŠ å›æ¥\r\n// - è¿”å›å•è°ƒæ ˆå…ƒç´ ä¸ªæ•°ï¼Œå³å¤šå°‘ä¸ªå¯ç”Ÿåºæ’åˆ—çš„å­é›†ä¸ªæ•° \r\nclass Solution {\r\n    Stack<Integer> stack = new Stack();\r\n    public int maxChunksToSorted(int[] arr) {\r\n        stack.push(arr[0]);\r\n        for (int i = 1; i < arr.length; i++) {\r\n            int stackTop = getStacktop();\r\n            if (arr[i] >= stackTop) {\r\n                stack.push(arr[i]);\r\n                continue;\r\n            }\r\n            while (stack.size() > 0 && arr[i] < getStacktop()) {\r\n                stack.pop();\r\n            }\r\n            stack.push(stackTop);\r\n        }\r\n        return stack.size();\r\n    }\r\n\r\n    int getStacktop() {\r\n        return stack.get(stack.size() - 1);\r\n    }\r\n}\r\n```\r\nT: O(N)\r\nS: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1192860221","body":"Java\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (k == 0 || head == null || head.next == null) return head;\r\n        int size = 0;\r\n        ListNode joint = null;\r\n        for (ListNode iter = head; iter != null; iter = iter.next) {\r\n            joint = iter;\r\n            size++;\r\n        }\r\n        k %= size;\r\n        if (k == 0) return head;\r\n        ListNode end = head;\r\n        for (int j = 1; j < size - k; j++) {\r\n            end = end.next;\r\n        }\r\n        ListNode start = end.next;\r\n        end.next = null;\r\n        joint.next = head;\r\n        return start;\r\n    }\r\n}\r\n```\r\nT: O(N)\r\nO: O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192748573","body":"```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        ListNode dummy = new ListNode(-1, head);\r\n        ListNode iter = dummy;\r\n        while (iter.next != null && iter.next.next != null) {\r\n            ListNode first = iter.next;\r\n            ListNode second = iter.next.next;\r\n            first.next = second.next;\r\n            second.next = first;\r\n\r\n            iter.next = second;\r\n            iter = first;\r\n        }\r\n        return dummy.next;\r\n    }\r\n}\r\n```\r\nT: O(N)\r\nS: O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193040493","body":"Java\r\n```java\r\n// linkedlist to bst, é€’å½’æ„å»ºäºŒå‰æ ‘\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    List<Integer> bst = new ArrayList<Integer>();\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        while (head != null) {\r\n            bst.add(head.val);\r\n            head = head.next;\r\n        }\r\n        return formBST(0, bst.size() - 1);\r\n    }\r\n\r\n    public TreeNode formBST(int start, int end) {\r\n        if (start > end) return null;\r\n        int mid = (start + end) >>> 1; \r\n        TreeNode root = new TreeNode(bst.get(mid));\r\n        root.left = formBST(start, mid - 1);\r\n        root.right = formBST(mid + 1, end);\r\n        return root;\r\n    }\r\n}\r\n```\r\nT: O(N)\r\nS: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1194739873","body":"Java\r\n```javascript\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode A = headA;\r\n        ListNode B = headB;\r\n        while (A != B) {\r\n            A = A == null ? headB : A.next;\r\n            B = B == null ? headA : B.next;\r\n        }\r\n        return A;\r\n    }\r\n}\r\n```\r\nT: O(N)\r\nS: O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193371218","body":"Java\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n       ListNode fast = head;\r\n       ListNode slow = head;\r\n       while (fast != null) {\r\n           if (fast.next == null) {\r\n               return null;\r\n           }\r\n           slow = slow.next;\r\n           fast = fast.next.next;\r\n           if (slow == fast) {\r\n               fast = head;\r\n               while (slow != fast) {\r\n                   slow = slow.next;\r\n                   fast = fast.next;\r\n               }\r\n               return fast;\r\n           }\r\n       }\r\n       return null;\r\n    }\r\n}\r\n```\r\nT: O(N)\r\nS: O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194613467","body":"Java\r\n```java\r\n// åŒå‘é“¾è¡¨ç”¨æ¥å¢åˆ å¤´å°¾èŠ‚ç‚¹ï¼Œhash ç”¨æ¥ O(1) æ‰¾åˆ°èŠ‚ç‚¹\r\n\r\nclass LRUCache {\r\n    class DLinkedNode {\r\n        int key;\r\n        int value;\r\n        DLinkedNode prev;\r\n        DLinkedNode next;\r\n        public DLinkedNode() {}\r\n        public DLinkedNode(int _key, int _value) {key = _key; value = _value;}\r\n    }\r\n\r\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\r\n    private int size;\r\n    private int capacity;\r\n    private DLinkedNode head, tail;\r\n\r\n    public LRUCache(int capacity) {\r\n        this.size = 0;\r\n        this.capacity = capacity;\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head.next = tail;\r\n        tail.prev = head;\r\n    }\r\n\r\n    // T: O(1) S: O(capacity)\r\n    public int get(int key) {\r\n       DLinkedNode node = cache.get(key);\r\n       if (node == null) return -1;\r\n       moveToHead(node);\r\n       return node.value;\r\n    }\r\n\r\n    // T: O(1) S: O(capacity)\r\n    public void put(int key, int value) {\r\n        DLinkedNode node = cache.get(key);\r\n        if (node != null) {\r\n            node.value = value;\r\n            moveToHead(node);\r\n        } else {\r\n            DLinkedNode newNode = new DLinkedNode(key, value);\r\n            cache.put(key, newNode);\r\n            addToHead(newNode);\r\n            if (size == capacity) {\r\n                cache.remove(removeTail());\r\n            } else {\r\n                size++;\r\n            }\r\n        }\r\n    }\r\n    \r\n    private void addToHead(DLinkedNode node) {\r\n        DLinkedNode hNext = head.next;\r\n        node.next = hNext;\r\n        node.prev = head;\r\n        head.next = node;\r\n        hNext.prev = node;\r\n    }\r\n\r\n    private void moveToHead(DLinkedNode node) {\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n\r\n    private int removeNode(DLinkedNode node) {\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n        return node.key;\r\n    }\r\n\r\n    private int removeTail() {\r\n        return removeNode(tail.prev);\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196161593","body":"Java\r\n```java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n    }\r\n}\r\n```\r\nT: O(N)\r\nS: O(H)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197380511","body":"Java\r\n```java\r\n// p æˆ– q å…¶ä¸­ä¸€ä¸ªä¸ºç©ºï¼Œæˆ–è€…å€¼ä¸ç›¸ç­‰ï¼Œéƒ½ä¸º false\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null && q == null) {\r\n            return true;\r\n        }\r\n        if (p == null || q == null || p.val != q.val) {\r\n            return false;\r\n        }\r\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n```\r\nDFS:\r\nT: O(min(pNodeNum, qNodeNum))\r\nS: O(min(pNodeNum, qNodeNum))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198569624","body":"Java\r\n```javascript\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    int ans = 0;\r\n    public int sumNumbers(TreeNode root) {\r\n        sumRecurr(root, 0);\r\n        return ans;\r\n    }\r\n\r\n    private void sumRecurr(TreeNode root, int sum) {\r\n        if (root == null) return;\r\n        sum = sum * 10 + root.val;\r\n        if (root.left == null && root.right == null) {\r\n            ans += sum;\r\n        }\r\n        sumRecurr(root.left, sum);\r\n        sumRecurr(root.right, sum);\r\n    }\r\n}\r\n```\r\nT: O(N)\r\nS: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1199880048","body":"Java\r\n```java\r\n// bfs ä»å³åˆ°å·¦éå†ï¼Œæœ€åä¸€ä¸ªè¢«retèµ‹å€¼çš„ï¼Œå³æœ€åº•å±‚æœ€å·¦ä¸‹è§’çš„å€¼\r\n// Tï¼šO(N)\r\n// S: O(N)\r\nclass Solution {\r\n    public int findBottomLeftValue(TreeNode root) {\r\n        int ret = 0;\r\n        Queue<TreeNode> queue = new ArrayDeque<TreeNode>();\r\n        queue.offer(root);\r\n        while (!queue.isEmpty()) {\r\n            TreeNode p = queue.poll();\r\n            if (p.right != null) {\r\n                queue.offer(p.right);\r\n            }\r\n            if (p.left != null) {\r\n                queue.offer(p.left);\r\n            }\r\n            ret = p.val;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200272601","body":"Java\r\n```java\r\n// æ‹¿åˆ°ä¸€ä¸ªå…ˆåºéå†å¾—åˆ°çš„å­—ç¬¦ä¸²ï¼Œæ€æ ·æ„å»ºäºŒå‰æ ‘ï¼š\r\n// string -> list\r\n// list ä¸æ–­å¼¹å‡º\r\n// å¯¹å¼¹å‡ºçš„å€¼è¿›è¡Œåˆ¤æ–­ï¼š\r\n// 1. null -> è¿”å› null\r\n// 2. å€¼ -> æ–°å»ºèŠ‚ç‚¹å’Œå·¦å³å­æ ‘ï¼Œè¿”å›æ–°å»ºçš„èŠ‚ç‚¹\r\n\r\npublic class Codec {\r\n    // Encodes a tree to a single string.\r\n    public String serialize(TreeNode root) {\r\n        return preorderSerialize(root);\r\n    }\r\n\r\n    private String preorderSerialize(TreeNode root) {\r\n        if (root == null) return \"null\";\r\n        String left = preorderSerialize(root.left);\r\n        String right = preorderSerialize(root.right);\r\n        return String.valueOf(root.val) + ',' + left + ',' + right;\r\n    }\r\n\r\n    public TreeNode deserialize(String data) {\r\n        String[] dataArray = data.split(\",\");\r\n        List<String> dataList = new LinkedList<String>(Arrays.asList(dataArray));\r\n        return preorderDeserialize(dataList);\r\n    }\r\n\r\n    private TreeNode preorderDeserialize(List<String> data) {\r\n        String nodeStr = data.remove(0);\r\n        if (nodeStr.equals(\"null\")) return null;\r\n        return new TreeNode(\r\n            Integer.valueOf(nodeStr),\r\n            preorderDeserialize(data),\r\n            preorderDeserialize(data)\r\n        );\r\n    }\r\n\r\n}\r\n```\r\nT: O(N)\r\nS: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200483485","body":"```javascript\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number[][]}\r\n */\r\n\r\n// T: O(col * log(Max Row))\r\n// S: O(N) \r\nconst verticalTraversal = function(root) {\r\n    if (!root.left && !root.right) return [[root.val]];\r\n    const hash = {};\r\n    dfs(root, 0, 0, hash);\r\n    const res = [];\r\n    Object.keys(hash).sort((a, b) => a - b).forEach(col => {\r\n        res.push(hash[col].sort(sortCol).map(node => node[2]));\r\n    })\r\n    return res;\r\n};\r\n\r\nconst sortCol = (a, b) => {\r\n    if (a[0] !== b[0]) {\r\n        return a[0] - b[0];\r\n    }\r\n    if (a[1] !== b[1]) {\r\n        return a[1] - b[1];\r\n    }\r\n    if (a[2] != b[2]) {\r\n        return a[2] - b[2];\r\n    }\r\n}\r\n\r\nconst dfs = (root, row, col, hash) => {\r\n    if (root == null) return;\r\n    if (hash[col] === undefined) {\r\n        hash[col] = [];\r\n    }\r\n    hash[col].push([col, row, root.val]);\r\n    dfs(root.left, row + 1, col - 1, hash);\r\n    dfs(root.right, row + 1, col + 1, hash);\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201531828","body":"Java\r\n```java\r\nclass Solution {\r\n    Map<Integer, Integer> map = new HashMap();\r\n    public int[] twoSum(int[] nums, int target) {\r\n        for (int i = 0; i < nums.length; i++) {\r\n            Integer anotherHalf = map.get(nums[i]);\r\n            if (anotherHalf != null) {\r\n                return new int[]{anotherHalf, i};\r\n            }\r\n            map.put(target - nums[i], i);\r\n        }\r\n        return new int[0];\r\n    }\r\n}\r\n```\r\nT: O(N)\r\nS: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1202996883","body":"Java\r\n```java\r\n// T: O(NlogK)\r\n// queue size: K\r\n// æ¯æ¬¡å †æ“ä½œ * O(log k)\r\n// å…± N æ¬¡æ“ä½œ\r\n// Sï¼šO(N)\r\n// 1. è®°å½•æ¯ä¸ªæ•°å­—çš„å‡ºç°é¢‘ç‡\r\n// 2. ç»™å‡ºç°é¢‘ç‡æ•°ç»„æ’åº\r\n// - ä¼˜å…ˆé˜Ÿåˆ—æ’åº\r\n//   - é˜Ÿä¼æ²¡æ»¡\r\n//   - é˜Ÿä¼æ»¡äº†ï¼Œå½“å‰é¢‘ç‡ VS é˜Ÿé¡¶\r\n//     - å½“å‰é¢‘ç‡ > é˜Ÿé¡¶ï¼Œå¼¹å‡ºé˜Ÿé¡¶ï¼Œæ”¾å…¥å½“å‰é¢‘ç‡\r\n//     - å½“å‰é¢‘ç‡ <= é˜Ÿé¡¶ï¼Œæ²¡çœ‹è§ï¼Œå¿½ç•¥\r\n\r\nclass Solution {\r\n    HashMap<Integer, Integer> map = new HashMap();\r\n    public int[] topKFrequent(int[] nums, int k) {\r\n        for (int num : nums) {\r\n            map.put(num, map.containsKey(num) ? map.get(num) + 1 : 1);\r\n        }\r\n\r\n        PriorityQueue<int[]> queue = new PriorityQueue(new Comparator<int[]>() {\r\n            @Override\r\n            public int compare(int[] m, int[] n) {\r\n                return m[1] - n[1];\r\n            }\r\n        });\r\n\r\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\r\n            int num = entry.getKey(), count = entry.getValue();\r\n            if (queue.size() < k) {\r\n                queue.offer(new int[]{num, count});\r\n            } else if (queue.peek()[1] < count) {\r\n                 queue.poll();\r\n                queue.offer(new int[]{num, count});\r\n            }\r\n        }\r\n\r\n        int[] res = new int[k];\r\n        for (int i = 0; i < k; i++) {\r\n            res[i] = queue.poll()[0];\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204589807","body":"Java\r\n```java\r\n// ç»„æˆå›æ—‹é•–ï¼ˆå°±æŒ‡ç­‰è¾¹ä¸‰è§’å½¢çš„ä¸¤æ¡è¾¹ï¼‰æ‰€æœ‰çš„ç‚¹éƒ½åœ¨ points å†…\r\n// ä¸¤å±‚å¾ªç¯æš´åŠ›ï¼Œè®¡ç®—ä»»æ„ä¸¤ç‚¹é—´çš„è·ç¦»ï¼ŒæŠŠå…·ä½“ç›¸åŒçš„ç»“ç®—ç»“æœä¿å­˜åˆ°å“ˆå¸Œå†…\r\n// å†å¤„ç†ä¸€ä¸‹å“ˆå¸Œï¼ŒNä¸ªæ•°ä»»å–2ä¸ªæ’åˆ—ï¼šN * (N - 1)\r\n// T: O(N ^ 2)\r\n// S: O(N ^ 2)\r\nclass Solution {\r\n    public int numberOfBoomerangs(int[][] points) {\r\n        int cnt = 0;\r\n\r\n        int n = points.length;\r\n\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        for (int i = 0; i < n; i++) {\r\n            for (int j = 0; j < n; j++) {\r\n                if (i != j) {\r\n                    int[] p0 = points[i];\r\n                    int[] p1 = points[j];\r\n                    int distance = (p0[0] - p1[0]) * (p0[0] - p1[0]) + (p0[1] - p1[1]) * (p0[1] - p1[1]);\r\n                    map.put(distance, map.getOrDefault(distance, 0) + 1);\r\n                }\r\n            }\r\n            for (int val : map.values()) {\r\n                // æ’åˆ— N ä»»å– 2 = n * (n - 1)\r\n                cnt += val * (val - 1);\r\n            }\r\n            map.clear();\r\n        }\r\n\r\n        return cnt;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205965995","body":"Java\r\n```java\r\n// å“ˆå¸Œè¡¨ + åŒæŒ‡é’ˆ\r\n\r\n// éå†æ•´ä¸ªå­—ç¬¦ä¸²\r\n\r\n// é‡åˆ°é‡å¤å­—ç¬¦æ—¶ï¼Œæ£€æŸ¥é‡å¤å­—ç¬¦ä¸Šä¸€æ¬¡å‡ºç°çš„ä½ç½®ï¼Œ\r\n// å³ä¸Šä¸€æ¬¡å‡ºç°çš„ä½ç½® >= å½“å‰leftä½ç½®æ—¶ï¼Œè°ƒæ•´leftï¼š\r\n// w = hash.get(ch) + 1\r\n\r\n// å¾ªç¯ä¸­æ¯”è¾ƒ longest\r\n// å“ˆå¸Œä¿å­˜å½“å‰å­—ç¬¦ä½ç½®\r\n// T:O(N)\r\n// S:O(N)\r\nclass Solution {\r\n    public int lengthOfLongestSubstring(String s) {\r\n        int longest = 0;\r\n        int w = 0;\r\n        HashMap<Character, Integer> hash = new HashMap();\r\n        char[] ss = s.toCharArray();\r\n        for (int r = 0; r < ss.length; r++) {\r\n            char ch = ss[r];\r\n            if (hash.containsKey(ch) && hash.get(ch) >= w) {\r\n                w = hash.get(ch) + 1;\r\n            }\r\n            longest = Math.max(longest, r - w + 1);\r\n            hash.put(ch, r);\r\n        }\r\n        return longest;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1206834822","body":"```typescript\r\n// T: O(s.len * words[0].len)\r\n// S: O(words.len * words[0].len)\r\nfunction findSubstring(s: string, words: string[]): number[] {\r\n  return findMatchedIndexes(s, words);  \r\n};\r\n\r\nconst findMatchedIndexes = (s: string, words: string[]) => {\r\n  const wordLen = words[0].length;\r\n  const tot = words.length * wordLen;\r\n  const wordCounts = countWords(words);\r\n  const matchedIndexes = [];\r\n  for (let i = 0; i + tot <= s.length; i++) {\r\n    const substringHash = splitSubstringToHash(s.substr(i, tot), wordLen);\r\n    if (isHashMatch(substringHash, wordCounts)) {\r\n      matchedIndexes.push(i);\r\n    }\r\n  }\r\n  return matchedIndexes;\r\n};\r\n\r\nconst splitSubstringToHash = (substring: string, wordLen: number) => {\r\n  const sHash = {};\r\n  for (let j = 0; j < substring.length; j=j+wordLen) {\r\n    let substrWord = substring.substr(j, wordLen);\r\n    if (sHash[substrWord]) {\r\n      sHash[substrWord]++;\r\n    } else {\r\n      sHash[substrWord] = 1;\r\n    }\r\n  }\r\n  return sHash;\r\n}\r\n\r\nconst isHashMatch = (hashA: object, hashB: object): boolean => {\r\n  const Akeys = Object.keys(hashA);\r\n  const Bkeys = Object.keys(hashB);\r\n  if (Akeys.length !== Bkeys.length) return false\r\n  let isMatching = true;\r\n  Akeys.find((aKey: string) => {\r\n    if (!hashB[aKey] || hashB[aKey] !== hashA[aKey]) {\r\n      isMatching = false;\r\n      return true;\r\n    }\r\n  })\r\n  Bkeys.find((bKey: string) => {\r\n    if (!hashA[bKey] || hashB[bKey] !== hashA[bKey]) {\r\n      isMatching = false;\r\n      return true;\r\n    }\r\n  })\r\n  return isMatching;\r\n};\r\n\r\nconst countWords = (words: string[]) => {\r\n  const wordsHash = {};\r\n  words.forEach((word: string) => {\r\n    if (wordsHash[word]) {\r\n      wordsHash[word]++;\r\n    } else {\r\n      wordsHash[word] = 1;\r\n    }\r\n  })\r\n  return wordsHash;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207295832","body":"Java\r\n```java\r\n// T: O(N)\r\n// S: O(N)\r\nimport java.util.*;\r\n\r\nclass Solution {\r\n    public int solve(int[] nums, int p) {\r\n        HashMap<Integer, Integer> map = new HashMap();\r\n        map.put(0, -1);\r\n        int total = 0;\r\n        for (int num : nums) {\r\n            // total += num;\r\n            // overflow: nums = [1000000000,1000000000,1000000000], p = 3\r\n            total = (total + num) % p;\r\n        }\r\n        int r0 = total % p;\r\n        if (r0 == 0) return 0;\r\n        int prefix =  0;\r\n        int res = Integer.MAX_VALUE;\r\n\r\n        for (int j = 0; j < nums.length; j++) {\r\n            // avoid overflow: prefix += num[j]\r\n            prefix = (prefix + nums[j]) % p;\r\n            int r = prefix % p;\r\n            int rr = (r - r0 + p) % p;\r\n            if (map.containsKey(rr)) {\r\n                int i = map.get(rr) + 1;\r\n                res = Math.min(res, j - i + 1);\r\n            }\r\n            map.put(prefix % p, j);\r\n        }\r\n        return res >= nums.length ? -1 : res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207451897","body":"Java\r\n```java\r\nclass Solution {\r\n    // T: O(N)\r\n    // S: O(1)\r\n    public ListNode middleNode(ListNode head) {\r\n        if (head.next == null) return head;\r\n        ListNode slow = head, fast = head;\r\n        while (fast != null && fast.next != null) {\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208408259","body":"Java\r\n```java\r\nclass Solution {\r\n    public int removeDuplicates(int[] nums) {\r\n        int n = nums.length;\r\n        if (n == 0) return 0;\r\n        int slow = 1;\r\n        for (int fast = 1; fast < n; fast++) {\r\n            if (nums[fast] != nums[fast - 1]) {\r\n                nums[slow++] = nums[fast];\r\n            }\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n```\r\nT: O(N)\r\nS: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/42#issuecomment-1209817837","body":"T: O(logN)\r\nS: O(1)\r\nåœ¨æœ‰åºæ•°ç»„ä¸­æŸ¥è¯¢ç›®æ ‡å€¼ï¼ŒäºŒåˆ†\r\n```java\r\nclass Solution {\r\n    public int searchInsert(int[] nums, int target) {\r\n        int len = nums.length;\r\n        int left = 0, right = len - 1;\r\n        while (left <= right) {\r\n            int mid = left + ((right - left) >> 1);\r\n            if (nums[mid] >= target) {\r\n                right = mid - 1;\r\n            } else {\r\n                left = mid + 1;\r\n            }\r\n        }\r\n        return right + 1; // target å¯èƒ½å¤§äºæ•°ç»„é‡Œçš„æ‰€æœ‰æ•°ï¼Œæ˜¯ä¸€ä¸ª right è¾¾ä¸åˆ°çš„æ•°\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gelxgx":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185772596","body":"### æ€è·¯\r\nåœ¨jsé‡Œï¼Œç›´æ¥å…ˆå°†æ•°ç»„åˆå¹¶ä¸ºå­—ç¬¦ä¸²ï¼Œç„¶åè½¬åŒ–ä¸ºæ•°å­—è¿›è¡Œç›¸åŠ \r\né¿å…ç²¾åº¦ä¸¢å¤±ï¼ŒæŸ¥äº†ä¸€ä¸‹å¯ä»¥ä½¿ç”¨BigIntæ–¹å¼è§£å†³\r\nç›¸åŠ å®Œæ¯•åï¼Œå†è½¬åŒ–ä¸ºå­—ç¬¦ä¸²ï¼Œåˆ‡åˆ†ä¸ºæ•°ç»„\r\n\r\n### ä»£ç \r\n``` javascript\r\nvar addToArrayForm = function(num, k) {\r\n    let str = num.join('')\r\n    let count = BigInt(str) + BigInt(k)\r\n    let res = count.toString().split('')\r\n    return res\r\n};\r\n```\r\n\r\n### å¤æ‚åº¦åˆ†æ\r\n\r\næ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186213182","body":"### æ€è·¯\né€šè¿‡å¾ªç¯ï¼Œéå†ä¸¤æ¬¡\n### ä»£ç \n\n\n```javascript\nvar shortestToChar = function(s, c) {\n    const n=s.length;\n    const ans=new Array(n).fill(0);\n    for(let i=0,idx=-n;i<n;i++){\n        if(s[i]==c){\n            idx=i;\n        }\n        ans[i]=i-idx;\n    }\n    for(let i=n-1,idx=2*n;i>=0;--i){\n        if(s[i]==c){\n            idx=i;\n        }\n        ans[i]=Math.min(ans[i],idx-i);\n    }\n    return ans;\n};\n\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186533856","body":"### æ€è·¯\n\næŠŠå±æ€§æŒ‚åœ¨åœ¨thisé“¾ä¸Š\næœ€åä¸€ä¸ªæ–¹æ³•ï¼Œé¦–å…ˆæŠŠé•¿åº¦è¿›è¡Œå¯¹æ¯”ï¼Œforå¾ªç¯ä¿®æ”¹å‚æ•°å³å¯\n\n### ä»£ç \n\n\n```javascript\n\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize\n    this.list = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.list.length  >= this.maxSize) {\n        return\n    }\n    this.list.push(x)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    return this.list.length ? this.list.pop() : -1 \n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let length = Math.min(k, this.list.length);\n    for (let i = 0; i < length; i++) {\n        this.list[i] += val;\n    }\n};\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(1)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187636888","body":"### æ€è·¯\r\n\r\nç»´æŠ¤ä¸¤ä¸ªæ ˆï¼Œç”¨æ¥è®°å½•éœ€è¦é‡å¤çš„æ¬¡æ•°å’Œéœ€è¦é‡å¤çš„å­—ç¬¦ä¸²\r\n\r\n### ä»£ç \r\n\r\n\r\n```javascript\r\nvar decodeString = function(s) {\r\n    let numStack = [];              \r\n    let strStack = [];              \r\n\r\n    let num = 0, result = '';\r\n\r\n    for(let i = 0; i < s.length; i++) {\r\n        const item = s[i];\r\n\r\n        if(!isNaN(item)) {             \r\n            num = num * 10 + parseInt(item);\r\n        } else if(item === '[') {\r\n            strStack.push(result);\r\n            result = '';\r\n            numStack.push(num);\r\n            num = 0;\r\n        } else if(item === ']') {\r\n            const repeatTimes = numStack.pop();        \r\n            result = strStack.pop() + result.repeat(repeatTimes);\r\n        } else {\r\n            result += item;\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\n\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œ\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193153150","body":"```javascript\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let a = headA\r\n    let b = headB\r\n    while(a != b) {\r\n        if (a == null) {\r\n            a = headB\r\n        } else {\r\n            a = a.next\r\n        }\r\n        if (b == null) {\r\n            b = headA\r\n        } else {\r\n            b = b.next\r\n        }\r\n    }\r\n    return a\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193348285","body":"```javascript\r\nvar detectCycle = function(head) {\r\n    let slow = fast = head\r\n    while(fast !== null && fast.next !== null) {\r\n        slow = slow.next\r\n        fast = fast.next.next\r\n        if (slow === fast) {\r\n            break\r\n        }\r\n    }\r\n    if (fast == null || fast.next == null) {\r\n        return null\r\n    }\r\n    slow = head\r\n    while(slow !== fast) {\r\n        slow = slow.next\r\n        fast = fast.next\r\n    }\r\n    return slow\r\n};\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199062523","body":"### æ€è·¯\r\nç”¨DFSè§£å†³\r\n```javascript\r\nconst sumNumbers = (root) => {\r\n  const helper = (root, cur) => {\r\n    if (root == null) {\r\n      return 0;\r\n    }\r\n    cur = 10 * cur + root.val;\r\n    if (root.left == null && root.right == null) {\r\n      return cur;\r\n    }\r\n    return helper(root.left, cur) + helper(root.right, cur);\r\n  };\r\n  return helper(root, 0);\r\n};\r\n\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205421988","body":"```javascript\r\nvar numberOfBoomerangs = function(points) {\r\n   \r\n    let res = 0;\r\n    for(let i = 0; i < points.length; i++){\r\n        let map = new Map(); //åº”è¯¥æ”¾åœ¨é‡Œé¢ï¼Œè¡¨ç¤ºæ˜¯iè¿™ä¸ªç‚¹å¯¹åº”å…¶ä»–ç‚¹çš„è·ç¦»å’Œä¸ªæ•°\r\n        for(let j = 0; j < points.length; j++){\r\n            if(j !== i){\r\n                let distance = dis(points[i], points[j]);\r\n                if(map.has(distance)){\r\n                    map.set(distance, map.get(distance) + 1);\r\n                }else{\r\n                    map.set(distance, 1)\r\n                }\r\n            }\r\n        }\r\n        map.forEach((count, distance) => res += count * (count - 1)); //map.forEach((value, key) => {}) value åœ¨ key çš„å‰é¢\r\n    }\r\n    return res;\r\n};\r\n\r\nfunction dis(x, y){\r\n    return (y[1] - x[1])* (y[1] - x[1]) + (y[0] - x[0]) * (y[0] - x[0]); //åæ ‡ä¸¤ç‚¹è·ç¦»ï¼Œæ˜¯+ä¸æ˜¯-\r\n}\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208246632","body":"ç›´æ¥å¿«æ…¢æŒ‡é’ˆ\r\n```javascript\r\nvar middleNode = function(head) {\r\n    let fast = head\r\n    let slow = head\r\n    while(fast !== null && fast.next !== null) {\r\n        fast = fast.next.next\r\n        slow = slow.next\r\n    }\r\n    return slow\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/42#issuecomment-1209684254","body":"æ€è·¯ï¼š\r\nå¾ªç¯æ•°ç»„ï¼Œå¦‚æœé‡åˆ°æ¯”å½“å‰targetç›¸ç­‰æˆ–è€…å¤§äºçš„æ•°ï¼Œè¯´æ˜æ•°å­—è¢«æ‰¾åˆ°æˆ–è€…éœ€è¦åœ¨è¿™ä¸ªåœ°æ–¹è¢«æ›¿æ¢ï¼Œç›´æ¥returnå½“å‰ç´¢å¼•\r\nå¦‚æœéƒ½æ²¡æœ‰ï¼Œé‚£å°±æ˜¯åº”è¯¥è¢«æ’å…¥æœ«å°¾\r\n```javascript\r\nvar searchInsert = function(nums, target) {\r\n    for(let i = 0;i<nums.length;i++) {\r\n        if(nums[i] >= target) {\r\n            return i\r\n        }\r\n    }\r\n    return nums.length\r\n};\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gaominghao":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186218926","body":"## æ€è·¯\nè´ªå¿ƒæ³•ï¼Œæœ€æ¥è¿‘çš„å€¼è¦ä¹ˆåœ¨å·¦è¾¹ï¼Œè¦ä¹ˆåœ¨å³è¾¹\n## ä»£ç \n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] ans = new int[s.length()];\n        int[] left = new int[s.length()];\n        int[] right = new int[s.length()];\n        left[0] = s.charAt(0) == c ? 0:Integer.MAX_VALUE-s.length();\n        for(int i = 1; i < s.length(); i++) {\n            if(s.charAt(i) == c)\n                left[i] = 0;\n            else\n                left[i] = left[i-1]+1;\n        }\n        right[s.length()-1] = s.charAt(s.length()-1) == c?0:Integer.MAX_VALUE-s.length();\n        for(int i = s.length()-2; i>=0;i--) {\n            if(s.charAt(i) == c)\n                right[i] = 0;\n            else\n                right[i] = right[i+1]+1;\n        }\n        for(int i = 0; i < left.length;i++)\n            ans[i] = Math.min(left[i],right[i]);\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186535387","body":"## æ€è·¯\näº†è§£æ ˆçš„å·¥ä½œæ–¹å¼å³å¯\n## ä»£ç \n```java\nclass CustomStack {\n    private int pointer;\n    private int[] stack;\n\n    public CustomStack(int maxSize) {\n        this.stack = new int[maxSize];\n        this.pointer = -1;\n    }\n    \n    public void push(int x) {\n        if(pointer < stack.length-1) {\n            pointer++;\n            this.stack[pointer] = x;\n        }\n\n    }\n    \n    public int pop() {\n        int val;\n        if(pointer < 0)\n            val = -1;\n        else {\n            val = this.stack[pointer];\n            pointer--;\n        }\n        return val;\n    }\n    \n    public void increment(int k, int val) {\n        for(int i = 0; i <= Math.min(k-1,this.pointer); i++)\n            this.stack[i] += val;\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187643314","body":"## æ€è·¯\næ ˆ\n## ä»£ç \n```java\nclass Solution {\n    static Stack<String> strings = new Stack<>();\n    public static String decodeString(String s) {\n        char[] chars = s.toCharArray();\n        for(int i = 0; i < chars.length; i++) {\n            if(chars[i] != ']') {\n                if(Character.isDigit(chars[i])) {\n                    int tempCal = 0;\n                    while(Character.isDigit(chars[i])){\n                        tempCal = tempCal*10 + chars[i] - '0';\n                        i++;\n                    }\n                    i--;\n                    strings.push(String.valueOf(tempCal));\n                } else {\n                    strings.push(String.valueOf(chars[i]));\n                }\n\n            } else {\n                String poped, temp = \"\", newString=\"\";\n                while(!(poped = strings.pop()).equals(\"[\")) {\n                    temp = poped + temp;\n                }\n                poped = strings.pop();\n                int cal = Integer.parseInt(poped);\n                for(int j = 0; j < cal;j++) {\n                    newString += temp;\n                }\n                strings.push(newString);\n            }\n        }\n        String ans = \"\";\n        while(!strings.isEmpty()) {\n            ans = strings.pop()+ans;\n        }\n        return ans;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195485790","body":"```java\nclass LRUCache {\n    class DLinkedNode {\n        int key, value;\n        DLinkedNode prev, next;\n        public DLinkedNode() {}\n        public DLinkedNode(int _key, int _value) {\n            key = _key;\n            value = _value;\n        }\n    }\n\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size, cap;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        size = 0;\n        cap = capacity;\n        //add dummy head and dummyTail\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) return -1;\n        //if key exist, move it to head by using its location store in Hashmap\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            //made a newNode if it does not exist\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            cache.put(key, newNode);\n            addToHead(newNode);\n            ++size;\n            if (size > cap) {\n                DLinkedNode removedTail = removeTail();\n                cache.remove(removedTail.key);\n                --size;\n            }\n        } else {\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DLinkedNode node){\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node){\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DLinkedNode node){\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail(){\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jessie725":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186219318","body":"â€˜â€™â€˜\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int position = -n;\n        int[] res = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == c) {\n                position = i;   \n            }\n            res[i] = i - position;\n        }\n        for (int i = position - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                position = i;   \n            }\n            res[i] = Math.min(res[i], position - i);\n        }\n        return res;\n    }\n}\nâ€™â€˜â€™","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188598361","body":"class MyQueue {\n    Deque<Integer> in;\n    Deque<Integer> out;\n    \n    public MyQueue() {\n        in = new ArrayDeque<>();\n        out = new ArrayDeque<>();\n    }\n    \n    public void push(int x) {\n        in.offerFirst(x);\n    }\n    \n    public int pop() {\n        peek();\n        return out.pollFirst();\n    }\n    \n    public int peek() {\n        if (!out.isEmpty()) {\n            return out.peek();\n        }\n        else {\n            while (!in.isEmpty()) {\n                out.offerFirst(in.pollFirst());\n            }\n            return out.peek();\n        }\n    }\n    \n    public boolean empty() {\n        return in.isEmpty() && out.isEmpty();\n    }\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191033999","body":"```\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) {\n            return head;\n        }\n        int len = 0;\n        ListNode curr = head;\n        while (curr != null && curr.next != null) {\n            curr = curr.next;\n            len++;\n        }\n        len++; // add last\n        curr.next = head;\n        \n        int offset = len - (k % len);\n        curr = head;\n        while (offset > 1) {\n            curr = curr.next;\n            offset--;\n        }\n        ListNode newHead = curr.next;\n        curr.next = null;\n        \n        return newHead;\n    }\n}\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195045354","body":"// Use a double linklist to store nodes in the cache\n// Use a map to store key-node pair to support quick access in list\n// Helper function: insert and remove to opreate map and list\n// Update (remove&insert) the position of opreated (get&put) node in list\n\nclass LRUCache {\n    Map<Integer, Node> map = new HashMap<>();\n    Node head = new Node(0, 0);\n    Node tail = new Node(0, 0);\n    int cap;\n    \n    public LRUCache(int capacity) {\n        cap = capacity;\n        head.next = tail;\n        tail.pre = head;\n    }\n    \n    public int get(int key) {\n        if (map.containsKey(key)) {\n            Node curr = map.get(key);\n            remove(curr);\n            insert(curr);\n            return curr.val;\n        }\n        else {\n            return -1;\n        }\n    }\n    \n    public void put(int key, int value) {\n        if (map.containsKey(key)) {\n            remove(map.get(key));\n            insert(new Node(key, value));\n        }\n        else {\n            if (map.size() == cap) {\n                remove(tail.pre);\n            }\n            insert(new Node(key, value));\n        }\n\n    }\n    \n    public void insert(Node node) {\n        map.put(node.key, node);\n        Node temp = head.next;\n        head.next = node;\n        node.pre = head;\n        node.next = temp;\n        temp.pre = node;\n    }\n    \n    public void remove(Node node) {\n        map.remove(node.key);\n        node.pre.next = node.next;\n        node.next.pre = node.pre;\n    }\n    \n    class Node{\n        int key;\n        int val;\n        Node pre;\n        Node next;\n        public Node(int k, int value) {\n            key = k;\n            val = value;\n        }\n    }\n}\n\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lsunxh":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186219816","body":"# Time: O(N), space O(N)\n        res = [len(s) for i in s]\n        leftC = -1\n        for i in range(len(s)):\n            if s[i] == c:\n                leftC = i\n            if leftC != -1:\n                res[i] = i - leftC\n        rightC = -1\n        for i in range(len(s)-1, -1, -1):\n            if s[i] == c:\n                rightC = i\n            if rightC != -1:\n                res[i] = min(res[i], rightC - i)\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186387091","body":"Code:\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.maxSize = maxSize\n        self.stack = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.stack) < self.maxSize:\n            self.stack = self.stack + [x]\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.stack == []:\n            return -1\n        else:\n            return self.stack.pop(len(self.stack)-1)\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        changeRange = min(len(self.stack), k)\n        for i in range(changeRange):","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186615278","body":"class Solution(object):\n    def getNum(self, s, rInd):\n        res = 0\n        place = 0\n        while rInd >= 0 and s[rInd].isnumeric():\n            res += 10**place*int(s[rInd])\n            place += 1\n            rInd -= 1\n        return res, rInd + 1\n    \n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        # base case: \"a\", \"[a]\", \"3[a]\"\n        # recursive case: \"3[3[a]]\"\n        left = []\n        i = 0\n        disFromLast = len(s)\n        while disFromLast > 0:\n            i = len(s) - disFromLast\n            if s[i] == \"[\":\n                left.append(i)\n            elif s[i] == \"]\":\n                # get the last left bracket\n                lastLeft = left[-1]\n                left = left[:-1]\n                curStr = s[lastLeft+1:i]\n                if s[lastLeft-1].isnumeric():\n                    num, newInd = self.getNum(s, lastLeft-1)\n                else:\n                    num, newInd = 1, i\n                # update s\n                if i == len(s)-1:\n                    s = s[:newInd] + num * s[lastLeft+1:i]\n                else:\n                    s = s[:newInd] + num * s[lastLeft+1:i] + s[i+1:]\n            # updating i depends on length change in s\n            disFromLast -= 1\n        return s","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188506364","body":"class MyQueue(object):\n    def __init__(self):\n        self.reversed = []\n        self.first = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.first.append(x)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.reversed == []:\n            self.reverseFirst()\n        res = self.reversed[-1]\n        self.reversed.pop()\n        return res\n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.reversed == []:\n            self.reverseFirst()\n        res = self.reversed[-1]\n        return res\n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return self.first == [] and self.reversed == []\n    \n    def reverseFirst(self):\n        for i in range(len(self.first)-1, -1, -1):\n            self.reversed.append(self.first[i])\n        self.first = []","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189803513","body":"## Idea: \nWe scan through the array and update a list of chunks, which stores min and max of each chunk. If cur element in arr is greater than or equal to the max of the last elem in chunks, add a new chunk. Otherwise, we find the first occurrence in chunk where the current elem would fit and merge everything in between. We return the length of chunk at the end.\n## Complexity\n**Time:** O(N), not sure because the while loop could be O(N) worst case. \\\n**Space:** O(N).\n## Code\n```\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        # chunks stores (min, max) of each chunk\n        chunks = [(arr[0], arr[0])]\n        for i in range(1, len(arr)):\n            if arr[i] >= chunks[-1][1]:\n                chunks.append((arr[i], arr[i]))\n            else:\n                combineIndex = 0\n                while combineIndex < len(chunks) and arr[i] >= chunks[combineIndex][1]:\n                    combineIndex += 1\n                newMin = min(arr[i], chunks[combineIndex][0])\n                newMax = chunks[-1][1]\n                chunks = chunks[:combineIndex]\n                chunks.append((newMin, newMax))\n        return len(chunks)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190947923","body":"## Time: O(N), Space: O(1)\n```\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if head == None: return head\n        copy = head\n        cnt = 0\n        while copy != None:\n            cnt += 1\n            if copy.next == None:\n                oldTail = copy\n            copy = copy.next\n        k = k % cnt\n        if k == 0: return head\n        \n        oldTail.next = head\n        newTail = head\n        for i in range(cnt - k - 1):\n            newTail = newTail.next\n            \n        newHead = newTail.next\n        newTail.next = None\n        return newHead\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192100147","body":"## Time: O(N), Space: O(1)\n```\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode()\n        dummy.next = head\n        prev = dummy\n        cur = dummy.next\n        while cur != None and cur.next != None:\n            nxt = cur.next.next\n            sec = cur.next\n            prev.next = sec\n            sec.next = cur\n            cur.next = nxt\n            prev = cur\n            cur = nxt\n        return dummy.next\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1192996278","body":"## Inorder\nTime: O(N), Space: O(logN)\n```\nclass Solution(object):\n    def __init__(self):\n        self.curHead = None\n        \n    def convert(self, s, e):\n        if s > e:\n            return None\n        \n        midInd = (s + e) // 2\n        mid = TreeNode()\n        mid.left = self.convert(s, midInd-1)\n        mid.val = self.curHead.val\n        self.curHead = self.curHead.next\n        mid.right = self.convert(midInd+1, e)\n        \n        return mid\n    \n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        cpy = head\n        size = 0\n        while cpy != None:\n            cpy = cpy.next\n            size += 1\n        self.curHead = head\n        return self.convert(0, size-1)\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193409411","body":"## Time: O(N) where N is the length of non-cycle + cycle, Space: O(1)\n```\nclass Solution(object):\n    def detectCycle(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head == None or head.next == None:\n            return None\n        hare, tor = head, head\n        while hare != None and hare.next != None:\n            tor = tor.next\n            hare = hare.next.next\n            if tor == hare:\n                break\n        if tor != hare:\n            return None\n        while head != tor:\n            head = head.next\n            tor = tor.next\n        return head\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194932403","body":"## Hash table with Doubly Linked List\n```\nclass DL(object):\n    def __init__(self, key=None, val=None):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n    \nclass LRUCache(object):\n\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.capacity = capacity\n        self.hash = dict()\n        self.head, self.tail = DL(), DL()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        \n    def moveToHead(self, node):\n        oldPrev, oldNext = node.prev, node.next\n        oldPrev.next = oldNext\n        oldNext.prev = oldPrev\n        \n        self.addToHead(node)\n    \n    def addToHead(self, node):\n        nxt = self.head.next\n        self.head.next = node\n        node.next = nxt\n        nxt.prev = node\n        node.prev = self.head\n    \n    def removeLast(self):\n        res = self.tail.prev.key\n        oldPrev = self.tail.prev.prev\n        oldPrev.next = self.tail\n        self.tail.prev = oldPrev\n        return res\n\n    def get(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: int\n        \"\"\"\n        if key not in self.hash.keys():\n            return -1\n        node = self.hash[key]\n        self.moveToHead(node)\n        return node.val\n    \n\n    def put(self, key, value):\n        \"\"\"\n        :type key: int\n        :type value: int\n        :rtype: None\n        \"\"\"\n        if key in self.hash:\n            self.hash[key].val = value\n            self.moveToHead(self.hash[key])\n        else:\n            if len(self.hash) >= self.capacity:\n                removedKey = self.removeLast()\n                del self.hash[removedKey]\n            newNode = DL(key, value)\n            self.addToHead(newNode)\n            self.hash[key] = newNode\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196147258","body":"### Time: O(N), Space: O(logN) if balanced, O(N) otherwise; N denotes number of nodes\n```\nclass Solution(object):\n    def maxDepthRecursion(self, root, level):\n        if root == None:\n            return level\n        return max(self.maxDepthRecursion(root.left, level+1), self.maxDepthRecursion(root.right, level+1))\n    \n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        return self.maxDepthRecursion(root, 0)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197502178","body":"### Time: O(N), Space: O(N)\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        if p == None:\n            return q == None\n        if q == None:\n            return p == None\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198794181","body":"```\nclass Solution(object):\n    def sumNumbersRecursive(self, root, curSum):\n        if root == None:\n            return 0\n        if root.left == None and root.right == None:\n            return curSum * 10 + root.val\n        return self.sumNumbersRecursive(root.left, curSum * 10 + root.val) + self.sumNumbersRecursive(root.right, curSum * 10 + root.val)\n    \n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        return self.sumNumbersRecursive(root, 0)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200058411","body":"## Iterative\n## Time: O(N), Space: O(N)\n```\nclass Solution(object):\n    def findBottomLeftValue(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        curMaxLevel = 1\n        curVal = root.val\n        queue = deque([(root, 1)])\n        while queue:\n            curNode, curLevel = queue.popleft()\n            if curLevel > curMaxLevel:\n                curVal = curNode.val\n                curMaxLevel = curLevel\n            if curNode.left != None:\n                queue.append((curNode.left, curLevel + 1))\n            if curNode.right != None:\n                queue.append((curNode.right, curLevel + 1))\n        return curVal\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200278526","body":"## BFS O(N) time and space\n```\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if root == None:\n            return ''\n        # deepest leaves don't need null after, while non-deepest ones do\n        queue = deque([root])\n        ans = []\n        level = 0\n        nullsPreLev = 0\n        while queue:\n            curLevNull = 0\n            toPop = 2**level - nullsPreLev\n            for i in range(toPop):\n                curNode = queue.popleft()\n                if curNode:\n                    ans.append(curNode.val)\n                    if curNode.left == None:\n                        queue.append(None)\n                    else:\n                        queue.append(curNode.left)\n                    if curNode.right == None:\n                        queue.append(None)\n                    else:\n                        queue.append(curNode.right)\n                else:\n                    ans.append('n')\n                    curLevNull += 1\n                \n            nullsPreLev = (nullsPreLev + curLevNull) * 2\n            level += 1\n        # remove excess n's\n        while ans[-1] == 'n':\n            ans.pop()\n        return str(ans)\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \n        \"\"\"\n        if data == '':\n            return None\n        data = data[1:-1].split(', ')\n        for i in range(len(data)):\n            if data[i] != \"'n'\":\n                data[i] = int(data[i])\n        res = TreeNode(int(data[0]))\n        if len(data) == 1:\n            return res\n        queue = deque([res])\n        i = 1\n        while queue:\n            toPop = len(queue)\n            for j in range(toPop):\n                curNode = queue.popleft()\n                l = data[i]\n                if i + 1 == len(data):\n                    r = None\n                else:\n                    r = data[i+1]\n                if l != \"'n'\":\n                    newLeft = TreeNode(l)\n                    curNode.left = newLeft\n                    queue.append(newLeft)\n                if r != None and r != \"'n'\":\n                    newRight = TreeNode(r)\n                    curNode.right = newRight\n                    queue.append(newRight)\n                i += 2\n                if i >= len(data): return res\n        return res\n```\n### è¿™é“é¢˜èŠ±æˆ‘å¥½ä¹…æ—¶é—´ã€‚ã€‚","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200600018","body":"### Time: O(N logN), Space: O(N)\n```\nclass Solution(object):\n    def __init__(self):\n        self.list = []\n        \n    def recurse(self, root, col, row):\n        if root == None:\n            return\n        self.list.append((col, row, root.val))\n        self.recurse(root.left, col - 1, row + 1)\n        self.recurse(root.right, col + 1, row + 1)\n        \n    def verticalTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        self.recurse(root, 0, 0)\n        res = [[]]\n        self.list.sort()\n        curCol = self.list[0][0]\n        for c, r, v in self.list:\n            if c == curCol:\n                res[-1].append(v)\n            else:\n                curCol = c\n                res.append([v])\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201936972","body":"### One pass hash map \nTime: O(N), Space: O(N)\n```\nclass Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"    \n        # Hash map\n        numIndices = dict()\n        for i in range(len(nums)):\n            cur = nums[i]\n            looking = target - cur\n            if looking in numIndices:\n                return [numIndices[looking], i]\n            else:\n                numIndices[cur] = i\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203451784","body":"### Time: O(N logK), Space: O(N)\n```python\nclass Solution(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        d = dict()\n        for n in nums:\n            if n in d:\n                d[n] += 1\n            else:\n                d[n] = 1\n        return heapq.nlargest(k, d.keys(), key=d.get) \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204697353","body":"## Time: O(N^2), Space: O(N)\r\n```python\r\nclass Solution(object):\r\n    def distance(self, x1, y1, x2, y2):\r\n        return (x2-x1)**2 + (y2-y1)**2\r\n    \r\n    def numberOfBoomerangs(self, points):\r\n        \"\"\"\r\n        :type points: List[List[int]]\r\n        :rtype: int\r\n        \"\"\"\r\n        if len(points) < 3: return 0\r\n\r\n        res = 0\r\n        for i in range(len(points)):\r\n            dis = dict()\r\n            for j in range(len(points)):\r\n                x1, y1 = points[i]\r\n                x2, y2 = points[j]\r\n                d = self.distance(x1, y1, x2, y2)\r\n                if d in dis:\r\n                    dis[d] += 1\r\n                else:\r\n                    dis[d] = 1\r\n            for count in dis:\r\n                res += dis[count] * (dis[count]-1)\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205996974","body":"### Sliding Window\n```python\nclass Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"        \n        if len(s) < 2:\n            return len(s)\n        l, r = 0, 0\n        count = dict()\n        maxLen = 0\n        while r < len(s) and l <= r:\n            count[s[r]] = count.get(s[r], 0) + 1\n            while count[s[r]] > 1:\n                count[s[l]] -= 1\n                l += 1\n            maxLen = max(maxLen, r - l + 1)\n            r += 1\n        return maxLen\n```\n### Time: O(N), Space: O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207483464","body":"### Time: O(N), Space: O(1)\n```python\nclass Solution(object):\n    def middleNode(self, head):\n        tortoise, hare = head, head\n        while hare != None and hare.next != None:\n            hare = hare.next.next\n            tortoise = tortoise.next\n        return tortoise\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208756606","body":"```python\nclass Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        cnt = 1\n        cur = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] != cur:\n                nums[cnt] = nums[i]\n                cnt += 1\n                cur = nums[i]\n        return cnt\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lanceli424":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186221215","body":"## ä»£ç \n```\nfunction shortestToChar(s: string, c: string): number[] {\n    let result: number[] = [];\n    if (s.length === 0 || c.length === 0) {\n        return result;\n    }\n    let strArray = Array.from(s);\n    let indexs: number[] = [];\n    strArray.forEach((element, index) => {\n        if (element === c) {\n            indexs.push(index);\n        }\n    });\n    for (let i = 0; i <= indexs[0]; i++) {\n        result.push(indexs[0] - i);\n    }\n    for (let i = 0; i <= indexs.length - 2; i++) {\n        let start = indexs[i];\n        let end = indexs[i + 1];\n        for (let i = start + 1; i <= end; i++) {\n            let distance = Math.min(i - start, end - i);\n            result.push(distance);\n        }\n    }\n    for (let i = indexs[indexs.length - 1] + 1; i < strArray.length; i++) {\n        result.push(i - indexs[indexs.length - 1]);\n    }\n    return result;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186531249","body":"## ä»£ç \n```\nclass CustomStack {\n    stack: number[];\n    maxSize: number;\n    size: number;\n    constructor(maxSize: number) {\n        this.stack = [];\n        this.maxSize = maxSize;\n        this.size = 0;\n    }\n\n    push(x: number): void {\n        if (this.size >= this.maxSize) {\n            return;\n        }\n        this.size += 1;\n        this.stack.push(x);\n    }\n\n    pop(): number {\n        if (this.size <= 0) {\n            return -1;\n        }\n        this.size -= 1;\n        return this.stack.pop();\n    }\n\n    increment(k: number, val: number): void {\n        let i = 0;\n        let size = this.size;\n        while (i < size && i < k) {\n            this.stack[i] += val;\n            i++;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1189204290","body":"## ä»£ç \n```\nfunction decodeString(s: string): string {\n    let length: number = s.length;\n    let stack: string[] = [];\n    for(let i: number = 0; i < length; i++) {\n        let char: string = s.charAt(i);\n        if(char === ']') {\n            let str:string = '';\n            while(true) {\n                let item = stack.pop();\n                if(item === '[') {\n                    break;\n                }\n                str = item + str;\n            }\n            let numStr:string = '';\n            while(true) {\n                let item: string = stack.pop();\n                if(!/\\d+/.test(item)) {\n                    stack.push(item);\n                    break;\n                }\n                numStr = item + numStr;   \n            }\n            let count:number = parseInt(numStr, 10);\n            stack.push(str.repeat(count));    \n        }else {\n            stack.push(char);   \n        }\n    }\n    return stack.join('');  \n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189201773","body":"## ä»£ç \n```\nclass MyQueue {\n    outStack: number[]\n    inStack: number[]\n    constructor() {\n        this.outStack = [];\n        this.inStack = [];\n    }\n\n    push(x: number): void {\n        this.inStack.push(x);\n    }\n\n    pop(): number {\n        if (this.outStack.length === 0) {\n            this.in2out();\n        }\n        return this.outStack.pop();\n    }\n\n    peek(): number {\n        if (this.outStack.length === 0) {\n            this.in2out();\n        }\n        return this.outStack[this.outStack.length - 1];\n    }\n\n    empty(): boolean {\n        return this.inStack.length === 0 && this.outStack.length === 0;\n    }\n\n    in2out(): void {\n        while (this.inStack.length > 0) {\n            this.outStack.push(this.inStack.pop());\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190436688","body":"## ä»£ç \n```\nfunction maxChunksToSorted(arr: number[]): number {\n    let count: number = 0;\n    let sorted = [...arr];\n    sorted.sort((a, b) => {\n        return a - b;\n    });\n    const length = arr.length;\n    let sum1: number = 0;\n    let sum2: number = 0;\n    for (let i = 0; i < length; i++) {\n        sum1 += arr[i];\n        sum2 += sorted[i];\n        if (sum1 === sum2) {\n            count++;\n        }\n    }\n    return count;\n};\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193343702","body":"## ä»£ç \n```\nfunction getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {\n    if (headA === null || headB === null) {\n        return null;\n    }\n    let pA: ListNode = headA;\n    let pB: ListNode = headB;\n    while (pA !== pB) {\n        if (pA === null) {\n            pA = headB;\n        } else {\n            pA = pA.next;\n        }\n        if (pB === null) {\n            pB = headA;\n        } else {\n            pB = pB.next;\n        }\n    }\n    return pA;\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1200404281","body":"## ä»£ç \n```\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction maxDepth(root: TreeNode | null): number {\n    if (root === null) {\n        return 0;\n    }\n    let leftDepth: number = maxDepth(root.left);\n    let rightRight: number = maxDepth(root.right);\n    return Math.max(leftDepth, rightRight) + 1;\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1200433575","body":"## ä»£ç \n```\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\n    if (p === null && q === null) {\n        return true;\n    }\n    if (p === null || q === null) {\n        return false;\n    }\n    if (p.val !== q.val) {\n        return false;\n    }\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n};\n```","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200434632","body":"## ä»£ç \n```\nvar serialize = function(root) {\n    return rserialize(root, '');\n};\n\nvar deserialize = function(data) {\n    const dataArray = data.split(\",\");\n    return rdeserialize(dataArray);\n};\n\nconst rserialize = (root, str) => {\n    if (root === null) {\n        str += \"None,\";\n    } else {\n        str += root.val + '' + \",\";\n        str = rserialize(root.left, str);\n        str = rserialize(root.right, str);\n    }\n    return str;\n}\n\nconst rdeserialize = (dataList) => {\n    if (dataList[0] === \"None\") {\n        dataList.shift();\n        return null;\n    }\n\n    const root = new TreeNode(parseInt(dataList[0]));\n    dataList.shift();\n    root.left = rdeserialize(dataList);\n    root.right = rdeserialize(dataList);\n\n    return root;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201351180","body":"## ä»£ç \n```\nvar verticalTraversal = function(root) {\n    const nodes = [];\n    dfs(root, 0, 0, nodes);\n    nodes.sort((tuple1, tuple2) => {\n        if (tuple1[0] !== tuple2[0]) {\n            return tuple1[0] - tuple2[0];\n        } else if (tuple1[1] !== tuple2[1]) {\n            return tuple1[1] - tuple2[1];\n        } else {\n            return tuple1[2] - tuple2[2];\n        }\n    });\n\n    const ans = [];\n    let lastcol = -Number.MAX_VALUE;\n    for (const tuple of nodes) {\n        let col = tuple[0], row = tuple[1], value = tuple[2];\n        if (col !== lastcol) {\n            lastcol = col;\n            ans.push([]);\n        }\n        ans[ans.length - 1].push(value);\n    }\n    return ans;\n}\n\nconst dfs = (node, row, col, nodes) => {\n    if (node === null) {\n        return;\n    }\n    nodes.push([col, row, node.val]);\n    dfs(node.left, row + 1, col - 1, nodes);\n    dfs(node.right, row + 1, col + 1, nodes);\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202873402","body":"## ä»£ç \n```\nvar twoSum = function(nums, target) {\n    let indexs = [];\n    if (!Array.isArray(nums) || nums.length < 2) {\n        return indexs;\n    }\n    if (typeof target !== 'number') {\n        return indexs;\n    }\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] === target) {\n                return [i, j];\n            }\n        }\n    }\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206567307","body":"## ä»£ç \n```\nfunction lengthOfLongestSubstring(s: string): number {\n    let length: number = s.length;\n    let max: number = 0;\n    let set = new Set();\n    let count: number = 0;\n    for(let i: number = 0; i < length; i++) {\n        set.clear();\n        count = 0;\n        if(length - i <= max) {\n            break;\n        }\n        for(let j: number = i; j < length; j++) {\n            let str = s.charAt(j);\n            if(!set.has(str)) {\n                set.add(str);\n                count++\n                continue;\n            }\n            break;\n        }\n        if(count > max) {\n            max = count;\n        }\n    }  \n    return max;\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208280217","body":"## ä»£ç \n```\nfunction middleNode(head: ListNode | null): ListNode | null {\n    let slow: ListNode = head;\n    let fast: ListNode = head;\n    while(slow && slow.next && fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next;\n        fast = fast && fast.next;\n    }\n    return slow;    \n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209535902","body":"## ä»£ç \n```\nfunction removeDuplicates(nums: number[]): number {\n    let length: number = nums.length;\n    for (let i = length - 1; i > 0; i--) {\n        if (nums[i] !== nums[i - 1]) {\n            continue;\n        }\n        nums.splice(i, 1);\n    }\n    return nums.length;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qycoder":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186225472","body":"### æ€è·¯\næ±‚\ns[i]s[i] åˆ°å…¶å·¦ä¾§æœ€è¿‘çš„å­—ç¬¦ c çš„è·ç¦»\ns[i]s[i] åˆ°å…¶å³ä¾§æœ€è¿‘çš„å­—ç¬¦ c çš„è·ç¦»\nä¸¤è€…çš„æœ€å°å€¼\n### ä»£ç \nÂ·Â·Â·\nconst shortestToChar = function(s, c) {\n    const n = s.length;\n    const ans = new Array(n).fill(0);\n\n    for (let i = 0, idx = -n; i < n; ++i) {\n        if (s[i] === c) {\n            idx = i;\n        }\n        ans[i] = i - idx;\n    }\n\n    for (let i = n - 1, idx = 2 * n; i >= 0; --i) {\n        if (s[i] == c) {\n            idx = i;\n        }\n        ans[i] = Math.min(ans[i], idx - i);\n    }\n    return ans;\n};\nÂ·Â·Â·\n## å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦ï¼š O(n)\nç©ºé—´å¤æ‚åº¦ï¼šO(1)\n### \n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qilin88":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186383345","body":"`/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.stack = [];\r\n    this.max = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  if(this.stack.length < this.max){\r\n      this.stack.push(x);\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n   return this.stack.pop() ?? -1;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    k = this.stack.length > k ? k : this.stack.length;\r\n    for(let i = 0; i < k; i++){\r\n        this.stack[i] += val\r\n    }\r\n};\r\n\r\n`\r\n# å¤æ‚åº¦\r\n## æ—¶é—´å¤æ‚åº¦ï¼š\r\n- push O(1)\r\n- pop O(1)\r\n- inc O(n)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)\r\n- push O(1)\r\n- pop O(1)\r\n- inc O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187632034","body":"`var decodeString = function(s) {\r\n    let str = '';\r\n    let num = '';\r\n    let numStack = [];\r\n    let strStack = [];\r\n    for(let i = 0; i < s.length; i++){\r\n\r\n        let item = s[i];\r\n        if(item === '['){ \r\n            numStack.push(Number(num));\r\n            strStack.push(str);\r\n            num = '';\r\n            str = ''\r\n        } else if(!isNaN(s[i])){\r\n            num += item\r\n        }else if(item === ']'){\r\n            str = strStack.pop() + str.repeat(Number(numStack.pop()));\r\n        }else {\r\n            str += item;\r\n        }\r\n    }\r\n    return str;\r\n};`\r\n# æ—¶é—´å¤æ‚åº¦O(n)\r\n# ç©ºé—´å¤æ‚åº¦ O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189791229","body":"`var MyQueue = function() {\r\n    this.stack1 = [];\r\n    this.stack2 = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack1.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    while(this.stack1.length){\r\n        this.stack2.push(this.stack1.pop());\r\n    }\r\n    const result = this.stack2.pop();\r\n    while(this.stack2.length){\r\n       this.stack1.push(this.stack2.pop()); \r\n    }\r\n    return result;\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.stack1[0];\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.stack1.length === 0 \r\n};`\r\n# æ—¶é—´å¤æ‚åº¦\r\n## åˆ é™¤ O(N)  å…¶ä»–O(1)\r\n# ç©ºé—´å¤æ‚åº¦\r\n## O(n)\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189953070","body":"`var maxChunksToSorted = function(arr) {\r\n    let arr2 = arr.slice().sort((a, b) => a - b);\r\n    let sum1 = 0;\r\n    let sum2 = 0;\r\n    let total = 0;\r\n    for(let i = 0; i < arr.length; i++){\r\n       if(sum1 === sum2){\r\n           total++;\r\n            sum1 = 0; \r\n            sum2 = 0;\r\n       } \r\n       sum1 += arr[i];\r\n       sum2 += arr2[i];\r\n    }\r\n    return total;\r\n};`\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n-  ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191063019","body":"`var rotateRight = function(head, k) {\r\n    if(!head || !k){\r\n        return head;\r\n    }\r\n    let len = 1;\r\n    let cur = head;\r\n    while(cur.next){\r\n        len++;\r\n        cur = cur.next;\r\n    }\r\n    k = len - k % len;\r\n    cur = head.next;\r\n    while(k){\r\n        cur = cur.next\r\n        k--;\r\n    }\r\n    let l = cur.next;\r\n    cur.next = null;\r\n    return l;\r\n};`\r\n- æ—¶é—´å¤æ‚åº¦ O(n)\r\n-  ç©ºé—´å¤æ‚åº¦O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1194859161","body":"    var getIntersectionNode = function(headA, headB) {\r\n    if(headB === null || headB === null){\r\n        return null;\r\n    }\r\n    let map = new Set();\r\n    let a = headA;\r\n    let b = headB;\r\n    while(a){\r\n        map.add(a);\r\n        a = a.next;\r\n    }\r\n    while(b){\r\n        if(map.has(b)){\r\n            return b;\r\n        }\r\n        b = b.next;\r\n    }\r\n    return null;\r\n};","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193479362","body":"Â´function(head) {\r\n    if(!head || !head.next){\r\n        return null;\r\n    }\r\n    let map = new Set();\r\n    while(head){\r\n        if(map.has(head)){\r\n            return head;\r\n        }\r\n         map.add(head)\r\n        head = head.next;\r\n    }\r\n    return null;\r\n};Â´\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196075451","body":"    var maxDepth = function(root) {\r\n    if(root === null){\r\n        return 0\r\n    }\r\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n};\r\n\r\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1203653914","body":"    var twoSum = function(nums, target) {\r\n    let map = new Map();\r\n    for(let i = 0; i < nums.length; i++){\r\n        const num = target - nums[i];\r\n        if(map.has(num)){\r\n            return [i, map.get(num)];\r\n        }else{\r\n            map.set(nums[i], i)\r\n        }\r\n    }\r\n    \r\n};","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203642469","body":"    var topKFrequent = function(nums, k) {\r\n    let json = {};\r\n    for(let i = 0; i < nums.length; i++){\r\n        if(json[nums[i]]){\r\n            json[nums[i]]++\r\n        }else{\r\n            json[nums[i]] = 1;\r\n        }\r\n    }\r\n    let arr = []\r\n    for(key in json){\r\n     arr.push({\r\n         value: key,\r\n         total: json[key]\r\n     })\r\n    }\r\n    arr.sort((a, b) => {\r\n        return b.total - a.total\r\n    });\r\n    return arr.splice(0 ,k).map(item => item.value)\r\n};\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206244275","body":"    var lengthOfLongestSubstring = function(s) {\r\n    let max = 0;\r\n    let map = {};\r\n    let l = r = 0;\r\n    while(r < s.length){\r\n        const pos = map[s[r]];\r\n        if(pos >= l && pos <= r){\r\n            l = pos + 1;\r\n        }\r\n        max = Math.max(max, r -l + 1);\r\n        map[s[r]] = r;\r\n        r++;\r\n    }\r\n    return max;\r\n};","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207805103","body":"    var middleNode = function(head) {\r\n    let slow = head;\r\n    let fast = head;\r\n    while(fast && fast.next){\r\n        slow = slow.next;\r\n        fast = fast.next.next\r\n    }\r\n    return slow;\r\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hengheng-yun":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186424382","body":"##### æƒ³æ³•\r\n1. è®¾è®¡ä¸€ä¸ªå¤§å°ä¸º`MaxSize`å¤§å°çš„æ ˆï¼Œå› ä¸ºå›ºå®šå¤§å°ï¼Œæƒ³åˆ°äº†ç”¨æ•°ç»„è¡¨ç¤º\r\n2. è¿›æ ˆï¼Œè¦æ¯”è¾ƒå½“å‰æ ˆæ˜¯å¦æ ˆæ»¡ï¼›å› æ­¤ï¼Œå¦‚ä½•åˆ¤æ–­å½“å‰æ ˆçš„å…ƒç´ ä¸ªæ•°\r\n3. å‡ºæ ˆï¼Œè¦æ¯”è¾ƒå½“å‰æ ˆæ˜¯å¦æ ˆç©ºï¼›\r\n4. ä¸è®ºè¿›æ ˆè¿˜æ˜¯å‡ºæ ˆï¼Œéƒ½è¦æ¯”è¾ƒå½“å‰æ ˆé¡¶å…ƒç´ çš„ç´¢å¼•å€¼ï¼Œå› æ­¤ï¼Œå¯ä»¥è®¾è®¡ä¸€ä¸ªæ ‡å¿—ä½ï¼Œå½“ä½œå®ä¾‹å˜é‡ã€‚åœ¨æ¯æ¬¡è¿›è¡Œæ¯”è¾ƒæ—¶ï¼Œç”¨`++top`æˆ–è€…`top--`å¯ä»¥æŒ‡å‘å½“å‰çš„æ ˆé¡¶ã€‚\r\n##### ä»£ç \r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1; \r\n\r\n    }    \r\n    public void push(int x) {\r\n        //åˆ¤æ–­å½“å‰æ ˆç©ºé—´çš„é•¿åº¦\r\n        if(top!=stack.length-1){\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }    \r\n    public int pop() {\r\n        if(top != -1){\r\n            int element = stack[top];\r\n            top--;\r\n            return element;\r\n        }else return -1;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if(top<k){\r\n            for(int i=0; i<=top; i++){\r\n                stack[i]+=val;\r\n            }\r\n        }else{\r\n            for(int i=0; i<k; i++){\r\n                stack[i]+=val;\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187461656","body":"#### code\r\n```Java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n       /*\r\n       åˆ†å››ç§æƒ…å½¢ï¼Œæ•°å­—ã€å­—æ¯\r\n       '[' å’Œ ']'\r\n       */\r\n\r\n       StringBuilder result = new StringBuilder();\r\n       int num = 0;    \r\n       LinkedList<Integer> multi = new LinkedList<>();\r\n       LinkedList<String> str = new LinkedList<>();\r\n\r\n       for(Character c: s.toCharArray()){\r\n\r\n           if(c>='0' && c<='9') {\r\n               num = num * 10 + Integer.parseInt(c + \"\");\r\n           }else if(c=='['){\r\n               multi.addLast(num);\r\n               str.addLast(result.toString());\r\n               num = 0;\r\n               result = new StringBuilder();\r\n           }else if(c == ']'){\r\n               StringBuilder tmp = new StringBuilder();\r\n               int curTimes = multi.removeLast();\r\n               for(int i=1; i<=curTimes; i++) tmp.append(result);\r\n\r\n               result = new StringBuilder(str.removeLast() + tmp);\r\n \r\n           }else result.append(c);\r\n\r\n       }\r\n       return result.toString();\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189091664","body":"### æƒ³æ³•\r\næ—¢ç„¶è§„å®šä¸¤ä¸ªæ ˆæ¨¡æ‹Ÿé˜Ÿåˆ—ï¼ŒæŠŠå…¶ä¸­ä¸€ä¸ªæ ˆå½“ä½œæ­£å¸¸æ ˆï¼Œåè¿›å…ˆå‡ºï¼Œå¦ä¸€æ ˆæ¨¡æ‹Ÿé€†æ ˆï¼Œå°†æ­£å¸¸æ ˆçš„å…ƒç´ å€’åºæ”¾å…¥é€†æ ˆä¸­\r\n### åœ¨å†™ä»£ç æ—¶é‡åˆ°çš„bug\r\nåœ¨å¤„ç†`pop()`ä»£ç æ—¶ï¼Œç›´æ¥è®©æ ˆ`s_out`ç›´æ¥`pop`äº†ï¼Œæ²¡æœ‰è€ƒè™‘åˆ°`s_out`å¯èƒ½æ˜¯ç©ºæ ˆï¼Œä¼šæŠ¥ç©ºæ ˆå¼‚å¸¸\r\n### ä»£ç \r\n```Java\r\nclass MyQueue {\r\n    private Stack<Integer> s_in;\r\n    private Stack<Integer> s_out;\r\n    int font = 0;  //é˜Ÿåˆ—å¤´å…ƒç´ \r\n\r\n\r\n    public MyQueue() {\r\n        s_in = new Stack<Integer>();\r\n        s_out = new Stack<Integer>();\r\n\r\n    }\r\n    \r\n    public void push(int x) {\r\n        s_in.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        while(!s_in.isEmpty()){\r\n            s_out.push(s_in.pop());\r\n        }\r\n        font = s_out.pop();\r\n\r\n        return font;\r\n\r\n    }\r\n    \r\n    public int peek() {\r\n       if(s_out.isEmpty()){\r\n           while(!s_in.isEmpty()){\r\n               s_out.push(s_in.pop());\r\n           }\r\n       }\r\n       return s_out.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        if(s_in.isEmpty() && s_out.isEmpty()){\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n```\r\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193074003","body":"### é“¾è¡¨å˜BTSï¼ˆå¹³å‡å†å¹³å‡--é€’å½’ï¼‰\r\n æ‰¾åˆ°æ ¹ç»“ç‚¹ï¼Œä¸€åˆ†ä¸ºäºŒï¼Œç„¶åä»è¿™ä¸¤éƒ¨åˆ†å†å¼€å§‹é€’å½’\r\n\r\n### ä»£ç \r\n```Java\r\npublic TreeNode sortedListToBST(ListNode head) {\r\n        if(head == null) return null;\r\n        if(head.next == null) return new TreeNode(head.val);\r\n\r\n        List<Integer> list = new ArrayList<>();\r\n\r\n        while(head!=null){\r\n            list.add(head.val);\r\n            head = head.next;\r\n\r\n        }\r\n        return BuildeTree(0, list.size()-1, list);\r\n    }\r\n\r\n    TreeNode BuildeTree(int left, int right, List<Integer> list){\r\n        if(left > right)return null;\r\n        //ä¸­é—´å…ƒç´ ä¸‹æ ‡\r\n        int mid = left + (right-left+1)/2;\r\n\r\n        TreeNode root = new TreeNode(list.get(mid));\r\n        root.left = BuildeTree(left, mid-1, list);\r\n        root.right = BuildeTree(mid+1, right, list);\r\n\r\n        return root; \r\n\r\n    }\r\n```\r\n ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193235084","body":"### æƒ³æ³•\r\n1. **idea 1** ä»ç›¸äº¤ç‚¹åˆ°`A`å’Œ`B`çš„æœ«å°¾----> ä»åå¾€å‰æ‰¾ï¼Œ ç›´åˆ°æ‰¾åˆ°ä¸åŒçš„å…ƒç´ ä¸ºæ­¢\r\n2. **idea 2** åŒæŒ‡é’ˆ\r\n### ä»£ç \r\n```Java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n\r\n        if(headA==null || headB==null) return null;\r\n        ListNode pA = headA, pB = headB;\r\n        while (pA != pB) {\r\n            pA = pA == null ? headB : pA.next;\r\n            pB = pB == null ? headA : pB.next;\r\n        }\r\n        return pA;\r\n\r\n\r\n        \r\n    //     int flag = 0;\r\n\r\n    //     //åˆ¤æ–­é“¾è¡¨Aå’Œé“¾è¡¨Bä¸ºç©ºé“¾è¡¨\r\n    //     if(headA == null) return null;\r\n    //     if(headB == null) return null;\r\n\r\n    //     //å°†é“¾è¡¨è½¬åŒ–ä¸ºArrayList\r\n    //     Set<Integer> listA = new HashSet<Integer>();\r\n    //     HashSet<Integer> listB = new HashSet<Integer>();\r\n    //     while(headA != null){\r\n    //         listA.add(headA.val);\r\n    //         headA = headA.next;\r\n    //     }\r\n    //      while(headB != null){\r\n    //         listB.add(headB.val);\r\n    //         headB = headB.next;\r\n    //     }\r\n    //     //æ‰¾ç›¸äº¤ç»“ç‚¹, ä¸”åé¢çš„å…ƒç´ å€¼éƒ½ç›¸åŒ\r\n    //     //ä»åå¾€å‰æ‰¾\r\n    //     int i = 1;\r\n    //     while(true){\r\n    //         if(listA[listA.size()-i] == listB[listB.size()-i]){\r\n    //             flag = listA.get(i);\r\n    //             i++;\r\n\r\n    //         }else{\r\n    //             break;\r\n    //         }\r\n    //     }\r\n\r\n    //     return new ListNode(flag);   \r\n    \r\n    // }\r\n    }\r\n}\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197520129","body":"#### idea\r\né€’å½’æ€æƒ³\r\n\r\n#### code\r\n```Java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if(p==null && q==null) return true;\r\n        if (p == null || q == null)  return false;\r\n        if(p.val != q.val){\r\n            return false;\r\n        }else{\r\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n        }\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201945598","body":"```Java\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int target) {\r\n        //æ–¹å¼ä¸€\r\n        // for(int i=0; i<nums.length; ++i){\r\n        //     for(int j=i+1; j<nums.length;++j){\r\n        //         if(nums[i]+nums[j]==target){\r\n        //             return new int[]{i,j};\r\n        //         }\r\n        //     }\r\n        // }\r\n        // return new int[0];\r\n        //æ–¹å¼äºŒ\r\n        HashMap<Integer, Integer> map = new HashMap<Integer,Integer>();\r\n        for(int i=0;i<nums.length;i++){\r\n            if(map.containsKey(target - nums[i])){\r\n                return new int[]{map.get(target - nums[i]), i};\r\n            }\r\n            map.put(nums[i], i);\r\n        }\r\n        return new int[0];\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203929318","body":"```Java\r\nclass Solution {\r\n    public int[] topKFrequent(int[] nums, int k) {\r\n        \r\n    //     Map<Integer, Integer> map = new HashMap<>();\r\n    //     List<Integer> list = new ArrayList<>();\r\n    //     //ç»Ÿè®¡æ¯ä¸ªæ•°å­—å‡ºç°çš„æ¬¡æ•°\r\n    //     for(int i=0;i<nums.length;i++){\r\n    //         map.put(nums[i], map.getOrDefault(nums[i], 0)+1);\r\n    //     }\r\n\r\n    //     //éå†æ¯ä¸€ä¸ªentryå®ä½“ï¼Œå–å‡ºé¢‘æ•°é«˜äºkçš„keyå€¼\r\n    //     Set<Map.Entry<Integer, Integer>> entries = map.entrySet();\r\n    //     Iterator<Map.Entry<Integer, Integer>> iterator = entries.iterator();\r\n    //     while(iterator.hasNext()){\r\n    //         Map.Entry<Integer,Integer> next = iterator.next();\r\n    //         if(next.getValue() >= k){\r\n    //             list.add(next.getKey());\r\n    //         }\r\n    //     }\r\n       \r\n    // }\r\n\r\n\r\n    // \r\n    \r\n        Map<Integer, Integer> occurrences = new HashMap<Integer, Integer>();\r\n        for (int num : nums) {\r\n            occurrences.put(num, occurrences.getOrDefault(num, 0) + 1);\r\n        }\r\n\r\n        // int[] çš„ç¬¬ä¸€ä¸ªå…ƒç´ ä»£è¡¨æ•°ç»„çš„å€¼ï¼Œç¬¬äºŒä¸ªå…ƒç´ ä»£è¡¨äº†è¯¥å€¼å‡ºç°çš„æ¬¡æ•°\r\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {\r\n            public int compare(int[] m, int[] n) {\r\n                return m[1] - n[1];\r\n            }\r\n        });\r\n        for (Map.Entry<Integer, Integer> entry : occurrences.entrySet()) {\r\n            int num = entry.getKey(), count = entry.getValue();\r\n            if (queue.size() == k) {\r\n                if (queue.peek()[1] < count) {\r\n                    queue.poll();\r\n                    queue.offer(new int[]{num, count});\r\n                }\r\n            } else {\r\n                queue.offer(new int[]{num, count});\r\n            }\r\n        }\r\n        int[] ret = new int[k];\r\n        for (int i = 0; i < k; ++i) {\r\n            ret[i] = queue.poll()[0];\r\n        }\r\n        return ret;\r\n    }\r\n\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205205932","body":"```Java\r\nclass Solution {\r\n    public int numberOfBoomerangs(int[][] points) {\r\n        int boomerangs = 0; \r\n\r\n        //è¾¹ç•Œæ¡ä»¶\r\n        //  if(points.length < 3) return -1;\r\n\r\n         for(int[] i : points){\r\n\r\n             Map<Integer, Integer> map = new HashMap<>();\r\n             //å¯¹å¾…æ¯ä¸ªiï¼Œ è®°å½•distanceå‡ºç°çš„æ¬¡æ•°\r\n             for(int[] j : points){\r\n                 int distance = (i[0] - j[0]) * (i[0] - j[0]) + (i[1] - j[1]) * (i[1] - j[1]);\r\n                map.put(distance, map.getOrDefault(distance, 0) + 1);\r\n             }\r\n             Set<Map.Entry<Integer, Integer>> entries = map.entrySet();\r\n             for(Map.Entry<Integer, Integer> entry : entries){\r\n                int count = entry.getValue();\r\n                boomerangs += count * (count-1);\r\n             }\r\n\r\n         }\r\n         return boomerangs;\r\n    }\r\n\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"smz1995":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186457384","body":"**æ€è·¯**\r\næ ˆçš„åŸºæœ¬æ“ä½œ\r\n\r\n**Pythonä»£ç **\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack:\r\n            return -1\r\n        else:\r\n            return self.stack.pop()\r\n        \r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k,len(self.stack())):\r\n            self.stack[i]+=val\r\n        \r\n**å¤æ‚åº¦**\r\n\r\n- æ—¶é—´ï¼šO(N)\r\n\r\n- ç©ºé—´ï¼šO(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188753934","body":"## æ€è·¯\r\n\r\n> + ä¸¤ä¸ªæ ˆä¸€ä¸ªè¾“å…¥ä¸€ä¸ªè¾“å‡º\r\n\r\n##ä»£ç \r\n\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack_in=[]\r\n        self.stack_out=[]\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack_in.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.stack_out:\r\n            return self.stack_out.pop()\r\n        while self.stack_in:\r\n            temp=self.stack_in.pop()\r\n            self.stack_out.append(temp)\r\n        return self.stack_out.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        ans=self.pop()\r\n        self.stack_out.append(ans)\r\n        return ans\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return len(self.stack_in)==0 and len(self.stack_out)==0\r\n\r\n\r\n## å¤æ‚åº¦\r\n\r\n> + æ—¶é—´å¤æ‚åº¦: O(n)\r\n> + ç©ºé—´å¤æ‚åº¦: O(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193280445","body":"## æ€è·¯\r\n\r\n> + åŒæŒ‡é’ˆ\r\n\r\n## ä»£ç \r\n\r\n```\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        a,b=headA,headB\r\n        while a!=b:\r\n            if a:\r\n                a=a.next\r\n            else:\r\n                a=headB\r\n            if b:\r\n                b=b.next\r\n            else:\r\n                b=headA\r\n        return a\r\n\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n> + æ—¶é—´å¤æ‚åº¦: O(n)\r\n> + ç©ºé—´å¤æ‚åº¦: O(1)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200124118","body":"## æ€è·¯\r\n\r\n> + ä»å³å‘å·¦å±‚åºéå†ï¼Œå–æœ€åä¸€ä¸ªå…ƒç´ \r\n\r\n## ä»£ç \r\n\r\n```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        if not root:\r\n            return None\r\n        q=deque()\r\n        q.append(root)\r\n        res=0\r\n        while q:\r\n            size=len(q)\r\n            while size>0:\r\n                cur=q.popleft()\r\n                res=cur.val\r\n                if cur.right:\r\n                    q.append(cur.right)\r\n                if cur.left:\r\n                    q.append(cur.left)\r\n                size-=1\r\n        return res\r\n\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207867206","body":"## æ€è·¯\r\n\r\n> + å¿«æ…¢æŒ‡é’ˆ\r\n\r\n## ä»£ç \r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def middleNode(self, head: ListNode) -> ListNode:\r\n        slow = fast = head\r\n        while fast and fast.next:\r\n            slow=slow.next\r\n            fast=fast.next.next\r\n        return slow\r\n\r\n```\r\n## å¤æ‚åº¦\r\n\r\n> + æ—¶é—´å¤æ‚åº¦:O(n) \r\n> + ç©ºé—´å¤æ‚åº¦:O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"size-of":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186457895","body":"\n```javascript\n\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize\n    this.stack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.stack.length >= this.maxSize) return\n    this.stack.push(x)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (!this.stack.length) return -1\n    return this.stack.pop()\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let n = this.stack.length < k ? this.stack.length : k\n\n    for (let i = n - 1; i >= 0; i--) {\n        this.stack[i] += val\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n```\n\n\n**å¤æ‚åº¦åˆ†æ**\nnä¸ºæ•°ç»„é•¿åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šPush:$O(1)$, Pop:$O(1)$, increment:$O(k)$\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187379263","body":"\n## ä»£ç \n\n- è¯­è¨€æ”¯æŒï¼šJavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    let stack = []\n    let num = 0, char = '', cur = '', top \n\n    for (let i = 0; i < s.length; i++) {\n        cur = s.charAt(i)\n\n        if (typeof +cur === 'number' && !isNaN(+cur)) {\n            num = num * 10 + +cur\n        } else if (cur === '[') {\n            stack.push([num, char])\n            num = 0\n            char = ''\n        } else if (cur === ']') {\n            top = stack.pop()\n            char = top[1] + new Array(top[0]).fill(char).join('')\n        } else {\n            char += cur\n        }\n    }\n\n    return char\n};\n\n```\n\n\n**å¤æ‚åº¦åˆ†æ**\n\nä»¤ n ä¸ºæ•°ç»„é•¿åº¦ã€‚\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189149637","body":"- è¯­è¨€æ”¯æŒï¼šJavaScript\n\nJavaScript Code:\n\n```javascript\n\nvar MyQueue = function() {\n    this.a = []\n    this.b = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.a.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if (this.b.length) return this.b.pop()\n    while (this.a.length) {\n        this.b.push(this.a.pop())\n    }\n    return this.b.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if (this.b.length) return this.b[this.b.length - 1]\n    while (this.a.length) {\n        this.b.push(this.a.pop())\n    }\n\n    return this.b[this.b.length - 1]\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.a.length && !this.b.length\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n\n```\n\n\n**å¤æ‚åº¦åˆ†æ**\n\nä»¤ n ä¸ºæ•°ç»„é•¿åº¦ã€‚\n\n- æ—¶é—´å¤æ‚åº¦ï¼šå‡æ‘Š$O(1)$\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190407922","body":"å•è°ƒæ ˆ\n## ä»£ç \n\n- è¯­è¨€æ”¯æŒï¼šJavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n  const stack = []\n\n  for (let i = 0; i < arr.length; i++) {\n    if (!stack.length || stack[stack.length - 1] <= arr[i]) {\n      stack.push(arr[i])\n    } else {\n      const cur = stack.pop()\n      while(stack[stack.length - 1] > arr[i]) {\n        stack.pop()\n      }\n      stack.push(cur)\n    }\n  }\n  return stack.length\n};\n\n```\n\n\n**å¤æ‚åº¦åˆ†æ**\n\nä»¤ n ä¸ºæ•°ç»„é•¿åº¦ã€‚\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194157935","body":"\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n    let quick = head, slow = null\r\n\r\n    while (quick !== slow && quick.next) {\r\n        slow = slow ? slow.next : head.next\r\n        quick = quick.next.next\r\n        if (!quick) return null\r\n    }\r\n    if (!quick || !quick.next) return null\r\n    quick = head\r\n    while (quick !== slow) {\r\n        quick = quick.next\r\n        slow = slow.next\r\n    }\r\n\r\n    return quick\r\n};\r\n\r\n```\r\n\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n\r\nä»¤ n ä¸ºé“¾è¡¨é•¿åº¦ã€‚\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$\r\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moyuanhua":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186475438","body":"/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize;\n    this.arr = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.maxSize === this.arr.length){\n        return\n    }\n    this.arr.push(x)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.arr.length === 0){\n        return -1;\n    }\n    return this.arr.pop()\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let min = Math.min(k,this.arr.length );\n    for(let i=0;i< min;i++){\n        this.arr[i] += val;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186981987","body":"```javascript\nvar isNumber = function(s) {\n    return !isNaN(Number(s))\n}\n\nvar getStackStrStr = function(stack= []){\n    // return stack.join();\n    let res = '';\n    while(stack.length){\n        res+=stack.shift()\n    }\n    return res;\n}\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n  \n    let resStack = []\n    for(let i=0;i<s.length;i++){\n        let char = s[i];\n        if(char === ']'){\n            // å­—ç¬¦å‡ºæ ˆ\n            let tempchar = resStack.pop();\n            let tempstr = '';\n            while(tempchar !== '['){\n                tempstr = tempchar + tempstr\n                tempchar = resStack.pop();\n            }\n            tempchar = resStack.pop();\n            \n            let tempNum = ''\n            while(isNumber(tempchar)){\n                tempNum = tempchar + tempNum\n                tempchar = resStack.pop()\n            }\n            resStack.push(tempchar);\n            tempNum = Number(tempNum);\n\n\n            for(let i=0;i<tempNum;i++){\n                resStack.push(tempstr)\n            }\n\n\n            \n        }else{\n            resStack.push(char)\n        }\n    }\n    return resStack.join('')\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188889674","body":"```javascript\nvar MyQueue = function() {\n    this.pushStack = []\n    this.popStack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.pushStack.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.popStack.length === 0){\n        while(this.pushStack.length){\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    const last = this.pop();\n    this.popStack.push(last)\n    return last\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.popStack.length === 0 && this.pushStack.length === 0\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191182240","body":"```JavaScript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    let n = 1;\n    if(!head || !head.next || k === 0){\n        return head\n    }\n    let rightEnd = head;\n    while(rightEnd.next){\n        rightEnd = rightEnd.next;\n        n++\n    }\n\n    let add = n - k % n;\n    if(add === n){ // \n        return head\n    }\n\n    rightEnd.next = head;\n    while(add--){\n        rightEnd = rightEnd.next;\n    }\n    head = rightEnd.next;\n    rightEnd.next = null\n    return head\n\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196195808","body":"```JavaScript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    if(!root) return 0\n    return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202242622","body":"```JavaScript\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    let map = {};\n   \n    for(let index = 0;index < nums.length;index++){\n        let item = nums[index];\n         const value = target - item;\n        if(map[value] !== undefined){\n            return [map[value],index]\n        }\n        map[item] = index\n    }\n    console.log(map)\n    return []\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204555414","body":"class Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ans = 0\n        for p in points:\n            cnt = defaultdict(int)\n            for q in points:\n                dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1])\n                cnt[dis] += 1\n            for m in cnt.values():\n                ans += m * (m - 1)\n        return ans\n\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207652695","body":"```JavaScript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function(head) {\n    let slow = head;\n    let fast = head;\n\n    while(fast && fast.next){\n        slow = slow.next;\n        fast = fast.next.next\n    }\n    return slow\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209104839","body":"```JavaScirpt\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    if(nums.length <= 1){\n        return nums.length;\n    }\n    let slow = 0, fast = 1;\n    while(fast < nums.length){\n        if(nums[fast] != nums[slow]){\n            slow++\n            nums[slow] = nums[fast]\n        }\n        fast++\n    }\n    return slow + 1\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"9vivian88":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1186465529","body":"class Solution:\r\n    def addToArrayForm(self, num: list, k: int) -> list:\r\n        m = len(num)\r\n        num = num[::-1]\r\n        i = 0\r\n        sum = 0\r\n        res = []\r\n        for n in num:\r\n            sum += n * 10 ** i\r\n            i += 1\r\n        ret = sum + k\r\n\r\n        while ret > 0:\r\n            yushu = ret % 10\r\n            ret //= 10\r\n            res.append(yushu)\r\n\r\n        return res[::-1]","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186466400","body":" def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        c_index = []\r\n        str_len = len(s)\r\n        for i in range(str_len):\r\n            if s[i]==c:\r\n                c_index.append(i)\r\n\r\n        answer = [0]*str_len\r\n        for j in range(str_len):\r\n            answer[j]= min([abs(j-m) for m in c_index])\r\n        return answer","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186475633","body":"class CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.val = []\r\n        self.size = 0\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size < self.maxSize:\r\n            self.val.append(x)\r\n            self.size +=1\r\n        else:\r\n            return -1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.size ==0:\r\n            return -1\r\n        else:\r\n            pop_val = self.val[-1]\r\n            del self.val[-1]\r\n            self.size -=1\r\n            return pop_val\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        max_inc_num = min(k,self.size)\r\n        for i in range(max_inc_num):\r\n            self.val[i] = self.val[i] + val","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187614280","body":"class Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = \"\", 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)            \r\n            else:\r\n                res += c\r\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188961888","body":"class MyQueue(object):\r\n\r\n    def __init__(self):\r\n        self.stk =[]\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.stk.append(x)\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if self.stk is not None:\r\n            return self.stk.pop(0)\r\n\r\n\r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if  self.stk is not None:\r\n            return self.stk[0]\r\n\r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        :rtype: bool\r\n        \"\"\"\r\n        if not self.stk:\r\n            return True\r\n        else:\r\n            return False\r\nå¤æ‚åº¦\r\næ—¶é—´å¤æ‚åº¦O(1)\r\nç©ºé—´å¤æ‚åº¦Oï¼ˆnï¼‰","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190422747","body":"class Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        \r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]: \r\n                head = stack.pop()\r\n                while stack and num < stack[-1]: stack.pop()\r\n                stack.append(head)\r\n            else: stack.append(num)\r\n        return len(stack)\r\nå¤æ‚åº¦\r\næ—¶é—´å¤æ‚åº¦O(n)\r\nç©ºé—´å¤æ‚åº¦O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191614812","body":"# Definition for singly-linked list.\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        cur =head\r\n        n = 1\r\n        while  cur.next:    \r\n            cur = cur.next\r\n            n+=1\r\n        add = n - k%n\r\n        if add==n:\r\n            return head\r\n        \r\n        cur.next = head\r\n        # æ‰¾åˆ°ç¬¬kä¸ªä½ç½®\r\n     \r\n        while add:\r\n            cur = cur.next\r\n            add-=1\r\n        ret = cur.next\r\n        cur.next = None\r\n        return ret\r\nå¤æ‚åº¦\r\nç©ºé—´å¤æ‚åº¦Oï¼ˆnï¼‰\r\næ—¶é—´å¤æ‚åº¦Oï¼ˆkï¼‰","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192692489","body":"class ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        newHead = head.next\r\n        head.next = self.swapPairs(newHead.next)\r\n        newHead.next = head\r\n        return newHead\r\nå¤æ‚åº¦\r\næ—¶é—´å¤æ‚åº¦Oï¼ˆnï¼‰\r\nç©ºé—´å¤æ‚åº¦Oï¼ˆ1ï¼‰","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193132272","body":"class Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        def getMedian(left: ListNode, right: ListNode) -> ListNode:\r\n            fast = slow = left\r\n            while fast != right and fast.next != right:\r\n                fast = fast.next.next\r\n                slow = slow.next\r\n            return slow\r\n        \r\n        def buildTree(left: ListNode, right: ListNode) -> TreeNode:\r\n            if left == right:\r\n                return None\r\n            mid = getMedian(left, right)\r\n            root = TreeNode(mid.val)\r\n            root.left = buildTree(left, mid)\r\n            root.right = buildTree(mid.next, right)\r\n            return root\r\n        \r\n        return buildTree(head, None)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193279899","body":"class Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        A, B = headA, headB\r\n        while A != B:\r\n            A = A.next if A else headB\r\n            B = B.next if B else headA\r\n        return A","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193997948","body":"class Solution(object):\r\n    def detectCycle(self, head):\r\n        fast, slow = head, head\r\n        while True:\r\n            if not (fast and fast.next): return\r\n            fast, slow = fast.next.next, slow.next\r\n            if fast == slow: break\r\n        fast = head\r\n        while fast != slow:\r\n            fast, slow = fast.next, slow.next\r\n        return fast\r\n\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196825512","body":"class Solution:\r\n    def maxDepth(self, root):\r\n        if root is None: \r\n            return 0 \r\n        else: \r\n            left_height = self.maxDepth(root.left) \r\n            right_height = self.maxDepth(root.right) \r\n            return max(left_height, right_height) + 1 \r\n\r\nä½œè€…ï¼šLeetCode-Solution\r\né“¾æ¥ï¼šhttps://leetcode.cn/problems/maximum-depth-of-binary-tree/solution/er-cha-shu-de-zui-da-shen-du-by-leetcode-solution/\r\næ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰\r\nè‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198020734","body":"class Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        elif not p or not q:\r\n            return False\r\n        elif p.val != q.val:\r\n            return False\r\n        else:\r\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199424217","body":"class Solution:\r\n    def sumNumbers(self, root: TreeNode) -> int:\r\n        res = 0\r\n        path = []\r\n        def backtrace(root):\r\n            nonlocal res\r\n            if not root: return # èŠ‚ç‚¹ç©ºåˆ™è¿”å›\r\n            path.append(root.val)\r\n            if not root.left and not root.right: # é‡åˆ°äº†å¶å­èŠ‚ç‚¹\r\n                res += get_sum(path)\r\n            if root.left: # å·¦å­æ ‘ä¸ç©º\r\n                backtrace(root.left)\r\n            if root.right: # å³å­æ ‘ä¸ç©º\r\n                backtrace(root.right)\r\n            path.pop()\r\n\r\n        def get_sum(arr):\r\n            s = 0\r\n            for i in range(len(arr)):\r\n                s = s * 10 + arr[i]\r\n            return s\r\n\r\n        backtrace(root)\r\n        return res\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200164510","body":"class Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        curVal = curHeight = 0\r\n        def dfs(node: Optional[TreeNode], height: int) -> None:\r\n            if node is None:\r\n                return\r\n            height += 1\r\n            dfs(node.left, height)\r\n            dfs(node.right, height)\r\n            nonlocal curVal, curHeight\r\n            if height > curHeight:\r\n                curHeight = height\r\n                curVal = node.val\r\n        dfs(root, 0)\r\n        return curVal","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guxuehua":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186494700","body":"#### JS  \n```\n function CustomStack(maxSize) {\n    this.arr = [];\n    this.maxSize = maxSize\n  }\n  CustomStack.prototype.push = function(x) {\n    const len = this.arr.length;\n    if (len < maxSize) { \n      this.arr[len] = x;\n    }\n    return;\n  }\n  CustomStack.prototype.pop = function () {\n    const len = this.arr.length;\n    if (len > 0) {\n      return this.arr.splice(0, 1);\n    }\n    return -1;\n  }\n  CustomStack.prototype.increment = function (k, val) {\n    return this.arr.map = function(item, index) {\n      if (index < k) {\n        return item + val;\n      }\n      return item;\n    }\n  }\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187654709","body":"JSå®ç°\r\n```\r\nfunction decodeStr (s) {\r\n  const repetStack = [];\r\n  const resStack = [];\r\n\r\n  let res = '';\r\n  let repet = 0;\r\n\r\n  for(let i = 0; i < s.length; i++) {\r\n    let cur = s.charAt(i);\r\n    if (cur === '[') {\r\n      repetStack.push(repet);\r\n      resStack.push(res);\r\n      repet = '';\r\n      res = '';\r\n    } else if (cur === ']') {\r\n      let count = repetStack.pop();\r\n      let tempStr = '';\r\n      for(let j = 0; j < count; j++) {\r\n        tempStr += res;\r\n      }\r\n      res = resStack.pop() + tempStr;\r\n    } else if (cur >= '0' && cur <= '9') {\r\n      repet = repet * 10 + (cur-'0')\r\n    } else {\r\n      res += cur;\r\n    }\r\n  }\r\n  return res;\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195627633","body":"```\r\nvar LRUCache = function(capacity) {\r\n  this.max = capacity;\r\n  this.map = new Map();\r\n};\r\n\r\nLRUCache.prototype.get = function(key) {\r\n  if (this.map.has(key)) {\r\n      const value = this.map.get(key);\r\n      this.map.delete(key);\r\n      this.map.set(key, value);\r\n      return value;\r\n  }\r\n  return -1;\r\n};\r\n\r\nLRUCache.prototype.put = function(key, value) {\r\n  if (this.map.has(key)) {\r\n      this.map.delete(key);\r\n  }\r\n  this.map.set(key, value);\r\n  if(this.map.size > this.max){\r\n      this.map.delete(this.map.keys().next().value)\r\n  }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kirosola":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186500203","body":"```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        self.top -= 1\r\n        return self.stk[self.top + 1]\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, self.top + 1)\r\n        for i in range(lim):\r\n            self.stk[i] += val\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biscuit279":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186511542","body":"# æ€è·¯:ç”¨åˆ—è¡¨æ¨¡æ‹Ÿ\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.data = []\r\n        self.maxSize=maxSize\r\n        self.size = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size<self.maxSize:\r\n            self.data.append(x)\r\n            self.size += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.size == 0:\r\n            return -1\r\n        else:\r\n            ans = self.data.pop()\r\n            self.size -= 1\r\n            return ans\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if self.size < k:\r\n            for i in range(self.size):\r\n                self.data[i] += val\r\n        else:\r\n            for i in range(k):\r\n                self.data[i] += val\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```\r\næ—¶é—´å¤æ‚åº¦ï¼šOï¼ˆkï¼‰\r\nç©ºé—´å¤æ‚åº¦ï¼šOï¼ˆ1ï¼‰","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190449428","body":"# æ€è·¯ï¼šè®¡æ•°æ’åºå‰åçš„æ•°ç»„å‰iä¸ªå…ƒç´ ï¼Œè®¡æ•°ç›¸åŒå°±å¯ä»¥åˆ†å—\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        ans = 0\r\n        count_a = collections.defaultdict(int)\r\n        count_b = collections.defaultdict(int)\r\n        for a,b in zip(arr, sorted(arr)):\r\n            count_a[a] += 1\r\n            count_b[b] += 1\r\n            if count_a == count_b:\r\n                ans += 1 \r\n        return ans\r\n        \r\n```\r\næ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)\r\nç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193062429","body":"# æ€è·¯\r\næ‰¾åˆ°é“¾è¡¨ç‚¹ï¼Œå·¦è¾¹çš„å½“å·¦å­æ ‘ï¼Œå³è¾¹çš„å½“å³å­æ ‘\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head:\r\n            return head\r\n        pre,slow,fast = None,head,head\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            pre = slow\r\n            slow = slow.next\r\n        if pre:\r\n            pre.next = None\r\n        node = TreeNode(slow.val)\r\n        if slow == fast :\r\n            return node\r\n        node.left = self.sortedListToBST(head)\r\n        node.right = self.sortedListToBST(slow.next)\r\n        return node\r\nÂ·Â·Â·\r\næ—¶é—´å¤æ‚åº¦:O(nlogn)\r\nç©ºé—´å¤æ‚åº¦ï¼šO(logn)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194089892","body":"# æ€è·¯\r\nå¿«æ…¢æŒ‡é’ˆï¼Œç¬¬ä¸€æ¬¡ç›¸é‡åå¿«æŒ‡é’ˆç§»åŠ¨åˆ°å¤´éƒ¨ï¼Œæ¥ä¸‹æ¥å¿«æ…¢æŒ‡é’ˆæ¯æ¬¡èµ°ä¸€æ­¥ï¼Œå†æ¬¡ç›¸é‡å°±æ˜¯ç¯çš„èµ·ç‚¹\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        fast = head\r\n        slow = head\r\n        x = None\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            if slow == fast:\r\n                x = fast\r\n                break\r\n        if not x:\r\n            return None\r\n        fast = head\r\n        while slow != fast:\r\n            slow=slow.next\r\n            fast = fast.next\r\n        return slow\r\n```\r\næ—¶é—´å¤æ‚åº¦ï¼šO(1)\r\nç©ºé—´å¤æ‚åº¦ï¼šOï¼ˆ1ï¼‰","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196671066","body":"# æ€è·¯\r\né€’å½’è¿”å›å·¦å³å­æ ‘çš„æœ€å¤§æ·±åº¦\r\n```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root:\r\n            return 0\r\n        return max(self.maxDepth(root.left),self.maxDepth(root.right)) + 1\r\n```\r\næ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\nç©ºé—´å¤æ‚åº¦ï¼šO(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197897896","body":"# æ€è·¯ï¼š\r\né€’å½’æ¯”è¾ƒä¸¤é¢—æ ‘çš„å­æ ‘èŠ‚ç‚¹çš„å€¼ã€‚ç»“æŸé€’å½’çš„æ¡ä»¶ä¸ºéƒ½æ²¡æœ‰å­æ ‘\r\n```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        if not p or not q:\r\n            return False\r\n        return  p.val == q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\r\n```\r\næ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\nç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202280599","body":"æ€è·¯ï¼š\r\nå“ˆå¸Œè¡¨ï¼Œä½†æ˜¯è¦åœ¨ifåˆ¤æ–­ä¹‹åæ›´æ–°ï¼Œå¦åˆ™ä¸¤ä¸ªä¸€æ ·çš„æ•°å­—ä¼šæŠ¥é”™ã€‚\r\n```python\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        remain = {}\r\n        ans = []\r\n        for i,num in enumerate(nums):  \r\n            if remain.get(num) is not None:\r\n                ans=[i, remain[num]]\r\n            remain[target-num] = i\r\n        return ans\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203996686","body":"# æ€è·¯\r\nå­—å…¸ï¼ŒæŒ‰é¢‘ç‡æ’åº\r\n```python\r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        freq = {}\r\n        for num in nums:\r\n            if num not in freq:\r\n                freq[num]  = 1\r\n            else:\r\n                freq[num] += 1\r\n        sorted_freq = sorted(freq.items(), key=lambda x: x[1], reverse = True)\r\n        ans = [item[0] for item in sorted_freq[0:k]] \r\n        return ans\r\n```\r\næ—¶é—´å¤æ‚åº¦ï¼šOï¼ˆnlognï¼‰\r\nç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206015046","body":"# æ€è·¯\r\næ»‘åŠ¨çª—å£ï¼Œå‘ç°é‡å¤çš„å­—ç¬¦å°±å·¦ç§»çª—å£çš„èµ·ç‚¹\r\n```python\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        if not s:\r\n            return 0\r\n        left = 0\r\n        window = set()\r\n        max_len, current_len = 0, 0\r\n        for i in range(len(s)):\r\n            current_len += 1\r\n            while s[i] in window:\r\n                window.remove(s[left])\r\n                left += 1\r\n                current_len -= 1\r\n            if current_len > max_len:\r\n                max_len = current_len\r\n            window.add(s[i])\r\n        return max_len\r\n\r\n```\r\næ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\nç©ºé—´å¤æ‚åº¦ï¼šO(k)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208102947","body":"# æ€è·¯\r\nå¿«æ…¢æŒ‡é’ˆï¼Œå¿«æŒ‡é’ˆåˆ°å°¾éƒ¨ï¼Œæ»¡æŒ‡é’ˆåˆ°ä¸­é—´\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def middleNode(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        fast, slow = head, head\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n        return slow\r\n```\r\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\r\nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maoting":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1186450526","body":"### æ€è·¯ï¼š\r\nä»åå¾€å‰è¿›ä½ï¼Œå°†kè½¬åŒ–æˆå­—ç¬¦ä¸²ï¼Œå¤„ç†è¿›ä½\r\n\r\n### ä»£ç \r\n```js\r\n   var addToArrayForm = function(num, k) {\r\n    let kIndex = (k + '').length - 1;\r\n    let nIndex = num.length - 1;\r\n    // è¿›ä½\r\n    let carrayBit = 0;\r\n    for (; kIndex >= 0 && nIndex >=0 ; kIndex--, nIndex--) {\r\n        let sum = carrayBit + (+(k+'').charAt(kIndex)) + num[nIndex];\r\n        num[nIndex] = sum % 10;\r\n        carrayBit = Math.floor(sum / 10);\r\n    }\r\n    // ç›¸åŒä½\r\n    if (kIndex <0 && nIndex < 0) {\r\n        return carrayBit ? [carrayBit, ...num] : num;\r\n    }\r\n    // kä½æ•°å¤š\r\n    else if (kIndex <0) {\r\n        for (; nIndex >=0 ; nIndex--) {\r\n            let sum = carrayBit + num[nIndex];\r\n            num[nIndex] = sum % 10;\r\n            carrayBit = Math.floor(sum / 10);\r\n        }\r\n        return carrayBit ? [carrayBit, ...num] : num;\r\n    }\r\n    // numä½æ•°å¤š\r\n    else {\r\n        let tmpArr = new Array(kIndex);\r\n        for (; kIndex >=0 ; kIndex--) {\r\n            let sum = carrayBit + (+(k+'').charAt(kIndex));\r\n            tmpArr[kIndex] = sum % 10;\r\n            carrayBit = Math.floor(sum / 10);\r\n        }\r\n        return carrayBit ? [carrayBit, ...tmpArr, ...num] : [...tmpArr, ...num];\r\n    }\r\n};\r\n```\r\n\r\n### å¤æ‚åº¦åˆ†æ\r\n* æ—¶é—´å¤æ‚åº¦O(N)\r\n* ç©ºé—´å¤æ‚åº¦O(N)\r\n\r\n### ä»£ç ä¼˜åŒ–(å‚è€ƒé¢˜è§£)ï¼š\r\nä»å³åˆ°å·¦ï¼Œé€šè¿‡ä¸æ–­é™¤ä»¥10æ¥å–å¯¹åº”ä½çš„æ•°å­—\r\nå¦‚num = [1, 2] k=999ã€‚ \r\nç¬¬ä¸€æ¬¡å¾ªç¯ï¼šk = 999 + 2 = 1001, res[0] = k % 10 = 1\r\nç¬¬äºŒæ¬¡å¾ªç¯ï¼š\r\n    k = Math.floor(k / 10) = 100 \r\n    k = k + 1 = 101\r\n    res[1] = k % 10 = 1\r\n\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0 || k > 0; --i, k = Math.floor(k / 10)) {\r\n        if (i >= 0) {\r\n            k += num[i];\r\n        }\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186476948","body":"### æ€è·¯ï¼š\r\nå¯¹äºå­—ç¬¦ä¸²ä¸­çš„ä½ç½®ä¸ºiçš„å­—ç¬¦ï¼Œå¯»æ‰¾å·¦ä¾§å­—ç¬¦Cå’Œå³ä¾§å­—ç¬¦Cçš„ä½ç½®ï¼Œå¹¶ä¿å­˜\r\nleft = åˆ°å…¶å·¦ä¾§æœ€è¿‘çš„å­—ç¬¦ c çš„è·ç¦»\r\nright = åˆ°å…¶å³ä¾§æœ€è¿‘çš„å­—ç¬¦ c çš„è·ç¦»\r\nå¦‚æœå­—ç¬¦çš„ä½ç½® > rightï¼Œleft = right, å¹¶é‡æ–°å¯»æ‰¾right\r\nres[i] = min(i - left, right - i)\r\n\r\n### ä»£ç \r\n```js\r\n   var shortestToChar = function(s, c) {\r\n    var res = [];\r\n    // å·¦æŒ‡é’ˆ\r\n    var left = -Infinity;\r\n    // å³æŒ‡é’ˆ\r\n    var right = 0;\r\n    var len = s.length;\r\n    function setPointer (left, right) {\r\n        left = right < 0 ? -Infinity : right;\r\n        for (var i = right + 1; i < len; i++) {\r\n            if (s[i] === c) {\r\n                right = i;\r\n                return [left, right];\r\n            }\r\n        }\r\n        if (i === len) {\r\n            right = Infinity;\r\n        }\r\n        return [left, right];\r\n    }\r\n    [left, right] = setPointer(-Infinity, -1);\r\n            \r\n    for (var charIndex = 0; charIndex < len; charIndex++ ) {\r\n        // ç»´æŠ¤å·¦æŒ‡é’ˆ\r\n        if (charIndex > right) {\r\n            [left, right] = setPointer(left, right);\r\n        }\r\n        res[charIndex] = Math.min(charIndex-left,  right - charIndex);\r\n    }\r\n    return res;\r\n};\r\n};\r\n```\r\n\r\n### å¤æ‚åº¦åˆ†æ\r\n* æ—¶é—´å¤æ‚åº¦O(N)\r\n* ç©ºé—´å¤æ‚åº¦O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186530463","body":"### æ€è·¯ï¼š\r\n    æŒ‰ç…§è§„åˆ™å®ç°\r\n\r\n### ä»£ç \r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\n var CustomStack = function(maxSize) {\r\n    this.stack = new Array();\r\n    this.maxSize = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.stack.length < this.maxSize) {\r\n        this.stack.push(x);\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if (this.stack.length) {\r\n        return this.stack.pop();\r\n    }\r\n    return -1;\r\n};\r\n\r\n/** \r\n * æ ˆåº•çš„ k ä¸ªå…ƒç´ çš„å€¼éƒ½å¢åŠ  val ã€‚å¦‚æœæ ˆä¸­å…ƒç´ æ€»æ•°å°äº k ï¼Œåˆ™æ ˆä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½å¢åŠ  val ã€‚\r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    const n = Math.min(this.stack.length, k);\r\n    for (let i = n - 1; i >= 0; i--) {\r\n        this.stack[i] += val; \r\n    }\r\n};\r\n```\r\n\r\n### å¤æ‚åº¦åˆ†æ\r\n* æ—¶é—´å¤æ‚åº¦pushå’Œpopä¸ºO(1)ï¼Œincrementä¸ºOï¼ˆminï¼ˆkï¼Œnï¼‰ï¼‰\r\n* ç©ºé—´å¤æ‚åº¦O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1189120052","body":"### æ€è·¯ï¼š\r\néå†æ•°ç»„ï¼Œ\r\n1. å¦‚æœæ˜¯'[',ç›´æ¥å…¥æ ˆ\r\n2. å¦‚æœæ˜¯'æ•°å­—'ï¼Œå°†è¿ç»­æ•°å­—å­—ç¬¦è¯†åˆ«å‡ºæ¥ï¼Œç»Ÿä¸€æ”¾å…¥æ ˆä¸­\r\n3. å¦‚æœæ˜¯']',è¿›è¡Œå¤„ç†\r\n-  â‘  è¿ç»­è·å–å­—ç¬¦ä¸²ï¼Œç›´åˆ°é‡åˆ°â€[â€œ\r\n- â‘¡ å–å‡ºæ•°å­—\r\n- â‘¢ è®¡ç®—å‡ºå­—ç¬¦ä¸²åå†å…¥æ ˆ\r\n4. å¦‚æœæ˜¯'æ™®é€šå­—ç¬¦'ï¼Œæ­£å¸¸å…¥æ ˆ\r\n\r\n### ä»£ç \r\n```js\r\nvar decodeString = function(s) {\r\n    let stack = [];\r\n    let len = s.length;\r\n    let i = 0;\r\n    while(i < len) {\r\n        let char = s[i];\r\n        if (char === '[') {\r\n            stack.push('[');\r\n            i++;\r\n        }\r\n        else if (/[0-9]/.test(+s[i])) {\r\n            let strNum = s[i];\r\n            i++;\r\n            while(/[0-9]/.test(+s[i])) {\r\n                strNum += s[i];\r\n                i++;\r\n            }\r\n            stack.push(strNum)\r\n        }\r\n        else if (char === ']') {\r\n            let str = stack.pop();\r\n            let cur = stack.pop();\r\n            while(true) {\r\n                if (cur === '[') break;\r\n                str = cur + str;\r\n                cur = stack.pop();\r\n            }\r\n            \r\n            const num = +stack.pop();\r\n            const strList = Array(num).fill().map(() => str).join('');\r\n            stack.push(strList);\r\n            i++;\r\n        }\r\n        else {\r\n            stack.push(s[i]);\r\n            i++;\r\n        }\r\n        \r\n    }\r\n    return stack.join('');\r\n};\r\n```\r\n\r\n### å¤æ‚åº¦åˆ†æ\r\n* æ—¶é—´å¤æ‚åº¦O(N)\r\n* ç©ºé—´å¤æ‚åº¦O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189126896","body":"### æ€è·¯ï¼š\r\nä¸¤ä¸ªæ ˆ\r\n\r\n```js\r\nvar MyQueue = function() {\r\n    this.stack = [];\r\n    this.size = 0;\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack.push(x);\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    if (this.empty()) {\r\n        return;\r\n    }\r\n    var tmpStack = [];\r\n    var stack = this.stack;\r\n    var stackLen = stack.length;\r\n    var res;\r\n    for(var i = stackLen - 1; i > 0 ; i--) {\r\n        tmpStack.push(stack.pop());\r\n    }\r\n    res = stack.pop();\r\n    for(var i = 0; i < stackLen - 1 ; i++) {\r\n        stack.push(tmpStack.pop())\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    if (this.empty()) {\r\n        return;\r\n    }\r\n    var tmpStack = [];\r\n    var stack = this.stack;\r\n    var stackLen = stack.length;\r\n    var res;\r\n    for(var i = stackLen - 1; i > 0 ; i--) {\r\n        tmpStack.push(stack.pop());\r\n    }\r\n    res = stack.pop();\r\n    stack.push(res);\r\n    for(var i = 0; i < stackLen - 1 ; i++) {\r\n        stack.push(tmpStack.pop())\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return !this.stack.length;\r\n};\r\n```\r\n### å¤æ‚åº¦åˆ†æ\r\n* æ—¶é—´å¤æ‚åº¦O(N)\r\n* ç©ºé—´å¤æ‚åº¦O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189871624","body":"### æ€è·¯ï¼š\r\nå•è°ƒæ ˆï¼ˆé€’å¢ï¼‰\r\n- å½“å‰å€¼å¤§äºç­‰äºæ ˆé¡¶ï¼Œå¯ä»¥æˆå—\r\n- å½“å‰å€¼å°äºæ ˆé¡¶ï¼Œå»æ‰ä¹‹å‰æ¯”ä»–å¤§çš„å€¼ï¼Œåªä¿ç•™æ ˆé¡¶ç”¨äºæˆå—\r\n\r\n### ä»£ç \r\n```js\r\n// è·å–æ ˆé¡¶å…ƒç´ \r\nvar stackTop = (stack) => {\r\n    return stack[stack.length - 1];\r\n}\r\nvar maxChunksToSortedError = function(arr) {\r\n    if (!arr.length) return 0;\r\n    let ascStack = [arr[0]];\r\n    for (let i=1; i < arr.length; i++) {\r\n        let top = stackTop(ascStack);\r\n        if (arr[i] < top) {\r\n\r\n        }\r\n        else {\r\n            ascStack.push(arr[i]);\r\n        }\r\n    }\r\n    return ascStack.length;\r\n};\r\n// [1,1,0,0,1]\r\n\r\nvar maxChunksToSorted = function(arr) {\r\n    if (!arr.length) return 0;\r\n    let ascStack = [arr[0]];\r\n    for (let i=1; i < arr.length; i++) {\r\n        let top = stackTop(ascStack);\r\n        if (arr[i] < top) {\r\n            // å°äºçš„æ—¶å€™ï¼Œåªä¿ç•™æ ˆé¡¶ç”¨äºæˆå—\r\n            while(ascStack.length && stackTop(ascStack) > arr[i]) {\r\n                ascStack.pop();\r\n            }\r\n            ascStack.push(top);\r\n        }\r\n        else {\r\n            // >= å¯ä»¥ç‹¬ç«‹æˆå—\r\n            ascStack.push(arr[i]);\r\n        }\r\n    }\r\n    return ascStack.length;\r\n};\r\n```\r\n\r\n### å¤æ‚åº¦åˆ†æ\r\n* æ—¶é—´å¤æ‚åº¦O(N)\r\n* ç©ºé—´å¤æ‚åº¦O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1192086515","body":"### æ€è·¯ï¼š\r\nå–ä½™æ•° + å¿«æ…¢æŒ‡é’ˆ\r\n\r\n### ä»£ç \r\n```js\r\nvar rotateRight = function(head, k) {\r\n    function ListNode(val, next) {\r\n        this.val = (val===undefined ? 0 : val)\r\n        this.next = (next===undefined ? null : next)\r\n    }\r\n    if (!head) {\r\n        return head;\r\n    }\r\n    let dummyNode = new ListNode();\r\n    dummyNode.next = head;\r\n    let cur = head;\r\n    // è®¡ç®—é“¾è¡¨çš„é•¿åº¦\r\n    let length = 1;\r\n    while (cur.next) {\r\n        cur = cur.next;\r\n        length ++;\r\n    }\r\n    // å¿«æ…¢æŒ‡é’ˆçš„é—´è·\r\n    k = k % length;\r\n    let slowNode = head;\r\n    let fastNode = head;\r\n    for (let i = 1; i <= k; i++) {\r\n        fastNode = fastNode.next;\r\n    }\r\n\r\n    // å¿«æ…¢æŒ‡é’ˆåŒæ—¶å‰è¿›\r\n    while(fastNode.next) {\r\n        slowNode && (slowNode = slowNode.next);\r\n        fastNode = fastNode.next;\r\n    }\r\n    // è°ƒæ•´èŠ‚ç‚¹\r\n    fastNode.next = head;\r\n    dummyNode.next = slowNode.next;\r\n    slowNode.next = null;\r\n    return dummyNode.next;\r\n};\r\n```\r\n\r\n### å¤æ‚åº¦åˆ†æ\r\n* æ—¶é—´å¤æ‚åº¦O(N)\r\n* ç©ºé—´å¤æ‚åº¦O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192102306","body":"### æ€è·¯ï¼š\r\nè®°å½•å‰ä¸­åèŠ‚ç‚¹\r\nå¾…ä¼˜åŒ–ï¼Œå‡å°‘preèŠ‚ç‚¹çš„è®°å½•æ”¹ç”¨xx.next\r\n\r\n### ä»£ç \r\n```js\r\nfunction ListNode(val, next) {\r\n    this.val = (val===undefined ? 0 : val)\r\n    this.next = (next===undefined ? null : next)\r\n}\r\n\r\nvar swapPairs = function(head) {\r\n    if (!head) return head;\r\n    if (head && !head.next) return head;\r\n    // åˆ›å»ºdumyèŠ‚ç‚¹\r\n    let dummyNode = new ListNode();\r\n\r\n    let pre = dummyNode;\r\n    let cur = head;\r\n    let next = head.next;\r\n    while (true) {\r\n        pre.next = cur.next;\r\n        cur.next = next.next;\r\n        tmp = next.next;\r\n        next.next = cur;\r\n        \r\n        pre = cur;\r\n        if (tmp && tmp.next) {\r\n            cur = tmp;\r\n            next = tmp.next;\r\n        }\r\n        else {\r\n            break;\r\n        }\r\n    }\r\n    return dummyNode.next;\r\n};\r\n```\r\n\r\n### å¤æ‚åº¦åˆ†æ\r\n* æ—¶é—´å¤æ‚åº¦O(N)\r\n* ç©ºé—´å¤æ‚åº¦O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193104162","body":"### æ€è·¯ï¼š\r\n1ã€å°†æœ‰åºé“¾è¡¨è½¬æˆæœ‰åºæ•°ç»„, åˆ†æ²»\r\n[-10,-3,0,5,9] è¾“å‡ºä¸º[0,-10,5,null,-3,null,9]\r\n2ã€å¿«æ…¢æŒ‡é’ˆ\r\nä¸ºäº†æ–­å¼€ï¼Œæˆ‘ä»¬éœ€è¦ä¿å­˜æ…¢æŒ‡é’ˆçš„å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå› ä¸ºå•å‘é“¾è¡¨çš„ç»“ç‚¹æ²¡æœ‰å‰é©±æŒ‡é’ˆã€‚\r\n### ä»£ç \r\n\r\n```js\r\nvar sortedListToBST = function (head) {\r\n    const arr = [];\r\n    while (head) {\r\n        // å°†é“¾è¡¨èŠ‚ç‚¹çš„å€¼é€ä¸ªæ¨å…¥æ•°ç»„arr\r\n        arr.push(head.val);\r\n        head = head.next;\r\n    }\r\n    // æ ¹æ®ç´¢å¼•startåˆ°endçš„å­æ•°ç»„æ„å»ºå­æ ‘\r\n    const buildBST = (start, end) => {\r\n        if (start > end) return null; // æŒ‡é’ˆäº¤é”™ï¼Œå½¢æˆä¸äº†å­åºåˆ—ï¼Œè¿”å›nullèŠ‚ç‚¹\r\n        // >>> æ— ç¬¦å·å³ç§»åŠ¨ã€‚math.floor\r\n        const mid = (start + end) >>> 1; // æ±‚ä¸­é—´ç´¢å¼• ä¸­é—´å…ƒç´ æ˜¯æ ¹èŠ‚ç‚¹çš„å€¼\r\n        const root = new TreeNode(arr[mid]); // åˆ›å»ºæ ¹èŠ‚ç‚¹\r\n        root.left = buildBST(start, mid - 1); // é€’å½’æ„å»ºå·¦å­æ ‘\r\n        root.right = buildBST(mid + 1, end); // é€’å½’æ„å»ºå³å­æ ‘\r\n        return root; // è¿”å›å½“å‰å­æ ‘\r\n    };\r\n    const root = buildBST(0, arr.length - 1); // æ ¹æ®æ•´ä¸ªarræ•°ç»„æ„å»º\r\n    return root;\r\n};\r\n```\r\n\r\n### å¤æ‚åº¦åˆ†æ\r\n\r\n- æ—¶é—´å¤æ‚åº¦ O(N)\r\n- ç©ºé—´å¤æ‚åº¦ O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193263203","body":"### æ€è·¯ï¼š\r\nåˆ†åˆ«ä¸å¦å¤–ä¸€ä¸ªé“¾è¡¨â€™è¿æ¥â€˜ï¼Œç¬¬äºŒè½®æ—¶ç›¸é‡\r\næ²¡æœ‰ä¿®æ”¹nextï¼Œåªæ˜¯ä¸æ–­æ”¹å˜å½“å‰æŒ‡é’ˆè€Œå·²ï¼Œæ‰€ä»¥ä¸ä¼šå‡ºç¯\r\n\r\n\r\n### ä»£ç \r\n```js\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let a = headA,\r\n        b = headB;\r\n    while (a != b) {\r\n        a = a === null ? headB : a.next;\r\n        b = b === null ? headA : b.next;\r\n    }\r\n    return a;\r\n};\r\n```\r\n\r\n### å¤æ‚åº¦åˆ†æ\r\n* æ—¶é—´å¤æ‚åº¦O(N)\r\n* ç©ºé—´å¤æ‚åº¦O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1196887393","body":"### æ€è·¯\r\n1. hash + åŒå‘é“¾è¡¨ï¼Œå…¶ä¸­hashç”¨æ¥åˆ¤æ–­é“¾è¡¨ä¸­æ˜¯å¦å­˜åœ¨èŠ‚ç‚¹ï¼ŒåŒå‘é“¾è¡¨å¿«é€Ÿåˆ é™¤å’Œæ’å…¥èŠ‚ç‚¹\r\n2. getæ“ä½œï¼Œ\r\n* å¦‚æœå…³é”®å­— key å­˜åœ¨äºç¼“å­˜ä¸­ï¼Œåˆ™è¿”å›å…³é”®å­—çš„å€¼å¹¶ä¸”è¯¥èŠ‚ç‚¹ç§»åˆ°å°¾éƒ¨ <=> åˆ é™¤è¯¥èŠ‚ç‚¹, å°¾éƒ¨æ’å…¥è¯¥èŠ‚ç‚¹, ç»´æŠ¤hashå€¼ï¼Œè¿”å›è¯¥èŠ‚ç‚¹çš„å€¼\r\n* å¦‚æœå…³é”®å­— key æ²¡æœ‰å­˜åœ¨äºç¼“å­˜ä¸­è¿”å› -1\r\n3. putæ“ä½œ\r\n* å¦‚æœå…³é”®å­—å·²ç»å­˜åœ¨ï¼Œåˆ™å˜æ›´å…¶æ•°æ®å€¼ï¼Œ <=>åˆ é™¤è¯¥èŠ‚ç‚¹ï¼Œåœ¨å°¾éƒ¨æ’å…¥æ–°èŠ‚ç‚¹ï¼Œç»´æŠ¤hashå€¼ï¼›\r\n* å½“ç¼“å­˜å®¹é‡è¾¾åˆ°ä¸Šé™æ—¶ï¼Œå®ƒåº”è¯¥åœ¨å†™å…¥æ–°æ•°æ®ä¹‹å‰åˆ é™¤æœ€ä¹…æœªä½¿ç”¨çš„æ•°æ®å€¼ï¼Œä»è€Œä¸ºæ–°çš„æ•°æ®å€¼ç•™å‡ºç©ºé—´ <=> åˆ é™¤ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œç„¶åå°†æ–°èŠ‚ç‚¹æ”¾åˆ°å°¾éƒ¨ï¼Œç»´æŠ¤hashå€¼\r\n* å½“ç¼“å­˜æœªè¾¾åˆ°æœ€å¤§ä¸Šé™æ—¶ï¼Œç›´æ¥å°†æ’å…¥è¯¥å€¼ <=> åœ¨å°¾éƒ¨æ’å…¥è¯¥èŠ‚ç‚¹ï¼Œç»´æŠ¤hashå€¼\r\n\r\n### è¸©å‘ç‚¹ï¼š\r\n1. å¦‚æœå…³é”®å­—å·²ç»å­˜åœ¨ï¼Œåˆ™å˜æ›´å…¶æ•°æ®å€¼\r\n```js\r\n//[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\r\n// [[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\r\n// putæ—¶ï¼Œå­˜åœ¨keyï¼Œä¹Ÿè¦åˆ é™¤æ—§èŠ‚ç‚¹ï¼Œæ’å…¥æ–°èŠ‚ç‚¹\r\n```\r\n2. ç°å°†èŠ‚ç‚¹æ’å…¥åˆ°é“¾è¡¨ä¸­ï¼Œå†æ”¾åˆ°hashè¡¨é‡Œï¼Œå¦åˆ™hashé‡Œçš„èŠ‚ç‚¹ç¼ºå°‘preå’Œnext\r\n3. å¯¹äºåˆ é™¤ï¼Œéœ€è¦å¤„ç†å½“å‰èŠ‚ç‚¹å‰åæŒ‡é’ˆ\r\n4. å¯¹äºæ’å…¥ï¼Œéœ€è¦å¤„ç†å½“å‰èŠ‚ç‚¹å·¦ä¾§ä¸¤ä¸ªæŒ‡é’ˆå’Œå³ä¾§ä¸¤ä¸ªæŒ‡é’ˆ\r\n5. åˆ›å»ºdummyèŠ‚ç‚¹ï¼Œä»¥å…å¤„ç†å„ç§è¾¹ç•Œé—®é¢˜\r\n\r\n### ä»£ç \r\n```js\r\nclass Node {\r\n    constructor(key, val, next, pre) {\r\n        this.key = (key===undefined ? 0 : key);\r\n        this.val = (val===undefined ? 0 : val);\r\n        this.next = (next===undefined ? null : next);\r\n        this.pre = (pre===undefined ? null : pre);\r\n    }\r\n}\r\n\r\nclass MyDoubleList {\r\n    constructor() {\r\n        // dummyèŠ‚ç‚¹ï¼Œå…äºå¤„ç†è¾¹ç•Œ\r\n        this.head = new Node('head');\r\n        // dummyèŠ‚ç‚¹ï¼Œå…äºå¤„ç†è¾¹ç•Œ\r\n        this.tail = new Node('tail');\r\n        this.head.next = this.tail;\r\n        this.tail.pre = this.head;\r\n        // é“¾è¡¨é•¿åº¦\r\n        this.size = 0;\r\n    }\r\n    // åœ¨é“¾è¡¨å°¾éƒ¨æ·»åŠ èŠ‚ç‚¹(æ³¨æ„æ˜¯å°¾éƒ¨ï¼Œæ‰€ä»¥lrué å°¾éƒ¨çš„æ•°æ®æ˜¯æœ€è¿‘ä½¿ç”¨çš„)\r\n    addLast(x) {\r\n        // å·¦\r\n        x.pre = this.tail.pre;\r\n        this.tail.pre.next = x;\r\n        // å³\r\n        this.tail.pre = x;\r\n        x.next = this.tail;\r\n        this.size ++;\r\n    }\r\n\r\n    // åˆ é™¤é“¾è¡¨ä¸­æŸä¸€ä¸ªèŠ‚ç‚¹\r\n    remove(x) {\r\n        x.pre.next = x.next;\r\n        x.next.pre = x.pre;\r\n        this.size--;\r\n    }\r\n\r\n    // åˆ æ‰ç¬¬ä¸€ä¸ªèŠ‚ç‚¹\r\n    removeFirst(x) {\r\n        if (this.head.next == this.tail) {\r\n            return null;\r\n        }\r\n        let firstNode = this.head.next;\r\n        this.remove(firstNode);\r\n        return firstNode;\r\n    }\r\n\r\n    getSize() {\r\n        return this.size;\r\n    }\r\n}\r\n/**\r\n* @param {number} capacity\r\n*/\r\nvar LRUCache = function(capacity) {\r\n    this.capacity = capacity;\r\n    this.hashObj = {};\r\n    this.cache = new MyDoubleList();\r\n};\r\n\r\n/** \r\n* @param {number} key\r\n* @return {number}\r\n*/\r\nLRUCache.prototype.get = function(key) {\r\n    const node = this.hashObj[key];\r\n    if (!node) {\r\n        return -1;\r\n    }\r\n    // å¦‚æœæœ‰nodeï¼Œç§»åˆ°åè¾¹, ä½œä¸ºæœ€è¿‘ä½¿ç”¨çš„\r\n    this.cache.remove(node);\r\n    this.cache.addLast(node);\r\n\r\n    return node.val;\r\n};\r\n\r\n/** \r\n* @param {number} key \r\n* @param {number} value\r\n* @return {void}\r\n*/\r\nLRUCache.prototype.put = function(key, value) {\r\n    \r\n    const node = this.hashObj[key];\r\n    const newNode = new Node(key, value);\r\n    // å¦‚æœå…³é”®å­—å·²ç»å­˜åœ¨ï¼Œåˆ™å˜æ›´å…¶æ•°æ®å€¼\r\n    if (node) {\r\n        // ä»hashé‡Œåˆ é™¤æ—§æ•°æ®\r\n        delete this.hashObj[key];\r\n        // ä»é“¾è¡¨ä¸­åˆ é™¤æ•°æ®\r\n        this.cache.remove(node);\r\n        \r\n        // å°†æ–°æ•°æ®æ’å…¥åˆ°é“¾è¡¨, è¦å…ˆæ’å…¥é“¾è¡¨ï¼Œå¦åˆ™æ²¡æœ‰preå’Œnext\r\n        this.cache.addLast(newNode);\r\n        // å°†æ–°æ•°æ®æ’å…¥åˆ°hash\r\n        this.hashObj[key] = newNode;\r\n        return;\r\n    }\r\n\r\n    const length = this.cache.getSize();\r\n    if (this.capacity === length) {\r\n        // æ— ç©ºé—´ï¼Œå…ˆåˆ é™¤ç¬¬ä¸€ä¸ªèŠ‚ç‚¹åæ’å…¥(åˆ é™¤æœ€ä¹…æœªä½¿ç”¨çš„å…ƒç´ )\r\n        // ä»hashä¸­ç§»å‡º\r\n        delete this.hashObj[this.cache.head.next.key];\r\n        // ä»é“¾è¡¨ä¸­ç§»é™¤\r\n        this.cache.removeFirst();\r\n\r\n        this.cache.addLast(newNode);\r\n        // åŠ åˆ°hashä¸­\r\n        this.hashObj[key] = newNode;\r\n    }\r\n    else {\r\n        this.cache.addLast(newNode);\r\n        // åŠ åˆ°hashä¸­\r\n        this.hashObj[key] = newNode;\r\n    }\r\n};\r\n```\r\n\r\n### å¤æ‚åº¦\r\n* æ—¶é—´å¤æ‚åº¦ï¼šget:O(1), put: O(1)\r\n* ç©ºé—´å¤æ‚åº¦ï¼šget:O(n), put: O(n)ï¼Œ nä¸ºcapacityå®¹é‡","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196849739","body":"### æ€è·¯ï¼š\r\næ±‚å·¦å³å­æ ‘æ·±åº¦çš„æœ€å¤§å€¼\r\n\r\n### ä»£ç \r\n```js\r\nvar maxDepth = function(root) {\r\n    if (root === null) {\r\n        return 0;\r\n    }\r\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n};\r\n```\r\n\r\n### å¤æ‚åº¦åˆ†æ\r\n* æ—¶é—´å¤æ‚åº¦O(N)\r\n* ç©ºé—´å¤æ‚åº¦O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197567344","body":"### æ€è·¯ï¼š\r\nç›¸åŒçš„æ ‘è¦æ±‚ï¼šâ‘  val ç›¸åŒ â‘¡ å·¦å­æ ‘ä¸­çš„valåŒ â‘¢ å³å­æ ‘valåŒ\r\n\r\n### ä»£ç \r\n```js\r\n/**\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {boolean}\r\n */\r\nvar isSameTree = function(p, q) {\r\n    if (p === null && q === null) {\r\n        return true;\r\n    } \r\n    if (p === null || q === null) {\r\n        return false;\r\n    }\r\n    return ((p && p.val) === (q && q.val)) \r\n        && isSameTree(p.left, q.left) \r\n        && isSameTree(p.right, q.right);\r\n};\r\n```\r\n\r\n### å¤æ‚åº¦åˆ†æ\r\n* æ—¶é—´å¤æ‚åº¦O(N)\r\n* ç©ºé—´å¤æ‚åº¦O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198898654","body":"### æ€è·¯ï¼š\r\nDFS+å›æº¯\r\n\r\n### ä»£ç \r\n```js\r\nvar sumNumbers = function(root) {\r\n    if (!root) return 0;\r\n    let sum = 0;\r\n    let ans = [];\r\n    const DFS = root => {\r\n        // è·å–å¶å­èŠ‚ç‚¹ã€‚ç´¯åŠ \r\n        if (!root.left && !root.right) {\r\n            sum += +(ans.join('') + root.val);\r\n            return;\r\n        }\r\n        else {\r\n            ans.push(root.val);\r\n        }\r\n        root.left && DFS(root.left);\r\n        root.right && DFS(root.right);\r\n        // æ’¤é”€å½“å‰èŠ‚ç‚¹é€‰æ‹©\r\n        ans.pop();\r\n    }\r\n    DFS(root);\r\n    return sum;\r\n\r\n};\r\n```\r\n\r\n### å¤æ‚åº¦åˆ†æ\r\n* æ—¶é—´å¤æ‚åº¦O(N)\r\n* ç©ºé—´å¤æ‚åº¦O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200164070","body":"### æ€è·¯ï¼š\r\nâ‘ ç”¨é˜Ÿåˆ—å­˜å‚¨å…ƒç´ ï¼Œä»¥BFSçš„æ–¹å¼è®¿é—®å…ƒç´ \r\nâ‘¡è®°å½•æ¯å±‚å…ƒç´ çš„èŠ‚ç‚¹æ€»æ•°ã€‚\r\nâ‘¢éå†å„å±‚èŠ‚ç‚¹ï¼Œä¸æ–­è®°å½•æœ€å·¦ä¾§çš„èŠ‚ç‚¹\r\n\r\n### ä»£ç \r\n```js\r\nvar findBottomLeftValue = function(root) {\r\n    let queue = [root];\r\n    let depthLeft = root.val;\r\n    while (queue.length) {\r\n        let size = queue.length;\r\n        for (let i = 0; i < size; i++) {\r\n            let cur = queue.shift();\r\n            if (i === 0) {\r\n                depthLeft = cur.val;\r\n            }\r\n            cur.left && queue.push(cur.left);\r\n            cur.right && queue.push(cur.right);\r\n        }\r\n    }\r\n    return depthLeft;\r\n};\r\n```\r\n\r\n### å¤æ‚åº¦åˆ†æ\r\n* æ—¶é—´å¤æ‚åº¦O(N)\r\n* ç©ºé—´å¤æ‚åº¦O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200380594","body":"### æ€è·¯ï¼š\r\n- åºåˆ—åŒ–ï¼š\r\nâ‘ DFSä¸­åºéå†\r\nâ‘¡å¦‚æœèŠ‚ç‚¹ä¸ºnullè½¬æˆ'x'\r\nâ‘¢å¦‚æœèŠ‚ç‚¹ä¸ä¸ºnull, è¿”å›root.valã€DFS(root.left)ã€DFS(root.right)ï¼Œå¹¶ç”¨â€˜ï¼Œâ€™åˆ†å‰²\r\n- ååºåˆ—åŒ–ï¼š\r\nâ‘ å°†å­—ç¬¦ä¸²å·²â€˜ï¼Œâ€™æ‹†åˆ†ä¸ºæ•°ç»„ï¼ˆé˜Ÿåˆ—ï¼‰ï¼Œ\r\nâ‘¡å–å‡ºé˜Ÿåˆ—çš„é¦–ä¸ªå€¼ï¼Œå¦‚æœèŠ‚ç‚¹ä¸ºâ€˜xâ€™ï¼Œè¿”å›null, å¦åˆ™é€’å½’æ„é€ root.valå’Œroot.leftå’Œroot.right\r\n\r\n### ä»£ç \r\n```js\r\n/**\r\n * Encodes a tree to a single string.\r\n *\r\n * @param {TreeNode} root\r\n * @return {string}\r\n */\r\nvar serialize = function(root) {\r\n    const dfs = (root) => {\r\n        if (!root) return 'x';\r\n        return root.val + ',' +\r\n            dfs(root.left) + ',' +\r\n            dfs(root.right);\r\n    }\r\n    const res = dfs(root);\r\n    return res;\r\n};\r\n\r\n/**\r\n * Decodes your encoded data to tree.\r\n *\r\n * @param {string} data\r\n * @return {TreeNode}\r\n */\r\nvar deserialize = function(data) {\r\n    const queue = data.split(',');\r\n    const buildTree = queue => {\r\n        let node = queue.shift();\r\n        if (node === 'x') {\r\n            return null;\r\n        }\r\n        let root = new TreeNode(node);\r\n        root.left = buildTree(queue);\r\n        root.right = buildTree(queue);\r\n        return root;\r\n    }\r\n    return buildTree(queue)\r\n};\r\n```\r\n\r\n### å¤æ‚åº¦åˆ†æ\r\n- serialize\r\n* æ—¶é—´å¤æ‚åº¦O(N)\r\n* ç©ºé—´å¤æ‚åº¦O(1)\r\n\r\n- deserialize\r\n* æ—¶é—´å¤æ‚åº¦O(N)\r\n* ç©ºé—´å¤æ‚åº¦O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200688223","body":"### æ€è·¯ï¼š\r\nçœ‹äº†é¢˜è§£\r\nDFSéå†\r\nç„¶åæŒ‰ç…§è¦æ±‚æ’åºï¼ŒæŒ‰ç…§åˆ—ã€è¡Œã€å€¼æ’åº\r\n\r\n### ä»£ç \r\n```js\r\n /**\r\n * @param {TreeNode} root\r\n * @return {number[][]}\r\n */\r\n\r\n var verticalTraversal = function(root) {\r\n    const nodes = [];\r\n    dfs(root, 0, 0, nodes);\r\n     // æ’åºå\r\n    // [ [ -1, 1, 9 ], [ 0, 0, 3 ], [ 0, 2, 15 ], [ 1, 1, 20 ], [ 2, 2, 7 ] ]\r\n    nodes.sort((tuple1, tuple2) => {\r\n        // åˆ—æ’åº\r\n        if (tuple1[0] !== tuple2[0]) {\r\n            return tuple1[0] - tuple2[0];\r\n        // è¡Œæ’åº\r\n        } else if (tuple1[1] !== tuple2[1]) {\r\n            return tuple1[1] - tuple2[1];\r\n        // å€¼æ’åº\r\n        } else {\r\n            return tuple1[2] - tuple2[2];\r\n        }\r\n    });\r\n\r\n    const ans = [];\r\n    let lastcol = -Number.MAX_VALUE;\r\n    for (const tuple of nodes) {\r\n        let col = tuple[0], value = tuple[2];\r\n        if (col !== lastcol) {\r\n            lastcol = col;\r\n            ans.push([]);\r\n        }\r\n        ans[ans.length - 1].push(value);\r\n    }\r\n    return ans;\r\n}\r\n\r\nconst dfs = (node, row, col, nodes) => {\r\n    if (node === null) {\r\n        return;\r\n    }\r\n    nodes.push([col, row, node.val]);\r\n    dfs(node.left, row + 1, col - 1, nodes);\r\n    dfs(node.right, row + 1, col + 1, nodes);\r\n}  \r\n```\r\n\r\n### å¤æ‚åº¦åˆ†æ\r\n* æ—¶é—´å¤æ‚åº¦O(nlogn)\r\nO(N)å¯¹æ•°ç»„è¿›è¡Œéå†ã€O(nlogn)å¯¹æ•°ç»„è¿›è¡Œæ’åº\r\n* ç©ºé—´å¤æ‚åº¦O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201931601","body":"### æ€è·¯ï¼š\r\n- ç”¨hashè®°å½•ä¸‹éå†è¿‡æ•°æ®çš„ä¸‹æ ‡\r\n- éå†æ•°ç»„ï¼Œåˆ¤æ–­ã€target-å½“å‰å€¼ã€‘åœ¨hashä¸­æ˜¯å¦å­˜åœ¨ï¼Œå¦‚å­˜åœ¨åˆ™è¿”å›ä¸‹æ ‡\r\nå¦‚ä¸å­˜åœ¨ï¼Œå°†å€¼ä»¥åŠä¸‹æ ‡è®°å½•åˆ°hashä¸­\r\n\r\n### ä»£ç \r\n```js\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number[]}\r\n */\r\nvar twoSum = function(nums, target) {\r\n    let hash = {};\r\n    let numsLen = nums.length;\r\n    for(let i = 0;i<numsLen;i++) {\r\n        const cur = nums[i];\r\n        if (hash[target - cur] !== undefined) {\r\n            return [hash[target - cur], i];\r\n        }\r\n        else {\r\n            hash[cur] = i;\r\n        }\r\n    }\r\n    return [-1, -1]\r\n}; \r\n```\r\n\r\n### å¤æ‚åº¦åˆ†æ\r\n* æ—¶é—´å¤æ‚åº¦O(N)\r\n* ç©ºé—´å¤æ‚åº¦O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1204113921","body":"### æ€è·¯ï¼š\r\n* å½’å¹¶æ’åº + hash,(å½’å¹¶æ’åºç¨³å®š)\r\n1. é¦–å…ˆéå†æ•´ä¸ªæ•°ç»„ï¼Œå¹¶ä½¿ç”¨å“ˆå¸Œè¡¨è®°å½•æ¯ä¸ªæ•°å­—å‡ºç°çš„æ¬¡æ•°ï¼Œå¹¶å½¢æˆä¸€ä¸ªã€Œå‡ºç°æ¬¡æ•°æ•°ç»„ã€ã€‚æ‰¾å‡ºåŸæ•°ç»„çš„å‰ k ä¸ªé«˜é¢‘å…ƒç´ ï¼Œå°±ç›¸å½“äºæ‰¾å‡ºã€Œå‡ºç°æ¬¡æ•°æ•°ç»„ã€çš„å‰ k å¤§çš„å€¼\r\n2. ä½¿ç”¨å½’å¹¶æ’åºæ¥ æ’åºhashMapä¸­çš„æ¬¡æ•°\r\n3. å½’å¹¶æ’åºæ˜¯ä¸æ–­åˆ†ç»„ï¼ˆæ ¹æ®ä½ç½®ä¸€åˆ†ä¸ºäºŒï¼‰ï¼Œåˆ†åˆ°æ¯ç»„åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œç„¶åå†åˆå¹¶ç›¸é‚»çš„2ä¸ªå°ç»„ã€‚å› ä¸ºå½’å¹¶æ’åºæ˜¯åŸºäºä½ç½®çš„ï¼Œæ‰€ä»¥è®²mapè½¬ä¸ºæ•°ç»„è¿›è¡Œæ’åº\r\n\r\n### ä»£ç ï¼š\r\n```js\r\n// å½’å¹¶æ’åº\r\nfunction mergeSort(arrData, start, end) {\r\n    if (start === end) {\r\n        return [arrData[start]];\r\n    }\r\n    // mid=Math.floor((end-start)/2).ç”±äºæ•°ç»„ä¸‹æ ‡å·²0å¼€å§‹ï¼Œend=arr.length-1\r\n    // å·¦ä¾§éƒ¨åˆ†ï¼š(start, start + mid)\r\n    // ä¸­é—´éƒ¨åˆ†ï¼šmid\r\n    // å³ä¾§éƒ¨åˆ†ï¼ˆstart + mid + 1, end)\r\n    const mid = Math.floor((end - start) / 2);\r\n    const left = sort(arrData, start, start + mid);\r\n    const right = sort(arrData, start + mid + 1, end);\r\n    let mergeData = [];\r\n    for(var lefti = 0, righti = 0; lefti < left.length && righti < right.length; ) {\r\n        if (left[lefti][1] >= right[righti][1]) {\r\n            mergeData.push(left[lefti])\r\n            lefti++\r\n        }\r\n        else {\r\n            mergeData.push(right[righti])\r\n            righti++\r\n        }\r\n    }\r\n    if (lefti < left.length) {\r\n        mergeData = [...mergeData, ...left.slice(lefti)]\r\n    }\r\n    if (righti < right.length) {\r\n        mergeData = [...mergeData, ...right.slice(righti)]\r\n    }\r\n    return mergeData;\r\n}\r\n\r\nvar topKFrequent = function(nums, k) {\r\n    let hashMap = new Map();\r\n    let cur = null;\r\n\r\n    nums.map(num => {\r\n        if (hashMap.get(num)) {\r\n            hashMap.set(num, hashMap.get(num) + 1);\r\n        }\r\n        else {\r\n            hashMap.set(num, 1);\r\n        }\r\n    });\r\n    // å¦‚æœå…ƒç´ æ•°é‡å°äºç­‰äº k\r\n    if(hashMap.size <= k) {\r\n        return [...hashMap.keys()]\r\n    }\r\n\r\n    const hashToArr = [...hashMap];\r\n    const maxK = mergeSort(hashToArr, 0, hashToArr.length -1).slice(0, k);\r\n    let res = [];\r\n    for (let [key, val] of maxK) {\r\n        res.push(key);\r\n    }\r\n    return res;\r\n};  \r\n\r\n// ç”¨arrè‡ªå¸¦çš„sort\r\nlet topKFrequent = function(nums, k) {\r\n    let map = new Map();\r\n    // å»é‡\r\n    let arr = [...new Set(nums)];\r\n    nums.map((num) => {\r\n        if(map.has(num)) {\r\n            map.set(num, map.get(num)+1)\r\n        }\r\n        else {\r\n            map.set(num, 1)\r\n        }\r\n    });\r\n    \r\n    return arr.sort((a, b) => map.get(b) - map.get(a)).slice(0, k);\r\n};\r\n```\r\n### å¤æ‚åº¦\r\n* æ—¶é—´å¤æ‚åº¦: O(nlog(n))\r\n* ç©ºé—´å¤æ‚åº¦: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205399415","body":"### æ€è·¯\r\n* è®¡ç®—æ¯ä¸ªç‚¹å¯èƒ½äº§ç”Ÿçš„å›æ—‹é•–ç»„åˆï¼Œç„¶åç´¯åŠ \r\n1. éå†æ¯ä¸ªç‚¹ä¸å…¶ä»–ç‚¹çš„è·ç¦»ï¼Œä½¿ç”¨hashMapè®°å½•\r\n2. å¯¹äºä¸€ä¸ªç‚¹ï¼Œæ¯ä¸ªè·ç¦»çš„\"æ’åˆ—å€¼â€ä¸ºå›æ—‹é•–æ•°\r\n3. éå†æ‰€æœ‰çš„ç‚¹ï¼Œè®¡ç®—æ€»æ•°\r\n\r\n### ä»£ç \r\n```js\r\nvar numberOfBoomerangs = function(points) {\r\n    const length = points.length;\r\n    let res = 0;\r\n    for (let i = 0; i<length; i++) {\r\n        let hashMap = new Map();\r\n        for (let j = 0; j<length; j++) {\r\n            if(i == j) continue;\r\n            let dx = points[j][0] - points[i][0];\r\n            let dy = points[j][1] - points[i][1];\r\n            let range =  dx * dx + dy * dy;\r\n            let rangeNum = hashMap.get(range) || 0;\r\n            if (rangeNum) {\r\n                hashMap.set(range, rangeNum + 1);\r\n            }\r\n            else {\r\n                hashMap.set(range, 1);\r\n            }\r\n        }\r\n        for(let item of hashMap) {\r\n            res += item[1] * (item[1] - 1);\r\n        }\r\n    }\r\n    return res;\r\n};\r\n\r\n// é”™è¯¯é¢˜è§£ï¼š\r\nvar numberOfBoomerangs = function(points) {\r\n    let len = points.length;\r\n    let res = 0;\r\n    let hashEdge = {};\r\n    for (let m = 0; m < len; m ++) {\r\n        for (let n = m + 1; n < len; n++) {\r\n            let edge1 = points[m][0] - points[n][0];\r\n            let edge2 = points[m][1] - points[n][1];\r\n            let edge = edge1 * edge1 + edge2 * edge2;\r\n            if (hashEdge[edge]) {\r\n                hashEdge[edge] +=1;\r\n            }\r\n            else {\r\n                hashEdge[edge] = 1;\r\n            }\r\n        }\r\n        console.log(hashEdge);\r\n    }\r\n    for (let i in hashEdge) {\r\n        res += hashEdge[i] * (hashEdge[i] - 1);\r\n    }\r\n    return res;\r\n};\r\n\r\n// å®˜æ–¹é¢˜è§£ï¼š\r\nvar numberOfBoomerangs = function(points) {\r\n    let ans = 0;\r\n    for (const p of points) {\r\n        const cnt = new Map();\r\n        for (const q of points) {\r\n            const dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\r\n            cnt.set(dis, (cnt.get(dis) || 0) + 1);\r\n        }\r\n        for (const [_, m] of cnt.entries()) {\r\n            ans += m * (m - 1);\r\n        }\r\n        console.log(cnt);\r\n    }\r\n    return ans;\r\n};\r\n```\r\n### å¤æ‚åº¦\r\n* æ—¶é—´å¤æ‚åº¦: O(N*N)\r\n* ç©ºé—´å¤æ‚åº¦: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205949602","body":"### æ€è·¯ï¼š\r\næ»‘åŠ¨çª—å£å’Œhash\r\n-  ç”¨hashè®°å½•å‡ºç°è¿‡å­—ç¬¦çš„ä½ç½®indexï¼Œå¦‚æœå†æ¬¡å‡ºç°ï¼Œæ›´æ–°ä½ç½®\r\n- æ»‘åŠ¨çª—å£å·¦ä¾§leftæ˜¯é‡å¤å­—ç¬¦èµ·å§‹ä½ç½®ï¼Œå³ä¾§æ˜¯é‡å¤å­—ç¬¦çš„ç»ˆæ­¢ä½ç½®\r\n- éå†å­—ç¬¦ï¼Œå¦‚æœå­—ç¬¦å·²å‡ºç°ï¼Œè®¡ç®—å½“å‰æœªé‡å¤å­—ç¬¦çš„æœ€å¤§é•¿åº¦ï¼Œå¹¶ä¿®æ­£left = index + 1(ä¿è¯leftçš„indexä¸ä¼šå˜å°)ï¼›\r\n\r\n*æ³¨æ„\r\n1. indexå€¼è¦ä¿è¯åœ¨leftåï¼Œå¦åˆ™caseå‡ºé”™ï¼šâ€™abbaâ€˜\r\n2. éå†åè¦é‡æ–°è®¡ç®—ä¸‹ï¼Œå› ä¸ºæœ€åä¸€ä½å¯èƒ½åœ¨å¿«æ…¢æŒ‡é’ˆèŒƒå›´å†…ä¸å­˜åœ¨é‡å¤å­—ç¬¦ï¼Œ å¦åˆ™caseå‡ºé”™ï¼š 'dvdf'\r\n### ä»£ç \r\n```js\r\n /**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nvar lengthOfLongestSubstring = function(s) {\r\n    let maxLen = 0;\r\n    let hash = {};\r\n    let left = 0;\r\n    let right = 0;\r\n    for (; right < s.length; right++) {\r\n        const cur = s[right];\r\n        const existIndex = hash[cur];\r\n        // å­—ç¬¦å·²å‡ºç°\r\n        if (existIndex !== undefined) {\r\n            maxLen = Math.max(maxLen, right - left);\r\n            // æ”¹å˜æ»‘åŠ¨çª—å£å·¦ä¾§å€¼\r\n            (existIndex + 1 > left) && (left = existIndex + 1);\r\n        }\r\n        // è®°å½•å‡ºç°å­—ç¬¦çš„ä½ç½®\r\n        hash[cur] = right;\r\n    }\r\n    return Math.max(maxLen, right - left);\r\n};  \r\n```\r\n\r\n### å¤æ‚åº¦åˆ†æ\r\n* æ—¶é—´å¤æ‚åº¦O(N)\r\n* ç©ºé—´å¤æ‚åº¦O(N))(hashå€¼å­˜å‚¨å·²å‡ºç°å…ƒç´ æ¬¡æ•°)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207234361","body":"### æ€è·¯ï¼š\r\nåŒæŒ‡é’ˆ+hash\r\nå¾…ä¼˜åŒ–\r\n\r\n### ä»£ç \r\n```js\r\nvar findSubstring = function(s, words) {\r\n    let res = [];\r\n    let left = 0;\r\n    let right = 0;\r\n    let strLen = s.length;\r\n    let wordLen = words && words[0].length || 0;\r\n    let hash = {};\r\n    const reset = (words) => {\r\n        hash = {};\r\n        words.forEach(word => {\r\n            hash[word] =  hash[word] !== undefined ?  hash[word] + 1 : 1;\r\n        })\r\n    }\r\n    reset(words, hash);\r\n    while(right < strLen) {\r\n        let curWord = s.slice(right, right + wordLen);\r\n        if (hash[curWord] !== undefined) {\r\n            hash[curWord] = hash[curWord] - 1;\r\n            if (hash[curWord] === 0) {\r\n                delete hash[curWord];\r\n            }\r\n            // æ»¡è¶³æ¡ä»¶\r\n            if (Object.keys(hash).length === 0) {\r\n                res.push(left);\r\n                left += 1;\r\n                right = left;\r\n                reset(words, hash);\r\n            }\r\n            else {\r\n                right +=wordLen;\r\n            }\r\n        }\r\n        else {\r\n            left += 1;\r\n            right = left;\r\n            reset(words, hash);\r\n        }\r\n    }\r\n    return res;\r\n};  \r\n```\r\n\r\n### å¤æ‚åº¦åˆ†æ\r\n* æ—¶é—´å¤æ‚åº¦O(N * N)\r\n* ç©ºé—´å¤æ‚åº¦O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207430142","body":"### æ€è·¯ï¼š\r\nhttps://leetcode.cn/problems/make-sum-divisible-by-p/\r\n####  å‰ç½®çŸ¥è¯†ï¼š\r\n- åŒä½™å®šç†(ä¸¤æ•´æ•°é™¤ä»¥åŒä¸€ä¸ªæ•´æ•°ï¼Œè‹¥å¯å¾—ç›¸åŒä½™æ•°ï¼Œåˆ™äºŒæ•´æ•°åŒä½™)\r\n- å‰ç¼€å’Œï¼š\r\nrunningSum[i] = sum(nums[0]â€¦nums[i])ï¼Œ\r\né‚£ä¹ˆ runningSum[i + 1] = sum(nums[0]â€¦nums[i]) + nums[i + 1]\r\n= runningSum[i] + nums[i + 1]ã€‚\r\n\r\n#### æ¨å¯¼\r\n(allSum - rangeSum) % p == 0 \r\n<=> allSum % p = rangeSum % p = (preSum2 - preSum1) % p \r\n<=> (allSum + preSum1) % p = preSum2 % p\r\n<=> floorMod((preSum2 - target) , p) = preSum1 % p\r\n\r\n### ä»£ç \r\n```js\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar floorMod = function (a, b) {\r\n    return ((a % b) + b) % b;\r\n};\r\nvar minSubarray = function(nums, k) {\r\n    var map = new Map();\r\n    map.set(0, -1);\r\n    var res = nums.length;\r\n    var target = 0;\r\n    var currSum = 0;\r\n    for (let i = 0; i < nums.length; i++) {\r\n      target += nums[i];\r\n    }\r\n    // æ•°ç»„çš„ä½™æ•°\r\n    target = target % k;\r\n    for (let i = 0; i < nums.length; i++) {\r\n        //å‰ç¼€å’Œæ±‚ä½™\r\n        currSum = (nums[i] + currSum) % k;\r\n        map.set(currSum, i);\r\n        var prevSum = floorMod(currSum - target, k);\r\n        if (map.has(prevSum)) {\r\n            // è®¡ç®—åŒºé—´\r\n            res = Math.min(res, i - map.get(prevSum));\r\n        }\r\n    }\r\n    return res === nums.length ? -1 : res;\r\n};\r\n```\r\n\r\n### å¤æ‚åº¦åˆ†æ\r\n* æ—¶é—´å¤æ‚åº¦O(N)\r\n* ç©ºé—´å¤æ‚åº¦O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207505489","body":"### æ€è·¯\r\n**å¿«æ…¢æŒ‡é’ˆ**\r\n1. é€šè¿‡å¿«æ…¢æŒ‡é’ˆæ‰¾ä¸­é—´èŠ‚ç‚¹\r\n2. å¦‚æœå¿«æŒ‡é’ˆèƒ½å¤Ÿè·³ä¸¤æ­¥ï¼Œåˆ™æ…¢æŒ‡é’ˆè·³ä¸€æ­¥\r\n3. å¦‚æœå¿«æŒ‡é’ˆä¸èƒ½ç»§ç»­ï¼Œåˆ™æ…¢æŒ‡é’ˆä¸ºä¸­é—´èŠ‚ç‚¹\r\n4. å¦‚æœå¿«æŒ‡é’ˆåªèƒ½ç»§ç»­ä¸€æ­¥ï¼Œåˆ™æœ‰ä¸¤ä¸ªä¸­é—´ç»“ç‚¹ï¼Œè¿”å›ç¬¬äºŒä¸ªä¸­é—´ç»“ç‚¹\r\n\r\n### ä»£ç \r\n```js\r\nvar middleNode = function(head) {\r\n    if (head === null) {\r\n        return head;\r\n    }\r\n    let slow = quick = head;\r\n    while(quick) {\r\n        // ç»§ç»­æ­£å¸¸è·³\r\n        if (quick.next && quick.next.next) {\r\n            quick = quick.next && quick.next.next;\r\n            slow = slow.next;\r\n            continue;\r\n        }\r\n        // å¶æ•°ï¼Œquickä¸èƒ½ç»§ç»­è·³åˆ°ä¸‹ä¸€æ­¥\r\n        else if (quick.next && !quick.next.next) {\r\n            return slow.next;\r\n        }\r\n        // å¥‡æ•°+æœ€åä¸€ä¸ªèŠ‚ç‚¹\r\n        return slow;\r\n    }\r\n};\r\n```\r\n### å¤æ‚åº¦\r\n* æ—¶é—´å¤æ‚åº¦: O(N)\r\n* ç©ºé—´å¤æ‚åº¦: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209542539","body":"### æ€è·¯ï¼š\r\nå¿«æ…¢æŒ‡é’ˆï¼Œæ•°ç»„æ˜¯æœ‰åºçš„ï¼Œé‚£ä¹ˆé‡å¤çš„å…ƒç´ ä¸€å®šä¼šç›¸é‚»ã€‚è¦æ±‚åˆ é™¤é‡å¤å…ƒç´ ï¼Œå®é™…ä¸Šå°±æ˜¯å°†ä¸é‡å¤çš„å…ƒç´ ç§»åˆ°æ•°ç»„çš„å·¦ä¾§.\r\n- è¯¯åŒº1ï¼šåŸåœ°hash, å‡ºé”™case: [0,0,0,0,3]\r\n- è¯¯åŒº2ï¼šä¸æ˜¯ä¸€å®šè¦åˆ é™¤é‡å¤å…ƒç´ \r\n- è¯¯åŒº3ï¼šä¸ä¸€å®šå¿«æŒ‡é’ˆå…ˆå‡ºå‘ï¼Œå¯ä»¥åŒæ—¶å‡ºå‘\r\n\r\n### ä»£ç \r\n```js\r\n// æˆ‘çš„ä»£ç \r\nvar removeDuplicates = function(nums) {\r\n    let len = nums.length;\r\n    if (len < 2) {\r\n        return len;\r\n    }\r\n    nums.push(-Infinity);\r\n    let slow = 0;\r\n    let quick = 1;\r\n    while(nums.length && quick < nums.length) {\r\n        if (nums[quick] !== nums[slow]) {\r\n            if (quick - slow - 1) {\r\n                nums.splice(slow, quick - slow - 1);\r\n                slow++;\r\n                quick = slow + 1;\r\n                continue;\r\n            }\r\n            else {\r\n                slow++;\r\n            }\r\n        }\r\n        quick++\r\n    }\r\n    nums.splice(nums.length -1, 1);\r\n};\r\n// ä¼˜åŒ–1ï¼Œå¿«æ…¢æŒ‡é’ˆåŒæ—¶å‡ºå‘ã€‚ï¼ˆè¯¯åŒºï¼šä¸ä¸€å®šå¿«æŒ‡é’ˆå…ˆå‡ºå‘ï¼Œå¯ä»¥åŒæ—¶å‡ºå‘ï¼‰\r\n// ä¼˜åŒ–2ï¼Œ[], [x]ä¸éœ€è¦å¤„ç†ï¼Œç›´æ¥è¿”å›æ•°å€¼\r\n// ä¼˜åŒ–3ï¼Œé¢˜è§£è¿”å›numberï¼Œä¿è¯numsã€0ï¼Œnumber-1ã€‘ä¸é‡å¤\r\nvar removeDuplicates = function(nums) {\r\n    if (nums.length < 2) {\r\n        return nums.length;\r\n    }\r\n    let w = 0;\r\n    let r = 0;\r\n    while(r < nums.length) {\r\n        if (nums[w] !== nums[r]) {\r\n            w++;\r\n            nums[w] = nums[r];\r\n        }\r\n        r ++;\r\n    }\r\n    return w+1;\r\n};\r\n```\r\n\r\n### å¤æ‚åº¦\r\n* æ—¶é—´å¤æ‚åº¦: O(N)\r\n* ç©ºé—´å¤æ‚åº¦: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"youzhaing":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1186703874","body":"### é¢˜ç›®ï¼š[989. æ•°ç»„å½¢å¼çš„æ•´æ•°åŠ æ³•](https://leetcode.cn/problems/add-to-array-form-of-integer/)\r\n### æ€è·¯ï¼š\r\nåˆ©ç”¨æ•°ç»„å’Œæ•°å­—çš„ç‰¹æ€§åˆ†åˆ«å¤„ç†numå’Œkï¼Œåœ¨å¾ªç¯ä¸­åŠ åˆ¤æ–­æ¥å¤„ç†numå’Œké•¿åº¦ä¸ä¸€çš„é—®é¢˜\r\n### pythonä»£ç \r\n```python \r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        index = len(num) - 1\r\n        flag = 0\r\n        res = []\r\n        while index >= 0 or k != 0:\r\n            x = num[index] if index >= 0 else 0\r\n            y = k % 10 if k != 0 else 0\r\n            sum = x + y + flag\r\n            res.append(sum % 10)\r\n            flag = sum // 10\r\n            k = k // 10\r\n            index -= 1\r\n        if flag != 0:\r\n            res.append(flag)\r\n        return res[::-1]\r\n\r\n```\r\n### å¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186531027","body":"### é¢˜ç›®ï¼š1381. è®¾è®¡ä¸€ä¸ªæ”¯æŒå¢é‡æ“ä½œçš„æ ˆ\r\n### æ€è·¯\r\nåˆ©ç”¨æ•°ç»„appendå’Œpopæ–¹æ³•\r\n### pythonä»£ç \r\n``` python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) == self.maxSize:\r\n            return False\r\n        else:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack: return -1\r\n        else:\r\n            return self.stack.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(len(self.stack), k)):\r\n            self.stack[i] += val\r\n```\r\n### å¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(min(maxSize, k))\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186812545","body":"### é¢˜ç›®ï¼š[394. å­—ç¬¦ä¸²è§£ç ](https://leetcode.cn/problems/decode-string/)\r\n### æ€è·¯ï¼š\r\nåˆ©ç”¨æ ˆå…ˆè¿›åå‡ºçš„ç‰¹æ€§æ¨¡æ‹Ÿæ‹¬å·ã€‚éå†å­—ç¬¦ä¸²ï¼Œåˆ¤æ–­æ¯ä¸ªå­—ç¬¦ç±»å‹å¹¶è¿›è¡Œä¸åŒå¤„ç†ã€‚æ ˆä¸»è¦ç”¨æ¥çºªå¾‹è®°å½•æ¯æ¬¡æ‹¬å·ä¹‹å‰å·²ç»æ•´ç†å¥½çš„å­—ç¬¦ä¸²ä»¥åŠæ‹¬å·ä¸­å­—ç¬¦ä¸²çš„å¾ªç¯æ¬¡æ•°ã€‚\r\n### pythonä»£ç \r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        res, tmp, mul = '', '', 0\r\n        for i in s:\r\n            if i.isdigit(): \r\n                mul = int(i) + 10 * mul\r\n            elif i == '[': \r\n                stack.append((mul, res))\r\n                res, mul = '', 0\r\n            elif i == ']':\r\n                mul1, tmp = stack.pop()  # tmpä¸º[ä¹‹å‰çš„æ‰€æœ‰å­—ç¬¦\r\n                res = tmp + mul1 * res\r\n            else:\r\n                res += i\r\n        return res\r\n    \r\n```\r\n### å¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n), e.g. '1[a1[a1[a]]]'","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188613232","body":"### é¢˜ç›®ï¼š[232. ç”¨æ ˆå®ç°é˜Ÿåˆ—](https://leetcode.cn/problems/implement-queue-using-stacks/)\r\n### æ€è·¯ï¼š\r\nç”¨ä¸¤ä¸ªæ ˆæ¨¡æ‹Ÿé˜Ÿåˆ—ï¼Œç¬¬ä¸€ä¸ªæ ˆå°¾æ˜¯é˜Ÿåˆ—çš„å¼€å¤´ï¼Œæ‰€ä»¥æ¯æ¬¡æ‰§è¡Œpushæ“ä½œçš„æ—¶å€™éœ€è¦ç”¨å¦ä¸€ä¸ªæ ˆè®°å½•è¯¥æ ˆçš„æ‰€æœ‰å…ƒç´ ï¼Œæ¸…ç©ºè¯¥æ ˆä¹‹åå†æ‰§è¡Œpushæ“ä½œã€‚\r\n### pythonä»£ç \r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        while self.stack1:\r\n            self.stack2.append(self.stack1.pop())\r\n        self.stack1.append(x)\r\n        while self.stack2:\r\n            self.stack1.append(self.stack2.pop())\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack1: return False\r\n        return self.stack1.pop()\r\n\r\n    def peek(self) -> int:\r\n        if not self.stack1: return False\r\n        return self.stack1[-1]\r\n\r\n    def empty(self) -> bool:\r\n        if not self.stack1 and not self.stack2: return True\r\n        else: return False\r\n\r\n```\r\n### å¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ï¼špush: O(n), pop/peek/empty: O(1)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190030476","body":"### é¢˜ç›® ï¼š[768. æœ€å¤šèƒ½å®Œæˆæ’åºçš„å— II](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/)\r\n### æ€è·¯ï¼š\r\nä½¿ç”¨æ ˆæ¥è®°å½•æ¯ä¸ªå—ä¸­æœ€å¤§å€¼ï¼Œéœ€è¦ä¿è¯æ ˆæ˜¯å•è°ƒçš„ã€‚éå†æ•°ç»„arrï¼Œå°†æ¯ä¸ªå€¼å’Œæ ˆé¡¶çš„å€¼è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœå¤§äºç­‰äºæ ˆé¡¶å€¼åˆ™å…¥æ ˆï¼›å°äºæ ˆé¡¶å€¼åˆ™å°†å–å‡ºæ ˆé¡¶å€¼ï¼Œç›´åˆ°è¯¥å€¼å¤§äºç­‰äºæ ˆé¡¶å€¼ï¼Œå¹¶è®°å½•ä¸‹ç¬¬ä¸€ä¸ªè¢«å–å‡ºçš„æ ˆé¡¶å€¼ã€‚ä¾‹å¦‚ï¼š[5,1,1,8,1,6,5,9,7,8], æ ˆçš„å˜åŒ–è¿‡ç¨‹ä¸ºï¼š[5] -> [5,8] -> [8] -> [9], æ‰€ä»¥æœ€åç»“æœä¸º1ã€‚\r\n### pythonä»£ç \r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        if not arr: return False\r\n        stack = []\r\n        i = 0\r\n        while i < len(arr):\r\n            if not stack: stack.append(arr[i])\r\n            elif arr[i] >= stack[-1]:\r\n                stack.append(arr[i])\r\n            elif arr[i] < stack[-1]:\r\n                head = stack.pop()\r\n                while stack and arr[i] < stack[-1]:\r\n                    stack.pop()\r\n                stack.append(head)\r\n            i += 1\r\n        return len(stack)\r\n```\r\n### å¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œéå†æ•°ç»„\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)ï¼Œæ ˆæ‰€éœ€è¦çš„ç©ºé—´ï¼Œæœ€å·®èƒ½åˆ°O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191578936","body":"### é¢˜ç›®ï¼š61. æ—‹è½¬é“¾è¡¨\n### æ€è·¯ï¼š\nå¿«æ…¢æŒ‡é’ˆ\n### pythonä»£ç \n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next: return head\n        cur = head\n        count = 0\n        while cur:\n            cur = cur.next\n            count += 1\n        k = k % count\n        slow, fast = head, head\n        step = 0\n        while fast.next:\n            step += 1\n            if step > k:\n                slow = slow.next\n            fast = fast.next\n        fast.next = head\n        res = slow.next\n        slow.next = None\n        return res\n```\n### å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192204334","body":"### é¢˜ç›®ï¼š[24. ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹](https://leetcode.cn/problems/swap-nodes-in-pairs/)\r\n### æ€è·¯\r\nä½¿ç”¨ä¸‰ä¸ªæŒ‡é’ˆæ¥è¿­ä»£çš„äº¤æ¢ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œä½¿ç”¨preheadå¤„ç†è¾¹ç•Œé—®é¢˜\r\n### pythonä»£ç \r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next: return head\r\n        prehead = ListNode(0, head)\r\n        pre, cur, tmp = prehead, prehead, prehead\r\n        while cur.next and cur.next.next:\r\n            pre, cur = pre.next, cur.next.next\r\n            tmp.next, cur.next, pre.next = cur, pre, cur.next\r\n            tmp, cur = pre, pre\r\n        return prehead.next\r\n```\r\n### å¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)\r\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195490623","body":"### é¢˜ç›®ï¼š[146. LRU ç¼“å­˜](https://leetcode.cn/problems/lru-cache/)\r\n### æ€è·¯ï¼š\r\nåŒå‘é“¾è¡¨+å“ˆå¸Œè¡¨\r\n### pythonä»£ç \r\n```python\r\nclass LRUCache(collections.OrderedDict):\r\n\r\n    def __init__(self, capacity: int):\r\n        super().__init__()\r\n        self.capacity = capacity\r\n\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self:\r\n            return -1\r\n        self.move_to_end(key)\r\n        return self[key]\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self:\r\n            self.move_to_end(key)\r\n        self[key] = value\r\n        if len(self) > self.capacity:\r\n            self.popitem(last=False)\r\n```\r\n### å¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(1)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(capacity)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196499582","body":"### é¢˜ç›®ï¼š[104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)\r\n### æ€è·¯ï¼š\r\nå¹¿åº¦ä¼˜å…ˆï¼Œæ·±åº¦ä¼˜å…ˆ\r\n### pythonä»£ç \r\n```python\r\n# å¹¿åº¦ä¼˜å…ˆ\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root: return 0\r\n        queue = [root]\r\n        depth = 0\r\n        while queue:\r\n            depth += 1\r\n            length = len(queue)\r\n            for _ in range(length):\r\n                node = queue.pop(0)\r\n                if node.left: queue.append(node.left)\r\n                if node.right: queue.append(node.right)\r\n        return depth\r\n\r\n# æ·±åº¦ä¼˜å…ˆ\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root: return 0\r\n        def DFS(root):\r\n            if not root: return 0\r\n            return max(DFS(root.left), DFS(root.right)) + 1\r\n        return DFS(root)\r\n```\r\n### å¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197556689","body":"### é¢˜ç›®ï¼š[100. ç›¸åŒçš„æ ‘](https://leetcode.cn/problems/same-tree/)\r\n### æ€è·¯\r\næ·±åº¦ä¼˜å…ˆï¼Œå¹¿åº¦ä¼˜å…ˆ\r\n### pythonä»£ç \r\n```python\r\n# æ·±åº¦ä¼˜å…ˆ\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        def DFS(root1, root2):\r\n            if not root1 and not root2:\r\n                return True\r\n            elif not root1 or not root2:\r\n                return False\r\n            elif root1.val != root2.val:\r\n                return False\r\n            return DFS(root1.left, root2.left) and DFS(root1.right, root2.right)\r\n        return DFS(p, q)\r\n```\r\n```python\r\n# å¹¿åº¦ä¼˜å…ˆ\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p and not q: return True\r\n        elif not p or not q: return False\r\n        queue1, queue2 = [p], [q]\r\n        while queue1 and queue2:\r\n            node1 = queue1.pop(0)\r\n            node2 = queue2.pop(0)\r\n\r\n            if node1.val != node2.val: return False\r\n\r\n            if node1.left and node2.left:\r\n                queue1.append(node1.left)\r\n                queue2.append(node2.left)\r\n            elif node1.left or node2.left:\r\n                return False\r\n\r\n            if node1.right and node2.right:\r\n                queue1.append(node1.right)\r\n                queue2.append(node2.right)\r\n            elif node1.right or node2.right:\r\n                return False\r\n            \r\n        if not queue1 and not queue2: return True\r\n        else: return False\r\n\r\n```\r\n### å¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(min(m,n))\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(min(m,n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199550750","body":"### é¢˜ç›®ï¼š[129. æ±‚æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹æ•°å­—ä¹‹å’Œ](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)\r\n### æ€è·¯ï¼š\r\nDFS\r\n### pythonä»£ç \r\n```python\r\nclass Solution:\r\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\r\n        def DFS(root, presum):\r\n            if not root: return 0\r\n            tmp = presum * 10 + root.val\r\n            if not root.left and not root.right:\r\n                return tmp\r\n            return DFS(root.left, tmp) + DFS(root.right, tmp)\r\n        return DFS(root, 0)\r\n```\r\n### å¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200224432","body":"### é¢˜ç›®ï¼š[513. æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼](https://leetcode.cn/problems/find-bottom-left-tree-value/)\r\n### æ€è·¯ï¼š\r\nBFS\r\n- æ–¹æ³•1: æ­£å¸¸ä»å·¦åˆ°å³éå†ï¼Œè®°å½•æ¯ä¸€è¡Œæœ€å·¦è¾¹çš„å€¼\r\n- æ–¹æ³•2: ä»å³åˆ°å·¦éå†ï¼Œè®°å½•æœ€åä¸€ä¸ªå€¼\r\n### pythonä»£ç \r\n```python\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        # queue = [root]\r\n        # while queue:\r\n        #     length = len(queue)\r\n        #     res = queue[0].val\r\n        #     for _ in range(length):\r\n        #         node = queue.pop(0)\r\n        #         if node.left: queue.append(node.left)\r\n        #         if node.right: queue.append(node.right)\r\n        # return res\r\n        queue = [root]\r\n        while queue:\r\n            node = queue.pop(0)\r\n            if node.right: queue.append(node.right)\r\n            if node.left: queue.append(node.left)\r\n            res = node.val\r\n        return res\r\n```\r\n### å¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201352725","body":"### é¢˜ç›®ï¼š[987. äºŒå‰æ ‘çš„å‚åºéå†](https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/)\r\n### æ€è·¯ï¼š\r\nDFS\r\n### python ä»£ç \r\n```python\r\nclass Solution:\r\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\r\n        def dfs(root, row, col) -> None:\r\n            if not root: return\r\n            nodes.append((col, row, root.val))\r\n            dfs(root.left, row + 1, col - 1)\r\n            dfs(root.right, row + 1, col + 1)\r\n        nodes = []\r\n        dfs(root, 0, 0)\r\n        nodes.sort()\r\n        res, lastcol = [], float(\"-inf\")\r\n        for col, row, value in nodes:\r\n            if col != lastcol:\r\n                lastcol = col\r\n                res.append([])\r\n            res[-1].append(value)\r\n        \r\n        return res\r\n```\r\n### å¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(NlogN)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202034952","body":"### é¢˜ç›®ï¼š[1. ä¸¤æ•°ä¹‹å’Œ](https://leetcode.cn/problems/two-sum/)\r\n### æ€è·¯\r\nåˆ©ç”¨å­—å…¸æŸ¥è¯¢æ—¶é—´å¤æ‚åº¦ä¸ºO(1)\r\n### python ä»£ç \r\n```python\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        dict1 = dict()\r\n        for i, num in enumerate(nums):\r\n            if target - num in dict1:\r\n                return [dict1[target-num], i]\r\n            dict1[num] = i\r\n        return dict1\r\n        \r\n```\r\n### å¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203504473","body":"### é¢˜ç›®ï¼š[347. å‰ K ä¸ªé«˜é¢‘å…ƒç´ ](https://leetcode.cn/problems/top-k-frequent-elements/)\r\n### æ€è·¯\r\nå“ˆå¸Œè¡¨å­˜å…ƒç´ å‡ºç°æ¬¡æ•°ï¼Œå †é€‰å‡ºtopk\r\n### pythonä»£ç \r\n```python\r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        count = collections.Counter(nums)\r\n        h = []\r\n        for num, cnt in count.items():\r\n            heapq.heappush(h, (cnt, num))\r\n            if len(h) > k:\r\n                heapq.heappop(h)\r\n        return [num for cnt, num in h]\r\n```\r\n### å¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(nlogk), Counterå¤æ‚åº¦O(n), å †æ’åºå¤æ‚åº¦O(nlogk)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205349709","body":"### é¢˜ç›®ï¼š[447. å›æ—‹é•–çš„æ•°é‡](https://leetcode.cn/problems/number-of-boomerangs/)\r\n### æ€è·¯\r\nå“ˆå¸Œè¡¨ä½¿ç”¨+æš´åŠ›æšä¸¾ï¼Œæ³¨æ„æ’åˆ—çš„ç®—æ³•\r\n### pythonä»£ç \r\n```python\r\nclass Solution:\r\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\r\n        res = 0\r\n        for p1 in points:\r\n            cnt = defaultdict(int)\r\n            for p2 in points:\r\n                dist = (p1[0] - p2[0])*(p1[0] - p2[0]) + (p1[1] - p2[1])*(p1[1] - p2[1])\r\n                cnt[dist] += 1\r\n            for i in cnt.values():\r\n                res += i*(i-1)\r\n        return res\r\n```\r\n### å¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N^2)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206076973","body":"### é¢˜ç›®ï¼š[3. æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)\r\n### æ€è·¯\r\nå“ˆå¸Œè¡¨+æ»‘åŠ¨çª—å£ï¼Œæ³¨æ„æ¡ä»¶åˆ¤æ–­å’ŒæŒ‡é’ˆå‰è¿›çš„é¡ºåºå…³ç³»\r\n### pythonä»£ç \r\n```python\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        tmp = set()\r\n        l, res = 0, 0\r\n        cur_len = 0\r\n        for r in range(len(s)):\r\n            cur_len += 1\r\n            while s[r] in tmp:\r\n                tmp.remove(s[l])\r\n                cur_len -=1\r\n                l += 1\r\n            tmp.add(s[r])\r\n            res = max(res , cur_len)\r\n        return res\r\n```\r\n### å¤æ‚åº¦ï¼š\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jawn-ha":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186545797","body":"### æ€è·¯\r\nç”¨æ•°ç»„å®ç°\r\n### ä»£ç \r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.maxSize = maxSize\r\n    this.stack = []\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.stack.length < this.maxSize) {\r\n        this.stack.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    return this.stack.length ? this.stack.pop() : -1\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    let len = Math.min(k, this.stack.length)\r\n    for(let i = 0; i < len; i++) {\r\n        this.stack[i] += val\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n### å¤æ‚åº¦åˆ†æ\r\næ—¶é—´å¤æ‚åº¦ï¼špush å’Œ pop æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¸º O(1) è€Œ increment æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¸º O(min(k, cnt))\r\nç©ºé—´å¤æ‚åº¦ï¼šO(1)O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187631118","body":"### æ€è·¯\r\næ–°å¢ä¸¤ä¸ªæ ˆï¼Œä¸€ä¸ªå­˜å€æ•°ï¼Œä¸€ä¸ªå­˜å¾…æ‹¼æ¥çš„ str\r\nå½“ item æ˜¯æ•°å­—æ—¶ï¼Œæ±‚å…·ä½“å€æ•°\r\nå½“ item === '[' æ—¶ï¼ŒnumStack å…¥æ ˆï¼ŒstrStack å…¥æ ˆï¼Œå¹¶ä¸” resultã€num é‡ç½®\r\nå½“ item === ']' æ—¶ï¼ŒnumStackã€strStack å‡ºæ ˆï¼Œå¹¶å°† result é‡å¤ å¯¹åº”å€æ•°\r\n### ä»£ç \r\n```js\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let numStack = []\r\n    let strStack = []\r\n    let num = 0, result = ''\r\n    for(let i= 0; i < s.length; i++) {\r\n        const item = s[i]\r\n        if(!isNaN(item)){\r\n            num = num * 10 + parseInt(item)\r\n        } else if(item === '[') {\r\n            strStack.push(result)\r\n            result = ''\r\n            numStack.push(num)\r\n            num = 0\r\n        } else if (item === ']') {\r\n            const repeatTimes = numStack.pop()\r\n            result = strStack.pop() + result.repeat(repeatTimes)\r\n        } else {\r\n            result += item\r\n        }\r\n    }\r\n    return result\r\n};\r\n```\r\n### å¤æ‚åº¦åˆ†æ\r\næ—¶é—´å¤æ‚åº¦ O(n)\r\nç©ºé—´å¤æ‚åº¦ O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189147371","body":"### æ€è·¯\r\nåŒæ ˆå®ç°\r\n### ä»£ç \r\n```js\r\nvar MyQueue = function () {\r\n  this.inStack = [];\r\n  this.outStack = [];\r\n};\r\n\r\nMyQueue.prototype.push = function (x) {\r\n  this.inStack.push(x);\r\n};\r\n\r\nMyQueue.prototype.pop = function () {\r\n  if (!this.outStack.length) {\r\n    this.in2out();\r\n  }\r\n  return this.outStack.pop();\r\n};\r\n\r\nMyQueue.prototype.peek = function () {\r\n  if (!this.outStack.length) {\r\n    this.in2out();\r\n  }\r\n  return this.outStack[this.outStack.length - 1];\r\n};\r\n\r\nMyQueue.prototype.empty = function () {\r\n  return this.outStack.length === 0 && this.inStack.length === 0;\r\n};\r\n\r\nMyQueue.prototype.in2out = function () {\r\n  while (this.inStack.length) {\r\n    this.outStack.push(this.inStack.pop());\r\n  }\r\n}\r\n```\r\n### å¤æ‚åº¦åˆ†æ\r\næ—¶é—´å¤æ‚åº¦ï¼š O(n)\r\nç©ºé—´å¤æ‚åº¦ï¼š O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191543867","body":"### æ€è·¯\nå°†é“¾è¡¨è¿æˆç¯ï¼Œç„¶åæ–­å¼€å¤„äºn-k-1ä½ç½®çš„æŒ‡é’ˆ\nå…ˆéå†é“¾è¡¨æ‰¾åˆ°å°¾èŠ‚ç‚¹è¿ç€å¤´\néå†æ‰¾åˆ°n-k-1çš„ä½ç½®ï¼Œæ–­å¼€èŠ‚ç‚¹\n### ä»£ç \n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if(!head || !head.next) return head\n    let count = 0\n    let p = head \n    while(p) {\n        count++\n        p = p.next\n    }\n    k = k % count\n    let slow = fast = head\n    while(fast.next) {\n        if(k-- <= 0) {\n            slow = slow.next\n        }\n        fast = fast.next\n    }\n    fast.next = head\n    let res = slow.next\n    slow.next = null\n    return res\n};\n```\n### å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦ O(n)\nç©ºé—´å¤æ‚åº¦ O(1)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196840850","body":"### æ€è·¯\né€’å½’ï¼Œå‰åºdepth + 1ï¼Œåç»­ depth - 1\n\n### ä»£ç \n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    let res = 0 \n    let depth = 0   \n    let traverse = (root) => {\n        if(root === null) {\n            return \n        }\n        depth ++\n        if (root.left === null && root.right === null) {\n            // åˆ°è¾¾å¶å­èŠ‚ç‚¹ï¼Œæ›´æ–°æœ€å¤§æ·±åº¦\n            res = Math.max(res, depth);\n        }\n        traverse(root.left);\n        traverse(root.right);\n        // ååºä½ç½®\n        depth--;\n    }\n    traverse(root)\n    return res\n};\n```\n### å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦ O(N)\nç©ºé—´å¤æ‚åº¦ O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198254085","body":"### æ€è·¯\né€’å½’\n### ä»£ç \n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n    if ( p === null && q === null) {\n        return true\n    }\n    if ( p === null || q === null) {\n        return false\n    }\n    if ( p.val !== q.val) {\n        return false\n    }\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n};\n```\n### å¤æ‚åº¦åˆ†æ\næ—¶é—´å¤æ‚åº¦ï¼š O(n)\nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200371154","body":"### æ€è·¯\nå‰åºéå†\n### ä»£ç \n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n    let res = []\n    let traverse = (root, res) => {\n         if ( root === null ) {\n            res.push('#')\n            return\n        }\n        traverse(root.left, res)\n        traverse(root.right, res)\n        res.push(root.val)\n    }\n    traverse(root, res)\n    return res.join(',')\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n    let nodes = data.split(',')\n    let traverse = (nodes) => {\n        if(nodes.length === 0) return null\n        let last = nodes.pop()\n        if(last === '#') return null\n        let root = new TreeNode(parseInt(last))\n        \n        root.right = traverse(nodes)\n        root.left = traverse(nodes)\n       \n        return root\n    }\n    return traverse(nodes)\n};\n\n```\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1204091271","body":"### æ€è·¯\nå°é¡¶å †\n\n### ä»£ç \n```js\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar topKFrequent = function(nums, k) {\n  const map = new Map();\n  \n  for(const num of nums) {\n    map.set(num, (map.get(num) || 0) + 1);\n  }\n\n  // åˆ›å»ºå°é¡¶å †\n  const priorityQueue = new PriorityQueue((a, b) => a[1] - b[1]);\n\n  // entry æ˜¯ä¸€ä¸ªé•¿åº¦ä¸º2çš„æ•°ç»„ï¼Œ0ä½ç½®å­˜å‚¨keyï¼Œ1ä½ç½®å­˜å‚¨value\n  for (const entry of map.entries()) {\n    priorityQueue.push(entry);\n    if (priorityQueue.size() > k) {\n      priorityQueue.pop();\n    }\n  }\n\n  const ret = [];\n\n  for(let i = priorityQueue.size() - 1; i >= 0; i--) {\n    ret[i] = priorityQueue.pop()[0];\n  }\n\n  return ret;\n};\n\n\nfunction PriorityQueue(compareFn) {\n  this.compareFn = compareFn;\n  this.queue = [];\n}\n\n// æ·»åŠ \nPriorityQueue.prototype.push = function(item) {\n  this.queue.push(item);\n  let index = this.queue.length - 1;\n  let parent = Math.floor((index - 1) / 2);\n  // ä¸Šæµ®\n  while(parent >= 0 && this.compare(parent, index) > 0) {\n    // äº¤æ¢\n    [this.queue[index], this.queue[parent]] = [this.queue[parent], this.queue[index]];\n    index = parent;\n    parent = Math.floor((index - 1) / 2);\n  }\n}\n\n// è·å–å †é¡¶å…ƒç´ å¹¶ç§»é™¤\nPriorityQueue.prototype.pop = function() {\n  const ret = this.queue[0];\n\n  // æŠŠæœ€åä¸€ä¸ªèŠ‚ç‚¹ç§»åˆ°å †é¡¶\n  this.queue[0] = this.queue.pop();\n\n  let index = 0;\n  // å·¦å­èŠ‚ç‚¹ä¸‹æ ‡ï¼Œleft + 1 å°±æ˜¯å³å­èŠ‚ç‚¹ä¸‹æ ‡\n  let left = 1;\n  let selectedChild = this.compare(left, left + 1) > 0 ? left + 1 : left;\n\n  // ä¸‹æ²‰\n  while(selectedChild !== undefined && this.compare(index, selectedChild) > 0) {\n    // äº¤æ¢\n    [this.queue[index], this.queue[selectedChild]] = [this.queue[selectedChild], this.queue[index]];\n    index = selectedChild;\n    left = 2 * index + 1;\n    selectedChild = this.compare(left, left + 1) > 0 ? left + 1 : left;\n  }\n\n  return ret;\n}\n\nPriorityQueue.prototype.size = function() {\n  return this.queue.length;\n}\n\n// ä½¿ç”¨ä¼ å…¥çš„ compareFn æ¯”è¾ƒä¸¤ä¸ªä½ç½®çš„å…ƒç´ \nPriorityQueue.prototype.compare = function(index1, index2) {\n  if (this.queue[index1] === undefined) {\n    return 1;\n  }\n  if (this.queue[index2] === undefined) {\n    return -1;\n  }\n\n  return this.compareFn(this.queue[index1], this.queue[index2]);\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205324698","body":"### æ€è·¯\næšä¸¾ + å“ˆå¸Œè¡¨\n### ä»£ç \n```js\n/**\n * @param {number[][]} points\n * @return {number}\n */\nvar numberOfBoomerangs = function(points) {\n    let res = 0\n    for ( const p of points) {\n        const map = new Map()\n        for(const q of points) {\n            const dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1])\n            map.set(dis, (map.get(dis) || 0) + 1)\n        }\n        for(const [_, m] of map.entries()) {\n           res += m * (m - 1) \n        }\n    }\n    return res\n};\n```\n### å¤æ‚åº¦\næ—¶é—´ï¼šO(n^2)\nç©ºé—´ï¼šO(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hanwangxxx":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186549520","body":"class CustomStack:\n\n    def __init__(self, size: int):\n        self.st = []\n        self.cnt = 0\n        self.size = size\n\n    def push(self, x: int) -> None:\n        if self.cnt < self.size:\n            self.st.append(x)\n            self.cnt += 1\n\n\n    def pop(self) -> int:\n        if self.cnt == 0: return -1\n        self.cnt -= 1\n        return self.st.pop()\n\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(0, min(self.cnt, k)):\n            self.st[i] += val","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190747230","body":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        def calculateLen(head):\n            n=1\n            while head.next:\n                n+=1\n                head = head.next\n            return n\n\n        if k==0 or not head or not head.next:\n            return head\n\n        n = calculateLen(head)\n        k=k%n\n        fast = slow = head\n        for i in range (k):\n            fast = fast.next\n        \n        while fast.next:\n            fast = fast.next\n            slow = slow.next\n\n        fast.next = head\n        head = slow.next\n        slow.next = None\n        \n        return head\n\n        \n        \n        \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1191952971","body":"class Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        dummy = ListNode(0, head)\n        prev, curr = dummy, head\n        while curr and curr.next:\n            nxtpair = curr.next.next\n            second = curr.next\n\n            second.next = curr\n            curr.next = nxtpair\n            prev.next = second\n\n            prev = curr\n            curr = nxtpair\n        return dummy.next","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193351118","body":"    def detectCycle(self, head: ListNode) -> ListNode:\n        f=s=head\n        while f and f.next:\n            f = f.next.next\n            s = s.next\n            if f == s:\n                f = head\n                while f!=s:\n                    f= f.next\n                    s = s.next\n                return s","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194447938","body":"class ListNode:\n    def __init__(self, key, val):\n        self.key = key\n        self.val = val\n        self.prev = self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.left , self.right = ListNode(0,0),ListNode(0,0)\n        self.left.next = self.right\n        self.right.prev = self.left\n\n    def insert(self,node):\n        prev, nxt = self.right.prev, self.right\n        prev.next = nxt.prev = node\n        node.prev, node.next = prev, nxt\n        \n    def remove(self, node):\n        prev, nxt = node.prev, node.next\n        prev.next, nxt.prev = nxt, prev\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            self.remove(self.cache[key])\n            self.insert(self.cache[key])\n            return self.cache[key].val\n        else:\n            return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.remove(self.cache[key])\n        self.cache[key] = ListNode(key, value)\n        self.insert(self.cache[key])\n\n        if len(self.cache) > self.capacity:\n            lru = self.left.next\n            self.remove(lru)\n            del self.cache[lru.key]\n            \n\n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1195961672","body":"class Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left),self.maxDepth(root.right))","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200306609","body":"class Codec:\n    def serialize(self, root):\n        ans = ''\n        queue = [root]\n        while queue:\n            node = queue.pop(0)\n            if node:\n                ans += str(node.val) + ','\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                ans += '#,'\n        print(ans[:-1])\n        return ans[:-1]\n\n\n\n    def deserialize(self, data: str):\n        if data == '#': return None\n        nodes = data.split(',')\n        if not nodes: return None\n        root = TreeNode(nodes[0])\n        queue = [root]\n        # å·²ç»æœ‰ root äº†ï¼Œå› æ­¤ä» 1 å¼€å§‹\n        i = 1\n\n        while i < len(nodes) - 1:\n            node = queue.pop(0)\n            lv = nodes[i]\n            rv = nodes[i + 1]\n            i += 2\n            if lv != '#':\n                l = TreeNode(lv)\n                node.left = l\n                queue.append(l)\n\n            if rv != '#':\n                r = TreeNode(rv)\n                node.right = r\n                queue.append(r)\n        return root","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201784600","body":"class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        map={}\n        for i,v in enumerate(nums):\n            diff=target-v\n            if diff in map:\n                return [map[diff],i]\n            map[v]=i","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206474902","body":"class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        res = 0\n        sw = set()\n        l=0\n\n        for r in range(len(s)):\n            while s[r] in sw:\n                sw.remove(s[l])\n                l+=1\n            sw.add(s[r])\n            res = max(res, r-l+1)\n        return res","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207500423","body":"class Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        f = s =head\n        while f and f.next:\n            f = f.next.next\n            s = s.next\n        return s","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dujt-x":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186977163","body":"# æ€è·¯ï¼š\r\næœ¬é¢˜ä¸­å¯èƒ½å‡ºç°æ‹¬å·åµŒå¥—çš„æƒ…å†µï¼Œæ¯”å¦‚`2[a2[bc]]`ï¼Œè¿™ç§æƒ…å†µä¸‹æˆ‘ä»¬å¯ä»¥å…ˆè½¬åŒ–æˆ`2[abcbc]`ï¼Œåœ¨è½¬åŒ–æˆ `abcbcabcbc`ã€‚æˆ‘ä»¬å¯ä»¥æŠŠå­—æ¯ã€æ•°å­—å’Œæ‹¬å·çœ‹æˆæ˜¯ç‹¬ç«‹çš„ TOKENï¼Œå¹¶ç”¨æ ˆæ¥ç»´æŠ¤è¿™äº› TOKENã€‚\r\n___\r\n# ä»£ç å®ç°\r\nC++\r\n```C++\r\nclass Solution {\r\npublic:\r\n    string getDigits(string &s, size_t &ptr) {\r\n        string ret = \"\";\r\n        while (isdigit(s[ptr])) {\r\n            ret.push_back(s[ptr++]);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    string getString(vector <string> &v) {\r\n        string ret;\r\n        for (const auto &s: v) {\r\n            ret += s;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    string decodeString(string s) {\r\n        vector <string> stk;\r\n        size_t ptr = 0;\r\n\r\n        while (ptr < s.size()) {\r\n            char cur = s[ptr];\r\n            if (isdigit(cur)) {\r\n                // è·å–ä¸€ä¸ªæ•°å­—å¹¶è¿›æ ˆ\r\n                string digits = getDigits(s, ptr);\r\n                stk.push_back(digits);\r\n            } else if (isalpha(cur) || cur == '[') {\r\n                // è·å–ä¸€ä¸ªå­—æ¯å¹¶è¿›æ ˆ\r\n                stk.push_back(string(1, s[ptr++])); \r\n            } else {\r\n                ++ptr;\r\n                vector <string> sub;\r\n                while (stk.back() != \"[\") {\r\n                    sub.push_back(stk.back());\r\n                    stk.pop_back();\r\n                }\r\n                reverse(sub.begin(), sub.end());\r\n                // å·¦æ‹¬å·å‡ºæ ˆ\r\n                stk.pop_back();\r\n                // æ­¤æ—¶æ ˆé¡¶ä¸ºå½“å‰ sub å¯¹åº”çš„å­—ç¬¦ä¸²åº”è¯¥å‡ºç°çš„æ¬¡æ•°\r\n                int repTime = stoi(stk.back()); \r\n                stk.pop_back();\r\n                string t, o = getString(sub);\r\n                // æ„é€ å­—ç¬¦ä¸²\r\n                while (repTime--) t += o; \r\n                // å°†æ„é€ å¥½çš„å­—ç¬¦ä¸²å…¥æ ˆ\r\n                stk.push_back(t);\r\n            }\r\n        }\r\n\r\n        return getString(stk);\r\n    }\r\n};\r\n```\r\n___\r\n# å¤æ‚åº¦åˆ†æ\r\næ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\nç©ºé—´å¤æ‚åº¦ï¼šO(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189234348","body":"# æ€è·¯\r\næˆ‘ä»¬ä½¿ç”¨ä¸¤ä¸ªæ ˆ`s1,s2` å°±èƒ½å®ç°ä¸€ä¸ªé˜Ÿåˆ—çš„åŠŸèƒ½ã€‚\r\n\r\nå½“è°ƒç”¨`push`è®©å…ƒç´ å…¥é˜Ÿæ—¶ï¼Œåªè¦æŠŠå…ƒç´ å‹å…¥`s1`å³å¯ï¼š\r\n___\r\n# ä»£ç å®ç°\r\nC++\r\n```C++\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> inStack, outStack;\r\n\r\n    void in2out() {\r\n        while (!inStack.empty()) {\r\n            outStack.push(inStack.top());\r\n            inStack.pop();\r\n        }\r\n    }\r\n\r\npublic:\r\n    MyQueue() {}\r\n\r\n    void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n\r\n    int pop() {\r\n        if (outStack.empty()) {\r\n            in2out();\r\n        }\r\n        int x = outStack.top();\r\n        outStack.pop();\r\n        return x;\r\n    }\r\n\r\n    int peek() {\r\n        if (outStack.empty()) {\r\n            in2out();\r\n        }\r\n        return outStack.top();\r\n    }\r\n\r\n    bool empty() {\r\n        return inStack.empty() && outStack.empty();\r\n    }\r\n};\r\n```\r\n___\r\n# å¤æ‚åº¦åˆ†æ\r\næ—¶é—´å¤æ‚åº¦ï¼šO(1)\r\nç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193773379","body":"# æ€è·¯\r\nåˆ¤æ–­ä¸¤ä¸ªé“¾è¡¨æ˜¯å¦ç›¸äº¤ï¼Œå¯ä»¥ä½¿ç”¨å“ˆå¸Œé›†åˆå­˜å‚¨é“¾è¡¨èŠ‚ç‚¹ã€‚\r\n\r\né¦–å…ˆéå†é“¾è¡¨ `headA`ï¼Œå¹¶å°†é“¾è¡¨ `headA` ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹åŠ å…¥å“ˆå¸Œé›†åˆä¸­ã€‚ç„¶åéå†é“¾è¡¨ `headB`ï¼Œå¯¹äºéå†åˆ°çš„æ¯ä¸ªèŠ‚ç‚¹ï¼Œåˆ¤æ–­è¯¥èŠ‚ç‚¹æ˜¯å¦åœ¨å“ˆå¸Œé›†åˆä¸­ï¼š\r\n\r\n* å¦‚æœå½“å‰èŠ‚ç‚¹ä¸åœ¨å“ˆå¸Œé›†åˆä¸­ï¼Œåˆ™ç»§ç»­éå†ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼›\r\n\r\n* å¦‚æœå½“å‰èŠ‚ç‚¹åœ¨å“ˆå¸Œé›†åˆä¸­ï¼Œåˆ™åé¢çš„èŠ‚ç‚¹éƒ½åœ¨å“ˆå¸Œé›†åˆä¸­ï¼Œå³ä»å½“å‰èŠ‚ç‚¹å¼€å§‹çš„æ‰€æœ‰èŠ‚ç‚¹éƒ½åœ¨ä¸¤ä¸ªé“¾è¡¨çš„ç›¸äº¤éƒ¨åˆ†ï¼Œå› æ­¤åœ¨é“¾è¡¨ `headB` ä¸­éå†åˆ°çš„ç¬¬ä¸€ä¸ªåœ¨å“ˆå¸Œé›†åˆä¸­çš„èŠ‚ç‚¹å°±æ˜¯ä¸¤ä¸ªé“¾è¡¨ç›¸äº¤çš„èŠ‚ç‚¹ï¼Œè¿”å›è¯¥èŠ‚ç‚¹ã€‚\r\n\r\nå¦‚æœé“¾è¡¨ `headB` ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹éƒ½ä¸åœ¨å“ˆå¸Œé›†åˆä¸­ï¼Œåˆ™ä¸¤ä¸ªé“¾è¡¨ä¸ç›¸äº¤ï¼Œè¿”å› `null`ã€‚\r\n___\r\n# ä»£ç å®ç°\r\nC++\r\n```C++\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        unordered_set<ListNode *> visited;\r\n        ListNode *temp = headA;\r\n        while (temp != nullptr) {\r\n            visited.insert(temp);\r\n            temp = temp->next;\r\n        }\r\n        temp = headB;\r\n        while (temp != nullptr) {\r\n            if (visited.count(temp)) {\r\n                return temp;\r\n            }\r\n            temp = temp->next;\r\n        }\r\n        return nullptr;\r\n    }\r\n};\r\n```\r\n___\r\n# å¤æ‚åº¦åˆ†æ\r\næ—¶é—´å¤æ‚åº¦ï¼šO(m+n)ï¼Œå…¶ä¸­ m å’Œ n æ˜¯åˆ†åˆ«æ˜¯é“¾è¡¨ }headA å’Œ headB çš„é•¿åº¦ã€‚éœ€è¦éå†ä¸¤ä¸ªé“¾è¡¨å„ä¸€æ¬¡ã€‚\r\nç©ºé—´å¤æ‚åº¦ï¼šO(m)ï¼Œå…¶ä¸­ m æ˜¯é“¾è¡¨ headA çš„é•¿åº¦ã€‚éœ€è¦ä½¿ç”¨å“ˆå¸Œé›†åˆå­˜å‚¨é“¾è¡¨ headA ä¸­çš„å…¨éƒ¨èŠ‚ç‚¹ã€‚\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193732280","body":"# æ€è·¯\r\néå†é“¾è¡¨ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹ï¼Œå¹¶å°†å®ƒè®°å½•ä¸‹æ¥ï¼›ä¸€æ—¦é‡åˆ°äº†æ­¤å‰éå†è¿‡çš„èŠ‚ç‚¹ï¼Œå°±å¯ä»¥åˆ¤å®šé“¾è¡¨ä¸­å­˜åœ¨ç¯ã€‚å€ŸåŠ©å“ˆå¸Œè¡¨å¯ä»¥å¾ˆæ–¹ä¾¿åœ°å®ç°ã€‚\r\n***\r\n# ä»£ç å®ç°\r\nC++\r\n```C++\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        unordered_set<ListNode *> visited;\r\n        while (head != nullptr) {\r\n            if (visited.count(head)) {\r\n                return head;\r\n            }\r\n            visited.insert(head);\r\n            head = head->next;\r\n        }\r\n        return nullptr;\r\n    }\r\n};\r\n```\r\n---\r\n# å¤æ‚åº¦åˆ†æ\r\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\r\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200853624","body":"# æ€è·¯\r\næˆ‘ä»¬å¯ä»¥ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œå¯¹æ•´æ£µæ ‘è¿›è¡Œä¸€æ¬¡éå†ï¼Œåœ¨éå†çš„è¿‡ç¨‹ä¸­ä½¿ç”¨æ•°ç»„ \\textit{nodes}nodes è®°å½•ä¸‹æ¯ä¸ªèŠ‚ç‚¹çš„è¡Œå· `row`ï¼Œåˆ—å· `col` ä»¥åŠå€¼ `value`ã€‚åœ¨éå†å®Œæˆåï¼Œæˆ‘ä»¬æŒ‰ç…§ `col` ä¸ºç¬¬ä¸€å…³é”®å­—å‡åºï¼Œ`row` ä¸ºç¬¬äºŒå…³é”®å­—å‡åºï¼Œ`value` ä¸ºç¬¬ä¸‰å…³é”®å­—å‡åºï¼Œå¯¹æ‰€æœ‰çš„èŠ‚ç‚¹è¿›è¡Œæ’åºå³å¯ã€‚\r\n\r\nåœ¨æ’åºå®Œæˆåï¼Œæˆ‘ä»¬è¿˜éœ€è¦æŒ‰ç…§é¢˜ç›®è¦æ±‚ï¼Œå°†åŒä¸€åˆ—çš„æ‰€æœ‰èŠ‚ç‚¹æ”¾å…¥åŒä¸€ä¸ªæ•°ç»„ä¸­ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹ `nodes` è¿›è¡Œä¸€æ¬¡éå†ï¼Œå¹¶åœ¨éå†çš„è¿‡ç¨‹ä¸­è®°å½•ä¸Šä¸€ä¸ªèŠ‚ç‚¹çš„åˆ—å· `lastcol`ã€‚å¦‚æœå½“å‰éå†åˆ°çš„èŠ‚ç‚¹çš„åˆ—å· `col` ä¸ `lastcol` ç›¸ç­‰ï¼Œåˆ™å°†è¯¥èŠ‚ç‚¹æ”¾å…¥ä¸ä¸Šä¸€ä¸ªèŠ‚ç‚¹ç›¸åŒçš„æ•°ç»„ä¸­ï¼Œå¦åˆ™æ”¾å…¥ä¸åŒçš„æ•°ç»„ä¸­ã€‚\r\n***\r\n# ä»£ç å®ç°\r\nC++\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\r\n        vector<tuple<int, int, int>> nodes;\r\n\r\n        function<void(TreeNode*, int, int)> dfs = [&](TreeNode* node, int row, int col) {\r\n            if (!node) {\r\n                return;\r\n            }\r\n            nodes.emplace_back(col, row, node->val);\r\n            dfs(node->left, row + 1, col - 1);\r\n            dfs(node->right, row + 1, col + 1);\r\n        };\r\n\r\n        dfs(root, 0, 0);\r\n        sort(nodes.begin(), nodes.end());\r\n        vector<vector<int>> ans;\r\n        int lastcol = INT_MIN;\r\n        for (const auto& [col, row, value]: nodes) {\r\n            if (col != lastcol) {\r\n                lastcol = col;\r\n                ans.emplace_back();\r\n            }\r\n            ans.back().push_back(value);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n***\r\n# å¤æ‚åº¦åˆ†æ\r\næ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)\r\nç©ºé—´å¤æ‚åº¦ï¼šO(n)\r\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207853336","body":"# æ€è·¯\r\né“¾è¡¨çš„ç¼ºç‚¹åœ¨äºä¸èƒ½é€šè¿‡ä¸‹æ ‡è®¿é—®å¯¹åº”çš„å…ƒç´ ã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥è€ƒè™‘å¯¹é“¾è¡¨è¿›è¡Œéå†ï¼ŒåŒæ—¶å°†éå†åˆ°çš„å…ƒç´ ä¾æ¬¡æ”¾å…¥æ•°ç»„`A`ä¸­ã€‚å¦‚æœæˆ‘ä»¬éå†åˆ°äº†Nä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆé“¾è¡¨ä»¥åŠæ•°ç»„çš„é•¿åº¦ä¹Ÿä¸ºNï¼Œå¯¹åº”çš„ä¸­é—´èŠ‚ç‚¹å³ä¸º`A[N/2]`ã€‚\r\n***\r\n# ä»£ç å®ç°\r\nC++\r\n```C++\r\nclass Solution {\r\npublic:\r\n    ListNode* middleNode(ListNode* head) {\r\n        vector<ListNode*> A = {head};\r\n        while (A.back()->next != NULL)\r\n            A.push_back(A.back()->next);\r\n        return A[A.size() / 2];\r\n    }\r\n};\r\n```\r\n***\r\n# å¤æ‚åº¦åˆ†æ\r\næ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­Næ˜¯ç»™å®šé“¾è¡¨ä¸­çš„ç»“ç‚¹æ•°ç›®ã€‚\r\n\r\nç©ºé—´å¤æ‚åº¦ï¼šO(N)ï¼Œå³æ•°ç»„`A` ç”¨å»çš„ç©ºé—´ã€‚","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"degndaixingqiu":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187137051","body":"```class Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<int> st_num;   \r\n        string symbol;       \r\n        int num=0;           \r\n        for(int i=0;i<s.size();i++)\r\n        {\r\n            if(s[i]>='0'&&s[i]<='9'){ \r\n                num=s[i]-'0'+num*10;\r\n            }else if(s[i]=='['){       \r\n                st_num.push(num);\r\n                num=0;\r\n                symbol+=s[i];\r\n            }else if(s[i]==']'){       \r\n                int j=symbol.size()-1;\r\n                string tmp_string;\r\n                while(symbol[j]!='[')\r\n                {\r\n                    tmp_string+=symbol[j];\r\n                    symbol.pop_back();\r\n                    j--;\r\n                }\r\n                symbol.pop_back();\r\n                int tmp_num=st_num.top();\r\n                st_num.pop();\r\n                reverse(tmp_string.begin(),tmp_string.end());\r\n                for(int k=0;k<tmp_num;k++)\r\n                {\r\n                    symbol+=tmp_string;\r\n                }\r\n            }else{                     \r\n                symbol+=s[i];\r\n            }\r\n        }\r\n        return symbol;\r\n    }\r\n};\r\n\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189082702","body":"```\r\nclass MyQueue {\r\npublic:\r\n    stack<int> st, tem;\r\n    MyQueue() {\r\n        \r\n    }\r\n    \r\n    void push(int x) {\r\n        st.push(x);\r\n    }\r\n    void get() {\r\n        if (tem.empty()) {\r\n            while (!st.empty()) {\r\n                tem.push(st.top());\r\n                st.pop();\r\n            } \r\n        }\r\n    }\r\n    int pop() {\r\n        int t;\r\n        get();\r\n        t = tem.top();\r\n        tem.pop();    \r\n        return t;\r\n    }\r\n    \r\n    int peek() {\r\n        get();\r\n        return tem.top();\r\n    }\r\n    \r\n    bool empty() {\r\n        return tem.empty() && st.empty();\r\n    }\r\n};","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192585179","body":"```class Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* dummyHead = new ListNode(0); \n        dummyHead->next = head;\n        ListNode* cur = dummyHead;\n        while(cur->next != nullptr && cur->next->next != nullptr) {\n            ListNode* tmp = cur->next; \n            ListNode* tmp1 = cur->next->next->next; \n\n            cur->next = cur->next->next;   \n            cur->next->next = tmp;          \n            cur->next->next->next = tmp1;   \n\n            cur = cur->next->next; \n        }\n        return dummyHead->next;\n    }\n};\n\n```\n\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195351966","body":"```class LRUCache {\npublic:\n    LRUCache(int capacity) : cap(capacity) {\n    }\n\n    int get(int key) {\n        if (map.find(key) == map.end()) return -1;\n        auto key_value = *map[key];\n        cache.erase(map[key]);\n        cache.push_front(key_value);\n        map[key] = cache.begin();\n        return key_value.second;\n    }\n\n    void put(int key, int value) {\n        if (map.find(key) == map.end()) {\n            if (cache.size() == cap) {\n                map.erase(cache.back().first);\n                cache.pop_back();\n            }\n        }\n        else {\n            cache.erase(map[key]);\n        }\n        cache.push_front({ key, value });\n        map[key] = cache.begin();\n    }\nprivate:\n    int cap;\n    list<pair<int, int>> cache;\n    unordered_map<int, list<pair<int, int>>::iterator> map;\n};\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201922072","body":"```\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        std::unordered_map <int,int> map;\n        for(int i = 0; i < nums.size(); i++) {\n            auto iter = map.find(target - nums[i]); \n            if(iter != map.end()) {\n                return {iter->second, i};\n            }\n            map.insert(pair<int, int>(nums[i], i)); \n        }\n        return {};\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205284594","body":"```\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        int ans = 0;\n        for (int i = 0; i < points.size(); i ++) {\n            unordered_map<int, int> m;\n            for (int j = 0; j < points.size(); j ++) {\n                if (i == j) continue;\n                int x = points[i][0] - points[j][0];\n                int y = points[i][1] - points[j][1];\n                int dis = pow(x, 2) + pow(y, 2);\n                m[dis] ++;\n            }\n            for(auto &[key, num]: m){\n                ans += num * (num - 1);\n            }\n        }\n        return ans;\n    }\n};\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208046532","body":"```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode p = head, q = head;\n        while (q != null && q.next != null) {\n            q = q.next.next;\n            p = p.next;\n        }\n        return p;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209287859","body":"```\n    public int removeDuplicates(int[] nums) {\n        int index=0;\n        for(int i=1;i<nums.length;i++){\n            if(nums[i-1]!=nums[i]){\n                nums[++index]=nums[i];\n            }\n        }\n        return index+1;\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gzgzgzgzgzgz":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187260764","body":"```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        res = \"\"\r\n        num = 0\r\n        stack = []\r\n        for c in s:\r\n            if c.isdigit():\r\n                num = num * 10 + int(c)\r\n            elif c == \"[\":\r\n                stack.append([res, num])\r\n                res = \"\"\r\n                num = 0\r\n            elif c == \"]\":\r\n                prev_res, prev_num = stack.pop()\r\n                res = prev_res + prev_num * res\r\n            else:\r\n                res += c\r\n        return res\r\n\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191387926","body":"```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return head\r\n        slow, fast = head, head\r\n        count = 0\r\n        temp = head\r\n        while temp:\r\n            count += 1\r\n            temp = temp.next\r\n        k = k % count\r\n        for i in range(k):\r\n            fast = fast.next\r\n        while fast.next:\r\n            slow = slow.next\r\n            fast = fast.next\r\n        fast.next = head\r\n        temp = slow.next\r\n        slow.next = None\r\n        return temp\r\n        \r\n        \r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193341668","body":"var getIntersectionNode = function(headA, headB) {\r\n    let a = headA\r\n    let b = headB\r\n    while(a != b) {\r\n        if (a == null) {\r\n            a = headB\r\n        } else {\r\n            a = a.next\r\n        }\r\n        if (b == null) {\r\n            b = headA\r\n        } else {\r\n            b = b.next\r\n        }\r\n    }\r\n    return a\r\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gentleman-goodman":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187331590","body":"## æ€è·¯\r\n\r\n                /*  æ€è·¯1ï¼šåˆ©ç”¨æ ˆçš„æ€§è´¨ï¼›å…ˆæŠŠæ‰€æœ‰å­—ç¬¦éƒ½å‹å…¥æ ˆä¸­ï¼Œé‡åˆ°\"]\"æ—¶è¯´æ˜æ‰¾åˆ°åŒ¹é…\r\n                è¯»åˆ°]æ—¶ï¼Œç”¨ä¸€ä¸ªwhileå¾ªç¯å°†[å’Œ]ä¹‹é—´çš„å­—ç¬¦ä¸²è¯»å‡ºï¼Œ\r\n                æˆ‘è¿™é‡Œç”¨äº†StringBuilderæ¥æé«˜å­—ç¬¦ä¸²æ‹¼æ¥æ€§èƒ½ï¼Œè¯»å‡ºåå°†[popåˆ å»ï¼Œ\r\n                ç„¶åå¼€å§‹è¯»æ•°å­—numäº†ï¼Œæ³¨æ„æ•°å­—å¯èƒ½æ˜¯å¾ˆå¤šä½æ•°å­—ï¼Œè¿™é‡Œå¤„ç†æ–¹æ³•å¾ˆå¤šï¼Œ\r\n                æˆ‘å°±ç›´æ¥ç”¨parseIntå°†å­—ç¬¦ä¸²è½¬åŒ–ä¸ºæ•°å­—äº†ï¼Œç„¶åæ˜¯å°†ä¸Šè¿°å­—ç¬¦ä¸²å¤åˆ¶numå€ï¼Œ\r\n                è¿™æ ·å¤„ç†åå†å°†å­—ç¬¦ä¸²æ”¾å›æ ˆä¸­å³å¯ï¼Œè‡³äºå…¶ä»–æƒ…å†µï¼Œç›´æ¥å°†å…¶è½¬åŒ–ä¸ºå­—ç¬¦ä¸²å‹å…¥æ ˆä¸­å³å¯ï¼Œ\r\n                æœ€åå‡ºæ ˆçš„æ—¶å€™è¦æ³¨æ„ï¼Œå­—ç¬¦ä¸²çš„æ€»ä½“é¡ºåºæ˜¯åçš„ï¼Œæ•…è¦ç”¨insertæ‹¼æ¥è€Œä¸æ˜¯append\r\n    \r\n                æ€è·¯1.1ï¼šå°±æ˜¯åˆ©ç”¨æ ˆçš„ç‰¹æ€§ï¼Œå…ˆæŠŠæ‰€æœ‰å­—ç¬¦éƒ½å‹å…¥æ ˆä¸­ï¼Œé‡åˆ°\"]\"æ—¶è¯´æ˜æ‰¾åˆ°åŒ¹é…ã€‚\r\n                è¿™ä¸ªæ—¶å€™å…ˆå°†[]å†…çš„stringå­˜åˆ°ä¸€ä¸ªåœ°æ–¹ã€‚\r\n                åœ¨è¯»å®Œstringåï¼Œå¼€å§‹è¯»æ•°å­—kï¼Œæ•°å­—æœ‰å¯èƒ½ä¸æ˜¯1ä½ï¼Œæ‰€ä»¥è¦ç”¨ä¸€ä¸ªbaseå’Œå¾ªç¯æ¥è¯»æ•°å­—ã€‚\r\n                æœ€åå°† k * stringå‹å›æ ˆä¸­ã€‚ç»§ç»­åŒ¹é…ã€‚æœ€ç»ˆæ ˆå†…çš„å­—ç¬¦ä¸²å› ä¸ºæ˜¯åç€çš„ï¼ˆå‡ºæ ˆçš„æ—¶å€™é¡ºåºç›¸åï¼‰ï¼Œ\r\n                æ‰€ä»¥resultè®°å¾—åç€å°†æ ˆä¸­æ‰€æœ‰å­—æ¯å¼¹å‡ºæ¥ã€‚\r\n\r\n*/\r\n\r\n## ä»£ç \r\n\r\n```java\r\nclass Solution {\r\n        public String decodeString(String s) {\r\n            int len=s.length();\r\n            if(len<=0) return \"\";\r\n            Stack<String> stack=new Stack<>();\r\n            for(int i=0; i<len; i++){\r\n                char mid=s.charAt(i);\r\n\r\n\r\n                //è¯»åˆ°]æ—¶ï¼Œç”¨ä¸€ä¸ªwhileå¾ªç¯å°†[å’Œ]ä¹‹é—´çš„å­—ç¬¦ä¸²è¯»å‡ºï¼Œ\r\n                if(mid==']'){\r\n                    StringBuilder fir=new StringBuilder();\r\n                    while(!stack.peek().equals(\"[\")){\r\n                        //firé‡Œé¢å­˜å–çš„å°±æ˜¯[]ä¹‹é—´çš„å†…å®¹\r\n                        fir.insert(0,stack.pop());\r\n                    }\r\n                    //è¯»å‡ºåå°†[popåˆ å»ï¼Œ\r\n                    stack.pop();\r\n\r\n                    StringBuilder num=new StringBuilder();\r\n\r\n                    /*ç„¶åå¼€å§‹è¯»æ•°å­—numäº†ï¼Œæ³¨æ„æ•°å­—å¯èƒ½æ˜¯å¾ˆå¤šä½æ•°å­—ï¼Œè¿™é‡Œå¤„ç†æ–¹æ³•å¾ˆå¤šï¼Œ\r\n                    æˆ‘å°±ç›´æ¥ç”¨parseIntå°†å­—ç¬¦ä¸²è½¬åŒ–ä¸ºæ•°å­—äº†*/\r\n                    while(!stack.isEmpty()&&(stack.peek().charAt(0)>='0'&&stack.peek().charAt(0)<='9')){\r\n                        num.insert(0,stack.pop());\r\n                    }\r\n                    int number=Integer.parseInt(num.toString());\r\n\r\n                    //ï¼Œç„¶åæ˜¯å°†ä¸Šè¿°å­—ç¬¦ä¸²å¤åˆ¶numå€ï¼Œè¿™æ ·å¤„ç†åå†å°†å­—ç¬¦ä¸²æ”¾å›æ ˆä¸­å³å¯\r\n                    StringBuilder sec=new StringBuilder();\r\n                    for(int j=0; j<number; j++){\r\n                        sec.append(fir);\r\n                    }\r\n                    stack.push(sec.toString());\r\n                }\r\n                //è‡³äºå…¶ä»–æƒ…å†µï¼Œç›´æ¥å°†å…¶è½¬åŒ–ä¸ºå­—ç¬¦ä¸²å‹å…¥æ ˆä¸­å³å¯\r\n                else{\r\n                    StringBuilder sb=new StringBuilder();\r\n                    sb.insert(0,mid);\r\n                    stack.push(sb.toString());\r\n                }\r\n            }\r\n\r\n            //æœ€åå‡ºæ ˆçš„æ—¶å€™è¦æ³¨æ„ï¼Œå­—ç¬¦ä¸²çš„æ€»ä½“é¡ºåºæ˜¯åçš„ï¼Œæ•…è¦ç”¨insertæ‹¼æ¥è€Œä¸æ˜¯append\r\n            StringBuilder res=new StringBuilder();\r\n            while(!stack.isEmpty()){\r\n                res.insert(0,stack.pop());\r\n            }\r\n            return res.toString();\r\n        }\r\n    }\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼š O(N)\r\n- ç©ºé—´å¤æ‚åº¦ï¼š O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188500355","body":"## æ€è·¯ï¼š\r\n\r\n### \t\tä¸¤ä¸ªæ ˆï¼Œ ä¸€ä¸ªè¾“å‡ºã€è¾“å…¥æ ˆ\r\n\r\n## ä»£ç \r\n\r\n```java\r\nclass MyQueue {\r\n\r\n    private Stack<Integer> inputStack;\r\n    private Stack<Integer> outputStack;\r\n    public MyQueue() {\r\n        inputStack = new Stack<>();\r\n        outputStack = new Stack<>();\r\n\r\n    }\r\n    \r\n    public void push(int x) {\r\n        //å°†å…ƒç´  x æ¨åˆ°é˜Ÿåˆ—çš„æœ«å°¾\r\n        inputStack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        //å°†è¾“å…¥æ ˆçš„æ•°æ®æ”¾å…¥è¾“å‡ºæ ˆä¸­\r\n        //ç„¶åæŠŠè¾“å‡ºæ ˆé‡Œé¢çš„æ•°æ®ï¼Œæ”¾å‡ºï¼ˆç§»é™¤ï¼‰ä¸€ä¸ªæ¥\r\n\r\n        if(outputStack.isEmpty()){\r\n            while(!inputStack.isEmpty()){\r\n\r\n                outputStack.push(inputStack.pop());\r\n\r\n            }\r\n\r\n        }\r\n        return   outputStack.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        //åŒä¸Š,ä½†æœ€åå°±ä¸æ˜¯ç§»é™¤ï¼Œå°±æ˜¯æ˜¾ç¤ºï¼ˆè¿”å›é˜Ÿåˆ—å¼€å¤´çš„å…ƒç´ ï¼‰\r\n\r\n        if(outputStack.isEmpty()){\r\n            while(!inputStack.isEmpty()){\r\n\r\n                outputStack.push(inputStack.pop());\r\n\r\n            }\r\n\r\n        }\r\n        // è¿”å›é˜Ÿåˆ—å¼€å¤´çš„å…ƒç´ \r\n        return outputStack.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        //åˆ¤æ–­ä¸¤ä¸ªæ ˆæ˜¯ä¸æ˜¯éƒ½æ˜¯ç©ºçš„\r\n        return inputStack.isEmpty()&&outputStack.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```\r\n\r\n## å¤æ‚åº¦\r\n\r\n- Time O(1)\r\n- Space O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xinyi-arch":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187533435","body":"æ€è·¯ï¼šæ‰¾åˆ°'['å’Œ']'æ¥é”å®šéœ€è¦å¾ªç¯çš„é¡¹ï¼Œä»åå¾€å‰éå†\r\nCode:\r\nclassÂ Solution(object):\r\nÂ Â Â Â defÂ decodeString(self,Â s):\r\nÂ Â Â Â Â Â Â Â \"\"\"\r\nÂ Â Â Â Â Â Â Â :typeÂ s:Â str\r\nÂ Â Â Â Â Â Â Â :rtype:Â str\r\nÂ Â Â Â Â Â Â Â \"\"\"\r\nÂ Â Â Â Â Â Â Â stack=list()\r\nÂ Â Â Â Â Â Â Â length=len(s)\r\nÂ Â Â Â Â Â Â Â i=length-1\r\nÂ Â Â Â Â Â Â Â whileÂ i>=0:\r\nÂ Â Â Â Â Â Â Â Â Â Â Â ifÂ s[i].isdigit()==False:\r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â stack.append(s[i])\r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â i-=1\r\nÂ Â Â Â Â Â Â Â Â Â Â Â else:\r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â num=''\r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â whileÂ i>=0Â andÂ s[i].isdigit():\r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â num=s[i]+num\r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â i-=1\r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â sub=''\r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â whileÂ stack[-1]!=']':\r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â tmp=stack.pop()\r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ tmp!='[':\r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â sub+=tmp\r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â stack.pop()\r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â sub=int(num)*sub\r\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â stack.append(sub)\r\n\r\nÂ Â Â Â Â Â Â Â stack.reverse()\r\nÂ Â Â Â Â Â Â Â returnÂ ''.join(stack)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190116027","body":"æ€è·¯ï¼š\r\nå¸Œæœ›æ’åºåçš„æ•°å­—ï¼Œè¿˜åœ¨åŸå§‹çš„ä½ç½®.æ‰€ä»¥å…ˆå¯¹æ•°ç»„æ’åºï¼Œå½“æ¯å¾€åå¾ªç¯çš„ä¸€ä¸ªæ•°ç»„çš„åŸå§‹æœ€å¤§åæ ‡ç­‰äºå½“å‰ä½ç½®æ—¶ï¼Œå°±å¯ä»¥åˆ‡åˆ†ã€‚\r\nCode:\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        \"\"\"\r\n        :type arr: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n        arr_list=list(enumerate(arr))\r\n        arr_list.sort(key=lambda x:x[1])\r\n        temp=[]\r\n        num=0\r\n        for i in range(len(arr_list)):\r\n            temp.append(arr_list[i][0])\r\n            if max(temp)==i:\r\n                num=num+1\r\n                temp=[]\r\n        return num","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191080280","body":"æ€è·¯ï¼šè‹¥K>æ€»é•¿åº¦N,åªè¦ç§»åŠ¨K//Nå³å¯ã€‚ç”¨head.nextå®Œæˆå…¶ä½™æ“ä½œ\r\nCode:\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        tail = head\r\n        count = 1\r\n        if not head or not head.next:\r\n            return head\r\n        while tail.next:\r\n            tail = tail.next\r\n            count += 1\r\n        if k % count == 0:\r\n            return head \r\n        tail.next = head\r\n        k %= count\r\n        for i in range(count - k):\r\n            tail = tail.next\r\n        temp = tail.next\r\n        tail.next = None\r\n        return temp","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193745915","body":"æ€è·¯ï¼šå¿«æ…¢æŒ‡é’ˆ\r\nCode:\r\nclass Solution(object):\r\n    def detectCycle(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        slow, fast = head, head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            # å¦‚æœç›¸é‡\r\n            if slow == fast:\r\n                p = head\r\n                q = slow\r\n                while p!=q:\r\n                    p = p.next\r\n                    q = q.next\r\n                return p","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195315685","body":"æ€è·¯ï¼šå“ˆå¸Œè¡¨å’ŒåŒå‘åˆ—è¡¨\r\nCode:\r\nclass DLinkedNode:\r\n    def __init__(self, key=0, value=0):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = None\r\n        self.next = None\r\n\r\n\r\nclass LRUCache(object):\r\n\r\n    def __init__(self, capacity):\r\n        \"\"\"\r\n        :type capacity: int\r\n        \"\"\"\r\n        self.cache = dict()\r\n        # ä½¿ç”¨ä¼ªå¤´éƒ¨å’Œä¼ªå°¾éƒ¨èŠ‚ç‚¹    \r\n        self.head = DLinkedNode()\r\n        self.tail = DLinkedNode()\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n        self.capacity = capacity\r\n        self.size = 0\r\n\r\n\r\n    def get(self, key):\r\n        \"\"\"\r\n        :type key: int\r\n        :rtype: int\r\n        \"\"\"\r\n        if key not in self.cache:\r\n            return -1\r\n        # å¦‚æœ key å­˜åœ¨ï¼Œå…ˆé€šè¿‡å“ˆå¸Œè¡¨å®šä½ï¼Œå†ç§»åˆ°å¤´éƒ¨\r\n        node = self.cache[key]\r\n        self.moveToHead(node)\r\n        return node.value\r\n\r\n\r\n    def put(self, key, value):\r\n        \"\"\"\r\n        :type key: int\r\n        :type value: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if key not in self.cache:\r\n            # å¦‚æœ key ä¸å­˜åœ¨ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„èŠ‚ç‚¹\r\n            node = DLinkedNode(key, value)\r\n            # æ·»åŠ è¿›å“ˆå¸Œè¡¨\r\n            self.cache[key] = node\r\n            # æ·»åŠ è‡³åŒå‘é“¾è¡¨çš„å¤´éƒ¨\r\n            self.addToHead(node)\r\n            self.size += 1\r\n            if self.size > self.capacity:\r\n                # å¦‚æœè¶…å‡ºå®¹é‡ï¼Œåˆ é™¤åŒå‘é“¾è¡¨çš„å°¾éƒ¨èŠ‚ç‚¹\r\n                removed = self.removeTail()\r\n                # åˆ é™¤å“ˆå¸Œè¡¨ä¸­å¯¹åº”çš„é¡¹\r\n                self.cache.pop(removed.key)\r\n                self.size -= 1\r\n        else:\r\n            # å¦‚æœ key å­˜åœ¨ï¼Œå…ˆé€šè¿‡å“ˆå¸Œè¡¨å®šä½ï¼Œå†ä¿®æ”¹ valueï¼Œå¹¶ç§»åˆ°å¤´éƒ¨\r\n            node = self.cache[key]\r\n            node.value = value\r\n            self.moveToHead(node)\r\n    \r\n    def addToHead(self, node):\r\n        node.prev = self.head\r\n        node.next = self.head.next\r\n        self.head.next.prev = node\r\n        self.head.next = node\r\n    \r\n    def removeNode(self, node):\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n\r\n    def moveToHead(self, node):\r\n        self.removeNode(node)\r\n        self.addToHead(node)\r\n\r\n    def removeTail(self):\r\n        node = self.tail.prev\r\n        self.removeNode(node)\r\n        return node\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196540299","body":"### æ€è·¯\r\næ·±åº¦ä¼˜å…ˆæœç´¢\r\n###  code\r\n```python\r\nclass Solution(object):\r\n    def maxDepth(self, root):\r\n        \"\"\"\r\n        :type root: TreeNode\r\n        :rtype: int\r\n        \"\"\"\r\n        if root is None: \r\n            return 0 \r\n        else: \r\n            left_height = self.maxDepth(root.left) \r\n            right_height = self.maxDepth(root.right) \r\n            return max(left_height, right_height) + 1 \r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197923017","body":"### æ€è·¯\r\né€’å½’\r\n### Code\r\n```python\r\nclass Solution(object):\r\n    def isSameTree(self, p, q):\r\n        \"\"\"\r\n        :type p: TreeNode\r\n        :type q: TreeNode\r\n        :rtype: bool\r\n        \"\"\"\r\n        ###é€’å½’è¾“å‡ºæ¡ä»¶ï¼Œæœ‰ä¸€ä¸ªç©ºå¦å¤–ä¸€ä¸ªéç©ºåˆ™False\r\n        if p is None and q is not None: \r\n            return False\r\n        ###é€’å½’è¾“å‡ºæ¡ä»¶ï¼Œæœ‰ä¸€ä¸ªç©ºå¦å¤–ä¸€ä¸ªéç©ºåˆ™False\r\n        if p is not None and q is None: \r\n            return False\r\n        ###é€’å½’è¾“å‡ºæ¡ä»¶ï¼Œå‡ä¸ºç©ºåˆ™True\r\n        if p is None and q is None:\r\n            return True\r\n        #åˆ¤æ–­æ¡ä»¶ï¼Œå€¼æ˜¯å¦ç›¸ç­‰\r\n        if p.val != q.val:\r\n            return False\r\n        #é€’å½’ä¸ºå·¦æ ‘ä¸å³æ ‘æ˜¯å¦ç›¸ç­‰\r\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201003014","body":"### æ€è·¯\r\nBFSï¼Œä½¿ç”¨åŒå‘é˜Ÿåˆ—å‚¨å­˜ï¼Œä¾æ¬¡éå†ï¼Œæ ¹æ®æ¨ªåæ ‡å‚¨å­˜è‡³å­—å…¸\r\n\r\n### code\r\n```python\r\nclass Solution(object):\r\n    def verticalTraversal(self, root):\r\n        \"\"\"\r\n        :type root: TreeNode\r\n        :rtype: List[List[int]] \"\"\"\r\n    \r\n        if root is None: return []\r\n        queue, d = deque([[root, 0, 0]]), {}\r\n        while queue:\r\n            for _ in range(len(queue)):\r\n                node, x, y = queue.popleft()\r\n                node.left and queue.append([node.left, x - 1, y + 1])\r\n                node.right and queue.append([node.right, x + 1, y + 1])\r\n                d.setdefault(x, []).append((y, node.val))\r\n        return [list(map(itemgetter(1), sorted(d[k]))) for k in sorted(d)]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202057088","body":"### æ€è·¯\r\nå“ˆå¸Œè¡¨ï¼Œtargetå‡å»å½“å‰æ•°å€¼æ˜¯å¦åœ¨å“ˆå¸Œè¡¨ä¸­\r\n### Code\r\n``` python\r\nclass Solution(object):\r\n    def twoSum(self, nums, target):\r\n        \"\"\"\r\n        :type nums: List[int]\r\n        :type target: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        hashtable = dict()\r\n        for i, num in enumerate(nums):\r\n            if target - num in hashtable:\r\n                return [hashtable[target - num], i]\r\n            hashtable[nums[i]] = i\r\n        return []\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203797090","body":"### æ€è·¯\r\nä½¿ç”¨counterè®¡æ•°å‡½æ•°\r\n### Code\r\n```python\r\nclass Solution(object):\r\n    def topKFrequent(self, nums, k):\r\n        \"\"\"\r\n        :type nums: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        return [x[0] for x in Counter(nums).most_common()[:k]]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205014134","body":"### æ€è·¯\r\næšä¸¾\r\n### Code\r\n``` python\r\nclass Solution(object):\r\n    def numberOfBoomerangs(self, points):\r\n        \"\"\"\r\n        :type points: List[List[int]]\r\n        :rtype: int\r\n        \"\"\"\r\n        ans = 0\r\n        for p in points:\r\n            cnt = defaultdict(int)\r\n            for q in points:\r\n                dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1])\r\n                cnt[dis] += 1\r\n            for m in cnt.values():\r\n                ans += m * (m - 1)\r\n        return ans\r\n```\r\n### å¤æ‚åº¦åˆ†æ\r\næ—¶é—´ O(n^2)\r\nç©ºé—´ O(n)\r\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209011549","body":"### æ€è·¯\r\nåŒæŒ‡é’ˆ\r\n### Code\r\n```python\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        j=0\r\n        for i in nums:\r\n            if nums[j]!=i:\r\n                j=j+1\r\n                nums[j]=i\r\n        return j+1\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zenwangzy":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187582912","body":"# dfs\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n        int u = 0;\n        return dfs(s, u);\n    }\n\n    string dfs(string& s, int& u) {\n        string res;\n        while (u < s.size() && s[u] != ']') {\n            if (s[u] >= 'a' && s[u] <= 'z') res += s[u ++];\n            else if (s[u] >= '0' && s[u] <= '9') {\n                int k = u;\n                while (s[k] >= '0' && s[k] <= '9') k ++;\n                int t = stoi(s.substr(u, k - u));\n                u = k + 1;\n                string sa = dfs(s, u);\n                u ++;\n                while (t --) res += sa;\n            }\n        }\n        return res;\n    }\n};// O(n) O(n)\n```\n# stack\n\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n      if (s.empty()) {\n        return s;\n      }\n      \n      std::string k;    // num\n      std::string str;  // result\n      std::stack<int> countStack;\n      std::stack<std::string> stringStack;\n      \n      for (auto& ch: s) {\n        if (isdigit(ch)) {\n          k += ch;\n        } else if (ch == '[') {\n          countStack.push(std::stoi(k));\n          stringStack.push(str);\n          k = \"\";\n          str = \"\";\n        } else if (isalpha(ch)) {\n          str += ch;\n\n        } else if (ch == ']') {\n          // get previously decoded, such as in 3[a]2[bc]\n          // second '[' push 'aaa' to stack, get them now\n          std::string decodedString = stringStack.top();\n          stringStack.pop();\n          \n          // str is not pushed to stack yet, but times is already pushed \n          // add the decoded sting and repeated str\n          for (int i = 0; i < countStack.top(); i++) {\n            decodedString += str;\n          }\n          countStack.pop();\n          \n          // remember the local variable\n          str = decodedString;\n        }\n      }\n      \n      return str;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189145882","body":"# idea\nä½¿ç”¨ä¸¤ä¸ªæ¨ªå‘æ‘†æ”¾ç›¸å¯¹å¼€å£çš„æ ˆæ¨¡æ‹Ÿé˜Ÿåˆ—ï¼Œå³è¾¹æ ˆå‚¨å­˜å…ƒç´ ï¼Œå·¦è¾¹æ ˆå¼¹å‡ºå…ƒç´ ã€‚ \nå¦‚æœéœ€è¦è®¿é—®é˜Ÿå¤´å…ƒç´ ï¼Œ å°±æŠŠæ‰€æœ‰instack å…ƒç´ ä¸€æŠŠæ’¸è¿‡æ¥åˆ°outstack pop ä¹Ÿæ˜¯åŒç† å…¶å®ƒç®€å•\næ³¨æ„popæ—¶å€™ä¸´æ—¶å‚¨å­˜topä»¥åå†return\n```cpp\nclass MyQueue {\nprivate:\n    stack<int> inStack,outStack;\n\n    void in2out() {\n    while (!inStack.empty()) {\n        outStack.push(inStack.top());\n        inStack.pop();\n    }\n}    \npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        inStack.push(x);\n\n    }\n    \n    int pop() {\n        if (outStack.empty()) {\n            in2out();\n        }\n        int x = outStack.top();//æ³¨æ„æ­¤å¤„ä¸èƒ½ç›´æ¥è¿”å› ä½ éœ€è¦ä¸€ä¸ªå±€éƒ¨å˜é‡æš‚å­˜ \n        outStack.pop();\n        return x;\n\n    }\n    \n    int peek() {\n        if (outStack.empty()) {\n            in2out();\n        }\n        return outStack.top();\n        \n\n    }\n    \n    bool empty() {\n        return inStack.empty() && outStack.empty();\n\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193317706","body":"```cpp\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* p = headA, * q = headB;\n        while (p != q) {\n            p = p ? p->next : headB;\n            q = q ? q->next : headA;\n        }\n        return p;\n    }\n};","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200155584","body":"# æ€è·¯\næœ€åä¸€å±‚bfsçš„ç¬¬ä¸€ä¸ªå€¼\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        queue<TreeNode *> que;\n        que.push(root);\n        TreeNode *node;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int i = 0; i < size; ++i) {\n                node = que.front();\n                que.pop();\n                if (node->right) {\n                    que.push(node->right);\n                }\n                if (node->left) {\n                    que.push(node->left);\n                } \n            }\n        }\n        return node->val;\n    }\n};\n```\n# å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦ï¼šO(n) æ¯ä¸ªèŠ‚ç‚¹éå†ä¸€é\nç©ºé—´å¤æ‚åº¦ï¼šO(w) é˜Ÿåˆ—æœ€å¤§æ˜¯æ ‘çš„å®½åº¦","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"andyyxw":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1193338176","body":"```ts\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n  let ret = []\r\n  let i = num.length - 1\r\n  while (i >= 0 || k > 0) {\r\n    if (i >= 0) k += num[i--]\r\n    ret.push(k % 10)\r\n    k = Math.floor(k / 10)\r\n  }\r\n  return ret.reverse()\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1200147807","body":"```ts\r\n/**\r\n * Algorithm: Traverse\r\n * Time Complexity: O(n)\r\n * Space Complexity: O(n)\r\n */\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n  const len = s.length\r\n  const ret = Array(len).fill(len - 1)\r\n  for (let i = 0; i < len; i++) {\r\n    if (s[i] === c) ret[i] = 0\r\n    else if (i === 0) continue\r\n    else ret[i] = ret[i - 1] + 1\r\n  }\r\n  for (let j = len - 1; j >= 0; j--) {\r\n    if (j === len - 1) continue\r\n    ret[j] = Math.min(ret[j], ret[j + 1] + 1)\r\n  }\r\n  return ret\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1200353490","body":"```ts\r\nclass CustomStack {\r\n  maxSize: number\r\n  stack: number[]\r\n\r\n  constructor(maxSize: number) {\r\n    this.maxSize = maxSize\r\n    this.stack = []\r\n  }\r\n\r\n  push(x: number): void {\r\n    if (this.stack.length >= this.maxSize) return\r\n    this.stack.push(x)\r\n  }\r\n\r\n  pop(): number {\r\n    if (this.stack.length === 0) return -1\r\n    return this.stack.pop()\r\n  }\r\n\r\n  increment(k: number, val: number): void {\r\n    for (let i = 0; i < k && i < this.stack.length; i++) this.stack[i] += val\r\n  }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187629977","body":"Code:\r\n```ts\r\nfunction decodeString(s: string): string {\r\n  const stack = []\r\n  let ret = ''\r\n  let count = 0\r\n  for (const c of s) {\r\n    if (c >= '0' && c <= '9') {\r\n      count = count * 10 + +c\r\n      continue\r\n    } else if (c === '[') {\r\n      stack.push({ count, lastRet: ret })\r\n      count = 0\r\n      ret = ''\r\n      continue\r\n    } else if (c === ']') {\r\n      const { count, lastRet } = stack.pop()\r\n      ret = lastRet + ret.repeat(count)\r\n      continue\r\n    }\r\n    ret += c\r\n  }\r\n  return ret\r\n};\r\n```\r\nComplexity:\r\n- Time complexity: O(n)\r\n- Space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189170203","body":"Code:\r\n```ts\r\nclass MyQueue {\r\n  pushStack: number[]\r\n  popStack: number[]\r\n\r\n  constructor() {\r\n    this.pushStack = []\r\n    this.popStack = []\r\n  }\r\n\r\n  transfer(): void {\r\n    if (this.popStack.length) return\r\n    while (this.pushStack.length) this.popStack.push(this.pushStack.pop())\r\n  }\r\n\r\n  push(x: number): void {\r\n    this.pushStack.push(x)\r\n  }\r\n\r\n  pop(): number {\r\n    this.transfer()\r\n    return this.popStack.pop()\r\n  }\r\n\r\n  peek(): number {\r\n    this.transfer()\r\n    return _.last(this.popStack)\r\n  }\r\n\r\n  empty(): boolean {\r\n    return !(this.pushStack.length || this.popStack.length)\r\n  }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```\r\nTime Complexity: O(n)\r\nSpace Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190461387","body":"Code:\r\n```ts\r\n/** Algorithm: Sliding Window */\r\nfunction maxChunksToSorted(arr: number[]): number {\r\n  const sortedArr = [...arr].sort((a, b) => a - b)\r\n  let ret = 0\r\n  let sum1 = 0\r\n  let sum2 = 0\r\n\r\n  for (let i = 0; i < arr.length; i++) {\r\n    sum1 += arr[i]\r\n    sum2 += sortedArr[i]\r\n    if (sum1 === sum2) ret++\r\n  }\r\n\r\n  return ret\r\n}\r\n```\r\nTime Complexity: O(NlogN)\r\nTime Complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190567251","body":"```ts\r\n/**\r\n * Algorithm: Fast and Slow Pointer\r\n * Time Complexity: O(N)\r\n * Space Complexity: O(1)\r\n */\r\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\r\n  if (!head || k === 0) return head\r\n  // get effective rotate times\r\n  let cur = head, length = 1\r\n  while (cur.next && ++length) cur = cur.next\r\n  k %= length\r\n  if (k === 0) return head\r\n\r\n  let slow = head, fast = head\r\n  while (k-- > 0) fast = fast.next\r\n  while (fast.next) { slow = slow.next; fast = fast.next }\r\n  const ret = slow.next\r\n  slow.next = null\r\n  fast.next = head\r\n  return ret\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1191774265","body":"```ts\r\n/**\r\n * Algorithm: Iterative\r\n * Time Complexity: O(n)\r\n * Space Complexity: O(1)\r\n */\r\nfunction swapPairs(head: ListNode | null): ListNode | null {\r\n  if (!head || !head.next) return head\r\n\r\n  let dummyHead = new ListNode(-1, head)\r\n  let p = dummyHead\r\n  while (head && head.next) {\r\n    let next = head.next\r\n    head.next = next.next\r\n    next.next = head\r\n    p.next = next\r\n    p = head\r\n    head = head.next\r\n  }\r\n  return dummyHead.next \r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193146877","body":"```ts\r\n/**\r\n * Algorithm: Recursive\r\n * Time Complexity: O(n)\r\n * Space Complexity: O(n)\r\n */\r\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\r\n  const arr = []\r\n  while (head) {\r\n    arr.push(head.val)\r\n    head = head.next\r\n  }\r\n\r\n  function buildBST(start: number, end: number) {\r\n    if (start > end) return null\r\n    const mid = (start + end) >>> 1\r\n    const root = new TreeNode(arr[mid])\r\n    root.left = buildBST(start, mid - 1)\r\n    root.right = buildBST(mid + 1, end)\r\n    return root\r\n  };\r\n\r\n  return buildBST(0, arr.length - 1)\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193343835","body":"```ts\r\n/**\r\n * Algorithm: Double Pointer\r\n * Time Complexity: O(m + n)\r\n * Space Complexity: O(1)\r\n */\r\nfunction getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {\r\n  if (!headA || !headB) return null\r\n  let p1 = headA, p2 = headB\r\n  while (p1 !== p2) {\r\n    p1 = p1 ? p1.next : headB\r\n    p2 = p2 ? p2.next : headA\r\n  }\r\n  return p1\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193369095","body":"```ts\r\n/**\r\n * Algorithm: Fast and Slow Pointer\r\n * Time Complexity: O(n)\r\n * Space Complexity: O(1)\r\n */\r\nfunction detectCycle(head: ListNode | null): ListNode | null {\r\n  if (!head) return null\r\n  let slow = head, fast = head, start = head\r\n  while (fast && fast.next) {\r\n    slow = slow.next\r\n    fast = fast.next.next\r\n    if (slow === fast) {\r\n      while (true) {\r\n        if (slow === start) return slow\r\n        slow = slow.next\r\n        start = start.next\r\n      }\r\n    }\r\n  }\r\n  return null\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194314825","body":"```ts\r\n/**\r\n * Algorithm: HashTable\r\n * Time Complexity: O(n)\r\n * Space Complexity: O(1)\r\n */\r\nclass LRUCache {\r\n  capacity: number\r\n  cache: Map<number, number>\r\n\r\n  constructor(capacity: number) {\r\n    this.capacity = capacity\r\n    this.cache = new Map()\r\n  }\r\n\r\n  get(key: number): number {\r\n    if (!this.cache.has(key)) return -1\r\n    const value = this.cache.get(key)\r\n    this.cache.delete(key)\r\n    this.cache.set(key, value)\r\n    return value\r\n  }\r\n\r\n  put(key: number, value: number): void {\r\n    if (this.cache.has(key)) this.cache.delete(key)\r\n    while (this.cache.size >= this.capacity) this.cache.delete(this.cache.keys().next().value)\r\n    this.cache.set(key, value)\r\n  }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196514507","body":"```ts\r\nfunction maxDepth(root: TreeNode | null): number {\r\n  if (!root) return 0\r\n  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197579306","body":"```ts\r\n/** Algorithm: Recursion */\r\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\r\n  if (p === null && q === null) return true\r\n  if (p === null || q === null) return false\r\n  if (p.val !== q.val) return false\r\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199504672","body":"```ts\r\n/**\r\n * Algorithm: DFS\r\n * Time Complexity: O(n)\r\n * Space Complexity: O(n)\r\n */\r\nfunction sumNumbers(root: TreeNode | null): number {\r\n  return dfs(root, 0)\r\n};\r\n\r\nfunction dfs(root: TreeNode | null, preSum: number): number {\r\n  if (!root) return 0\r\n  const sum = preSum * 10 + root.val\r\n  if (!root.left && !root.right) return sum\r\n  return dfs(root.left, sum) + dfs(root.right, sum)\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200092412","body":"```ts\r\n/**\r\n * Algorithm: BFS\r\n * Time Complexity: O(n)\r\n * Space Complexity: O(n)\r\n */\r\nfunction findBottomLeftValue(root: TreeNode | null): number {\r\n  if (!root) return 0\r\n  let ret = 0\r\n  let queue = [root]\r\n  while (queue.length) {\r\n    const node = queue.shift()\r\n    ret = node.val\r\n    node.right && queue.push(node.right)\r\n    node.left && queue.push(node.left)\r\n  }\r\n  return ret\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200352283","body":"```ts\r\n/*\r\n * Encodes a tree to a single string.\r\n * Algorithm: BFS\r\n * Time Complexity: O(n)\r\n * Space Complexity: O(n)\r\n */\r\nfunction serialize(root: TreeNode | null): string {\r\n  if (!root) return ''\r\n  const ret = []\r\n  const queue = [root]\r\n\r\n  while (queue.length) {\r\n    const node = queue.shift()\r\n    if (node) {\r\n      ret.push(node.val)\r\n      queue.push(node.left)\r\n      queue.push(node.right)\r\n    } else {\r\n      ret.push('#')\r\n    }\r\n  }\r\n  return ret.join(',')\r\n}\r\n\r\n/*\r\n * Decodes your encoded data to tree.\r\n * Algorithm: BFS\r\n * Time Complexity: O(n)\r\n * Space Complexity: O(n)\r\n */\r\nfunction deserialize(data: string): TreeNode | null {\r\n  if (!data) return null\r\n  const list = data.split(',')\r\n  const root = new TreeNode(+list.shift())\r\n  const queue = [root]\r\n  \r\n  while (queue.length) {\r\n    const node = queue.shift()\r\n    // ç¬¬ä¸€ä¸ªæ˜¯å·¦èŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹ä¸ºç©ºï¼Œç›´æ¥è·³è¿‡\r\n    const leftVal = list.shift()\r\n    if (leftVal !== \"#\") {\r\n      node.left = new TreeNode(+leftVal)\r\n      queue.push(node.left)\r\n    }\r\n    // ç¬¬äºŒä¸ªæ˜¯å³èŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹ä¸ºç©ºï¼Œç›´æ¥è·³è¿‡\r\n    const rightVal = list.shift()\r\n    if (rightVal !== \"#\") {\r\n      node.right = new TreeNode(+rightVal)\r\n      queue.push(node.right)\r\n    }\r\n  }\r\n  return root\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200461995","body":"```ts\r\n/*\r\n * Algorithm: BFS\r\n * Time Complexity: O(nlogn)\r\n * Space Complexity: O(n)\r\n */\r\nfunction verticalTraversal(root: TreeNode | null): number[][] {\r\n  if (!root) return []\r\n\r\n  const queue: [[number, TreeNode]] = [[0, root]]\r\n  const map = new Map([[0, [root.val]]])\r\n  while (queue.length) {\r\n    let len = queue.length\r\n    const tempMap = new Map<number, number[]>()\r\n    while (len--) {\r\n      const [x, root] = queue.shift()\r\n      if (root.left) {\r\n        queue.push([x - 1, root.left]);\r\n        tempMap.set(x - 1, (tempMap.get(x - 1) || []).concat(root.left.val))\r\n      }\r\n      if (root.right) {\r\n        queue.push([x + 1, root.right]);\r\n        tempMap.set(x + 1, (tempMap.get(x + 1) || []).concat(root.right.val))\r\n      }\r\n    }\r\n    tempMap.forEach((value, key) => {\r\n      value.sort((a, b) => a - b)\r\n      map.set(key, (map.get(key) || []).concat(value))\r\n    })\r\n  }\r\n  return [...map.keys()].sort((a, b) => a - b).map(v => map.get(v))\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201422693","body":"```ts\r\n/*\r\n * Algorithm: HashMap\r\n * Time Complexity: O(n)\r\n * Space Complexity: O(n)\r\n */\r\nfunction twoSum(nums: number[], target: number): number[] {\r\n  const targets = new Map<number, number>()\r\n  for (const [i, v] of nums.entries()) {\r\n    if (targets.has(v)) return [targets.get(v), i]\r\n    targets.set(target - v, i)\r\n  }\r\n  return []\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1204130426","body":"```ts\r\nfunction topKFrequent(nums: number[], k: number): number[] {\r\n  if (!nums.length) return []\r\n  const map = new Map<number, number>()\r\n  nums.forEach((v) => map.set(v, (map.get(v) || 0) + 1))\r\n\r\n  const priorityQueue = new PriorityQueue((a, b) => a[1] - b[1])\r\n  for (const entry of map.entries()) {\r\n    priorityQueue.enqueue(entry)\r\n    if (priorityQueue.size() > k) priorityQueue.dequeue()\r\n  }\r\n\r\n  const ret = []\r\n  for (let i = 0; i < priorityQueue.size(); i++) {\r\n    ret[i] = priorityQueue.dequeue()[0]\r\n  }\r\n  return ret\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204312270","body":"```ts\r\n/*\r\n * Algorithm: HashMap\r\n * Time Complexity: O(n^2)\r\n * Space Complexity: O(n)\r\n */\r\nfunction numberOfBoomerangs(points: number[][]): number {\r\n  let ret = 0\r\n  points.forEach((p) => {\r\n    const map = new Map<number, number>()\r\n    points.forEach((q) => {\r\n      const dis = distance(p ,q)\r\n      map.set(dis, (map.get(dis) || 0) + 1)\r\n    })\r\n    for (const v of map.values()) ret += v * (v - 1)\r\n  })\r\n  return ret\r\n};\r\n\r\nfunction distance(a: number[], b: number[]): number {\r\n  return Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2)\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205685969","body":"```ts\r\n/*\r\n * Algorithm: Sliding Window + HashMap\r\n * Time Complexity: O(n)\r\n * Space Complexity: O(n)\r\n */\r\nfunction lengthOfLongestSubstring(s: string): number {\r\n  let max = 0, windowStart = 0\r\n  let indexMap = new Map<string, number>()\r\n  for (let i = 0; i < s.length; i++) {\r\n    const c = s[i]\r\n    if (indexMap.has(c) && indexMap.get(c) >= windowStart) windowStart = indexMap.get(c) + 1\r\n    indexMap.set(c, i)\r\n    max = Math.max(max, i - windowStart + 1)\r\n  }\r\n  return max\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207182663","body":"```ts\r\n/*\r\n * Algorithm: Sliding Window + HashMap\r\n * Time Complexity: O((n-k)*k)\r\n * Space Complexity: O(m)\r\n */\r\nfunction findSubstring(s: string, words: string[]): number[] {\r\n  const ret = []\r\n  const wordSize = words[0].length, subStrLen = words.length * wordSize\r\n  const hash = new Map<string, number>()\r\n  words.forEach((w) => hash.set(w, (hash.get(w) || 0) + 1))\r\n  for (let i = 0; i <= s.length - subStrLen; i++) {\r\n    const tmpHash = new Map(hash)\r\n    let wordCount = words.length\r\n    for (let j = i; j < i + subStrLen; j += wordSize) {\r\n      const word = s.slice(j, j + wordSize)\r\n      const count = tmpHash.get(word)\r\n      if (!count) break\r\n      if (--wordCount === 0) {\r\n        ret.push(i)\r\n        break\r\n      }\r\n      tmpHash.set(word, count - 1)\r\n    }\r\n  }\r\n  return ret\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207421990","body":"```js\r\n/*\r\n * Algorithm: Prefx Sum + HashMap\r\n * Time Complexity: O(n)\r\n * Space Complexity: O(n)\r\n */\r\nclass Solution {\r\n    solve(nums, k) {\r\n        if (!nums.length) return -1\r\n        const diff = nums.reduce((a, b) => a + b) % k\r\n        let res = diff === 0 ? 0 : nums.length\r\n        for (let i = 0, sum = 0, map = new Map([[0, -1]]); i < nums.length; i++) {\r\n            sum += nums[i]\r\n            const target = (sum % k - diff + k) % k\r\n            if (map.has(target)) res = Math.min(res, i - map.get(target))\r\n            map.set(sum % k, i)\r\n        }\r\n        return res === nums.length ? -1 : res\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208233319","body":"```ts\r\n/**\r\n * Algorithm: Fast and Slow Pointer\r\n * Time Complexity: O(n)\r\n * Space Complexity: O(1)\r\n */\r\nfunction middleNode(head: ListNode | null): ListNode | null {\r\n  if (!head) return null\r\n  let slow = head, fast = head\r\n  while (fast && fast.next) {\r\n    slow = slow.next\r\n    fast = fast.next.next\r\n  }\r\n  return slow\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208848531","body":"```ts\r\n/**\r\n * Algorithm: Fast and Slow Pointer\r\n * Time Complexity: O(n)\r\n * Space Complexity: O(1)\r\n */\r\nfunction removeDuplicates(nums: number[]): number {\r\n  let slow = 0, fast = 0\r\n  while (fast++ < nums.length - 1) {\r\n    if (nums[slow] !== nums[fast]) nums[++slow] = nums[fast]\r\n  }\r\n  return slow + 1\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fourierhai":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187671196","body":"``` java\r\n\r\npublic String decodeString(String s) {\r\n        StringBuilder currStr = new StringBuilder();\r\n        int currNum = 0;\r\n        Stack<Integer> numsStack = new Stack<>();\r\n        Stack<StringBuilder> strsStack = new Stack<>();\r\n\r\n        for (char c : s.toCharArray()) {\r\n            if (c == '[') {\r\n                numsStack.push(currNum);\r\n                strsStack.push(currStr);\r\n                //é‡æ–°å¼€å§‹ç»Ÿè®¡\r\n                currNum = 0;\r\n                currStr = new StringBuilder();\r\n            } else if (c == ']') {\r\n                //é‡åˆ°] ï¼Œæ ˆé‡Œé¢çš„æ•°å­—å’Œå­—ç¬¦ä¸²éƒ½å‡ºæ ˆï¼Œå¹¶ä¸”ä¸æ‹¬å·å†…çš„å­—ç¬¦ä¸²è¿›è¡Œæ‹¼æ¥\r\n                int prenum = numsStack.pop();\r\n                StringBuilder prestr = strsStack.pop();\r\n                //æ‹¼æ¥å­—ç¬¦ä¸²ï¼Œå¯èƒ½éœ€è¦è¿›è¡Œå¤šæ¬¡æ‹¼æ¥\r\n                for (int i = 0; i < prenum; i++) {\r\n                    prestr.append(currStr);\r\n                }\r\n                currStr = prestr;\r\n            } else if (c >= '0' && c <= '9') {\r\n                //é‡åˆ°äº†æ•°å­—ï¼Œé‚£ä¹ˆæ‹¼æ¥æ•°å­—ï¼Œæœ‰å¯èƒ½ä¸æ­¢ä¸ªä½æ•°\r\n                currNum = currNum * 10 + Integer.parseInt(String.valueOf(c));\r\n            } else {\r\n                //å…¶ä»–ï¼Œå½“ä½œæ™®é€šå­—ç¬¦æ‹¼æ¥ï¼Œä½œä¸ºå½“å‰å­—ç¬¦ä¸²\r\n                currStr.append(c);\r\n            }\r\n        }\r\n        return currStr.toString();\r\n    }\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189049685","body":"``` java\nclass MyQueue {\n\n    public Stack<Integer> stackPush;\n    public Stack<Integer> stackPop;\n\n    public MyQueue() {\n        this.stackPush = new Stack<Integer>();\n        this.stackPop = new Stack<Integer>();\n    }\n    \n    public void push(int x) {\n        stackPush.push(x);\n    }\n    \n    public int pop() {\n        if (stackPop.isEmpty() && stackPush.isEmpty()) {\n            throw new RuntimeException(\"Queue is empty\");\n        }\n        if (stackPop.isEmpty()) {\n            while (!stackPush.isEmpty()) {\n                stackPop.push(stackPush.pop());\n            }\n        }\n        return stackPop.pop();\n    }\n    \n    public int peek() {\n        if (stackPop.isEmpty() && stackPush.isEmpty()) {\n            throw new RuntimeException(\"Queue is empty\");\n        }\n        if (stackPop.isEmpty()) {\n            while (!stackPush.isEmpty()) {\n                stackPop.push(stackPush.pop());\n            }\n        }\n        return stackPop.peek();\n    }\n    \n    public boolean empty() {\n        return stackPush.isEmpty() && stackPop.isEmpty();\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190462192","body":"```java\n//å…ˆæ‰“å¡\npublic int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n\n        for (int num : arr) {\n            if (!stack.isEmpty() && num < stack.getLast()) {\n                // æˆ‘ä»¬éœ€è¦å°†èåˆåçš„åŒºå—çš„æœ€å¤§å€¼é‡æ–°æ”¾å›æ ˆ\n                // è€Œ stack æ˜¯é€’å¢çš„ï¼Œå› æ­¤ stack[-1] æ˜¯æœ€å¤§çš„\n                int cur = stack.removeLast();\n                // ç»´æŒæ ˆçš„å•è°ƒé€’å¢\n                while (!stack.isEmpty() && num < stack.getLast()) {\n                    stack.removeLast();\n                }\n                stack.addLast(cur);\n            } else {\n                stack.addLast(num);\n            }\n        }\n        // æ ˆå­˜çš„æ˜¯å—ä¿¡æ¯ï¼Œå› æ­¤æ ˆçš„å¤§å°å°±æ˜¯å—çš„æ•°é‡\n        return stack.size();\n    }\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194084853","body":"```java\npublic ListNode detectCycle(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n        //è€ƒè™‘è¾¹ç•Œ\n        if (head == null) {\n            return null;\n        }\n        while (fast.next != null && fast.next.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) {\n                break;\n            }\n        }\n        // è€ƒè™‘è¾¹ç•Œï¼Œæ¯”å¦‚é“¾è¡¨åªæœ‰1ä¸ªèŠ‚ç‚¹\n        if (fast.next == null || fast.next.next == null) {\n            return null;\n        }\n        // ä»ç›¸é‡ç‚¹å¼€å§‹ï¼Œéšä¾¿å“ªä¸ªæŒ‡é’ˆä»å¤´å¼€å§‹ï¼ŒåŒæ­¥èµ°ï¼Œå†ç›¸é‡å°±æ˜¯ç¯çš„åˆ‡ç‚¹\n        slow = head;\n        while (slow != fast) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200441651","body":"```java\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        if (root == null) {\n            return \"null\";\n        }\n        String left = serialize(root.left);\n        String right = serialize(root.right);\n        return root.val + \",\" + left + \",\" + right;\n        \n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        String[] nodes = data.split(\",\");\n        Queue<String> queue = new ArrayDeque<>(Arrays.asList(nodes));\n        return buildTree(queue);\n    }\n\n    private TreeNode buildTree(Queue<String> queue) {\n        String value = queue.poll();\n        if (value.equals(\"null\")) {\n            return null;\n        }\n        TreeNode root = new TreeNode(Integer.parseInt(value));\n        root.left = buildTree(queue);\n        root.right = buildTree(queue);\n        return root;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yangz001":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187671250","body":"# æ€è·¯\r\n\r\næ ˆ\r\n\r\n# ä»£ç \r\n\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        StringBuilder res = new StringBuilder();\r\n        int multi = 0;\r\n        LinkedList<Integer> stk_multi = new LinkedList<>();\r\n        LinkedList<String> stk_res = new LinkedList<>();\r\n        for (char c : s.toCharArray()) {\r\n            if (c == '[') {\r\n                stk_multi.addLast(multi);\r\n                stk_res.addLast(res.toString());\r\n                multi = 0;\r\n                res = new StringBuilder();\r\n            }\r\n            else if (c == ']') {\r\n                StringBuilder tmp = new StringBuilder();\r\n                int cur_multi = stk_multi.removeLast();\r\n                for (int i = 0; i < cur_multi; i++) {\r\n                    tmp.append(res);\r\n                }\r\n                res = new StringBuilder(stk_res.removeLast() + tmp);\r\n            }\r\n            else  if (c >= '0' && c <= '9') {\r\n                multi = multi * 10 + Integer.parseInt(c + \"\");\r\n            }\r\n            else {\r\n                res.append(c);\r\n            }\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n```\r\n\r\n# å¤æ‚åº¦åˆ†æ\r\n\r\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\r\n\r\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188609109","body":"# æ€è·¯\n\n- å®ç°æ ˆï¼šä½¿ç”¨SLL\n  \n- 2ä¸ªæ ˆå®ç°é˜Ÿåˆ—\n  \n\n# ä»£ç \n\n```java\nclass MyQueue {\n    private class Stack {\n        private class ListNode {\n            int val;\n            ListNode next;\n            public ListNode(int val, ListNode next) {\n                this.val = val;\n                this.next = next;\n            }\n            \n            public ListNode(int val) {\n                this(val, null);\n            }\n        }\n        // Use SLL as a stack\n        \n        ListNode head;\n        \n        public Stack() {\n            head = new ListNode(0);\n        }\n        \n        public boolean isEmpty() {\n            return head.next == null;\n        }\n        \n        public int pop() {\n            int val = head.next.val;\n            head.next = head.next.next;\n            return val;\n        }\n        \n        public void push(int x) {\n            ListNode p = new ListNode(x, head.next);\n            head.next = p;\n        }\n        public int peek() {\n            return head.next.val;\n        }\n    }\n    \n    Stack in;\n    Stack out;\n    public MyQueue() {\n        in = new Stack();\n        out = new Stack();\n    }\n    \n    public void push(int x) {\n        in.push(x);\n    }\n    \n    public int pop() {\n        peek();\n        return out.pop();\n    }\n    \n    public int peek() {\n        if (out.isEmpty()) {\n            while (!in.isEmpty()) {\n                out.push(in.pop());\n            }\n        }\n        return out.peek();\n    }\n    \n    public boolean empty() {\n        return in.isEmpty() && out.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n\n# å¤æ‚åº¦åˆ†æ\n\næ—¶é—´å¤æ‚åº¦ï¼š\n\n- å…¥æ ˆï¼šO(1)\n  \n- å‡ºæ ˆï¼šO(1)\n  \n\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191618465","body":"# æ€è·¯\n\n1. æ±‚å¾—é“¾è¡¨é•¿åº¦n\n\n2. k = n % k. æ‰¾åˆ°å€’æ•°kä¸ªï¼Œæˆªæ–­æˆa, bä¸¤ä¸ªlistã€‚äº¤æ¢ä½ç½®å†æ‹¼æ¥ã€‚\n\n# ä»£ç \n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null) return head;\n        if (k == 0) return head;\n        // get length\n        int size = getSize(head);\n        k = k % size;\n        if (k == 0) return head;\n        k = size - k;\n        //System.out.printf(\"k = %d\",k);\n        ListNode p = head;\n        while (k > 1) {\n            p = p.next;\n            k--;\n        }\n        // k ==0, p is the kth node\n        ListNode newHead = p.next;\n        p.next = null;\n        p = newHead;\n        while (p.next != null) {\n            p = p.next;\n        }\n        // p is the last node\n        p.next = head;\n        return newHead;\n    }\n\n    public int getSize(ListNode head) {\n        ListNode p = head;\n        int cnt = 0;\n        while (p != null) {\n            cnt++;\n            p = p.next;\n        }\n        return cnt;\n    }\n}\n```\n\n# å¤æ‚åº¦åˆ†æ\n\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192629667","body":"# LeetCode Link\n\n[Swap Nodes in Pairs - LeetCode](https://leetcode.com/problems/swap-nodes-in-pairs/)\n\n# Idea\n\nFind every two listNode. And swap. Could be iteratively or recursively.\n\n# Code\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        // Recursively\n        if (head == null || head.next == null) return head;\n        ListNode rest = swapPairs(head.next.next);\n        ListNode a = head;\n        ListNode b = head.next;\n        b.next = a;\n        a.next = rest;\n        return b;\n    }\n\n    public ListNode swapPairs(ListNode head) {\n        // Iteratively\n        if (head == null || head.next == null) return head;\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode p = dummy;\n        while (p.next != null && p.next.next != null) {\n            ListNode a = p.next;\n            ListNode b = p.next.next;\n            ListNode next = b.next;\n            p.next = b;\n            b.next = a;\n            a.next = next;\n            p = a;\n        }\n        return dummy.next;\n    }\n}\n```\n\n# Complexity Analysis\n\nTime Complexity: O(N)\n\nSpace Complexity: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193135631","body":"# LeetCode Link\n\n[Convert Sorted List to Binary Search Tree - LeetCode](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/)\n\n# Idea\n\n1. Convert nodes to nums array. Build BST tree.\n\n# Code\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n        List<Integer> lst = new ArrayList<>();\n        getNodes(head, lst);\n        int n = lst.size();\n        int[] nums = new int[n];\n        for (int i = 0; i < n; i++) {\n            nums[i] = lst.get(i);\n        }\n        return buildTree(nums, 0, n - 1);\n    }\n    \n    public TreeNode buildTree(int[] nums, int start, int end) {\n        if (start > end) {\n            return null;\n        }\n        int mid = (start + end) / 2;\n        TreeNode root = new TreeNode(nums[mid]);\n        root.left = buildTree(nums, start, mid - 1);\n        root.right = buildTree(nums, mid + 1, end);\n        return root;\n    }\n    \n    public void getNodes(ListNode head, List<Integer> lst) {\n        ListNode p = head;\n        while (p != null) {\n            lst.add(p.val);\n            p = p.next;\n        }\n    }\n}\n```\n\n# Complexity Analysis\n\nTime Complexity: O(N)\n\nSpace Complexity: O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193244193","body":"# LeetCode Link\n\n[Intersection of Two Linked Lists - LeetCode](https://leetcode.com/problems/intersection-of-two-linked-lists/)\n\n# Idea\n\nIf headA == null or headB == null, return null.\n\nElse, traverse each linkedlist. If current pointer(a,b) is null, then contatenate to the other head. If exists an intersection node, a == b == intersection node. If not exists, then a and b will points to null and return.\n\n# Code\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) return null;\n        ListNode a = headA, b = headB;\n        while (a != b) {\n            a = a == null ? headB : a.next;\n            b = b == null ? headA : b.next;\n        }\n        return a;\n    }\n}\n```\n\n# Complexity Analysis\n\nTime Complexity\n\nO(N)\n\nSpace Complexity\n\nO(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193996265","body":"# LeetCode Link\n\n[Linked List Cycle II - LeetCode](https://leetcode.com/problems/linked-list-cycle-ii/)\n\n# Idea\n\nFast/slow pointers. Fast pointer go twice the distance than that of slow pointer. If cycle exists, fast and slow will meet each other. Let's assume 5 variable. \n\n1. Distance of slow : s.\n2. Distance of fast : f.\n3. From head to where cycle begins is x. \n4. From x to where two pointer meets is y. \n5. And the length of cycle is r.\n\nWe can have these equation:\n\n1. `f = 2 * s`\n2. `s = x + y`\n3. `f - s = n * r`\n\nCombined to get: `x + y = n * r` which equals to `x = n*r - y`\n\nIn order to get `x`, which is `n*r - y`, let a new node go from head and slow go next, while they meet, it is where the cycle begins.\n\n# Code\n\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) return null;\n        ListNode slow = head, fast = head;\n        while (fast.next != null && fast.next.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) break;\n        }\n        if (fast.next == null || fast.next.next  == null) return null;\n        ListNode p = head;\n        while (p != slow) {\n            p = p.next;\n            slow = slow.next;\n        }\n        return p;\n    }\n}\n```\n\n# Complexity Analysis\n\nTime Complexity\n\nO(N)\n\nSpace Complexity\n\nO(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195404141","body":"# LeetCode Link\n\n[LRU Cache - LeetCode](https://leetcode.com/problems/lru-cache/)\n\n# Idea\n\nDoublyLinkedList + HashMap.\n\n# Code\n\n```java\nclass LRUCache {\n    private class Node {\n        int key;\n        int val;\n        Node prev;\n        Node next;\n        public Node(int key, int val, Node prev, Node next) {\n            this.key = key;\n            this.val = val;\n            this.prev = prev;\n            this.next = next;\n        }\n        public Node(int key, int val) {\n            this(key, val, null, null);\n        }\n    }\n\n    private class DDL {\n        // doubly linked list\n        private Node head;\n        private Node tail;\n        public DDL() {\n            head = new Node(0, 0);\n            tail = new Node(0,0);\n            head.next = tail;\n            tail.prev = head;\n        }\n\n        public Node pollFirst() {\n            Node evict = head.next;\n            removeNode(evict);\n            return evict;\n        }\n\n        public void removeNode(Node node) {\n            node.next.prev = node.prev;\n            node.prev.next = node.next;\n            node.next = null;\n            node.prev = null;\n        }\n\n        public void offerLast(Node node) {\n            node.next = tail;\n            node.prev = tail.prev;\n            tail.prev.next = node;\n            tail.prev = node;\n        }\n    }\n\n    private DDL ddl = new DDL();\n    private int cap;\n    private Map<Integer, Node> memo = new HashMap<>();\n\n    public LRUCache(int capacity) {\n        cap = capacity;\n    }\n\n    public int get(int key) {\n        if (!memo.containsKey(key)) return -1;\n        Node node = memo.get(key);\n        ddl.removeNode(node);\n        ddl.offerLast(node);\n        return node.val;\n    }\n\n    public void put(int key, int value) {\n        if (memo.containsKey(key)) {\n            Node node = memo.get(key);\n            node.val = value;\n            ddl.removeNode(node);\n            ddl.offerLast(node);\n        }\n        else {\n            Node node = new Node(key, value);\n            if (memo.size() >= cap) {\n                // should evict\n                Node evict = ddl.pollFirst();\n                memo.remove(evict.key);\n            }\n            ddl.offerLast(node);\n            memo.put(key, node);\n        }\n    }\n}\n\n```\n\n# Complexity Analysis\n\nTime Complexity\n\nO(1)\n\nSpace Complexity\n\nO(k)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196197716","body":"# LeetCode Link\n\n[Maximum Depth of Binary Tree - LeetCode](https://leetcode.com/problems/maximum-depth-of-binary-tree/)\n\n# Idea\n\nPostorder traversal. Get maxDepth from left and right, return 1 + Max(depth(left), depth(right));\n\n# Code\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n    }\n}\n```\n\n# Complexity Analysis\n\nTime Complexity\n\nO(N)\n\nSpace Complexity\n\nO(logN)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198310079","body":"# LeetCode Link\n\n[Same Tree - LeetCode](https://leetcode.com/problems/same-tree/)\n\n# Idea\n\nPreorder traversal.\n\n# Code\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n```\n\n# Complexity Analysis\n\nTime Complexity\n\nO(N)\n\nSpace Complexity\n\nO(logN)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199142555","body":"# LeetCode Link\n\n[Sum Root to Leaf Numbers - LeetCode](https://leetcode.com/problems/sum-root-to-leaf-numbers/)\n\n# Idea\n\nPreorder traversal.\n\nStore temperary result at each node's val. Collect result only when it is a leaf node.\n\n\n# Code\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int res = 0;\n    public int sumNumbers(TreeNode root) {\n        traverse(root, 0);\n        return res;\n    }\n    \n    public void traverse(TreeNode root, int k) {\n        if (root == null) {\n            return ;\n        }\n        root.val += 10 * k;\n        if (root.left == null && root.right == null) {\n            // leaf\n            res += root.val;\n        }\n        traverse(root.left, root.val);\n        traverse(root.right, root.val);\n    }\n}\n```\n\n# Complexity Analysis\n\nTime Complexity\n\nO(N)\n\nSpace Complexity\n\nO(logN)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200087390","body":"# LeetCode Link\n\n[Find Bottom Left Tree Value - LeetCode](https://leetcode.com/problems/find-bottom-left-tree-value/)\n\n# Idea\n\n**Solution 1: Level order traversal**\n\nBinary tree level order traversal, from right to left. The result value is the last node visited.\n\n# Code\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        // Level order traversal, from right to left. The res value is the last node visited.\n        int res = root.val;\n        Queue<TreeNode> q = new ArrayDeque<>();\n        q.offer(root);\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode cur = q.poll();\n                if (cur.right != null) q.offer(cur.right);\n                if (cur.left != null) q.offer(cur.left);\n                res = cur.val;\n            }\n        }\n        return res;\n    }\n}\n```\n\n**Solution 2: binary tree preorder traversal**\n\nBinary tree preorder traversal. \n\nWhy preorder? Preorder ensures that the left most TreeNode will be visited firstly for each level.\n\nSo whenever entering a new row, its leftmost node's val will be recorded. If reach null node, return the funciton.\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        // Preorder traversal.\n        int[] res = new int[2];\n        find(root, 1, res);\n        return res[0];\n    }\n    \n    public void find(TreeNode root, int depth, int[] res) {\n        // preorder traversal\n        if (root == null) return ;\n        if (res[1] < depth) {\n            // a new level\n            res[0] = root.val;\n            res[1] = depth;\n        }\n        find(root.left, depth+1, res);\n        find(root.right, depth+1, res);\n    }\n}\n```\n# Complexity Analysis\n\nTime Complexity\n\nO(N)\n\nSpace Complexity\n\nO(logN)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200337906","body":"# LeetCode Link\n\n[Serialize and Deserialize Binary Tree - LeetCode](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)\n\n# Idea\n\nEncode: preorder traversal.\n\nDecode: preorder traversal, with the help of a queue.\n\n# Code\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n    private String SEP = \",\";\n    private String NULL = \"#\";\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        shelp(root, sb);\n        return sb.toString();\n    }\n    \n    private void shelp(TreeNode root, StringBuilder sb) {\n        if (root == null) {\n            sb.append(NULL).append(SEP);\n            return ;\n        }\n        sb.append(root.val).append(SEP);\n        shelp(root.left, sb);\n        shelp(root.right, sb);\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        String[] input = data.split(SEP);\n        Queue<String> q = new ArrayDeque<>();\n        for (String s : input) {\n            q.offer(s);\n        }\n        return dhelp(q);\n    }\n    \n    private TreeNode dhelp(Queue<String> q) {\n        String cur = q.poll();\n        if (cur.equals(NULL)) {\n            return null;\n        }\n        int val = Integer.parseInt(cur);\n        TreeNode root = new TreeNode(val);\n        root.left = dhelp(q);\n        root.right = dhelp(q);\n        return root;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser = new Codec();\n// Codec deser = new Codec();\n// TreeNode ans = deser.deserialize(ser.serialize(root));\n```\n\n# Complexity Analysis\n\nTime Complexity\n\nO(N)\n\nSpace Complexity\n\nO(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201156442","body":"# LeetCode Link\n\n[Vertical Order Traversal of a Binary Tree - LeetCode](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/)\n\n# Idea\n\nSince the question requires traversal by column, then by row, then by value. My first thought would be store each node into a list and sort by that order. Then add to a result list and return.\n\nTime Complexity: O(NlogN)\n\nSpace Complexity: O(N)\n\n# Code\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private class State{\n        int val;\n        int row;\n        int col;\n        public State(int val, int row, int col) {\n            this.val = val;\n            this.row = row;\n            this.col = col;\n        }\n    }\n\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<State> lst = new ArrayList<>();\n        traverse(root, lst, 0, 0);\n        lst.sort(Comparator.comparing((State s) -> s.col)\n                        .thenComparing((State s) -> s.row)\n                        .thenComparing((State s) -> s.val));\n        List<List<Integer>> res = new ArrayList<>();\n        for (int i = firstCol; i <= lastCol; i++) {\n            res.add(new ArrayList<>());\n        }\n        int offSet = -firstCol;\n        for (State s : lst) {\n            res.get(s.col + offSet).add(s.val);\n        }\n        return res;\n    }\n\n    int firstCol = Integer.MAX_VALUE;\n    int lastCol = Integer.MIN_VALUE;\n    public void traverse(TreeNode root, List<State> lst, int row, int col) {\n        if (root == null) return ;\n        lst.add(new State(root.val, row, col));\n        firstCol = Math.min(firstCol, col);\n        lastCol = Math.max(lastCol, col);\n        traverse(root.left, lst, row+1, col-1);\n        traverse(root.right, lst, row+1, col+1);\n    }\n}\n```\n\nResult:\n\nRuntime: 85 ms, faster than 5.39% of Java online submissions for Vertical Order Traversal of a Binary Tree.\nMemory Usage: 42.9 MB, less than 71.02% of Java online submissions for Vertical Order Traversal of a Binary Tree.\n\n# Complexity Analysis\n\nTime Complexity\n\nO(NlogN)\n\nSpace Complexity\n\nO(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202271404","body":"# LeetCode Link\n\n[Two Sum - LeetCode](https://leetcode.com/problems/two-sum/)\n\n# Idea\n\nHashmap\n\n# Code\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int n = nums.length;\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            if (map.containsKey(target - nums[i])) {\n                return new int[]{i, map.get(target - nums[i])};\n            }\n            map.put(nums[i], i);\n        }\n        return new int[]{-1,-1};\n    }\n}\n```\n\n# Complexity Analysis\n\nTime Complexity\n\nO(N)\n\nSpace Complexity\n\nO(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203512291","body":"# LeetCode Link\n\n[Top K Frequent Elements - LeetCode](https://leetcode.com/problems/top-k-frequent-elements/)\n\n# Idea\n\nHashmap to store frequency. Use priorityQueue to select Top k.\n\n# Code\n\n```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        int n = nums.length;\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i : nums) {\n            map.put(i, map.getOrDefault(i, 0) + 1);\n        }\n        Queue<Integer> q = new PriorityQueue<>((a, b) -> map.get(a) - map.get(b));\n        for (int i : map.keySet()) {\n            q.offer(i);\n            if(q.size()>k) q.poll();\n        }\n        int[] res = new int[q.size()];\n        int i = res.length;\n        while (i > 0) {\n            res[i-1] = q.poll();\n            i--;\n        }\n        return res;\n    }\n}\n```\n\n# Complexity Analysis\n\nTime Complexity\n\nO(NlogK)\n\nSpace Complexity\n\nO(N+k)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205396249","body":"# LeetCode Link\n\n[Number of Boomerangs - LeetCode](https://leetcode.com/problems/number-of-boomerangs/)\n\n# Idea\n\nUse hashMap to store \\<Distance, number of pairs\\>.\n\n# Code\n\n```java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int res = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i=0; i<points.length; i++) {\n            // centered i\n            for(int j=0; j<points.length; j++) {\n                if(i == j)\n                    continue;\n\n                int d = getDistance(points[i], points[j]);\n                map.put(d, map.getOrDefault(d, 0) + 1);\n            }\n\n            for(int val : map.values()) {\n                res += val * (val-1);\n            }\n            map.clear();\n        }\n\n        return res;\n    }\n\n    private int getDistance(int[] a, int[] b) {\n        int dx = a[0] - b[0];\n        int dy = a[1] - b[1];\n\n        return dx*dx + dy*dy;\n    }\n}\n```\n\n# Complexity Analysis\n\nTime Complexity\n\nO(N^2)\n\nSpace Complexity\n\nO(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206538278","body":"# LeetCode Link\n\n[Longest Substring Without Repeating Characters - LeetCode](https://leetcode.com/problems/longest-substring-without-repeating-characters/)\n\n# Idea\n\nSliding window with memo as count for window.\n\n# Code\n\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int[] memo = new int[128];\n        int n = s.length();\n        int l = 0, r = 0;\n        int res = 0;\n        while (r < n) {\n            char c = s.charAt(r);\n            memo[c]++;\n            r++;\n            while (memo[c] > 1) {\n                char e = s.charAt(l);\n                l++;\n                memo[e]--;\n            }\n            res = Math.max(res, r - l);\n        }\n        return res;\n    }\n}\n```\n\n# Complexity Analysis\n\nTime Complexity\n\nO(N)\n\nSpace Complexity\n\nO(128) = O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207165417","body":"# LeetCode Link\n\n[Substring with Concatenation of All Words - LeetCode](https://leetcode.com/problems/substring-with-concatenation-of-all-words/)\n\n# Idea\n\nSubstring problem, use sliding window.\n\nFor each position `i`, can search for the condition. If meet, record. Else, find next one.\n\nHow to search?\n\nSliding window with hashMap.\n\n# Code\n\n```java\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        /*\n        Time Complexity: O(N^2);\n        Space Complexity: O(N);\n        */\n        // Store all the words in hashMap\n        Map<String, Integer> need = new HashMap<>();\n        int valid = 0;\n        for (String w : words) {\n            if (!need.containsKey(w)) {\n                valid++;\n            }\n            need.put(w, need.getOrDefault(w, 0) + 1);\n        }\n        int k = words[0].length();\n        int n = s.length();\n        int m = words.length;\n        List<Integer> res = new ArrayList<>();\n        //System.out.printf(\"New test, valid=%d, n=%d, m*k=%d \\n\",valid, n, m*k);\n        \n        for (int l = 0; l <= n - k * m; l++) {\n            // for every possible position, perform sliding window\n            int cnt = 0; // valid matches\n            Map<String, Integer> window = new HashMap<>(); // HashMap, store valus in window.\n            int r = l;\n            while (r + k <= n) {\n                String cur = s.substring(r, r+k);\n                if (!need.containsKey(cur)) break; // unknown, break;\n                window.put(cur, window.getOrDefault(cur, 0) + 1); // plus 1\n                if (window.get(cur).equals(need.get(cur))) cnt++; // find a valid one\n                if (window.get(cur) > (need.get(cur))) break; // more than need, break;\n                //System.out.printf(\"l=%d, r=%d,cnt=%d\\n\",l,r,cnt);\n                if (cnt == valid) {\n                    res.add(l);\n                    break;\n                }\n                r+=k;\n            }\n        }\n        return res;\n    }\n}\n```\n\n# Complexity Analysis\n\nTime Complexity\n\nO(N^2)\n\nSpace Complexity\n\nO(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207435714","body":"# LeetCode Link\n\n[Delete Sublist to Make Sum Divisible By K | binarysearch](https://binarysearch.com/problems/Delete-Sublist-to-Make-Sum-Divisible-By-K)\n\n\n\n# Idea\n\nPrefix sum\n\n\n# Code\n\n```java\nimport java.util.*;\n\nclass Solution {\n    public int solve(int[] nums, int p) {\n        // Find target module\n        int target = 0, res = nums.length;\n        for (int n : nums)\n            target = (target + n) % p;\n        // No need to remove any sublist\n        if (target == 0) {return 0;}\n        \n        // Key: prefixSumModP, Value: position index\n        Map<Integer, Integer> pos = new HashMap<>();\n        pos.put(0, -1);\n        \n        int curMod = 0;\n        for (int i = 0; i < nums.length; ++i) {\n            curMod = (curMod + nums[i]) % p;\n            // Comp Equation!\n            int comp = (p - target + curMod) % p;\n            if (pos.containsKey(comp))\n                res = Math.min(res, i - pos.get(comp));\n            pos.put(curMod, i);\n        }    \n        return res >= nums.length ? -1 : res;\n    }\n}\n```\n\n# Complexity Analysis\n\nTime Complexity\n\nO(N)\n\nSpace Complexity\n\nO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207659909","body":"# LeetCode Link\n\n[Middle of the Linked List - LeetCode](https://leetcode.com/problems/middle-of-the-linked-list/)\n\n# Idea\n\nUse fast pointer and slow pointer.\n\nOriginally, if we start at head node, then `s.next` will always give the head of second linked list, which is not suitable for this question. Because if it is `odd` linked list, then we should return `s` instead of `s.next`.\n\nSo, we create a dummy node, start from this dummy. Then `s.next` is always what we need.\n\n\n# Code\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode d = new ListNode(1);\n        d.next = head;\n        ListNode s = d, f = d;\n        while (f.next != null && f.next.next != null) {\n            s = s.next;\n            f = f.next.next;\n        }\n        return s.next;\n    }\n}\n```\n\n# Complexity Analysis\n\nTime Complexity\n\nO(N)\n\nSpace Complexity\n\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208854473","body":"# LeetCode Link\n\n[Remove Duplicates from Sorted Array - LeetCode](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)\n\n# Idea\n\nDouble pointer.\n\nPointer `i` points to position that is valid result.\n\nPointer `j` points to new position.\n\nIf `nums[i] != nums[j]`, valid result should plus one. So, `i++`, then `swap(nums, i, j)`\n\n\n# Code\n\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int n = nums.length;\n        int i = 0;\n        for (int j = 1; j < n; ++j) {\n            if (nums[i] != nums[j]) {\n                i++;\n                swap(nums, i, j);\n            }\n        }\n        return i+1;\n    }\n    \n    public void swap(int[] nums, int i, int j) {\n        int tmp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = tmp;\n    }\n}\n```\n\n# Complexity Analysis\n\nTime Complexity\n\nO(N)\n\nSpace Complexity\n\nO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mannnn6":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1187984710","body":"```python\nclass MyQueue:\n\n    def __init__(self):\n        self.input = []    \n        self.op = []\n    def push(self, x: int) -> None:\n        self.input.append(x)\n\n    def pop(self) -> int:\n        if not self.op:\n            while self.input:\n                self.op.append(self.input.pop())\n        return self.op.pop()    \n        \n    def peek(self) -> int:\n        if not self.op:\n            while self.input:\n                self.op.append(self.input.pop())\n        return self.op[-1] \n\n    def empty(self) -> bool:\n        return len(self.input) == 0 and len(self.op) == 0\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190968022","body":"```python\nclass Solution:\n    def rotateRight(self, head: 'ListNode', k: 'int') -> 'ListNode':\n       \n        if not head:\n            return None\n        if not head.next:\n            return head\n        \n       \n        old_tail = head\n        n = 1\n        while old_tail.next:\n            old_tail = old_tail.next\n            n += 1\n        old_tail.next = head\n        \n        \n        new_tail = head\n        for i in range(n - k % n - 1):\n            new_tail = new_tail.next\n        new_head = new_tail.next\n        \n \n        new_tail.next = None\n        \n        return new_head\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194826719","body":"```python \nfrom collections import OrderedDict\nclass LRUCache(OrderedDict):\n\n    def __init__(self, capacity):\n    \n        self.capacity = capacity\n\n    def get(self, key):\n    \n        if key not in self:\n            return - 1\n        \n        self.move_to_end(key)\n        return self[key]\n\n    def put(self, key, value):\n        \n        if key in self:\n            self.move_to_end(key)\n        self[key] = value\n        if len(self) > self.capacity:\n            self.popitem(last = False)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196018040","body":"```python\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197547463","body":"```python\nclass Solution:\n    def isSameTree(self, p, q): \n        if not p and not q:\n            return True\n        if not q or not p:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.right, q.right) and \\\n               self.isSameTree(p.left, q.left)\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200065808","body":"```python\nclass Solution(object):\n    def findBottomLeftValue(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        q = collections.deque([root])\n        tmpq = collections.deque()\n        res = root.val\n        while q:\n            u = q.popleft()\n            if u.left:\n                tmpq.append(u.left)\n            if u.right:\n                tmpq.append(u.right)\n            if not q:\n                if tmpq:\n                    res = tmpq[0].val\n                    q = tmpq\n                    tmpq = collections.deque()\n        return res\n ```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200429105","body":"```python\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        result_str_list = ['[']\n        if root:\n            q = collections.deque([root])\n            while q:\n                for _ in range(len(q)):\n                    cur = q.popleft()\n                    \n                    if cur:\n                        q.extend([cur.left, cur.right])\n                        result_str_list.append(f\"{cur.val},\")\n                    else:\n                        result_str_list.append(\"None,\")\n                \n        if result_str_list[-1] != '[':\n            result_str_list[-1] = result_str_list[-1][:-1]\n        result_str_list.append(']')\n        return ''.join(result_str_list)\n        \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        data = data[1:-1].split(',')\n        q = collections.deque(data)\n                             \n        if len(q) == 1 and q[0] == '':\n            return None\n        \n        root_val = int(q.popleft())\n        root = TreeNode(root_val)\n        tree = collections.deque([root])\n        \n        while tree:\n            for _ in range(len(tree)):\n                cur = tree.popleft()\n                if cur:\n                    left_str, right_str = q.popleft(), q.popleft()\n\n                    if left_str != 'None':\n                        cur.left = TreeNode(int(left_str))\n                    else:\n                        cur.left = None\n\n                    if right_str != 'None':\n                        cur.right = TreeNode(int(right_str))\n                    else:\n                        cur.right = None\n\n                    tree.extend([cur.left, cur.right])\n        return root\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203395104","body":"```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]: \n        if k == len(nums):\n            return nums\n        count = Counter(nums)          \n        return heapq.nlargest(k, count.keys(), key=count.get) \n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/42#issuecomment-1209673645","body":"```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            pivot = (left + right) // 2\n            if nums[pivot] == target:\n                return pivot\n            if target < nums[pivot]:\n                right = pivot - 1\n            else:\n                left = pivot + 1\n        return left\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"haoyangxie":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1190786185","body":"# Code\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> array = new ArrayList<>();\r\n        for (int i = num.length - 1; i >= 0; i--) {\r\n            k += num[i];\r\n            array.add(0, k%10);\r\n            k = k / 10;\r\n        }\r\n        while (k > 0) {\r\n            array.add(0, k%10);\r\n            k = k/10;\r\n        }\r\n        return array;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\nTime: O(n)\r\nSpace: O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1191823942","body":"# Idea\r\nåŒå‘éå†æ•°ç»„å–æœ€å°\r\n\r\n# Code\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] res = new int[n];\r\n        \r\n        int index = Integer.MIN_VALUE / 2;\r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) {\r\n                index = i;\r\n            }\r\n            res[i] = i - index;\r\n        }\r\n        \r\n       index = Integer.MAX_VALUE;\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                index = i;\r\n            }\r\n            res[i] = Math.min(res[i], index - i);\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\nTime: O(n) éå†ä¸¤æ¬¡æ•°ç»„\r\nSpace: O(1) æ²¡æœ‰ä½¿ç”¨é¢å¤–ç©ºé—´","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1190714536","body":"# Idea\r\nç”¨æ•°ç»„ä»£è¡¨æ ˆ\r\n\r\n# Code\r\n```\r\nclass CustomStack {\r\n    int size;\r\n    int index;\r\n    int[] stack;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        size = maxSize;\r\n        index = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (index < size) {\r\n            stack[index++] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (index == 0) {\r\n            return -1;\r\n        }\r\n        return stack[--index];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for (int i = 0; i < Math.min(k, stack.length); i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n# Complexity\r\nTime: O(1) for pop and push.  O(n) for increment.\r\nSpace: O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1190774460","body":"# Idea\r\nä½¿ç”¨ä¸€ä¸ªæ ˆï¼Œ é‡åˆ°]å°±å¼€å§‹å¤„ç†å‰é¢çš„ï¼Œå¤„ç†å®Œå‹å…¥æ ˆï¼›é‡åˆ°å…¶ä»–æƒ…å†µç›´æ¥å‹å…¥æ ˆç­‰å¾…åç»­å¤„ç†ã€‚\r\n\r\n# Code\r\n```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Stack<Character> stack = new Stack<>();\r\n        for (char c : s.toCharArray()) {\r\n            if (c != ']') {\r\n                stack.push(c);\r\n            } else {\r\n                StringBuilder sb = new StringBuilder();\r\n                while (!stack.isEmpty() && Character.isLetter(stack.peek())) {\r\n                    sb.insert(0, stack.pop());\r\n                }\r\n                String sub = sb.toString();\r\n                stack.pop(); // pop \"[\"\r\n\r\n                // get number\r\n                sb = new StringBuilder();\r\n                while (!stack.isEmpty() && Character.isDigit(stack.peek())) {\r\n                    sb.insert(0, stack.pop());\r\n                }\r\n                int count = Integer.parseInt(sb.toString());\r\n\r\n                while (count > 0) {\r\n                    for (char ch : sub.toCharArray()) {\r\n                        stack.push(ch);\r\n                    }\r\n                    count--;\r\n                }\r\n            }\r\n        }\r\n        StringBuilder res = new StringBuilder();\r\n        while (!stack.isEmpty()) {\r\n            res.insert(0, stack.pop());\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\nTime: O(n)\r\nSpace:  O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188387205","body":"# Idea \r\nç”¨stack1æ¥å­˜å‚¨æ–°åŠ çš„å…ƒç´ ï¼Œè¦ä½¿ç”¨popæˆ–è€…peekæ—¶ï¼Œå°†stack1çš„å…ƒç´ å…¨éƒ¨popå‡ºæ¥æ·»åŠ åˆ°stack2ï¼Œæ­¤æ—¶stcak2çš„é¡ºåºå°±æ˜¯å…ˆè¿›å…ˆå‡º(queue)\r\n\r\n```\r\nclass MyQueue {\r\n    Stack<Integer> stack1;\r\n    Stack<Integer> stack2;\r\n\r\n    public MyQueue() {\r\n        stack1 = new Stack<>();\r\n        stack2 = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        stack1.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (stack2.isEmpty()) {\r\n            while (!stack1.isEmpty()) {\r\n                stack2.push(stack1.pop());\r\n            }\r\n        }\r\n        return stack2.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (stack2.isEmpty()) {\r\n            while (!stack1.isEmpty()) {\r\n                stack2.push(stack1.pop());\r\n            }\r\n        }\r\n        return stack2.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return stack1.isEmpty() && stack2.isEmpty();\r\n    }\r\n}\r\n```\r\n\r\n# å¤æ‚åº¦åˆ†æ\r\næ—¶é—´ï¼šO(n)\r\nç©ºé—´ï¼šO(n)\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189384265","body":"# Idea\r\nä½¿ç”¨å•è°ƒæ ˆï¼Œé‡åˆ°å¤§äºç­‰äºæ ˆé¡¶å…ƒç´ ç›´æ¥åŠ å…¥æ ˆï¼Œå¦‚æœå½“å‰å…ƒç´ å°äºæ ˆé¡¶ï¼Œå…ˆå°†ç°åœ¨çš„æ ˆé¡¶å–å‡ºï¼Œç¡®ä¿æ ˆå†…æ²¡æœ‰å¤§äºè¯¥å…ƒç´ çš„å…ƒç´ æœ€åå°†åŸå…ˆçš„æ ˆé¡¶åŠ å…¥ã€‚æ ˆä¸­å…ƒç´ ä¸ªæ•°å°±æ˜¯æœ€å¤šå—çš„ä¸ªæ•°ã€‚\r\n\r\n# Code\r\n```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        stack.push(arr[0]);\r\n        for (int i = 1; i < arr.length; i++) {\r\n            if (!stack.isEmpty() && arr[i] >= stack.peek()) {\r\n                stack.push(arr[i]);\r\n            } else {\r\n                int curMax = stack.pop();\r\n                while (!stack.isEmpty() && stack.peek() > arr[i]) {\r\n                    stack.pop();\r\n                }\r\n                stack.push(curMax);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\nTime: O(n)\r\nSpace:  O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190553938","body":"# Idea\r\nå…ˆç¡®å®šé“¾è¡¨çš„é•¿åº¦ï¼Œéå†é“¾è¡¨æ‰¾åˆ°èµ·å§‹ä½ç½®çš„å‰ä¸€ä¸ªnodeï¼Œä½¿node.next = nullï¼Œæœ€åå°†é“¾è¡¨ç»“å°¾ä¸å¤´éƒ¨ç›¸è¿ã€‚\r\n\r\n# Code\r\n\r\n```\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || head.next == null) return head;\r\n        \r\n        ListNode dummy = head;\r\n        int length = 1;\r\n        while (dummy.next != null) {\r\n            length ++;\r\n            dummy = dummy.next; // dummyç°åœ¨æŒ‡åˆ°æœ€åä¸€ä¸ªnode\r\n        } //ç¡®å®šé“¾è¡¨é•¿åº¦\r\n        \r\n        int pos = k % length;\r\n        length = length - pos;\r\n        ListNode cur = head;\r\n        \r\n        while (length > 1) {\r\n            length --;\r\n            cur = cur.next;\r\n        }\r\n        \r\n        dummy.next = head;\r\n        head = cur.next;\r\n        cur.next = null;\r\n        return head;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1191801680","body":"# Idea\r\nåœ¨é“¾è¡¨é—®é¢˜ä¸­ï¼Œå¦‚æœç¬¬ä¸€ä¸ªnodeè¦è¢«æ“ä½œï¼Œè¦æ˜¯ç”¨dummyheadã€‚\r\n\r\n# Code\r\n```\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if (head == null || head.next == null) {\r\n            return head;\r\n        }\r\n\r\n        ListNode dummyHead = new ListNode(0, head);\r\n        ListNode prev = dummyHead;\r\n        while (head != null && head.next != null) {\r\n            ListNode first = head;\r\n            ListNode second = head.next;   \r\n            first.next = second.next;\r\n            second.next = prev.next;\r\n            prev.next = second;\r\n            \r\n            prev = first;\r\n            head = first.next;\r\n        }\r\n        \r\n        return dummyHead.next;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\nTime: O(n) éå†é“¾è¡¨\r\nSpace: O(1) åªåœ¨é“¾è¡¨ä¸Šæ“ä½œï¼Œæ²¡æœ‰ä½¿ç”¨é¢å¤–ç©ºé—´","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1192852513","body":"# Idea\r\næœ¬é¢˜ç±»ä¼¼äº108ï¼Œåªæ˜¯éœ€è¦ç”¨é“¾è¡¨æ„å»ºå¹³è¡¡äºŒå‰æ ‘è€Œä¸æ˜¯æ•°ç»„ã€‚æ•°ç»„å¯ä»¥ç›´æ¥æ‰¾åˆ°ä¸­é—´å€¼ï¼Œé“¾è¡¨åˆ™ä¸è¡Œã€‚ä¸ºäº†æ„å»ºå¹³è¡¡äºŒå‰æ ‘ï¼Œéœ€è¦æ„å»ºè¾…åŠ©å‡½æ•°æ‰¾åˆ°é“¾è¡¨çš„ä¸­é—´ä»è€Œé€’å½’æ„å»ºã€‚\r\n\r\n# Code\r\n```\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if (head == null) {\r\n            return null;\r\n        }\r\n        if (head.next == null) {\r\n            return new TreeNode(head.val);\r\n        }\r\n        ListNode preMid = findMid(head);\r\n        ListNode mid = preMid.next;\r\n        preMid.next = null;\r\n        TreeNode root = new TreeNode(mid.val);\r\n        root.left = sortedListToBST(head);\r\n        root.right = sortedListToBST(mid.next);\r\n        return root;\r\n    }\r\n    \r\n    private ListNode findMid(ListNode head) {\r\n        ListNode pre = head, slow = head, fast = head.next;\r\n        while (fast != null && fast.next != null) {\r\n            pre = slow;\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        return pre;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\nTime: O(NlgN)\r\nSpace:  O(lgN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193168406","body":"# Idea\r\nAæŒ‡é’ˆèµ°åˆ°å¤´å°±ä»headBé‡æ–°èµ°ï¼ŒBæŒ‡é’ˆèµ°åˆ°å¤´å°±ä»headAé‡æ–°èµ°ï¼Œè¿™æ ·Aï¼ŒBæŒ‡é’ˆç›¸é‡çš„æ—¶å€™å°±éƒ½èµ°äº†ä¸€æ ·çš„è·¯ç¨‹ã€‚\r\n\r\n# Code\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode pA = headA, pB = headB;\r\n        while (pA != pB) {\r\n            pA = pA == null ? headB : pA.next;\r\n            pB = pB == null ? headA : pB.next;\r\n        }\r\n        return pA;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\nTime: O(N + M)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193372015","body":"# Idea\r\nä½¿ç”¨å¿«æ…¢æŒ‡é’ˆï¼Œç»è¿‡è¯æ˜ï¼Œåœ¨æœ‰ç¯çš„æƒ…å†µä¸‹ï¼Œå½“å¿«æ…¢æŒ‡é’ˆç›¸é‡åï¼Œå¿«æŒ‡é’ˆå›åˆ°headç„¶åæ”¹ä¸ºä¸€æ¬¡å‘åèµ°ä¸€æ­¥ï¼Œä¸æ…¢æŒ‡é’ˆå†æ¬¡ç›¸é‡æ—¶å°±æ˜¯è¿˜çš„å…¥å£ã€‚\r\n\r\n# Code\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n        boolean isCycle = false;\r\n        while (fast != null && fast.next != null) {\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n            if (slow == fast) {\r\n                isCycle = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!isCycle) {\r\n            return null;\r\n        }\r\n        \r\n        fast = head;\r\n        while (fast != slow) {\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return fast;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195084040","body":"# Idea\r\nä½¿ç”¨hashmapå’ŒåŒå‘é“¾è¡¨\r\n\r\n# Code\r\n```java\r\nclass LinkNode {\r\n    int key;\r\n    int val;\r\n    LinkNode front;\r\n    LinkNode next;\r\n\r\n    public LinkNode(int key, int val) {\r\n        this.key = key;\r\n        this.val = val;\r\n    }\r\n\r\n}\r\n\r\n\r\nclass LRUCache {\r\n    int capacity;\r\n    Map<Integer, LinkNode> map = new HashMap<>();\r\n    LinkNode head = new LinkNode(0, 0);\r\n    LinkNode tail = new LinkNode(0, 0);\r\n    \r\n\r\n    public LRUCache(int capacity) {\r\n        this.capacity = capacity;\r\n        head.next = tail;\r\n        tail.front = head;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        if (map.containsKey(key)) {\r\n            LinkNode node = map.get(key);\r\n            int value = node.val;\r\n            map.remove(key);\r\n            node.front.next = node.next;\r\n            node.next.front = node.front;\r\n            addFirstNode(key, value);\r\n            return map.get(key).val;\r\n            \r\n        } else {\r\n            return -1;\r\n        }\r\n        \r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        if (!map.containsKey(key)) { // æ²¡è¿™ä¸ªå€¼\r\n            if (map.size() == capacity) { // æ»¡äº†å…ˆåˆ \r\n                deleteLastNode();\r\n            } // ç„¶åå°†è¿™ä¸€å¯¹key valueæ’å…¥æœ€å‰é¢\r\n                addFirstNode(key, value);\r\n            } else { // å·²ç»æœ‰äº†ï¼Œæ‰¾åˆ°å¹¶ä¸”åˆ é™¤ï¼Œç„¶åæ’å…¥æ–°çš„åœ¨æœ€å‰é¢\r\n                LinkNode node = map.get(key);\r\n                map.remove(key);\r\n                node.front.next = node.next;\r\n                node.next.front = node.front;\r\n                addFirstNode(key, value);\r\n            }\r\n    }\r\n    \r\n\r\n    private void deleteLastNode() {\r\n        LinkNode lastNode = tail.front;\r\n        lastNode.front.next = tail;\r\n        tail.front = lastNode.front;\r\n        map.remove(lastNode.key);\r\n    }\r\n    \r\n    private void addFirstNode(int key, int value) {\r\n        LinkNode temp = head.next;\r\n        LinkNode newNode = new LinkNode(key, value);\r\n        head.next = newNode;\r\n        newNode.front = head;\r\n        newNode.next = temp;\r\n        temp.front = newNode;\r\n        map.put(key, newNode);\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\nTime: O(1)\r\nSpace: O(capacity)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1195807025","body":"# Idea\r\nå±‚åºéå†\r\n\r\n# Code\r\n```java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) return 0;\r\n        int depth = 0;\r\n        Queue<TreeNode> queue = new LinkedList<>();\r\n        queue.add(root);\r\n        while (!queue.isEmpty()) {\r\n            int level = queue.size();\r\n            depth++;\r\n            for (int i = 0; i < level; i++) {\r\n                TreeNode node = queue.poll();\r\n                if (node.left != null) {\r\n                    queue.add(node.left);\r\n                }\r\n                if (node.right != null) {\r\n                    queue.add(node.right);\r\n                }\r\n            }\r\n        }\r\n        return depth;\r\n    }\r\n}\r\n```\r\n# Complexity\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197139488","body":"# Idea\r\né€’å½’\r\n\r\n# Code\r\n``` java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null && q == null) {\r\n            return true;\r\n        }\r\n        if (p == null || q == null || p.val != q.val) {\r\n            return false;\r\n        }\r\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n```\r\n# Complexity\r\nTime: O(N)\r\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198604640","body":"# Idea\r\nè¿­ä»£å‰åºéå†\r\n\r\n# Code\r\n```java\r\nclass Solution {\r\n    public int sumNumbers(TreeNode root) {\r\n        int res = 0;\r\n        Stack<TreeNode> stack = new Stack<>();\r\n        stack.push(root);\r\n        while (!stack.isEmpty()) {\r\n            TreeNode node = stack.pop();\r\n            if (node.right != null) {\r\n                node.right.val = 10 * node.val + node.right.val;\r\n                stack.push(node.right);\r\n            }\r\n            if (node.left != null) {\r\n                node.left.val = 10 * node.val + node.left.val;\r\n                stack.push(node.left);\r\n            }\r\n            if (node.right == null && node.left == null) {\r\n                res += node.val;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n// é€’å½’\r\nclass Solution {\r\n    public int sumNumbers(TreeNode root) {\r\n      return helper(root, 0);\r\n    }\r\n    \r\n    private int helper(TreeNode root, int sum) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n        sum += root.val;\r\n        if (root.left == null && root.right == null) {\r\n            return sum;\r\n        }\r\n        return helper(root.left, 10 * sum) + helper(root.right, 10 * sum);\r\n    }\r\n}\r\n```\r\n# Complexity\r\nTime: O(N)\r\nSpace: O(h) hä¸ºæ ‘çš„é«˜åº¦","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200098082","body":"# Code\r\n```java\r\n// é€’å½’, dfså‰åºéå†(ååºï¼Œä¸­åºä¹Ÿéƒ½å¯ä»¥ï¼Œåªè¦ä¿è¯å·¦èŠ‚ç‚¹åœ¨å³èŠ‚ç‚¹ä¹‹å‰è¢«éå†)ã€‚ \r\n// åŸç†: æ¯æ¬¡æ›´æ·±çš„æ—¶å€™ï¼Œéƒ½æ˜¯å·¦èŠ‚ç‚¹çš„valè¢«è®°å½•ã€‚\r\nclass Solution {\r\n    int res = 0;\r\n    int maxDepth = 0;\r\n    public int findBottomLeftValue(TreeNode root) {\r\n        preorder(root, 1);\r\n        return res;\r\n    }\r\n    \r\n    public void preorder(TreeNode root, int depth) {\r\n        if (root == null) {\r\n            return;\r\n        }\r\n        if (root.left == null && root.right == null && depth  > maxDepth) {\r\n            maxDepth = depth;\r\n            res = root.val;\r\n        }\r\n        preorder(root.left, depth+1);\r\n        preorder(root.right, depth+1);\r\n    }\r\n}\r\n\r\n// BFS\r\nclass Solution {\r\n    public int findBottomLeftValue(TreeNode root) {\r\n        int res = 0;\r\n        Queue<TreeNode> queue = new LinkedList<>();\r\n        queue.add(root);\r\n        while (!queue.isEmpty()) {\r\n            int level = queue.size();\r\n            for (int i = 0; i < level; i++) {\r\n                TreeNode node = queue.poll();\r\n                if (i == 0) {\r\n                    res = node.val;\r\n                }\r\n                if (node.left != null) {\r\n                    queue.add(node.left);\r\n                }\r\n                if (node.right != null) {\r\n                    queue.add(node.right);\r\n                }\r\n            }\r\n            \r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\né€’å½’:\r\nTime: O(N)\r\nSpace: O(lgN)\r\n\r\nè¿­ä»£ï¼š\r\nTime: O(N)\r\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200272734","body":"# Code\r\n\r\n``` java\r\n// Â BFS\r\npublic class Codec {\r\n\r\n    // Encodes a tree to a single string.\r\n    public String serialize(TreeNode root) {\r\n        String res = \"\";\r\n        if (root == null) {\r\n            return res;\r\n        }\r\n        Queue<TreeNode> queue = new LinkedList<>();\r\n        queue.add(root);\r\n        while (!queue.isEmpty()) {\r\n            int level = queue.size();\r\n            for (int i = 0; i < level; i++) {\r\n                TreeNode node = queue.poll();\r\n                if (node == null) {\r\n                    res += \"n \";\r\n                    continue;\r\n                } \r\n                res += node.val + \" \";\r\n                queue.add(node.left);     \r\n                queue.add(node.right);          \r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    public TreeNode deserialize(String data) {\r\n        if (data.equals(\"\")) {\r\n            return null;\r\n        }\r\n        Queue<TreeNode> queue = new LinkedList<>();\r\n        String[] values = data.split(\" \");\r\n        TreeNode root = new TreeNode(Integer.parseInt(values[0]));\r\n        queue.add(root);\r\n        for (int i = 1; i < values.length; i++) {\r\n            TreeNode parent = queue.poll();\r\n            if (!values[i].equals(\"n\")) {\r\n                TreeNode left = new TreeNode(Integer.parseInt(values[i]));\r\n                parent.left = left;\r\n                queue.add(left);\r\n            }\r\n            if (!values[++i].equals(\"n\")) {\r\n                TreeNode right = new TreeNode(Integer.parseInt(values[i]));\r\n                parent.right = right;\r\n                queue.add(right);\r\n            }  \r\n        }\r\n        return root;\r\n    }\r\n}\r\n\r\n\r\n// DFS\r\npublic class Codec {\r\n    String res = \"\";\r\n\r\n    // Encodes a tree to a single string.\r\n    public String serialize(TreeNode root) {  \r\n        preorder(root);\r\n        return res;\r\n    }\r\n\r\n    private void preorder(TreeNode root) {\r\n        if (root == null) {\r\n            res += \"n \";\r\n            return;\r\n        }   \r\n        res += root.val + \" \";\r\n        preorder(root.left);\r\n        preorder(root.right);\r\n\r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    public TreeNode deserialize(String data) {\r\n        String[] values = data.split(\" \");\r\n        Queue<String> queue = new LinkedList<>(Arrays.asList(values));\r\n        return helper(queue);\r\n    }\r\n    \r\n    private TreeNode helper(Queue<String> queue) {\r\n        String s = queue.poll();\r\n        if (s.equals(\"n\")) return null;\r\n        TreeNode root = new TreeNode(Integer.parseInt(s));\r\n        root.left = helper(queue);\r\n        root.right = helper(queue);\r\n        return root;\r\n    }\r\n}\r\n\r\n```\r\n# Complexity\r\nTime: O(N)\r\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200506103","body":"# DFS\r\n``` java\r\nclass Solution {\r\n    class Node {\r\n        int val;\r\n        int row;\r\n\r\n        public Node(int val, int row) {\r\n            this.val = val;\r\n            this.row = row;\r\n        }\r\n    }\r\n\r\n    Map<Integer, List<Node>> map = new HashMap<>();\r\n    int min = Integer.MAX_VALUE;\r\n    int max = Integer.MIN_VALUE;\r\n\r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n        dfs(root, 0, 0);\r\n\r\n        List<List<Integer>> res = new LinkedList<>();\r\n        for (int i = min; i <= max; i++) {\r\n            List<Node> temp = map.get(i);\r\n            Collections.sort(temp, (a, b) -> {\r\n                if (a.row == b.row) {\r\n                    return a.val - b.val;\r\n                } else {\r\n                    return a.row - b.row;\r\n                }\r\n            });\r\n            List<Integer> values = new ArrayList<>();\r\n            for (Node n : temp) {\r\n                values.add(n.val);\r\n            }\r\n            res.add(values);\r\n        }\r\n        return res;\r\n    }\r\n    \r\n    private void dfs(TreeNode node, int col, int row) {\r\n        if (node == null) {\r\n            return;\r\n        }\r\n        min = Math.min(col, min);\r\n        max = Math.max(col, max);\r\n\r\n        List<Node> list = map.getOrDefault(col, new ArrayList<>());\r\n        list.add(new Node(node.val, row));\r\n        map.put(col, list);\r\n\r\n        dfs(node.left, col - 1, row + 1);\r\n        dfs(node.right, col + 1, row + 1);\r\n    }\r\n}\r\n```\r\n\r\n# BFS\r\n```java\r\nclass Solution {\r\n    class Group {\r\n        TreeNode node;\r\n        int row;\r\n        int col;\r\n\r\n        Group(TreeNode node, int row, int col) {\r\n            this.node = node;\r\n            this.row = row;\r\n            this.col = col;\r\n        }\r\n    }\r\n\r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n        List<List<Integer>> res = new LinkedList<>();\r\n        if (root == null) {\r\n            return res;\r\n        }\r\n        HashMap<Integer, List<Group>> colMap = new HashMap<>();\r\n        int minCol = Integer.MAX_VALUE;\r\n        int maxCol = Integer.MIN_VALUE;\r\n\r\n        Queue<Group> queue = new LinkedList<>();\r\n        queue.add(new Group(root, 0, 0));\r\n\r\n        while (!queue.isEmpty()) {\r\n            Group node = queue.poll();\r\n\r\n            int row = node.row;\r\n            int col = node.col;\r\n\r\n            minCol = Math.min(minCol, col);\r\n            maxCol = Math.max(maxCol, col);\r\n\r\n            if (node.node.left != null) {\r\n                queue.add(new Group(node.node.left, row + 1, col - 1));\r\n            }\r\n            if (node.node.right != null) {\r\n                queue.add(new Group(node.node.right, row + 1, col + 1));\r\n            }\r\n\r\n            if (colMap.containsKey(node.col)) {\r\n                colMap.get(node.col).add(node);\r\n            } else {\r\n                List<Group> list = new ArrayList<>();\r\n                list.add(node);\r\n                colMap.put(node.col, list);\r\n            }\r\n        }\r\n\r\n        for (int i = minCol; i <= maxCol; i++) {\r\n            List<Group> list = colMap.get(i);\r\n            Collections.sort(list, (a, b) -> {\r\n                if (a.row == b.row) {\r\n                    return a.node.val - b.node.val;\r\n                } else {\r\n                    return a.row - b.row;\r\n                }\r\n            });\r\n\r\n            List<Integer> values = new ArrayList<>();\r\n            for (Group g : list) {\r\n                values.add(g.node.val);\r\n            }\r\n            res.add(values);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n# Complexity\r\nTime: O(NlgN)\r\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201981463","body":"# Code\r\n```java\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int target) {\r\n        HashMap<Integer, Integer> map = new HashMap<>();\r\n        for (int i = 0; i < nums.length; i++) {\r\n            map.put(nums[i], i);\r\n        }\r\n        for (int i = 0; i < nums.length; i++) {\r\n            int difference = target - nums[i];\r\n            if (map.containsKey(difference) && map.get(difference) != i) {\r\n                return new int[]{i, map.get(difference)};\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203069606","body":"# Code\r\n```java\r\n\r\n// HashMap + Heap\r\n// Time: O(NlgK)\r\n// Space: O(N+K) \r\nclass Solution {\r\n    public int[] topKFrequent(int[] nums, int k) {\r\n        int[] result = new int[k];\r\n        HashMap<Integer, Integer> map = new HashMap<>();\r\n        for (int num : nums) {\r\n            map.put(num, map.getOrDefault(num, 0) + 1);\r\n        }\r\n\r\n        Queue<Integer> heap = new PriorityQueue<>((n1, n2) -> map.get(n1) - map.get(n2));\r\n\r\n        for (int n : map.keySet()) {\r\n            heap.add(n);\r\n            if (heap.size() > k)\r\n                heap.poll();\r\n        }\r\n        for (int i = 0; i < k; i++) {\r\n            result[i] = heap.poll();\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n// frequency as index, nums as value\r\n// Time: O(N)\r\n// Space: O(N)\r\nclass Solution {\r\n    public int[] topKFrequent(int[] nums, int k) {\r\n        ArrayList<Integer> res = new ArrayList<>();\r\n        HashMap<Integer, Integer> map = new HashMap<>();\r\n        for (int i = 0; i < nums.length; i++) {\r\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\r\n        }\r\n        List<Integer>[] list = new List[nums.length + 1];\r\n        for (int key : map.keySet()) {\r\n            if (list[map.get(key)] == null) {\r\n                list[map.get(key)] = new ArrayList<>();\r\n            }\r\n            list[map.get(key)].add(key);\r\n        }\r\n\r\n        for (int i = list.length - 1; i >= 0 && res.size() < k; i--) {\r\n            if (list[i] != null) {\r\n                for (int j = 0; j < list[i].size(); j++) {\r\n                    res.add(list[i].get(j));\r\n                }\r\n            }\r\n        }\r\n        return res.stream().mapToInt(i->i).toArray();\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204849729","body":"# Code\r\n```java\r\nclass Solution {\r\n    public int numberOfBoomerangs(int[][] points) {\r\n        int res = 0;\r\n        for (int i = 0; i < points.length; i++) {\r\n            HashMap<Integer, Integer> map = new HashMap<>();\r\n            for (int j = 0; j < points.length; j++) {\r\n                int dis = distance(points[i], points[j]);\r\n                map.put(dis, map.getOrDefault(dis, 0) + 1);\r\n            }\r\n            for (int dis : map.keySet()) {\r\n                res += map.get(dis) * (map.get(dis) - 1);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    \r\n    private int distance(int[] p1, int[] p2) {\r\n        int x1 = p1[0], x2 = p2[0];\r\n        int y1 = p1[1], y2 = p2[1];\r\n        return (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);\r\n    }\r\n}\r\n```\r\n# Complexity\r\nTime: O(n^2)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205579128","body":"# code\r\n```java\r\nclass Solution {\r\n    public int lengthOfLongestSubstring(String s) {\r\n        int left = 0, res = 0;\r\n        char[] ch = new char[128];\r\n        for (int right = 0; right < s.length(); right++) {\r\n            char r = s.charAt(right);\r\n            ch[r]++;\r\n            while (ch[r] > 1) {\r\n                char l = s.charAt(left);\r\n                ch[l]--;\r\n                left++;\r\n            }\r\n            res = Math.max(res, right - left + 1);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n# complexity\r\nTime: O(n)\r\nSpace: O(s)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207164310","body":"# Idea\r\næ»‘åŠ¨çª—å£+å“ˆå¸Œè¡¨\r\n# Code\r\n```java\r\nclass Solution {\r\n    public List<Integer> findSubstring(String s, String[] words) {\r\n        HashMap<String, Integer> count = new HashMap<>();\r\n        for (String word : words) {\r\n            count.put(word, count.getOrDefault(word, 0) + 1);\r\n        }\r\n        List<Integer> index = new ArrayList<>();\r\n        int n = s.length(), wordsCount = words.length, wordsLength = words[0].length();\r\n        for (int i = 0; i <= n - wordsCount * wordsLength; i++) {\r\n            HashMap<String, Integer> wordsSeen = new HashMap<>();\r\n            for (int j = 0; j < wordsCount; j++) {\r\n                int nextWordIndex = i + j * wordsLength;\r\n                String word = s.substring(nextWordIndex, nextWordIndex + wordsLength);\r\n                if (!count.containsKey(word)) {\r\n                    break;\r\n                }\r\n                wordsSeen.put(word, wordsSeen.getOrDefault(word, 0) + 1);\r\n                if (wordsSeen.get(word) > count.getOrDefault(word, 0)) {\r\n                    break;\r\n                }\r\n                if (j + 1 == wordsCount) {\r\n                    index.add(i);\r\n                }\r\n            }\r\n        }\r\n        return index;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207354806","body":"# code\r\n```java\r\nimport java.util.*;\r\n\r\nclass Solution {\r\n    public int solve(int[] nums, int k) {\r\n        int total = 0;\r\n        for (int n : nums) {\r\n            total += n;\r\n        }\r\n        int totalMod = Math.floorMod(total, k);\r\n\r\n        Map<Integer, Integer> map = new HashMap();\r\n        map.put(0, -1);\r\n        int prefix = 0;\r\n        int res = nums.length;\r\n        for (int i = 0; i < nums.length; i++) {\r\n            prefix += nums[i];\r\n            int curMod = Math.floorMod(prefix, k);\r\n            map.put(curMod, i);\r\n            int afterMod = Math.floorMod(prefix - totalMod, k);\r\n            // System.out.println(afterMod + \"total\" + totalMod +\"pre\" + prefix);\r\n            if (map.containsKey(afterMod)) {\r\n                int len = i - map.get(afterMod);\r\n                System.out.println(i);\r\n                res = len < res ? len : res;\r\n            }\r\n        }\r\n        return res == nums.length ? -1 : res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207727710","body":"# idea\r\nå¿«æ…¢æŒ‡é’ˆ\r\n# code\r\n```java\r\nclass Solution {\r\n    public ListNode middleNode(ListNode head) {\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        while (fast != null && fast.next != null) {\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n```\r\n# complexity\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208920369","body":"# code\r\n```java\r\nclass Solution {\r\n    public int removeDuplicates(int[] nums) {\r\n        int slow = 0;\r\n        for (int fast = 1; fast < nums.length; fast++) {\r\n            if (nums[fast] != nums[slow]) {\r\n                slow++;\r\n                nums[slow] = nums[fast];\r\n            }\r\n        }\r\n        return slow + 1;\r\n    }\r\n}\r\n```\r\n# complexity\r\nTime: O(N)\r\nSpace: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chjillout":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1188502616","body":"   ```\n public int[] shortestToChar(String S, char C) {\n        int n = S.length(), pos = -n, res[] = new int[n];\n        for (int i = 0; i < n; ++i) {\n            if (S.charAt(i) == C) pos = i;\n            res[i] = i - pos;\n        }\n        for (int i = pos - 1; i >= 0; --i) {\n            if (S.charAt(i) == C)  pos = i;\n            res[i] = Math.min(res[i], pos - i);\n        }\n        return res;\n    } \n```\n\nComplexity O(n)","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188497313","body":"class MyQueue {\n\n    Stack<Integer> input = new Stack();\n    Stack<Integer> output = new Stack();\n    \n    public void push(int x) {\n        input.push(x);\n    }\n\n    public void pop() {\n        peek();\n        output.pop();\n    }\n\n    public int peek() {\n        if (output.empty())\n            while (!input.empty())\n                output.push(input.pop());\n        return output.peek();\n    }\n\n    public boolean empty() {\n        return input.empty() && output.empty();\n    }\n}\n\n#### Complexity O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wenjialu":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188506954","body":"\n# æ€è·¯ï¼š\n put 1 2 3, get 1\n\n method1: 9:36 - 42 = 6min\n\n stack [\n sec_stack [3 2 \n put it back to stack1.\n\n time: O(n); space O(n)\n\n\nmethod2:  43 - 45 = 2min\n push: all ele to stack2, append. put it back to stack1.\nstack [3 2 1\nsec_stack [\n\n\né€‰method1 or method2ï¼Œ çœ‹å“ªç§æ“ä½œæ›´é¢‘ç¹ã€‚ æ’å…¥é¢‘ç¹ ï¼ˆm1ï¼‰ or æŸ¥æ‰¾ï¼ˆm2ï¼‰ã€‚\n```\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.stack1.append(x)\n\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        while self.stack1:\n            self.stack2.append(self.stack1.pop() )\n        num = self.stack2.pop()\n        while self.stack2:\n            self.stack1.append( self.stack2.pop() )\n        return num\n\n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        while self.stack1:\n            self.stack2.append(self.stack1.pop() )\n        num = self.stack2[-1]\n        while self.stack2:\n            self.stack1.append( self.stack2.pop() )\n        return num\n\n\n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return len(self.stack1) == 0\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190767492","body":"\n# thought\n4:41 - 59 = 20min\n\næ³•1:m = k mod len(linkedlist) find last m - 1, m-1 point to None, make m point to head\næ³•2æ”¹è¿›ï¼šæ—¢ç„¶éƒ½ç®—å‡ºé“¾è¡¨é•¿åº¦äº†å°±ä¸è¦æ‰¾å€’æ•°çš„èŠ‚ç‚¹äº†ï¼Œç›´æ¥çŸ¥é“æ˜¯ç¬¬å‡ ä¸ªèŠ‚ç‚¹äº†ï¼š\n len = 5 k=2 m = 2 æ–­ç‚¹ï¼šlen-m-1=2\n len = 3 k=4 m =1 æ–­ç‚¹ï¼šlen-m-1=\n\n\n # complexity\nO(n) space O(1)\n\n# code\n```      \n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        pointer = head\n        length = 1\n        while pointer and pointer.next: # pointer point to last node\n            pointer = pointer.next\n            length += 1\n        if length == 0:\n            return head\n        m = k % length \n\n        if m == 0:\n            return head\n        # fa2ï¼šæ–­ç‚¹ï¼šlen-m-1=2\n        slow = head\n        for i in range(length - m - 1):\n            slow = slow.next\n        last = slow\n        next_ll = slow.next\n        slow.next = None\n        #pointer is last node\n        pointer.next = head\n        return next_ll\n\n        \n        # fa1 : æ‰¾å€’æ•°m-1 node\n        # slow, fast = head, head\n        # pre = ListNode(-1)\n        # for i in range(m + 1):\n        #     pre = fast\n        #     fast = fast.next\n        # while fast:\n        #     pre = fast\n        #     slow = slow.next\n        #     fast = fast.next \n        # next_ll = slow.next\n        # slow.next = None \n        # pre.next = head\n        # return next_ll\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1191984842","body":"\n\n\n# thought \nMethod1 : recursion\n  # recusion: change first 2, head.next = recursion.\n\n        #  1 2 3 4\n        #. s\n        #.   f head\n\nMethod2: \n\n# complexity\n time: O(n) spaceO(n)\n\n\n# code\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        # 03-04 reading\n        # 04-06 thought\n        # 06-07 coding = 4min\n\n      \n        # time: O(n) spaceO(n)\n        if not head or not head.next:\n            return head \n        \n        slow, fast = head, head.next \n        next_head = fast.next \n        fast.next = slow \n        slow.next = self.swapPairs(next_head)\n        return fast\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193234517","body":"\n\n# thought\n 23 - 31 thought = 9 min\n        31 - 34 coding = 3\n        34 -40 test case \n         total: 17\n         clarifation: no insertion, return null. must have one node for each linkedlist.\n\n         high level:\n         p1: start from  a + c(until the end) + b\n         same time p2: start from b + c(until the end) + start from the head of the other linkedlist a \n         if they have intersection, they would meet!!!! p1=p2=intersection\n\n        a + b , b + a.\n          if they have no intersection, would reach the None node. p1=p2=None\n\n         speacial case:  \n\n         p1 1 9 1 2 4 3 2\n         p2 3 2 4 1 9 1 2\n\n\n# complexity\ntime: O\n(n) space O(1)\n\n\n# code\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n       \n        p1, p2 = headA, headB \n        while p1 != p2:\n            p1 = p1.next if p1 != None else headB\n            p2 = p2.next if p2 != None else headA \n        return p1 # if p1 != None else None\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196220207","body":"\n #  thought\nå±‚å±‚è¿”å›æ¯ä¸ªå­æ ‘çš„max depthï¼› ç­‰é€’å½’å®Œäº†ï¼Œ è¿”å›å¯¹äºæ•´ä¸ªæ ‘çš„rootçš„max depthã€‚\n\n# \ntime: O(n) n: num of nodes\nSpace: O(h) h: height of tree\n\n# code\n```\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n    return max(self.maxDepth( root.left), self.maxDepth( root.right) ) + 1\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mhcn":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188512612","body":"### idea\r\nä¸€å…±4ç§æƒ…å†µï¼šå­—ç¬¦ã€æ•°å­—ã€[,]\r\nå‡ºç°å¤šä½æ•°å­—å­—ç¬¦ï¼Œå°†å…¶è½¬åŒ–ä¸ºä¸€ä¸ªæ•°\r\nç„¶ååˆ©ç”¨è¾…åŠ©æ ˆä»å†…åˆ°å¤–å±•å¼€\r\n### code\r\n```java\r\n    public String decodeString(String s){\r\n        LinkedList<String> strStack = new LinkedList<>();\r\n        LinkedList<Integer> numStack = new LinkedList<>();\r\n\r\n         int times = 0;\r\n        StringBuilder sb = new StringBuilder();\r\n\r\n        final char[] chars = s.toCharArray();\r\n        for (int i=0; i< chars.length; i++){\r\n            if (Character.isLetter(chars[i])){\r\n                sb.append(chars[i]);\r\n            }else if (Character.isDigit(chars[i])){\r\n                times = times * 10 + chars[i] - '0';\r\n            }else if (chars[i] == '['){\r\n                numStack.addLast(times);\r\n                strStack.addLast(sb.toString());\r\n                times = 0;\r\n                sb = new StringBuilder();\r\n            }else if (chars[i] == ']'){\r\n                 StringBuilder temp = new StringBuilder();\r\n                 Integer multi = numStack.removeLast();\r\n                for (int j=0; j< multi; j++){\r\n                     temp.append(sb);\r\n                 }\r\n                sb = new StringBuilder(strStack.removeLast() + temp);\r\n            }\r\n\r\n        }\r\n        return sb.toString();\r\n    }\r\n```\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192626933","body":"/**\r\n * Definition for singly-linked list.\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next == null){\r\n            return head;\r\n        }\r\nListNode next = head.next;\r\nhead.next = swapPairs(next.next);\r\nnext.next = head;\r\nreturn next;\r\n    }\r\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194152558","body":"```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode fast;\r\n        ListNode slow;\r\n        fast = slow = head;\r\n        while ((fast != null) && (fast.next != null)) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n            if (fast == slow) {\r\n                fast = head;\r\n                while (slow != fast) {\r\n                    fast = fast.next;\r\n                    slow = slow.next;\r\n                }\r\n                return slow;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198179538","body":"```java\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n          if(p == null && q == null) return true;\n          if (p == null || q == null) return false;\n          if (p.val != q.val) return false;\n          return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n```","onTime":true},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206444078","body":"```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int result = 0;\n        int left=0,right=0;\n        Map<Character, Integer> map = new HashMap<>();\n        while(right < s.length()){\n            char c = s.charAt(right);\n            right++;\n            map.put(c, map.getOrDefault(c,0) + 1);\n            while(map.get(c) > 1){\n                char d = s.charAt(left);\n                left++;\n                map.put(d, map.getOrDefault(d,0) - 1);\n            }\n            result = Math.max(result, right - left);\n        }\n        return result;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"coconutice":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188517276","body":"## æ€è·¯\r\nä¸€ä¸ªstackç”¨äºå…¥æ ˆ\r\nå¦å¤–ä¸€ä¸ªç”¨äºå‡ºæ ˆ\r\n\r\n## ä»£ç \r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.ins = []\r\n        self.outs = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.ins.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.outs:\r\n            while self.ins:\r\n                self.outs.append(self.ins.pop())\r\n        return self.outs.pop()\r\n\r\n    def peek(self) -> int:\r\n        if not self.outs:\r\n            while self.ins:\r\n                self.outs.append(self.ins.pop())\r\n        return self.outs[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        if self.outs or self.ins:\r\n            return False\r\n        else:\r\n            return True\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190997715","body":"\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        l = []\r\n        t = ListNode(0, head)\r\n        p = head\r\n        while p:\r\n            l.append(p.val)\r\n            p = p.next\r\n        if not l:\r\n            return head\r\n        stop = len(l) -  k % len(l)\r\n        if stop == len(l):\r\n            return head\r\n        count = 0\r\n        p = head\r\n        while count < stop -  1 and p:\r\n        \r\n            p = p.next\r\n            count += 1    \r\n        temp1 = p\r\n        while p and p.next:\r\n            p = p.next       \r\n        t.next = temp1.next\r\n        p.next = head\r\n        temp1.next = None\r\n        return t.next\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192045185","body":"class Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        t = ListNode(0, head)\r\n        curr = head\r\n        pre = t\r\n        while curr and curr.next:\r\n            temp = curr.next\r\n            curr.next = curr.next.next\r\n            pre.next = temp\r\n            temp.next = curr\r\n            pre = curr\r\n            curr = curr.next\r\n        return t.next","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193248591","body":"    def getIntersectionNode(self, headA, headB):\r\n        \"\"\"\r\n        :type head1, head1: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        a, b = headA, headB\r\n        while a and b: \r\n            if a == b: return a \r\n            a = a.next \r\n            b = b.next\r\n            if a is None and b is None: \r\n                return None \r\n            if a is None: \r\n                a = headB\r\n            if b is None: \r\n                b = headA","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197643617","body":"def isSameTree(self, p, q):\r\n        def tra(p_r, q_r, tag):\r\n            if not p_r and not q_r:\r\n                return tag\r\n            if not p_r or not q_r:\r\n                tag = 1\r\n                return tag\r\n            if p_r.val != q_r.val:\r\n                tag = 1\r\n                return tag\r\n            a =tra(p_r.left, q_r.left, tag)\r\n            b =tra(p_r.right, q_r.right, tag)\r\n            return a or b\r\n        tag = 0\r\n        a = tra(p, q, 0)\r\n        if a == 0:\r\n            return True\r\n        else:\r\n            return False\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198851423","body":"    def sumNumbers(self, root):\r\n        \"\"\"\r\n        :type root: TreeNode\r\n        :rtype: int\r\n        \"\"\"\r\n        def s(r, i):\r\n            if not r:\r\n                return 0\r\n            temp = i * 10 + r.val\r\n            if not r.left and not r.right:\r\n                return temp\r\n            return s(r.left, temp) + s(r.right, temp)\r\n        return s(root, 0)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201961111","body":"class Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        d = {}\r\n        for i in range(len(nums)):\r\n            if target - nums[i] in d:\r\n                return [i, d[target - nums[i]]]\r\n            else:\r\n                d[nums[i]] = i\r\n        return []  ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jackgaoyuan":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188540304","body":"type MyQueue struct {\r\n\tinStack, outStack []int\r\n}\r\n\r\nfunc Constructor() MyQueue {\r\n\treturn MyQueue{}\r\n}\r\n\r\nfunc (this *MyQueue) Push(x int) {\r\n\tthis.inStack = append(this.inStack, x)\r\n}\r\n\r\nfunc (this *MyQueue) in2Out() {\r\n\t//å°†å…¥æ ˆçš„å…ƒç´ å€’è¿›å‡ºæ ˆ\r\n\tfor i := len(this.inStack) - 1; i >= 0; i-- {\r\n\t\tthis.outStack = append(this.outStack, this.inStack[i])\r\n\t}\r\n    this.inStack = nil\r\n}\r\n\r\n//ä»é˜Ÿåˆ—çš„å¼€å¤´ç§»é™¤å¹¶è¿”å›å…ƒç´ \r\nfunc (this *MyQueue) Pop() int {\r\n\tif len(this.outStack) == 0 {\r\n\t\tthis.in2Out()\r\n\t}\r\n    //è·å–æ ˆå¤´å…ƒç´ ï¼ˆåˆ‡ç‰‡æœ€åçš„å…ƒç´ ï¼‰\r\n\tres := this.outStack[len(this.outStack)-1]\r\n    //ç§»é™¤æ ˆå¤´å…ƒç´ \r\n\tthis.outStack = this.outStack[:len(this.outStack) - 1]\r\n\treturn res\r\n}\r\n\r\n// è¿”å›é˜Ÿåˆ—å¼€å¤´çš„å…ƒç´ \r\nfunc (this *MyQueue) Peek() int {\r\n\tif len(this.outStack) == 0 {\r\n\t\tthis.in2Out()\r\n\t}\r\n\treturn this.outStack[len(this.outStack)-1]\r\n}\r\n\r\nfunc (this *MyQueue) Empty() bool {\r\n\treturn len(this.inStack) == 0 && len(this.outStack) == 0\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190041412","body":"func maxChunksToSorted(arr []int) int {\r\n    // æ’åºåï¼Œå¯¹ä¸¤ä¸ªæ•°ç»„è¿›è¡Œdiffï¼Œåç§»é‡ä¸º0æ—¶ï¼Œè¡¨ç¤ºå¯ä»¥åˆ†å—\r\n\tb := append([]int{}, arr...)\r\n\tsort.Ints(b)\r\n\r\n\tret := 0\r\n\tdiff := 0\r\n\tm := map[int]int{}\r\n\tfor i := 0; i < len(arr); i++ {\r\n\t\tm[b[i]]++\r\n\t\tif m[b[i]] > 0 { //è¯¥æ•°æ‹‰å¼€äº†ä¸¤ä¸ªæ•°ç»„çš„å·®è·ï¼Œæ­£å‘åç§»ï¼ˆåå‘bæ•°ç»„ï¼‰\r\n\t\t\tdiff++\r\n\t\t} else { // æŠµæ¶ˆäº†arræ•°ç»„çš„åç§»\r\n\t\t\tdiff--\r\n\t\t}\r\n\r\n\t\tm[arr[i]]--\r\n\t\tif m[arr[i]] < 0 { //è¯¥æ•°æ‹‰å¼€äº†ä¸¤ä¸ªæ•°ç»„çš„å·®è·ï¼Œè´Ÿå‘åç§»ï¼ˆåå‘arræ•°ç»„ï¼‰\r\n\t\t\tdiff++\r\n\t\t} else { // æŠµæ¶ˆäº†bæ•°ç»„çš„åç§»\r\n\t\t\tdiff--\r\n\t\t}\r\n\r\n\t\tif diff == 0 {\r\n\t\t\tret++\r\n\t\t}\r\n\t}\r\n\treturn ret\r\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192459453","body":"func swapPairs(head *ListNode) *ListNode {\r\n    if head == nil || head.Next == nil{\r\n        return head\r\n    }\r\n    cur, next :=  head, head.Next\r\n    var pre *ListNode\r\n    for i:=0;i<2;i++{\r\n        cur.Next = pre\r\n        pre = cur\r\n        cur = next\r\n        if next != nil{\r\n            next = next.Next\r\n        }\r\n    }\r\n    head.Next = swapPairs(cur)\r\n    return pre\r\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193845003","body":"func detectCycle(head *ListNode) *ListNode {\r\n    if (head == nil) {\r\n\t\treturn nil\r\n\t}\r\n\tfast := head\r\n\tslow := head\r\n\tfor {\r\n\t\tif (fast.Next == nil || fast.Next.Next == nil || slow.Next == nil) {\r\n\t\t\treturn nil\r\n\t\t}\r\n\t\tfast = fast.Next.Next\r\n\t\tslow = slow.Next\r\n\t\tif (fast == slow) {\r\n\t\t\tfast = head\r\n\t\t\tbreak\r\n\t\t}\r\n\t}\r\n\tfor fast != slow {\r\n\t\tfast, slow = fast.Next, slow.Next\r\n\t}\r\n\treturn fast\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195186132","body":"/*\r\ntype LRUCache struct {\r\n    head: åŒå‘é“¾è¡¨headï¼Œè®°å½•cacheä¸­nodeé¡ºåºï¼Œç”¨ä½œæ·˜æ±°æ ‡å‡†\r\n    tail\r\n    nodeMap: hashmapï¼škeyä¸ºnodeçš„keyï¼Œvalueä¸ºæŒ‡å‘åŒå‘é“¾è¡¨ä¸­nodeçš„æŒ‡é’ˆï¼Œç”¨ä½œo(1)æ—¶é—´è®¿é—®node\r\n    cap: å®¹é‡\r\n    count: ç°æœ‰nodeæ•°é‡\r\n}\r\n\r\nfunc put(k, v) {\r\n    node = Node{k, v}\r\n    if kåœ¨nodeMapä¸­å›½ {\r\n        æ›´æ–°node valueå€¼\r\n        å°†nodeç§»åˆ°æœ€å‰é¢\r\n    } else { // kä¸åœ¨nodeMapä¸­ï¼Œæ„å‘³ç€cacheä¸­æ²¡æœ‰è¿™ä¸ªk\r\n        å°†nodeæ’å…¥åˆ°æœ€å‰é¢\r\n        å°†nodeæ–°å¢åˆ°nodeMap\r\n        count++\r\n        if count > capacity { // è¶…å‡ºå®¹é‡\r\n            ä¸¢å¼ƒæœ€åä¸€ä¸ªå…ƒç´ ï¼ŒtailæŒ‡å‘å€’æ•°ç¬¬äºŒä¸ªå…ƒç´ \r\n            ä»nodeMapä¸­åˆ é™¤å€’æ•°ç¬¬äºŒä¸ªå…ƒç´ \r\n            count --\r\n        }\r\n    }\r\n}\r\n\r\nfunc get(k, v) {\r\n    p = nodeMap[k]\r\n    if p == nil {\r\n        return nil\r\n    }\r\n    return p.Value\r\n}\r\n*/\r\n\r\ntype Node struct {\r\n\tKey   int\r\n\tValue int\r\n\tPrev  *Node\r\n\tNext  *Node\r\n}\r\ntype LRUCache struct {\r\n\tHead    *Node\r\n\tTail    *Node\r\n\tNodeMap map[int]*Node\r\n\tCap     int\r\n\tCount   int\r\n}\r\n\r\nfunc Constructor(capacity int) LRUCache {\r\n\thead := Node{}\r\n\ttail := Node{}\r\n\thead.Next = &tail\r\n\ttail.Prev = &head\r\n\tm := make(map[int]*Node)\r\n\tlru := LRUCache{Head: &head, Tail: &tail, NodeMap: m, Cap: capacity, Count: 0}\r\n\treturn lru\r\n}\r\n\r\nfunc (this *LRUCache) Get(key int) int {\r\n\tnode, ok := this.NodeMap[key]\r\n\tif !ok {\r\n\t\treturn -1\r\n\t}\r\n\tif node.Prev != this.Head { // å¦‚æœä¸æ˜¯ç¬¬ä¸€ä¸ªï¼Œåˆ™ç§»åŠ¨åˆ°å¤´éƒ¨\r\n\t\t// å°†nodeä»é“¾è¡¨ä¸­ç§»é™¤\r\n\t\tnode.Prev.Next, node.Next.Prev = node.Next, node.Prev\r\n\t\t// å°†nodeæ·»åŠ åˆ°å¤´éƒ¨\r\n\t\tfirstNode := this.Head.Next\r\n\t\tnode.Prev, node.Next = this.Head, firstNode\r\n\t\tthis.Head.Next, firstNode.Prev = node, node\r\n\t}\r\n\treturn node.Value\r\n}\r\n\r\nfunc (this *LRUCache) Put(key int, value int) {\r\n\tif node, ok := this.NodeMap[key]; ok { // keyåœ¨mapä¸­\r\n\t\tnode.Value = value          // æ›´æ–°node value\r\n\t\tif node.Prev == this.Head { // å¦‚æœå·²ç»æ˜¯ç¬¬ä¸€ä¸ªäº†ï¼Œç›´æ¥è¿”å›\r\n\t\t\treturn\r\n\t\t}\r\n\t\t// å°†nodeä»é“¾è¡¨ä¸­ç§»é™¤\r\n\t\tnode.Prev.Next, node.Next.Prev = node.Next, node.Prev\r\n\t\t// å°†nodeæ·»åŠ åˆ°å¤´éƒ¨\r\n\t\tfirstNode := this.Head.Next\r\n\t\tnode.Prev, node.Next = this.Head, firstNode\r\n\t\tthis.Head.Next, firstNode.Prev = node, node\r\n\t} else { // keyä¸åœ¨mapä¸­\r\n\t\tnewNode := Node{Key: key, Value: value}\r\n\t\tthis.NodeMap[key] = &newNode\r\n\t\t// å°†æ–°nodeæ·»åŠ è¿›å¤´éƒ¨\r\n\t\tfirstNode := this.Head.Next\r\n\t\tnewNode.Prev, newNode.Next = this.Head, firstNode\r\n\t\tthis.Head.Next, firstNode.Prev = &newNode, &newNode\r\n\t\tthis.Count += 1\r\n\t\tif this.Count > this.Cap {\r\n\t\t\tlastNode := this.Tail.Prev\r\n\t\t\tlastNode.Prev.Next, this.Tail.Prev = this.Tail, lastNode.Prev\r\n\t\t\tdelete(this.NodeMap, lastNode.Key)\r\n\t\t\tthis.Count -= 1\r\n\t\t}\r\n\t}\r\n}\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196230655","body":"func traverseTree(node *TreeNode, currentDeep int, maxDeepth *int) {\r\n    if node == nil {\r\n\t\treturn\r\n\t}\r\n\tif currentDeep > *maxDeepth {\r\n\t\t*maxDeepth = currentDeep\r\n\t}\r\n\tif node.Left != nil {\r\n\t\ttraverseTree(node.Left, currentDeep+1, maxDeepth)\r\n\t}\r\n\tif node.Right != nil {\r\n\t\ttraverseTree(node.Right, currentDeep+1, maxDeepth)\r\n\t}\r\n\treturn\r\n}\r\n\r\nfunc maxDepth(root *TreeNode) int {\r\n\tvar maxDeepth int\r\n\ttraverseTree(root, 1, &maxDeepth)\r\n\treturn maxDeepth\r\n}","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200352239","body":"type Codec struct {\r\n    null int\r\n}\r\n\r\nfunc Constructor() Codec {\r\n    return Codec{null: math.MinInt64}\r\n}\r\n\r\nfunc (c *Codec) serialize(root *TreeNode) string {\r\n    if root == nil {\r\n        return ``\r\n    }\r\n    s := make([]int, 0)\r\n    q := []*TreeNode{root}\r\n    for len(q) > 0 {\r\n        v := q[0]\r\n        q = q[1:]\r\n\r\n        if v == nil {\r\n            s = append(s, c.null)\r\n        } else {\r\n            s = append(s, v.Val)\r\n            q = append(q, v.Left, v.Right)\r\n        }\r\n    }\r\n    return c.serializeSlice(s)\r\n}\r\n\r\nfunc (c *Codec) deserialize(data string) *TreeNode {\r\n    if len(data) == 0 {\r\n        return nil\r\n    }\r\n\r\n    vs := c.deserializeSlice(data)\r\n    n := len(vs)\r\n    root := &TreeNode{Val: vs[0]}\r\n    i := 1\r\n    q := []*TreeNode{root}\r\n    for len(q) > 0 {\r\n        v := q[0]\r\n        q = q[1:]\r\n        for j := 0; j < 2; j++ {\r\n            var newNode *TreeNode\r\n            if i < n && vs[i] != c.null {\r\n                newNode = &TreeNode{Val: vs[i]}\r\n                q = append(q, newNode)\r\n            }\r\n            if j&1 == 0 {\r\n                v.Left = newNode\r\n            } else {\r\n                v.Right = newNode\r\n            }\r\n            i++\r\n        }\r\n    }\r\n    return root\r\n}\r\n\r\nfunc (c *Codec) serializeSlice(s []int) string {\r\n    n := len(s)\r\n    var sb strings.Builder\r\n    for i := 0; i < n; i++ {\r\n        if i > 0 {\r\n            sb.WriteByte(',')\r\n        }\r\n        sb.WriteString(strconv.Itoa(s[i]))\r\n    }\r\n    return sb.String()\r\n}\r\n\r\nfunc (c *Codec) deserializeSlice(data string) []int {\r\n    splits := strings.Split(data, `,`)\r\n    s := make([]int, 0, len(splits))\r\n    for _, split := range splits {\r\n        v, _ := strconv.Atoi(split)\r\n        s = append(s, v)\r\n    }\r\n    return s\r\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202068809","body":"func TwoSum(nums []int, target int) []int {\r\n\tm := make(map[int]int)\r\n\tres := []int{}\r\n\tfor idx, val := range nums {\r\n\t\tv, ok := m[target-val]\r\n\t\tif ok {\r\n\t\t\tres = append(res, v, idx)\r\n\t\t\tbreak\r\n\t\t}\r\n\t\tm[val] = idx\r\n\t}\r\n\treturn res\r\n}\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203913218","body":"func topKFrequent(nums []int, k int) []int {\r\n    occurrences := map[int]int{}\r\n    for _, num := range nums {\r\n        occurrences[num]++\r\n    }\r\n    h := &IHeap{}\r\n    heap.Init(h)\r\n    for key, value := range occurrences {\r\n        heap.Push(h, [2]int{key, value})\r\n        if h.Len() > k {\r\n            heap.Pop(h)\r\n        }\r\n    }\r\n    ret := make([]int, k)\r\n    for i := 0; i < k; i++ {\r\n        ret[k - i - 1] = heap.Pop(h).([2]int)[0]\r\n    }\r\n    return ret\r\n}\r\n\r\ntype IHeap [][2]int\r\n\r\nfunc (h IHeap) Len() int           { return len(h) }\r\nfunc (h IHeap) Less(i, j int) bool { return h[i][1] < h[j][1] }\r\nfunc (h IHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\r\n\r\nfunc (h *IHeap) Push(x interface{}) {\r\n    *h = append(*h, x.([2]int))\r\n}\r\n\r\nfunc (h *IHeap) Pop() interface{} {\r\n    old := *h\r\n    n := len(old)\r\n    x := old[n-1]\r\n    *h = old[0 : n-1]\r\n    return x\r\n}","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207671942","body":"func middleNode(head *ListNode) *ListNode {\r\n    slow := head\r\n    fast := head\r\n    for fast != nil && fast.Next != nil {\r\n        slow = slow.Next\r\n        fast = fast.Next.Next\r\n    }\r\n    return slow\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208879453","body":"func removeDuplicates(nums []int) int {\r\n    i := 0\r\n    for j := 1; j < len(nums); j++ {\r\n        if nums[j] != nums[i] {\r\n            i++\r\n            nums[i] = nums[j]\r\n        }\r\n    }\r\n    return i + 1\r\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhan0312":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188696765","body":"# ****ã€Day 5ã€‘232. ç”¨æ ˆå®ç°é˜Ÿåˆ—****\n\n## æ€è·¯ï¼š\n\n1. ç”±äºJsé‡Œæ²¡æœ‰stack ç±»å‹ï¼Œå…ˆæ„å»ºä¸€ä¸ªåŒ…å«å¿…è¦åŠŸèƒ½çš„stackç±»\n2. ç”¨ä¸¤ä¸ªstackæ¥æ¨¡æ‹Ÿå…ˆè¿›å…ˆå‡º\n3. è¿™é‡Œé€‰æ‹©åœ¨pushæ—¶ç»´æŠ¤ç¬¬ä¸€ä¸ªstackï¼Œåˆ©ç”¨ç¬¬äºŒä¸ªstackæ¥reverseé‡Œé¢çš„å…ƒç´ é¡ºåºï¼Œäºæ˜¯popå’Œpeekæ—¶å–çš„æ˜¯æœ€å…ˆå­˜æ”¾çš„å…ƒç´ \n\n## ä»£ç \n\n```jsx\nclass Stack {\n    constructor() {\n        this.stack = [];\n    }    \n    \n    push = (x) => {\n        this.stack.push(x);\n    }\n    \n    pop = () => {\n        return this.stack.pop();\n    }\n    \n    size = () => {\n        return this.stack.length;\n    }\n    \n    peek = () => {\n        return this.stack[this.stack.length - 1];\n    }\n}\n\nclass MyQueue {\n    constructor() {\n        this.stack1 = new Stack();\n        this.stack2 = new Stack();    \n    }\n    \n    push = (x) => {\n        while (this.stack1.size() > 0) {\n            const item = this.stack1.pop();\n            this.stack2.push(item);\n        }\n\n        this.stack2.push(x);\n\n        while (this.stack2.size() > 0) {\n            const item = this.stack2.pop();\n            this.stack1.push(item);\n        }\n    }\n    \n    peek = () => {\n        return this.stack1.peek();   \n    }\n    \n    pop = () => {\n        return this.stack1.pop();\n    }\n    \n    empty = () => {\n        return this.stack1.size() === 0;\n    }\n}\n```\n\n## å¤æ‚åº¦åˆ†æ\n\nTime Complexity: O(n) when pushing, O(1) when others\n\nSpace Complexity: O(n) when pushing, O(1) when others","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yufeng727":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188920030","body":"var MyQueue = function() {\n  this.is = [];\n  this.os = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  this.is.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  if (!this.os.length) {\n    while (this.is.length) {\n      this.os.push(this.is.pop());\n    }\n  }\n  return this.os.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  if (!this.os.length) {\n    while (this.is.length) {\n      this.os.push(this.is.pop());\n    }\n  }\n  return this.os[this.os.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return !this.is.length && !this.os.length;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */","onTime":true},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196418624","body":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    if (!root) {\n        return 0\n    }\n    var left = maxDepth(root.left);\n    var right = maxDepth(root.right);\n    return Math.max(left, right) + 1;\n};\n","onTime":true},null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207203458","body":"var findSubstring = function(s, words) {\n    const res = [];\n    const m = words.length, n = words[0].length, ls = s.length;\n    for (let i = 0; i < n; i++) {\n        if (i + m * n > ls) {\n            break;\n        }\n        const differ = new Map();\n        for (let j = 0; j < m; j++) {\n            const word = s.substring(i + j * n, i + (j + 1) * n);\n            differ.set(word, (differ.get(word) || 0) + 1);\n        }\n        for (const word of words) {\n            differ.set(word, (differ.get(word) || 0) - 1);\n            if (differ.get(word) === 0) {\n                differ.delete(word);\n            }\n        }\n        for (let start = i; start < ls - m * n + 1; start += n) {\n            if (start !== i) {\n                let word = s.substring(start + (m - 1) * n, start + m * n);\n                differ.set(word, (differ.get(word) || 0) + 1);\n                if (differ.get(word) === 0) {\n                    differ.delete(word);\n                }\n                word = s.substring(start - n, start);\n                differ.set(word, (differ.get(word) || 0) - 1);\n                if (differ.get(word) === 0) {\n                    differ.delete(word);\n                }\n            }\n            if (differ.size === 0) {\n                res.push(start);\n            }\n        }\n    }\n    return res;\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fontendart":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189039042","body":"ä¿æ‰“å¡\n```javascript\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function () {\n    this.stack1 = []\n    this.stack2 = []\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n    let stack = this.stack1.length? this.stack1: this.stack2\n    stack.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n    let stack1, stack2, value;\n    if (this.stack1.length) {\n        stack1 = this.stack1\n        stack2 = this.stack2\n    } else {\n        stack1 = this.stack2\n        stack2 = this.stack1\n    }\n    while (value = stack1.pop()) {\n        stack2.push(value)\n    }\n    let res = stack2.pop()\n\n    while (value = stack2.pop()) {\n        stack1.push(value)\n    }\n\n    return res\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n    let stack1, stack2, value;\n    if (this.stack1.length) {\n        stack1 = this.stack1\n        stack2 = this.stack2\n    } else {\n        stack1 = this.stack2\n        stack2 = this.stack1\n    }\n    while (value = stack1.pop()) {\n        stack2.push(value)\n    }\n\n    let res = stack2.pop()\n    stack1.push(res);\n    while (value = stack2.pop()) {\n        stack1.push(value)\n    }\n    return res;\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n    // console.log(this.stack1, this.stack2)\n    return !this.stack1.length && !this.stack2.length\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yingchehu":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189180981","body":"### æ€è·¯\r\n* ä¸€å€‹ stack è£ååºçš„æ•¸å­— (æœ€æ–°çš„åœ¨æœ€ä¸Šå±¤)ï¼Œåœ¨ push æ™‚ä½¿ç”¨å¦ä¸€å€‹ help_stack ä¾†ä¿æŒ stack è£¡çš„æ•¸å­—ç‚ºååº\r\n* pop è·Ÿ peek å‰‡å–æœ€ä¸Šå±¤çš„æ•¸å­—\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack = []\r\n        self.help_stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        # å…ˆå°‡ stack å…§çš„éƒ½æ•¸å­—æ¬åˆ° help_stack\r\n        while len(self.stack) > 0:\r\n            num = self.stack.pop()\r\n            self.help_stack.append(num)\r\n        # å°‡æ–°æ•¸å­—æ”¾å…¥ stack\r\n        self.stack.append(x)\r\n        # æ¥è‘—æŠŠæ•¸å­—å¾ help_stack æ¬å› stack\r\n        while len(self.help_stack) > 0:\r\n            num = self.help_stack.pop()\r\n            self.stack.append(num)\r\n\r\n    def pop(self) -> int:\r\n        return self.stack.pop()\r\n        \r\n\r\n    def peek(self) -> int:\r\n        return self.stack[-1]\r\n        \r\n\r\n    def empty(self) -> bool:\r\n        return len(self.stack) == 0\r\n```\r\n\r\nTime Complexity: O(N)\r\nSpace Complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190380648","body":"```python\n# å°‡ sub array èˆ‡ sub sorted array æ¯”å°æ•¸å­—å‡ºç¾çš„æ¬¡æ•¸\n# æ¬¡æ•¸éƒ½ç›¸åŒå°±ä»£è¡¨ sub array å¯ä»¥æ’åºæˆ sub sorted arrayï¼Œä¹Ÿå°±ä»£è¡¨å¯ä»¥åˆ†æˆä¸€å€‹ chunk\n\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        arr_counter = collections.defaultdict(int)\n        sorted_arr_counter = collections.defaultdict(int)\n        ans = 0\n        \n        sorted_arr = sorted(arr)\n        \n        for i in range(len(arr)):\n            arr_counter[arr[i]] += 1\n            sorted_arr_counter[sorted_arr[i]] += 1\n            if arr_counter == sorted_arr_counter:\n                ans += 1\n        return ans\n\n# Time: O(N^2) è¿´åœˆè£¡åŠ ä¸Š dict æ¯”å°\n# Space: O(N) é–‹äº†å…©å€‹ dict \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191610090","body":"```Python\n# ä½¿ç”¨å¿«æ…¢æŒ‡é‡æ‰¾å‡ºå€’æ•¸ç¬¬ k å€‹ç¯€é»ï¼Œä»¥å€’æ•¸ç¬¬ k å€‹ç¯€é»ç•¶åšæ–°çš„ headï¼ŒåŸæœ¬çš„ head æ¥åœ¨å°¾ç«¯\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if head is None:\n            return head\n        if k == 0:\n            return head\n        \n        fast = head\n        slow = head\n        \n\t# è¨ˆç®— linked list çš„é•·åº¦ï¼Œä»¥ç¸®çŸ­ k çš„é•·åº¦\n        length = 1\n        while fast.next:\n            fast = fast.next\n            length += 1\n        fast = head\n        k = k % length\n        \n        # fast å…ˆè·Ÿ slow æ‹‰é–‹è·é›¢ k\n        while k > 0:\n            if fast.next is not None:\n                fast = fast.next\n            else:\n                fast = head\n            k -= 1\n        \n        # slow é–‹å§‹è·Ÿè‘— fast å¾€å³ç§»\n        while fast.next is not None:\n            fast = fast.next\n            slow = slow.next\n        \n        # éˆçš„å‰åŠèˆ‡å¾ŒåŠäº’æ›\n        fast.next = head\n        head = slow.next\n        slow.next = None\n        \n        return head\n\n# Time: O(N)\n# Space: O(1)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192654251","body":"```python\r\n# å‡è¨­ Linked List é•·é€™æ¨£ A -> B -> C ->\r\n# å¦‚æœè¦æ› A, Bï¼Œå…ˆè®“ left, right åˆ†åˆ¥åœ¨é€™å…©å€‹ä½ç½®ä¸Šï¼šleft -> A -> B(right) -> C ->\r\n# åŸ·è¡Œ swap ä»¥å¾Œå†å°‡ left, right å¾€ä¸‹ä¸€å€‹ç›®æ¨™ä½ç½®ç§»å‹•\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head:\r\n            return head\r\n        if not head.next:\r\n            return head\r\n        \r\n        left = ListNode()\r\n        # left å¾ head å‰ä¸€å€‹ node é–‹å§‹\r\n        left.next = head\r\n        # right å¾ head ä¸‹ä¸€å€‹ node é–‹å§‹\r\n        right = head.next\r\n        \r\n        head = None\r\n        while True:\r\n            # swap nodes\r\n            left.next.next = right.next\r\n            right.next = left.next\r\n            left.next = right\r\n            # ç¬¬ä¸€è¼ªçš„ swap è¦æŒ‡å®šæ–°çš„ head\r\n            if not head:\r\n                head = right\r\n            \r\n            # å¾€å³ç§»å‹•ï¼Œå¦‚æœç¯€é»ä¸å¤ äº†å°±ä¸­æ­¢è¿´åœˆ\r\n            left = right.next\r\n            if left.next and left.next.next:\r\n                right = left.next.next\r\n            else:\r\n                break\r\n        \r\n        return head\r\n\r\n# Time: O(N)\r\n# Space: O(1)\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193139711","body":"```python\r\n# ç”¨å¿«æ…¢æŒ‡é‡æ‰¾åˆ° linked list ä¸­é–“çš„ç¯€é»ç•¶ä½œ BST çš„ root\r\n# ä½¿ç”¨éè¿´ï¼Œlinked list å‰åŠçµ„æˆå·¦å­æ¨¹ï¼Œå¾ŒåŠæ®µçµ„æˆå³å­æ¨¹\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head:\r\n            return None\r\n        if not head.next:\r\n            return TreeNode(head.val)\r\n        if not head.next.next:\r\n            return TreeNode(head.next.val, TreeNode(head.val))\r\n        \r\n        fast = head\r\n        # slow å¾ head å‰ä¸€å€‹ç¯€é»é–‹å§‹ï¼ŒæœŸæœ›èƒ½å¾—åˆ° linked list ä¸­é–“ç¯€é»çš„å‰ä¸€å€‹ç¯€é»\r\n        slow = ListNode()\r\n        slow.next = head\r\n        while fast.next and fast.next.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n        \r\n        mid = slow.next\r\n        slow.next = None\r\n        node = TreeNode(mid.val)\r\n        node.left = self.sortedListToBST(head)\r\n        node.right = self.sortedListToBST(mid.next)\r\n        \r\n        return node\r\n\r\n# Time complexity: O(NlogN)\r\n# Space complexity: O(1) æ˜¯éŒ¯çš„ï¼Œä¸€æ¨£è¦ä¹˜ä»¥éè¿´æ·±åº¦ logNï¼Œæ‰€ä»¥æ­£ç¢ºç­”æ¡ˆæ˜¯ O(logN)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193281511","body":"```python\r\n# å…ˆèµ°é linked list Aï¼Œå°‡ç¶“éçš„ node å­˜åœ¨ set è£¡é¢\r\n# å†èµ°é lilnked list Bï¼Œå°‡ç¶“éçš„ node å» set è£¡ç¢ºèªæ˜¯å¦å·²ç¶“å­˜åœ¨\r\n# å¦‚æœå·²ç¶“å­˜åœ¨ä»£è¡¨äº¤é›†åœ¨æ­¤ node\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\r\n        if not headA or not headB:\r\n            return None\r\n        \r\n        seen = { headA }\r\n        while headA.next:\r\n            headA = headA.next\r\n            seen.add(headA)\r\n        \r\n        if headB in seen:\r\n            return headB\r\n        while headB.next:\r\n            headB = headB.next\r\n            if headB in seen:\r\n                return headB\r\n        return None\r\n# Time complexity: O(M+N), M is length of A, N is length of B\r\n# Space complexity: O(M)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1200354870","body":"## æ€è·¯\nå¿«æ…¢æŒ‡é‡ï¼Œå¿«æŒ‡é‡èµ°å…©æ­¥ï¼Œæ…¢æŒ‡é‡èµ°ä¸€æ­¥\nç•¶å…©å€‹æŒ‡é‡é‡ç–Šçš„æ™‚å€™ï¼Œä»£è¡¨å¿«æŒ‡é‡è¶…è¶Šæ…¢æŒ‡é‡å‰›å¥½ä¸€åœˆçš„è·é›¢\n fast = 2 * slow\n fast - slow = ç’°åœ“å‘¨é•·\n => slow = ç’°åœ“å‘¨é•·\né€™æ™‚å€™ä¸€å€‹æŒ‡é‡åŸåœ°ï¼Œå¦ä¸€å€‹æŒ‡é‡å¾é ­ï¼Œç­‰é€Ÿç§»å‹•ï¼Œç¬¬ä¸€æ¬¡ç¢°åˆ°çš„å°±æ˜¯ç’°é–‹å§‹çš„ç¯€é»\n## Code\n```python\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast = slow = head\n        while True:\n            if not fast or not fast.next:\n                return None    \n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                break\n                \n        fast = head\n        while fast.next and slow.next:\n            if fast == slow:\n                return fast\n            fast = fast.next\n            slow = slow.next\n```\n**è¤‡é›œåº¦**\n- Time complexity: O(N)\n- Space complexity: O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195611879","body":"## æ€è·¯\r\nä½¿ç”¨ hash map ä»¥åŠé›™å‘ linked list\r\nhash map çš„ key ç‚º intï¼Œvalue ç‚º linked list è£¡çš„ node\r\nlinked list çš„ head ç‚ºæœ€å·¦é‚Šçš„ dummy nodeï¼Œtail ç‚ºæœ€å³é‚Šçš„ dummy node\r\n\r\n## ç¨‹å¼ç¢¼\r\n```python\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.dict = dict()\r\n        self.head = ListNode(-1, -1)\r\n        self.tail = ListNode(-1, -1)\r\n        self.head.right = self.tail\r\n        self.tail.left = self.head\r\n        \r\n    def get(self, key: int) -> int:\r\n        if key in self.dict:\r\n            # å°‡å°æ‡‰çš„ node å¾ linked list æ‘˜é™¤\r\n            node = self.dict[key]\r\n            self._remote_from_list(node)\r\n            # å°‡å°æ‡‰çš„ node ç§»åˆ° linked list çš„æœ€å³é‚Š\r\n            self._move_to_right(node)\r\n            # å›å‚³ value\r\n            return node.value\r\n        else:\r\n            return -1\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.dict:\r\n            # å°‡å°æ‡‰çš„ node å¾ linked list æ‘˜é™¤\r\n            node = self.dict[key]\r\n            self._remote_from_list(node)\r\n            # å°‡å°æ‡‰çš„ node ç§»åˆ° linked list çš„æœ€å³é‚Š\r\n            self._move_to_right(node)\r\n            # æ›´æ–° value\r\n            node.value = value\r\n        else:        \r\n            if len(self.dict) >= self.capacity:\r\n                # å»é™¤æ‰æœ€ä¹…æ²’ç”¨åˆ°çš„ï¼Œä¹Ÿå°±æ˜¯æœ€å·¦é‚Šçš„ node\r\n                to_delete = self.head.right.key\r\n                del self.dict[to_delete]\r\n                self.head = self.head.right\r\n            # å¡å…¥æ–°çš„ key value\r\n            # æ¥ä¸Šæ–°çš„ node åˆ° linked list å³å´\r\n            node = ListNode(key, value)\r\n            self._move_to_right(node)\r\n            # ç´€éŒ„æ–°çš„ node åˆ° dictionary\r\n            self.dict[key] = node\r\n           \r\n    def _move_to_right(self, node):\r\n        self.tail.left.right = node\r\n        node.left = self.tail.left\r\n        self.tail.left = node\r\n        node.right = self.tail\r\n        \r\n    def _remote_from_list(self, node):\r\n        node.left.right = node.right\r\n        node.right.left = node.left \r\n\r\nclass ListNode:\r\n    def __init__(self, key, value):\r\n        self.value = value\r\n        self.key = key\r\n        self.left = None\r\n        self.right = None\r\n```\r\n**è¤‡é›œåº¦**\r\n- Time: get put éƒ½æ˜¯ O(1)\r\n- Space: O(N) N ç‚º capacity","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196782629","body":"## æ€è·¯\r\n- æ¨¹çš„æœ€æ·±æ·±åº¦ç­‰æ–¼å·¦å³å­æ¨¹è¼ƒæ·±çš„æ·±åº¦çš„å†åŠ ä¸€\r\n- ç”¨ dfs éè¿´ï¼Œå¦‚æœåˆ°è‘‰ç¯€é»å†å¾€ä¸‹ä¸€å±¤å°±å›å‚³ 0\r\n\r\n## Code\r\n```python\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root:\r\n            return 0\r\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\r\n```\r\n\r\n**è¤‡é›œåº¦**\r\n- Time complexity: O(N)ï¼ŒN ç‚ºç¯€é»æ•¸ç›®\r\n- Space complexity: O(h)ï¼Œh = æ¨¹çš„æ·±åº¦ï¼Œæœ€å¥½ logNï¼Œæœ€å·® N","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198080947","body":"## æ€è·¯ \r\nå…©æ£µæ¨¹åŒæ™‚ç”¨ dfs èµ°éæ‰€æœ‰çš„ç¯€é»\r\nå¦‚æœä¸­é–“æœ‰ä¸ä¸€æ¨£çš„åœ°æ–¹å°±ä»£è¡¨å…©æ£µæ¨¹ä¸ä¸€æ¨£\r\nå¦‚æœé †åˆ©èµ°å®Œå°±ä»£è¡¨å…©æ£µæ¨¹ä¸€æ¨£\r\n\r\n## Code\r\n```python\r\nclass Solution:\r\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        if not p or not q:\r\n            return False\r\n        \r\n        left = self.isSameTree(p.left, q.left)\r\n        right = self.isSameTree(p.right, q.right)\r\n        if not left or not right:\r\n            return False\r\n        return p.val == q.val\r\n```\r\n**è¤‡é›œåº¦**\r\n- æ™‚é–“è¤‡é›œåº¦ï¼šO(N)ï¼ŒN ç‚ºæ¨¹çš„ç¯€é»æ•¸\r\n- ç©ºé–“è¤‡é›œåº¦ï¼šO(h)ï¼Œh ç‚ºæ¨¹çš„é«˜åº¦","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199348717","body":"## æ€è·¯\r\nå¾ root å¾€ leaf èµ°ï¼Œæ¯ä¸€æ¢è·¯å¾‘éƒ½æ˜¯ä¸€å€‹æ•¸å­—\r\næ¯æ¢è·¯å¾‘ä¸€å±¤å±¤æ…¢æ…¢ç´¯åŠ ç®—å‡ºå±¬æ–¼é‚£å€‹è·¯å¾‘çš„æ•¸å­—ï¼Œåˆ° leaf ä»¥å¾Œæ•¸å­—å°±è¨ˆç®—å®Œæˆ\r\nå›å‚³çš„éšæ®µæŠŠæ‰€æœ‰æ•¸å­—ç´¯åŠ èµ·ä¾†\r\n\r\n## Code\r\n```python\r\nclass Solution:\r\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\r\n        def dfs(node, cur):\r\n            if not node:\r\n                return 0\r\n            if not node.left and not node.right:\r\n                return cur * 10 + node.val\r\n            return dfs(node.left, cur * 10 + node.val) + dfs(node.right, cur * 10 + node.val)\r\n        \r\n        return dfs(root, 0)\r\n```\r\n**è¤‡é›œåº¦**\r\n- Time: O(N)\r\n- Space: O(h)ï¼Œh ç‚ºæ¨¹çš„é«˜åº¦","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200354427","body":" ## æ€è·¯\r\nBFS ä¸¦ä¸”ç”±å³å‘å·¦èµ°ï¼Œèµ°åˆ°æœ€å¾Œä¸€å€‹ç¯€é»å°±æ˜¯ç­”æ¡ˆ\r\n## Code\r\n```python\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        q = collections.deque([root])\r\n        \r\n        node = root\r\n        while q:\r\n            node = q.popleft()\r\n            if node.right:\r\n                q.append(node.right)\r\n            if node.left:\r\n                q.append(node.left)\r\n        return node.val\r\n```\r\n**è¤‡é›œåº¦**\r\n- Time: O(N)ï¼ŒN ç‚ºç¯€é»æ•¸\r\n- Space: O(Q)ï¼ŒQ ç‚º queue çš„é•·åº¦ï¼Œæœ€ç³Ÿçš„æƒ…æ³æ˜¯ O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200353854","body":"```python\r\nclass Codec:\r\n    # ç…§è‘— BFS åºåˆ—åŒ–ï¼Œé‡åˆ°ç©ºç¯€é»ä¾¿å¡«ä¸Š null åˆ°å­—ä¸²è£¡\r\n    def serialize(self, root):\r\n        # ç©ºçš„æ¨¹å›å‚³ç©ºå­—ä¸²\r\n        if not root:\r\n            return ''\r\n        q = collections.deque([root])\r\n        ans = []\r\n        while q:\r\n            node = q.popleft()\r\n            if not node:\r\n                ans.append('null')\r\n            else:\r\n                ans.append(str(node.val))\r\n                q.append(node.left)\r\n                q.append(node.right)\r\n        # æœ«ç«¯çš„ null éƒ½æ¸…æ‰\r\n        while ans[-1] == 'null':\r\n            ans.pop()\r\n        return ','.join(ans)\r\n\r\n    # ä¾åºèµ°éå­—ä¸²ï¼Œç…§è‘— BFS çš„é †åºçµ„å‡ºæ¨¹ï¼Œ\r\n    # å¦‚æœé‡åˆ°å­—ä¸²æ˜¯ nullï¼Œå‰‡ä»£è¡¨ç„¡éœ€æ–°å¢ç¯€é»\r\n    # æŠŠæ–°å¢çš„ç¯€é»ç´€éŒ„åœ¨ queue è£¡é¢ï¼Œç­‰å¾…ä¸‹æ¬¡å‡º queue çš„æ™‚å€™å¾€ä¸‹é€£çµå­ç¯€é»\r\n    # å¾ queue å‡ºä¾†çš„ç¯€é»è¦ç¢ºå®šå·¦å³å­ç¯€é»éƒ½å®Œæˆäº†æ‰å¯ä»¥è¼ªåˆ°ä¸‹ä¸€å€‹ queue è£¡çš„ç¯€é»\r\n    def deserialize(self, data):\r\n        if data == '':\r\n            return None\r\n        values = data.split(',')\r\n        # å…ˆå®Œæˆ root ç¯€é»\r\n        root = TreeNode(values[0])\r\n        q = collections.deque([root])      \r\n        # æš«å­˜ï¼Œå·¦å­ç¯€é»å®Œæˆï¼Œå³å­ç¯€é»é‚„æ²’å®Œæˆ\r\n        cur = None\r\n        for val in values[1:]:\r\n            if val == 'null':\r\n                new_node = None\r\n            else:\r\n                new_node = TreeNode(val)\r\n                q.append(new_node)\r\n                \r\n            if cur:\r\n                node = cur\r\n                node.right = new_node\r\n                cur = None\r\n            else:\r\n                node = q.popleft()\r\n                node.left = new_node\r\n                cur = node\r\n            \r\n        return root\r\n```\r\nè¤‡é›œåº¦\r\n- Time: O(N)\r\n- Space: O(q)ï¼Œqueue çš„é•·åº¦","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201389315","body":"## æ€è·¯\r\ndfs èµ°éï¼Œå°‡ç¯€é»å€¼ç´€éŒ„åœ¨ map è£¡ï¼Œkey ç‚º 'x:y'ï¼Œvalue ç‚ºå°æ‡‰åº§æ¨™çš„ç¯€é»å€¼çš„ list ä¸¦ä¸”è¦å…ˆç…§å°åˆ°å¤§æ’åºå¥½\r\ndfs éç¨‹åŒæ™‚ç´€éŒ„ x, y çš„ç¯„åœ\r\næœ€å¾Œä¾æ“š x, y çš„ç¯„åœï¼Œ x, y å¾å°åˆ°å¤§ å» map è£¡æ‹¿å‡ºç¯€é»å€¼çš„ listï¼Œæ‹¼æ¥å‡ºç­”æ¡ˆ\r\n## Code\r\n```python\r\nclass Solution:\r\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\r\n        self.smallest_x_index = 0\r\n        self.largest_x_index = 0\r\n        self.largest_y_index = 0\r\n        self.storage = dict()\r\n        \r\n        def dfs(node, x, y):\r\n            if not node:\r\n                return\r\n            dfs(node.left, x-1, y+1)\r\n            dfs(node.right, x+1, y+1)\r\n            self.smallest_x_index = min(self.smallest_x_index, x)\r\n            self.largest_x_index = max(self.largest_x_index, x)\r\n            self.largest_y_index = max(self.largest_y_index, y)\r\n            \r\n            key = str(x)+\":\"+str(y)\r\n            if key not in self.storage:\r\n                self.storage[key] = [node.val]\r\n            else:\r\n                # ä¾ç…§å°åˆ°å¤§æ’åº\r\n                for i in range(len(self.storage[key])):\r\n                    if node.val <= self.storage[key][i]:\r\n                        self.storage[key].insert(i, node.val)\r\n                        break\r\n                    elif i == len(self.storage[key]) - 1:\r\n                        self.storage[key].append(node.val)\r\n                \r\n        dfs(root, 0, 0)\r\n        \r\n        ans = []\r\n        for x in range(self.smallest_x_index, self.largest_x_index+1):\r\n            column = []\r\n            for y in range(self.largest_y_index+1):\r\n                key = str(x)+\":\"+str(y)\r\n                if key in self.storage:\r\n                    column += self.storage[key]\r\n            ans.append(column)\r\n        \r\n        return ans\r\n```\r\n**è¤‡é›œåº¦**\r\n- Time: O(logN * D + W * H)ï¼ŒN ç‚ºç¯€é»æ•¸ï¼ŒD ç‚ºåŒä¸€å€‹åº§æ¨™ä¸Šæœ€å¤šæœ‰å¹¾å€‹ç¯€é»ï¼ŒW ç‚ºæ¨¹å¯¬ï¼ŒH ç‚ºæ¨¹é«˜\r\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201421467","body":"## æ€è·¯\r\néæ­·éç¨‹ä¸­å¦‚æœæœ‰å€‹ hash map å¯ä»¥æŸ¥åˆ° target - nums[i] æ˜¯å¦å­˜åœ¨ nums è£¡ä¸¦ä¸”å­˜åœ¨å“ªå€‹ indexï¼Œæ™‚é–“è¤‡é›œå°±å¯ä»¥å°æ–¼ O(N^2)ã€‚è€Œé€™å€‹ hash map å°±æ˜¯åœ¨éæ­· nums æ™‚ï¼Œå°‡ nums[i] ç•¶ä½œ keyï¼Œi ç•¶ä½œ value å­˜åœ¨ hash map è£¡ã€‚\r\n## Code\r\n```python\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        remain_dict = dict()\r\n        for i in range(len(nums)):\r\n            remain = target - nums[i]\r\n            if remain in remain_dict:\r\n                return [remain_dict[remain], i]\r\n            remain_dict[nums[i]] = i\r\n```\r\n**è¤‡é›œåº¦**\r\n- Time: O(N)\r\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1204093870","body":"## æ€è·¯\r\nç”¨ hash map ç´€éŒ„æ¯å€‹æ•¸å­—å‡ºç¾æ¬¡æ•¸ï¼Œæ¥è‘—ä¾å‡ºç¾æ¬¡æ•¸æ’åºï¼Œå›å‚³å‰ k å¤šæ¬¡çš„æ•¸å­—\r\n\r\n## Code\r\n```python\r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        counter = collections.defaultdict(int)\r\n        for n in nums:\r\n            counter[n] += 1\r\n        sorted_items = sorted(counter.items(), reverse=True, key=lambda item: item[1])\r\n        return [k for k, _ in sorted_items[:k]]\r\n```\r\n**è¤‡é›œåº¦**\r\n- Time: O(NlogN)\r\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205333665","body":"## æ€è·¯\r\né¡Œç›®è¦æ±‚ i åˆ° j è·Ÿ i åˆ° k çš„è·é›¢è¦ä¸€æ¨£ï¼Œå¯ä»¥å…ˆæŠŠ i åˆ°å…¶ä»–é»çš„è·é›¢è¨ˆç®—å‡ºä¾†ï¼Œä¸¦çµ±è¨ˆå‡ºåŒè·é›¢çš„é»æœ‰å¹¾å€‹ã€‚å†ä¾åŒè·é›¢çš„é»çš„æ•¸é‡è¨ˆç®—å¯èƒ½çš„ j, k çš„çµ„åˆæœ‰å¹¾å€‹ï¼Œä¸¦ç´¯åŠ èµ·ä¾†ã€‚\r\n## Code\r\n```python\r\nclass Solution:\r\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\r\n        ans = 0\r\n        seen = dict()\r\n        for i in range(len(points)):\r\n            d = collections.defaultdict(int)\r\n            for j in range(len(points)):\r\n                pi, pj = points[i], points[j]\r\n                dist = (pi[0]-pj[0])**2 + (pi[1]-pj[1])**2\r\n                d[dist] += 1\r\n                \r\n            for k in d.keys():\r\n                ans += d[k] * (d[k]-1)\r\n        return ans\r\n```\r\n**è¤‡é›œåº¦**\r\n- Time: O(N^2)\r\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206396460","body":"## æ€è·¯\r\nä½¿ç”¨å¿«æ…¢æŒ‡é‡éæ­· strï¼Œæ…¢æŒ‡é‡æŒ‡å‘ substring çš„é ­ï¼Œå¿«æŒ‡é‡æŒ‡å‘ substring çš„å°¾\r\næŠŠå¿«æŒ‡é‡é‡åˆ°çš„å­—æ¯ç•¶ key èˆ‡å…¶ä½ç½®ç•¶ value ç´€éŒ„åœ¨ hash map\r\nè‹¥å¿«æŒ‡é‡é‡åˆ°å­—æ¯é‡è¤‡å‡ºç¾åœ¨ substing ç¯„åœå…§\r\n- æ¯”å° substring é•·åº¦æ˜¯å¦å¯ä»¥æ›´æ–°ç‚ºæ–°çš„ç­”æ¡ˆ\r\n- ç§»å‹•æ…¢æŒ‡é‡åˆ°é‡è¤‡å­—æ¯çš„ä¸‹ä¸€ä½\r\n\r\nç›´åˆ°å¿«æŒ‡é‡èµ°åˆ°åº•ï¼Œæœ€å¾Œå†æ¯”å° substring çœ‹æœ‰æ²’æœ‰è¾¦æ³•æ›´æ–°ç­”æ¡ˆ\r\n## Code\r\n```python\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        slow = fast = 0\r\n        seen = {}\r\n        ans = 0\r\n        while fast < len(s):\r\n\t    # å¦‚æœå¿«æŒ‡é‡æŒ‡åˆ°çš„å­—æ¯ï¼Œé‡è¤‡å‡ºç¾åœ¨ substring è£¡é¢\r\n            if s[fast] in seen and seen[s[fast]] >= slow:\r\n                ans = max(ans, fast - slow)\r\n                # ç§»å‹•æ…¢æŒ‡é‡\r\n                slow = seen[s[fast]] + 1\r\n            seen[s[fast]] = fast\r\n            fast += 1\r\n        return max(ans, fast - slow)\r\n```\r\n**è¤‡é›œåº¦**\r\n- Time: O(N)\r\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207257099","body":"```python\r\nclass Solution:\r\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\r\n        window_length = len(\"\".join(words))\r\n        \r\n        # å°‡é¡Œç›®çµ¦çš„ words å…ˆåŒ–æˆ countersï¼Œä¹‹å¾Œç”¨ä¾†å°ç­”æ¡ˆ\r\n        words_dict = collections.defaultdict(int)\r\n        for word in words:\r\n            words_dict[word] += 1\r\n        \r\n        # å–®å­—çš„é•·åº¦\r\n        word_length = len(words[0])\r\n        \r\n        # words è£¡çµ¦çš„å–®å­—æœ‰å¤šé•·ï¼Œå°±é–‹å¤šå°‘å€‹ counter ä¾†ç´€éŒ„\r\n        seen_dicts = [collections.defaultdict(int) for _ in range(word_length)]\r\n        \r\n        ans = []\r\n        for r in range(len(s) - word_length + 1):\r\n            window_head = r + word_length - window_length\r\n            \r\n            # ç•¶å‰å°æ‡‰çš„ counter\r\n            cur_counter = seen_dicts[r%word_length]\r\n            \r\n            # å°‡ r æŒ‡åˆ°çš„å–®å­—ç´å…¥å°æ‡‰çš„ counter è£¡\r\n            r_word = s[r:r+word_length]\r\n            cur_counter[r_word] += 1\r\n            \r\n            # ä¸€æ—¦ç•¶å‰ counter å­˜çš„å–®å­—æ•¸è¶…éé¡Œç›®çµ¦çš„å–®å­—æ•¸ï¼Œå°±è¦è¸¢é™¤æœ€æ—©ç´å…¥çš„å–®å­—\r\n            if sum(cur_counter.values()) > len(words):\r\n                word_to_remove = s[window_head-word_length:window_head]\r\n                cur_counter[word_to_remove] -= 1\r\n                if cur_counter[word_to_remove] == 0:\r\n                    del cur_counter[word_to_remove]\r\n\r\n            # æ¯”å°ç•¶ä¸‹å°æ‡‰çš„ counter è·Ÿç­”æ¡ˆæ˜¯ä¸æ˜¯ä¸€è‡´\r\n            if cur_counter == words_dict:\r\n                window_head = r + word_length - window_length\r\n                ans.append(window_head)\r\n        \r\n        return ans\r\n```\r\n**è¤‡é›œåº¦**\r\n- Time: O(len(s))ï¼Œéæ­· s ä¸€æ¬¡\r\n- Space: O(word_length * len(words))ï¼Œseen_dicts çš„å¤§å°","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207427715","body":"## æ€è·¯\r\næš´åŠ›è§£\r\n## Code\r\n```python\r\nclass Solution:\r\n    def solve(self, nums, k):\r\n        mod = sum(nums)%k\r\n        if mod == 0:\r\n            return 0\r\n        ans = len(nums)\r\n        for l in range(len(nums)):\r\n            total = 0\r\n            for r in range(l, len(nums)):\r\n                total += nums[r]               \r\n                if total % k == mod:\r\n                    ans = min(ans, r-l+1)\r\n        return ans if ans < len(nums) else -1\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208105080","body":"## æ€è·¯\r\nå¿«æ…¢æŒ‡é‡ï¼Œæ…¢æŒ‡é‡èµ°ä¸€æ­¥ï¼Œå¿«æŒ‡é‡èµ°å…©æ­¥ï¼Œç›´åˆ°å¿«æŒ‡é‡èµ°åˆ°åº•ï¼Œæ…¢æŒ‡é‡æŒ‡çš„ä½ç½®å°±æ˜¯ linked list æ­£ä¸­é–“\r\n## Code\r\n```python\r\nclass Solution:\r\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        slow = fast = head\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n        return slow\r\n```\r\n**è¤‡é›œåº¦**\r\n- time: O(N)\r\n- space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209455569","body":"## æ€è·¯\r\nä½¿ç”¨è®€èˆ‡å¯«æŒ‡é‡ï¼Œè®€æŒ‡é‡é€æ­¥å¾€å³ï¼Œæ¯”å°è®€èˆ‡å¯«æŒ‡é‡çš„æ•¸å€¼\r\nè‹¥è®€æŒ‡é‡çš„æ•¸å€¼å¤§æ–¼å¯«æŒ‡é‡ï¼Œå¯«æŒ‡é‡å¾€å³ä¸€æ­¥ï¼Œä»¥è®€æŒ‡é‡çš„æ•¸å€¼å–ä»£å¯«æŒ‡é‡çš„æ•¸å€¼\r\nè®€æŒ‡é‡èµ°å®Œæ•´å€‹ list çš„æ™‚å€™ï¼Œå¯«æŒ‡é‡çš„ index +1 ä¾¿æ˜¯ç­”æ¡ˆ\r\n## Code\r\n```python\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        r = w = 0\r\n        while r < len(nums):\r\n            if nums[r] > nums[w]:\r\n                w += 1\r\n                nums[w] = nums[r]\r\n            r += 1\r\n        return w+1\r\n```\r\n**è¤‡é›œåº¦**\r\n- Time: O(N)\r\n- Space: O(1)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cobayaz":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1189171833","body":"func addToArrayForm(A []int, K int) (ans []int) {\n    for i := len(A) - 1; i >= 0; i-- {\n        //ä»åå¾€å‰åŠ  æ¯æ¬¡åŠ ä¸€ä¸ª  æ¯”å¦‚ K=806\n        sum := A[i] + K%10    //A[i] = 1   1 + 6\n        K /= 10\n        if sum >= 10 {\n            K++ //Kå¾€å‰è¿›ä¸€ä½\n            sum -= 10  //sum åªç•™ä¸‹ä¸ªä½æ•°\n        }\n        ans = append(ans, sum) //æ·»åŠ 0åˆ°æ•°ç»„é¦–éƒ¨\n    }\n\n\n//å¦‚æœè¿›ä½çš„æ˜¯æœ€åå‡ ä½ å¾ªç¯æ·»åŠ \n    for ; K > 0; K /= 10 {\n        ans = append(ans, K%10)\n    }\n    //åè½¬æ•°ç»„\n    reverse(ans)\n    return\n}\n\nfunc reverse(A []int) {\n    for i, n := 0, len(A); i < n/2; i++ {\n        A[i], A[n-1-i] = A[n-1-i], A[i]\n    }\n}\n","onTime":false},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189195841","body":"### æ ˆ\n\n\n```go\n\ntype MyQueue struct {\n\tinstack []int \n\toutstack []int \n}\n\n\nfunc NewQueue() MyQueue {\n\treturn MyQueue{\n\t\tinstack: make([]int, 0),\n\t\toutstack: make([]int, 0),\n\t}\n}\n\n// push å‹æ ˆ\nfunc (this *MyQueue) Push(x int)  {\n\tthis.instack = append(this.instack, x)\n}\n\n// å‡ºæ ˆ\nfunc (this *MyQueue) in2out()  {\n\t// å½“outstackç©ºæ—¶ï¼Œéœ€è¦å°†instackå…¨éƒ¨è½¬å…¥outstack\n\tfor len(this.instack) > 0 {\n\t\tthis.outstack = append(this.outstack, this.instack[len(this.instack)-1])\n\t\tthis.instack = this.instack[:len(this.instack)-1]\n\t}\n}\n\n// pop\nfunc (this *MyQueue) Pop() int {\n\t// popæ—¶éœ€è¦å…ˆåˆ¤æ–­outstackæ˜¯å¦ä¸ºç©º\n\tif len(this.outstack) == 0 {\n\t\tthis.in2out()\n\t}\n\t// popæ—¶å‡ºæ ˆtop, ç„¶åæ›´æ–°outstack\n\tval := this.outstack[len(this.outstack)-1]\n\tthis.outstack = this.outstack[:len(this.outstack)-1]\n\treturn val\n}\n\n// peek\nfunc (this *MyQueue) Peek() int {\n\t// å› ä¸ºoutstackæ‰æ˜¯å‡ºæ ˆåŠŸèƒ½éƒ¨åˆ†ï¼Œéœ€è¦å…ˆåˆ¤æ–­æ˜¯å¦ä¸ºç©º\n\tif len(this.outstack) == 0 {\n\t\tthis.in2out()\n\t}\n\treturn this.outstack[len(this.outstack)-1]\n}\n\n// empty\nfunc (this *MyQueue) Empty() bool {\n\t// ä»…å½“å…¥æ ˆå’Œå‡ºæ ˆéƒ½ä¸ºç©ºæ—¶ï¼Œqueueæ‰ä¸ºç©º\n\treturn len(this.outstack) == 0 && len(this.instack) == 0\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201365179","body":"### ä»£ç \n\n```go\ntype pos struct {\n\tx, y, val int\n}\nvar result []pos\n\n\nfunc (r result) Len() int {\n\treturn len(r)\n}\n\nfunc (r result) Less(i, j int) bool {\n\tif r[i].x == r[j].x { // åŒä¸€åˆ—\n\t\tif r[i].y == r[j].y { // åŒä¸€åˆ—ä¸”åŒä¸€è¡Œ,æ•°å€¼å°çš„æ”¾å‰é¢\n\t\t\treturn r[i].val < r[j].val\n\t\t}\n\t\treturn r[i].y < r[j].y // åŒä¸€åˆ—ä¸åŒè¡Œ,è¡Œæ•°å°çš„æ”¾å‰é¢\n\t}\n\treturn r[i].x < r[j].x // ä¸åŒåˆ—åˆ™åˆ—æ•°å°çš„æ”¾å‰é¢\n}\n\nfunc (r result) Swap(i, j int) {\n\tr[i], r[j] = r[j], r[i]\n}\n\nfunc verticalTraversal(root *TreeNode) [][]int {\n\tif root == nil {\n\t\treturn nil\n\t}\n\tvar loc result\n\ttree(root, 0, 0, &loc)\n\tsort.Sort(loc)\n\tvar (\n\t\tindex = 0\n\t\tx     = loc[index].x\n\t\tres   = [][]int{{loc[index].val}}\n\t)\n\tfor i := 1; i < len(loc); i++ {\n\t\tif x != loc[i].x { // ä¸åŒåˆ—åˆ™èµ‹å€¼x,ä¸”ç»“æœæ–°å¼€ä¸€ä¸ªæ•°ç»„\n\t\t\tx = loc[i].x\n\t\t\tindex++\n\t\t\tres = append(res, []int{})\n\t\t}\n\t\tres[index] = append(res[index], loc[i].val)\n\t}\n\treturn res\n}\n\nfunc tree(root *TreeNode, x, y int, loc *result) {\n\tif root != nil { // å°†åæ ‡å’Œå€¼å­˜å…¥æ•°ç»„\n\t\t*loc = append(*loc, pos{x, y, root.Val})\n\t\ttree(root.Left, x-1, y+1, loc)\n\t\ttree(root.Right, x+1, y+1, loc)\n\t}\n}\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1204145620","body":"### ä»£ç \n```go\nfunc topKFrequent(nums []int, k int) []int {    \n    freqMap := make(map[int]int) // è®°å½•æ¯ä¸ªå€¼å‡ºç°çš„æ¬¡æ•°\n    mostFreq := 0 // è®°å½•å‡ºç°è¿‡æœ€å¤šæ¬¡çš„å€¼\n    \n    for _, num := range nums{\n        freqMap[num]++\n        if count, _ := freqMap[num];mostFreq<count{\n            mostFreq = count\n        }\n    }\n\n    var res []int\n    hashTop := make([][]int, mostFreq+1) // \n    for k, v := range freqMap{\n        hashTop[v] = append(hashTop[v], k) // æ ¼å¼æ˜¯å‡ºç°æ¬¡æ•°ä»¥åŠå¯¹åº”çš„ å€¼åˆ—è¡¨\n    }\n    for i:=mostFreq;i>=0;i--{\n        res = append(res, hashTop[i]...)\n        k -= len(hashTop[i])\n        if k <= 0{\n            break\n        }\n    }\n    return res\n}\n\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208122645","body":"## æ€è·¯\nå¿«æ…¢æŒ‡é’ˆ\n\n## ä»£ç \n```go\nfunc middleNode(head *ListNode) *ListNode {\n    zero := &ListNode{Next:head}\n    slow, fast := zero, zero\n\n    for fast != nil && fast.Next != nil {\n        fast = fast.Next.Next\n        slow = slow.Next\n    }\n\n    if fast == nil {\n        return slow\n    }\n\n    return slow.Next\n}\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tomato-tomato":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189231157","body":"```js\nvar MyQueue = function() {\n    this.mainStack = [];\n    this.tempStack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.mainStack.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    while(this.mainStack.length > 1) {\n        this.tempStack.push(this.mainStack.pop());\n    }\n    const res = this.mainStack.pop();\n    while(this.tempStack.length) {\n        this.mainStack.push(this.tempStack.pop());\n    }\n\n    return res;\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    return this.mainStack[0];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.mainStack.length;\n};\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195667267","body":"```js\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.map = new Map();\n    this.capacity = capacity;\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if(this.map.has(key)) {\n        let temp = this.map.get(key);\n        this.map.delete(key);\n        this.map.set(key, temp);\n        return temp;\n    }\n    return -1;\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    if(this.map.has(key)) {\n        this.map.delete(key);\n    }\n    this.map.set(key, value);\n    if(this.map.size > this.capacity) {\n        this.map.delete(this.map.keys().next().value)\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xfliudx":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1188827861","body":"- Language: JAVA\r\n\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        if(s == null || s.length() == 0){\r\n            return s;\r\n        }\r\n\r\n        int len = s.length();\r\n        Stack<Character> stack = new Stack<>();\r\n        for(int i = 0; i < len; i++){\r\n            char c = s.charAt(i);\r\n            if(c != ']'){\r\n                stack.push(c);\r\n            } else {\r\n                char sc = ' ';\r\n                StringBuffer sb = new StringBuffer();\r\n                while(!stack.isEmpty()){\r\n                    sc = stack.pop();\r\n                    if(sc != '['){\r\n                        sb.append(sc);\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                int num = 0;\r\n                int idx = 0;\r\n                while(!stack.isEmpty()){\r\n                    char n = stack.peek();\r\n                    if(n >= '0' && n <= '9'){\r\n                        int tmp = 1;\r\n                        for(int m = 0; m < idx; m++){\r\n                            tmp *= 10;\r\n                        }\r\n                        num += tmp * (n - '0');\r\n                        idx++;\r\n                        stack.pop();\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                String pattern = sb.reverse().toString();\r\n                sb.setLength(0);\r\n\r\n                for(int j = 0; j < num; j++){\r\n                    sb.append(pattern);\r\n                }\r\n\r\n                for(int k = 0; k < sb.length(); k++){\r\n                    stack.push(sb.charAt(k));\r\n                }\r\n            }\r\n        }\r\n\r\n        StringBuffer res = new StringBuffer(stack.size());\r\n        while(!stack.isEmpty()){\r\n            res.append(stack.pop());\r\n        }\r\n\r\n        return res.reverse().toString();\r\n    }\r\n}\r\n```\r\n\r\nTime Complexity: O(n)\r\nSpace Complexity: O(n);","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"djd28176":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189702954","body":"```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int res = 0;\n        int[] sorted = arr.clone();\n        Arrays.sort(sorted);\n        int diff = 0;\n        for (int i = 0; i < arr.length; i++){\n            diff += arr[i] - sorted[i];\n            if (diff == 0){\n                res ++;\n            }\n        }\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190982420","body":"```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null) return null;\n        int n = 1;\n        ListNode tail = head;\n        while(tail.next != null){\n            n++;\n            tail = tail.next;\n        }\n        tail.next = head;\n        \n        ListNode newTail = head;\n\n        for(int i = 0; i < n-k%n- 1; i++){\n            newTail = newTail.next;\n        }\n        ListNode newHead = newTail.next;\n        newTail.next = null;\n        \n        return newHead;\n        \n    }\n}","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193366911","body":"```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head == null) return null;\n        ListNode start = check(head);\n        if(start == null) return null;\n        ListNode slow = head;\n        ListNode fast = start;\n        while(slow != fast){\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n    private ListNode check(ListNode head){\n        ListNode fast = head;\n        ListNode slow = head;\n        \n        while(fast != null && fast.next != null){\n            fast = fast.next.next;\n            slow = slow.next;\n            if(fast == slow){\n                return slow;\n            }\n        }\n        return null;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194510012","body":"```java\nclass LRUCache {\n    private Map<Integer, DLinkedNode> map = new HashMap<>();\n    private DLinkedNode head, tail;\n    private int size;\n    private int capacity;\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        this.size = 0;\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    public int get(int key) {\n        if(map.containsKey(key)){\n            moveToHead(map.get(key));\n            return map.get(key).value;\n        }\n        return -1;\n    }\n    \n    public void put(int key, int value) {\n        if (map.containsKey(key)){\n            moveToHead(map.get(key));\n            map.get(key).value = value;\n        }else{\n            DLinkedNode newNode = new DLinkedNode();\n            newNode.key = key;\n            newNode.value = value;\n            map.put(key,newNode);\n            addNode(newNode);\n            this.size++;\n            if(this.size > this.capacity){\n                DLinkedNode pop = popTail();\n                map.remove(pop.key);\n                this.size--;\n            }\n        }\n    }\n    \n    \n    class DLinkedNode{\n        int key;\n        int value;\n        DLinkedNode prev;\n        DLinkedNode next;\n    }\n    private void addNode(DLinkedNode node){\n        node.prev = head;\n        node.next = head.next;\n        \n        head.next.prev = node;\n        head.next = node;\n    }\n    private void removeNode(DLinkedNode node){\n        DLinkedNode prev = node.prev;\n        DLinkedNode next = node.next;\n        \n        prev.next = next;\n        next.prev = prev;\n    }\n    private void moveToHead(DLinkedNode node){\n        removeNode(node);\n        addNode(node);\n    }\n    private DLinkedNode popTail(){\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196203809","body":"```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) return 0;\n        Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n        int level = 0;\n        while(!q.isEmpty()){\n            int curSize = q.size();\n            while(curSize-->0){\n                TreeNode cur = q.poll();\n                if(cur.left != null){\n                    q.add(cur.left);\n                }\n                if(cur.right != null){\n                    q.add(cur.right);\n                }\n            }\n            level++;\n        }\n        return level;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197102899","body":"```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null) return true;\n        if(p == null || q == null) return false;\n        if(p.val != q.val) return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right,q.right);\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198474801","body":"```java\nclass Solution {\n     private int rootToLeaf = 0;\n    public int sumNumbers(TreeNode root) {\n        build(root, 0);\n        return rootToLeaf;\n    }\n    private void build(TreeNode node, int currNumber){\n        if (node != null){\n            currNumber = currNumber * 10 + node.val;\n            if(node.left == null && node.right == null){\n                rootToLeaf += currNumber;\n            }\n            build(node.left, currNumber);\n            build(node.right, currNumber);\n        }\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200227266","body":"```java\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n        int res = 0;\n        while(!q.isEmpty()){\n            int size = q.size();\n            for(int i = 0; i < size; i++){\n                TreeNode curNode = q.poll();\n                if (i == 0) res = curNode.val;\n                if(curNode.left != null){\n                    q.add(curNode.left);\n                }\n                if(curNode.right != null){\n                    q.add(curNode.right);\n                }\n            }\n            \n        }\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200420611","body":"```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n        while(!q.isEmpty()){\n            TreeNode cur = q.poll();\n            if (cur != null){\n                sb.append(cur.val + \",\");\n                q.add(cur.left);\n                q.add(cur.right);                \n            }else{\n                sb.append(\"#,\");\n            }\n        }\n        return sb.toString();\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        if(data == \"#\") return null;\n        String[] nodes = data.split(\",\");\n        if(nodes[0].equals(\"#\")) return null;\n        TreeNode root = new TreeNode(Integer.valueOf(nodes[0]));\n        int index = 1;\n        Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n        while(!q.isEmpty()){\n            TreeNode node = q.poll();\n            String left = nodes[index];\n            String right = nodes[index + 1];\n            \n            if(!left.equals(\"#\")){\n                TreeNode leftNode = new TreeNode(Integer.parseInt(left));\n                node.left = leftNode;\n                q.add(leftNode);\n            }\n            if(!right.equals(\"#\")){\n                TreeNode rightNode = new TreeNode(Integer.parseInt(right));\n                node.right = rightNode;\n                q.add(rightNode);\n            }\n            index += 2;\n        }\n        return root;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser = new Codec();\n// Codec deser = new Codec();\n// TreeNode ans = deser.deserialize(ser.serialize(root));","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201247369","body":"```java\nclass Solution {\n    Map<Integer, ArrayList<Pair<Integer,Integer>>> columnTable = new HashMap<>();\n    int minCol = 0, maxCol = 0;\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<List<Integer>> output = new ArrayList<>();\n        if(root == null){\n            return output;\n        }\n        DFS(root,0,0);\n        for(int i = minCol; i < maxCol + 1; i++){\n            Collections.sort(columnTable.get(i), new Comparator<Pair<Integer,Integer>>(){\n                public int compare(Pair<Integer,Integer> p1, Pair<Integer,Integer> p2){\n                    if(p1.getKey().equals(p2.getKey()))\n                        return p1.getValue() - p2.getValue();\n                    else\n                        return p1.getKey() - p2.getKey();\n                }\n            });\n            List<Integer> sortedColumn = new ArrayList();\n            for(Pair<Integer,Integer> p : columnTable.get(i)){\n                sortedColumn.add(p.getValue());\n            }\n            output.add(sortedColumn);\n        }\n        return output;\n        \n    }\n    private void DFS(TreeNode node, Integer row, Integer column){\n        if(node == null){\n            return;\n        }\n        if(!columnTable.containsKey(column)){\n            columnTable.put(column, new ArrayList<Pair<Integer,Integer>>());\n        }\n        columnTable.get(column).add(new Pair<Integer,Integer>(row, node.val));\n        minCol = Math.min(minCol, column);\n        maxCol = Math.max(maxCol, column);\n        DFS(node.left, row+1, column-1);\n        DFS(node.right, row+1, column+1);\n    }\n\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201462944","body":"```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer,Integer> map = new HashMap<>();\n        int[] res = new int[2];\n        for(int i = 0; i < nums.length; i++){\n            if(map.containsKey(target - nums[i])){\n                res[0] = map.get(target-nums[i]);\n                res[1] = i;\n                break;\n            }\n            map.put(nums[i],i);\n        }\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1202991982","body":"```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        if(nums.length == 0) return nums;\n        Map<Integer,Integer> map = new HashMap<>();\n        for(int num : nums){\n            map.put(num,map.getOrDefault(num,0)+1);\n        }\n        Queue<Integer> heap = new PriorityQueue<>((n1,n2)->map.get(n1)-map.get(n2));\n        for(int key : map.keySet()){\n            heap.add(key);\n            if(heap.size()>k){\n                heap.poll();\n            }\n        }\n        int[] res = new int[k];\n        for(int i = k-1; i >=0; i--){\n            res[i] = heap.poll();\n        }\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204305769","body":"```java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        HashMap<Integer, Integer> distances = new HashMap<>();\n        int boomerangs = 0;\n        for (int i = 0; i < points.length; i++){\n            for (int j = 0; j < points.length; j++){\n                if (i == j){\n                    continue;\n                }\n                int distance = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + \n                    (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\n                distances.put(distance, distances.getOrDefault(distance, 0) + 1);\n            }\n            for (Integer distance : distances.values()){\n                boomerangs += distance * (distance -1);\n            }\n            distances.clear();\n        }\n        return boomerangs;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205469823","body":"```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        //2ä¸ªæŒ‡é’ˆ right ç”¨æ¥æ‰©å¼ window left ç”¨æ¥ç¼©å‡ window\n        int[] chars = new int[128];\n        int left = 0, right = 0;\n        int res = 0;\n        while(right < s.length()){\n            char r = s.charAt(right);\n            chars[r]++;\n            \n            while(chars[r] > 1){\n                char l = s.charAt(left);\n                chars[l]--;\n                left++;\n            }\n            res = Math.max(res, right - left + 1);\n            right++;\n        }\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1206708904","body":"```java\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> res = new ArrayList<>();\n        Map<String, Integer> map = new HashMap<>();\n        for(String word: words){\n            map.put(word, map.getOrDefault(word,0) + 1);\n        }\n        int n = s.length();\n        int wordSize = words[0].length();\n        int subStringSize = wordSize * words.length;\n        for(int i = 0; i < n - subStringSize + 1; i++){\n            Map<String, Integer> temp = new HashMap<>();\n            int j = i;\n            for( ; j < i + subStringSize; j += wordSize){\n                String curWord = s.substring(j, j+ wordSize);\n                if(!map.containsKey(curWord)){\n                    break;\n                }\n                temp.put(curWord, temp.getOrDefault(curWord,0)+1);\n                if(temp.get(curWord) > map.get(curWord)){\n                    break;\n                }\n            }\n            if (j == i + subStringSize)\n                res.add(i);\n        }\n        return res;\n    }   \n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207414222","body":"```java\nclass Solution {\n    public int minSubarray(int[] nums, int p) {\n        int remove = 0;\n        int res = Integer.MAX_VALUE;\n        for(int num : nums){\n            remove = (num + remove) %p;\n        }\n        if (remove ==0) return 0;\n        \n        Map<Integer,Integer> map = new HashMap<>();\n        map.put(0,-1);\n        int prefix = 0;\n        for(int i = 0; i < nums.length;i++){\n            prefix = (prefix + nums[i]) % p;\n            map.put(prefix,i);\n            int rem = (prefix - remove + p) % p;\n            if(map.containsKey(rem)){\n                res = Math.min(res, i - map.get(rem));\n            }\n        }\n        return res >= nums.length ? -1 : res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207469649","body":"```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast != null && fast.next != null){\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208418152","body":"```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int n = nums.length;\n        if (n == 0) return 0;\n        \n        int index = 1;\n        for(int i = 1; i < n; i++){\n            if(nums[i] != nums[i-1]){\n                nums[index] = nums[i];\n                index ++;\n            }\n        }\n        return index;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/42#issuecomment-1209736136","body":"```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int left = 0, right = nums.length;\n        while(left < right){\n            int mid = left + (right - left) / 2;\n            if(nums[mid] == target) return mid;\n            else if(nums[mid] > target) right = mid;\n            else left = mid + 1;\n        }\n        return left;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xilutian":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189754021","body":"class Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int>maxStk;\n        maxStk.push(arr[0]);\n        for(int i=1;i<arr.size();i++){\n            if(arr[i]<maxStk.top()){\n                int maxNum=maxStk.top();\n                while(!maxStk.empty()&&maxStk.top()>arr[i])maxStk.pop();\n                maxStk.push(maxNum);\n            }\n            else maxStk.push(arr[i]);\n        }\n        return maxStk.size();\n\n\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191159350","body":"```\r\nif (k == 0 || head == nullptr || head->next == nullptr) {\r\nreturn head;\r\n}\r\nint n = 1;\r\nListNode* iter = head;\r\nwhile (iter->next != nullptr) {\r\niter = iter->next;\r\nn++;\r\n}\r\nint add = n - k % n;\r\nif (add == n) {\r\nreturn head;\r\n}\r\niter->next = head;\r\nwhile (add--) {\r\niter = iter->next;\r\n}\r\nListNode* ret = iter->next;\r\niter->next = nullptr;\r\nreturn ret;\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195071927","body":"```\r\nstruct DLinkedNode {\r\n    int key, value;\r\n    DLinkedNode* prev;\r\n    DLinkedNode* next;\r\n    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}\r\n    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}\r\n};\r\n\r\nclass LRUCache {\r\nprivate:\r\n    unordered_map<int, DLinkedNode*> cache;\r\n    DLinkedNode* head;\r\n    DLinkedNode* tail;\r\n    int size;\r\n    int capacity;\r\n\r\npublic:\r\n    LRUCache(int _capacity): capacity(_capacity), size(0) {\r\n        // ä½¿ç”¨ä¼ªå¤´éƒ¨å’Œä¼ªå°¾éƒ¨èŠ‚ç‚¹\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head->next = tail;\r\n        tail->prev = head;\r\n    }\r\n    \r\n    int get(int key) {\r\n        if (!cache.count(key)) {\r\n            return -1;\r\n        }\r\n        // å¦‚æœ key å­˜åœ¨ï¼Œå…ˆé€šè¿‡å“ˆå¸Œè¡¨å®šä½ï¼Œå†ç§»åˆ°å¤´éƒ¨\r\n        DLinkedNode* node = cache[key];\r\n        moveToHead(node);\r\n        return node->value;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if (!cache.count(key)) {\r\n            // å¦‚æœ key ä¸å­˜åœ¨ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„èŠ‚ç‚¹\r\n            DLinkedNode* node = new DLinkedNode(key, value);\r\n            // æ·»åŠ è¿›å“ˆå¸Œè¡¨\r\n            cache[key] = node;\r\n            // æ·»åŠ è‡³åŒå‘é“¾è¡¨çš„å¤´éƒ¨\r\n            addToHead(node);\r\n            ++size;\r\n            if (size > capacity) {\r\n                // å¦‚æœè¶…å‡ºå®¹é‡ï¼Œåˆ é™¤åŒå‘é“¾è¡¨çš„å°¾éƒ¨èŠ‚ç‚¹\r\n                DLinkedNode* removed = removeTail();\r\n                // åˆ é™¤å“ˆå¸Œè¡¨ä¸­å¯¹åº”çš„é¡¹\r\n                cache.erase(removed->key);\r\n                // é˜²æ­¢å†…å­˜æ³„æ¼\r\n                delete removed;\r\n                --size;\r\n            }\r\n        }\r\n        else {\r\n            // å¦‚æœ key å­˜åœ¨ï¼Œå…ˆé€šè¿‡å“ˆå¸Œè¡¨å®šä½ï¼Œå†ä¿®æ”¹ valueï¼Œå¹¶ç§»åˆ°å¤´éƒ¨\r\n            DLinkedNode* node = cache[key];\r\n            node->value = value;\r\n            moveToHead(node);\r\n        }\r\n    }\r\n\r\n    void addToHead(DLinkedNode* node) {\r\n        node->prev = head;\r\n        node->next = head->next;\r\n        head->next->prev = node;\r\n        head->next = node;\r\n    }\r\n    \r\n    void removeNode(DLinkedNode* node) {\r\n        node->prev->next = node->next;\r\n        node->next->prev = node->prev;\r\n    }\r\n\r\n    void moveToHead(DLinkedNode* node) {\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n\r\n    DLinkedNode* removeTail() {\r\n        DLinkedNode* node = tail->prev;\r\n        removeNode(node);\r\n        return node;\r\n    }\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197871464","body":"```\r\nclass Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n         if (p == nullptr && q == nullptr) {\r\n            return true;\r\n        } else if (p == nullptr || q == nullptr) {\r\n            return false;\r\n        } else if (p->val != q->val) {\r\n            return false;\r\n        } else {\r\n            return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\r\n        }\r\n\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201960137","body":"```\r\nclass Solution {\r\npublic:\r\n    vector<int> twoSum(vector<int>& nums, int target) {\r\n        unordered_map<int, int> hashtable;\r\n        for (int i = 0; i < nums.size(); ++i) {\r\n            auto it = hashtable.find(target - nums[i]);\r\n            if (it != hashtable.end()) {\r\n                return {it->second, i};\r\n            }\r\n            hashtable[nums[i]] = i;\r\n        }\r\n        return {};\r\n    }\r\n};\r\n\r\n\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207717313","body":"```\r\nclass Solution {\r\npublic:\r\n    ListNode* middleNode(ListNode* head) {\r\n        vector<ListNode*> A = {head};\r\n        while (A.back()->next != NULL)\r\n            A.push_back(A.back()->next);\r\n        return A[A.size() / 2];\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xy147":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189833390","body":"### æ€è·¯\r\næ»‘åŠ¨çª—å£\r\n### jsä»£ç \r\n```JavaScript\r\nvar maxChunksToSorted = function (arr) {\r\n    const sorted = [...arr];\r\n    sorted.sort((a, b) => a - b);\r\n\r\n    let count = 0,\r\n        sum1 = 0,\r\n        sum2 = 0;\r\n\r\n    for (let i = 0; i < arr.length; i++) {\r\n        sum1 += arr[i];\r\n        sum2 += sorted[i];\r\n\r\n        if (sum1 === sum2) {\r\n            count++;\r\n            sum1 = sum2 = 0; \r\n        }\r\n    }\r\n\r\n    return count;\r\n};\r\n\r\n```\r\n\r\n### å¤æ‚åº¦åˆ†æ\r\n- æ—¶é—´å¤æ‚åº¦: O(nlogn)\r\n- ç©ºé—´å¤æ‚åº¦: O(n)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196188309","body":"### æ€è·¯\né€’å½’\n### jsä»£ç \n```JavaScript\nvar maxDepth = function(root) {\n    if(root === null) {\n        return 0\n    }\n    let leftHeight = maxDepth(root.left);\n    let rightHeight = maxDepth(root.right);\n    return Math.max(leftHeight,rightHeight) + 1;\n};\n```\n\n### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦: O(N)\n- ç©ºé—´å¤æ‚åº¦: O(N)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203499151","body":"### æ€è·¯\nåˆ†æ²»å¿«æ’\n### jsä»£ç \n```JavaScript\nvar topKFrequent = function(nums, k) {\n    let hash = new Map();\n    for(let i of nums){\n        if(!hash.has(i)) hash.set(i,1);\n        else hash.set(i,hash.get(i)+1);\n    }\n    nums=new Array(hash.size);\n    let j=0;\n    for(let [key,value] of hash){\n        nums[j++]=[key,value];\n    }\n    getK(nums,0,nums.length-1,k);\n    let res=new Array(k);\n    for(let i=0;i<k;++i){\n        res[i] = nums[i][0];\n    }\n    return res;\n};\n\n//åˆ†æ²»   \nvar getK = function(nums,left,right,k){\n    if(left>=right) return ;\n    let temp = quikSort(nums,left,right,k);\n    if(temp+1==k+left) return ;\n    else if(temp+1<k+left){\n        getK(nums,temp+1,right,k-(temp+1-left));\n    } else getK(nums,left,temp-1,k);\n    return ;\n}\n\nvar quikSort = function(nums,left,right){\n    if(left>=right) return left;\n    let pivot = nums[left];\n    let i=left,j=right;\n    while(i<j){\n        while(nums[j][1]<pivot[1] && i<j) --j;\n        nums[i] = nums[j];\n        while(nums[i][1]>=pivot[1] && i<j) ++i;\n        nums[j] = nums[i];\n        if(i==j) nums[i] = pivot;\n    }\n    return i;\n}\n```\n\n### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦: O(N2)\n- ç©ºé—´å¤æ‚åº¦: O(N)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/42#issuecomment-1210030342","body":"### æ€è·¯\näºŒåˆ†\n### jsä»£ç \n```JavaScript\nvar searchInsert = function(nums, target) {\n    const n = nums.length;\n    let left = 0, right = n - 1, ans = n;\n    while (left <= right) {\n        let mid = ((right - left) >> 1) + left;\n        if (target <= nums[mid]) {\n            ans = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return ans;\n};\n\n```\n### å¤æ‚åº¦åˆ†æ\n- æ—¶é—´å¤æ‚åº¦: O(log n)\n- ç©ºé—´å¤æ‚åº¦: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"itsjacob":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189849757","body":"### Implementation\n```c++\nclass Solution\n{\npublic:\n  int maxChunksToSorted(vector<int>& arr)\n  {\n    std::stack<int> s;\n    for (auto const& ele : arr) {\n      if (s.empty() || s.top() <= ele) {\n        s.push(ele);\n      } else {\n        int chunkLeader = s.top();\n        s.pop();\n        while (!s.empty() && s.top() > ele) {\n          s.pop();\n        }\n        // Now the leader of the chunk is back to the stack\n        s.push(chunkLeader);\n      }\n    }\n    return s.size();\n  }\n};\n```\n### Complexity\n- Time complexity: O(n) \n- Space complexity: O(n) ","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193366284","body":"### Implementation\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n      ListNode *pSlow{head};\n      ListNode *pFast{head};\n      while (pFast != nullptr && pFast->next != nullptr) {\n        pFast = pFast->next->next;\n        pSlow = pSlow->next;\n        if (pSlow == pFast) break;\n      }\n      \n      if (pFast == nullptr || pFast->next == nullptr) {\n        return nullptr;\n      }\n      \n      pSlow = head;\n      while (pSlow != pFast) {\n        pSlow = pSlow->next;\n        pFast = pFast->next;\n      }\n      return pSlow;\n    }\n};\n```\n### Complexity\n- Time complexity: O(N) \n- Space complexity: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shunanch":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189964725","body":"å‚è€ƒé¢˜è§£ï¼Œä½¿ç”¨è¾…åŠ©æ ˆ\r\n\r\n```cpp\r\n#include<bits/stdc++.h>\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        vector<int> stack;\r\n        for(int num : arr) {\r\n            if(!stack.empty() && num < *stack.rbegin()) {\r\n                int head = *stack.rbegin();\r\n                stack.pop_back();\r\n                while(!stack.empty() && num < *stack.rbegin())\r\n                 stack.pop_back();\r\n                stack.push_back(head);\r\n            }\r\n            else stack.push_back(num);\r\n        }\r\n        return stack.size();\r\n    }\r\n};","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195132359","body":"``` cpp\r\nstruct Node {\r\n    int key;\r\n    int val;\r\n    Node *next, *prev;\r\n    Node(int k, int v) : key(k), val(v), prev(nullptr), next(nullptr) {}\r\n};\r\n\r\nclass DoubleLinkedList {\r\n    Node *head, *tail;\r\npublic:\r\n    DoubleLinkedList() {\r\n        head = new Node(-1, -1);\r\n        tail = new Node(-1, -1);\r\n        head->next = tail;\r\n        tail->prev = head;\r\n    }\r\n\r\n    void push_front(Node* node) {\r\n        node->next = head->next;\r\n        node->prev = head;\r\n        node->next->prev = node;\r\n        head->next = node;\r\n    }\r\n\r\n    void erase(Node* node) {\r\n        node->next->prev = node->prev;\r\n        node->prev->next = node->next;\r\n    }\r\n\r\n    Node* back() {\r\n        return tail->prev;\r\n    }\r\n\r\n    void pop_back() {\r\n        erase(tail->prev);\r\n    }\r\n};\r\n\r\nclass LRUCache {\r\n    int cap;\r\n    unordered_map<int, Node*> key_node_map;\r\n    DoubleLinkedList* node_list;\r\npublic:\r\n    LRUCache(int capacity) {\r\n        cap = capacity;\r\n        node_list = new DoubleLinkedList();\r\n    }\r\n    \r\n    int get(int key) {\r\n        // ä¸å­˜åœ¨è¯¥key\r\n        if (key_node_map.find(key) == key_node_map.end()) {\r\n            return -1;\r\n        } else {\r\n            // å°†å½“å‰èŠ‚ç‚¹åœ¨ç§»åŠ¨åˆ°åŒé“¾è¡¨çš„é¦–ä½\r\n            Node* node = key_node_map[key];\r\n            node_list->erase(node);\r\n            node_list->push_front(node);\r\n            return node->val;\r\n        }\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        // å¦‚æœkeyå­˜åœ¨ï¼Œåˆ™ä¿®æ”¹å¯¹åº”çš„valueå¹¶ç§»åŠ¨è‡³é“¾è¡¨é¦–ç«¯\r\n        if (key_node_map.find(key) != key_node_map.end()) {\r\n            Node *node = key_node_map[key];\r\n            node->val = value;\r\n            node_list->erase(node);\r\n            node_list->push_front(node);\r\n        } else {\r\n            // å¦‚æœç¼“å­˜å·²æ»¡ï¼Œåˆ™åˆ é™¤åŒé“¾è¡¨æœ«ç«¯èŠ‚ç‚¹\r\n            if (key_node_map.size() == cap) {\r\n                key_node_map.erase(node_list->back()->key);\r\n                node_list->pop_back();\r\n            }\r\n            // æ’å…¥æ–°èŠ‚ç‚¹\r\n            Node *node = new Node(key, value);\r\n            key_node_map[key] = node;\r\n            node_list->push_front(node);\r\n        }\r\n    }\r\n};","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198837985","body":"```cpp\r\nclass Solution {\r\npublic:\r\n    int dfs(TreeNode* root, int prevSum) {\r\n        if (root == nullptr) {\r\n            return 0;\r\n        }\r\n        int sum = prevSum * 10 + root->val;\r\n        if (root->left == nullptr && root->right == nullptr) {\r\n            return sum;\r\n        } else {\r\n            return dfs(root->left, sum) + dfs(root->right, sum);\r\n        }\r\n    }\r\n    int sumNumbers(TreeNode* root) {\r\n        return dfs(root, 0);\r\n    }\r\n};\r\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206034380","body":"```cpp\r\nclass Solution {\r\npublic:\r\n    int lengthOfLongestSubstring(string s) {\r\n        if(s.size() == 0) return 0;\r\n        unordered_set<char> lookup;\r\n        int maxStr = 0;\r\n        int left = 0;\r\n        for(int i = 0; i < s.size(); i++){\r\n            while (lookup.find(s[i]) != lookup.end()){\r\n                lookup.erase(s[left]);\r\n                left ++;\r\n            }\r\n            maxStr = max(maxStr,i-left+1);\r\n            lookup.insert(s[i]);\r\n    }\r\n        return maxStr;\r\n        \r\n    }\r\n};\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yppah-eb":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189968695","body":"### æ€è·¯\r\n\r\nå‚è€ƒé¢˜è§£çš„å•è°ƒæ ˆæ€è·¯ï¼Œæ»¡è¶³æ¡ä»¶çš„åˆ†å—ä¸€å®šæ˜¯åè¾¹åˆ†å—çš„æœ€å°å€¼ä¸å°äºå‰è¾¹åˆ†å—çš„æœ€å¤§å€¼ï¼Œæ‰€ä»¥ä¿ç•™æ¯ä¸€ä¸ªåˆ†å—çš„æœ€å¤§å€¼åŠ å…¥æ ˆï¼Œæœ€åå–æ ˆçš„é•¿åº¦å³å¯\r\n\r\n### ä»£ç \r\n\r\n\r\n```\r\nvar maxChunksToSorted = function(arr) {\r\n    const stack=[]\r\n    for(let i=0;i<arr.length ;i++){\r\n        let a=arr[i]\r\n        if(stack[stack.length-1]&&stack[stack.length-1]>a){\r\n            const cur=stack[stack.length-1]\r\n            while(stack[stack.length-1]&&stack[stack.length-1]>a){\r\n                stack.pop()\r\n            }\r\n            stack.push(cur)\r\n        }else{\r\n            stack.push(a)\r\n        }\r\n    }\r\n    return stack.length\r\n};\r\n```\r\n\r\n**å¤æ‚åº¦åˆ†æ**\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"raychenlei":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190386338","body":"**æ€è·¯**\r\n\r\nè‡ªå·±æ²¡ä»€ä¹ˆæ€è·¯ï¼ŒæŒ‰ç…§é¢˜è§£é‡Œçš„ä¸¤æ¬¡éå†æ–¹æ³•\r\nå…ˆéå†ä¸€éï¼Œè®°å½•åˆ°å½“å‰æ•°ä¸ºæ­¢çš„æœ€å¤§å€¼head\r\nç„¶åä»åå¾€å‰éå†ï¼Œå¦‚æœéå†è¿‡çš„arræ•°ç»„é‡Œçš„æœ€å°å€¼æ¯”å‰ä¸€ä¸ªåˆ†å—çš„æœ€å¤§å€¼headè¦å¤§ï¼Œå—çš„æ•°é‡ + 1\r\n\r\n**ä»£ç **\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int[] head = new int[arr.length];\r\n        head[0] = arr[0];\r\n        for(int i = 1; i < arr.length; i++){\r\n            head[i] = Math.max(head[i - 1], arr[i]);\r\n        }\r\n        int tail = Integer.MAX_VALUE, res = 0;\r\n        for(int i = arr.length - 1; i >= 0; i--){\r\n            if(tail >= head[i]){\r\n                res++;\r\n            }\r\n            tail = Math.min(tail, arr[i]);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n```\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)\r\n","onTime":true},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198006098","body":"\r\n\r\n```java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null && q == null) {\r\n            return true;\r\n        }\r\n        if (p != null && q == null) {\r\n            return false;\r\n        }\r\n        if (p == null && q != null) {\r\n            return false;\r\n        }\r\n        if (p.val != q.val) {\r\n            return false;\r\n        }\r\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n\r\n```\r\n\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n\r\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202060217","body":"é¢˜è§£ï¼š\r\n\r\n```java\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int target) {\r\n        //æš´åŠ›è§£æ³•éœ€è¦éå†næ¬¡ï¼Œå¯¹æ¯ä¸ªå…ƒç´ éƒ½è¦å¾€åéå†ä¸€æ¬¡\r\n        //é—®é¢˜è½¬æ¢ï¼šå¯¹äºä¸€ä¸ªç‰¹å®šçš„å€¼curï¼ŒæŸ¥æ‰¾æ•°ç»„ä¸­æ˜¯å¦å­˜åœ¨ä¸€ä¸ªå€¼ä¸º target - curçš„å…ƒç´ ï¼Œå¦‚æœå­˜åœ¨ï¼Œåˆ™æ‰¾åˆ°ä»–çš„ä¸‹æ ‡\r\n        //éœ€è¦é€šè¿‡å…ƒç´ çš„å€¼æ‰¾åˆ°å…ƒç´ çš„ä¸‹æ ‡ï¼Œæ•°ç»„åªå¯ä»¥é€šè¿‡ä¸‹æ ‡æ¥è·å¾—å€¼ï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨mapæ¥å­˜å‚¨å€¼å’Œä¸‹æ ‡çš„å…³ç³»\r\n        //æ¯æ¬¡æ¯”è¾ƒå®Œï¼Œå°±å¯ä»¥å­˜å‚¨è¿™ä¸ªå¯¹åº”å…³ç³»\r\n\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        for(int i = 0; i < nums.length; i ++){\r\n            int temp = target - nums[i];\r\n            if (map.containsKey(temp)){\r\n                return new int[]{map.get(temp), i};\r\n            }\r\n            map.put(nums[i], i);\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206088956","body":"```java\r\nclass Solution {\r\n    public int lengthOfLongestSubstring(String s) {\r\n        Set<Character> set = new HashSet<Character>();\r\n        int n = s.length();\r\n        int j = -1, ans = 0;\r\n        for (int i = 0; i < n; ++i) {\r\n            if (i != 0) {\r\n                set.remove(s.charAt(i - 1));\r\n            }\r\n            while (j + 1 < n && !set.contains(s.charAt(j + 1))) {\r\n                set.add(s.charAt(j + 1));\r\n                ++j;\r\n            }\r\n            ans = Math.max(ans, j - i + 1);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"woshichuanqilz":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190438348","body":"```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int>maxStk;\r\n        maxStk.push(arr[0]);\r\n        for(int i=1;i<arr.size();i++){\r\n            if(arr[i]<maxStk.top()){\r\n                int maxNum=maxStk.top();\r\n                while(!maxStk.empty()&&maxStk.top()>arr[i])maxStk.pop();\r\n                maxStk.push(maxNum);\r\n            }\r\n            else maxStk.push(arr[i]);\r\n        }\r\n        return maxStk.size();\r\n    }\r\n};\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"willuuu":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1189685480","body":"```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        sum = k\r\n        results=[]\r\n        i = len(num)-1\r\n        while True:\r\n            if sum == 0 and i <0:\r\n                break\r\n            current = 10**(len(num)-i-1)\r\n            if i >= 0:\r\n                sum += current*num[i] \r\n            reminder = int(sum%(current*10)/current)\r\n            results.insert(0, reminder)\r\n            sum = sum - reminder*current\r\n            i -= 1\r\n        return results\r\n```\r\nå¤æ‚åº¦O(n)","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"christina-soda":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190642938","body":"### æ€è·¯\n\n1. å½¢æˆä¸€ä¸ªé“¾è¡¨ç¯ï¼› 2. å‘å³ç§»åŠ¨ ï¼ˆlen_list - k % len_listï¼‰ï¼› 3. å¾—åˆ°æ–°åˆ—è¡¨çš„headï¼Œ å¹¶æ–­å¼€é“¾è¡¨ç¯ã€‚\n\n### ä»£ç \n\n\n```python\n\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \n        currentNode = head\n        len_list = 1\n        if head is None:\n            return None\n        while currentNode.next is not None:\n            len_list = len_list + 1\n            currentNode = currentNode.next\n        currentNode.next = head\n                \n        move = len_list - k % len_list\n        \n        for i in range(move):\n            currentNode = currentNode.next\n        head = currentNode.next\n        currentNode.next = None\n        \n        return head\n\n\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jia98shanliang":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190893559","body":"\r\n\r\nclass Solution {\r\n         public ListNode rotateRight(ListNode head, int j) {\r\n             if(head == null || head.next == null) {\r\n                 return head;\r\n             }\r\n             ListNode tail = head;\r\n             int length = 1;\r\n             while(tail.next != null) {\r\n                 tail = tail.next;\r\n                 length++;\r\n             }\r\n             tail.next = head;\r\n             ListNode cur = head;\r\n             for(int i = 1; i <  len - (j % len); i++) {\r\n                 cur = cur.next;\r\n             }\r\n             tail = cur.next;\r\n             cur.next = null;\r\n\r\n             return tail;\r\n         }\r\n     }","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197542225","body":"class Solution {\r\npublic:\r\n\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        if (p == NULL && q == NULL) return true;\r\n        if (p == NULL || q == NULL) return false;\r\n        queue<TreeNode*> que;\r\n        que.push(p);   //\r\n        que.push(q);  //\r\n        while (!que.empty()) {  //\r\n            TreeNode* leftNode = que.front(); que.pop();\r\n            TreeNode* rightNode = que.front(); que.pop();\r\n            if (!leftNode && !rightNode) {  //\r\n                continue;\r\n            }\r\n            //\r\n            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {\r\n                return false;\r\n            }\r\n            que.push(leftNode->left);   //\r\n            que.push(rightNode->left); //\r\n            que.push(leftNode->right);  //\r\n            que.push(rightNode->right);  //\r\n        }\r\n        return true;\r\n    }\r\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"user-vannnn":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1191415978","body":"```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        i=len(num)-1\r\n        while k:\r\n            num[i]+=k\r\n            k=num[i]//10\r\n            num[i]=num[i]%10\r\n            i-=1\r\n            if i<0 and k:\r\n                num.insert(0,0)\r\n                i=0\r\n        return num\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1193054066","body":"CODE\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        if not s:\r\n            return None\r\n\r\n        count = 0       #è®¡æ•°å™¨\r\n        temp = 10000\r\n\r\n        result = []\r\n        \r\n        for i in range(len(s)):\r\n            if s[i] != c:\r\n                count += 1\r\n                temp += 1\r\n                if i+1 == len(s):\r\n                    for j in range(count):\r\n                        result.append(j+1)\r\n                        count -= 1\r\n                                \r\n            else:                \r\n                for j in range(count):                    \r\n                    pre = temp - count + 1\r\n                    result.append(min(count,pre))\r\n                    count -= 1\r\n                    \r\n                temp = 0\r\n                result.append(0)\r\n\r\n        return result\r\n```\r\n//æ‰§è¡Œç”¨æ—¶ï¼š40 ms,å†…å­˜æ¶ˆè€—ï¼š14.9 MB","onTime":false},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191234692","body":"CODE\r\n```\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if k==0 or not head or not head.next:\r\n            return head\r\n\r\n        n=1\r\n        cur=head\r\n\r\n        while cur.next:\r\n            cur=cur.next\r\n            n+=1\r\n\r\n        if(add:=n-k%n)==n:\r\n            return head\r\n        cur.next=head\r\n\r\n        while add:\r\n            cur=cur.next\r\n            add-=1\r\n\r\n        ret=cur.next\r\n        cur.next=None\r\n\r\n        return ret        \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192142197","body":"----éœ€è¦åˆ›å»ºä¸€ä¸ªè™šæ‹ŸèŠ‚ç‚¹å»æ¥ä½é“¾è¡¨ï¼Œé“¾è¡¨å¤´ç»“ç‚¹ä¸å¸¦å€¼\r\n\r\nCODE\r\n\r\n```\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        \r\n        #åˆ›å»ºè™šæ‹ŸèŠ‚ç‚¹\r\n        dummyHead=ListNode(-1)\r\n\r\n        p1 = head\r\n        p2 = dummyHead\r\n\r\n        while p1 and p1.next:\r\n            q = p1.next\r\n\r\n            p2.next = q\r\n            p1.next = q.next\r\n            q.next = p1\r\n\r\n            p2 = p1\r\n            p1 = p1.next\r\n\r\n        return dummyHead.next\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193049431","body":"CODE\r\n\r\n```\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        def getMedian(left:ListNode,right:ListNode)->ListNode:\r\n            fast = slow = left\r\n            while fast != right and fast.next != right:\r\n                slow = slow.next\r\n                fast = fast.next.next\r\n            return slow\r\n\r\n        def buildTree(left:ListNode,right:ListNode)->TreeNode:\r\n            if left == right:        #é“¾è¡¨ä¸ºç©º\r\n                return  None\r\n            mid = getMedian(left,right)\r\n            root = TreeNode(mid.val)    #è·å–ä¸­å€¼èŠ‚ç‚¹ï¼Œä¾æ¬¡æ’å…¥\r\n            root.left = buildTree(left,mid)\r\n            root.right = buildTree(mid.next,right)\r\n            return root\r\n        \r\n        return buildTree(head,None)\r\n```\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195198436","body":"CODE\r\n\r\n//çº¯å‡ æŠŠä¸ä¼šå†™ï¼ŒäºŒåˆ·çœ‹å®Œå“ˆå¸Œè¡¨å›å¤´é‡åš--\r\n\r\n```\r\nclass ListNode:         #initialize listnode\r\n    def __init__(self,key = 0,val = 0):\r\n        self.key = key\r\n        self.val = val\r\n        self.prev = None\r\n        self.next = None\r\n\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.hashmap = {}\r\n        \r\n        self.head = ListNode()\r\n        self.tail = ListNode()\r\n\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n\r\n    def remove_node(self,node):\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n\r\n    def add_node_to_last(self,node):\r\n        self.tail.prev.next = node\r\n        node.prev = self.tail.prev\r\n        node.next = self.tail\r\n        self.tail.prev = node\r\n\r\n    def  move_node_to_last(self,node):\r\n        self.remove_node(node)\r\n        self.add_node_to_last(node)\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.hashmap:\r\n            return -1\r\n\r\n        node = self.hashmap[key]\r\n        self.move_node_to_last(node)\r\n        return node.val\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.hashmap:\r\n            node = self.hashmap[key]\r\n            node.val = value\r\n            self.move_node_to_last(node)\r\n            return\r\n        if len(self.hashmap) == self.capacity:\r\n            del self.hashmap[self.head.next.key]\r\n            self.remove_node(self.head.next)\r\n        node = ListNode(key,value)\r\n\r\n        self.hashmap[key] = node\r\n        self.add_node_to_last(node)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1198012967","body":"CODE\r\n```\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root:\r\n            return 0\r\n\r\n        else:\r\n            return max(self.maxDepth(root.left),self.maxDepth(root.right))+1\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197978173","body":"CODE\r\n//self.fuction\r\n```\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        elif not p or not q:\r\n            return False\r\n        elif p.val != q.val:\r\n            return False\r\n        else:\r\n            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203883122","body":"CODE\r\n\r\n```\r\n\r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        if not nums:\r\n            return None\r\n\r\n        nums_off = nums\r\n        temp  = 0\r\n        count = [0]\r\n        result = []  \r\n        nums_result = []         \r\n\r\n        for i in range(len(nums)):\r\n            if nums_off[i] != 0:\r\n                temp = nums[i]\r\n                nums_count = 0\r\n            else:\r\n                continue\r\n\r\n            for j in range(len(nums)):\r\n                if temp == nums[j] and nums_off[j] != 0:\r\n                    nums_count += 1\r\n                    nums_off[j] = 0\r\n            \r\n            for j in range(len(count)):\r\n                if nums_count > count[j]:\r\n                    print(j,nums_count,temp)\r\n                    count.insert(j+1,nums_count)\r\n                    result.insert(j+1,temp) \r\n        print(count,result)\r\n        for i in range(k):\r\n            nums_result.append(result[i])\r\n                \r\n        return nums_result\r\n```\r\n            ","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207167174","body":"CODE\r\n\r\næ‰§è¡Œç”¨æ—¶ï¼š84 ms, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†90.95%çš„ç”¨æˆ·\r\nå†…å­˜æ¶ˆè€—ï¼š15.5 MB, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†70.96%çš„ç”¨æˆ·\r\n//æ»‘åŠ¨çª—å£è¿˜ä¸æ˜¯å¾ˆç†è§£ï¼ŒäºŒåˆ·è‡ªå·±å°è¯•å®ç°----\r\n\r\n```\r\nclass Solution:\r\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\r\n        res = []\r\n        m,n,ls = len(words),len(words[0]),len(s)\r\n        for i in range(n):\r\n            if i+m*n > ls:\r\n                break\r\n            differ = Counter()\r\n            for j in range(m):\r\n                word = s[i+j*n:i+(j+1)*n]\r\n                differ[word] += 1\r\n            for word in words:\r\n                differ[word] -= 1\r\n                if differ[word] == 0:\r\n                    del differ[word]\r\n\r\n            for start in range(i,ls-m*n+1,n):\r\n                if start != i:\r\n                    word = s[start+(m-1)*n:start+m*n]\r\n                    differ[word] += 1\r\n                    if differ[word] == 0:\r\n                        del differ[word]\r\n                    word = s[start-n:start]\r\n                    differ[word] -= 1\r\n                    if differ[word] == 0:\r\n                        del differ[word]\r\n                if len(differ) == 0:\r\n                    res.append(start)\r\n        return res\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tobepellucid":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191560985","body":"```\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if not head or not head.next:\n            return head\n\n        tail = head\n        length = 1\n        while tail.next:\n            length += 1\n            tail = tail.next\n        tail.next = head\n\n        k = k % length\n        for _ in range(length - k):\n            tail = tail.next\n\n        head = tail.next\n        tail.next = None\n        return head\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203845826","body":"# æ€è·¯\næ¡¶æ’åºè®¡æ•°\n\n# ä»£ç \n```python3\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        buckets = [[] for _ in range(len(nums))]\n\n        for num, freq in Counter(nums).items():\n            buckets[freq-1].append(num)\n        \n        ans = []\n        for li in buckets[::-1]:\n            for num in li:\n                ans.append(num)\n                if len(ans) == k:\n                    return ans\n```\n# å¤æ‚åº¦\n    ç©ºé—´ O(N) ;    æ—¶é—´ O(NLogN)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207428286","body":"```python3\nclass Solution:\n    def solve(self, nums, k):\n        n = len(nums)\n        t_remainder = sum(nums) % k\n        map = {0: -1}\n        prefix = 0\n        ret = n\n        for i in range(n):\n            prefix += nums[i]\n            re = prefix % k\n            map[remainder] = i\n            if ((prefix - t_remainder) % k) in map:\n                ret = min(ret, i - map[((prefix - t_remainder) % k)])\n        if ret < n:\n            return ret\n        else:\n            return -1\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208206034","body":"```python3\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        fast = head\n        slow = head\n        while(fast != None and fast.next != None):\n            fast = fast.next.next\n            slow = slow.next\n        return slow\n        \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208759387","body":"```python3\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        fast, slow = 0,0\n        if len(nums) == 1:\n            return 1\n        while (fast <= len(nums)-1):\n            if nums[fast] == nums[slow]:\n                fast += 1\n            else:\n                nums[slow+1] = nums[fast]\n                slow += 1 \n                fast += 1\n        return slow + 1\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"johnvsd":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191616669","body":"## æ€è·¯\r\n\r\næ ¹æ®é¢˜ç›®å¯ä»¥æ€»ç»“å‡ºï¼Œå°†é“¾è¡¨çš„æ¯ä¸ªèŠ‚ç‚¹å‘åç§»åŠ¨ k æ­¥ï¼Œä¹Ÿå°±æ˜¯å°†é“¾è¡¨çš„å€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹ä½œä¸ºå¤´ç»“ç‚¹ï¼Œå…¶å‰é¢çš„æ‰€æœ‰èŠ‚ç‚¹æ”¾åœ¨åŸé“¾è¡¨å°¾ç»“ç‚¹ä¹‹åã€‚\r\nå¯ä»¥åˆ©ç”¨å¿«æ…¢æŒ‡é’ˆæ¥å¤„ç†ã€‚\r\n\r\n## ä»£ç  (JS)\r\n\r\n```JavaScript\r\nvar rotateRight = function(head, k) {\r\n    if(k === 0 || head === null) return head;\r\n\r\n    // è·å–é“¾è¡¨é•¿åº¦\r\n    let len = calculateLen(head);\r\n    k = k%len;\r\n\r\n    // å®šä¹‰å¿«æ…¢æŒ‡é’ˆ\r\n    let slow = head;\r\n    let fast = head;\r\n\r\n    // å¿«æŒ‡é’ˆå‘å‰ç§»åŠ¨ k æ­¥\r\n    for(let i=0; i<k; i++) {\r\n        fast = fast.next\r\n    }\r\n\r\n    // å¿«æŒ‡é’ˆç§»åŠ¨åˆ°å°¾éƒ¨ä¸ºæ­¢\r\n    while (fast.next !== null) {\r\n        fast = fast.next;\r\n        slow = slow.next;\r\n    }\r\n\r\n    // å°†å¿«æŒ‡é’ˆçš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹è®¾ä¸ºå¤´ç»“ç‚¹\r\n    fast.next = head;\r\n    // æ–°çš„å¤´èŠ‚ç‚¹ä¸ºæ…¢æŒ‡é’ˆçš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹\r\n    head = slow.next;\r\n    slow.next = null;\r\n\r\n    return head;\r\n};\r\n\r\n// è®¡ç®—é“¾è¡¨é•¿åº¦\r\nfunction calculateLen(head) {\r\n    let len = 0;\r\n    while (head!==null) {\r\n        head = head.next;\r\n        len++;\r\n    }\r\n    return len;\r\n}\r\n```\r\n\r\n## å¤æ‚åº¦åˆ†æ\r\n* æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n* ç©ºé—´å¤æ‚åº¦ï¼šO(1) ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yueza":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192167435","body":"## æ€è·¯\r\nè¿­ä»£ï¼šè®¾ç½®preèŠ‚ç‚¹åï¼ŒåŸåœ°äº¤æ¢preèŠ‚ç‚¹å’ŒcurèŠ‚ç‚¹\r\n## ä»£ç \r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        dummy_head = ListNode(0)\r\n        dummy_head.next = head\r\n        pre = dummy_head\r\n        cur = head\r\n        while cur != None and cur.next != None:\r\n            pre.next = cur.next\r\n            cur.next = cur.next.next\r\n            pre.next.next = cur\r\n            pre = cur\r\n            cur = cur.next\r\n        return dummy_head.next\r\n```\r\n## å¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193133881","body":"### æ€è·¯\né€šè¿‡å¿«æ…¢æŒ‡é’ˆæ‰¾åˆ°ä¸­é—´å€¼ï¼ˆä¿è¯æ ‘å¹³è¡¡ï¼‰ï¼Œå·¦å³ä¸¤ä¾§å„è‡ªå»ºæ ‘\n\nå’Œå®˜æ–¹çš„ç¬¬ä¸€ç§æ€è·¯ç›¸åŒï¼Œä½†å†™çš„æœ‰äº›ä¸‘é™‹...\n### ä»£ç \n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        def find_mid(head: Optional[ListNode]) -> ListNode:\n            fast, slow = head, head\n            while fast != None and fast.next != None:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n        \n        def buildTree(head: ListNode) -> TreeNode:\n            if head == None:\n                return None\n            elif head.next == None:\n                return TreeNode(head.val)\n            \n            mid = find_mid(head)\n            left, right = head, mid.next\n            while head.next != mid:\n                head = head.next\n            head.next = None  #æˆªæ–­å·¦é“¾è¡¨\n        \n            root = TreeNode(mid.val)\n            root.left = self.sortedListToBST(left)\n            root.right = self.sortedListToBST(right)\n            return root\n        \n        return buildTree(head)\n```\n### å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193160207","body":"### æ€è·¯\næŒ‡é’ˆAå’ŒæŒ‡é’ˆBåˆ†åˆ«ä»ä¸¤é“¾è¡¨å¤´èŠ‚ç‚¹å¾€åèµ°ï¼Œè‹¥éå†å®Œé“¾è¡¨åˆ™ä»å¦ä¸€é“¾è¡¨å¤´èŠ‚ç‚¹ç»§ç»­èµ°\n\nè‹¥ä¸ç›¸äº¤ï¼Œå„è‡ªèµ°å®Œä¸¤ä¸ªé“¾è¡¨ï¼Œè¿”å›None\n\nè‹¥ç›¸äº¤ï¼Œåˆ™åœ¨å…¬å…±èŠ‚ç‚¹ç›¸é‡ï¼Œè¿”å›èŠ‚ç‚¹\n\n### ä»£ç \n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        A, B = headA, headB\n        while A != B:\n            A = A.next if A else headB\n            B = B.next if B else headA\n        return A\n```\n### å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(m+n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194219052","body":"### æ€è·¯\n1.é€šè¿‡å¿«æ…¢æŒ‡é’ˆfast, slowæ‰¾åˆ°ç›¸äº¤èŠ‚ç‚¹\n\n2.é¢å¤–æŒ‡é’ˆretæŒ‡å‘å¤´èŠ‚ç‚¹ï¼Œretä¸slowå¿…ç›¸è¾ƒäºç¯å…¥å£èŠ‚ç‚¹\n\n### ä»£ç \n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        fast, slow = head, head\n        flag = False\n        while fast != None and fast.next != None and slow != None:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                flag = True\n                break\n        if flag:\n            ret = head\n            while ret != slow:\n                ret = ret.next\n                slow = slow.next\n            return ret\n        else:\n            return None\n```\n### å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195665133","body":"### æ€è·¯\r\nç¬¬ä¸€æ¬¡åšè¿™é¢˜ï¼Œå·æ‡’ç”¨dictï¼Œacæ˜¯acäº†ï¼Œè¿è¡Œæ—¶é—´å’Œå†…å­˜éƒ½æœ‰ç‚¹æ‹‰è·¨\r\n\r\n### ä»£ç \r\n\r\n```python\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.cache = {}\r\n        self.cap = capacity\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.cache:\r\n            value = self.cache.pop(key)\r\n            self.cache[key] = value\r\n            return value\r\n        else:\r\n            return -1\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.cache:\r\n            self.cache.pop(key)\r\n        elif len(self.cache) == self.cap:\r\n            pop_key = list(self.cache.keys())[0]\r\n            self.cache.pop(pop_key)\r\n        self.cache[key] = value\r\n        return self\r\n```\r\n### å¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(1)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196884225","body":"### æ€è·¯\né€’å½’ï¼šæ ‘çš„é«˜åº¦ç­‰äºmax(å·¦å­æ ‘é«˜åº¦, å³å­æ ‘é«˜åº¦) + 1\n\n### ä»£ç \n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if root == None:\n            return 0\n        else:\n            return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\n```\n### å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(tree_height)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198298769","body":"### æ€è·¯\né€’å½’ï¼š1.éƒ½ä¸ºç©ºèŠ‚ç‚¹ï¼Œè¿”å›Trueï¼›2.ä¸€ä¸ªä¸ä¸ºç©ºï¼Œè¿”å›Falseï¼›3.å€¼ä¸ç›¸ç­‰ï¼Œè¿”å›Falseï¼›4.é€’å½’å·¦å³å­æ ‘\n\n### ä»£ç \n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n### å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(min(m, n))\n- ç©ºé—´å¤æ‚åº¦ï¼šO(min(m, n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1199767267","body":"### æ€è·¯\né€’å½’: dfs\n\n### ä»£ç \n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def dfs(self, root, val=0):\n        if not root:\n            return 0\n        val = val * 10 + root.val\n        if not root.left and not root.right:\n            return val\n        return self.dfs(root.left, val) + self.dfs(root.right, val)\n    \n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        return self.dfs(root, 0)\n```\n### å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1199792417","body":"### æ€è·¯\né€’å½’ï¼šä»å³å¾€å·¦BFSï¼Œæœ€åä¸€ä¸ªèŠ‚ç‚¹å³æ ‘å·¦ä¸‹è§’èŠ‚ç‚¹\n\n### ä»£ç \n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return None\n        queue = [root]\n        while queue:\n            node = queue.pop(0)\n            if node.right:\n                queue.append(node.right)\n            if node.left:\n                queue.append(node.left)\n        return node.val\n```\n### å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200451275","body":"### æ€è·¯\n\n\n### ä»£ç \n\n```python\nclass Codec:\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        ret = []\n        if not root:\n            return None\n        queue = [root]\n        while queue:\n            node = queue.pop(0)\n            ret.append(str(node.val))\n            if node.left:\n                queue.append(node.left)\n            else:\n                ret.append('#')\n            if node.right:\n                queue.append(node.right)\n            else:\n                ret.append('#')\n        print(ret)\n        return ','.join(ret)\n\n    def BuildTree(self, seq):\n        if len(seq) == 0:\n            return None\n        if seq[0] == '#':\n            return None\n        else:\n            val = int(seq[0])\n            node = TreeNode(val)\n            print(val)\n            self.left = self.BuildTree(seq[1:])\n            self.right = self.BuildTree(seq[2:])\n            return node\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        seq = data.split(',')\n        return self.BuildTree(seq)\n```\n### å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201392030","body":"### æ€è·¯\n\n\n\n### ä»£ç \n\n```python\nclass Solution:\n    def __init__(self):\n        self.max_col = 0\n        self.min_col = 0\n\n    def dfs_mark(self, root, row, col):\n        if root == None:\n            return\n        root.row = row\n        root.col = col\n        if col > self.max_col : self.max_col = col\n        if col < self.min_col : self.min_col = col\n        self.dfs_mark(root.left, row+1, col-1)\n        self.dfs_mark(root.right, row+1, col+1)\n    \n    def dfs(self, root, ret):\n        if not root:\n            return ret\n        col_id = root.col - self.min_col\n        insert_idx = 0\n        while insert_idx < len(ret[col_id]):\n            if root.val < ret[col_id][insert_idx]:\n                break\n            insert_idx += 1\n        ret[col_id].insert(insert_idx, root.val)\n        if col_id == 2:\n            print(ret[col_id])\n        self.dfs(root.left, ret)\n        self.dfs(root.right, ret)\n        return ret\n\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        self.dfs_mark(root, 0, 0)\n        ret = [[] for i in range(self.max_col - self.min_col + 1)]\n        return self.dfs(root, ret)\n```\n### å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202854744","body":"### æ€è·¯\nå“ˆå¸Œè¡¨å‚¨å­˜å·²ç»éå†çš„æ•°ï¼Œåˆ¤æ–­target-numæ˜¯å¦åœ¨å“ˆå¸Œè¡¨ä¸­\n\n\n### ä»£ç \n\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        pre_nums = []\n        for i, num in enumerate(nums):\n            if (target - num) in pre_nums:\n                return [pre_nums.index(target - num), i]\n            pre_nums.append(num)\n```\n### å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1204057313","body":"### æ€è·¯\néå†æ•°ç»„ç»Ÿè®¡å„æ•°å­—å‡ºç°æ¬¡æ•°ï¼Œå°é¡¶å †è®°å½•æ¬¡æ•°ï¼Œæœ€åéå†æ•°ç»„ï¼Œè¿”å›å‡ºç°æ¬¡æ•°å¤§äºå †é¡¶æ¬¡æ•°çš„æ•°å­—\n\n### ä»£ç \n\n```python\nimport heapq\n\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        num_count = dict()\n        for num in nums:\n            num_count[num] = num_count.get(num, 0) + 1\n        heap = []\n        for num, freq in num_count.items():\n            if len(heap) < k:\n                heapq.heappush(heap, freq)\n            else:\n                if freq > heap[0]:\n                    heapq.heapreplace(heap, freq)\n        return [num for num, freq in num_count.items() if freq >= heap[0]]\n```\n### å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(nlogk)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205426563","body":"### ä»£ç \n\n```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ret = 0\n        for a in points:\n            cnt = defaultdict(int)\n            for b in points:\n                dis = (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1])\n                cnt[dis] += 1\n            for x in cnt.values():\n                ret += x * (x-1)\n        return ret\n```\n### å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n^2)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206467494","body":"### æ€è·¯\næ»‘åŠ¨çª—å£\n\n### ä»£ç \n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        max_len, right = 0, 0\n        temp = set()\n        for left in range(len(s)):\n            while right < len(s) and s[right] not in temp:\n                temp.add(s[right])\n                right += 1\n            max_len = max(max_len, right - left)\n            temp.remove(s[left])\n\n        return max_len\n```\n### å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207238332","body":"### æ€è·¯\næ»‘åŠ¨çª—å£\n\n### ä»£ç \n\n```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        ret = []\n        for left in range(0, len(s)):\n            temp_words = {word:'' for word in words}\n            temp_s = ''\n            right = left\n            while temp_words and right < len(s):\n                temp_s += s[right]\n                find_word = ''\n                for word in words:\n                    if word in temp_s:\n                        find_word = word\n                        break\n                if find_word != '':\n                    del temp_words[find_word]\n                    if temp_s != find_word:\n                        break\n                    temp_s = ''\n                right += 1\n            if temp_s == '' and temp_words == {}:\n                ret.append(left)\n        return ret\n```\n### å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO()\n- ç©ºé—´å¤æ‚åº¦ï¼šO()","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207368337","body":"### æ€è·¯\nå‰ç¼€å’Œ+å“ˆå¸Œè¡¨\n\nmod_dict = {0:-1}æ˜¯é’ˆå¯¹å‰”é™¤å­ä¸²ä»å¤´å¼€å§‹çš„æƒ…å†µï¼Œå¦åˆ™æ‰¾ä¸åˆ°ä»å¤´å¼€å§‹çš„å­—ä¸²\n\n### ä»£ç \n\n```python\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        num_sum = sum(nums)\n        if num_sum < p: return -1\n        mod = num_sum % p\n        if mod == 0: return 0\n        num_len = len(nums)\n\n        min_len = num_len\n        mod_dict = {0:-1}\n        pre_sum = 0\n        for i in range(num_len):\n            pre_sum += nums[i]\n            cur_mod = pre_sum % p\n            target_mod = (cur_mod - mod + p) % p\n            if target_mod in mod_dict:\n                min_len = min(min_len, i - mod_dict[target_mod])\n            mod_dict[cur_mod] = i\n        return min_len if min_len != num_len else -1\n```\n### å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208290637","body":"### æ€è·¯\nå¿«æ…¢æŒ‡é’ˆ\n\n### ä»£ç \n\n```python\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        fast, slow = head, head\n        while fast != None and fast.next != None:\n            fast = fast.next.next\n            slow = slow.next\n        return slow\n```\n### å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209546123","body":"### æ€è·¯\r\nåŒæŒ‡é’ˆ\r\n\r\n### ä»£ç \r\n\r\n```python\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        if nums == []:\r\n            return 0\r\n        left, right = 1, 1\r\n        while right < len(nums):\r\n            if nums[right] != nums[right-1]:\r\n                nums[left] = nums[right]\r\n                left += 1\r\n            right += 1\r\n        return left\r\n```\r\n### å¤æ‚åº¦\r\n- æ—¶é—´å¤æ‚åº¦ï¼šO(n)\r\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawyuan97":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192279295","body":"## ä»£ç \r\n\r\n- è¯­è¨€æ”¯æŒï¼šPython3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        dummy_head = ListNode()\r\n        prev = dummy_head\r\n        while head and head.next:\r\n            first = head\r\n            second = first.next\r\n\r\n            prev.next = second\r\n            first.next = second.next\r\n            second.next = first\r\n            prev = first\r\n            \r\n            head = first.next\r\n        return dummy_head.next\r\n\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"victorhuang99":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192447685","body":"```\nCODE:\n\nvar swapPairs = function(head) {\n\n    let dumpHead = new ListNode(0, head);\n    let tmp = dumpHead;\n\n    while(tmp.next && tmp.next.next) {\n        let prev = tmp.next, cur = tmp.next.next.next;\n        \n        tmp.next = prev.next;\n        prev.next.next = prev;\n        prev.next = cur;\n\n        tmp = tmp.next.next;\n    }\n\n    return dumpHead.next;\n\n};\n\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196636144","body":"```\nvar maxDepth = function(root) {\n    let res = 0 // æœ€å¤§æ·±åº¦\n    // æ±‚æœ€å¤§æ·±åº¦ä½¿ç”¨æ·±åº¦ä¼˜å…ˆéå†ï¼›æ±‚æœ€å°æ·±åº¦ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆéå†\n    // lä»£è¡¨å½“å‰èŠ‚ç‚¹æ‰€åœ¨å±‚çº§\n    const dfs = (n, l) => {\n        if(!n) return\n        // åªåœ¨å¶å­èŠ‚ç‚¹æ—¶åšåˆ¤æ–­\n        if(!n.left && !n.right) {\n            res = Math.max(res, l)\n        }\n        dfs(n.left, l+1)\n        dfs(n.right, l+1)\n    }\n    dfs(root, 1)\n    return res\n};\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203355616","body":"```\nvar topKFrequent = function(nums, k) {\n    let len = nums.length;\n    let map = new Map();\n    //åšè¡¨ï¼Œç»Ÿè®¡å‡ºç°æ¬¡æ•°\n    for(let i = 0; i < len; i ++){\n        if(map.has(nums[i])){\n            let count = map.get(nums[i]);\n            map.set(nums[i],++count);\n        }else{\n            map.set(nums[i],1);\n        }\n    }\n    let arr = Array.from(map);//æ ¹æ®è¡¨ç”Ÿæˆæ•°ç»„\n    let res = [];\n    arr.sort((a,b) => b[1] - a[1]);//ä¾æ®å‡ºç°æ¬¡æ•°ä»å¤šåˆ°å°‘æ’åº\n    for(let j = 0; j < k; j++){\n        res.push(arr[j][0]);\n    }\n    return res;\n};\n\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/42#issuecomment-1210007829","body":"```\nvar searchInsert = function (nums, target) {\n    let result = nums.indexOf(target)\n    if (result === -1) {\n        for (let index in nums) {\n            if (nums[index] > target) return index\n            if(nums[nums.length-1] < target) return nums.length\n        }\n    } else {\n        return result\n    }\n};\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cusanity":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192590876","body":"public class Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode second = head.next;\n        ListNode third = second.next;\n        second.next = head;\n        head.next = swapPairs(third);\n        return second;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193111278","body":"class Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return buildHelper(head, null);\n    }\n    public TreeNode buildHelper(ListNode begin, ListNode end){\n        if(begin == end) return null;\n        ListNode mid = begin, fast = begin;\n        while(fast != end && fast.next != end){\n            mid = mid.next;\n            fast = fast.next.next;\n        }\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildHelper(begin, mid);\n        root.right = buildHelper(mid.next, end);\n        return root;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193300147","body":"## Solution\n\n```java\npublic class Solution {\n Â  Â public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n Â  Â  Â  Â if(headA == null || headB == null) return null;\n Â  Â  Â  Â ListNode pA = headA, pB = headB;\n Â  Â  Â  Â while(pA != pB){\n Â  Â  Â  Â  Â  Â pA = pA == null ? headB : pA.next;\n Â  Â  Â  Â  Â  Â pB = pB == null ? headA : pB.next;\n Â  Â  Â   }\n Â  Â  Â  Â return pA;\n Â   }\n}\n```\næ—¶é—´å¤æ‚åº¦: O(M+N)\nç©ºé—´å¤æ‚åº¦: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193892649","body":"## Solution\n```java\npublic class Solution {\n Â  Â public ListNode detectCycle(ListNode head) {\n Â  Â  Â  Â if(head == null) return null;\n Â  Â  Â  Â ListNode fast = head, slow = head;\n Â  Â  Â  Â Boolean found = false;\n Â  Â  Â  Â while(fast != null && fast.next != null){\n Â  Â  Â  Â  Â  Â slow = slow.next;\n Â  Â  Â  Â  Â  Â fast = fast.next.next;\n Â  Â  Â  Â  Â  Â if(slow == fast){\n Â  Â  Â  Â  Â  Â  Â  Â found = true;\n Â  Â  Â  Â  Â  Â  Â  Â break;\n Â  Â  Â  Â  Â   }\n Â  Â  Â   }\n Â  Â  Â  Â if(!found) return null;\n Â  Â  Â  Â slow = head;\n Â  Â  Â  Â while(slow != fast){\n Â  Â  Â  Â  Â  Â slow = slow.next;\n Â  Â  Â  Â  Â  Â fast = fast.next;\n Â  Â  Â   }\n Â  Â  Â  Â return slow;\n Â   }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194820126","body":"## Solution\n```java\nclass LRUCache {\n Â  Â int capacity;\n Â  Â LinkedHashMap<Integer, Integer> cache = new LinkedHashMap<>();\n Â  Â public LRUCache(int capacity) {\n Â  Â  Â  Â this.capacity = capacity;\n Â   }\n\n Â  Â public int get(int key) {\n Â  Â  Â  Â if (!cache.containsKey(key)) {\n Â  Â  Â  Â  Â  Â return -1;\n Â  Â  Â   }\n Â  Â  Â  Â makeMostRecent(key);\n Â  Â  Â  Â return cache.get(key);\n Â   }\nâ€‹\n Â  Â public void put(int key, int val) {\n Â  Â  Â  Â if (cache.containsKey(key)) {\n Â  Â  Â  Â  Â  Â cache.put(key, val);\n Â  Â  Â  Â  Â  Â makeMostRecent(key);\n Â  Â  Â  Â  Â  Â return;\n Â  Â  Â   }\n Â  Â  Â  Â if (cache.size() >= this.capacity) {\n Â  Â  Â  Â  Â  Â int LRU = cache.keySet().iterator().next();\n Â  Â  Â  Â  Â  Â cache.remove(LRU);\n Â  Â  Â   }\n Â  Â  Â  Â cache.put(key, val);\n Â   }\nâ€‹\n Â  Â private void makeMostRecent(int key) {\n Â  Â  Â  Â int val = cache.get(key);\n Â  Â  Â  Â cache.remove(key);\n Â  Â  Â  Â cache.put(key, val);\n Â   }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196892169","body":"## Solution\n```java\nclass Solution {\n Â  Â public int traverse(TreeNode root){\n Â  Â  Â  Â if(root == null) return 0;\n Â  Â  Â  Â if(root.left == null) return 1 + traverse(root.right);\n Â  Â  Â  Â if(root.right == null) return 1 + traverse(root.left); \n Â  Â  Â  Â return 1 + Math.max(traverse(root.right), traverse(root.left));\n Â   }\n Â  Â \n Â  Â public int maxDepth(TreeNode root) {\n Â  Â  Â  Â return traverse(root);\n Â   }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197999269","body":"## Solution\n```java\nclass Solution {\n Â  Â public boolean isSameTree(TreeNode p, TreeNode q) {\n Â  Â  Â  Â if(p == null && q == null) return true;\n Â  Â  Â  Â if(p == null && q != null) return false; Â  Â  Â  Â \n Â  Â  Â  Â if(p != null && q == null) return false;\n Â  Â  Â  Â if(p.val != q.val) return false;\n Â  Â  Â  Â return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n Â   }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198830966","body":"## Solution\n```java\nclass Solution {\n Â  Â public int sumNumbers(TreeNode root) {\n     Â  Â return helper(root, 0);\n Â   }\nâ€‹\n Â  Â public int helper(TreeNode root, int curr_sum){\n Â  Â  Â  Â if (root == null) return 0;\n Â  Â  Â  Â if (root.right == null && root.left == null) return curr_sum * 10 + root.val;\n Â  Â  Â  Â return helper(root.left, curr_sum * 10 + root.val) + helper(root.right, curr_sum * 10 + root.val);\n Â   }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200145832","body":"## Solution\n\nLanguage: **Java**\n\n```java\nclass Solution {\n Â  Â int maxDepth = 0;\n Â  Â int depth = 0;\n Â  Â TreeNode res = null;\n Â  Â public int findBottomLeftValue(TreeNode root) {\n Â  Â  Â  Â traverse(root);\n Â  Â  Â  Â return res.val;\n Â   }\nâ€‹\n Â  Â void traverse(TreeNode root) {\n Â  Â  Â  Â if (root == null) {\n Â  Â  Â  Â  Â  Â return;\n Â  Â  Â   }\n Â  Â  Â  Â depth++;\n Â  Â  Â  Â if (depth > maxDepth) {\n Â  Â  Â  Â  Â  Â maxDepth = depth;\n Â  Â  Â  Â  Â  Â res = root;\n Â  Â  Â   }\n Â  Â  Â  Â traverse(root.left);\n Â  Â  Â  Â traverse(root.right);\n Â  Â  Â  Â depth--;\n Â   }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201079625","body":"## Solution\n\nLanguage: **Java**\n\n```java\nclass Solution {\n Â  Â class Triple {\n Â  Â  Â  Â public int row, col;\n Â  Â  Â  Â public TreeNode node;\n Â  Â  Â  Â public Triple(TreeNode node, int row, int col) {\n Â  Â  Â  Â  Â  Â this.node = node;\n Â  Â  Â  Â  Â  Â this.row = row;\n Â  Â  Â  Â  Â  Â this.col = col;\n Â  Â  Â   }\n Â   }\nâ€‹\n Â  Â public List<List<Integer>> verticalTraversal(TreeNode root) {\n Â  Â  Â  Â traverse(root, 0, 0);\n Â  Â  Â  Â Collections.sort(nodes, (Triple a, Triple b) -> {\n Â  Â  Â  Â  Â  Â if (a.col == b.col && a.row == b.row) {\n Â  Â  Â  Â  Â  Â  Â  Â return a.node.val - b.node.val;\n Â  Â  Â  Â  Â   }\n Â  Â  Â  Â  Â  Â if (a.col == b.col) {\n Â  Â  Â  Â  Â  Â  Â  Â return a.row - b.row;\n Â  Â  Â  Â  Â   }\n Â  Â  Â  Â  Â  Â return a.col - b.col;\n Â  Â  Â   });\n Â  Â  Â  Â LinkedList<List<Integer>> res = new LinkedList<>();\n Â  Â  Â  Â int preCol = Integer.MIN_VALUE;\n Â  Â  Â  Â for (int i = 0; i < nodes.size(); i++) {\n Â  Â  Â  Â  Â  Â Triple cur = nodes.get(i);\n Â  Â  Â  Â  Â  Â if (cur.col != preCol) {\n Â  Â  Â  Â  Â  Â  Â  Â res.addLast(new LinkedList<>());\n Â  Â  Â  Â  Â  Â  Â  Â preCol = cur.col;\n Â  Â  Â  Â  Â   }\n Â  Â  Â  Â  Â  Â res.getLast().add(cur.node.val);\n Â  Â  Â   }\nâ€‹\n Â  Â  Â  Â return res;\n Â   }\nâ€‹\n Â  Â ArrayList<Triple> nodes = new ArrayList<>();\n Â  Â void traverse(TreeNode root, int row, int col) {\n Â  Â  Â  Â if (root == null) {\n Â  Â  Â  Â  Â  Â return;\n Â  Â  Â   }\n Â  Â  Â  Â nodes.add(new Triple(root, row, col));\n Â  Â  Â  Â traverse(root.left, row + 1, col - 1);\n Â  Â  Â  Â traverse(root.right, row + 1, col + 1);\n Â   }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201944760","body":"## Solution\n\nLanguage: **Java**\n\n```java\nclass Solution {\n Â  Â public int[] twoSum(int[] nums, int target) {\n Â  Â  Â  Â HashMap<Integer, Integer> valToIndex = new HashMap<>();\n Â  Â  Â  Â for (int i = 0; i < nums.length; i++) {\n Â  Â  Â  Â  Â  Â int need = target - nums[i];\n Â  Â  Â  Â  Â  Â if (valToIndex.containsKey(need)) {\n Â  Â  Â  Â  Â  Â  Â  Â return new int[]{valToIndex.get(need), i};\n Â  Â  Â  Â  Â   }\n Â  Â  Â  Â  Â  Â valToIndex.put(nums[i], i);\n Â  Â  Â   }\n Â  Â  Â  Â return null;\n Â   }\n}\nâ€‹\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203321086","body":"## Solution\n\nLanguage: **Java**\n\n```java\nclass Solution {\n Â  Â public int[] topKFrequent(int[] nums, int k) {\n Â  Â  Â  Â Map<Integer,Integer> map = new HashMap<>();\n Â  Â  Â  Â ArrayList<int[]> arr = new ArrayList<>();\n Â  Â  Â  Â for(int i=0;i<nums.length;i++){\n Â  Â  Â  Â  Â  Â if(!map.containsKey(nums[i])){\n Â  Â  Â  Â  Â  Â  Â  Â map.put(nums[i],arr.size());\n Â  Â  Â  Â  Â  Â  Â  Â int[] x = new int[2];\n Â  Â  Â  Â  Â  Â  Â  Â x[0]=nums[i];\n Â  Â  Â  Â  Â  Â  Â  Â arr.add(x);\n Â  Â  Â  Â  Â   }\n Â  Â  Â  Â  Â  Â arr.get(map.get(nums[i]))[1]++;\n Â  Â  Â   }\n Â  Â  Â  Â PriorityQueue<int[]> pq = new PriorityQueue<>((int[] a,int[] b) -> b[1]-a[1]);\n Â  Â  Â  Â for(int i=0;i<arr.size();i++){\n Â  Â  Â  Â  Â  Â pq.add(arr.get(i));\n Â  Â  Â   }\n Â  Â  Â  Â int[] ans = new int[k];\n Â  Â  Â  Â for(int i=0;i<k;i++){\n Â  Â  Â  Â  Â  Â ans[i]=pq.poll()[0];\n Â  Â  Â   }\n Â  Â  Â  Â return ans;\n Â   }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1204613067","body":"## Solution\n\nLanguage: **Java**\n\n```java\nclass Solution {\n Â  Â public int numberOfBoomerangs(int[][] points) {\n Â  Â  Â  Â int n = points.length;\n Â  Â  Â  Â int count = 0;\n Â  Â  Â  Â for (int i = 0; i < n; i++) {\n Â  Â  Â  Â  Â  Â HashMap < Double, Integer > map = new HashMap < > ();\n Â  Â  Â  Â  Â  Â int x1 = points[i][0];\n Â  Â  Â  Â  Â  Â int y1 = points[i][1];\n Â  Â  Â  Â  Â  Â for (int j = 0; j < n; j++) {\n Â  Â  Â  Â  Â  Â  Â  Â if (i == j) continue;\n Â  Â  Â  Â  Â  Â  Â  Â int x2 = points[j][0];\n Â  Â  Â  Â  Â  Â  Â  Â int y2 = points[j][1];\n Â  Â  Â  Â  Â  Â  Â  Â double dist = Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2);\n Â  Â  Â  Â  Â  Â  Â  Â if (map.containsKey(dist)) {\n Â  Â  Â  Â  Â  Â  Â  Â  Â  Â count += map.get(dist);\n Â  Â  Â  Â  Â  Â  Â  Â  Â  Â map.put(dist, map.get(dist) + 1);\n Â  Â  Â  Â  Â  Â  Â   } else {\n Â  Â  Â  Â  Â  Â  Â  Â  Â  Â map.put(dist, 1);\n Â  Â  Â  Â  Â  Â  Â   }\n Â  Â  Â  Â  Â   }\n Â  Â  Â   }\n Â  Â  Â  Â return count * 2;\n Â   }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1205821775","body":"## Solution\n\nLanguage: **Java**\n\n```java\nclass Solution {\n Â  Â public int lengthOfLongestSubstring(String s) {\n Â  Â  Â  Â HashSet<Character> used = new HashSet<>();\n Â  Â  Â  Â int left = 0;\n Â  Â  Â  Â int right = 0;\n Â  Â  Â  Â int max = 0;\n Â  Â  Â  Â int n = s.length();\n Â  Â  Â  Â while (right < n) {\n Â  Â  Â  Â  Â  Â char curr_ch = s.charAt(right);\n Â  Â  Â  Â  Â  Â if (used.contains(curr_ch)) {\n Â  Â  Â  Â  Â  Â  Â  Â while (s.charAt(left) != curr_ch) {\n Â  Â  Â  Â  Â  Â  Â  Â  Â  Â used.remove(s.charAt(left));\n Â  Â  Â  Â  Â  Â  Â  Â  Â  Â left++;\n Â  Â  Â  Â  Â  Â  Â   }\n Â  Â  Â  Â  Â  Â  Â  Â left++;\n Â  Â  Â  Â  Â   }\n Â  Â  Â  Â  Â  Â used.add(curr_ch);\n Â  Â  Â  Â  Â  Â max = Math.max(max, right - left + 1);\n Â  Â  Â  Â  Â  Â right++;\n Â  Â  Â  Â }\n Â  Â  Â  Â return max;\n Â   }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207134562","body":"## Solution\n\nLanguage: **Java**\n\n```java\npublic List<Integer> findSubstring(String s, String[] words) {\n Â  Â if (s == null || words == null || s.length() == 0 || words.length == 0) {\n Â  Â  Â  Â return new ArrayList<>();\n Â   }\n Â  Â Map<String, Integer> counts = new HashMap<>();\n Â  Â for (String word : words) {\n Â  Â  Â  Â counts.put(word, counts.getOrDefault(word, 0) + 1);\n Â   }\n Â  Â List<Integer> r = new ArrayList<>();\n Â  Â int sLen = s.length();\n Â  Â int num = words.length;\n Â  Â int wordLen = words[0].length();\n Â  Â for (int i = 0; i < sLen - num * wordLen + 1; i++) {\n Â  Â  Â  Â String sub = s.substring(i, i + num * wordLen);\n Â  Â  Â  Â if (isConcat(sub, counts, wordLen)) {\n Â  Â  Â  Â  Â  Â r.add(i);\n Â  Â  Â   }\n Â   }\n Â  Â return r;\n}\nprivate boolean isConcat(String sub, Map<String, Integer> counts, int wordLen) {\n Â  Â Map<String, Integer> seen = new HashMap<>();\n Â  Â for (int i = 0; i < sub.length(); i += wordLen) {\n Â  Â  Â  Â String sWord = sub.substring(i, i + wordLen);\n Â  Â  Â  Â seen.put(sWord, seen.getOrDefault(sWord, 0) + 1);\n Â   }\n Â  Â return seen.equals(counts);\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207298015","body":"## Solution\n\nLanguage: **Java**\n\n```java\nclass Solution {\n Â  Â public int minSubarray(int[] A, int p) {\n Â  Â  Â  Â int n = A.length, res = n, need = 0, cur = 0;\n Â  Â  Â  Â for (int a : A)\n Â  Â  Â  Â  Â  Â need = (need + a) % p;\n Â  Â  Â  Â Map<Integer, Integer> last = new HashMap<>();\n Â  Â  Â  Â last.put(0, -1);\n Â  Â  Â  Â for (int i = 0; i < n; ++i) {\n Â  Â  Â  Â  Â  Â cur = (cur + A[i]) % p;\n Â  Â  Â  Â  Â  Â last.put(cur, i);\n Â  Â  Â  Â  Â  Â int want = (cur - need + p) % p;\n Â  Â  Â  Â  Â  Â res = Math.min(res, i - last.getOrDefault(want, -n));\n Â  Â  Â   }\n Â  Â  Â  Â return res < n ? res : -1;\n Â   }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207523584","body":"## Solution\n\nLanguage: **Java**\n\n```java\nclass Solution {\n Â  Â public ListNode middleNode(ListNode head) {\n Â  Â  Â  Â if(head == null) return null;\n Â  Â  Â  Â ListNode slow = head, fast = head;\n Â  Â  Â  Â while(fast != null && fast.next != null){\n Â  Â  Â  Â  Â  Â fast = fast.next.next;\n Â  Â  Â  Â  Â  Â slow = slow.next;\n Â  Â  Â   }\n Â  Â  Â  Â return slow;\n Â   }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208805165","body":"## Solution\n\nLanguage: **Java**\n\n```java\nclass Solution {\n Â  Â public int removeDuplicates(int[] nums) {\n Â  Â  Â  Â int left = 0, right = 1;\n Â  Â  Â  Â while(right < nums.length){\n Â  Â  Â  Â  Â  Â if(nums[right] != nums[left]){\n Â  Â  Â  Â  Â  Â  Â  Â left++;\n Â  Â  Â  Â  Â  Â  Â  Â nums[left] = nums[right];\n Â  Â  Â  Â  Â   }\n Â  Â  Â  Â  Â  Â right++;\n Â  Â  Â   }\n Â  Â  Â  Â return left + 1;\n Â   }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/42#issuecomment-1209995950","body":"## Solution\n\nLanguage: **Java**\n\n```java\nclass Solution {\n Â  Â public int searchInsert(int[] nums, int target) {\n Â  Â  Â  Â int left = 0, right = nums.length - 1;\n Â  Â  Â  Â while(left <= right){\n Â  Â  Â  Â  Â  Â int mid = left + (right - left) / 2;\n Â  Â  Â  Â  Â  Â if(nums[mid] == target){\n Â  Â  Â  Â  Â  Â  Â  Â return mid;\n Â  Â  Â  Â  Â   }\n Â  Â  Â  Â  Â  Â if(nums[mid] > target){\n Â  Â  Â  Â  Â  Â  Â  Â right = mid - 1;\n Â  Â  Â  Â  Â   }\n Â  Â  Â  Â  Â  Â if(nums[mid] < target){\n Â  Â  Â  Â  Â  Â  Â  Â left = mid + 1;\n Â  Â  Â  Â  Â   }\n Â  Â  Â   }\n Â  Â  Â  Â return left;\n Â   }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jay-xzj":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192624895","body":"class Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummyHead = new ListNode(0);\n        dummyHead.next = head;\n        ListNode temp = dummyHead;\n        while (temp.next != null && temp.next.next != null) {\n            ListNode node1 = temp.next;\n            ListNode node2 = temp.next.next;\n            temp.next = node2;\n            node1.next = node2.next;\n            node2.next = node1;\n            temp = node1;\n        }\n        return dummyHead.next;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiradaone":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192671432","body":"### æ€è·¯\nè¿­ä»£\n\n### ä»£ç \n```c++\nclass Solution \n{\npublic:\n    ListNode* swapPairs(ListNode* head) \n    {\n        ListNode* p = new ListNode(0);\n        p->next = head;\n        ListNode* curr = p;\n        //å½“å‰èŠ‚ç‚¹æˆ–ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¸ºNULLï¼Œåˆ†åˆ«å¯¹åº”å¶æ•°å’Œå¥‡æ•°ä¸ªèŠ‚ç‚¹çš„ç»ˆæ­¢æ ‡å¿—\n        while(head != NULL && head->next != NULL)\n        {\n            ListNode* firstNode = head;\n            ListNode* secondNode = head->next;\n\n            curr->next = secondNode;\n            firstNode->next = secondNode->next;\n            secondNode->next = firstNode;\n\n            curr = firstNode;\n            head = firstNode->next;\n        }\n        return p->next;\n\n    }\n};\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„é•¿åº¦ã€‚\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194275949","body":"### æ€è·¯\nåŒæŒ‡é’ˆï¼Œå¿«æ…¢æŒ‡é’ˆ\nè®¾åŒæŒ‡é’ˆ fastï¼Œslow æŒ‡å‘é“¾è¡¨å¤´éƒ¨ head\n\n### ä»£ç \n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        auto fast=head,slow=head;\n        while(fast){\n            fast=fast->next;\n            slow=slow->next;\n            if(fast) fast=fast->next;\n            else break;\n\n            if(fast==slow){\n                fast=head;\n                while(fast!=slow){\n                    fast=fast->next;\n                    slow=slow->next;\n                }\n                return fast;\n            } \n        }\n        return NULL;\n    }\n};\n```\n\n**å¤æ‚åº¦åˆ†æ**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205421383","body":"### æ€è·¯\n\né€šè¿‡åµŒå¥—çš„forå¾ªç¯ï¼Œè®¡ç®—æ‰€æœ‰ç‚¹ä¸¤ä¸¤ä¹‹é—´çš„è·ç¦»ï¼Œç„¶åé€šè¿‡unordered_map(keyä¸ºç‚¹ä¹‹é—´çš„è·ç¦»ï¼Œvalueä¸ºè¯¥è·ç¦»çš„æ•°é‡\n\n### ä»£ç \n```c++\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        int res = 0;\n        for (const auto &p : points) {\n            unordered_map<int, int> dist2num;\n            for (const auto &q : points) {\n                int dx = p[0]-q[0];\n                int dy = p[1]-q[1];\n                ++dist2num[dx*dx+dy*dy];\n            }\n\n            for (const auto &x : dist2num) {\n                res += 1 * x.second * (x.second-1);\n            }\n        }\n        return res;\n    }\n};\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xinyue-ma":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192713188","body":"```\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        res = ListNode(next=head)\r\n        pre = res\r\n        while pre.next and pre.next.next:\r\n            cur = pre.next\r\n            post = pre.next.next            \r\n            cur.next = post.next\r\n            post.next = cur\r\n            pre.next = post\r\n            pre = pre.next.next\r\n        return res.next\r\n```","onTime":true},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200353821","body":"```\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: TreeNode) -> int:\r\n        queue = deque()\r\n        if root: \r\n            queue.append(root)\r\n        result = 0\r\n        while queue: \r\n            q_len = len(queue)\r\n            for i in range(q_len): \r\n                if i == 0: \r\n                    result = queue[i].val \r\n                cur = queue.popleft()\r\n                if cur.left: \r\n                    queue.append(cur.left)\r\n                if cur.right: \r\n                    queue.append(cur.right)\r\n        return result\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200353619","body":"```\r\nclass Codec:\r\n    def serialize(self, root):\r\n        if not root:\r\n            return 'None'\r\n        return str(root.val) + ',' + str(self.serialize(root.left)) + ',' + str(self.serialize(root.right))\r\n\r\n    def deserialize(self, data):\r\n        def dfs(datalist):\r\n            val = datalist.pop(0)\r\n            if val == 'None':\r\n                return None\r\n            root = TreeNode(int(val))\r\n            root.left = dfs(datalist)\r\n            root.right = dfs(datalist)\r\n            return root\r\n        datalist = data.split(',')\r\n        return dfs(datalist)\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207500034","body":"```\r\npublic int subarraysDivByK(int[] A, int K) {\r\n    int[] map = new int[K];\r\n    map[0] = 1;\r\n    int count = 0, sum = 0;\r\n    for (int a : A) {\r\n        sum = (sum + a) % K;\r\n        if (sum < 0) sum += K;  // Because -1 % 5 = -1, but we need the positive mod 4\r\n        map[sum]++;\r\n    }\r\n    for (int m : map) {\r\n        if (m == 0) continue;\r\n        count += m * (m - 1) / 2;\r\n    }\r\n    return count;\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207499871","body":"```\r\ndef middleNode(self, head: ListNode) -> ListNode:\r\n    fast = head\r\n    slow = head\r\n    while fast and fast.next:\r\n        slow = slow.next\r\n        fast = fast.next.next\r\n    return slow\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taojin1992":[null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193067204","body":"```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\n/*\r\n[1]:\r\n0-1\r\ns r\r\nf\r\n\r\n0   -1\r\ns    r  null\r\nf\r\n\r\n-> must deal with one node case\r\n\r\nO(n) for each level, O(logn) levels, Time: O(nlogn) \r\n\r\nspace: stack depth O(height), height-balanced, then O(logn), n = list length + tree space O(n)\r\n*/\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if (head == null) return null;\r\n        if (head.next == null) return new TreeNode(head.val, null, null);\r\n        \r\n        ListNode dummy = new ListNode(0, head);\r\n        ListNode slow = dummy, fast = dummy;\r\n        while (fast.next != null && fast.next.next != null) {\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        ListNode rootListNode = slow.next;\r\n        slow.next = null;\r\n        ListNode head2 = rootListNode.next;\r\n        rootListNode.next = null;\r\n        \r\n        TreeNode root = new TreeNode(rootListNode.val);\r\n        root.left = sortedListToBST(head);\r\n        root.right = sortedListToBST(head2);\r\n        return root;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/31#issuecomment-1200237623","body":"```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\n/*\nBFS, the leftmost value\n\nTime: O(n), n = number of nodes\nSpace: O(widest level) = O(n)\n\n\nDFS: find the first deepest node using preorder \nTime: O(n), n = number of nodes\nSpace: O(tree height)\n*/\nclass Solution {\n    \n    int maxDepth = -1;\n    int bottomLeftVal = -1;\n    \n    public int findBottomLeftValue(TreeNode root) {\n        preorder(root, -1);\n        return bottomLeftVal;\n    }\n\n    private void preorder(TreeNode curNode, int parentDepth) {\n        if (curNode == null) {\n            return;\n        }\n        int curDepth = parentDepth + 1;\n        if (curDepth > maxDepth) {\n            maxDepth = curDepth;\n            bottomLeftVal = curNode.val;\n        }\n        /*\n        System.out.println(\"cur at \" + curNode.val);\n        System.out.println(\"cur dep \" + curDepth);\n        System.out.println(\"bottomLeftVal = \" + bottomLeftVal);\n        */\n        preorder(curNode.left, curDepth);\n        preorder(curNode.right, curDepth);\n    }\n    \n    public int findBottomLeftValueBFS(TreeNode root) {\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        int bottomLeftVal = -1;\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode cur = queue.poll();\n                if (i == 0) {\n                    bottomLeftVal = cur.val;\n                }\n                if (cur.left != null) {\n                    queue.offer(cur.left);\n                }\n                if (cur.right != null) {\n                    queue.offer(cur.right);\n                }\n            }\n        }\n        return bottomLeftVal;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joyce94":[null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193140748","body":"```\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193334140","body":"```\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        ## æ‰¾åˆ°ä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦ï¼Œå¿«æ…¢æŒ‡é’ˆ \n        m, n = 0, 0 \n        pa, pb = headA, headB \n        while pa is not None:\n            pa = pa.next \n            m += 1 \n        while pb is not None:\n            pb = pb.next \n            n += 1 \n        len_abs = m - n \n\n        pa, pb = headA, headB \n        if len_abs < 0: # Aæ¯”BçŸ­ï¼ŒBå…ˆèµ°\n            len_abs = abs(len_abs)\n            while len_abs > 0:\n                pb = pb.next \n                len_abs -= 1 \n        else:\n            while len_abs > 0:\n                pa = pa.next\n                len_abs -= 1 \n        while pa is not None and pb is not None:\n            if pa == pb:\n                return pa \n            pa = pa.next \n            pb = pb.next \n        return None \n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200451851","body":"```\npublic class Codec {\n    public String serialize(TreeNode root) {\n        if (root == null) {\n            return \"\";\n        }\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\n        List<Integer> res = new LinkedList<Integer>();\n        queue.offer(root);\n        //BFS\n        while (!queue.isEmpty()) {\n            TreeNode curNode = queue.poll();\n            if (curNode != null) {\n                res.add(curNode.val);\n                queue.offer(curNode.left);\n                queue.offer(curNode.right);\n            } else {\n                res.add(null);\n            }\n        } \n        return res.toString();\n    }\n\n    public TreeNode deserialize(String data) {\n        if (data.length() == 0) {\n            return null;\n        }\n        //å°†å­—ç¬¦ä¸²è¿˜åŸä¸ºæ•°ç»„\n        String[] preStr = data.substring(1, data.length() - 1).split(\",\");\n        Integer[] bfsOrder = new Integer[preStr.length];\n        for (int i = 0; i < preStr.length; i++) {\n            if (preStr[i].trim().equals(\"null\")) {\n                bfsOrder[i] = null;\n            } else {\n                bfsOrder[i] = Integer.parseInt(preStr[i].trim());\n            }\n        }\n\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\n        TreeNode root = new TreeNode(bfsOrder[0]);\n        int cur = 1;//é€šè¿‡ cur æŒ‡é’ˆä¾æ¬¡ç»™èŠ‚ç‚¹èµ‹å€¼\n        queue.offer(root);\n        while (!queue.isEmpty()) { \n            TreeNode curNode = queue.poll();\n            if (bfsOrder[cur] != null) {\n                curNode.left = new TreeNode(bfsOrder[cur]);\n                queue.add(curNode.left);\n            }\n            cur++; \n            if (bfsOrder[cur] != null) {\n                curNode.right = new TreeNode(bfsOrder[cur]);\n                queue.add(curNode.right);\n            }\n            cur++;\n        }\n        return root;\n    }\n}\n\n```","onTime":false},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207330806","body":"```\nclass Solution:\n    def solve(self, nums, k):\n        # total sum, æ‰¾åˆ°æœ€å¤§çš„kçš„å€æ•°ï¼Œå¾—åˆ°éœ€è¦å»é™¤çš„subsumï¼Œå†æ±‚æœ€å°‘ä¸ªæ•° \n        total_sum = sum(nums)\n        div_num = total_sum // k \n        # nums_dic = collections.Counter(nums) \n        ## å‰ç¼€å’Œ \n        subsum_list = []\n        add = 0 \n        for num in nums:\n            add += num \n            subsum_list.append(add)\n        \n        min_len = len(nums) + 1 \n        while div_num > 0:\n            remove_sum = total_sum - div_num * k \n            if remove_sum == 0:     ### [1,2],k=3 \n                min_len = 0 \n                break \n            pre_subsum = collections.defaultdict(int)\n            for idx in range(len(subsum_list)):\n                subsum = subsum_list[idx]\n                if subsum == remove_sum:\n                    min_len = min(min_len, idx + 1) \n                if subsum - remove_sum in pre_subsum:\n                    min_len = min(min_len, idx - pre_subsum[subsum - remove_sum]) \n                pre_subsum[subsum] = idx \n            div_num -= 1 \n            \n        if min_len == len(nums) + 1:\n            return -1 \n        return min_len \n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"steven72574":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1206810213","body":"```\nimport java.util.ArrayList;\nimport java.util.*;\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new ArrayList<Integer>();\n        for(int i =num.length-1;i>=0;i--){\n            int sum = num[i]+k%10;\n            k/=10;\n            if(sum>=10){\n                k++;\n                sum-=10;\n            }\n            list.add(sum);\n\n        }\n        while(k!=0){\n            list.add(k%10);\n            k/=10;\n        }\n        Collections.reverse(list);\n        return list;\n    }\n}\n```\næ—¶é—´å¤æ‚åº¦O(n)\nç©ºé—´å¤æ‚åº¦O(n)","onTime":false},null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193207055","body":"**æ€è·¯**ï¼š\nåˆ©ç”¨åŒæŒ‡é’ˆï¼Œaå’Œbå…ˆæŒ‡å‘ä¸¤ä¸ªé“¾è¡¨çš„å¤´ï¼Œç„¶ååŒæ—¶å¾€åç§»åŠ¨ï¼Œå½“aèµ°åˆ°å°¾æ—¶ï¼Œé‡æ–°æŒ‡å‘bé“¾è¡¨çš„å¤´éƒ¨ï¼Œå½“bæŒ‡é’ˆèµ°åˆ°å°¾æ—¶ï¼Œé‡æ–°æŒ‡å‘aé“¾è¡¨çš„å¤´éƒ¨ï¼Œaå’Œbç›¸ç­‰çš„æ—¶ä¸ºä¸¤é“¾è¡¨ç›¸äº¤å¤„ã€‚\n\n**ä»£ç **\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        \n        ListNode a = headA;\n        ListNode b = headB;\n        while(a!=b){\n            a = a.next;\n            b = b.next;\n            if((a ==null) && (b==null)){\n                return null;\n            }\n            if(a == null){\n                a = headB;\n            }\n            if(b == null){\n                b = headA;\n            }\n        }\n        return a;\n    }\n}\n\n**æ—¶é—´å¤æ‚åº¦O(n)**\n\n**ç©ºé—´å¤æ‚åº¦O(1)**","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193904662","body":"**æ€è·¯**ç”¨å¿«æ…¢æŒ‡é’ˆï¼Œå¿«æŒ‡é’ˆä¸€æ¬¡èµ°ä¸¤æ­¥ï¼Œæ…¢æŒ‡é’ˆä¸€æ¬¡ä¸€æ­¥ï¼Œä¸¤æŒ‡é’ˆç¬¬ä¸€æ¬¡ç›¸é‡æ—¶ï¼Œå°†å¿«æŒ‡é’ˆå®šä½è‡³å¼€å¤´ï¼Œå¹¶ä¸”æ­¤åä¸€æ¬¡èµ°ä¸€æ­¥ï¼Œä¸¤æŒ‡é’ˆå†æ¬¡ç›¸é‡æ—¶åˆ™ä¸ºç¯çš„å…¥å£ã€‚\n\n**ä»£ç **\n\npublic class Solution {\n\n    public ListNode detectCycle(ListNode head) {\n\n        if(head == null || head.next == null){\n\n            return null;\n        }\n        ListNode fast = head ;\n        ListNode slow = head ;\n        do{\n            if(fast!=null && fast.next!=null){//ç§»åŠ¨æŒ‡é’ˆå‰åˆ¤æ–­å½“å‰ç»“ç‚¹æ˜¯å¦ä¸ºç©º\n                fast = fast.next.next ;\n                if(fast == null){\n                    return null;//ç§»åŠ¨åfastå¯èƒ½æŒ‡å‘ç©ºæŒ‡é’ˆï¼Œæ­¤æ—¶è¿”å›null\n                }\n            }\n            if(slow != null){//ç§»åŠ¨æŒ‡é’ˆå‰åˆ¤æ–­å½“å‰ç»“ç‚¹æ˜¯å¦ä¸ºç©º\n                slow = slow.next ;\n                \n            }\n        }\n        while(fast!=slow);\n        \n        fast = head;\n        while(fast!=slow){\n            if(fast!=null){\n            fast = fast.next ;\n            }else{return null;}\n            if (slow != null){\n                slow = slow.next ;\n            }else{return null;}\n        }\n        return fast;\n    }\n}\n\næ—¶é—´å¤æ‚åº¦O(n)\n\nç©ºé—´å¤æ‚åº¦O(1)\n\næ„Ÿå—æ¯”è¾ƒå¤§çš„æ˜¯è¾¹ç•Œæ¡ä»¶çš„åˆ¤æ–­éœ€è¦è€ƒè™‘å…¨é¢ï¼Œå¦‚åˆ¤æ–­å¤´æŒ‡é’ˆæ˜¯å¦ä¸ºç©ºï¼Œä»¥åŠæ¯æ¬¡ç§»åŠ¨æŒ‡é’ˆæ—¶éƒ½è¦åˆ¤æ–­å½“å‰æŒ‡é’ˆæ˜¯å¦ä¸ºç©ºï¼Œè¿™äº›è§£å†³åã€‚å‰©ä¸‹çš„åˆ™æ¯”è¾ƒå®¹æ˜“äº›ã€‚","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1207952768","body":"**æ€è·¯**é€’å½’\n\n**ä»£ç **\n```\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null){\n            return 0;\n\n        }\n        return Math.max(maxDepth(root.left),maxDepth(root.right))+1;\n    }\n}\n```\næ—¶é—´å¤æ‚åº¦Oï¼ˆnï¼‰, nä¸ºäºŒå‰æ ‘ç»“ç‚¹\nç©ºé—´å¤æ‚åº¦Oï¼ˆmï¼‰ï¼Œmä¸ºäºŒå‰æ ‘æ·±åº¦","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197993371","body":"\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n       if(p==null&&q==null)return true;\n       else if(p==null || q == null)return false;\n       else if(p.val!=q.val)\n       {return false;}\n       else{\n           return (isSameTree(p.left,q.left)&&isSameTree(p.right,q.right));\n       }\n       \n    }","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1201759846","body":"\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int diff = 0;\n        int[] result = new int[2];\n        \n        for(int x =0;x<nums.length;x++){\n            diff = target-nums[x];\n            for(int y = 0; y <nums.length;y++){\n                if(diff == nums[y]){\n                    if(x!=y){\n                        result[0]=x;\n                        result[1]=y;\n                        break;\n                    }\n                }\n\n            }\n        }\n        return result;\n    }\n}\næš´åŠ›è§£æ³•\næ—¶é—´å¤æ‚åº¦O(n*n)\nç©ºé—´å¤æ‚åº¦O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203800703","body":"æ€è·¯ï¼šå°†å‡ºç°é¢‘ç‡æ”¾å…¥å“ˆå¸Œå›¾ä¸­ï¼Œå¯¹å‡ºç°é¢‘ç‡è¿›è¡Œæ’åºï¼Œå¹¶å–å‰Kä¸ªï¼Œç„¶åæ‰¾åˆ°æ¯ä¸ªå‡ºç°é¢‘ç‡å¯¹åº”çš„å€¼ï¼›\nä»£ç ï¼š\nimport java.util.*;\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        HashMap<Integer,Integer> map = new HashMap<>();\n        //Hashmap<val,often>ï¼›\n        //å¾—åˆ°å€¼å‡ºç°é¢‘ç‡çš„å“ˆå¸Œå›¾ï¼›\n        for(int i =0;i<nums.length;i++){\n            if(map.containsKey(nums[i])){\n                map.compute(nums[i],(key,value)->value+1);\n            }else{\n                map.put(nums[i],1);\n            }\n        }\n        \n        //å¯¹å‡ºç°é¢‘ç‡è¿›è¡Œé™åºæ’åº\n        Integer[] times = new Integer[map.size()];\n        int idx = 0;\n        for(int each:map.values()){\n            times[idx]=each;\n            idx++;\n        }\n        Arrays.sort(times,Collections.reverseOrder());\n        \n        //å¯¹å“ˆå¸Œè¡¨éå†ï¼Œæ‰¾åˆ°å‡ºç°é¢‘ç‡æ’å‰kæ¬¡å¯¹åº”çš„å€¼\n        Set<Integer> result = new HashSet<>();\n        if(k<=times.length){\n            \n            for(int i =0;i<k;i++){\n                for(int each:map.keySet()){\n                    if(map.get(each)==times[i]){\n                        result.add(each);\n                    }\n                    \n                }\n            }\n        }else if(k>times.length){\n            for(int each:map.values()){\n                result.add(each);\n            }\n        \n        }\n        \n        int[] result_1 = new int[result.size()];\n        int i = 0;\n        for(int each:result){\n            result_1[i]=each;\n            i++;\n        }\n        return result_1;\n    }\n\n}\næ—¶é—´å¤æ‚åº¦O(mn)\nç©ºé—´å¤æ‚åº¦O(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207935665","body":"**æ€è·¯**\nå°†æ‰€æœ‰ç»“ç‚¹å­˜å…¥å“ˆå¸Œè¡¨ä»¥<ä½ç½®ï¼Œç»“ç‚¹>å­˜å‚¨ï¼Œå†è¿”å›ä¸­é—´å€¼ã€‚\n**ä»£ç **\n```\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        int i =1;\n        ListNode cur =head;\n        HashMap<Integer,ListNode> hashmap = new HashMap<>();\n        while(cur!=null){\n            hashmap.put(i,cur);\n            cur = cur.next;\n            i++;\n            \n            \n        }\n\n        \n        return hashmap.get(hashmap.size()/2+1);\n    \n    }\n}\n```\n**æ—¶é—´å¤æ‚åº¦**O(n),nä¸ºé“¾è¡¨é•¿åº¦\n**ç©ºé—´å¤æ‚åº¦**O(n)ï¼Œnä¸ºé“¾è¡¨é•¿åº¦ï¼Œç”¨äºå“ˆå¸Œè¡¨å­˜å‚¨é“¾è¡¨çš„å¼€é”€","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tian-pengfei":[null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193315147","body":"```c++\r\n\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n struct ListNode {\r\n     int val;\r\n     ListNode *next;\r\n     ListNode(int x) : val(x), next(NULL) {}\r\n };\r\n\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        ListNode *p_a = headA;\r\n        ListNode *p_b = headB;\r\n\r\n        while (p_a &&p_b){\r\n            p_a = p_a->next;\r\n            p_b = p_b->next;\r\n        }\r\n\r\n        ListNode *firstCommon = nullptr;\r\n\r\n        ListNode *p_a2 = headA;\r\n        ListNode *p_b2 = headB;\r\n\r\n        while (p_a!= nullptr){\r\n            p_a2 = p_a2->next;\r\n            p_a = p_a->next;\r\n        }\r\n        while (p_b!= nullptr){\r\n            p_b = p_b->next;\r\n            p_b2 = p_b2->next;\r\n        }\r\n\r\n        while (p_a2 &&p_b2){\r\n            if(p_a2==p_b2)\r\n                return p_a2;\r\n            p_a2 = p_a2->next;\r\n            p_b2 = p_b2->next;\r\n        }\r\n        return nullptr;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194079556","body":"```c++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        if(!head)return nullptr;\r\n\r\n        ListNode * final = new ListNode(0);\r\n        ListNode *slowPos = head;\r\n        ListNode *fastPos = head->next;\r\n        int t =1;\r\n        while (fastPos){\r\n            slowPos = slowPos->next;\r\n            t++;\r\n\r\n            fastPos = fastPos->next;\r\n            if(!fastPos)return nullptr;\r\n            fastPos = fastPos->next;\r\n            if(!fastPos)return nullptr;\r\n            //æ°¸è¿œæ˜¯æ•´æ•°æ—¶é—´èŠ‚ç‚¹è¿½ä¸Šä¸ºä»€ä¹ˆï¼Ÿ\r\n            if(fastPos==slowPos){\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!fastPos)return nullptr;\r\n\r\n        ListNode *slowPos2 = head;\r\n        slowPos = slowPos->next;\r\n        while (true){\r\n            if(slowPos2==slowPos)return slowPos2;\r\n            slowPos2 = slowPos2->next;\r\n            slowPos = slowPos->next;\r\n        }\r\n\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195408726","body":"```c++\r\n\r\nstruct DListNode {\r\n    int key;\r\n    int val;\r\n    DListNode *next;\r\n    DListNode *pre;\r\n    DListNode(int key,int value) :key(key), val(value), next(NULL) ,pre(NULL){}\r\n  };\r\n\r\nclass LRUCache {\r\n\r\nprivate:\r\n    DListNode *head = new DListNode(-1,-1);\r\n\r\n    DListNode *tail = new DListNode(-1,-1);\r\n    int capacity = 0;\r\n\r\n    map<int,DListNode*> _map;\r\n\r\n\r\npublic:\r\n    LRUCache(int capacity):capacity(capacity) {\r\n        head->next = tail;\r\n        tail->pre = head;\r\n    }\r\n\r\n    int get(int key) {\r\n        if(_map.find(key)!=_map.end()){\r\n\r\n            DListNode * node = _map[key];\r\n            deleteNode(node);\r\n            addNode(node);\r\n            return node->val;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    void put(int key, int value) {\r\n\r\n      int a= get(key);\r\n      if(a!=-1){\r\n          _map[key]->val = value;\r\n      } else{\r\n\r\n          //è¦åˆ é™¤\r\n          if(_map.size()==capacity){\r\n              int oldKey = deleteNode();\r\n              _map.erase(oldKey);\r\n          }\r\n          auto newNode = new DListNode(key,value);\r\n          _map[key] = newNode;\r\n          addNode(newNode);\r\n      }\r\n\r\n    }\r\n\r\n    void deleteNode(DListNode * node){\r\n        DListNode * pre = node->pre;\r\n        DListNode * next = node->next;\r\n\r\n        node->next = nullptr;\r\n        node->pre = nullptr;\r\n\r\n        pre->next = next;\r\n        next->pre = pre;\r\n\r\n    }\r\n\r\n    int deleteNode(){\r\n\r\n        int key = head->next->key;\r\n\r\n        deleteNode(head->next);\r\n        return key;\r\n    }\r\n\r\n    void addNode(DListNode * node){\r\n        DListNode * tailPre = tail->pre;\r\n\r\n        tailPre->next = node;\r\n        node->pre = tailPre;\r\n        node->next = tail;\r\n        tail->pre = node;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196474626","body":"```c++\n\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n\n        if(!root)return 0;\n\n        return max(maxDepth(root->left)+1,maxDepth(root->right)+1);\n    }\n\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197889088","body":"```c++\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p&&!q)return true;\n        if(!p||!q)return false;\n\n        return p->val==q->val&&isSameTree(p->left,q->left)&&isSameTree(p->right,q->right);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1200122445","body":"```c++\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n\n        int num = 1;\n        queue<TreeNode *> q;\n        q.push(root);\n        TreeNode *re;\n        while (num!=0){\n            int cyc_num = num;\n            num =0;\n            re = q.front();\n\n            for (int i = 0; i < cyc_num; ++i) {\n                TreeNode * node = q.front();\n                q.pop();\n                if(node->left){\n                    q.push(node->left);\n                    num++;\n                }\n                if(node->right){\n                    q.push(node->right);\n                    num++;\n                }\n            }\n        }\n\n        return re->val;\n    }\n};\n```","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1200964859","body":"```c++\nclass Solution {\npublic:\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        //           col row value\n        vector<tuple<int,int,int>> lst ;\n\n        preOrder(lst,root,0,0);\n        sort(lst.begin(),lst.end());\n\n        vector<vector<int>> re;\n        re.emplace_back();\n        int last_col = get<0>(lst[0]);\n        for (auto& t:lst){\n            int c_col = get<0>(t);\n            int val = get<2>(t);\n            if(last_col!=c_col){\n                re.emplace_back();\n                last_col = c_col;\n            }\n            re.rbegin()->emplace_back(val);\n        }\n\n        return re;\n\n    }\n\n    void preOrder(vector<tuple<int,int,int>>&lst,TreeNode *root,int col,int row){\n\n        if(!root)return;\n        lst.emplace_back(col,row,root->val);\n\n        preOrder(lst,root->left,col-1,row+1);\n        preOrder(lst,root->right,col+1,row+1);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202225520","body":"```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n\n        vector<int> re ;\n        for (int i = 0; i < nums.size()-1; ++i) {\n\n            int two = findOne(nums,target-nums[i],i+1);\n\n            if(two!=-1){\n                return vector<int>{i,two};\n            }\n        }\n        return re;\n\n    }\n\n\n    int findOne(vector<int> &nums,int target,int pos){\n\n        for (int i = pos;i<nums.size();i++){\n\n            if(nums[i]==target)return i;\n        }\n        return -1;\n    }\n\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203745407","body":"```c++\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n\n\n        sort(nums.begin(),nums.end());\n\n        priority_queue <pair<int,int>,vector<pair<int,int>>> q;\n        int count = 1;\n        int last_value = nums[0];\n        if(nums.size()==1){\n              q.push(make_pair(count,last_value));\n        }\n        for (int i = 1; i < nums.size(); ++i) {\n            if(last_value!=nums[i]){\n                q.push(make_pair(count,last_value));\n                last_value = nums[i];\n                count = 1;\n            }else{\n                count++;\n            }\n\n            if(i==nums.size()-1){\n                q.push(make_pair(count,last_value));\n\n            }\n        }\n\n        vector<int> re(k);\n        for (int i = 0; i < k; ++i) {\n            auto v = q.top();\n            q.pop();\n            re[i] = v.second;\n        }\n\n        return re;\n\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205015341","body":"```c++\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n\n        int size = points.size();\n        int count = 0;\n        vector<map<int,int>> same_distance(size,map<int,int>());\n\n        for (int i = 0; i < points.size(); ++i) {\n            for (int j = i+1; j < points.size(); ++j) {\n                int distance =  (points[i][0]-points[j][0])*(points[i][0]-points[j][0])\n                                                   +(points[i][1]-points[j][1])*(points[i][1]-points[j][1]);\n\n                same_distance[i][distance]++;\n\n                same_distance[j][distance]++;\n\n            }\n        }\n\n        for (int i = 0; i < same_distance.size(); ++i) {\n            for (auto & s_count:same_distance[i]){\n                if(s_count.second==1)continue;\n                count+= (Acount(s_count.second));\n            }\n        }\n        return count;\n    }\n\n//Cn2 *2 \n    int Acount(int i ){    \n        return i*(i-1);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206383680","body":"```c++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n\n        if(s.size()==0)return 0;\n\n       int longest = 1;\n\n       int pos1 = 0;\n       int pos2 = 1;\n       set<int> _set;\n       _set.insert(s[0]);\n        while (pos2<s.size()){\n            if(_set.count(s[pos2])){\n                _set.erase(s[pos1]);\n                pos1++;\n            }else{\n                _set.insert(s[pos2]);\n                pos2++;\n                longest = max(longest,pos2-pos1);\n            }\n        }\n\n        return longest;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207398985","body":"```c++\nint solve(vector<int>& nums, int k) {\n\n\n        long long sum,sum2 =0;\n        int ans = nums.size();\n        for (auto num:nums){\n            sum2+=num;\n        }\n        int d = sum2%k;\n        if(!d)return 0;\n\n        //(d1 -d2+k)%k = d\n        //  ä½™æ•°ï¼Œæœ€è¿‘ä¸€æ¬¡ä½ç½®\n        map<int,int> _map;\n        _map[0] = -1;\n        for (int i = 0; i < nums.size(); ++i) {\n            sum+=nums[i];\n            int d1 = sum%k;\n            int d2 = (d1-d+k)%k;\n            if(_map.count(d2)){\n                cout<<_map[d2];\n                 cout<< i;\n                cout<< d1;\n                cout<< d2;\n                ans = min(ans,i-_map[d2]);\n            }\n             _map[d1] = i;\n\n        }\n\n        if(ans==nums.size())return -1;\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207920888","body":"```c++\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n\n        ListNode * h =new ListNode();\n        h->next = head;\n\n        ListNode* p1 = h;\n        ListNode *p2 = h;\n\n        while (p2->next){\n            p1 = p1->next;\n            p2 = p2->next;\n            if(!p2->next){\n                return p1;\n            }\n            p2 = p2->next;\n        }\n\n        return p1->next;\n\n\n\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209129374","body":"```c++\n\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n\n        int p1=1;\n\n        int p2=1;\n\n        int c_val = nums[0];\n\n        while (p2<nums.size()){\n\n            if(nums[p2]==c_val){\n                p2++;\n            } else{\n                nums[p1] = nums[p2];\n                c_val = nums[p2];\n                p2++;\n                p1++;\n            }\n        }\n\n        return p1;\n\n\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asuka1h":[null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193367059","body":"```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        ListNode* inters = nullptr;\n        while(fast != nullptr && fast->next != nullptr ){\n            fast = fast->next->next;\n            slow = slow->next;\n            if(fast == slow){\n                inters = fast;\n                break;\n            }\n        }\n        \n        if(inters){\n            fast = head;\n            while(fast != slow){\n                fast = fast->next;\n                slow = slow->next;\n            }\n\n            return fast;\n        }\n        else{\n            return nullptr;\n        }\n        \n    }\n};\n\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200445775","body":"```Kotlin\n/**\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\n\nclass Codec() {\n\t// Encodes a URL to a shortened URL.\n    fun serialize(root: TreeNode?): String {\n        val q = LinkedList<TreeNode?>()\n        q.offer(root)\n        var str = StringBuilder()\n\n        while(!q.isEmpty()){\n            val top = q.poll()\n            \n            if(top != null){\n                q.offer(top.left)\n                q.offer(top.right)\n                str.append(top.`val`)\n            }\n            else{\n                str.append(\"#\")\n            }\n            str.append(\",\")\n        }\n        return str.toString()\n    }\n\n    // Decodes your encoded data to tree.\n    fun deserialize(data: String): TreeNode? {\n       if (data.isEmpty()) return null\n        val list = data.split(\",\")\n        if(list[0] == \"#\"){\n            return null;\n        }\n        val root = TreeNode(list[0].toInt())\n        val q = ArrayDeque<TreeNode>()\n        q.offer(root)\n        \n        var i = 1\n        while (i < list.size && !q.isEmpty()) {\n            val node = q.poll()\n            if (i < list.size && list[i] != \"#\") {\n                node.left = TreeNode(list[i].toInt())\n                q.offer(node.left)\n            }\n            i++\n            if (i < list.size && list[i] != \"#\") {\n                node.right = TreeNode(list[i].toInt())\n                q.offer(node.right)\n            }\n            i++           \n        }\n        return root\n    }\n}\n\n/**\n * Your Codec object will be instantiated and called as such:\n * var ser = Codec()\n * var deser = Codec()\n * var data = ser.serialize(longUrl)\n * var ans = deser.deserialize(data)\n */","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205283772","body":"```C++\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        // unordered_map<int,int> hashmap;\n        // for(int i = 0; i < points.size(); ++i){\n        //     // vector<int> curr;\n        //     // hashmap[i] = curr;\n        //     for(int j = 0; j < points.size();++j){\n        //         // if(i == j){\n        //         //     continue;\n        //         // }\n        //         int x = points[i][0] - points[j][0];\n        //         int y = points[i][1] - points[j][1];\n        //         int dis = (x*x)+y*y;\n        //         hashmap[dis]++;\n                 \n        //     }\n        // }\n         int cnt = 0;\n        for(auto i: points){\n           \n            unordered_map<int,int> hashmap;\n            for(auto j: points){\n                int x = i[0] - j[0];\n                int y = i[1] - j[1];\n                int dis = (x*x)+y*y;\n                hashmap[dis]++;\n            }\n            \n            for(auto i: hashmap){\n                cnt+=i.second*(i.second-1);\n            }\n        }\n        \n        return cnt;\n        //  for(auto const&[key,value]: hashmap){\n\n        //  }\n        // int retCnt = 0;\n        // for(auto const&[key,value]: hashmap){\n        //     cout << \"key : \" << key <<endl;\n        //     for(int j = 0; j< value.size()-2; ++j){\n        //         cout << value[j] << endl;\n        //         if(value[j] == value[j+1] && value[j+1] == value[j+2]){\n        //             retCnt++;\n        //         }\n        //     }\n        // }\n        // return retCnt;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206030791","body":"```C++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int ret = 0;\n        int begin = 0;\n        // vector<int> hash(26,0);\n        unordered_set<int> hash;\n        for(int i = 0; i < s.length(); ++i){\n            while(hash.count(s[i]) != 0){\n                hash.erase(s[begin]);\n                ++begin;\n            }\n          \n            ret = max(ret,i-begin+1);\n            hash.emplace(s[i]);\n           \n        }\n        return ret;\n    }\n};","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207485525","body":"```C++\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* fast = head;\n        ListNode* slow = head;\n        while(fast&& fast->next){\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaowangcoding":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185112936","body":"## æ€è·¯\n    å°†æ•°ç»„ä»åå¾€å‰åŠ ç»™k kæ¯æ¬¡å–ä½™ä½œä¸ºç»“æœ /10å‚ä¸ä¸‹ä¸€æ¬¡è¿ç®—\n## å¤æ‚åº¦\n    æ—¶é—´å¤æ‚åº¦ O(max(n,m)) m n ä¸ºæ•°ç»„çš„é•¿åº¦ å’Œkçš„é•¿åº¦ ç©ºé—´å¤æ‚åº¦ O(n)\n## ä»£ç \n```java\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> result = new LinkedList<>();\n        for (int i = num.length - 1; i >= 0; i--) {\n            k += num[i];\n            result.addFirst(k % 10);\n            k /= 10;\n        }\n        while (k > 0) {\n            result.addFirst(k % 10);\n            k /= 10;\n        }\n        return result;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186101492","body":"## æ€è·¯ \n     ä»å‰åˆ°åä¸€æ¬¡åˆ¤æ–­cå’Œå½“å‰ä½ç½®çš„è·ç¦» å†ä»åå¾€å‰åˆ¤æ–­cå’Œå½“å‰ä½ç½®çš„è·ç¦» å–è¾ƒå°çš„å€¼ä½œä¸ºç»“æœ\n## å¤æ‚åº¦\n    æ—¶é—´å¤æ‚åº¦O(n) ç©ºé—´å¤æ‚åº¦O(n)\n## ä»£ç \n```java\n  public int[] shortestToChar(String s, char c) {\n        char[] ss= s.toCharArray();\n        int[] result = new int[ss.length];\n        int temp = 1-s.length();\n        for(int i=0;i<ss.length;i++){\n            if(c!=ss[i]){\n                result[i] = i-temp;\n            }else{\n                temp = i;\n            }\n        }\n        temp= 0;\n        for(int i=result.length-1;i>=0;i--){\n            if(c!=ss[i]){\n                result[i] = Math.min(Math.abs(temp-i),result[i]);\n            }else{\n                temp = i;\n            }\n        }\n        return result;\n    }\n  ```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186520696","body":"## æ€è·¯\n\n    ä½¿ç”¨æ•°ç»„è®°å½•æ ˆçš„æ•°æ® ä½¿ç”¨ä¸€ä¸ªä¸‹æ ‡è®°å½•æ ˆæŒ‡é’ˆå½“å‰æ‰€åœ¨çš„ä½ç½® å‡ºå…¥æ ˆçš„æ—¶å€™å¤„ç†è¿™ä¸ªæ ˆæŒ‡é’ˆ\n\n## å¤æ‚åº¦\n\n    æ—¶é—´å¤æ‚åº¦O(n) ç©ºé—´å¤æ‚åº¦O(n)\n\n## ä»£ç \n\n```java\n    class CustomStack {\n    int[] stack;\n    int len;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        len=-1;\n    }\n\n    public void push(int x) {\n        if(len+1<stack.length){\n            len++;\n            stack[len] =x;\n\n        }\n    }\n\n    public int pop() {\n        if(len<0){\n            return -1;\n        }\n        len--;\n        return stack[len+1];\n    }\n\n    public void increment(int k, int val) {\n        int limit = Math.min(k, len + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187600669","body":"## æ€è·¯\n\n    ä½¿ç”¨æ ˆè®°å½•æ•°æ® å·¦æ‹¬å·å…¥æ ˆ æœ‰æ‹¬å·å‡ºæ ˆ æ•°å­—åˆ™åŠ å€\n\n## å¤æ‚åº¦\n\n    æ—¶é—´å¤æ‚åº¦O(n) ç©ºé—´å¤æ‚åº¦O(n)\n\n## ä»£ç \n\n```java\n class Solution {\n    public String decodeString(String s) {\n        Deque<Integer> stackNumber = new LinkedList<>();\n        Deque<String> stackString = new LinkedList<>();\n        StringBuilder stringBuilder = new StringBuilder();\n        int number = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '[') {\n                stackNumber.push(number);\n                number = 0;\n                stackString.push(stringBuilder.toString());\n                stringBuilder = new StringBuilder();\n            } else if (s.charAt(i) == ']') {\n                StringBuilder temp = new StringBuilder();\n                int curr_number = stackNumber.pop();\n                for (int j = 0; j < curr_number; j++) {\n                    temp.append(stringBuilder);\n                }\n                stringBuilder = temp.insert(0, stackString.pop());\n            } else if (s.charAt(i) > 47 && s.charAt(i) < 58) {\n                number = 10 * number + (s.charAt(i) - '0');\n            } else {\n                stringBuilder.append(s.charAt(i));\n            }\n        }\n        return stringBuilder.toString();\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189219881","body":"## æ€è·¯\n\n    ä½¿ç”¨åŒæ ˆè®°å½•æ•°æ®  å‹æ ˆå­˜æ•° ç¿»è½¬æ ˆå–æ•°\n\n## å¤æ‚åº¦\n\n    æ—¶é—´å¤æ‚åº¦O(1) ç©ºé—´å¤æ‚åº¦O(n)\n\n## ä»£ç \n\n```java\nclass MyQueue {\n        //å¤´æ ˆ\n        private Stack<Integer> headStack = new Stack<>();\n        //å°¾æ ˆ\n        private Stack<Integer> tailStack = new Stack<>();\n\n        public MyQueue() {\n        }\n\n        public void push(int x) {\n\n            headStack.push(x);\n        }\n\n        public int pop() {\n            if (tailStack.empty()) {\n                while (!headStack.empty()) {\n                    tailStack.push(headStack.pop());\n                }\n            }\n            return tailStack.pop();\n        }\n\n        public int peek() {\n            if (tailStack.empty()) {\n                while (!headStack.empty()) {\n                    tailStack.push(headStack.pop());\n                }\n            }\n            return tailStack.peek();\n        }\n\n        public boolean empty() {\n            return headStack.empty() && tailStack.empty();\n        }\n    }\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189967735","body":"## æ€è·¯\n\tå•è°ƒæ ˆ å°†æ•°ç»„é¦–ä¸ªå…¥æ ˆ å¯¹å…¶åçš„æ•°æ® å¤§äºç­‰äºå½“å‰æ ˆé¡¶åˆ™å…¥æ ˆ å°äºåˆ™å‡ºæ ˆä¸€ä¸ªå¹¶æ¯”è¾ƒä¸‹ä¸€ä¸ªæ ˆé¡¶ ç›´åˆ°å¤§äºç­‰äºæ ˆé¡¶æˆ–è€…æ ˆç©ºå†å…¥æ ˆ\n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ O(n) ç©ºé—´å¤æ‚åº¦O(n)\n## ä»£ç \n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Deque<Integer> stack = new LinkedList<>();\n        stack.push(arr[0]);\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] >= stack.peek()) {\n                stack.push(arr[i]);\n            } else {\n                Integer head = stack.pop();\n                while (stack.size() > 0 && arr[i] < stack.peek()) {\n                    stack.pop();\n                }\n                stack.push(head);\n            }\n        }\n        return stack.size();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191205570","body":"## æ€è·¯\n\tæˆç¯å†ç§»ä½\n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ O(n) ç©ºé—´å¤æ‚åº¦O(1)\n## ä»£ç \n\n```java\npublic ListNode rotateRight(ListNode head, int k) {\n        if(head==null){\n            return head;\n        }\n        ListNode temp = new ListNode(0, head);\n        //é“¾è¡¨é•¿åº¦\n        int len = 1;\n        //æˆç¯\n        while (head.next != null) {\n            head = head.next;\n            len++;\n        }\n        head.next = temp.next;\n        head = head.next;\n        //åç§»ç­‰äºé•¿åº¦- å‰ç§»ä½å’Œé•¿åº¦çš„ä½™æ•°\n        int number = len - k % len;\n        //ç§»ä½\n        while (number > 0) {\n            number--;\n            temp = head;\n            head = head.next;\n        }\n        temp.next = null;\n        return head;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192261271","body":"\n## æ€è·¯\n\tä¸¤ä¸¤äº¤æ¢ä½ç½® \n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ O(n) ç©ºé—´å¤æ‚åº¦O(1)\n## ä»£ç \n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode ans = new ListNode(0, head);\n        ListNode temp = ans;\n        while (head != null && head.next != null) {\n\t\t\t//å¤´æŒ‡é’ˆæŒ‡å‘2\n            ans.next = ans.next.next;\n            //1æŒ‡å‘3\n\t\t\thead.next= head.next.next;\n            //2æŒ‡å‘1\n\t\t\tans.next.next = head;\n            //å¤´æŒ‡é’ˆå†åç§»ä¸€ä½\n\t\t\thead = head.next;\n            //ä¸´æ—¶æŒ‡é’ˆåç§»ä¸¤ä½\n\t\t\tans= ans.next.next;\n        }\n        return temp.next;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193141648","body":"## æ€è·¯\n\tå¿«æ…¢æŒ‡é’ˆ å¿«æŒ‡é’ˆç§»åŠ¨ä¸¤æ¬¡ æ…¢æŒ‡é’ˆç§»åŠ¨ä¸€æ¬¡ å¿«æŒ‡é’ˆç§»åŠ¨åˆ°å°¾éƒ¨çš„æ—¶å€™æ…¢æŒ‡é’ˆä¸ºä¸­ä½æ•°\n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)  ç©ºé—´å¤æ‚åº¦ï¼šO(logn)\n## ä»£ç \n\n```java\n\nclass Solution {\n      public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head, null);\n    }\n\n    public TreeNode buildTree(ListNode left, ListNode right) {\n        if (left == right) {\n            return null;\n        }\n        ListNode mid = getMedian(left, right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left, mid);\n        root.right = buildTree(mid.next, right);\n        return root;\n    }\n\n    public ListNode getMedian(ListNode left, ListNode right) {\n        ListNode fast = left;\n        ListNode slow = left;\n        while (fast != right && fast.next != right) {\n            fast = fast.next;\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193285203","body":"## æ€è·¯\n\tå¿«æ…¢æŒ‡é’ˆ å¿«æŒ‡é’ˆç§»åŠ¨ä¸¤æ¬¡ æ…¢æŒ‡é’ˆç§»åŠ¨ä¸€æ¬¡  ç­‰å¿«æŒ‡é’ˆå’Œæ…¢æŒ‡é’ˆç›¸é‡çš„æ—¶å€™æœ‰é‡åˆ\n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)  ç©ºé—´å¤æ‚åº¦ï¼šO(logn)\n## ä»£ç \n\n```java\n\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode tailA = headA;\n        ListNode tailB = headB;\n        while(tailA!=tailB){\n            tailA = tailA==null?headB:tailA.next;\n            tailB = tailB == null? headA:tailB.next;\n        }\n        return tailA;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193499293","body":"## æ€è·¯\n\tå¿«æ…¢æŒ‡é’ˆ å­˜åœ¨ç¯çš„æ—¶å€™ä½¿ç”¨ä¸´æ—¶æŒ‡é’ˆä»å¤´å¼€å§‹å’Œæ…¢æŒ‡é’ˆä¸€ç›´ä¾¿åˆ© ç›¸é‡æ—¶ä¸ºç»“æœ \n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ O(n) ç©ºé—´å¤æ‚åº¦O(1)\n## ä»£ç \n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return null;\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n        ListNode temp = null;\n        while (fast.next != null && fast.next.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) {\n                temp = head;\n                break;\n            }\n        }\n        if (temp == null) {\n            return null;\n        }\n        while (temp != slow) {\n            temp = temp.next;\n            slow = slow.next;\n        }\n        return temp;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195189242","body":"\n## æ€è·¯\n\tä»¿LinkedHashMapçš„æ€è·¯ map+åŒé“¾è¡¨ \n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ O(n) ç©ºé—´å¤æ‚åº¦O(1)\n## ä»£ç \n\n```java\n class LRUCache {\n        Map<Integer, DoubleListNode> cache;\n        int max;\n        int len;\n        DoubleListNode head;\n        DoubleListNode tail;\n\n        public LRUCache(int capacity) {\n            cache = new HashMap<>(capacity);\n            max = capacity;\n            head = tail = null;\n            len = 0;\n        }\n\n        public int get(int key) {\n            DoubleListNode ans = cache.get(key);\n            if(ans == null){\n                return -1;\n            }\n            moveToLast(ans);\n            return ans.getValue();\n        }\n\n        public void put(int key, int value) {\n            DoubleListNode doubleListNode = cache.get(key);\n            if (doubleListNode == null) {\n                DoubleListNode temp = new DoubleListNode(key, value);\n                if (max == len) {\n                    DoubleListNode headTemp = head;\n                    if (head == tail) {\n                        head = tail = null;\n                    } else {\n                        head = head.getAfter();\n                        head.setBefore(null);\n                        headTemp.setAfter(null);\n                    }\n                    cache.remove(headTemp.getKey());\n                    len--;\n                }\n                cache.put(key, temp);\n                moveToLast(temp);\n                len++;\n            } else {\n                doubleListNode.setKeyValue(key, value);\n                moveToLast(doubleListNode);\n            }\n        }\n\n        private void moveToLast(DoubleListNode temp) {\n            //åˆ†å››ç§æƒ…å†µ\n            //æ–°å¢çš„ å‰èŠ‚ç‚¹ä¸ºå°¾èŠ‚ç‚¹ å°¾èŠ‚ç‚¹=è¿™ä¸ªèŠ‚ç‚¹\n            //å¤´èŠ‚ç‚¹ ä¸‹ä¸€ä¸ªèŠ‚ç‚¹å˜ä¸ºå¤´èŠ‚ç‚¹ ä¸‹ä¸€èŠ‚ç‚¹ç½®ç©º å‰èŠ‚ç‚¹ä¸ºå°¾èŠ‚ç‚¹ å°¾èŠ‚ç‚¹=è¿™ä¸ªèŠ‚ç‚¹\n            //å°¾èŠ‚ç‚¹ ä¸åŠ¨\n            //ä¸­é—´èŠ‚ç‚¹ è®°å½•å‰åèŠ‚ç‚¹ è°ƒè½¬å‰åèŠ‚ç‚¹çš„æŒ‡å‘ åèŠ‚ç‚¹ç½®ç©º å‰èŠ‚ç‚¹ä¸ºå°¾èŠ‚ç‚¹ å°¾èŠ‚ç‚¹=è¿™ä¸ªèŠ‚ç‚¹\n            if (temp.getBefore() == null) {\n                if (head == null) {\n                    head = tail = temp;\n                    return ;\n                }\n                if (temp.getAfter() != null) {\n                    //å¤´èŠ‚ç‚¹\n                    head = head.getAfter();\n                    head.setBefore(null);\n                    temp.setAfter(null);\n                }\n                tail.setAfter(temp);\n                temp.setBefore(tail);\n                tail = temp;\n            }else {\n                if (temp.getAfter() != null) {\n                    //ä¸­é—´èŠ‚ç‚¹\n                    DoubleListNode after = temp.getAfter();\n                    DoubleListNode before = temp.getBefore();\n                    before.setAfter(after);\n                    after.setBefore(before);\n                    temp.setAfter(null);\n                    tail.setAfter(temp);\n                    temp.setBefore(tail);\n                    tail = temp;\n                }\n            }\n        }\n\n        class DoubleListNode {\n            private DoubleListNode before;\n            private Integer key;\n            private Integer value;\n            private DoubleListNode after;\n\n            public DoubleListNode(Integer key, Integer value) {\n                this.key = key;\n                this.value = value;\n                this.before = null;\n                this.after = null;\n            }\n\n            public DoubleListNode(DoubleListNode before, Integer key, Integer value, DoubleListNode after) {\n                this.key = key;\n                this.value = value;\n                this.before = before;\n                this.after = after;\n            }\n\n            public DoubleListNode getBefore() {\n                return before;\n            }\n\n            public DoubleListNode getAfter() {\n                return after;\n            }\n\n            public void setAfter(DoubleListNode after) {\n                this.after = after;\n            }\n\n            public void setBefore(DoubleListNode before) {\n                this.before = before;\n            }\n\n            public Integer getKey() {\n                return key;\n            }\n\n            public Integer getValue() {\n                return value;\n            }\n\n            public void setKeyValue(Integer key, Integer value) {\n                this.key = key;\n                this.value = value;\n            }\n        }\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196156669","body":"\n## æ€è·¯\n\té€’å½’\n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ O(n) ç©ºé—´å¤æ‚åº¦O(1)\n## ä»£ç \n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root==null){\n        \treturn 0;\n\t\t}\n        return Math.max(getDeep(root.left,0),getDeep(root.right,0))+1;\n    }\n\n    public int getDeep(TreeNode tree,int deep){\n        if(tree==null){\n            return deep;\n        }\n        return Math.max(getDeep(tree.left,deep),getDeep(tree.right,deep))+1;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197535109","body":"\n## æ€è·¯\n\té€’å½’\n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ O(n) ç©ºé—´å¤æ‚åº¦O(1)\n## ä»£ç \n\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null&&q==null){\n            return true;\n        }\n        if(p==null||q==null){\n            return false;\n        }\n        if(q.val!=p.val){\n            return false;\n        }\n        return isSameTree(p.left,q.left)&isSameTree(p.right,q.right);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/30#issuecomment-1198758044","body":"\n## æ€è·¯\n\tBFS ä¸‹ä¸€å±‚èŠ‚ç‚¹çš„å€¼ += ä¸Šä¸€å±‚èŠ‚ç‚¹çš„å€¼*10\n## å¤æ‚åº¦\n\tæ—¶é—´å¤æ‚åº¦ O(n) ç©ºé—´å¤æ‚åº¦O(n)\n## ä»£ç \n\n```java\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        List<TreeNode> treeNodeList = new LinkedList<>();\n        int ans = 0;\n        treeNodeList.add(root);\n        while(treeNodeList.size()>0){\n            int len = treeNodeList.size();\n            for(int i=0;i<len;i++){\n                TreeNode temp = treeNodeList.remove(0);\n                if(temp.right ==null && temp.left==null){\n                    ans += temp.val;\n                }\n                if(temp.left!=null){\n                    temp.left.val += temp.val*10;\n                    treeNodeList.add(temp.left);\n                }\n                if(temp.right!=null){\n                    temp.right.val += temp.val*10;\n                    treeNodeList.add(temp.right);\n                }\n            }\n        }\n        return ans;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"james0608":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1200112910","body":"é¢˜ç›®åç§°ï¼š[989. æ•°ç»„å½¢å¼çš„æ•´æ•°åŠ æ³•](https://leetcode.cn/problems/add-to-array-form-of-integer/)\r\né¢˜ç›®æ€è·¯ï¼š\r\n- é”™è¯¯è§£æ³•ï¼šå°†numè½¬æ¢ä¸ºintï¼Œç›´æ¥ä¸kç›¸åŠ ï¼Œæœ‰æº¢å‡ºçš„é£é™©\r\n- å¯è¡Œè§£æ³•ï¼šå°†kè½¬æ¢ä¸º[]intï¼Œéå†numä¸num2ï¼Œæ³¨æ„ç›¸åŠ æ—¶è®°å½•è¿›ä½\r\n- ç±»ä¼¼é¢˜ï¼š[2. ä¸¤æ•°ç›¸åŠ ](https://leetcode.cn/problems/add-two-numbers/)\r\n\r\nè§£é¢˜ä»£ç ï¼š\r\n```go\r\nfunc addToArrayForm(num []int, k int) []int {\r\n    var num2 []int\r\n    for k!=0 {\r\n        num2 = append([]int{k%10}, num2...)\r\n        k /= 10\r\n    }\r\n    var result []int\r\n    var carry int\r\n    for len(num)!=0||len(num2)!=0||carry>0 {\r\n        number1, number2 := 0, 0\r\n        if len(num) > 0 {\r\n            number1 = num[len(num)-1]\r\n            num = num[0:len(num)-1]\r\n        }\r\n        if len(num2) > 0 {\r\n            number2 = num2[len(num2)-1]\r\n            num2 = num2[0:len(num2)-1]\r\n        }\r\n        sum := number1 + number2 + carry\r\n        carry = sum/10\r\n        result = append([]int{sum%10}, result...)\r\n    }\r\n    return result\r\n}\r\n```\r\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\r\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200439144","body":"é¢˜ç›®åç§°ï¼š[297. äºŒå‰æ ‘çš„åºåˆ—åŒ–ä¸ååºåˆ—åŒ–](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)\r\n\r\nè§£é¢˜æ€è·¯ï¼šåºåˆ—åŒ–æ—¶ä½¿ç”¨DFSä¸­çš„å‰åºéå†ï¼Œé‡åˆ°ç©ºèŠ‚ç‚¹æ—¶ä½¿ç”¨nullè¡¥ä½ï¼›ååºåˆ—åŒ–æ—¶ï¼Œæ ¹æ® , æŠŠåŸå…ˆçš„åºåˆ—åˆ†å‰²å¼€æ¥å¾—åˆ°å…ˆåºéå†çš„å…ƒç´ åˆ—è¡¨ï¼Œç„¶åä»å·¦å‘å³éå†è¿™ä¸ªåºåˆ—\r\n\r\nè§£é¢˜ä»£ç ï¼š\r\n```go\r\n/**\r\n * Definition for a binary tree node.\r\n * type TreeNode struct {\r\n *     Val int\r\n *     Left *TreeNode\r\n *     Right *TreeNode\r\n * }\r\n */\r\n\r\ntype Codec struct {\r\n}\r\n\r\nfunc Constructor() Codec {\r\n    return Codec{}\r\n}\r\n\r\n// Serializes a tree to a single string.\r\nfunc (this *Codec) serialize(root *TreeNode) string {\r\n    sb := &strings.Builder{}\r\n    var preorder func(*TreeNode)\r\n    preorder = func(node *TreeNode) {\r\n        if node == nil {\r\n            sb.WriteString(\"null,\")\r\n            return\r\n        }\r\n        sb.WriteString(strconv.Itoa(node.Val))\r\n        sb.WriteString(\",\")\r\n        preorder(node.Left)\r\n        preorder(node.Right)\r\n    }\r\n    preorder(root)\r\n    return sb.String()\r\n}\r\n\r\n// Deserializes your encoded data to tree.\r\nfunc (this *Codec) deserialize(data string) *TreeNode {\r\n    sp := strings.Split(data, \",\")\r\n    var build func() *TreeNode\r\n    build = func() *TreeNode {\r\n        if sp[0] == \"null\" {\r\n             sp = sp[1:]\r\n            return nil\r\n        }\r\n        val, _ := strconv.Atoi(sp[0])\r\n        sp = sp[1:]\r\n        return &TreeNode{val, build(), build()}\r\n    }\r\n    return build()\r\n}\r\n```\r\n\r\næ—¶é—´å¤æ‚åº¦ï¼šO(N)\r\n\r\nç©ºé—´å¤æ‚åº¦ï¼šO(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202658473","body":"```go\r\nfunc twoSum(nums []int, target int) []int {\r\n    numMap := make(map[int]int)\r\n    for index, num := range nums {\r\n        sub := target - num;\r\n        if i, isExist := numMap[sub];!isExist {\r\n            numMap[num] = index;\r\n        } else {\r\n            return []int{i, index};\r\n        }\r\n    }\r\n    return []int{};\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaneyang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200425293","body":"# æ€è·¯\r\n### Binary Tree + BFS + Queue\r\n\r\n# ä»£ç \r\n\r\n<!---\r\nDefinition for a binary tree node.\r\nclass TreeNode(object):\r\n    def __init__(self, x):\r\n        self.val = x\r\n        self.left = None\r\n        self.right = None\r\n-->\r\n\r\n```\r\nfrom collections import deque\r\nclass Codec:\r\n\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n\r\n        if not root:\r\n            return \"\"\r\n        res = []\r\n        dq = deque([root])\r\n        while dq:\r\n            elem = dq.popleft()\r\n            if elem:\r\n                res.append(str(elem.val))\r\n                dq.append(elem.left)\r\n                dq.append(elem.right)\r\n            else:\r\n                res.append('None')\r\n        return '[' + ','.join(res) + ']'\r\n\r\n    \r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        if not data:\r\n            return []\r\n        data_list = data[1:-1].split(',')\r\n        root = TreeNode(int(data_list[0]))\r\n        dq = deque([root])\r\n        idx = 1\r\n        while dq:\r\n            elem = dq.popleft()\r\n            if data_list[idx] != 'None':\r\n                elem.left = TreeNode(int(data_list[idx]))\r\n                dq.append(elem.left)\r\n            idx += 1\r\n            if data_list[idx] != 'None':\r\n                elem.right = TreeNode(int(data_list[idx]))\r\n                dq.append(elem.right)\r\n            idx += 1\r\n        \r\n        return root\r\n\r\n```\r\n        \r\n# å¤æ‚åº¦åˆ†æ\r\n#### æ—¶é—´å¤æ‚åº¦: O(n)\r\n#### ç©ºé—´å¤æ‚åº¦: O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201360654","body":"## æ€è·¯\r\n### In-Order DFS + Stack\r\n### å…ˆéå†æ•´ä¸ªæ ‘ï¼Œå…¶æ¬¡æŒ‰ç…§col,row,value æ’åºï¼Œæœ€åæ‰¾åˆ°ç›¸åŒåˆ—çš„èŠ‚ç‚¹æ”¾å…¥åŒä¸€ä¸ªåˆ—è¡¨\r\n\r\n## ä»£ç \r\n\r\n```\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n\r\nclass Solution:\r\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\r\n        nodes = []\r\n        \r\n        # Step1: Traverse the tree\r\n        def dfs(node: TreeNode, row: int, col: int) -> None:\r\n            if not node:\r\n                return\r\n            \r\n            nodes.append((col, row, node.val))\r\n            dfs(node.left, row - 1, col - 1)\r\n            dfs(node.right, row + 1, col - 1)\r\n        \r\n        dfs(root, 0, 0)\r\n        \r\n        # Step2: Sort the tree by column, row, value\r\n        nodes.sort()\r\n        \r\n        # Step3:  Put the nodes in the same column into a single list\r\n        ans, lastcol = [], float('-inf')\r\n        \r\n        for col, row, value in nodes:\r\n            if col != lastcol:\r\n                lastcol = col\r\n                ans.append([])\r\n            ans[-1].append(value)\r\n            \r\n        return ans\r\n```\r\n\r\n## å¤æ‚åº¦åˆ†æ\r\n### æ—¶é—´å¤æ‚åº¦: O(nlogn)\r\n### ç©ºé—´å¤æ‚åº¦: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202270800","body":"## æ€è·¯\r\n### Hash Table\r\n### ç”¨å­—å…¸åˆ›å»ºå“ˆå¸Œè¡¨å­˜å‚¨æ•°å­—å’Œä½ç½®ä½œä¸ºKey Value Pairsï¼Œå“ˆå¸Œè¡¨çš„æŸ¥è¯¢æ—¶é—´æ˜¯O(1)ï¼Œä»£æ›¿äº†éå†æŸ¥è¯¢çš„O(n)ä»¥åŠä¸¤ä¸ªfor loopã€‚\r\n### ifçš„ç”¨æ³•ï¼Œéå†æ•°æ®ï¼Œå¯¹æ¯ä¸€ä¸ªå‡ºç°çš„ num åˆ¤æ–­å…¶å¦ä¸€åŠ target - num æ˜¯å¦ä¹Ÿå‡ºç°åœ¨å“ˆå¸Œè¡¨ä¸­ã€‚å¦‚æœå“ˆå¸Œè¡¨ä¸ºç©ºï¼Œåˆ™å­˜å…¥å½“å‰çš„æ•°å­—å’Œä½ç½®ã€‚\r\n\r\n## ä»£ç \r\n```\r\nfrom typing import List\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        hashtable = {}\r\n        for i, num in enumerate(nums):\r\n            if (target - num) in hashtable:\r\n                return [hashtable[(target - num)], i]\r\n            hashtable[nums[i]] = i\r\n        return []\r\n```\r\n\r\n## å¤æ‚åº¦åˆ†æ\r\n### æ—¶é—´å¤æ‚åº¦: O(n) + O(1) = O(n)\r\n### ç©ºé—´å¤æ‚åº¦: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203823407","body":"## æ€è·¯\r\n### Hash Table + min-heap/Sorting\r\n### ç”¨å­—å…¸åˆ›å»ºå“ˆå¸Œè¡¨å­˜å‚¨æ•°å­—å’Œå‡ºç°æ¬¡æ•°ä½œä¸ºKey Value Pairsã€‚\r\n### å“ˆå¸Œè¡¨çš„åˆ›å»ºæ—¶é—´å¤æ‚åº¦ä¸ºO(n)ã€‚ä½†æ˜¯å…³é”®æ˜¯æ’åºSortingçš„æ—¶é—´å¤æ‚åº¦å½±å“äº†æ•´ä½“ç®—æ³•çš„æ€§èƒ½ã€‚æ ¹æ®é¢˜ç›®è¦æ±‚ï¼Œéœ€è¦æ‰¾åˆ°æ’åºç®—æ³•æ—¶é—´å¤æ‚åº¦ä¼˜äºO(nlogn)ï¼Œåœ¨æœ€å¥½æƒ…å†µä¸‹å¯ä»¥é€‰æ‹©å¿«é€Ÿæ’åºç®—æ³•O(nlogn), ä½†æœ€åçš„æƒ…å†µæ˜¯O(n^2)ï¼Œä¸ç¬¦åˆé¢˜ç›®è¦æ±‚ã€‚\r\n### æ›´ä¼˜çš„è§£æ³•æ˜¯åˆ©ç”¨å †(min-heap)æ•°æ®ç»“æ„ï¼Œä»æ ¹åˆ°å¶ç”±kä¸ªå…ƒç´ ç”±å°åˆ°å¤§ç»„æˆã€‚éå†å“ˆå¸Œè¡¨ï¼Œå°äºkåˆ™æ’å…¥å…ƒç´ ï¼Œå¤§äºkåˆ™ç”¨å½“å‰å€¼ä¸æ ¹çš„å€¼æ¯”è¾ƒï¼Œå¤§äºæ ¹åˆ™æ›¿æ¢ï¼Œå°äºå®ƒåˆ™è·³è¿‡åˆ°ä¸‹ä¸€ä¸ªã€‚æœ€åè¾“å‡ºkeyã€‚\r\n\r\n## ä»£ç \r\n```\r\nfrom typing import List\r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        # create hashtable to count the frequency\r\n        from collections import Counter\r\n        count = Counter(nums)\r\n        \r\n        # Create the heap\r\n        h = []\r\n        import heapq\r\n        for key, value in count.items():\r\n            heapq.heappush(h, (value, key))\r\n            if len(h) > k:\r\n                heapq.heappop(h)\r\n        return [key for value, key in h]\r\n```\r\n\r\n## å¤æ‚åº¦åˆ†æ\r\n### æ—¶é—´å¤æ‚åº¦: O(n) + O(nlogk) = O(nlogk)\r\n### ç©ºé—´å¤æ‚åº¦: O(n) + O(k) = O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205428233","body":"## æ€è·¯\r\n### 1. æ‰¾Vå‹ï¼Œéå†æ¯ä¸ªç‚¹ä½œä¸ºVçš„æ‹ç‚¹ï¼Œè®¡ç®—æ‰€æœ‰ç‚¹ä¸å…¶è·ç¦»\r\n### 2. å°†æ‰€æœ‰çš„è·ç¦»è®°å½•åˆ°å“ˆå¸Œè¡¨ï¼Œå‡è®¾ç”±mä¸ªç‚¹ç›¸åŒï¼Œæ’åˆ—ç»„åˆ m(m-1)\r\n### 3. å°†æ‰€æœ‰çš„æ’åˆ—å¯èƒ½æ€§ç›¸åŠ è¿”å›ï¼Œå› ä¸ºéœ€è¦è€ƒè™‘å…ƒç»„çš„é¡ºåº\r\n\r\n## ä»£ç \r\n```\r\nfrom typing import List\r\nfrom collections import defaultdict\r\n\r\nclass Solution:\r\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\r\n        ans = 0\r\n        for p in points:\r\n            cnt = defaultdict(int)\r\n            for q in points:\r\n                dis = (p[0] - q[0])*(p[0] - q[0])   + (p[1] - q[1])*(p[1] - q[1])\r\n                cnt[dis] += 1\r\n            for m in cnt.values():\r\n                ans += m * (m - 1)\r\n        return ans        \r\n```\r\n\r\n## å¤æ‚åº¦åˆ†æ\r\n### æ—¶é—´å¤æ‚åº¦: O(n^2) + O(n) = O(n^2)\r\n### ç©ºé—´å¤æ‚åº¦: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206583542","body":"## æ€è·¯\r\n### Hashtable\r\n### éå†å­—ç¬¦ä¸²ï¼Œæ£€æŸ¥å½“å‰å­—ç¬¦æ˜¯å¦å·²ç»å­˜åœ¨, å¦‚å¦åˆ™å°†å­—ç¬¦å­˜å…¥å“ˆå¸Œè¡¨ã€‚å¦‚æœå·²å­˜åœ¨åˆ™è¿”å›è¾ƒé•¿çš„é•¿åº¦åˆ°ç»“æœï¼Œå¹¶æ“¦é™¤å“ˆå¸Œè¡¨å’Œé•¿åº¦å˜é‡ã€‚æ‰§è¡Œæ­¤å¾ªç¯ç›´åˆ°æœ€åä¸€ä¸ªå­—ç¬¦ã€‚ä¸€ä¸ªå˜é‡è®°å½•å½“å‰å­å­—ç¬¦ä¸²é•¿åº¦ï¼Œå¦ä¸€ä¸ªå˜é‡è®°å½•ç»“æœã€‚\r\n\r\n## ä»£ç \r\n```\r\nfrom typing import List\r\n\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        hashtable = set()\r\n        length, ans = 0, 0\r\n        for i in s:\r\n            if i in hashtable:\r\n                ans = max(ans, length)\r\n                hashtable.clear()\r\n                length = 0\r\n            hashtable.add(i)\r\n            length += 1\r\n        return ans\r\n```\r\n\r\n## å¤æ‚åº¦åˆ†æ\r\n### æ—¶é—´å¤æ‚åº¦: O(n)\r\n### ç©ºé—´å¤æ‚åº¦: O(âˆ£Î£âˆ£))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/38#issuecomment-1207237353","body":"## æ€è·¯\r\n### Hashtable+ Sliding Windowã€‚åŒ¹é…çš„æ¡ä»¶ï¼šå•è¯æ•°é‡å’Œå†…å®¹éƒ½ä¸€è‡´\r\n### 1. è®¡ç®—wordsé•¿åº¦ä¸ºm,wordsé‡Œæ¯ä¸ªå•è¯çš„é•¿åº¦nï¼Œsçš„é•¿åº¦ä¸ºlsã€‚\r\n### 2. ç”¨å“ˆå¸Œè¡¨ç»Ÿè®¡wordsä¸­æ¯ä¸ªå•è¯å‡ºç°çš„æ¬¡æ•°ã€‚\r\n### 2. éå†sä¸­æ¯ä¸ªå­—æ¯ï¼Œå–æ€»é•¿åº¦ä¸ºm*nçš„å­—ç¬¦ä¸²ï¼Œåˆ’åˆ†ä¸ºmä¸ªwordsã€‚éå†wordsï¼Œå­˜å‚¨æ‰€æœ‰çš„å•è¯ï¼Œå¦‚æœå’Œwordsç›¸åŒåˆ™å‚¨å­˜å½“å‰å­—æ¯æ‰€åœ¨çš„ä½ç½®ã€‚å¾ªç¯è‡³ls-mnçš„ä½ç½®ã€‚\r\n\r\n## ä»£ç \r\n```\r\nfrom typing import List\r\nfrom collections import Counter\r\n\r\nclass Solution:\r\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\r\n        m, n, ls = len(words), len(words[0]), len(s)\r\n        counter = Counter(words)\r\n        ans = []\r\n        for i in range(ls):\r\n            temp = []\r\n            if i+m*n>ls:\r\n                return ans\r\n            for j in range(i,i+m*n,n):\r\n                temp.append(s[j:j+n])\r\n            if Counter(temp)==counter:\r\n                ans.append(i)\r\n```\r\n\r\n## å¤æ‚åº¦åˆ†æ\r\n### æ—¶é—´å¤æ‚åº¦: O(ls*m)\r\n### ç©ºé—´å¤æ‚åº¦: O(m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/39#issuecomment-1207397902","body":"## æ€è·¯\r\n### å‰ç¼€å’Œ + åŒä½™å®šç†\r\n### [sum(nums) - sum(del)] % k == 0, del=nums[i:j]\r\n### (pre[j] - pre[i-1])%k == sum(nums)%k (target_remainder)\r\n### (pre[j] - target_remainder)%k == pre[i-1]%k\r\n\r\n## ä»£ç \r\n```\r\nclass Solution:\r\n    def solve(self, nums, k):\r\n        target_remainder = sum(nums)%k\r\n        hashtable = {}\r\n        presum = 0\r\n        n = len(nums)\r\n        for i in range(n):\r\n            presum += nums[i]\r\n            cur_remainder = presum%k\r\n            hashtable[cur_remainder] = i\r\n            if (presum - target_remainder)%k in hashtable:\r\n                return (i - hashtable[(presum - target_remainder)%k])\r\n        return -1\r\n```\r\n## å¤æ‚åº¦åˆ†æ\r\n### æ—¶é—´å¤æ‚åº¦: O(n)\r\n### ç©ºé—´å¤æ‚åº¦: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208129443","body":"## æ€è·¯\r\n### å¿«æ…¢æŒ‡é’ˆ Hare & Tortoise\r\n\r\n## ä»£ç \r\n```\r\n# Definition for singly-linked list.\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\n\r\nclass Solution:\r\n    def middleNode(self, head: ListNode) -> ListNode:\r\n        slow_pointer = fast_pointer = head\r\n        while fast_pointer and fast_pointer.next:\r\n            slow_pointer = slow_pointer.next\r\n            fast_pointer = fast_pointer.next.next\r\n        return slow_pointer.val\r\n```\r\n\r\n## å¤æ‚åº¦åˆ†æ\r\n### æ—¶é—´å¤æ‚åº¦: O(n)\r\n### ç©ºé—´å¤æ‚åº¦: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209303092","body":"## æ€è·¯\r\n### å¿«æ…¢åŒæŒ‡é’ˆ\r\n\r\n## ä»£ç \r\n```\r\nfrom typing import List\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        if not nums:\r\n            return 0\r\n        \r\n        n = len(nums)\r\n        slow = fast = 1\r\n        for i in range(n-1):\r\n            if nums[fast] != nums[fast-1]:\r\n                nums[slow] = nums[fast]\r\n                slow += 1\r\n            fast += 1\r\n        return slow\r\n```\r\n\r\n## å¤æ‚åº¦åˆ†æ\r\n### æ—¶é—´å¤æ‚åº¦: O(n)\r\n### ç©ºé—´å¤æ‚åº¦: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"azl397985856":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whgsh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202138449","body":"# æ€è·¯\n\nforå¾ªç¯éå†æ•°ç»„å­˜å…¥å“ˆå¸Œè¡¨ï¼Œåˆ¤æ–­ç›®æ ‡æ˜¯å¦åœ¨å“ˆå¸Œè¡¨å†…å¹¶è¿”å›ä¸‹æ ‡\n\n# ä»£ç \n\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        dic = {}\n        for i, n in enumerate(nums):\n            if target - n not in dic:\n                dic[n] = i\n            else:\n                return [dic[target-n], i]\n```\n\n# å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦:O(N)\n\nç©ºé—´å¤æ‚åº¦:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/35#issuecomment-1203452357","body":"# æ€è·¯\n\nä½¿ç”¨å“ˆå¸Œè¡¨ç»Ÿè®¡æ•°å­—å‡ºç°æ¬¡æ•°ï¼Œæœ€åç”¨sortedæ‰¾å‡ºå‰kä¸ªé«˜é¢‘å…ƒç´ \n\n# ä»£ç \n\n```python\n\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        dic = {}\n        for num in nums:\n            if num in dic:\n                dic[num] = dic.get(num,0) + 1\n            else:\n                dic[num] = 1\n        \n        return sorted(dic,key=dic.get,reverse = True)[:k]  \n```\n\n# å¤æ‚åº¦\n\næ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)\n\nç©ºé—´å¤æ‚åº¦ï¼šO(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1208963392","body":"# æ€è·¯\n\nå¿«æ…¢æŒ‡é’ˆ\n\n# ä»£ç \n\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        slow, fast = 0, 1\n        while fast < len(nums):\n            if nums[slow] != nums[fast]:\n                slow += 1\n                nums[slow] = nums[fast]\n            fast += 1\n        return slow + 1   \n```\n# å¤æ‚åº¦\n\næ—¶é—´ï¼šO(n)\n\nç©ºé—´ï¼šO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chengfengfengwang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205013965","body":"## æ–¹æ³•ä¸€ï¼Œæšä¸¾\r\nç”¨ä¸‰å±‚å¾ªç¯éå†æ•°ç»„ï¼Œå¯ä»¥å¾—åˆ°æ•°ç»„ä¸­ä»»æ„3é¡¹çš„ç»„åˆæƒ…å†µ\r\n```\r\nfunction getNum1(arr) {\r\n  for (let i = 0; i < arr.length; i++) {\r\n    for (let j = 0; j < arr.length; j++) {\r\n      for (let k = 0; k < arr.length; k++) {\r\n        console.log([i, j , k]);\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\nç”±äºå›æ—‹é•–å½¢çŠ¶ä¸å…è®¸ä¸€ä¸ªç‚¹å‡ºç°ä¸¤æ¬¡,æ‰€ä»¥åŠ ä¸ªåˆ¤æ–­è¿‡æ»¤\r\n```\r\nfunction getNum1(arr) {\r\n  for (let i = 0; i < arr.length; i++) {\r\n    for (let j = 0; j < arr.length; j++) {\r\n      for (let k = 0; k < arr.length; k++) {\r\n        if(i !== j && i !==k && j !==k ) {\r\n          console.log([i, j , k]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\nåŠ ä¸Šé¢˜ç›®è·ç¦»åˆ¤æ–­\r\n```\r\nfunction getNum1(arr) {\r\n  let result = 0;\r\n  for (let i = 0; i < arr.length; i++) {\r\n    for (let j = 0; j < arr.length; j++) {\r\n      for (let k = 0; k < arr.length; k++) {\r\n        if(i !== j && i !==k && j !==k ) {\r\n          console.log([i, j , k]);\r\n          if (getDistance(arr[i], arr[j]) === getDistance(arr[i], arr[k])) {\r\n            result++\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return result\r\n}\r\nfunction getDistance(a, b) {\r\n  return (b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1]);\r\n}\r\n```\r\n## æ–¹æ³•äºŒï¼Œå“ˆå¸Œè¡¨\r\nå¦‚æœæŠŠä¸€ä¸ªç‚¹å½“ä½œé¡¶ç‚¹ï¼Œè·ç¦»è¿™ä¸ªç‚¹é•¿åº¦ä¸º1çš„æœ‰3ä¸ªå…¶ä»–ç‚¹ï¼Œè¿™ç§æƒ…å†µä¸‹æŠŠè¿™ä¸ªç‚¹ä½œä¸ºä¸­é—´ç‚¹çš„å›æ—‹é•–æœ‰å¤šå°‘ä¸ªï¼Ÿ\r\nå¦‚ï¼šoä¸ºä¸­é—´ç‚¹aã€bã€cä¸ºå…¶ä»–ç‚¹ï¼Œåˆ™å›æ—‹é•–æœ‰oab,oac,oba,ocaå¯ä»¥çœ‹åˆ°å…¶å®æ˜¯aã€bã€cçš„ä»»æ„ä¸¤ä¸ªç‚¹çš„æ’åˆ—æƒ…å†µï¼Œç©·ä¸¾æ•°é‡ä¸ºlength * length - lengthï¼›\r\nä»è¿™ç§æƒ…å†µä¸‹å¼€å§‹éå†\r\n```\r\nfunction getDistance(a, b) {\r\n  return (b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1]);\r\n}\r\nfunction getNum(arr) {\r\n  let result = 0;\r\n  for (let i = 0; i < arr.length; i++) {\r\n    let map = new Map();\r\n    for (let k = 0; k < arr.length; k++) {\r\n      if (i !== k) {\r\n        let distance = getDistance(arr[i], arr[k]);\r\n        if (map.has(distance)) {\r\n          map.set(distance, map.get(distance) + 1);\r\n        } else {\r\n          map.set(distance, 1);\r\n        }\r\n      }\r\n    }\r\n    // å¾—åˆ°ä»¥iä¸ºä¸­é—´ç‚¹æ—¶çš„é•¿åº¦æƒ…å†µ\r\n    // ç›¸åŒé•¿åº¦é¡¶ç‚¹åˆ—è¡¨çš„ä¸¤ä¸¤æ’åˆ—æƒ…å†µä¸º length * length - length\r\n    map.forEach((value, key) => (result += value * value - value));\r\n  }\r\n  return result;\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/37#issuecomment-1206315476","body":"## æ–¹æ³•ä¸€ï¼Œæšä¸¾æ‰€æœ‰å¯èƒ½çš„å­å­—ç¬¦ä¸²\r\næŒ¨ä¸ªæŠŠå­—ç¬¦ä¸²çš„æ¯ä¸€é¡¹ä½œä¸ºã€ä¸€ä¸ªä¸é‡å¤å­—ç¬¦ä¸²ã€‘ çš„å¼€å¤´ï¼Œ\r\nç®—å‡ºä»¥å®ƒä¸ºå¼€å¤´çš„æœ€å¤§ä¸é‡å¤å­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œ\r\næ‰€æœ‰é¡¹éƒ½è¯•è¿‡åï¼Œæœ€åå°†è¿™äº›é•¿åº¦æ±‚æœ€å¤§å€¼\r\n```\r\nconst str = 'acdaedfg';\r\nfunction method1(str) {\r\n  let max = 0;\r\n  for (let i = 0; i < str.length; i++) {\r\n    // ä»¥str[i]å¼€å¤´çš„å­—ç¬¦ä¸²\r\n    const set = new Set();\r\n    for (let k = i; k < str.length; k++) {\r\n      const current = str[k];\r\n      if (set.has(current)) {\r\n        // é€€å‡ºå½“å‰forå¾ªç¯\r\n        break\r\n      } else {\r\n        set.add(current)\r\n      }\r\n    }\r\n    // åœ¨æœ¬è½®å¾ªç¯ç»“æŸåï¼Œå½“å‰çš„setå°±æ˜¯ str[i]å¼€å¤´çš„ä¸é‡å¤å­—ç¬¦ä¸²\r\n    if (set.size > max) {\r\n      max = set.size\r\n    }\r\n  }\r\n  return max\r\n}\r\n```\r\n## æ–¹æ³•äºŒï¼ŒåŒæŒ‡é’ˆ\r\n1. start,endåˆ†åˆ«ä»£è¡¨å·¦å³æŒ‡é’ˆï¼Œåˆå§‹å€¼éƒ½ä¸º0ï¼›\r\n2. startæŒ‡é’ˆä¸å˜ï¼ŒendæŒ‡é’ˆå‘åç§»ï¼Œç›´åˆ°ç¢°åˆ°endæŒ‡é’ˆå½“å‰å€¼ä¸æ»¡è¶³éé‡å¤çš„æ¡ä»¶ï¼›\r\n3. æ­¤æ—¶[start, end]åŒºé—´å†…çš„ä¸ºè¿ç»­ä¸é‡å¤å­—ç¬¦ä¸²ï¼Œç§°ä¸ºçª—å£ï¼›è®°å½•æ­¤æ—¶å­—ç¬¦ä¸²é•¿åº¦ï¼›\r\n4. startæŒ‡é’ˆå‘å³ç§»åŠ¨ä¸€ä½ï¼ŒæŠŠçª—å£é‡Œæœ€å·¦çš„å­—ç¬¦ä¸²ä¸¢å¼ƒ\r\n5. é‡å¤2ã€3ã€4æ­¥ï¼Œç›´åˆ°endæŒ‡é’ˆè¶Šç•Œï¼Œå¾—åˆ°æœ€å¤§å€¼\r\n6. æœ€åæƒ…å†µä¸‹å·¦å³æŒ‡é’ˆéƒ½ä»å¤´èµ°åˆ°å°¾ï¼Œå› æ­¤æ—¶é—´å¤æ‚åº¦ä¸ºO(n)\r\n```\r\nfunction method2(str) {\r\n  let max = 0,\r\n    start = 0,\r\n    end = 0;\r\n  let set = new Set();\r\n  while (end < str.length) {\r\n    if (set.has(str[end])) {\r\n      // å½“å‰setæ˜¯ä»¥startå¼€å¤´çš„æœ€é•¿è¿ç»­éé‡å¤å­—ç¬¦ä¸²\r\n      if (set.size > max) {\r\n        max = set.size;\r\n      }\r\n      set.delete(str[start]); \r\n      start++;\r\n    } else {\r\n      set.add(str[end]);\r\n      end++\r\n    }\r\n  }\r\n  // æœ€é•¿å­—ç¬¦ä¸²å‡ºç°åœ¨æœ«å°¾è¿ç»­çš„æƒ…å†µ\r\n  if (set.size > max) {\r\n    max = set.size;\r\n  }\r\n  return max;\r\n}\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1208296459","body":"## step1 è®¡ç®—é“¾è¡¨é•¿åº¦\r\n```\r\nlet count = 0, current = head;\r\nwhile(current) {\r\n  current = current.next;\r\n  count++\r\n}\r\n```\r\n## step2éå†åˆ°é•¿åº¦ä¸­é—´å€¼\r\n```\r\ncurrent = head\r\nfor (let i = 0; i < Math.floor(count / 2); i++) {\r\n  current = current.next\r\n}\r\nretturn current\r\n```\r\n```\r\nvar middleNode = function (head) {\r\n  let count = 0,\r\n    current = head;\r\n  while (current) {\r\n    current = current.next;\r\n    count++;\r\n  }\r\n  current = head;\r\n  for (let i = 0; i < Math.floor(count / 2); i++) {\r\n    current = current.next;\r\n  }\r\n  return current;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209252255","body":"1. æ•°ç»„æ˜¯æœ‰åºæ•°ç»„ï¼›è€ƒè™‘ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆ\r\n2. å¿«æŒ‡é’ˆåœ¨å‰ï¼Œè´Ÿè´£æ‰«ææ•´ä¸ªæ•°ç»„ï¼›æ…¢æŒ‡é’ˆåœ¨åä½œä¸ºå‚è€ƒ\r\n3. å¦‚æœå¿«æŒ‡é’ˆå’Œæ…¢æŒ‡é’ˆä¸ç›¸ç­‰ï¼Œåˆ™è¡¨ç¤ºæ…¢æŒ‡é’ˆçš„å½“å‰å€¼ï¼Œåœ¨æ•´ä¸ªæ•°ç»„ä¸­å·²ç»æ²¡æœ‰äº†é‡å¤é¡¹ï¼ˆå› ä¸ºæ˜¯æœ‰åºæ•°ç»„ï¼‰ï¼Œå¿«æ…¢æŒ‡é’ˆå„æ­£å¸¸å‘åæ£€ç´¢\r\n4. å¦‚æœæƒ³ç­‰åˆ™éœ€è¦å¤„ç†æ•°ç»„ï¼Œåˆ é™¤è¯¥é¡¹\r\n```\r\nvar removeDuplicates = function(nums) {\r\n  let slowIndex = 0;\r\n  let fastIndex = 1;\r\n  while(fastIndex < nums.length) {\r\n    if (nums[slowIndex] !== nums[fastIndex]) {\r\n      slowIndex++;\r\n      fastIndex++\r\n    } else {\r\n      nums.splice(fastIndex, 1)\r\n    }\r\n  }\r\n  return slowIndex + 1\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bulingbulingbuling":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/40#issuecomment-1207861154","body":"## å¿«æ…¢æŒ‡é’ˆ \n\n å¿«æŒ‡é’ˆ ä¸€æ¬¡ä¸¤æ­¥ æ…¢æŒ‡é’ˆä¸€æ¬¡ä¸€æ­¥ å½“å¿«æŒ‡é’ˆåˆ°æœ«å°¾ æ…¢æŒ‡é’ˆå°±æ˜¯ä¸­é—´\n\n```javascript\nvar middleNode = function(head) {\n  let fast = slow = head\n  while(fast && fast.next) {\n    slow = slow.next\n    fast = fast.next.next\n  }\n  return slow\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"c2tr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209450016","body":"function removeDuplicates(nums: number[]): number {\n    \n    const n = nums.length\n    let slow = 0, fast = 0\n    while(slow <= fast && fast< n) {\n        if(nums[slow]!= nums[fast]) {\n            slow++\n            nums[slow] = nums[fast]\n        } \n        fast++\n\n    }\n    return slow+1\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eden-ye":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/41#issuecomment-1209530245","body":"### æ€è·¯\nç»´æŒå¾ªç¯ä¸å˜é‡ [0, slow) ä¸­æœ‰åºä¸”å…ƒç´ å”¯ä¸€çš„æ€§è´¨ã€‚fastéå†numsï¼Œåœ¨ä¸é‡åˆ°é‡å¤å…ƒç´ æ—¶ï¼Œå°†fastä½ç½®çš„å…ƒç´ èµ‹äºˆslowä½ç½®ï¼Œslow++\n### ä»£ç \n\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int slow = 1;\n        for (int fast = 1; fast < nums.length; fast++) {\n            if (nums[fast] != nums[fast - 1]) {\n                nums[slow] = nums[fast];\n                slow++;\n            }\n        }\n        return slow;\n    }\n}\n\n```\n\n**å¤æ‚åº¦**\n- æ—¶é—´å¤æ‚åº¦ï¼šO(N)\n- ç©ºé—´å¤æ‚åº¦ï¼šO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"codingtrains":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184674932","body":"## æ€è·¯\næ³¨æ„ k ã€numæ•°ç»„ã€ä»¥åŠè¿›ä½é—®é¢˜å³å¯ã€‚\n- Javaï¼šæ•°ç»„éå†\n- Pythonï¼š å­—ç¬¦ä¸²å·æ‡’\n\n## è§£é¢˜\nJava:\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> arr = new LinkedList<>();\n        int index = num.length - 1;\n        int plus = 0;\n        while (k > 0 || plus != 0 || index > -1) {\n            int mod = k % 10 + plus;\n            k /= 10;\n            if (index > -1) {\n                mod += num[index--];\n            }\n            arr.addFirst(mod % 10);\n            plus = mod / 10;\n        }\n        return arr;\n    }\n}\n```\nPython:\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = reduce(lambda x, y: x * 10 + y, num) + k\n        return [0] if n == 0 else [int(i) for i in str(n)]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186186080","body":"## æ€è·¯\n1. éå†æŸ¥è¯¢æ‰€æœ‰sä¸­ç­‰äºcçš„ä¸‹æ ‡å¹¶ä¿å­˜\n2. äºŒæ¬¡éå†å¹¶å¯¹æ¯”è¯¥å­—ç¬¦åˆ°ä¸¤ç«¯çš„æœ€çŸ­è·ç¦»\n\n## ä»£ç \n```Java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] ret = new int[s.length()];\n        ArrayList<Integer> index = new ArrayList<>();\n        index.add(-s.length() - 1);\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c){\n                index.add(i);\n            }\n        }\n        index.add(s.length() * 2);\n        int point = 1;\n        for (int i = 0; i < s.length(); i++) {\n            ret[i] = Math.min(i - index.get(point - 1),index.get(point) - i);\n            if (i == index.get(point)){\n                point++;\n            }\n        }\n        return ret;\n    }\n}\n```\n\n## å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦ï¼š O(N)\nç©ºé—´å¤æ‚åº¦ï¼š O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186522499","body":"## æ€è·¯\nä½¿ç”¨æ•°ç»„æ¨¡æ‹Ÿæ ˆæ“ä½œ\n\n## è§£é¢˜\n```Java\nclass CustomStack {\n    int[] stack;\n    int[] nums;\n    int p = -1;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        nums = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (p < stack.length - 1) {\n            stack[++p] = x;\n        }\n    }\n\n    public int pop() {\n        if (p >= 0) {\n            int val = stack[p];\n            int num = nums[p];\n            nums[p--] = 0;\n            if (p >= 0) {\n                nums[p] += num;\n            }\n            return val + num;\n        }\n        return -1;\n    }\n\n    public void increment(int k, int val) {\n        if ( p >= 0){\n            k = Math.min(k - 1, p);\n            nums[k] += val;\n        }\n    }\n}\n```\n## å¤æ‚åº¦\næ—¶é—´å¤æ‚åº¦: O(1)\nç©ºé—´å¤æ‚åº¦: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186565468","body":"## æ€è·¯\nä½¿ç”¨æ ˆçš„å‹å…¥å¼¹å‡ºï¼Œæ ¹æ®å³æ‹¬å·ä½œä¸ºå¼¹æ ˆçš„è§¦å‘ã€‚\n\n## ä»£ç \n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for i in s:\n            if i == ']':\n                strs = ''\n                repeat = ''\n                while stack[-1] != '[':\n                    strs = stack.pop() + strs\n                stack.pop()\n                while stack and stack[-1].isdigit():\n                    repeat = stack.pop() + repeat\n                stack.append(int(repeat) * strs)\n                continue\n            stack.append(i)\n        return ''.join(stack)\n```\n## å¤æ‚åº¦\n- æ—¶é—´å¤æ‚åº¦ï¼š O(N)\n- ç©ºé—´å¤æ‚åº¦ï¼š O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188936014","body":"## æ€è·¯\nä½¿ç”¨ä¸¤ä¸ªæ ˆï¼Œæ¥å®ç°é˜Ÿåˆ—çš„æ“ä½œ\n## ä»£ç \n```python\nclass MyQueue:\n    def __init__(self):\n        self.stack1, self.stack2 = [], []\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self) -> int:\n        return self.stack2[-1] if self.stack2 else self.stack1[0]\n\n    def empty(self) -> bool:\n        return len(self.stack1) + len(self.stack2) == 0\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190382731","body":"## æ€è·¯\nåŸºç¡€æ ˆæ“ä½œ\n## ä»£ç \n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for i in arr:\n            if stack and i < stack[-1]:\n                head = stack[-1]\n                while stack and i < stack[-1]:\n                    stack.pop()\n                stack.append(head)\n            else:\n                stack.append(i)\n        return len(stack)\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191540789","body":"## æ€è·¯\nå¿«æ…¢æŒ‡é’ˆï¼Œå®Œæˆç¯çš„æ–­å¼€æ“ä½œã€‚\n## ä»£ç \n```python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        count = 0\n        cur = head\n        while cur:\n            count += 1\n            cur = cur.next\n        if count <= 1 or k % count == 0:\n            return head\n        k = k % count\n        slow = fast = head\n        while k:\n            fast = fast.next\n            k -= 1\n        while fast.next:\n            fast = fast.next\n            slow = slow.next\n        new_head = slow.next\n        slow.next = None\n        fast.next = head\n        return new_head\n        \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192641820","body":"## æ€è·¯\nä½¿ç”¨æŒ‡é’ˆå¤åˆ¶ï¼Œå®Œæˆäº¤æ¢\n## ä»£ç \n```python\nclass Solution:\n    def swapPairs(self, head):\n        ret = ListNode()\n        ret.next = head\n        tmp = ret\n        while tmp.next and tmp.next.next:\n            t3 = tmp.next.next.next\n            t2 = tmp.next\n            tmp.next = tmp.next.next\n            tmp.next.next = t2\n            t2.next = t3\n            tmp = t2\n        return ret.next\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193146136","body":"## æ€è·¯\nåˆå§‹åŒ–äºŒå‰æ ‘ï¼Œå¹¶æ ¹æ®é“¾è¡¨æ„é€ äºŒå‰æ ‘\n## ä»£ç \n```python\nclass Solution:\n    def sortedListToBST(self, head):\n        def get_mid(left, right):\n            fast = slow = left\n            while fast != right and fast.next != right:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n\n        def tree(left, right):\n            if left == right:\n                return None\n            mid = get_mid(left, right)\n            root = TreeNode(mid.val)\n            root.left = tree(left, mid)\n            root.right = tree(mid.next, right)\n            return root\n\n        return tree(head, None)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193296735","body":"## æ€è·¯\nä½¿ç”¨å¿«æ…¢æŒ‡é’ˆï¼Œå®Œæˆç›¸äº¤é“¾è¡¨çš„ç¡®å®š\n## ä»£ç \n```python\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        d = {}\n        while headA:\n            d[headA] = headA.val\n            headA = headA.next\n        while headB:\n            if d.get(headB):\n                return headB\n            headB = headB.next\n        return None\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193995380","body":"## æ€è·¯\né‡‡ç”¨å¿«æ…¢æŒ‡é’ˆï¼Œçœ‹æ˜¯å¦ä¸¤ä¸ªæŒ‡é’ˆä¼šç›¸é‡ï¼Œå³å¯åˆ¤æ–­é“¾è¡¨æ˜¯å¦æœ‰ç¯ã€‚\n## ä»£ç \n```python\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                point = head\n                while point!=slow:\n                    point = point.next\n                    slow = slow.next\n                return point\n\n        return None\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196618976","body":"## ä»£ç \n```python\nclass Solution:\n    def maxDepth(self, root):\n        if not root:\n            return 0\n        else:\n            return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1198020883","body":"## ä»£ç \n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        def bfs(root):\n            ret = []\n            queue = deque([root])\n            while queue:\n                tmp = []\n                for i in range(len(queue)):\n                    child = queue.popleft()\n                    if child:\n                        tmp.append(child.val)\n                        queue.append(child.left)\n                        queue.append(child.right)\n                    else:\n                        tmp.append(None)\n                if tmp:\n                    ret.append(tmp)\n            return ret\n\n        return bfs(p) == bfs(q)\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/32#issuecomment-1200408877","body":"## ä»£ç \n```python\nfrom collections import deque\n\nclass Codec:\n    \n    def serialize(self, root):\n        if not root:\n            return \"\"\n        dq = deque([root])\n        res = []\n        while dq:\n            node = dq.popleft()\n            if node:\n                res.append(str(node.val))\n                dq.append(node.left)\n                dq.append(node.right)\n            else:\n                res.append('None')\n        return ','.join(res)\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n\n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        if not data:\n            return []\n        dataList = data.split(',')\n        root = TreeNode(int(dataList[0]))\n        dq = deque([root])\n        i = 1\n        while dq:\n            node = dq.popleft()\n            if dataList[i] != 'None':\n                node.left = TreeNode(int(dataList[i]))\n                dq.append(node.left)\n            i += 1\n            if dataList[i] != 'None':\n                node.right = TreeNode(int(dataList[i]))\n                dq.append(node.right)\n            i += 1\n        return root\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/33#issuecomment-1201339590","body":"## ä»£ç \n```python\nclass Solution(object):\n    def verticalTraversal(self, root):\n        seen = collections.defaultdict(\n                  lambda: collections.defaultdict(list))\n\n        def dfs(node, x=0, y=0):\n            if node:\n                seen[x][y].append(node)\n                dfs(node.left, x-1, y+1)\n                dfs(node.right, x+1, y+1)\n\n        dfs(root)\n        ans = []\n\n        for x in sorted(seen):\n            report = []\n            for y in sorted(seen[x]):\n                report.extend(sorted(node.val for node in seen[x][y]))\n            ans.append(report)\n\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/34#issuecomment-1202405282","body":"## ä»£ç \n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        tmp = {}\n        for k, v in enumerate(nums):\n            if target - v in tmp:\n                return [tmp[target - v], k]\n            tmp[v] = k\n```\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/36#issuecomment-1205389473","body":"##  ä»£ç \n```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ans = 0\n        for p in points:\n            cnt = defaultdict(int)\n            for q in points:\n                dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1])\n                cnt[dis] += 1\n            for m in cnt.values():\n                ans += m * (m - 1)\n        return ans\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}