{"577961141":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085986299","body":"## 题目思路\n解法一：假如，需要计算的数组为[1,2,3]和数字1095；首先向1095取余（以10），那么得到5再和数组3相加，得到8，将结果加入到新的数组；再将1095向下取整，再取余，得到9，在和数组的2相加，会发现得到的结果超过了10，那么就要将结果减10后加入新的数组，109还需要加一。重复以上步骤即可。\n\n解法二： 假如，需要计算的数组为[1,2,3]和数字1095；我们可以直接向1095加上数组的末尾的数，即1095+3然后取余，得到8，加入到新的数组中去，一直重复这个步骤即可。\n\n## 题目的题解code\n解法1：\n```PHP\nclass Solution {\n\n    /**\n     * @param Integer[] $num\n     * @param Integer $k\n     * @return Integer[]\n     */\n    function addToArrayForm($num, $k) {\n        $res = [];\n        for ($i = count($num) -1; $i >=0; $i--) {\n            $remainder = $k % 10;\n            $addVal = $remainder + $num[$i];\n\n            if ($addVal >= 10) {\n                $addVal = $addVal % 10;\n                $k = floor($k /10) + 1;\n            }else {\n                $k = floor($k /10);\n            }\n            $res[] = $addVal;\n        }\n        while($k) {\n            $res[] = $k % 10;\n            $k = floor($k /10);\n        }\n        return array_reverse($res);\n    }\n}\n```\n\n解法2：\n```PHP\nclass Solution {\n\n    /**\n     * @param Integer[] $num\n     * @param Integer $k\n     * @return Integer[]\n     */\n    function addToArrayForm($num, $k) {\n        $res = [];\n        for ($i = count($num) -1; $i >=0; $i--) {\n            $k = $num[$i] + $k;\n            $res[] = $k % 10;\n            $k = floor($k / 10);\n        }\n        while($k) {\n            $res[] = $k % 10;\n            $k = floor($k /10);\n        }\n        return array_reverse($res);\n    }\n}\n```\n\n## 时间和空间复杂度\n时间复杂度：O(max(n,logk)),其中n为数组的长度，k为数值的长度\n空间复杂度：O(1),除了返回值之外，其余全是常数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086643481","body":"## 题目思路\n1. 先遍寻左边，记录上一次字符C出现的位置```prev```,那么答案就是```i-prev```\n2. 再遍寻右边，记录上一次字符C出现的位置```prev```,那么答案就是```prev-i```\n3. 最后比较相同位置的数值，谁小取谁\n\n## 题目的题解code\n```PHP\n<?php\n\nclass Solution {\n\n    /**\n     * @param String $s\n     * @param String $c\n     * @return Integer[]\n     */\n    function shortestToChar($s, $c) {\n        $ans = [];\n        $len = mb_strlen($s);\n\n        // 计算左边\n        $prev = PHP_INT_MIN / 2;\n        for ($i = 0; $i < $len; $i++) {\n            if ($s[$i] == $c) {\n                $prev = $i;\n            }\n\n            $ans[] = $i - $prev;\n        }\n\n        // 计算右边\n        $prev = PHP_INT_MAX / 2;\n        for ($j = $len - 1; $j >= 0; $j--) {\n            if ($s[$j] == $c) {\n                $prev = $j;\n            }\n\n            $ans[$j] = min($ans[$j], $prev - $j);\n        }\n\n        return $ans;\n    }\n}\n```\n\n\n## 时间和空间复杂度\n时间复杂度： O(N),N是字符串的长度，我们需要遍历两次\n空间复杂度： O(N),ans的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086858899","body":"## 题目思路\n额。思路没有挺简单的\n\n## 题目的题解code\n```PHP\n<?php\n\nclass CustomStack {\n    public $maxSize;\n    public $stack = [];\n    /**\n     * @param Integer $maxSize\n     */\n    function __construct($maxSize) {\n        $this->maxSize = $maxSize;\n    }\n\n    /**\n     * @param Integer $x\n     * @return NULL\n     */\n    function push($x) {\n        if  (count($this->stack) < $this->maxSize) {\n            array_push($this->stack, $x);\n        }\n\n        return null;\n    }\n\n    /**\n     * @return Integer\n     */\n    function pop() {\n        if (count($this->stack) <= 0) {\n            return -1;\n        }\n\n        return array_pop($this->stack);\n    }\n\n    /**\n     * @param Integer $k\n     * @param Integer $val\n     * @return NULL\n     */\n    function increment($k, $val) {\n        for ($i = 0; $i < $k && $i < count($this->stack); $i++) {\n            $this->stack[$i] += $val;\n        }\n\n        return null;\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * $obj = CustomStack($maxSize);\n * $obj->push($x);\n * $ret_2 = $obj->pop();\n * $obj->increment($k, $val);\n */\n```\n\n## 时间和空间复杂度\n时间复杂度：所有操作的渐进时间复杂度均为O(1)。\n空间复杂度：这里用到了两个长度为 maxSize 的数组作为辅助空间，渐进空间复杂度为O(maxSize)。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"1973719588":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085541708","body":"思路：将int型的数字变为str字符串型的就很好处理了\r\n```python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        i = ''\r\n        for x in num:\r\n            i = i + str(x)\r\n        numi = int(i)\r\n        xx = numi + k\r\n        ls = []\r\n        for s in str(xx):\r\n            ls.append(int(s))\r\n\r\n        return ls\r\n```\r\n\r\n空间复杂度：O(n)\r\n时间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zacherycao":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085303351","body":"## Idea\nScan the array from end to begin. Use an extra variable to record the carry number.\n\n## Code\n```python 3\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = k\n        for i in range(len(num) - 1, -1, -1):\n            total = (num[i] + carry)\n            carry = total // 10\n            A = total % 10\n            num[i] = A\n        if carry:\n            return [int(i) for i in str(carry)] + num\n        return num\n                \n```\n\n## Complexity:\nTime: O(N). N = max(len(num), len(k))\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086642145","body":"## Idea\nDeque q for the index of character c. For each index i in s check whether abs(i - q[0])>abs(i - q[1]) and q has more than 1 element. If it is, pop the most front element from the q. \n\n## Code\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        position = collections.deque()\n        for i in range(len(s)):\n            if s[i] == c:\n                position.append(i)\n        ans = []\n        for i in range(len(s)):\n            if len(position)>1 and abs(i-position[0])>abs(i-position[1]):\n                position.popleft()\n            ans.append(abs(i-position[0]))\n        return ans\n```\n\n## Complexity:\nTime: O(N)\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086894362","body":"## Idea\nSimulation\n\n## Code\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.cap = maxSize\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack)<self.cap:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len(self.stack))):\n            self.stack[i] += val\n\n```\n\n## Complexity:\nTime: Increment: O(k.) Others: O(1)\nSpace: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"freedom0123":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085327382","body":"> 实现思路\n\n实际上就是一个模拟人工加法的过程\n\n> 复杂度分析\n1. 时间复杂度：O(n)\n2. 空间复杂度：O(n)\n\n> 代码实现\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n = num.length;\n        List<Integer> ans = new ArrayList<>();\n        num[n-1] += k;\n        int t  = 0;// 用 t 来表示进位 \n        for(int i = n - 1; i >=0 ; i--) {\n            // 比如说 now = 11， ans 的当前位就是 1，进位为 10\n            int now = num[i] + t; // 当前位 + 进位之后的结果\n            ans.add(now % 10);// ans 中当前位的结果是 now 的个位\n            t = now / 10; // 进位就是 除了个位 以上的为\n        }\n        if(t > 0){\n            while(t != 0) {\n                ans.add(t % 10);\n                t /= 10;\n            }\n        }\n        Collections.reverse(ans); \n        return ans;\n    }\n}\n\n```\n> [高精度加法](https://www.acwing.com/problem/content/description/793/)\n> Acwing\n\n```markdown\n给定两个正整数（不含前导 0），计算它们的和。\n\n # 输入格式\n \n共两行，每行包含一个整数。\n\n # 输出格式\n共一行，包含所求的和。\n\n# 数据范围\n1≤ 整数长度 ≤100000\n```\n\n```c\n#include<iostream>\n#include<cstring>\n#include<vector> \nusing namespace std;\nvector<int> add(vector<int> A,vector<int> B) {\n    if(A.size() < B.size()) return add(B,A);\n    vector<int> C;\n    int t = 0;// 表示进位\n    for(int i = 0 ;i < A.size(); i++) {\n        t += A[i];\n        if(i < B.size()) t+= B[i];\n        C.push_back(t % 10);\n        t /= 10;\n    }\n    if(t > 0) {\n        while(t !=0 ) C.push_back(t % 10), t/=10;\n    }\n    return C;\n    \n}\nint main() {\n    string a,b;\n    vector<int> A,B;\n    cin>>a>>b;\n    for(int i = a.size()-1; i >=0 ;--i) {\n        A.push_back(a[i] - '0');\n    }\n    for(int i = b.size() - 1; i >= 0; --i) {\n        B.push_back(b[i] - '0');\n    }\n    auto C = add(A,B);\n    for(int i = C.size() - 1; i >= 0; i--){\n        cout<<C[i];\n    }\n    return 0;\n    \n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086474703","body":"[原题链接](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n> 算法一\n1. 时间复杂度为：O(n ^ 2)\n2. 思路：暴力枚举，对于每个位置都向左右两个方向进行搜索，判断每个位置上的字符是否是c，如果是，进行相应的计算即可\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[n];\n        for(int i = 0; i < n; i++){\n            int left = i;\n            int right = i+1;\n            int res  = Integer.MAX_VALUE;\n            while(left >= 0) {\n                if(s.charAt(left) == c) res = Math.min(res, Math.abs(i - left));\n                left --;\n            }\n            while(right < n) {\n                if(s.charAt(right) == c) res = Math.min(res, Math.abs(i - right));\n                right ++;\n            }\n            ans[i] = res;\n        }\n        return ans;\n    }\n}\n```\n> 算法二\n \n\n  - 时间复杂度：O(n)\n-  思路： 在算法一中，对于每个位置我们都要向左 和向右搜索距离这个位置最近的c，这种算法的时间复杂度很高，并且在做很多无用功。对于每个位置，我们如果说知道了他的前一位，距离最近的c    的位置，我们就不需要每个位置都进行枚举\n-  通过这种思想，我们只需要向左扫一遍，记住每个位置上，左边距离它最近的c的距离；在向右扫一遍，记住每个位置上，右边距离它最近的c的位置，就行。\n- 这里pre 除以2 的目的是为了，防止越界 \n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[n];\n        int pre = Integer.MIN_VALUE / 2;\n        for(int i = 0; i < n; i++) {\n            if(s.charAt(i) == c) {\n                pre = i;\n            }\n            ans[i] = i - pre;\n        }\n        pre = Integer.MAX_VALUE / 2;\n        for(int i = n -1; i >= 0; i--) {\n            if(s.charAt(i) == c) {\n                pre = i;\n            }\n            ans[i] = Math.min(ans[i],pre- i);\n        }\n        return ans;\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086787651","body":"[原题链接](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n@[toc]\n# 思路\n题目中已经确切的告诉了我们，数组中会放入多少个元素，这种情况并且只有添加操作，这种情况之下，使用数组模拟效率会更高一点。\n# 代码\n> 用数组模拟栈,击败100%\n```java\nclass CustomStack {\n    private int[] stack;\n    private int tt;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(tt == stack.length) return;\n        stack[tt++] = x;\n    }\n    \n    public int pop() {\n        if(tt == 0) return -1;\n        return stack[--tt];\n    }\n    \n    public void increment(int k, int val) {\n        for(int i = 0; i < k && i < tt; i++) {\n            stack[i] += val;\n        }\n    }\n}\n```\n#  用数组来模拟栈\n> 用一个数组来表示栈结构，并且加一个索引来方便操作,这里的 tt 指向的是 下一次要放的位置 \n\n```c\nconst int N  = 10010;\nint stack[N];\nint tt;\n// 向栈中添加元素\nstack[tt++] = x;\n// 弹出栈顶元素\n--tt;\n// 判断栈是否是空\ntt == 0;\n// 栈顶\nint top = tt;\nstack[top--];\n```\n\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tonylee017":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085338085","body":"#### 思路\n\n直接把k加到num[i]上，保留个位数在num[i]，k取为其他位数。\n\n#### 代码实现\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\t\ti = len(num)-1\n        while k:\n            num[i] += k\n            k, num[i] = num[i]//10, num[i]%10\n            i -= 1\n            if i<0 and k:\n                num.insert(0,0)\n                i = 0 \n        return num\n```\n#### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"youxucoding":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085341434","body":"### 思路\r\n\r\n模拟加法，类似链表两数相加那题，所以我使用的LinkedList。\r\n\r\n\r\n### 代码实现\r\n```java \r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int vaild = 0;\r\n        int i = num.length-1;\r\n        while(i >= 0 || k > 0){\r\n            int cur = 0;\r\n            if(i < 0){\r\n                cur = (k % 10) + vaild;\r\n            }else if(k == 0){\r\n                cur = num[i] + vaild;\r\n            }else{\r\n                cur = num[i] + (k % 10) +vaild;\r\n            }\r\n            vaild = cur/10;\r\n            cur = cur % 10;\r\n            k = k / 10;\r\n            i--;\r\n            res.addFirst(cur);\r\n        }\r\n        if(vaild > 0){\r\n            res.addFirst(vaild);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度O(n)\r\n- 空间复杂度O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086568629","body":"> 4月2日\n\n- 【day02】\n\n### [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n难度简单218\n\n给你一个字符串 `s` 和一个字符 `c` ，且 `c` 是 `s` 中出现过的字符。\n\n返回一个整数数组 `answer` ，其中 `answer.length == s.length` 且 `answer[i]` 是 `s` 中从下标 `i` 到离它 **最近** 的字符 `c` 的 **距离** 。\n\n两个下标 `i` 和 `j` 之间的 **距离** 为 `abs(i - j)` ，其中 `abs` 是绝对值函数。\n\n \n\n**示例 1：**\n\n```java\n输入：s = \"loveleetcode\", c = \"e\"\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n```\n\n\n\n### 思路：\n\n1. 暴力解法：得到所有目标字符的下标，遍历字符串一一比较，获得最近距离\n2. 滑动窗口：按照目标字符重复出现的位置，将字符串划分为若干窗口，在窗口内就可以计算出当前下标与目标字符最近距离。\n\n### 代码实现：\n\n- 暴力解法：\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        ArrayList<Integer> list = new ArrayList<>();\n        int res[] = new int[s.length()];\n        for(int i = 0;i < s.length();i++){\n            if(s.charAt(i) == c){\n                list.add(i);\n            }\n        }\n        for(int j = 0;j < s.length();j++){\n            res[j] = Integer.MAX_VALUE;\n            for(Integer i : list){\n                res[j] = Math.min(res[j],Math.abs(j-i));\n            } \n        }\n        return res;\n    }\n}\n```\n\n- 滑动窗口：\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int cur = 0;\n        int left = Integer.MAX_VALUE;\n        int right = -1;\n        int res[] = new int[s.length()];\n        while(cur < s.length()){\n            right++;\n            while((s.charAt(right) == c || right == s.length() - 1)&&cur <= right){\n               if((right == s.length() - 1) && (s.charAt(right) != c)){\n                   res[cur] = Math.abs(cur - left);\n                   cur++;\n               }else{\n                    res[cur] = Math.min(Math.abs(cur-left),Math.abs(cur-right));\n                    if(cur == right){\n                        left = cur;\n                    }\n                    cur++;\n                }\n                \n            }\n\n        }\n        return res;\n    }\n}\n```\n\n\n\n### 复杂度分析：\n\n- 暴力解法：\n  - 时间复杂度：O(m*n)\n  - 空间复杂度：O(n)\n- 滑动窗口：\n  - 时间复杂度：O(n)\n  - 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086783707","body":"> 4月3日\r\n\r\n- 【day03】\r\n\r\n#### [1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\r\n\r\n难度  中等\r\n\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 `CustomStack` ：\r\n\r\n- `CustomStack(int maxSize)`：用 `maxSize` 初始化对象，`maxSize` 是栈中最多能容纳的元素数量，栈在增长到 `maxSize` 之后则不支持 `push` 操作。\r\n- `void push(int x)`：如果栈还未增长到 `maxSize` ，就将 `x` 添加到栈顶。\r\n- `int pop()`：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 **-1** 。\r\n- `void inc(int k, int val)`：栈底的 `k` 个元素的值都增加 `val` 。如果栈中元素总数小于 `k` ，则栈中的所有元素都增加 `val` 。\r\n\r\n### 思路：\r\n\r\n看到题目上的前缀和标签就尝试了使用差分数组思想，构建原数组（也就是本题中的栈）的差分数组。在差分数组目标区间起点增加值，在终点后一位减值。最后通过差分数组更新原数组。\r\n\r\n\r\n\r\n### 代码实现：\r\n\r\n```java\r\nclass CustomStack {\r\n    private int stack[];\r\n    private int top;\r\n    private int diff[];\r\n    public CustomStack(int maxSize) {\r\n        this.stack = new int[maxSize];\r\n        this.top = -1;\r\n        this.diff = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top < stack.length - 1){\r\n            stack[++top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top > -1){\r\n            return stack[top--];\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        diff[0] = stack[0];\r\n        for(int i = 1;i <= top;i++){\r\n            diff[i] = stack[i] - stack[i-1];\r\n        }\r\n        if(k > top+1){\r\n            diff[0] += val;\r\n        }else{\r\n        diff[0] += val;\r\n        diff[k] -= val;\r\n        }\r\n\r\n        stack[0] = diff[0];\r\n        for(int i = 1;i <= top;i++){\r\n            stack[i] = diff[i] + stack[i-1];\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 复杂度分析：\r\n\r\n- 时间复杂度：O(N) N为题中方法 increment 参数k\r\n- 空间复杂度：O(N) N = maxSize\r\n\r\nps:使用差分数组思想不是最优解","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"forestie9":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085353261","body":"### Idea\nConvert int item in list to get the first value, and add up with k. Then convert the final value to item in a list.\n\n### Code\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        s = ''.join([str(i) for i in num])\n        summ = str(int(s) + k)\n        return [int(i) for i in summ]\n```\n### Complexity\nTime O(n) <br>\nSpace O(n)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086719398","body":"## Ideas\nUse addition array to make `increment` O(1)\n\n## Code\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.len = maxSize\n        self.s = []\n        self.inc = []\n        \n    def push(self, x: int) -> None:\n        if len(self.s) < self.len:\n            self.s.append(x)\n            self.inc.append(0)\n        \n    def pop(self) -> int:\n        if not self.inc: return -1\n        if len(self.inc) > 1:\n            self.inc[-2] += self.inc[-1]\n        return self.s.pop() + self.inc.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if self.inc:\n            self.inc[min(k, len(self.inc)) - 1] += val\n```\n## Complexity\nO(1) time and space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086905383","body":"## Ideas\nUse stack to track letter and count, reset values in every left bracket\n## Code\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        num = 0\n        string = ''\n        stack = []\n        for i in s:\n            if i.isdigit():\n                num = num*10 + int(i)                                \n            elif i == '[':\n                stack.append((string, num))\n                string = ''\n                num = 0\n            elif i == ']':\n                pre, k = stack.pop()\n                string = pre + k * string\n            elif i.isalpha():\n                string += i\n        return string\n```\n## Complexity\nO(n) time and space","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"houmk1212":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085369488","body":"# 思路\n用数组模拟加法运算，注意进位和数组的长度。\n\n# 代码\npublic class ClockIn20220401 {\n    public static void main(String[] args) {\n  \n    }\n\n    public static void swap(int[] nums, int i, int j) {\n        if (i != j) {\n            nums[i] = nums[i] ^ nums[j];\n            nums[j] = nums[i] ^ nums[j];\n            nums[i] = nums[i] ^ nums[j];\n        }\n    }\n    public static int[] solution(int[] nums, int k) {\n        int upper = 0;\n        int exp = 1;\n        int n = nums.length;\n        int kLeng = 0;\n        // 先找最大的范围\n        for (int e = 1; k / e > 0; e *= 10) {\n            kLeng ++;\n        }\n        int maxLeng = Math.max(n , kLeng);\n        int[] result = new int[maxLeng + 1];\n        int i = 0;\n        int j = n-1;\n        while (i < n / 2) {\n            swap(nums, i , j);\n            i ++;\n            j --;\n        }\n        i = 0;\n        while (i < maxLeng || upper == 1) {\n            int left = i < n ? nums[i] : 0;\n            int right = k / exp > 0 ? (k / exp) % 10 : 0;\n            result[i] = (left + right + upper) % 10;\n            upper = left + right + upper >= 10 ? 1 : 0;\n            exp *= 10;\n            i ++;\n        }\n        int[] ans = new int[i];\n        int p = 0;\n        for (int q = i - 1; q >= 0; q--) {\n            ans[p ++] = result[q];\n        }\n        return ans;\n    }\n}\n\n# 复杂度\n时间复杂度: O(n + e)   n是数组的长度， e是k的位数;\n\n空间复杂度：O(max(n,e))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086508946","body":"# 思路\r\n因为是找左右侧距离目标字符的最短距离，想到类似单调栈的找右侧最小或者最大值的做法。左侧的目标字符的下表可以用一个变量存，右侧的目标距离可以用单调栈来得到。当目标元素入栈时，弹出所有栈中非目标字符，并得到他们的结果。\r\n# 代码\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        int[] ans = new int[s.length()];\r\n        int pre = - 1;\r\n        for (int i = 0 ; i < s.length(); i ++) {\r\n            if (s.charAt(i) == c) {\r\n                while (!stack.isEmpty() && s.charAt(stack.peek()) != c) {\r\n                    int p = stack.pop();\r\n                    ans[p] = pre >= 0 ? Math.min(Math.abs(p - i) , Math.abs(p - pre)) : Math.abs(p - i);\r\n                }\r\n                pre = i;\r\n            }\r\n            stack.push(i);\r\n        }\r\n        while (!stack.isEmpty()) {\r\n            int p = stack.pop();\r\n            ans[p] = s.charAt(p) == c ? 0 : Math.abs(p - pre);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n# 复杂度\r\n时间复杂度： 每个字符串s中的字符都要入栈一次，出栈一次，所以时间复杂度是O（N）， N是字符串的长度。\r\n空间复杂度：栈的大小，是O（N）。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086760827","body":"# 思路\n需要实现方便按索引存取的栈结构，所以用数组。\n\n# 代码\n```\nclass CustomStack {\n    int[] stack;\n    int top = 0;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (top >= stack.length) return;\n        stack[top ++] = x;\n    }\n\n    public int pop() {\n        if (top == 0) return -1;\n        int peek = stack[top - 1];\n        top --;\n        return peek;\n    }\n\n    public void increment(int k, int val) {\n        int tmp = Math.min(top, k);\n        for (int i = 0; i < tmp; i++) {\n            sta ck[i] += val;\n        }\n    }\n}\n```\n\n# 复杂度分析\n时间复杂度： push和pop  都是O(1)  inc是O(K)\n\n空间复杂度： O(N)  N是数组的长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kelving-611":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085375480","body":"### 思路\n\n思路1: 把A转化成数字. 再跟K求和. 最后把输出结果转化成数组. (这种方法感觉没什么意思, 就是来回调用几个函数)\n思路2: 双指针. 从A, K的\"尾巴\"开始, 从后往前移动, 然后每次把得到的和放进数组里(不要忘记carry). 返回数组颠倒过来之后的结果. 注意: 时刻要注意carry. 如果双指针最后走到头, 还需要考虑carry的情况. \n\n### 代码\n\n思路2\n```python\nclass Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        carry = 0\n        i, j = len(A) - 1, len(str(K)) - 1\n        res = []\n\n        while i >= 0 or j >= 0: \n            val_1 = A[i] if i >= 0 else 0\n            val_2 = int(str(K)[j]) if j >= 0 else 0\n            i -= 1\n            j -= 1\n            val = val_1 + val_2 + carry\n            carry = val // 10\n            val %= 10\n            res.append(val)\n\n        if carry: \n            res.append(carry)\n        return res[::-1]\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(max(len(A), len(str(K)))) 也就是 O(A, str(K)之间较长的长度)\n- 空间复杂度：O(max(len(A), len(str(K)))) . 由于算法不是原地算法, 所以需要重新开辟空间. \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086658104","body":"# 思路\n分别记录两个数组: \n1. 当前位置到右边最近的c的距离\n2. 当前位置到左边最近的c的距离\n\n# 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        occurrence = deque()\n        for idx, i in enumerate(s): \n            if i == c: \n                occurrence.append(idx)\n\n        # print(occurrence)\n        occ_1, occ_2 = copy.deepcopy(occurrence), copy.deepcopy(occurrence)\n\n        dis_right = []  # 当前距离右边最近的c的距离\n        right_pos = occurrence[0]\n        for idx, char in enumerate(s): \n            if char == c: \n                right_pos = occ_1.popleft()\n                dis_right.append(0)\n            else: \n                dis_right.append(abs(idx - occurrence[0]))\n        # print(dis_right)\n\n        dis_left = []  # 当前距离左边最近的c的距离\n        left_pos = inf\n        for idx, char in enumerate(s): \n            if char == c: \n                left_pos = occ_2.popleft()\n                dis_left.append(0)\n            else: \n                dis_left.append(abs(idx - left_pos))\n\n        res = []\n        for i in range(len(dis_left)): \n            res.append(min(dis_left[i], dis_right[i]))\n        # print(dis_left)\n        return res\n\n```\n# 复杂度\n时间. 空间复杂度: 都是O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086705756","body":"## 思路\r\n模拟栈操作. \r\n\r\n## 代码\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.cur_size = 0\r\n        self.stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cur_size == self.maxSize: \r\n            return\r\n        self.stack.append(x)\r\n        self.cur_size += 1\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack: return -1\r\n        res = self.stack.pop()\r\n        self.cur_size -= 1\r\n        return res\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(self.cur_size, k)): \r\n            self.stack[i] += val\r\n```\r\n## 复杂度分析\r\n时间复杂度: \r\n`push`: O(1)\r\n`pop`: O(1)\r\n`increment`: O(N)\r\n空间复杂度: \r\n`push`: O(1)\r\n`pop`: O(1)\r\n`increment`: O(1). 由于是原地算法所以不占空间. ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lqyt2012":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085378454","body":"## 思路\n将数组转换成整数，然后与整数K做加法，之后再转换成数组返回\n## 代码\n```python\nclass Solution:\n    def add_array_with_num(self, num: List[int], k: int) -> List[int]:\n        sum = 0\n        digit = 1\n        for i in range(len(num)-1, -1, -1):\n            sum += num[i]*digit\n            digit *= 10\n        sum += k\n        result = [0]*len(str(sum))\n        for i in range(len(result)-1, -1, -1):\n            result[i] = sum % 10\n            sum //= 10\n        return result\n```\n## 复杂度分析\n空间复杂度：O(N)  \n时间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086634529","body":"## 思路\n两次遍历字符串，取其中较短的距离作为返回值\n## 代码\n```python\nclass Solution:\n    def find_smallest_dist(self, s:str, c:str) -> List[int]:\n         nearest_dist = len(s)\n         result = [0]*len(s)\n         for i in range(len(s)):\n             nearest_dist = 0 if s[i] == c else nearest_dist + 1\n             result[i] = nearest_dist\n         nearest_dist = len(s)\n         for i in range(len(s)-1, -1, -1):\n             nearest_dist = 0 if s[i] == c else nearest_dist + 1\n             result[i] = min(nearest_dist, result[i])\n         return result\n```\n## 复杂分析\n空间复杂度：O(N)  \n时间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086864051","body":"## 思路\n用数组来模拟栈，因为increment函数涉及到随机读取\n## 代码\n```python\nclass CustomStack:\n    def __init__(self, Max_Size=None):\n        self.stack = []\n        self.size = Max_Size\n        self.length = len(self.stack)\n    \n    def push(self, val:int) -> None:\n        if self.length < Max_Size:\n            self.stack.append(val)\n            self.length += 1\n        return None\n    \n    def pop(self) -> int:\n        if self.length > 0:\n            self.length -= 1\n            return self.stack.pop(-1)\n        return -1\n    \n    def increment(self, k:int, val:int) -> None:\n        if self.length > 0:\n            for i in range(min(k,self.length)):\n                self.stack[i] += val\n        return None\n```\n## 负责度分析\n空间复杂度：O(N)  \n时间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yz3516":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085380660","body":"### **思路**\r\n把k当做carry，从后往前遍历，每次加k的个位数值进res的头部并更新k；\r\n\r\n### **代码**\r\n```java\r\n    public List<Integer> addToArrayForm(int[] nums, int k) {\r\n        List res = new LinkedList<>();\r\n        for (int i = nums.length - 1; i >= 0 || k > 0; --i) { //这里可以用三元运算符简化；\r\n\t        if(i >= 0){\r\n\t\t\tres.add(0, (nums[i] + k) % 10);\r\n\t\t\tk = (nums[i] + k) / 10;\r\n\t\t} else {\r\n\t\t\tres.add(0, k % 10);\r\n\t\t\tk /= 10;\r\n\t\t}   \r\n        }\r\n        return res;\r\n    }\r\n```\r\n\r\n### **复杂度**\r\nTime: O(n), n is the length of nums;\r\nSpace: O(n), the res List uses extra space ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086526568","body":"### 思路\n先从左边往右扫，记录每个字符离C的距离；\n然后从右边往左扫，如果比第一次扫的距离小则替换掉，这样最后剩下的就是每个字符距离C最短的距离；\n\n### 代码\n```java\n        int[] result = new int[S.length()];\n        int currDist = S.length(); \n        for (int i = 0; i < S.length(); ++i) {\n            currDist = S.charAt(i) == C ? 0 : currDist + 1;\n            result[i] = currDist;\n        }\n\n        currDist = S.length();\n        for (int i = S.length() - 1; i >= 0; --i) {\n            currDist = S.charAt(i) == C ? 0 : currDist + 1;\n            result[i] = Math.min(result[i], currDist);\n        }\n        return result;\n    }\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)， N 为数组长度;\n- 空间复杂度：O(N)，创建了新的array result;","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086734511","body":"### 思路\n一般思路下increment的时间复杂度很高，每次inc的时候都要遍历inc对应的值；\\\n优化思路：只有在pop出来的时候才increment历史inc的值，这样inc是O(1)时间；这样需要一个inc array来储存历史上inc的值；\\\ninc[i]对应是的栈顶需要在pop时候inc的值，每次pop的时候需要更新inc[i - 1] = inc[i];\n\n### 代码\n```java\nclass CustomStack {\n    int n;\n    int[] inc;\n    Stack<Integer> stack;\n    \n    public CustomStack(int maxSize) {\n        n = maxSize;\n        inc = new int[n];\n        stack = new Stack<>();\n    }\n\n    public void push(int x) {\n        if (stack.size() < n)\n            stack.push(x);\n    }\n\n    public int pop() {\n        int i = stack.size() - 1;\n        if (i < 0)\n            return -1;\n        if (i > 0)\n            inc[i - 1] += inc[i];\n        int res = stack.pop() + inc[i];\n        inc[i] = 0;\n        return res;\n    }\n\n    public void increment(int k, int val) {\n        int i = Math.min(k, stack.size()) - 1;\n        if (i >= 0)\n            inc[i] += val;\n    }\n}\n```\n**复杂度分析**\\\n初始化时空均为O(N)，push, pop, increment 时空均为 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yongxi-zhou":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085383015","body":"## 思路 \n把num转换成整数后加上k，再转换成数组\n\n## 代码\n    class Solution(object):\n        def addToArrayForm(self, num, k):\n            \"\"\"\n            :type num: List[int]\n            :type k: int\n            :rtype: List[int]\n            \"\"\"\n            temp = 0\n            for item in num:\n                temp = temp * 10 + item\n            res = []\n            sumNum = temp + k\n            while sumNum != 0:\n                last = sumNum % 10\n                sumNum //= 10\n                res.insert(0, last)\n            return res\n## 复杂度\ntime O(max(num和k的长度))\nspace O(max(num和k的长度))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"caterpillar-0":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085387672","body":"### 思路\n将k加到最后一位，取余放在当前位，接着/10继续向前加\n### 代码\n``` c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n       //将K加到最后一位，依次向前\n       vector<int> res;\n       for(int i=num.size()-1;i>=0 || k>0;i--,k/=10){\n           //if(i>=0){\n           //    int sum=num[i]+k;\n           //    res.push_back(sum%10);\n           //}\n           //else{\n           //    res.push_back(k%10);\n          // }\n          //上面这一段还是没想清楚\n          if(i>=0){\n              k+=num[i];\n          }\n          res.push_back(k%10);\n       }\n       reverse(res.begin(),res.end());\n       return res;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：O（n）遍历一遍数组\n* 空间复杂度：O（n），建立了数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086537714","body":"### 思路\n两次遍历，从左到右更新一遍，从右到左更新一遍\n### 代码\n``` C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int>res(s.size());\n        //方法二，只遍历两次，先从左到右，再从右到左\n        int prev=INT_MAX/2;//防止越界，所以除以2\n        for(int i=0;i<s.size();i++){\n            if(s[i]==c){\n                prev=i;\n            }\n            res[i]=i-prev;\n        }\n        prev=INT_MAX/2;\n        for(int i=s.size()-1;i>=0;i--){\n            if(s[i]==c){\n                prev=i;\n            }\n            res[i]=min(abs(res[i]),prev-i);\n        }\n    return res;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：O（n）\n* 空间复杂度：O（n）\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086767470","body":"### 思路\n利用数组，使用了三个参数，分别表示最大容量，当前栈顶位置和指向栈的指针\n### 代码\n``` C++\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        size=maxSize;\n        arr=new int[size];\n        top=-1;\n    }\n    ~CustomStack(){//析构函数\n        delete [] arr;\n    }\n    void push(int x) {\n        if(top==size-1){//栈满\n            return ;\n        }\n        arr[++top]=x;\n    }\n    int pop() {\n        if(top==-1){//栈空\n            return -1;\n        }\n        return arr[top--];//弹出栈顶元素，并--\n    }\n    void increment(int k, int val) {\n        if(top+1<k){//所有元素都增加val\n            for(int i=0;i<=top;i++){\n                arr[i]+=val;\n            }\n        }\n        else{\n            for(int i=0;i<k;i++){\n                arr[i]+=val;\n            }\n        }\n    }\nprivate:\n    int size;//栈的最大容量\n    int top;//当前元素数量,栈顶\n    int* arr;//指向栈的指针\n};\n```\n### 复杂度分析\n* 时间复杂度：push,pop O(1)\n* 空间复杂度O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kite-fly6618":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085387840","body":"### 思路： \n模拟加法，从后往前逐位相加\n\n### 代码：\n```js\nvar addToArrayForm = function(num, k) {\n    let res = []\n    let len = num.length\n    for (let i = len-1;i>=0;i--) {\n        let sum = num[i] + k%10\n        k = Math.floor(k/10)\n        if (sum >=10) {\n            k++\n            sum = sum-10\n        }\n        res.unshift(sum)\n    }\n    // k > 0 往数组上继续添加高位\n    while(k>0) {\n        res.unshift(k%10)\n        k = Math.floor(k/10)\n    }\n    return res\n};\n```\n### 复杂度：\n时间复杂度: O(n)  \n空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086647422","body":"### 思路： \n两头遍历，取较小值\n\n### 代码：\n```js\nvar shortestToChar = function(s, c) {\n    let len = s.length\n    let left = []\n    let right = []\n    for (let i = 0;i <len;i++) {\n        if (s.indexOf(c,i)==-1) {\n            left.push(Infinity)\n        } else {\n            left.push(s.indexOf(c,i)-i)\n        }  \n    }\n    for (let i = len-1;i >= 0;i--) {\n        if (s.lastIndexOf(c,i)==-1) {\n            right.unshift(Infinity)\n        } else {\n            right.unshift(i-s.lastIndexOf(c,i))\n        }\n        \n    }\n    for (let i = 0;i < len;i++) {\n        left[i] = Math.min(left[i],right[i])\n    }\n    return left\n};\n```\n### 复杂度：\n时间复杂度: O(n)  \n空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086772995","body":"### 思路： \n数组模拟栈\n\n### 代码：\n```js\nvar CustomStack = function(maxSize) {\n    this.size = maxSize\n    this.data = []\n};\n\nCustomStack.prototype.push = function(x) {\n    if (this.data.length < this.size) {\n        this.data.push(x)\n    }\n};\n\nCustomStack.prototype.pop = function() {\n    if(this.data.length!=0) {\n        return this.data.pop()\n    }else {\n        return -1\n    }\n\n};\n\nCustomStack.prototype.increment = function(k, val) {\n    let len = Math.min(k,this.data.length)\n    for (let i = 0;i < len;i ++) {\n        this.data[i] = this.data[i] + val\n    }\n};\n```\n### 复杂度：\n时间复杂度: O(n)  \n空间复杂度: O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xixiao51":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085396374","body":"### 思路\r\n\r\n从最后一位开始模拟加法进位计算， 注意不可以直接转化成数字相加会溢出 - Integer\r\n\r\n### 代码\r\n\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> result = new ArrayList<>();\r\n        int len = num.length - 1;\r\n        //先将最后一位加入list，此时list为倒序\r\n        int sum = num[len] + k;\r\n        result.add(sum % 10);\r\n        int carry = sum / 10;\r\n        \r\n        //从倒数第二位开始循环\r\n        for(int i = len - 1; i >= 0; i --) {\r\n            sum = num[i] + carry;\r\n            result.add(sum % 10);\r\n            carry = sum / 10;\r\n        }\r\n        \r\n        //如果carry还有进位\r\n        while(carry > 0) {\r\n            result.add(carry % 10);\r\n            carry /= 10;\r\n        }\r\n        \r\n        //反转数组\r\n        Collections.reverse(result);\r\n        return result;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(max(N, log k))，其中 N 为数组num长度。\r\n- 空间复杂度：O(max(N, log k)), 储存结果的新数组\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086552671","body":"### 思路\n\n前序遍历数组找出与左侧的字母的最短距离，后序遍历数组找出与右侧字母的最短距离，两者取其最小为最终结果。\n\n### 代码\n\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] result = new int[len];\n        int max = len - 1;\n        \n        int cur = max;\n        for(int i = 0; i < len; i++) {\n            if (s.charAt(i) == c) {\n                result[i] = 0;\n                cur = 0;\n            } else {\n                result[i] = Math.min(max, ++cur);\n            }\n        }\n        \n        cur = max;\n        for(int i = len - 1; i >= 0 ; i--) {\n            if (s.charAt(i) == c) {\n                cur = 0;\n            } else {\n                result[i] = Math.min(result[i], ++cur);\n            }\n        }\n        \n        return result;\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为String的长度。\n- 空间复杂度：O(N), 其中 N 为String的长度。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086709764","body":"### 思路\n\n用数组模拟栈操作\n\n### 代码\n\n\n```java\nclass CustomStack {\n    private int[] arr;\n    private int top;\n    \n\n    public CustomStack(int maxSize) {\n        arr = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top < arr.length - 1) {\n            arr[++top] = x;\n        }\n    }\n    \n    public int pop() {\n        return top == -1 ? -1 : arr[top--];\n    }\n    \n    public void increment(int k, int val) {\n        for(int i = 0; i < k && i <= top ; i++) {\n            arr[i] += val; \n        }\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：\npush: O(1)\npop: O(1)\nincrement: O(K)\n- 空间复杂度：\npush: O(1)\npop: O(1)\nincrement: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"venchyluo":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085407589","body":"从尾到头 一位一位计算。 可以另开list 倒叙存 ｜｜ 直接修改原数组，多位的从头插入。\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        # brute force, convert to int then to list\r\n        carry, i = 0, len(num) -1\r\n        while carry or i >= 0 or k:\r\n            temp = (num[i] if i >= 0 else 0) + (k % 10 if k else 0) +  carry            \r\n            carry = temp // 10\r\n            \r\n            if i >= 0:\r\n                num[i] = temp % 10\r\n            else:\r\n                num.insert(0,temp % 10)\r\n            \r\n            k //= 10\r\n            i -= 1\r\n\r\n        return num\r\n```\r\ntime complexity: O(N)   \r\nspace complexity: O(N) （不考虑返回值，额外使用O(1))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ballerjay":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085407797","body":"### 解题思路\n\n默认人工计算的过程，k与数组最后一位相加，然后k去掉个位的数字；然后k与倒数第二位相加，也就是十位，然后去掉十位的数组；依次循环。。。\n\n还有一些特殊的情况就是数组循环结束之后，k还存在值，所以需要继续往res中添加\n\n\n\n```JavaScript\nfunction solution(num,k) {\n  // 默认人工计算的过程，k与数组最后一位相加，然后k去掉个位的数字；然后k与倒数第二位相加，也就是十位，然后去掉十位的数组；依次循环。。。\n  // 还有一些特殊的情况就是数组循环结束之后，k还存在值，所以需要继续往res中添加\n  const res = []\n  const len = num.length\n  for(let i = len - 1;i >= 0 || k > 0;i --, k = Math.floor(k / 10)) {\n    if(i >= 0) {\n      k += num[i]\n    }\n    res.unshift(k % 10)\n  }\n  return res\n}\n```\n\n### 时间复杂度\n\nO(max(n,k)),n为数组的长度,k为数字的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086658551","body":"``` js\nvar shortestToChar = function(s, c) {\n    // 中心扩散法，从当前元素为中心，寻找左右两边的c值，然后找出最短距离\n    const res = [] \n    for(let i = 0;i < s.length;i ++) {\n    let l = r = i\n    while(l >= 0) {\n        if(s[l] == c) break\n        l--\n    }\n    while(r < s.length) {\n        if(s[r] == c) break\n        r++\n    }\n    if(l < 0) l = -10000\n    if(r === s.length) r = 10000\n    res.push(Math.min(i - l, r - i))\n    }\n    return res\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"magua-hub":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085412418","body":"思路\n模拟加法，本质上是以到高精度加法。先把数组翻转，从最后一位开始加，最后在翻转过来\n\n代码实现\n```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        reverse(num.begin(), num.end());\n\n        for(auto& x : num) {\n            k += x;\n            x = k % 10;\n            k /= 10;\n        }\n\n        while(k) num.push_back(k % 10), k /= 10;\n        reverse(num.begin(), num.end());\n        return num;\n    }\n};\n```\n复杂度分析:\n\n时间复杂度O(n)\n\n空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086550335","body":"思路\n分析一下可知，只有两种情况，即c在这个数的左边或者右边，所以我们遍历两次，一次从前向后，一次从后向前，最后把两次遍历的结果取min\n\n代码\n```\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> res(n, INT_MAX);\n        for(int i = 0, j = -1; i < n;  i ++){\n            if(s[i] == c) j = i;\n            if(j != -1) res[i] = i - j;\n        }\n        for(int i = n , j = -1; i >= 0; i --) {\n            if(s[i] == c) j = i;\n            if(j != -1) res[i] = min(res[i], j - i);\n        }\n        return res;\n\n    }\n};\n```\n复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)结果数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086762515","body":"思路\n使用数组实现栈\n\n代码\n```C++\nclass CustomStack {\npublic:\n    vector<int> stk;\n    int mx;\n    CustomStack(int maxSize) {\n       // stk.resize(maxSize);\n        mx = maxSize;\n    }\n    \n    void push(int x) {\n        if(stk.size() < mx)\n            stk.push_back(x);\n    }\n    \n    int pop() {\n        if(!stk.empty()){\n            int val = stk.back();\n            stk.pop_back();\n            return val;\n        }else {\n            return -1;\n        }\n        \n        \n    }\n    \n    void increment(int k, int val) {\n        if(stk.size() < k) {\n            for(int i = 0; i < stk.size(); i ++)\n                stk[i] += val;\n        }else if(stk.size() >= k){\n            for(int i = 0; i < k; i ++)\n                stk[i] += val;\n        }\n    }\n};\n\n\n复杂度分析\n时间复杂度： push:O(1)、pop：O(1)\n空间复杂度 O(N) ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suukii":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085420206","body":"```c\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* addToArrayForm(int* num, int numSize, int k, int* returnSize){\n    int resLen = fmax(numSize + 1, 5); // k 的取值范围 [1, 10^4]，加上进位最多是 5 位数\n    int* res = malloc(sizeof(int) * resLen);\n    int r, w;\n\n    w = resLen - 1;\n    r = numSize - 1;\n\n    while (k || r >= 0) {\n        if (r >= 0) k += num[r--];\n        res[w--] = k % 10;\n        k /= 10;\n    }\n\n    int realStart = w + 1;\n    *returnSize = resLen - realStart;\n    return res + realStart;\n}\n```\n- ****Time:**** $O(max(N,logk))$\n- ***Space:** $O(1)$*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086484326","body":"```c\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* shortestToChar(char * s, char c, int* returnSize) {\n    int len = strlen(s);\n    int* res = malloc(sizeof(int) * len);\n\n    res[0] = s[0] == c ? 0 : len;\n\n    for (int i = 1; i < len; ++i)\n        res[i] = s[i] == c ? 0 : res[i - 1] + 1;\n\n    for (int i = len - 2; i >= 0; --i)\n        res[i] = fmin(res[i], res[i + 1] + 1);\n\n    *returnSize = len;\n    return res;\n}\n```\n\n- ****Time:**** $O(N)$，N 是 S 的长度。\n- ****Space:**** $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086883763","body":"```cpp\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) : maxSize_(maxSize), top_(-1) {\n        stack_.resize(maxSize);\n        inc_.resize(maxSize);\n    }\n    \n    void push(int x) {\n        if (top_ < maxSize_ - 1) stack_[++top_] = x;\n    }\n    \n    int pop() {\n        if (top_ == -1) return -1;\n        if (top_ > 0) inc_[top_ - 1] += inc_[top_];\n        int val = stack_[top_] + inc_[top_];\n        inc_[top_--] = 0;\n        return val;\n    }\n    \n    void increment(int k, int val) {\n        int idx = min(k - 1, top_);\n        if (idx >= 0) inc_[idx] += val;\n    }\nprivate:\n    vector<int> stack_;\n    vector<int> inc_;\n    int maxSize_;\n    int top_;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dzwhh":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085428758","body":"### 思路\n逐位相加,当数组不为空或者k不为0，从末位数字开始，加k当前位(k%10)+进位(carry初始是0),加和后push到开辟的数组去同时只push当前位，循环结束最后判断一次是否还有进位，如果有再push一次，最后反转数组得到最终结果\n\n### 关键点\n- 处理当前位是 num % 10\n- 处理进位是 num / 10\n- 需要判断数组是空，或者k是0的情况\n\n### 代码\n- js版本\n```js\nconst addToArrayForm = (num, k) => {\n  let res = []; // 最终输出结果数组\n  let carry = 0; // 标记进位\n  let tail = num.length - 1; // 数组末位元素，代表各个位的数字\n  let sum = 0; // 各个位加和的结果\n\n  while(tail >= 0 || k != 0) {\n    let x = tail >= 0 ? num[tail] : 0;\n    let y = k != 0 ? k % 10 : 0;\n    sum = x + y + carry; //num数组当前位+k当前位+进位\n    res.push(sum % 10); //sum 可能有进位 取模 10 剔除掉进位数字\n    tail--; //数组向前挪动\n    k = Math.floor(k/10);  // k向高位数字挪动\n    carry = Math.floor(sum / 10); //记录进位数字\n  }\n  if(carry === 1)\n    res.push(carry); //最后一次加和如果有进位最后的1push到数组\n  return res.reverse(); // 从后往前添加的数组，需要反转得到最终结果\n}\n\n```\n### 复杂度分析\n时间复杂度: O(max(n,k))\n空间复杂度: O(max(n,k))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086588218","body":"### 思路\n先把字符串中等于c字符的对应下标存到数组res中，作为对比项使用，同时设置指向c字符下标数组的指针p，然后在遍历字符串每个字符，把每个字符的下标数值与res的c字符下标相减，得到距离，每次只比较c字符下标当前值和后继值，如果发现当前值的差值比后继值的差值大，那就把p指针向后挪一位，因为这时候当前值不需要在以后的判断中使用，因为肯定比后面的c字符位置要远,同时把字符串当前字符位置和c字符下标数组对应位置的差异存到dist最终结果数组中\n\n### 关键点\n- 下标差值的比较\n- 当前字符位置与c字符前后2个位置的距离比较，大的代表距离远，需要移动指针\n\n### 代码\n\n- js 版本\n\n```js\nconst shortestToChar = (s, c) => {\n  let res = []; // c字符下标数组\n  let p = 0; // 指向c字符下标数组的指针\n  let dist = []; // 最终结果\n\n  // 把字符串中等于c字符的对应下标存在res数组中\n  for(let i = 0; i < s.length; i++) {\n    if (s[i] ===  c)\n      res.push(i)\n  }\n  \n  // 遍历字符串字符，比较每个字符下标与对应c字符下标的差值\n  for(let j = 0; j < s.length; j++) {\n    // 数组元素和c下标数组前后两个值对比,如果前一个比较值比后一个比较值大，p指针向后挪一位\n    if (p < res.length && Math.abs(j - res[p]) > Math.abs(j - res[p+1])) \n      p++; \n    dist.push(Math.abs(j - res[p]));\n  }\n  return dist;\n};\n```\n\n### 复杂度分析\n\n时间复杂度:O(m+n)\n空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086839940","body":"## 1381. Design a Stack With Increment Operation「设计一个支持增量操作的栈」\n- 题目地址: https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n\n### 题目描述\n请你设计一个支持下述操作的栈。\n实现自定义栈类 CustomStack ：\n- CustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\n- void push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\n- int pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\n- void inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n\n### 前置知识\n- 数组、栈\n\n### 思路\n用数组模拟栈操作，maxSize 数组容量也是栈容量，设置一个top指针，作为指向栈顶的指针，每次向栈增加一个元素就是向top位置下标添加一个元素，同时top向后挪一位,pop栈顶操作就是返回top前一位元素; inc 操作可以判断k和top谁小，就遍历范围定到谁作为边界添加val\n\n### 关键点\n- top指针的前后移动，如果初始值为0，那push是先添加元素在挪动top，pop是返回top-1位置的元素\n\n### 代码\n- js 版本\n```js\n/**\n * @param {number} maxSize\n */\n var CustomStack = function(maxSize) {\n  this.stack = new Array(maxSize);\n  this.top = 0;\n};\n\n/** \n* @param {number} x\n* @return {void}\n*/\nCustomStack.prototype.push = function(x) {\n  if (this.top === this.stack.length)\n      return;\n  else   \n      this.stack[this.top++] = x;\n};\n\n/**\n* @return {number}\n*/\nCustomStack.prototype.pop = function() {\n  if (this.top === 0)\n    return -1\n  return this.stack[--this.top];\n  \n};\n\n/** \n* @param {number} k \n* @param {number} val\n* @return {void}\n*/\nCustomStack.prototype.increment = function(k, val) {\n  let len = Math.min(k,this.top)\n  for(let i = 0; i < len; i++){\n      this.stack[i] += val\n  }\n};\n```\n\n### 复杂度分析\n时间复杂度: O(n)\n空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lyuliangliu":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085434802","body":"\n### 思路\nAdding from rear to front until both num and k are exhausted.\n### Code\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int carry = 0;\n        List<Integer> result = new LinkedList<>();\n        int i = num.length - 1;\n        while (i >= 0 || k > 0) {\n            int digitFromK = k % 10;\n            int currentDigit = digitFromK + (i >= 0 ? num[i] : 0) + carry;\n            if (currentDigit >= 10) {\n                carry = 1;\n                currentDigit -= 10;\n            } else {\n                carry = 0;\n            }\n            result.add(0, currentDigit);\n            k /= 10;\n            i--;\n        }\n        if (carry == 1) {\n            result.add(0, 1);\n        }\n        return result;\n    }\n}\n```\n### 复杂度\n* Time: O(N) \n* Space: O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086543333","body":"### Idea\n* Go forward: record the distance between each letter and the latest c in its left;\n* Go backward: update the distance if a letter is closer to the latest c in its right\n### Code\n```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] ans = new int[s.length()];\n        int lastIndexC = Integer.MAX_VALUE;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                ans[i] = 0;\n                lastIndexC = i;\n            } else if (lastIndexC == Integer.MAX_VALUE) {\n                ans[i] = Integer.MAX_VALUE;\n            } else {\n                ans[i] = i - lastIndexC;\n            }\n        }\n        lastIndexC = Integer.MAX_VALUE;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                lastIndexC = i;\n            } else if (lastIndexC - i < ans[i]) {\n                ans[i] = lastIndexC - i;\n            }\n        }\n        return ans;\n    }\n}\n```\n### Complexity\n* Time: 2N\n* Space: N","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086707378","body":"###Idea\nInitialize an array of size maxSize. Use a pointer top to indicate current stack top.\n### Code\n```\nclass CustomStack {\n    \n    int[] stack;\n    int top;\n    int maxSize;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n        this.maxSize = maxSize;\n    }\n    \n    public void push(int x) {\n        if (top < this.maxSize - 1) {\n            stack[++top] = x;\n        }\n    }\n    \n    public int pop() {\n        return top == -1 ? -1 : stack[top--];\n    }\n    \n    public void increment(int k, int val) {\n        for (int i = 0; i < k && i <= top; i++) {\n            stack[i] += val;\n        }\n    }\n}\n```\nComplexity:\n* Time: push/pop O(1), inc O(K)\n* Space: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawyuan97":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085443568","body":"\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n\r\n```\r\n整数的 数组形式  num 是按照从左到右的顺序表示其数字的数组。\r\n\r\n例如，对于 num = 1321 ，数组形式是 [1,3,2,1] 。\r\n\r\n给定 num ，整数的 数组形式 ，和整数 k ，返回 整数 num + k 的 数组形式 。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：num = [1,2,0,0], k = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n\r\n\r\n示例 2：\r\n\r\n输入：num = [2,7,4], k = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n\r\n\r\n示例 3：\r\n\r\n输入：num = [2,1,5], k = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= num.length <= 104\r\n0 <= num[i] <= 9\r\nnum 不包含任何前导零，除了零本身\r\n1 <= k <= 104\r\n```\r\n\r\n## 前置知识\r\n\r\n数组 取模 取余 列表相加\r\n\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  见代码\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        carry = 0\r\n        # 从低位到高位进行加法\r\n        # 判断是否需要进位\r\n        # 如果num比k大 就可以结束了\r\n        for i in range(len(num)-1,-1,-1):\r\n            num[i],carry  = (num[i] + k%10 + carry)%10,(num[i] + k%10 + carry)//10\r\n            k //= 10\r\n        # 如果num比k小 考虑继续进位\r\n        high = []\r\n        k = k + carry\r\n        if k:\r\n            high = [int(i) for i in str(k)]\r\n        return high + num\r\n        \r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086516918","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n窗口的左右边界\r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n将字符c作为窗口的边界 每次记录窗口的左右边界 然后开始计算距离\r\n\r\n## 关键点\r\n\r\n-  如何确定第一个窗口？\\\r\n  由于第一个窗口可能不存在左边界，因此先从索引位置0开始判断左边界是否存在，如果不存在可以将左边界置为n，那么第一个窗口可以不考虑左边界\r\n- 如何更换窗口？\\\r\n  随着对字符串的遍历，一定会遍历到窗口右边界，那么新窗口的左边界就是当前索引i\r\n- 如何使用字符串查找函数？ \\\r\n  s.find(c,beg=i,end=n)，该函数会从字符串s中查找字符c，然后beg表示开始的索引，end表示结束的索引（左闭右开）；如果找不到返回-1\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        \"\"\"寻找距离最近的字符的长度 \r\n\r\n        Args:\r\n            s(str):字符串\r\n            c(str):字符\r\n        \r\n        Returns:\r\n            ans(List[int]):返回结果列表\r\n\r\n        \"\"\"\r\n        n = len(s)\r\n        ans = [0] * n\r\n        \r\n        # 寻找左边界 如果没有左边界 那么直接将左边界设置为字符串长度\r\n        l = 0 if s[0] == c else n\r\n        # 从索引位置1开始搜索字符c\r\n        r = s.find(c,1) \r\n\r\n        for i in range(n):\r\n            # 取距离两个边界的最小距离\r\n            ans[i] = min(abs(i-l),abs(r-i))\r\n            # 考虑移动边界的问题\r\n            if i == r:\r\n                l = i\r\n                r = s.find(c,i+1)\r\n        return ans\r\n        \r\n\r\n\r\n        \r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086815684","body":"\r\n## 题目地址(1381. 设计一个支持增量操作的栈)\r\n\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 CustomStack ：\r\n\r\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n\r\n \r\n\r\n示例：\r\n\r\n输入：\r\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\r\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\r\n输出：\r\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\r\n解释：\r\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\r\ncustomStack.push(1);                          // 栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\r\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\r\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\r\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\r\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= maxSize <= 1000\r\n1 <= x <= 1000\r\n1 <= k <= 1000\r\n0 <= val <= 100\r\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n设置三个类的成员变量，分别存储栈，栈的最大长度以及栈的当前长度，然后实现push、pop以及inc操作\r\n\r\n## 关键点\r\n\r\n-  用到列表的append函数，向后添加元素\r\n-  用到列表的pop()函数，可以返回列表中对应索引的元素\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.size = maxSize\r\n        self.len = len(self.stack)\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.len < self.size:\r\n            self.stack.append(x)\r\n            self.len += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.len > 0:\r\n            self.len -= 1\r\n            return self.stack.pop(-1)\r\n        else:\r\n            return -1 \r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if self.len < k:\r\n            self.stack = [i+val for i in self.stack]\r\n        else:\r\n            self.stack[:k] = [i+val for i in self.stack[:k]]\r\n        \r\n\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$ O(1) $\r\n- 空间复杂度：$ O(n) $ \r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duke-github":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085447103","body":"## 思路\n    将数组的最后一位加到k上，然后k对10取余，得到的结果放到linkedList的第一位。数组长度不足时则只操作k。直到k小于0并且数组遍历结束。\n## 复杂度分析\n    时间复杂度O(n) 空间复杂度O(n)\n## 代码\n```\npublic List<Integer> addToArrayForm2(int[] num, int k) {\n    LinkedList<Integer> ans = new LinkedList<>();\n    int i = num.length - 1;\n    while (k >= 1 || i >= 0) {\n        if (i >= 0) {\n            k += num[i];\n        }\n        i--;\n        ans.addFirst(k % 10);\n        k /= 10;\n    }\n    return ans;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086581512","body":"##   思路\r\n    预设一个初始为0的k来记录上一次c出现的下标，循环将i-k当做答案。\r\n    当c再次出现的时候 只需要将(i+k)/2到i的下标重新赋值即可。\r\n    使用flag标记来解决当0下标为c的时候只会对0到下一个下标之前的全部数据赋值的错误\r\n##   复杂度\r\n    时间复杂度O(n) 空间复杂度O(n)\r\n##  代码\r\n```\r\npublic int[] shortestToChar(String s, char c) {\r\n    int k = 0;\r\n    int[] ans = new int[s.length()];\r\n    boolean flag = false;\r\n    for (int i = 0; i < s.length(); i++) {\r\n        if (s.charAt(i) == c) {\r\n            for (int j = i; flag && j > (i + k) >> 1 || !flag && j >= k; j--) {\r\n                ans[j] = i - j;\r\n            }\r\n            k = i;\r\n            flag = true;\r\n        }\r\n        ans[i] = i - k;\r\n    }\r\n    return ans;\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086764486","body":"##   思路\n      数组实现，使用两个值分别保存最大长度和当前长度，添加和移除的时候就从当前长度位上操作\n##  代码\n```\nclass CustomStack {\n    int[] value;\n    int maxSize;\n    int current = 0;\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        this.value = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(current==maxSize){\n            return;\n        }\n        value[current++]=x;\n    }\n    \n    public int pop() {\n        if(current==0){\n            return -1;\n        }\n        return value[--current];\n    }\n    \n    public void increment(int k, int val) {\n        for(int i=0;i<k&&i<current;i++){\n            value[i]+=val;\n        }\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yaya-bb":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085449145","body":"\n## 题目地址(989. 数组形式的整数加法)\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n## 题目描述\n\n```\n整数的 数组形式  num 是按照从左到右的顺序表示其数字的数组。\n\n例如，对于 num = 1321 ，数组形式是 [1,3,2,1] 。\n\n给定 num ，整数的 数组形式 ，和整数 k ，返回 整数 num + k 的 数组形式 。\n\n \n\n示例 1：\n\n输入：num = [1,2,0,0], k = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n\n\n示例 2：\n\n输入：num = [2,7,4], k = 181\n输出：[4,5,5]\n解释：274 + 181 = 455\n\n\n示例 3：\n\n输入：num = [2,1,5], k = 806\n输出：[1,0,2,1]\n解释：215 + 806 = 1021\n\n\n \n\n提示：\n\n1 <= num.length <= 104\n0 <= num[i] <= 9\nnum 不包含任何前导零，除了零本身\n1 <= k <= 104\n```\n\n## 前置知识\n\n- 数组遍历、逐位相加的方法\n\n\n## 思路\n1、数组输出，需要通过for循环将数组输出\n2、将数组和整数依次相加，整数获取位数上的数可通过依次进行求余运算\n\n## 关键点\n\n-  熟悉整数获取位数上的方法\n- 熟悉数组的API，push（）、reverse（）\n\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let res = [];\n    let n = num.length;\n    for(let i = n -1; i >= 0; i--)\n    {\n        let sum = num[i] + k%10;\n        k = Math.floor(k/10);\n        if(sum>=10)\n        {\n            k++;\n            sum = sum -10;\n        }\n        res.push(sum);\n    }\n    for(;k>0;k = Math.floor(k/10))\n    {\n        res.push(k%10);\n    }\n    res.reverse();\n    return res;\n\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$，\n- 空间复杂度：$O(1)$，没有额外增加空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086657535","body":"\n## 题目地址(821. 字符的最短距离)\n\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\n\n## 题目描述\n\n```\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n\n \n\n示例 1：\n\n输入：s = \"loveleetcode\", c = \"e\"\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n\n\n示例 2：\n\n输入：s = \"aaab\", c = \"b\"\n输出：[3,2,1,0]\n\n\n \n\n提示：\n1 <= s.length <= 104\ns[i] 和 c 均为小写英文字母\n题目数据保证 c 在 s 中至少出现一次\n```\n\n## 前置知识\n\n- 数组的API\n- 双指针\n\n\n## 思路\n（本题参考了其他人的代码）\n- 主要需要解决的问题是取离c最小的距离\n\n## 关键点\n\n-  判断离c最小的距离\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let num = [];\n    num.length === s.length;\n    let indexNext=s.indexOf(c);//indexNext表示下一个c的下标， \n    let index=indexNext;//index表示前一个c的坐标\n    //index也在当前字符的右边，否则在左右都有C字符的时候，当前字符必在index和indexNext的中间。\n       for(let i = 0; i < s.length; i++){\n            if(s[i] == c){//每当遍历到C就更新index和indexNext\n                num[i] = 0;\n                index = i;\n                indexNext = s.indexOf(c, i+1);\n            }else{\n                num[i] = Math.min(Math.abs(index - i), Math.abs(indexNext - i));\n            }\n        }\n    return num;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086888061","body":"\n## 题目地址(1381. 设计一个支持增量操作的栈)\n\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n\n## 题目描述\n\n```\n请你设计一个支持下述操作的栈。\n\n实现自定义栈类 CustomStack ：\n\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n\n \n\n示例：\n\n输入：\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n输出：\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\n解释：\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\ncustomStack.push(1);                          // 栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\n\n\n \n\n提示：\n\n1 <= maxSize <= 1000\n1 <= x <= 1000\n1 <= k <= 1000\n0 <= val <= 100\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\n```\n\n## 前置知识\n\n- 栈\n\n\n## 思路\n主要难点在于void inc(int k, int val)，但暂时只会使用for循环进行完成，但复杂度较高\n\n## 关键点\n\n-  需要考虑个数需求以及栈的元素是否为0\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize;\n    this.Stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.Stack.length >= this.maxSize)\n    {\n        return;\n    }\n    this.Stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.Stack.length == 0)\n    {\n        return -1;\n    }\n    return this.Stack.pop();\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    if(this.Stack.length <= k)\n    {\n        for(let i = 0; i < this.Stack.length ;i++)\n    {\n            this.Stack[i] += val;\n    }\n    }\n    else\n    {\n        for(let j = 0; j < k ; j++)\n        {\n            this.Stack[j] += val;\n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bzlff":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085454092","body":"### 思路\n\n- 将整型列表拼接为字符串后，再转为int型与k相加\n- 将相加后的结果转为字符串后遍历，生成整型列表\n\n### 代码\n\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num = int(\"\".join(list(map(str, num))))\n        return [int(i) for i in str(num + k)]\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086650955","body":"### 思路\n\n1. 先遍历列表s，找到每一个元素c的索引位置，并添加到一个c_pos列表中\n2. for循环len(s)，如果当前位置的索引i小于c_pos[0]，即在c_pos[0]的左侧， 那么就往ans列表中添加“c_pos[0] - i“\n3. 如果当前的位置索引i大于c_pos[-1]，机在c_pos[-1]的右侧，那么就往ans列表中添加“i - c_pos[-1]”\n4. 如果当前的位置索引等于c_pos[p], p=0, 即当前的索引对于的就是元素c，那么就往ans列表中添加“0”, 同时p+=1\n5. 否则，如果恰巧当前位置前后都有元素c的索引，那么就判断离着谁更近，就往ans列表中“min(c_pos[p]-i, i-c_pos[p-1])”\n\n### 代码\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        \n        c_pos, ans = [], []\n        for idx, i in enumerate(s):\n            if i == c:\n                c_pos.append(idx)\n        \n        p = 0\n        for i in range(len(s)):\n            if i < c_pos[0]:\n                ans.append(c_pos[0] - i)\n            elif i > c_pos[-1]:\n                ans.append(i - c_pos[-1])\n            elif i == c_pos[p]:\n                ans.append(0)\n                p += 1\n            else:\n                ans.append(min(c_pos[p] - i, i - c_pos[p-1]))\n        return ans\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086763675","body":"### 代码\n\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n        self.length = 0\n        \n\n    def push(self, x: int) -> None:\n        if self.length < self.maxSize:\n            self.stack.append(x)\n            self.length += 1\n\n    def pop(self) -> int:\n        if self.length > 0:\n            self.length -= 1\n            return self.stack.pop()\n        \n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(self.length, k)):\n            self.stack[i] += val\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(1) / O(K)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maggiexie00":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085454513","body":"### 思路\r\n\r\n从尾部开始，原地更新num中的数值，k处理完则break\r\n\r\n***把k当作carry\r\n***题目已知num长度最多10^4，k最多5位数，若开辟新数组，则极大增加时间复杂度（遍历num），因而选择原地更新num数组，最坏情况是进行6次操作。\r\n*** key point 是k处理完就停止，无需遍历num。\r\n\r\n### 代码\r\n\r\n\r\n    def addToArrayForm(self, num, k) :\r\n\r\n        p=len(num)-1\r\n        while p>-1 and k!=0:\r\n            tmp=num[p]+k%10\r\n            num[p]=tmp%10\r\n            k=k//10+tmp//10\r\n            p-=1    \r\n\r\n        while k:\r\n            num=[k%10]+num\r\n            k//=10\r\n\r\n        return num\r\n\r\n### 复杂度\r\n空间复杂度 O(1)\r\n时间复杂度 O(N）其中N为k的位数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086642755","body":"### 思路\r\n\r\n两次遍历\r\n\r\n记录上一个字符c出现的位置，从头走一遍，计算距离，再从尾部走一遍，更新距离为两次计算中的较小值。\r\n\r\n### 代码\r\n\r\n\r\n    def shortestToChar(self, s, c):\r\n        last=-10000\r\n        ans=[]\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                last=i\r\n            ans.append(i-last)\r\n        last=10000\r\n        for i in range(len(s)-1,-1,-1):\r\n            if s[i]==c:\r\n                last=i\r\n            ans[i]=min(ans[i],last-i)\r\n        return ans\r\n            \r\n\r\n\r\n### 复杂度\r\n时间 O(N)\r\n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086716724","body":"### 思路\r\n一句话总结：只有pop操作时才真正进行增量操作，使得increment操作时间复杂度也是O(1)。\r\n\r\npush操作时，用[x，y]代替x。y用于increment操作，初始值均为0。\r\nincrement操作时，找到最后一个需要更新数值的位置，将该数值对应的y加上val。\r\npop操作时，返回x+y，并更新栈顶元素的y。\r\n### 代码\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack=[]\r\n        self.size=0\r\n        self.maxSize=maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size<self.maxSize:\r\n            self.stack.append([x,0])\r\n            self.size+=1\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack:\r\n            return -1\r\n        self.size-=1\r\n        a,b=self.stack.pop(-1)\r\n        if self.stack:\r\n            self.stack[-1][1]+=b\r\n        return a+b\r\n        \r\n    def increment(self, k: int, val: int) -> None:\r\n        idx=min(k,self.size)-1\r\n        if idx>-1:\r\n            self.stack[idx][1]+=val\r\n\r\n### 复杂度\r\n时间 O(1)\r\n空间 O(maxSize)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bigboom666":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085464204","body":"## 思路\n低位往高位加。\n进位放到k里处理。\n## code\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> resultSta = new ArrayList<>();\n        \n        //进位放到k里处理\n        for(int i=num.length-1; i>=0;i--){\n\n            int sum =  num[i] +k%10;\n            k = k/10;\n\n            if(sum >= 10){\n                k++;\n                sum -= 10;\n            }\n\n\n            resultSta.add(sum);\n        }\n\n        while(k!=0){\n            resultSta.add(k%10);\n            k = k/10;\n        }\n\n        Collections.reverse(resultSta);\n        return resultSta;\n    }\n}\n```\n\n## 复杂度\n时间：o(n+k)\n控件：o(n+k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086558958","body":"## 思路\n同时正向和反向遍历\n## code\n```java\nclass Solution {\n    //同时正向和反向遍历\n    public int[] shortestToChar(String s, char c) {\n        int[] result = new int[s.length()];\n        for(int i=0;i<s.length();i++){\n            int head = i;\n            int tail = i;\n            while(true){\n                if(head>=0 && s.charAt(head) == c) break;\n                if(tail<s.length() && s.charAt(tail) == c) break;\n                head--;\n                tail++;\n            }\n            result[i] = (i-head)<(tail-i)?(i-head):(tail-i);\n        }\n        return result; \n\n    }\n}\n```\n\n## 复杂度\n时间：o(n^2)\n空间：o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086885319","body":"```java\nclass CustomStack {\n    int[] mStack;\n    int top = -1;\n    public CustomStack(int maxSize) {\n        mStack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(top < mStack.length-1){\n            mStack[++top] = x;\n        }\n       \n    }\n    \n    public int pop() {\n        if(top>=0){\n            return mStack[top--];\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        int temp = top<k-1?top:k-1;\n        for(int i=0;i<=temp;i++){\n            mStack[i] +=val;\n        }\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"carrieyqzhang":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085470672","body":"### 思路\r\n从个位数求两数之和，carry= 1 如果sum大于10.\r\nsum % 10 得到的结果就是当位数的值\r\nwhile 结束loop如果num[]里没有元素，而且k 等于0\r\n\r\n### 代码\r\n\r\n```java\r\npublic List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        int carry = 0;\r\n        int l1 = num.length -1;\r\n        while (l1 >= 0 || k != 0){\r\n            int a = l1 < 0 ? 0 : num[l1]; //get last element in num[]\r\n            int b = k <= 0 ? 0 : k % 10; //get last digit in k            \r\n            int sum = a + b + carry;\r\n            res.add(0, sum % 10);\r\n            carry = sum / 10;\r\n            \r\n            l1--;\r\n            k /= 10;\r\n        }\r\n        if (carry != 0) res.add(0,carry);\r\n    \r\n        return res;     \r\n    }\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086667323","body":"### 思路\n左右遍历一遍\n\n### 代码\n```java\npublic int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] out_arr = new int[n];\n        int cPos = -n;\n        \n        for(int i =0; i <n; i++){\n            if(s.charAt(i) == c){\n                cPos = i;\n            }\n            out_arr[i] = i - cPos;\n        }\n        for(int i = n-1; i >=0; i--){\n            if(s.charAt(i) == c){\n                cPos = i;\n                \n            }\n            out_arr[i] = Math.min(out_arr[i], Math.abs(i-cPos));\n        }\n        return out_arr;\n        \n    }\n```\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086790288","body":"### 思路\n用stack实现CustomStack\ninc[] 用来存储increment value,每pop一个值，加上inc[i]的值返回，inc[i-1]=inc[i],以便后面pop时可以加上increment value值\n\n### 代码\n\n```Java\nclass CustomStack {\n    int n;\n    int[] inc;\n    Stack<Integer> stack;\n\n    public CustomStack(int maxSize) {\n        n = maxSize;\n        inc = new int[n];\n        stack =  new Stack<>();\n    }\n    \n    public void push(int x) {\n        if( stack.size() < n){\n            stack.push(x);\n        }\n    }\n    \n    public int pop() {\n        int i = stack.size() - 1;\n        if(i < 0 )return -1;\n        if(i > 0){\n            inc[i-1] += inc[i]; //store the increment value for bottom use\n        }\n        int res = stack.pop() + inc[i];\n        inc[i] = 0; //set current increment to 0 since its poped\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        int i = Math.min(k, stack.size()) - 1;\n        if(i >= 0)\n            inc[i] += val; //inc[i] means increment val for all stack[0]-> stack[i]\n        \n    }\n}\n\n```\n\n时间/空间复杂度： O（N）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"l-sui":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085485310","body":"/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let len = num.length-1;\n    while(len>=0&&k>0){\n        const sum = k+num[len]\n        num[len] = sum%10\n        k=~~(sum/10)\n        len--\n    }\n    if(k>0) return [...k.toString().split(''),...num]\n    return num\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086770679","body":"/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.queue = [];\n    this.maxSize = maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.queue.length<this.maxSize) this.queue.push(x)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.queue.length==0) return -1;\n    return this.queue.pop()\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(let i=0;i<k&&i<this.queue.length;i++)this.queue[i] += val\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xil324":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085491089","body":"思路: 先把数组转换为正数,然后再把两个数相加，最后再把得到的整数转换为数组。 时间复杂度o(n), 空间复杂度O(n) , n取决于num 和结果数组的最大值。 \r\n```\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        number = self.convert_array_to_integer(num);\r\n        print(number)\r\n        sum_two_numbers = number + k\r\n        res = [];\r\n        while sum_two_numbers >= 10:\r\n            res.append(sum_two_numbers % 10);\r\n            sum_two_numbers = sum_two_numbers // 10; \r\n        res.append(sum_two_numbers)\r\n        return res[::-1]; \r\n        \r\n            \r\n    \r\n    def convert_array_to_integer (self, arr):\r\n        result = 0;\r\n        for i in range(len(arr)):\r\n            if arr[i] == '0': \r\n                result - result * 10;\r\n            else:\r\n                result = result * 10 + arr[i]; \r\n            \r\n        return result; \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086540900","body":"```\r\nclass Solution(object):\r\n    #数组的遍历(正向遍历和反向遍历)\r\n    #思路： 遍历两次，每次遍历，更新target到i的距离， 取两次遍历的最小值，也就是查看，左右target哪一个离i更近，更新result（返回数组）\r\n    #result[target] = 0\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        \r\n        result = [float('inf')] * len(s); \r\n        target = -len(s);\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                target = i; \r\n            result[i] = min(result[i], abs(target-i)); \r\n        for i in range(len(s)-1, -1,-1):\r\n            if s[i] == c:\r\n                target = i; \r\n            result[i] = min(result[i], abs(target-i));\r\n        return result;\r\n```\r\n时间复杂度： o(n)\r\n空间复杂度： o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086776798","body":"```\r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.maxSize = maxSize; \r\n        self.stack = []; \r\n        \r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x);\r\n        \r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if len(self.stack) != 0:\r\n            temp = self.stack[-1];\r\n            self.stack.pop(); \r\n            return temp;\r\n        else:\r\n            return -1; \r\n        \r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        i = 0; \r\n        while i < k and i < len(self.stack):\r\n            self.stack[i] += val;\r\n            i+=1; \r\n    \r\n        \r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nineis7":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085491869","body":"/* 求和的方法始终会溢出，故不可采取\r\n        size_t sum = 0, max_size = num.size();\r\n        // get the sum\r\n        for(int i(0); i < max_size; ++i)\r\n            // sum += num[i] * pow(10, max_size-i-1);\r\n            sum  = sum * 10 + num[i];\r\n        sum += k;\r\n        // int count(1), level(0);\r\n        // while(sum % count) {\r\n        //     level++;\r\n        //     count *= 10;\r\n        // }\r\n        // vector<int> tmp_vec[level];\r\n        // int i(0);\r\n        // while(level){\r\n        //     tmp_vec.push_back(sum / power(10, level-1));\r\n            \r\n        //     --level;\r\n        // }\r\n\r\n        // 对于数值的位的操作有：移位操作，不过基于十进制的移位可能需要重新设计；\r\n        // 转化为string类型；\r\n        // 通过for循环取余或除提取\r\n\r\n        string str_sum = to_string(sum);  //将int型转化为string，从而可以单独操作每一位；\r\n        const size_t length = str_sum.size();\r\n        vector<int> tmp_vec;\r\n        for(int i(0); i < length; ++i)\r\n            tmp_vec.push_back(str_sum[i]-48);\r\n\r\n        return tmp_vec;\r\n        */\r\n\r\n        string str_k = to_string(k);\r\n        size_t length_num = num.size();\r\n        size_t length_k = str_k.size();\r\n        int i = length_num-1;\r\n        int j = length_k-1;\r\n        int carry = 0;\r\n        while((i+1) && (j+1)){\r\n            num[i] = num[i] + str_k[j] - 48 + carry;\r\n            carry = 0;\r\n            if(num[i] >= 10){\r\n                carry = 1;\r\n                num[i] %= 10;\r\n            }\r\n            --i;\r\n            --j;\r\n        }\r\n\r\n        if(carry){\r\n            \r\n        }\r\n    }\r\n\r\n只能说 尝试了相加的方法，但是用了size_t后还是溢出，又采取了逐位相加，结果在判断上理解还是不够到位，对情况的分析很卡。最后没忍住看了官方题解，那么这题也就作废了。留此记录。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pfyyh":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085499940","body":"### 思路\r\n\r\n模拟加法\r\n\r\n按照低位求和，大于等于十则进一。\r\n\r\n\r\n\r\n存储结构，使用的是LinkedList。底层是链表结构，往链表头插入元素。低位先进入链表，高位最后。减少一次反转\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        //以num数组为基准\r\n        LinkedList<Integer> deque = new LinkedList<>();\r\n        for (int i = num.length - 1; i >= 0; i--) {\r\n            //计算当前位\r\n            int value = num[i] + k % 10;\r\n            //丢弃最低位\r\n            k /= 10;\r\n            //如果结果大于10，k进1\r\n            if (value >= 10) {\r\n                k += 1;\r\n                value -= 10;\r\n            }\r\n            deque.addFirst(value);\r\n        }\r\n        //如果数组用完了，将K剩下的高位放进去\r\n        for (; k > 0; k /= 10) {\r\n            deque.addFirst(k % 10);\r\n        }\r\n        return deque;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(max(N+M,N))，其中 N 为数组长度,M=K长度-N长度。\r\n- 空间复杂度：O(max(N+M,N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086630219","body":"### 思路\n\n借鉴了滑动窗口算法，找到第一个和第二个出现字符的位置。\n\n比较下标-头的距离和尾巴-下标的距离，填入数组。\n\n当下标到达尾巴的时候，说明已经\n\n当S字符串只有一个符合的c的时候，从符合位置点往两边填充距离。\n\n### 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        //存储结果\n        int[] result = new int[s.length()];\n        //判断滑动窗口\n        int head = s.indexOf(c);\n        int tail = s.indexOf(c, head + 1);\n        //说明没有窗口，直接填充两边值即可\n        if(tail==-1){\n            int absLength = 0;\n            int lP = head;\n            int rP = head;\n            //从唯一的下标开始往两边扩展\n            while(lP>=0||rP<s.length()){\n                if(lP>=0){\n                    result[lP]=absLength;\n                    lP--;\n                }\n                if(rP<s.length()){\n                    result[rP]=absLength;\n                    rP++;\n                }\n                absLength++;\n            }\n            return result;\n\n        }\n        char[] chars = s.toCharArray();\n        \n        for (int i = 0; i < chars.length; i++) {\n            result[i] = Math.min(Math.abs(head - i), Math.abs(tail - i));\n            //遍历到了尾巴，尾巴变头，找下一个尾巴。\n            if (i == tail) {\n                head = tail;\n                //如果尾巴没了，tail = -1 tail-i的绝对值永远大于head-i的绝对值,永远是head-i\n                tail = s.indexOf(c, tail + 1);\n            }\n        }\n        return result;\n    }\n}\n```\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086863323","body":"### 思路\n\n最开始想的是直接使用LinkedList，用着用着越不对劲。\n\n用数组重写，重要的就是当前栈顶所在位置的管理。\n\n### 代码\n\n```java\nclass CustomStack {\n    int[] stack;\n    int iPoint;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        iPoint = -1;\n    }\n    \n    public void push(int x) {\n        //如果到了最后\n        if (iPoint == stack.length-1) {\n            return;\n        }\n        //向右偏移一位\n        iPoint++;\n        //存值\n        stack[iPoint] = x;\n    }\n    \n    public int pop() {\n        //栈底\n        if (iPoint == -1) {\n            return iPoint;\n        }\n        --iPoint;\n        //直接返回即可，后面直接覆盖\n        return stack[iPoint + 1];\n    }\n    \n    public void increment(int k, int val) {\n        //影响数量\n        int num = Math.min(k, iPoint + 1);\n        //修改值\n        for (int i = 0; i < num; ++i) {\n            stack[i] += val;\n        }\n    }\n}\n```\n\n### 时间复杂度\n\npush和pop都是栈顶直接操作，O(1)\n\nincrement遍历的数组O(num),num为临时的空间。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"judyzhou95":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085515819","body":"```python\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        \n        p = len(num) - 1\n        while k:\n            k += num[p]            \n            v = k % 10    \n            num[p] = v\n            \n            k //=10\n            p -= 1\n        \n            if p < 0:\n                break\n        \n        while k:\n            v = k % 10\n            num = [v] + num\n            k //= 10\n        \n        return num\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086570363","body":"```python\nclass Solution:\n    def shortestToChar(self, S, C):\n        def letter_get(letter, dr):\n            n = len(S)\n            res, cur = [0]*n, -n\n            for i in range(n)[::dr]:\n                if S[i] == letter: cur = i\n                res[i] = abs(i - cur)\n            return res\n        \n        return [min(x,y) for x,y in zip(letter_get(C, 1), letter_get(C, -1))]\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086797319","body":"```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.inc = []\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n            self.inc.append(0)\n\n    def pop(self) -> int:\n        if not self.inc:\n            return -1\n        if len(self.inc) > 1:\n            self.inc[-2] += self.inc[-1]\n        \n        return self.stack.pop() + self.inc.pop()\n\n    def increment(self, k: int, val: int) -> None:        \n        if self.inc:\n            self.inc[min(k, len(self.inc)) - 1] += val\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhiyuanpeng":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085517916","body":"```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num[-1] += k\r\n        for i in range(len(num)-1, -1, -1):\r\n            carry, num[i] =divmod(num[i], 10)\r\n            if i:\r\n                num[i-1] += carry \r\n        if carry:\r\n            num = [int(i) for i in str(carry)] + num\r\n        return num\r\n```\r\nspace `O(M+N)` time `O(N)`","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086798751","body":"```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.add = []\r\n        self.size = 0\r\n        self.max_size = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.max_size:\r\n            self.stack.append(x)\r\n            self.add.append(0)\r\n            self.size += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.size > 0:\r\n            v = self.stack.pop()\r\n            i = self.add.pop()\r\n            self.size -= 1\r\n            if self.size > 0:\r\n                self.add[-1] += i\r\n            return v+i\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        n = min(k, len(self.stack))\r\n        if n >= 1:\r\n            self.add[n-1] += val\r\n```\r\ntime `O(1)`, space `O(N)`","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"davont":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085528745","body":"## 代码\n```js\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086470126","body":"## 代码\r\n```js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    const sArr = s.split('');\r\n    const keyArr = [];\r\n    const ans = [];\r\n    for (let i = 0; i < sArr.length; i++) {\r\n        const ele = sArr[i];\r\n        if(ele === c){\r\n            keyArr.push(i);\r\n        }\r\n    }\r\n    for (let i = 0; i < sArr.length; i++) {\r\n        const ele = sArr[i];\r\n        let minLen = sArr.length;\r\n        for (let j = 0; j < keyArr.length; j++) {\r\n            const keyEle = keyArr[j];\r\n            minLen = Math.min(minLen,Math.abs(keyEle - i));\r\n        }\r\n        ans.push(minLen);\r\n    }\r\n    return ans;\r\n\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086839680","body":"## 代码\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n  this.length = maxSize;\n  this.stack = [];\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n  if (this.stack.length < this.length) {\n    this.stack.push(x);\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n  return this.stack.pop() || -1;\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n  for (let i = 0; i < k; i++) {\n    if (!this.stack[i]) {\n      break;\n    }\n    this.stack[i] += val;\n  }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ellie-wu05":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085530541","body":"## 思路\n1. 比较intuitive的想法就是先转换成字符串-> 数字+k ->字符串 \n2.  \n## 代码\n1. \n’‘’\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n                \n        int_str = ''\n\n        for i in num:\n            int_str += str(i)\n        \n        int_str = str(int(int_str) + k)\n\n        res=[int(i) for i in int_str]\n\n        return res\n‘’‘\n## 复杂度分析\n1. Time complexity: On; Space complexity On.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086603805","body":"## 思路\n先建造一个index list 存储target character相应的index\n\n在用index list 里面的值分别减去字符串单个的index，取最小值\n\n## 代码\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n\n        index = [i for i, j in enumerate(s) if j==c]\n\n        result = []\n        for i in range(len(s)):\n            a=[]\n            for ind in index:\n                b = abs(ind - i)\n                a.append(b)\n            min_num = min(a)\n            result.append(min_num)\n\n        return result\n\n```\n\n## 复杂度分析\n时间：最差On^2, 正常O(mn)    m 为index list 长度(最差m=n)  \\\n空间： On, index list 的worst case, On, result index 也是On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086742469","body":"## 思路一：暴力求解\n\n## 代码\n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack= []\n        self.max_size = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.max_size:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,len(self.stack))):\n            stack[i] += val\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n## 复杂度分析\nTIME COMPLEXITY:  push 和 pop 都为O(1)，increment 为O(k),最差为O1 \\\nSPACE COMPLEXITY: O(maxSize)\n\n## 思路二：优化思路一的increment\n这里是参考了答案和评论区\n## 代码\n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack= []\n        self.max_size = maxSize\n        self.inc = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.max_size:\n            self.stack.append(x)\n            self.inc.append(0)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        if len(self.inc)>1:\n            self.inc[-2] +=self.inc[-1]\n           \n        return self.stack.pop() + self.inc.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if self.inc:\n            self.inc[min(k,len(self.inc))-1] += val\n```\n## 复杂度分析\nTIME COMPLEXITY: 都为O1 \\\nSPACE COMPLEXITY:  O(maxSize)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuyingliu2021":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085533007","body":"三种方法\n```\n暴力\n时间复杂度O(n)\n空间复杂度O(n)\n先把k转为字符串 然后转成int 和k相加再慢慢转回来\n```\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        return list(map(int,str(int(''.join(map(str,num))) + k)))\n```\n\n```\n模拟\n时间复杂度O(n)\n空间复杂度O(n)\n模板真好用hh\n```\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        lstk = list(int(i) for i in str(k))\n        i = len(num) -1\n        j = len(lstk) -1\n        carry = 0\n        \n        res = []\n        while i >=0 or j >=0:\n            x = num[i] if i >=0 else 0\n            y = lstk[j] if j >=0 else 0\n            \n            sum = x + y + carry  \n            \n            keep = sum % 10\n            carry = sum // 10\n    \n            res.append(keep)\n               \n            i = i -1\n            j = j -1\n            \n        if carry != 0:\n            res.append(carry)\n        return res[::-1]\n```\n\n```\n把k加进去 这个和模拟差不多 \n看了别人的答案 感觉也不错\n```\n\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        i = len(num) - 1\n        while k:\n            num[i] += k\n            k, num[i] = num[i] // 10, num[i] % 10\n            i -= 1\n\n            if i < 0 and k:\n                num.insert(0,0)\n                i = 0\n        return num\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086542553","body":"两种方法\r\n```\r\n暴力\r\n把s中和c相等的index取出来 之后一个个和s中的index相减 max(abs(差))\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)\r\n```\r\n\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        lst = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                lst.append(i)\r\n        res= []\r\n        for i in range(len(s)):\r\n            dis = [] \r\n            for j in lst:\r\n                dis.append(abs(i-j))\r\n            res.append(min(dis)) \r\n        return res \r\n```\r\n\r\n```\r\n一个指针\r\n当满足两个条件p+=1\r\n1. p还没有走完\r\n2. i 到  p 的绝对距离 > 到p + 1的绝对距离\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)\r\n\r\n```\r\n\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        p = 0\r\n        lst = list(i for i in range(len(s)) if s[i] == c)\r\n\r\n        for i, j in enumerate(s):\r\n            if p < len(lst) -1 and abs(lst[p] -i) > abs((lst[p+1]) -i):\r\n                p+=1\r\n            res.append(abs(lst[p]-i))\r\n            \r\n        return res\r\n        \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086744260","body":"```\r\n时间复杂度：O(1)\r\n空间复杂度：O(maxSize)\r\n```\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        self.length = 0\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.length < self.maxSize:\r\n            self.stack.append(x)\r\n            self.length +=1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.length == 0:\r\n            return -1\r\n        else:\r\n            self.length -= 1\r\n            return self.stack.pop()\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, self.length)):\r\n            self.stack[i] += val\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"futurefields":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085538554","body":"Idea:high precision addition\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n    reverse(num.begin(), num.end());\n        for(auto&t : num){\n            k+= t;\n            t= k % 10;\n            k/= 10;\n        }\n        while(k) num.push_back(k % 10), k/= 10;\n        reverse(num.begin(), num.end());\n        return num;\n    }\n};\nSpace O(n) Time O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086576973","body":"Idea: scan from left to right, and reverse\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> answer(s.size());\r\n        int prev = -100000;\r\n        for (int i = 0; i < s.size(); i++) {\r\n            if (s[i] == c) {\r\n                prev = i;\r\n            }\r\n            answer[i] = i - prev;\r\n        }\r\n        prev = 20000;\r\n        for (int i = s.size() - 1; i >= 0; i--) {\r\n            if (s[i] == c){\r\n                prev = i;\r\n            }\r\n            answer[i] = min(answer[i], prev - i);\r\n        }\r\n        return answer;\r\n    }\r\n};\r\n\r\nspace O(N), time O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wwang4768":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085550862","body":"***Idea***  \nTo convert the int k to string, and then can leverage math functions to add. Finally converting the result back to list. However this is very brute force. \n\n***Code***\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        \n        numInt = int(''.join((str(i) for i in num)))\n       \n        temp = numInt + k\n        result = [int(j) for j in str(temp)]\n        \n        return result\n```\n\n***Complexity***  \nTime: O(n)  \nMemory usage: O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086665384","body":"***Idea***\n1) Loop through the string s and note down and note down the index of occurance of target char c \n2) Loop through s and array of all c occurance index again, create a temp int that stores the distance between current digit and each c occurance. If there is a shorter distance, update temp ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flyzenr":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085553826","body":"- ### 思路\n\t- 将数组转换成字符串，然后转换成整数\n\t- 然后做加法\n\t- 然后再将结果转换成数组\n- ### Code\n\t  ```python\t  \t  \n              class Solution:\n\t  \t      def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\t  \t          str1 = ''.join([str(x) for x in num])\n\t  \t          number = int(str1)\n\t  \t          newNumber = number + k\n\t  \t          newList = list(map(int,str(newNumber)))\n\t  \t          return newList\n\t  ```\n- ### 复杂度\n\t- 时间复杂度 O(n)\n\t- 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086648516","body":"- Name: Leetcode No.821 字符的最短距离\n- ### 题目描述\n  ```\n  对给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n  \n  返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n  \n  两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n  \n  \n  示例 1：\n  输入：s = \"loveleetcode\", c = \"e\"\n  输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n  解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n  距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n  距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n  对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n  距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n  \n  \n  示例 2：\n  输入：s = \"aaab\", c = \"b\"\n  输出：[3,2,1,0]\n  \n  提示：\n  \t1 <= s.length <= 104\n  \ts[i] 和 c 均为小写英文字母\t\n  \t题目数据保证 c 在 s 中至少出现一次\n  ```\n- ### 思路\n\t- 遍历字符串，双指针，同时计算正反两个方向的字符的距离\n\t- 然后将得到的两个数组，对应位置进行比较，选择小的留下来\n- ### 题目考察点分析\n\t- 我觉得这个题，主要考查**字符的遍历**。\n- ### Code\n\t-\n\t  ``` python\n\t  \t  class Solution:\n\t  \t      def shortestToChar(self, s: str, c: str) -> List[int]:\n\t  \t          prev1, prev2 = 2*len(s), 2*len(s)\n\t  \t          ans1,ans2 = [len(s)]*len(s), [len(s)]*len(s)\n\t  \t          j = len(s)-1\n\t  \t          for i in range(len(s)):\n\t  \t              if s[i] == c:\n\t  \t                  prev1 = i\n\t  \t              ans1[i] = abs(i - prev1)\n\t  \t              if s[j] == c:\n\t  \t                  prev2 = j\n\t  \t              ans2[j] = abs(j - prev2)\n\t  \t              j -= 1\n\t  \t          for i in range(len(s)):\n\t  \t              ans1[i] = min(ans1[i],ans2[i])\n\t  \t          return ans1\n\t  ```\n- ### 复杂度\n\t- 时间复杂度 $O(n)$\n\t- 空间复杂度 $O(n)$\n- ### 知识汇总\n\t- #### `min`\n\t\t- min选两个数中小的","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086830285","body":"- ### 题目描述\n- 请你设计一个支持下述操作的栈。\n 实现自定义栈类`CustomStack`  ：\n `CustomStack(int maxSize)`：用 `maxSize` 初始化对象，`maxSize` 是栈中最多能容纳的元素数量，栈在增长到 `maxSize` 之后则不支持 `push` 操作。\n  `void push(int x)`：如果栈还未增长到 `maxSize` ，就将 x 添加到栈顶。\n  `int pop()`：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\n  `void inc(int k, int val)`：栈底的 k 个元素的值都增加 `val` 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 `val` 。\n 请你设计一个支持下述操作的栈。\n    \n  实现自定义栈类 CustomStack ：\n    \n  CustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\n  void push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\n  int pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\n  void inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n    \n    \n  示例 1：\n  输入：\n  [\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n  [[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n  输出：\n  [null,null,null,2,null,null,null,null,null,103,202,201,-1]\n  解释：\n  - CustomStack customStack = new CustomStack(3); // 栈是空的 []\n  - customStack.push(1);                          // 栈变为 [1]\n  - customStack.push(2);                          // 栈变为 [1, 2]\n  - customStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\n  - customStack.push(2);                          // 栈变为 [1, 2]\n  - customStack.push(3);                          // 栈变为 [1, 2, 3]\n  - customStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\n  - customStack.increment(5, 100);                // 栈变为 [101, 102, 103]\n  - customStack.increment(2, 100);                // 栈变为 [201, 202, 103]\n  - customStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\n  - customStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\n  - customStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\n  - customStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\n    \n    \n    \n  提示：\n  1 <= maxSize <= 1000;\n  1 <= x <= 1000;\n  1 <= k <= 1000;\n  0 <= val <= 100;\n  每种方法 increment，push 以及 pop 分别最多调用 1000 次\n- ### 思路\n\t- 设计初始函数，传入所需的变量数组的`maxSize`\n\t- 然后写入入栈，出栈，对栈中元素进行操作的函数\n- ### 题目考察点分析\n\t- 我觉得这个题，主要考查**栈**这种数据结构的相关概念。\n- ### Code\n\t-\n\t  ``` python\n\t  \t  class CustomStack:\n\t  \t  \n\t  \t      def __init__(self, maxSize: int):\n\t  \t          self.maxSize = maxSize\n\t  \t          self.customStack = []\n\t  \t  \n\t  \t      def push(self, x: int) -> None:\n\t  \t          if len(self.customStack) < self.maxSize:\n\t  \t              self.customStack.append(x)\n\t  \t  \n\t  \t      def pop(self) -> int:\n\t  \t          if self.customStack == []:\n\t  \t              return -1\n\t  \t          else:\n\t  \t              return self.customStack.pop(-1)\n\t  \t  \n\t  \t      def increment(self, k: int, val: int) -> None:\n\t  \t          for i in range(min(len(self.customStack), k)):\n\t  \t              self.customStack[i] += val\n\t  \t  \n\t  \t  \n\t  \t  \n\t  \t  # Your CustomStack object will be instantiated and called as such:\n\t  \t  # obj = CustomStack(maxSize)\n\t  \t  # obj.push(x)\n\t  \t  # param_2 = obj.pop()\n\t  \t  # obj.increment(k,val)\n\t  ```\n- ### 复杂度\n\t- 时间复杂度: `push`: O(1); `pop`: O(1); `increment`: $O(min(k, maxSize))$\n\t- 空间复杂度 $O(maxSize)$ 我们产生了一个额外的 $maxSize$ 维的空间\n- ### 知识汇总\n\t- #### `类`\n\t\t- 类是抽象的概念，是一类东西的抽象化表述\n\t\t- 类的具体化实例化就是具体对象\n\t\t- 实例化对象可以调用类中所有函数\n\t\t- 在类中还有一个初始化函数，将一些特殊的属性值（变量），传入类","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mo660":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085579178","body":"* ### 思路\n\n最开始想着将num数组变为数字，再加K，但是数组的长度最大为1w，变量接收不了这么大的数。\n\n最后用数组从后向前遍历，加上k的值，注意进位与整除。\n\n* ### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        for (int i=num.size()-1; i>=0 ;i--){\n            int temp = 0;\n            temp = (num[i] + k)%10;\n            k = (num[i] + k)/10;\n            res.insert(res.begin(), temp);\n        }\n        while (0 != k){\n            res.insert(res.begin(), k%10);\n            k /= 10;\n        }\n        return res;\n    }\n};\n```\n\n* ### 复杂度\n    * 时间复杂度O(max(n,c)) n为num的长度，c为k的位数\n    * 空间复杂度O(max(n,c)) n为num的长度，c为k的位数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086519518","body":"### 思路\n先从左向右遍历，再从右向左遍历取最小值\n\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> answer(s.size());\n        int pre = INT32_MIN/2;\n        for (int i = 0; i < s.size() ; i++){\n            if (s[i] == c) pre = i;\n            answer[i] = i - pre;\n        }\n        pre = INT32_MAX;\n        for (int i = s.size()-1 ; i >= 0 ; i--){\n            if (s[i] == c) pre = i;\n            if (answer[i] > (pre - i))\n                answer[i] = pre - i;\n        }\n        return answer;\n    }\n};\n```\n### 复杂度\n* 时间复杂度 O(n)\n* 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086890399","body":"```c++\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) {\r\n        stack.resize(maxSize);\r\n        top = maxSize;\r\n        now = -1;\r\n    }\r\n\r\n    void push(int x) {\r\n        if (now < top-1){\r\n            ++now;\r\n            stack[now] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (-1 == now) return -1;\r\n        int popNum = stack[now];\r\n        --now;\r\n        return popNum;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        k = min(k, now+1);\r\n        for (int i = 0; i < k; i++){\r\n            stack[i] += val;\r\n        }\r\n    }\r\nprivate:\r\n    vector<int> stack;\r\n    int top;\r\n    int now;\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zywang0":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085584434","body":"## 思路\n将数组转换成整数，然后与整数K做加法，之后再转换成数组返回\n## 代码\nclass Solution:\n    def add_array_with_num(self, num: List[int], k: int) -> List[int]:\n        sum = 0\n        digit = 1\n        for i in range(len(num)-1, -1, -1):\n            sum += num[i]*digit\n            digit *= 10\n        sum += k\n        result = [0]*len(str(sum))\n        for i in range(len(result)-1, -1, -1):\n            result[i] = sum % 10\n            sum //= 10\n        return result\n## 复杂度分析\n空间复杂度：O(N) 时间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086566322","body":"```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        Stack<Integer> stack = new Stack<>();\n        int[] ans = new int[s.length()];\n        int pre = - 1;\n        for (int i = 0 ; i < s.length(); i ++) {\n            if (s.charAt(i) == c) {\n                while (!stack.isEmpty() && s.charAt(stack.peek()) != c) {\n                    int p = stack.pop();\n                    ans[p] = pre >= 0 ? Math.min(Math.abs(p - i) , Math.abs(p - pre)) : Math.abs(p - i);\n                }\n                pre = i;\n            }\n            stack.push(i);\n        }\n        while (!stack.isEmpty()) {\n            int p = stack.pop();\n            ans[p] = s.charAt(p) == c ? 0 : Math.abs(p - pre);\n        }\n        return ans;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bolunzhang2021":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085594873","body":"```\r\nimport java.util.*;\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n      List<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            int sum = num[i] + k % 10;\r\n            k /= 10;\r\n            if (sum >= 10) {\r\n                k++;\r\n                sum =sum% 10;\r\n            }\r\n            res.add(sum);\r\n        }\r\n        for (; k > 0; k /= 10) {\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n空间复杂度：O(N) 时间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wychmod":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085602602","body":"### 思路\n大体上是先将数组遍历一遍，将其转换为数字，然后与k相加，再将数字转换为数组\n### 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        sum = ''.join([str(n) for i, n in enumerate(num)])\n        sum = int(sum) + k\n        return [int(i) for i in str(sum)]\n```\n### 时间复杂度\n空间复杂度：O(n) 在将数字转换为数组的时候创建了数组\n\n时间复杂度：O(n) 遍历了有限次的数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086544108","body":"### 思路\n（比较暴力）先把所有的e找出来下标放入数组中，然后将原数组的每一个点与所有e的下标对比取最小的那个。\n### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        el = []\n        for i, n in enumerate(s):\n            if n == c:\n                el.append(i)\n        res = [0]*len(s)\n        for i in range(len(s)):\n            less = abs(i-el[0])\n            for j in el:\n                less = min(abs(i-j), less)\n            res[i] = less\n        return res\n```\n### 复杂度分析\n时间复杂度：O(n*目标字符在数组中出现的次数)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086888495","body":"### 思路\n数组进行模拟，同时设置两个变量当前长度（不设也行）和最大长度，然后数组天生有pop函数\n### 代码\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.length = 0\n        self.maxSize = maxSize\n        self.stack = []\n\n\n    def push(self, x: int) -> None:\n        if self.length < self.maxSize:\n            self.stack.append(x)\n            self.length += 1\n\n\n    def pop(self) -> int:\n        if self.length > 0:\n            self.length -= 1\n            return self.stack.pop()\n        return -1\n\n\n    def increment(self, k: int, val: int) -> None:\n        k = min(self.length, k)\n        for i in range(k):\n            self.stack[i] += val\n```\n### 复杂度分析\n时间复杂度：push O1 popO1 incOk\n\n空间复杂度On","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"orangejuz":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085608090","body":"\n### 题目：\n\n【Day 1】989. 数组形式的整数加法 \n\n[力扣地址：989](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n### 思路：\n\n用的 python 语言\n\n- 用 c 作为进位记录值，用当前的 num 作为结果数组\n- 当 num 和 k 都没有结束的时候，进行 num[i] + 个位数 + 进位值\n- 当 k 没有结束的时候，进行将 k 剩下的转为 数组进行想加\n- 当 num 没有结束的时候，将当前的 i 和进位值加起来然后前面数组保留\n- 当 进位值 还未归 0 的时候，将 进位值增加到 数组最前面\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        c = 0  #进位\n        i = len(num) - 1 #数组位置\n\n       # 当num没结束 and k 没结束\n        while(k and i > -1):\n            n = num[i] + (k % 10) + c \n            k //= 10\n            c = n // 10\n            num[i] = n % 10\n            i = i - 1\n        \n        # 当 k 没有结束的时候\n        while(k): \n            num = [(k % 10 +c)%10] + num \n            c = (k % 10 +c) // 10   \n            k = k // 10 \n           \n        # 当 数组没有结束的时候\n        while(i > -1):\n            n = c + num[i]\n            c = n // 10\n            num[i] = n % 10\n            i = i - 1  \n        # 当进位没有结束的时候\n        while(c):\n            num = [c] + num \n            c = 0\n\n        return num\n```\n\n\n\n### 时间复杂度：O（N）\n\n### 空间复杂度：O（N）\n\n反思：我可太笨了，思维不够缜密，最终还是写出垃圾冗长的代码，还得再学习一下...","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086665920","body":"### 题目：【Day 2】821. 字符的最短距离\n[821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n### 思路1\n1. 新建列表存放字符 c 存在的位置\n2. 在 result 列表中，存放两次循环找出的最小 diff 距离\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        L = []\n        result = []\n        for i in range(len(s)):\n            if s[i] == c:\n                L.append(i)\n        for i in range(len(s)):\n            diff = 10000\n            for j in L:\n                if (abs(j - i)) < diff:\n                    diff = abs(j - i)\n            result.append(diff)\n        return result\n```\n### 复杂度\n时间复杂度：O(N^2)\n空间复杂度：O(N)\n\n\n### 思路2\n1. 循环找到字符 c 存在的位置\n2. 前后循环找到最短的距离\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        result = [99999 for i in s]\n        n = len(s)\n        for i in range(n):\n            if s[i] != c:\n                continue\n            result[i] = 0\n            for j in range(i-1, -1, -1):\n                if s[j] == c:\n                    result[j] = 0\n                    break\n                result[j] = min(abs(i-j), result[j])\n            if i == n-1:\n                break\n            for j in range(i+1, n):\n                if s[j] == c:\n                    result[j] = 0\n                    break\n                result[j] = min(abs(i-j), result[j])\n        return result\n```\n\n### 复杂度\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086780406","body":"### 题目：【Day 3】1381. 设计一个支持增量操作的栈\n\n[1381.设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n\n### 思路：\n\n用列表模拟栈的操作\n\n### 代码：\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.L = []\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if(len(self.L)<self.maxSize):\n            self.L.append(x)\n\n    def pop(self) -> int:\n        if(len(self.L) > 0):\n            return self.L.pop(-1)\n        else:\n            return -1\n        \n            \n    def increment(self, k: int, val: int) -> None:\n        for i in range(k):\n            if i >= len(self.L):\n                break\n            self.L[i] += val\n```\n\n### 复杂度\n\n时间复杂度：O(N)  主要是在 increment()中用了一次循环\n\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tensorstart":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085612304","body":"### 思路\n类似于第二题，按位倒叙相加，注意进位\n\n### 代码\n```javascript\nvar addToArrayForm = function(num, k) {\n    res=[];\n    l=num.length;\n    for (let i = l-1; i >=0 ; i--) {\n        let pos_num=0;\n        pos_num=num[i]+k%10;\n        k=Math.floor(k/10);\n        if (pos_num>=10){\n            pos_num-=10;\n            k+=1;\n        }\n        res.push(pos_num);\n    }\n    while (k){\n        res.push(k%10);\n        k=Math.floor(k/10);\n    }\n    res.reverse();\n    return res;\n};\n\n```\n**复杂度分析**\n- 时间复杂度：$O(k,n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086664861","body":"### 思路\n用的双指针循环部分有待优化\n### 代码\n\n\n```javascript\n\nvar shortestToChar = function(s, c) {\n    const res=[];\n    let l=0,r=0,pos=0;\n    let length=s.length;\n    for (let i = 0; i < length; i++) {\n        let array_abs=0;\n        l=r=pos=i;\n        for (let j = r; j < length; j++) {\n            if (s[j]===c) {\n                r=j;\n                break;\n            }\n        }\n        for (let j = l; j >=0 ; j--) {\n            if (s[j]===c){\n                l=j;\n                break;\n            }\n        }\n        if (s[l]===c && s[r]===c)\n            array_abs=Math.min(Math.abs(l-pos),Math.abs(r-pos));\n        else if (s[l]===c && s[r]!==c)\n            array_abs=Math.min(Math.abs(l-pos));\n        else\n            array_abs=Math.min(Math.abs(r-pos));\n        res.push(array_abs);\n    }\n    return res;\n};\n```\n\n**复杂度分析**\n- 时间复杂度：$O(N^2)$\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086892427","body":"### 思路\njs刚开始学，还是用的不好，java的思路写的\n### 代码\n\n\n```javascript\n/**\n * @param {number} maxSize\n */\nlet stack;//创建栈\nlet pos;//创建指针\nvar CustomStack = function(maxSize) {\n    stack=new Array(maxSize);\n    pos=-1;\n};\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (pos!==stack.length-1){\n        pos++;\n        stack[pos]=x;\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (pos !== -1) {\n        let pos_value = stack[pos];\n        stack[pos] = undefined;\n        pos--;\n        return pos_value;\n    } else return -1;\n}\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    if (k>pos+1){\n        for (let i = 0; i <=pos; i++) {\n            stack[i]+=val;\n        }\n    }else {\n        for (let i = 0; i < k; i++) {\n            stack[i]+=val;\n        }\n    }\n};\n\n\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"physicshi":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085682784","body":"## 思路\n按位求和，用flag保存进位，加到下一轮\n## 代码\n```js\nvar addToArrayForm = function (num, k) {\n  const res = [];\n  let order = num.length - 1;\n  // 进位\n  let flag = 0;\n  while (order >= 0 || k != 0) {\n    let x = order >= 0 ? num[order] : 0;\n    let y = k != 0 ? k % 10 : 0;\n    let sum = x + y + flag;\n    // 保存余数\n    res.push(sum % 10);\n    flag = Math.floor(sum / 10);\n    k = Math.floor(k / 10);\n    order--;\n  }\n  if (flag) res.push(flag);\n  return res.reverse();\n};\n```\n## 复杂度\n+ 时间复杂度：O(n)\n+ 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086665965","body":"## 思路\r\n中心扩展\r\n## 代码\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n    const res=Array(s.length).fill(0);\r\n    for(let i=0;i<s.length;i++){\r\n        if(s[i]===c) continue\r\n        let l=i,r=i,shortest=Infinity;\r\n        while (l>=0){\r\n            if(s[l]===c){\r\n                shortest=Math.min(shortest,i-l)\r\n                break\r\n            }\r\n            l--\r\n        }\r\n        while(r<s.length){\r\n            if(s[r]===c){\r\n                shortest=Math.min(shortest,r-i);\r\n                break\r\n            }\r\n            r++\r\n        }\r\n        res[i]=shortest;\r\n    }\r\n    return res\r\n};\r\n```\r\n## 复杂度\r\n- 时间复杂度：O(n^2)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086823118","body":"## 思路\r\n\r\n直接按着题意即可。\r\n\r\n## 代码\r\n\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n  this.stack = [];\r\n  this.maxSize = maxSize;\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.stack.length === this.maxSize) {\r\n    return null;\r\n  }\r\n  this.stack.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n  var x = this.stack.pop();\r\n  return x === undefined ? -1 : x;\r\n};\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n  for (let i = 0; i < k && i < this.stack.length; i++) {\r\n    this.stack[i] = this.stack[i] + val;\r\n  }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度：push 操作和 pop 操作的渐进时间复杂度为 O(1)，inc 操作的渐进时间复杂度为 O(k)\r\n- 空间复杂度：O(maxSize)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"m908":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085689040","body":"### 思路\n从后往前遍历数组，按位与K相加\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> result;\n        for(int i = num.size() - 1; i >= 0; i--)\n        {\n            int curNumber = num[i] + k % 10;\n            k /= 10;\n            if(curNumber >= 10)\n            {\n                curNumber -= 10;\n                k += 1;\n            }\n            result.push_back(curNumber);\n        }\n        \n        for (; k > 0; k /= 10) {\n            result.push_back(k % 10);\n        }\n        reverse(result.begin(), result.end());\n        return result;\n    }\n};\n```\n### 复杂度\n- 时间复杂度：O(max(n,logk))\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086597840","body":"### 思路\r\n\r\n先保存目标字符出现的所有位置，逐个与字符串比对距离\r\n\r\n### 代码\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> result(s.size());\r\n        vector<int> targetChars;\r\n\r\n        for(int i = 0; i < s.size(); i++)\r\n        {\r\n            if(s[i] == c)\r\n                targetChars.push_back(i);\r\n        }\r\n\r\n        for(int i=0; i < result.size(); i++)\r\n        {\r\n            int minDistance = INT_MAX;\r\n            for(int j=0; j < targetChars.size(); j++)\r\n            {\r\n                if(minDistance > abs(i - targetChars[j]))\r\n                    minDistance = abs(i - targetChars[j]);\r\n            }\r\n            result[i] = minDistance;\r\n        }\r\n        return result;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度\r\n\r\n- 时间复杂度：O(m * n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086887598","body":"```c++\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        mMaxSize=maxSize;\n    }\n    \n    void push(int x) {\n        if(mNumbers.size()<mMaxSize)\n        {\n            mNumbers.push_back(x);\n        }\n    }\n    \n    int pop() {\n        if(!mNumbers.empty())\n        {\n        int result=mNumbers.back();\n        mNumbers.pop_back();\n        return result;\n        }\n        else\n        {\n            return -1;\n        }\n    }\n    \n    void increment(int k, int val) {\n        if(mNumbers.size()<k)\n        {\n            for(int i=0;i<mNumbers.size();i++)\n            {\n                mNumbers[i]+=val;\n            }\n        }\n        else\n        {\n            for(int i=0;i<k;i++)\n            {\n                mNumbers[i]+=val;\n            }\n        }\n    }\n    \nprivate:\n    vector<int> mNumbers;\n    int mMaxSize;     \n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"astrking":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085691561","body":"思路\n\n    二者从低位相加，满10进位即可\n\n代码\n\n    class Solution {\n        public List<Integer> addToArrayForm(int[] num, int k) {\n            List<Integer> res = new ArrayList<Integer>();\n            int n = num.length;\n            for (int i = n - 1; i >= 0; --i) {\n                int sum = num[i] + k % 10;\n                k /= 10;\n                if (sum >= 10) {\n                    k++;\n                    sum -= 10;\n                }\n                res.add(sum);\n            }\n            for (; k > 0; k /= 10) {\n                res.add(k % 10);\n            }\n            Collections.reverse(res);\n            return res;\n        }\n    }\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086620620","body":"思路\n\n    左右两次遍历，找出最小值即可\n\n代码\n\n    class Solution {\n        public int[] shortestToChar(String S, char C) {\n            int N = S.length();\n            int[] ans = new int[N];\n            int prev = Integer.MIN_VALUE / 2;\n    \n            for (int i = 0; i < N; ++i) {\n                if (S.charAt(i) == C) prev = i;\n                ans[i] = i - prev;\n            }\n    \n            prev = Integer.MAX_VALUE / 2;\n            for (int i = N-1; i >= 0; --i) {\n                if (S.charAt(i) == C) prev = i;\n                ans[i] = Math.min(ans[i], prev - i);\n            }\n    \n            return ans;\n        }\n    }\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqy97":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085696335","body":"\n## 题目地址(989. 数组形式的整数加法)\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n## 思路\n\n- 从后向前逐位相加\n\n## 关键点\n\n-  不能直接把num转成数字相加，数字过大时会越界被截取\n-  考虑进位\n-  考虑k的长度大于num\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let add = k\n    for (let i=num.length-1;i>=0;i--) {\n        if(!add) {\n          break;\n        }\n        let sum = num[i] + add%10\n        add = Math.floor(add/10)\n        if (sum >= 10) {\n            add++\n            num[i] = sum%10\n        } else {\n          num[i] = sum\n        }\n    }\n    while(add > 0) {\n        num.unshift(add%10)\n        add = Math.floor(add/10)\n    }\n    return num\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"timmmyang":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085699745","body":"## 思路\r\n从低位相加，`num`结束后继续判断`k`即可。\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        carry = 0\r\n        for digit in num[::-1]:\r\n            if k > 0:\r\n                add = k % 10\r\n                k = k // 10\r\n                digit = digit + add + carry\r\n                carry = digit // 10\r\n                res.append(digit%10)\r\n            else:\r\n                digit += carry\r\n                carry = digit // 10\r\n                res.append(digit%10)\r\n        if k > 0:\r\n            while k > 0:\r\n                add = k % 10\r\n                k = k // 10\r\n                digit = add + carry\r\n                carry = digit // 10\r\n                res.append(digit%10)\r\n        if carry == 1:\r\n            res.append(1)\r\n        return res[::-1]\r\n```\r\n## 复杂度\r\n时间：O(n)，n为数组长度\r\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086534623","body":"### 思路\r\n\r\n正反两次遍历，分别记录当前字符是`c`的index，初始值使用`inf`。第二次遍历时比较存入最小值。\r\n\r\n### 代码\r\n\r\n```Python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        idx = -float('inf')\r\n        res = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                idx = i\r\n            res.append(i - idx)\r\n        idx = float('inf')\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                idx = i\r\n            res[i] = min(res[i], idx - i)\r\n        return res \r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度：O(n)，n为`s`长度\r\n\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086850004","body":"## 方法一\r\n\r\n### 思路\r\n\r\n直观做法，定义`self.stack`来作为这个栈。每次增加时index为0～min(k, len(self.stack))的元素增加`val`.\r\n\r\n### 代码\r\n\r\n```Python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) == self.maxSize:\r\n            return\r\n        self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack:\r\n            return -1\r\n        else: \r\n            return self.stack.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        n = min(k, len(self.stack))\r\n        for i in range(n):\r\n            self.stack[i] += val\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度：初始，push, pop 为O(1)；increment为O(k)\r\n\r\n空间复杂度：O(maxSize)\r\n\r\n## 方法二\r\n\r\n### 思路\r\n\r\n为了减小方法一中的increment的时间复杂度，设计一个增量数组，只记录增加值的边界，在pop时一并加上作为返回值，之后将增量向栈底进行传递。\r\n\r\n### 代码\r\n\r\n```Python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = [0] * maxSize\r\n        self.add = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stack) - 1:\r\n            self.top += 1\r\n            self.stack[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        res = self.stack[self.top] + self.add[self.top]\r\n        self.stack[self.top] = 0\r\n        if self.top > 0:\r\n            self.add[self.top-1] += self.add[self.top]\r\n        self.add[self.top] = 0\r\n        self.top -= 1 \r\n        return res\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        tmp = min(k-1, self.top)\r\n        if tmp > -1:\r\n            self.add[tmp] += val\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度：全部操作都为O(1)\r\n\r\n空间复杂度：O(maxSize)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linjunhe":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085702964","body":"## 思路\r\n转换为字符串后再进行处理\r\n![image](https://user-images.githubusercontent.com/30134501/161241442-d66bc6e2-aaee-41a4-ba25-072de0f524be.png)\r\n\r\n## 代码（python）\r\n\r\n```python\r\nclass Solution:\r\n  def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n      return list(map(int, list(str(int(''.join(list(map(str, num))))+k))))\r\n```\r\n**复杂度分析**\r\n- 时间复杂度： O(n) , n 为数组长度。\r\n- 空间复杂度： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086539562","body":"## 思路\r\n暴力解法，遍历找到index；将`answer`里的值设置很大，循环`range(0, len(s))`+循环`index`，作差求绝对值，跟`answer[i]`比较大小\r\n\r\n## 代码 （python3）\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        index = [i for i,si in enumerate(s) if si==c]\r\n        answer = [len(s)]*len(s)\r\n        for i in range(0, len(s)):\r\n            for j in index:\r\n                if abs(i-j)<answer[i]:\r\n                    answer[i] = abs(i-j) \r\n        return answer\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度： O(n^2)， n为`s`长度, 套了两个循环\r\n- 空间复杂度： O(n)，n为`answer`数组长度\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086792048","body":"- ## 思路\r\n\t- 正常list操作，push对应append()，pop对应pop()\r\n- ### 代码（python3）\r\n``` python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) > 0:\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if len(self.stack) > 0: \r\n            for i in range(min(k, len(self.stack))):\r\n                self.stack[i] += val\r\n```\r\n- ### 复杂度分析\r\n  - 时间复杂度：O(n), n是`stack`长度\r\n  - 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yinhaoti":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085717791","body":"```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        \"\"\"\n        Idea:\n            case1: len(num) > len(str(k)):\n                add two digital -> get result & carry\n                left move 1 digital of k\n            case2: len(num) < len(str(k)):\n                k += carry\n                while: add k to new array / convert k to array\n        Topic: Array enumerate\n        TC: O(N + max(0, (K-N)^2)\n        SC: O(max(1,K-N))\n        \"\"\"\n        carry = 0\n        for i in range(len(num) - 1, -1, -1):\n            add_result = carry + num[i] + k % 10\n            num[i] = add_result % 10\n            carry = add_result // 10\n            k = k // 10\n        \n        re = []\n        k = k + carry\n        while k:\n            re.insert(0, k % 10)\n            k = k // 10\n        \n        return re + num\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086549709","body":"```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        \"\"\"\n        Brute-force\n        TC: O(n^2)\n        SC: O(n)\n        \"\"\"\n        re = [-1] * len(s)\n\n                \n        for i in range(len(s)):\n            shortest = float('inf')\n            count = 0\n            for j in range(i, -1, -1):\n                if s[j] != c:\n                    count += 1\n                if s[j] == c:\n                    shortest = min(shortest, count)\n            \n            count = 0\n            for k in range(i, len(s)):\n                if s[k] != c:\n                    count += 1\n                if s[k] == c:\n                    shortest = min(shortest, count)\n            re[i] = shortest\n        \n        return re\n    \n    \n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        \"\"\"\n        Topic: Array enumerate\n        Idea: enumerate 3times\n            [-1] * n\n            1st: put 0\n            2nd: left->right, 0+1\n            3rd: right->left, 0+1\n        \n        TC: O(n)\n        SC: O(n)\n        \"\"\"\n        l = len(s)\n        re = [-1] * l\n        \n        for i in range(l):\n            if s[i] == c:\n                re[i] = 0\n        \n        cur_d = -1\n        for i in range(l):\n            print(re[i], cur_d)\n\n\n            if re[i] == 0:\n                cur_d = 0\n            re[i] = cur_d\n            if cur_d != -1:\n                cur_d += 1\n\n        # reversed enumerate\n        cur_d = float('inf')\n        for i in range(l-1, -1, -1):\n            if re[i] == 0:\n                cur_d = 0\n                \n            if cur_d < re[i] or re[i] == -1:\n                re[i] = cur_d\n            if cur_d != -1:\n                cur_d += 1\n\n\n        return re\n\n                \n                \n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086868202","body":"```python\nclass CustomStack:\n    \"\"\"\n    Topic: Stack\n    Idea: \n        init: []-> stack, n->size\n        push: append\n        pop: pop()\n        increment: for -> increase\n    TC:\n        push: O(1)\n        pop: O(1)\n        increment: O(min(k, len(self.stack)))\n    SC: O(1)\n    \n    Improve: prefix-sum -> make increment O(1)\n    \"\"\"\n    \n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.max_size = maxSize\n        \n        \n    def push(self, x: int) -> None:\n        if len(self.stack) == self.max_size:\n            return\n        self.stack.append(x)\n\n\n    def pop(self) -> int:\n        if len(self.stack) == 0: return -1\n        return self.stack.pop()\n\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(k):\n            if i == len(self.stack):\n                break\n            self.stack[i] += val\n\n            \nclass CustomStack:\n    \"\"\"\n    Topic: Stack\n    Improve: prefix-sum -> make increment O(1)\n    Idea: \n        prefix-sum to record\n    TC:\n        push: O(1)\n        pop: O(1)\n        increment: O(1)\n    SC: O(n)\n    Improve: SC -> O(size of stack)\n    \"\"\"\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.max_size = maxSize\n        self.incrementals = [0] * maxSize\n     \n           \n    def push(self, x: int) -> None:\n        if len(self.stack) == self.max_size:\n            return\n        self.stack.append(x)\n    \n    def pop(self) -> int:\n        if len(self.stack) == 0: return -1\n        n = len(self.stack)\n        if n >= 2:\n            self.incrementals[n-2] += self.incrementals[n - 1]\n        re = self.stack.pop()\n        re += self.incrementals[n - 1]\n        self.incrementals[n - 1] = 0\n        return re\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack) > 0:\n            self.incrementals[min(k, len(self.stack)) - 1] += val\n        \n\nclass CustomStack:\n    \"\"\"\n    Topic: Stack\n    SC -> O(size of stack)\n    Idea: \n        prefix-sum to record\n    TC:\n        push: O(1)\n        pop: O(1)\n        increment: O(1)\n    SC: O(size of stack)\n    \"\"\"\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.max_size = maxSize\n        self.incrementals = []\n     \n           \n    def push(self, x: int) -> None:\n        if len(self.stack) == self.max_size:\n            return\n        self.stack.append(x)\n        self.incrementals.append(0)\n    \n    def pop(self) -> int:\n        if len(self.stack) == 0: return -1\n        n = len(self.stack)\n        if n >= 2:\n            self.incrementals[n-2] += self.incrementals[n - 1]\n        re = self.stack.pop() + self.incrementals.pop()\n        return re\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack) > 0:\n            self.incrementals[min(k, len(self.stack)) - 1] += val\n        \n        \n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miss1":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085768414","body":"## 思路\n新建一个数组，长度为num和k的长度的最大值，从num和k的末尾开始相加，得到的值赋值到新数组中，注意进位。\n\n## 代码\n```javascript\nvar addToArrayForm = function(num, k) {\n  let size = Math.max(num.length, (k + '').length);\n  let res = new Array(size);\n  let j = num.length - 1;\n  for (let i = res.length - 1; i >= 0; i--) {\n    let sum = k % 10;\n    if (j >= 0) sum += num[j];\n    if (res[i]) sum += res[i];\n    if (i === 0) {\n      res[i] = sum;\n    } else {\n      res[i] = sum % 10;\n      res[i - 1] = Math.floor(sum / 10);\n    }\n    k = Math.floor(k / 10);\n    j--;\n  }\n  if (res[0] >= 10) {\n    let s = res[0];\n    res[0] = s % 10;\n    res.unshift(Math.floor(s /10));\n  }\n  return res;\n};\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086627537","body":"## 思路\n两遍循环，先从左到右遍历s, 找到值左边第一个c的距离。再从右到左遍历，找到值右边第一个c的距离。取两个值中的最小值。\n\n## 代码\n```javascript\nvar shortestToChar = function(s, c) {\n  let res = [];\n  let cIndex = -Infinity;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === c) cIndex = i;\n    res[i] = i - cIndex;\n  }\n  let rcIndex = Infinity;\n  for (let i = s.length - 1; i >= 0; i--) {\n    if (s[i] === c) rcIndex = i;\n    res[i] = Math.min(res[i], rcIndex - i);\n  }\n  return res;\n};\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086786982","body":"## 代码\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.arr = [];\n  this.maxSize = maxSize;\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.arr.length < this.maxSize) this.arr.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  if (this.arr.length === 0) return -1;\n  else return this.arr.pop();\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  for (let i = 0; i < k; i++) {\n    if (i >= this.arr.length) break;\n    this.arr[i] += val;\n  }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sallyrubyjade":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085802765","body":"### 思路\n从数组最后一位开始遍历，并取出k的个位数进行相加，再对k进行除10处理来保证每次取出的都是最末位，然后对判断相加数是否大于10，是的话要进一位（记得把这个进位带进下一次数组循环里），把相加数的个位数放在要返回数组的开头。最后判断k或者进位是否处理干净，因为可能k的位数比num数组长度大，进行循环，直到k为0。\n\n### 代码\n```javascript\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let ans = [];\n    let carry = 0;\n    for (let i = num.length - 1; i >= 0; i--) {\n        let temp = num[i] + (k % 10) + carry;\n        k = Math.floor(k / 10);\n        if (temp >= 10) {\n            temp = temp % 10;\n            carry = 1;\n        }else {\n            carry = 0;\n        }\n        ans.unshift(temp);\n    }\n\n    while (carry != 0 || k > 0){\n        let temp = carry + (k % 10);\n        k = Math.floor(k / 10);\n        if (temp >= 10) {\n            temp = temp % 10;\n            carry = 1;\n        }else {\n            carry = 0;\n        }\n        ans.unshift(temp);\n    }\n\n    return ans;\n};\n```\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086623359","body":"### 思路\n遍历字符串，对每一个字符元素，使用左右指针思想，分别向左和向右寻找最近的字符c，使用Math.min()进行对比，找到最短距离，把值放进数组中，再对下一个字符元素进行相同操作，直到遍历结束。\n\n### 代码\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let ans = [];\n    for(let i = 0; i < s.length; i++) {\n        if(s[i] === c) {\n            ans.push(0);\n            continue;\n        }\n\n        let left = i;\n        let right = i;\n        let shortest = Number.MAX_VALUE;\n\n        while(left >= 0) {\n            if(s[left] === c) {\n                shortest = Math.min(shortest, i - left);\n                break;\n            }\n            left--;\n        }\n\n        while(right <= s.length - 1) {\n            if (s[right] === c) {\n                shortest = Math.min(shortest, right - i);\n                break;\n            }\n            right++;\n        }\n        ans.push(shortest);\n    }\n    return ans;\n};\n```\n### 复杂度分析\n- 时间复杂度：O(n^2)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086792767","body":"### 思路\n用数组模拟栈，push和pop直接用数组的原生方法，但要对数组的长度进行判断，increment方法要比较数组长度大小与k值大小，选择偏小值对这个范围内的数组元素加上增量。\n\n### 代码\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.list = [];\n    this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.list.length < this.maxSize) this.list.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.list.length > 0) {\n        return this.list.pop();\n    }else {\n        return -1;\n    }\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    if(this.list.length <= k) {\n        for(let i = 0; i < this.list.length; i++) {\n            this.list[i] += val;\n        }\n    }else {\n        for(let i = 0; i < k; i++) {\n            this.list[i] += val;\n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n### 复杂度分析\n- 时间复杂度：初始化对象CustomStack O(1)，push操作 O(1)，pop操作 O(1)，increment操作 O(n)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"meemx":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085804058","body":"### 思路\r\n从最低位（num数组最后一位开始），逐位相加\r\n\r\n### 代码\r\n```python3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        length = len(num)\r\n        result = []\r\n\r\n        for i in range(length - 1, -1, -1):\r\n            sum = num[i] + k % 10\r\n            k = k // 10\r\n            if sum >= 10:\r\n                k = k + sum // 10\r\n                sum = sum % 10\r\n            result.append(sum)\r\n\r\n        # 若A长度小于整数K\r\n        while k > 0:\r\n            sum = k % 10\r\n            k = k // 10\r\n            result.append(sum)\r\n\r\n        # 逆序输出\r\n        return result[::-1]\r\n```\r\n\r\n### 复杂度分析\r\n- 时间：O(n)\r\n- 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086569073","body":"### 思路\r\n\r\n- 第一遍：从左向右遍历\r\n- 第二遍：从右向左遍历，同时取最小值\r\n\r\n### 代码\r\n\r\n```pthon3\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        prev = float('-inf')\r\n        ans = []\r\n        # 第一遍 从左向右遍历\r\n        for i, x in enumerate(s):\r\n            if x == c:\r\n                prev = i\r\n            ans.append(i - prev)\r\n\r\n        # 第二遍 从右向左遍历 同时取最小值\r\n        prev = float('inf')\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n\r\n        return ans\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086883737","body":"### 思路\r\n\r\n使用数组进行模拟，操作即较为简单与高效\r\n\r\n### 代码\r\n\r\n```python3\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        self.top -= 1\r\n        return self.stk[self.top + 1]\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, self.top + 1)\r\n        for i in range(lim):\r\n            self.stk[i] += val\r\n```\r\n\r\n### 时间复杂度\r\n\r\n- 时间复杂度：push是O(1)、pop是O(1)、increment是O(N)\r\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moonlee001":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085808810","body":"## 思路\n将k转化为数组，利用双指针倒序相加。\n## 代码\nvar addToArrayForm = function(num, k) {\n    const arrK = k.toString().split('');\n    const n = num.length;\n    const m = arrK.length;\n    let p1 = n - 1, p2 = m - 1;\n    let res = [];\n    let carry = 0;\n    while (p1 >= 0 || p2 >= 0) {\n        const num1 = p1 < 0 ? 0 : num[p1];\n        const num2 = p2 < 0 ? 0 : arrK[p2] - 0;\n        const sum = num1 + num2 + carry;\n        const mode = sum % 10;\n        carry = Math.floor(sum / 10);\n        res.unshift(mode);\n        p1--;\n        p2--;\n    }\n    if (carry) {\n        res.unshift(carry);\n    }\n    return res;\n};\n\n## 复杂度\n时间：O(n)\n空间： O(m) m为数字个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086597227","body":"### 思路\n两次遍历字符串，取最小值。\n\n### 代码\n\n\n```js\nvar shortestToChar = function(S, C) {\n  let n = S.length;\n  let prev = -Infinity;\n  let ans = [];\n  for (let i = 0; i < n; i++) {\n    if (S.charAt(i) == C) {\n      prev = i;\n    }\n    ans[i] = i - prev;\n  }\n  \n  prev = Infinity;\n  for(let i = n - 1; i >= 0; i--) {\n    if (S.charAt(i) == C) {\n      prev = i;\n    }\n    ans[i] = Math.min(prev - i, ans[i]);\n  }\n  \n  return ans;\n\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086797204","body":"### 思路\n使用数组模拟栈，inc使用空间换取时间，存储增量，如果需要pop的时候再将增量加到对应的值\n\n### 代码\n\n```javascript\nvar CustomStack = function(maxSize) {\n  this.maxSize = maxSize;\n  this.stack = stack;\n  this.map = new Map();\n}\nCustomStack.prototype.push = function(x) {\n  if (this.stack.length < this.maxSize) {\n    this.stack.push(x);\n  }\n}\n\nCustomStack.prototype.pop = function() {\n  if (this.stack.length === 0) {\n    return -1;\n  } \n  const inc = this.map.get(this.stack.length) || 0;\n  this.map.set(this.stack.length - 1, (this.map.get(this.stack.length - 2) || 0) + inc);\n  this.map.set(this.stack.length, 0);\n  return this.stack.pop() + inc;\n}\n\nCustomStack.prototype.increment = function(k, val) {\n  const index = Math.min(k, this.stack.length) - 1;\n  if (index < 0) {\n    return;\n  }\n  this.map.set(index, (this.map.get(index) || 0) + val);\n}\n```\n\n### 复杂度分析\n\n* 时间复杂度：O(1)\n* 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gzgzgzgzgzgz":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085811348","body":"# 思路\r\n先将数组转换成数字 再将结果转换为数组\r\n# 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        sum = 0\r\n        digit = 1\r\n        for i in num[::-1]:\r\n            sum += i * digit\r\n            digit *= 10\r\n        sum += k\r\n        res = []\r\n        while sum:\r\n            res.append(sum % 10)\r\n            sum = sum // 10\r\n        return res[::-1]\r\n        \r\n```\r\n# 复杂度\r\n时间：O(n)\r\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086538280","body":"# 思路\r\n先正序遍历 再倒着遍历一遍 \r\n# 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        idx = -float(\"inf\")\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                idx = i \r\n            # i - 负无穷 = 正无穷\r\n            res.append(i - idx)\r\n        idx = float(\"inf\")\r\n        for i in range(len(s) - 1, -1 , -1):\r\n            if s[i] == c:\r\n                idx = i \r\n            res[i] = min(idx - i, res[i])\r\n        return res\r\n```\r\n# 时间复杂度\r\n时间：0(n)\r\n空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"momomoi":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085818993","body":"**思路** \r\n把num列表数据合并为数字和k相加然后再拆分还原\r\n\r\n**时间复杂度** \r\n单循环O(N)\r\n\r\n**代码实现**\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n       cmt_num = ''.join((str(i) for i in num))\r\n       add_sum = int(cmt_num) + k\r\n       split_sum = [int(l) for l in str(add_sum)]\r\n       return split_sum\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086651671","body":"# 思路\r\n### 第一次遍历进行位置确认，第二次遍历进行选最小值\r\n\r\n# 复杂度\r\n### 时间复杂度O(N)\r\n### 空间复杂度O(N)\r\n# 代码\r\n```\r\nclass demo:\r\n    def test(self, S:str, C:str) -> List[int]:\r\n         sums = -1\r\n         zero_sums = [0]*len(S)\r\n         for i in range(len(S)):\r\n            if S[i] == C:\r\n                 sums = 0\r\n            else:\r\n                sums += 1\r\n            zero_sums[i] = sums\r\n         sums = -1\r\n         for j in range(len(S)-1, -1, -1):\r\n            if S[j] == C:\r\n                 sums = 0\r\n            else:\r\n                sums +=1\r\n            zero_sums[j] = min(sums, zero_sums[j])\r\n         return sums\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086874668","body":"###看了题解和评论，因为在外面没法写就直接复用一下了\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, size: int):\r\n        self.st = []\r\n        self.cnt = 0\r\n        self.size = size\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cnt < self.size:\r\n            self.st.append(x)\r\n            self.cnt += 1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.cnt == 0: return -1\r\n        self.cnt -= 1\r\n        return self.st.pop()\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(0, min(self.cnt, k)):\r\n            self.st[i] += val\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuajingliu":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085860307","body":"#### 解题思路\n  1. 低位到高位逐位将数字加在一起\n  2. 若加法的结果大于等于 1010，把进位的 11 加入到下一位的计算中\n#### 代码实现\n\n```\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```\n#### 复杂度分析\n- 时间复杂度: O(max(n,logk), 其中 nn 为数组的长度\n- 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086639221","body":"#### 解题思路\n- 从当前下标出发，分别向左、右两个方向去寻找目标字符 C。\n- 如果只在一个方向找到，直接计算字符距离。\n- 如果两个方向都找到，取两个距离的最小值\n\n#### 代码实现\n\n```\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  const res = Array(S.length).fill(0);\n\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) continue;\n    // 定义两个指针 l, r 分别向左、右两个方向寻找目标字符 C，取最短距离\n    let l = i,\n      r = i,\n      shortest = Infinity;\n\n    while (l >= 0) {\n      if (S[l] === C) {\n        shortest = Math.min(shortest, i - l);\n        break;\n      }\n      l--;\n    }\n\n    while (r < S.length) {\n      if (S[r] === C) {\n        shortest = Math.min(shortest, r - i);\n        break;\n      }\n      r++;\n    }\n\n    res[i] = shortest;\n  }\n  return res;\n};\n```\n#### 复杂度分析\n- 时间复杂度：$O(N^2)$，N 为 S 的长度，两层循环。\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086876043","body":"### 思路\n  用数组模拟栈，用数组原生方法pop、push方法实现\n  \n### 代码\n\n```\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.maxSize = maxSize;\n  this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.stack.length >= this.maxSize) {\n    return;\n  }\n  this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  return this.stack.length ? this.stack.pop() : -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  const length = Math.min(k, this.stack.length);\n  for (let i = 0; i < length; i++) {\n    this.stack[i] += val;\n  }\n};\n```\n### 复杂度\n- 时间复杂度 \n\n  push: O(1)\n\n  pop：O(1)\n  \n  increment：O(K) \n \n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"quieter2018":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085861308","body":"**思路**\r\n从num的个位开始与k逐个相加，与10相除，余数为当前位的数值，商为下次循环的k，求完后再倒序即可。\r\n\r\n**代码实现**\r\n```C++\r\nclass Solution {\r\n  public:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> out;\r\n        int sum = 0;\r\n        for(int i = num.size()-1; i >= 0 || k > 0; i--) {\r\n            if(i >= 0){\r\n                sum = k + num[i];\r\n                out.push_back(sum % 10);\r\n                k = sum /10;\r\n            }else{\r\n                out.push_back(k % 10);\r\n                k = k /10;\r\n            }\r\n        }\r\n        reverse(out.begin(),out.end());\r\n        return out;\r\n    }\r\n};\r\n```\r\n**复杂度分析**\r\n时间复杂度：O(max(n,k))  n：num的数据长度；k：k的数据长度\r\n空间复杂度：同上","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhulin1110":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085873537","body":"## 题目\n数组形式的整数加法\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n## 思路\n首先想到的是将数组转换成数，再和K相加，但会发生内存溢出的情况。\n- **改进** \n从个位数开始考虑，依次与 k 相加，（和 % 10） 存入输出数组 ，（和 / 10）取出进位位（更新后的k包含进位）。最后考虑 k 超出数组长度的部分，依次加到输出数组里即可。\n## 代码(JavaScript)\n```JavaScript\nvar addToArrayForm = function(num, k) {\n    var res = [];\n    for (let i = num.length - 1; i >= 0; i--) {\n        res.push((num[i] + k) % 10);  //个位数存入数组\n        k = Math.floor((num[i] + k) / 10);  //更新k, 进位位包含在k中\n    }\n    // 对超出数组长度的 k 进行处理\n    while (k > 0) {\n        res.push(k % 10);\n        k = Math.floor(k / 10);\n    }\n    return res.reverse();\n};\n```\n## 复杂度\n- 时间复杂度\n> O(n) ，for循环遍历数组长度n，后面的可以忽略不计\n- 空间复杂度\n> O(n) ， 创建一个新的数组res存放结果，后面有循环但是没有分配新的内存空间\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086646686","body":"## 题目\n\n字符的最短距离 https://leetcode-cn.com/problems/shortest-distance-to-a-character/\n\n## 思路1（菜鸡的我自己写的，吐了）\n\n找到 s 中所有与 c 相同的字符，并将其索引存放到一个数组中。将数组中的元素索引依次与相同字符的索引做差，并比较得出最小值。值得注意的是，当 s 中与 c 相同的字符只有一个时，无需比较，直接做差即可。\n\n## 代码1（JavaScript）\n\n```javascript\nvar shortestToChar = function(s, c) {\n    var curr = [];\n    var res = [];\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] == c) {\n            curr.push(i);\n        }\n    }\n    if (curr.length == 1) {\n        for (let i = 0; i < s.length; i++) {\n            res[i] = Math.abs(i - curr[0]);\n        }\n        return res;\n    }\n    for (let i = 0; i < s.length; i++) {\n        let j = 0;\n        let data = Math.abs(curr[j] - i);\n        while (curr && (j < curr.length - 1)) {\n            data = Math.min(data, (Math.abs(curr[j + 1] - i)));\n            j++;\n            res[i] = data;\n        }\n    }\n    return res;\n};\n```\n\n \t\t### 代码1改进（看了题解，稍稍改进）\n\n```javascript\nvar shortestToChar = function(s, c) {\n    var curr = [];\n    var res = [];\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] == c) {\n            curr.push(i);\n        }\n    }\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] == c) {\n            res[i] = 0;\n            continue;\n        }\n        for (const j of curr) {\n            const dist = Math.abs(j - i);\n            if (dist >= res[i]) break; // 小小剪枝，跟上次存的比较，j是不断增大的，目的就是为了找最小值，设置阈值\n            res[i] = dist;\n        }  \n    }\n    return res;\n};\n```\n\n\n\n## 复杂度1\n\n- 时间复杂度\n\n  > O(n * n) 前面for循环是n，后面for循环嵌套while，while内最大是n，时间复杂度就是n*n，前面的n可以忽略不记\n\n- 空间复杂度\n\n  > O(n) res 和 curr \n\n## 思路2 （看了题解-贪心算法）\n\n两遍循环，先从左到右遍历s，找到左边第一个c的距离。再从右到左遍历，找到值右边第一个c的距离。最后，取两个值中的最小值。\n\n## 代码2 （评论区大佬的）\n\n```javascript\nvar shortestToChar = function(s, c) {\n  let res = [];\n  let lcIndex = -Infinity;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === c) lcIndex = i;\n    res[i] = i - lcIndex;\n  }\n  let rcIndex = Infinity;\n  for (let i = s.length - 1; i >= 0; i--) {\n    if (s[i] === c) rcIndex = i;\n    res[i] = Math.min(res[i], rcIndex - i);\n  }\n  return res;\n};\n```\n\n## 复杂度2\n\n- 时间复杂度 O(n)\n- 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086837506","body":"## 题目\n\n设计一个支持增量操作的栈 https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n\n## 思路1\n\n根据题目要求的直觉栈操作\n\n## 代码1（JavaScript）\n\n```javascript\nvar CustomStack = function(maxSize) {\n    this.max = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n   if (this.stack.length < this.max) {\n        this.stack.push(x); \n   }\n\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    let res = this.stack.pop();\n    if (res == null) {\n        return -1;\n    } else {\n        return res;\n    }\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for (let i = 0; i < this.stack.length; i++) {\n        if (i < k) {\n            this.stack[i] += val;\n        }\n    }\n   \n};\n```\n\n## 复杂度1\n\n- 时间复杂度\n\n  > O(n ) \n\n- 空间复杂度\n\n  > O(1)  未定义新的数组存放结果\n\n## 思路2 （题解学习）\n\n前缀和（没看懂，待补充）。。。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lizimu0709":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085873737","body":"- 思路\r\n当前位 = (A 的当前位 + B 的当前位 + 进位) % 10\r\nAB两数都加完后判断进位 , 进位不为 0 加在前面。\r\n\r\n- 代码\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] res, int K) {\r\n        List<Integer> Arr = new ArrayList<>();\r\n        int n = res.length;\r\n        int i = n-1;\r\n        int carry = 0;\r\n        int sum = 0;\r\n        while(i >= 0 || K != 0){\r\n            int x = i >= 0 ? res[i] : 0;\r\n            int y = K >= 0 ? K%10 : 0;\r\n            sum = x + y +carry;\r\n            carry = sum / 10;\r\n            K = K / 10;\r\n             --i;\r\n             Arr.add(0,sum%10);\r\n        }\r\n        if(carry != 0)\r\n            Arr.add(0,carry);\r\n        return Arr;\r\n    }\r\n}\r\n```\r\n\r\n- 复杂度\r\n时间：O(n)\r\n空间：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnhu23":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085898822","body":"## Idea\r\nIterate through the number array backwards. Add each element to k, remove the last digit from k and add it to the list.\r\n\r\n## Code\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new ArrayList<>();\r\n        for (int i = num.length-1; i >= 0; i--) {\r\n            k += num[i];\r\n            list.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        while (k > 0) {\r\n            list.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        Collections.reverse(list);\r\n        return list;\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086368202","body":"## Idea\r\nIterate through the string for 3 times. Locate all occurrences of c in the first iteration. Update distance based on distance on the left side in the second iteration and update distance based on distance on the right side in the third iteration.\r\n\r\n## Code\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        char[] str = s.toCharArray();\r\n        int[] ans = new int[str.length];\r\n        Arrays.fill(ans, Integer.MAX_VALUE);\r\n        for (int i = 0; i < str.length; i++) {\r\n            if (str[i] == c) {\r\n                ans[i] = 0;\r\n            }\r\n        }\r\n        \r\n        for (int i = 0; i < str.length - 1; i++) {\r\n            if (ans[i] != Integer.MAX_VALUE) {\r\n                ans[i+1] = Math.min(ans[i] + 1, ans[i+1]);\r\n            }\r\n        }\r\n        \r\n        for (int i = str.length-1; i > 0; i--) {\r\n            if (ans[i] != Integer.MAX_VALUE) {\r\n                ans[i-1] = Math.min(ans[i] + 1, ans[i-1]);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086866023","body":"## Idea\r\nStore the element in an array and use an int variable to represent the actual size.\r\n\r\n## Code\r\n```\r\nclass CustomStack {\r\n    int[] arr;\r\n    int cur = 0;\r\n    \r\n    public CustomStack(int maxSize) {\r\n        arr = new int[maxSize];        \r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (cur < arr.length) {\r\n            arr[cur++] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (cur == 0) {\r\n            return -1;\r\n        }\r\n        return arr[--cur];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for (int i = 0; i < Math.min(k, cur); i++) {\r\n            arr[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\nTime: push: O(1); pop: O(1); increment: O(min(k, cur))\r\nSpace: O(maxSize)\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiayuhui231":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085901627","body":"## 题目\n数组形式的整数加法\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/submissions/\n## 思路\n   - 由于直接循环将数组取出来相加长度可能会超出，所以按倒序取出数组，依次相加取余放进数组\n   - 可能会出现加完后k值为个位数的情况，所以多加个判断，将剩余数也加入数组\n## C++代码\n``` class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        reverse(num.begin(), num.end());\n        int t = k, idx=0;\n        vector<int> ans;\n        while(t)\n        {\n            if(idx<num.size()) t+=num[idx++];\n            ans.push_back(t%10);\n            t /= 10;\n        }\n        while(idx<num.size()) ans.push_back(num[idx++]);\n        reverse(ans.begin(), ans.end());\n        return ans;\n\n    }\n};\n```\n## 复杂度\n     时间：O(n）\n     空间：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086558705","body":"## 题目\n字符的最短距离\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\n## 思路\n- 前后各遍历一次，找最短距离\n## 代码\n``` class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n            vector<int> pos(s.size(),-1);\n        int pre = -1;\n        for(int i = s.size() -1;i >= 0;i--)\n            if(s[i] == c){\n                pre = i;\n                pos[i] = 0;\n            }else if(pre != -1) pos[i] = pre - i;\n        pre = -1;\n        for(int i = 0;i < s.size();i++){\n            if(s[i] == c){\n                pre = i;\n        }else if(pos[i] == -1 && pre != -1){\n            pos[i] = i - pre;\n        }else if(pos[i] != -1 && pre != -1){\n            pos[i] = min( i - pre, pos[i]);\n        }\n        }\n        return pos;\n    }\n};\n```\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086872513","body":"# 代码\nclass CustomStack {\npublic:\n    vector<int> stk;\n    int top;\n\n    CustomStack(int maxSize) {\n        stk.resize(maxSize);\n        top = -1;\n    }\n    \n    void push(int x) {\n        if (top != stk.size() - 1) {\n            ++top;\n            stk[top] = x;\n        }\n    }\n    \n    int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        --top;\n        return stk[top + 1];\n    }\n    \n    void increment(int k, int val) {\n        int lim = min(k, top + 1);\n        for (int i = 0; i < lim; ++i) {\n            stk[i] += val;\n        }\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taojin1992":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085906678","body":"# Plan:\r\n```\r\niterate from end of num, last digit of k, insert to the head of the linkedlist, update carry, curSum\r\n\r\nedge cases: k is longer, num is longer, carry == 1 in the end\r\n```\r\n\r\n# Code:\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> sum = new LinkedList<>();\r\n        int numIndex = num.length - 1;\r\n        int curSum = 0, carry = 0;\r\n        \r\n        while (numIndex >= 0) {\r\n            curSum = num[numIndex] + k % 10 + carry;\r\n            carry = curSum / 10;\r\n            curSum %= 10;\r\n            sum.addFirst(curSum);\r\n            k /= 10;\r\n            numIndex--;\r\n        }\r\n        \r\n        while (k > 0) {\r\n            curSum = k % 10 + carry;\r\n            carry = curSum / 10;\r\n            curSum %= 10;\r\n            sum.addFirst(curSum);\r\n            k /= 10;\r\n        }\r\n        \r\n        if (carry == 1) sum.addFirst(carry);\r\n        return sum;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity:\r\n```\r\nTime: O(max(num.length, log_10_k))\r\nSpace: O(max(num.length, log_10_k)) for the linkedlist\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086537211","body":"# Plan & Complexity: \n\n```\nIt is guaranteed that c occurs at least once in s.\n1 <= s.length <= 10^4\n\ns = \"loveleetcode\", c = \"e\"\n\nl o v e l e e t c o d e\nm m m 0 1 0 0 1 2 3 4 0\n3 2 1 0 1 0 0 1 2 2 1 0\n\nidea: two traversals, left-> right, right -> left\n\nTime: O(s.length())\nSpace: O(s.length()) for the distances array\n```\n\n# Code:\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] distances = new int[s.length()];\n        int toCompare = Integer.MAX_VALUE;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                distances[i] = 0;\n                toCompare = i;\n            } else {\n                distances[i] = Math.abs(toCompare - i);\n            }\n        }\n        \n        \n        for (int i = s.length() - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                distances[i] = 0;\n                toCompare = i;\n            } else {\n                distances[i] = Math.min(distances[i], Math.abs(toCompare - i));\n            }\n        }\n        \n        return distances;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086897041","body":"```java\n/*\nBruteforce:\nsimulate with an array\n\n\nOptimization:\nprefix sum\n\nwhen pop, adjust the inc for the previous cell\n\ninc list and stack list\n\nTime: O(1) \nSpace: O(1) per element\n\n*/\n\nclass CustomStack {\n\tint capacity;\n\tint size;\n\tList<Integer> stack = new ArrayList<>();\n\tList<Integer> inc = new ArrayList<>();\n\n\tpublic CustomStack(int maxSize) {\n\t\tcapacity = maxSize;\n\t\tsize = 0;\n\t}\n\n\tpublic void push(int x) {\n\t\tif (size < capacity) {\n\t\t\tstack.add(x);\n\t\t\tinc.add(0);\n\t\t\tsize++;\n\t\t}\n\t}\n\n\tpublic int pop() {\n\t\tif (size == 0) return -1; // empty check\n\t\tint ans = stack.get(size - 1) + inc.get(size - 1);\n\t\tif (size >= 2) {\n\t\t\tinc.set(size - 2, inc.get(size - 2) + inc.get(size - 1));\n\t\t}\n\t\tinc.remove(size - 1);\n\t\tstack.remove(size - 1);\n\t\tsize--;\n\t\treturn ans;\n\t}\n\n    // index - > inc at that index\n\tpublic void increment(int k, int val) {\n\t\tif (size > 0) { \n\t\t\tinc.set(Math.min(k, size) - 1, inc.get(Math.min(k, size) - 1) + val);\n\t\t}\n\t}\n\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bin214":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085914856","body":"####思路\n\n按位取出数字k，依次加到数组A内，需注意产生的进位，如果数组首位仍有进位，则数组首部加一位\n\n\n\n#### 代码\n\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> ans = new ArrayList<>();\n    int n = num.length;\n    int sum = 0, flag = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        sum = (k % 10) + num[i] + flag;\n        k = k / 10;\n        if (sum >= 10) {\n            sum = sum % 10;\n            flag = 1;\n        } else {\n            flag = 0;\n        }\n        ans.add(sum);\n    }\n    while (k != 0){\n        ans.add(k % 10 + flag);\n        k = k / 10;\n        if(flag != 0) flag = 0;\n    }\n    if(flag != 0)\n        ans.add(1);\n    Collections.reverse(ans);\n    return ans;\n}\n```\n\n\n\n#### 复杂度分析\n\n时间复杂度：O(m + n)\n\n空间复杂度：O(n)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"oision-hub":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085926377","body":"### 思路\n逐位相加，若大于10则进位。\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> result;\n        int len = num.size();\n        for (int i = len - 1; i >= 0; i--) {\n            int temp = num[i] + k % 10;\n            k = k / 10;\n            if (temp >= 10) {\n                k += 1;\n                temp = temp % 10;\n            }\n            result.push_back(temp);\n        }\n        while (k != 0) {\n            result.push_back(k % 10);\n            k = k / 10;\n        }\n        reverse(result.begin(), result.end());\n        return result;\n    }\n};\n```\n### 复杂度\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086650727","body":"### 思路\n将两边遍历的结果存入数组，留下较小的值\n### 解答\n``` c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> ans(s.size(), 0);\n        int left = INT_MAX;\n        int right = INT_MAX;\n        for(int i = 0; i < s.size(); i ++) {\n            if (s[i] == c) {\n                left = i;\n            }\n            ans[i] = i - left;\n        }\n        for(int i = s.size() - 1; i >= 0; i --) {\n            if (s[i] == c) {\n                right = i;\n            }\n            ans[i] = min(abs(ans[i]), right - i);\n        }\n        return ans;\n    }\n};\n```\n###  复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guangsizhongbin":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085927113","body":"func addToArrayForm(num []int, k int) []int {\n    for i := len(num) - 1; i >= 0; i-- {\n        num[i] += k % 10\n        k /= 10\n\n        // if overflow\n        if num[i] > 9 {\n            k++\n            num[i] -= 10\n        }\n    }\n\n    // if k length more than num length\n    for k > 0 {\n        num = append([]int{k % 10}, num...)\n        k /= 10\n    }\n\n    return num\n\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086666125","body":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestShortestDistanceToACharacter(t *testing.T) {\n\ts := \"loveleetcode\"\n\tvar c byte = 'e'\n\n\tchars := shortestDistanceToACharacter(s, c)\n\n\tfor _, v := range chars {\n\t\tfmt.Print(v, \"\\t\")\n\t}\n\tfmt.Println()\n\n}\n\nfunc shortestDistanceToACharacter(s string, c byte) []int {\n\tres := make([]int, len(s))\n\n\t// prevent overflow\n\tleft, right := math.MinInt32/2, math.MaxInt32/2\n\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == c {\n\t\t\tleft = i\n\t\t}\n\t\tres[i] = i - left\n\t}\n\n\tfor i := len(s) - 1; i >= 0; i-- {\n\t\tif s[i] == c {\n\t\t\tright = i\n\t\t}\n\t\tres[i] = min(res[i], right-i)\n\t}\n\n\treturn res\n}\n\nfunc min(a, b int) int {\n\tif a > b {\n\t\treturn b\n\t} else {\n\t\treturn a\n\t}\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086868863","body":"```go\r\ntype CustomStack struct {\r\n    stack []int\r\n    size int\r\n}\r\n\r\n\r\nfunc Constructor(maxSize int) CustomStack {\r\n    return CustomStack {\r\n        make ([]int, 0),\r\n        maxSize,\r\n    }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Push(x int)  {\r\n    if len(this.stack) < this.size {\r\n        this.stack = append(this.stack, x)\r\n    }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Pop() int {\r\n   if len(this.stack) > 0  {\r\n       res := this.stack[len(this.stack) - 1]\r\n       this.stack = this.stack[:len(this.stack) - 1]\r\n       return  res\r\n   } else {\r\n      return -1 \r\n   }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Increment(k int, val int)  {\r\n    if k > len(this.stack) {\r\n        k = len(this.stack)\r\n    } \r\n\r\n    for i := 0; i < k; i++ {\r\n        this.stack[i] += val\r\n    }\r\n}\r\n```\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * obj := Constructor(maxSize);\r\n * obj.Push(x);\r\n * param_2 := obj.Pop();\r\n * obj.Increment(k,val);\r\n */","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhishinaigai":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085936068","body":"### 思路\r\n浅抄一手答案\r\n\r\n### 代码\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector <int> ans;\r\n        int len=num.size();\r\n        \r\n        for(int i=len-1;i>=0;i--){\r\n            int s=num[i]+k%10;\r\n            k/=10;\r\n            if(s>=10){\r\n                k++;\r\n                s-=10;\r\n            }\r\n            ans.push_back(s);\r\n        }\r\n        while(k>0){\r\n            ans.push_back(k%10);\r\n            k/=10;\r\n        }\r\n        reverse(ans.begin(),ans.end());\r\n        return ans;\r\n    }\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086652806","body":"### 思路\r\n今天也是抄答案的一天呢\r\n### 代码\r\n```\r\nvector<int> shortestToChar(string s, char c) {\r\n        vector<int> ans(s.size(),-1);\r\n        int len=s.size();\r\n        int p=-1;\r\n        for(int i=0;i<len;i++){\r\n            if(s[i]==c){\r\n                p=i;\r\n                ans[i]=0;\r\n            } \r\n            else if(p!=-1) ans[i]=i-p;\r\n        }\r\n        p=-1;\r\n        for(int i=len-1;i>=0;--i){\r\n            if(s[i]==c) p=i;\r\n            if(p!=-1) ans[i]=min(ans[i],p-i);\r\n            if(ans[i]==-1) ans[i]=p-i;\r\n             \r\n        }\r\n        return ans;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086847912","body":"### 思路\r\n使用vector实现\r\n### 代码\r\n```c\r\nclass CustomStack {\r\npublic:\r\n    vector <int> stk;\r\n    int top;\r\n    CustomStack(int maxSize) {\r\n        stk.resize(maxSize);\r\n        top=-1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(top!=stk.size()-1){\r\n            ++top;\r\n            stk[top]=x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if(top==-1) return -1;\r\n        --top;\r\n        return stk[top+1];\r\n\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int lim=min(k,top+1);\r\n        for(int i=0;i<lim;++i){\r\n            stk[i]+=val;\r\n        }\r\n    }\r\n};\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jasonhe-wq":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085938194","body":"思路：将列表中的数转化为整数，与k相加，再转化为可迭代对象，加入数组输出\n代码：\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        s=''.join(str(i) for i in num)\n        n = str(eval(s)+k)\n        l = []\n        for i in n:\n            l.append(eval(i))\n        return l\n        \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086649828","body":"思路：\n对于每一个等于c的字符，在其两侧分别计算距离，而对于每个字符，距离取最小值\n优化方向：\n将等于c的字符分为首个，中间，末尾，分别控制不同的区域\n代码：\n'''\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        l = len(s)\n        ans = [l for i in range(l)]\n        for i in range(l):\n            if s[i] == c:\n                for j in range(l):\n                    ans[j]=min(ans[j],abs(i-j))\n        return ans\n'''","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086877618","body":"思路：\n构建数组作为栈，再用一个额外的变量存储maxsize，对于每个要相加的值，先判断长度是否小于k，再遍历\n```\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.num = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack)<self.num:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        else:\n            return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack) <= k:\n            for i in range(len(self.stack)):\n                self.stack[i] += val\n        else:\n            for i in range(k):\n                self.stack[i] += val\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flaming-cl":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085938263","body":"## 989. Add to Array-Form of Integer\n### 1. 思路\n- 基础思考点：transform a number to an int array\n```C\n// 代码实现\nvar array = [];\nvar k = 123;\nwhile (k >= 1) {\n  array.push(Math.floor(k % 10));\n  k /= 10;\n}\n// array: [1, 2, 3]\n```\n拓展上述代码，思路变为：\n> k 或 num 还有剩余位数时，resultArray 不断添加剩余数位\n### 2. 细节处理\n- 相加的结果会进位（这里我用了 num 来存储进位数据）\n  - 如果 num 数组还有数字，给数组的最后一位+1\n  - 如果 num 数组没有数字了，将数组的最后一位赋为 1\n- num 代表的数字，其位数和 k 的位数不一致\n  - 判断一下，确保 getK 和 getN 不会越位\n\n### 3. 复杂度\n- 时间：O(n)  \n  - while 的长度为 max(k的位数，num的位数);  \n  - while 内部涉及的数组操作:     \narray.pop(), array.push(), array[i] =，三者的时间复杂度为 O(1)\n- 空间：O(n)\n  - 新开了一个数组，O(n)\n\n```javascript\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nconst addToArrayForm = (num, k) => {\n  let temp = 0;\n  const resultArray = [];\n  while (k >= 1 || num.length) {\n    temp = getK(Math.floor(k % 10)) + getN(num);\n    resultArray.push(handleTemp(temp, num));\n\n    temp = 0;\n    k /= 10;\n  }\n  return resultArray.reverse();\n};\n\nconst getK = (kNum) => kNum >= 1 ? kNum : 0;\nconst getN = (num) => num.length ? num.pop() : 0;\nconst handleTemp = (temp, num) => {\n  if (temp >= 10) {\n    temp -= 10;\n    if (num.length) {\n      num[num.length - 1] += 1;\n    } else {\n      num[0] = 1;\n    }\n  }\n  return temp;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086504869","body":"821. Shortest Distance to a Character\n### 1. 思路\n- 基础思路\n  - 求数组中两个元素 i, j 的距离: i - j\n- 拓展\n  - 求 i 到左右两边 j、h 的最短距离  \n### 2. 细节\n  - j 的位置未知：\n    - 开一个线性数据结构，记录 j 的位置\n  - 离 i 最近的元素不一定是 j，i 可能还有左相邻、且距离更近的元素 h：\n    - 求最短距离时，比较 Math.min(Math.abs(i - j), Math.abs(i - h))\n  - i - j、i - h，索引不应越界  \n### 3. 复杂度\n- 时间：O(n)\n  - 遍历 s，且遍历内部无 O(n) 及以上层级的操作\n- 空间：O(n)\n  - 新开了 resultArr 数组\n\n```javascript\nvar shortestToChar = function(s, c) {\n  const cHash = new Array(s.length).fill(0);\n  let cHashStart = 0;\n  const resultArr = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === c) {\n      cHash[cHashStart] = i;\n      cHashStart++;\n      resultArr[i] = 0;\n    }\n  }\n  cHashStart = 0;\n  cHashPrev = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (i !== cHash[cHashStart]) {\n      cHashPrev = cHashStart > 0 ? cHashStart - 1 : 0;\n      const shortestGap = Math.min(\n        Math.abs(cHash[cHashPrev] - i),\n        Math.abs(cHash[cHashStart] - i)\n      );\n      resultArr[i] = shortestGap;\n    } else {\n      cHashStart++;\n    }\n  }\n  return resultArr;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086889454","body":"```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.maxSize = maxSize;\n  this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.stack.length < this.maxSize) {\n    this.stack.push(x);\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  return this.stack.pop() || -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  for (let i = 0; i < k; i++) {\n    if (this.stack[i]) { this.stack[i] += val; }\n  }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n### Complexity\n- time\n  - inc: O(n), pop/push: O(1)\n- space\n  - O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"divingcub":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085938282","body":"## Idea\r\nBackward iteration, 考虑位进.\r\n\r\n## Code \r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> sum = new ArrayList<Integer>();\r\n        int length = num.length;\r\n        num[length - 1] += k;\r\n        for (int i = length - 1; i > 0; i--) {\r\n            int curNum = num[i];\r\n            if (curNum > 9) {\r\n                num[i - 1] += curNum / 10;\r\n                num[i] %= 10;\r\n            }\r\n            sum.add(num[i]);\r\n        }\r\n        do {\r\n            sum.add(num[0] % 10);\r\n            num[0] /= 10;\r\n        } while (num[0] > 0);\r\n        Collections.reverse(sum);\r\n        return sum;\r\n    }\r\n}\r\n\r\n## Complexity\r\nTime:O(n)\r\nSpace: O(1)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yaru-zhang":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085944030","body":"# 思路\r\n- 由于直接循环将数组取出来相加长度可能会超出，所以按倒序取出数组，依次相加取余放进数组\r\n- 可能会出现加完后k值为个位数的情况，所以多加个判断，将剩余数也加入数组\r\n# 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        n = len(A)\r\n        ans = []\r\n\r\n        for i in range(n-1, -1, -1):\r\n            total = A[i] + K % 10\r\n\r\n            K //= 10\r\n            \r\n            if total >= 10:\r\n                #当前位相加结果大于 10 时，进位 1 加入下一位计算\r\n                K += 1\r\n\r\n            ans.append(total % 10)\r\n            \r\n        # 这里考虑数组 A 的长度小于整数 K 位数个数的情况\r\n        while K > 0:\r\n            ans.append(K % 10)\r\n            K //= 10\r\n        # 因为添加进来是由低位往高位，输出时进行逆序输出\r\n        return ans[::-1]\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086878823","body":"# 思路\r\n使用数组模拟栈，用一个变量 top 来记录当前栈顶的位置。\r\n# 代码\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        self.top -= 1\r\n        return self.stk[self.top + 1]\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, self.top + 1)\r\n        for i in range(lim):\r\n            self.stk[i] += val\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cshowww":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085951022","body":"## 代码\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int n = num.length;\n        for(int i=n-1;i>=0;i--){\n            int sum = k%10 + num[i];\n            k = k/10;\n            if(sum >= 10){\n                sum = sum-10;\n                k++;\n            }\n            res.add(0,sum);\n        }\n\n        while(k > 0){\n            res.add(0,k%10);\n            k = k/10;\n        }\n        return res;\n    }\n}\n```\n\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086661223","body":"## 代码\n```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int prev = Integer.MIN_VALUE/2;\n        int n = s.length();\n        int ans[] = new int[n];\n\n        for(int i=0;i<n;i++){\n            if(s.charAt(i) == c){\n                prev = i;\n            }\n            ans[i] = i-prev;\n        }\n        prev = Integer.MAX_VALUE/2;\n        for(int i=n-1;i>=0;i--){\n            if(s.charAt(i) == c){\n                prev = i;\n            }\n            ans[i] = Math.min(ans[i],prev-i);\n        }\n        return ans;\n    }\n}\n```\n\n## 复杂度\n时间：O(n)  \n空间：O(n)\n\n## 思路\n双指针，两次遍历，一次从头到尾，一次从尾到头。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086896699","body":"## 代码\nclass CustomStack {\n    int[] stack;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if(top<stack.length-1){\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if(top==-1){\n            return -1;\n        }else{\n            return stack[top--];\n        }\n    }\n    \n    public void increment(int k, int val) {\n        for(int i=0;i<k;i++){\n            if(i<=top){\n                stack[i] += val;\n            }else{\n                break;\n            }\n        }\n    }\n}\n\n\n## 复杂度\n时间： O(1)  \n空间： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086899934","body":"## 思路\n使用栈，遇到‘]’弹出元素，对字母和数字分别转成string和int，然后再运算结果压栈。\n\n## 代码\n```\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n        for(char c : s.toCharArray()){\n            if(c != ']'){\n                stack.push(c);\n            }\n            else{\n                StringBuilder sb = new StringBuilder();\n                while(!stack.isEmpty() && stack.peek()!='['){\n                    sb.insert(0,stack.pop());\n                }\n                String sub = sb.toString();\n\n                stack.pop();\n\n                sb = new StringBuilder();\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\n                    sb.insert(0,stack.pop());\n                }\n                int count = Integer.parseInt(sb.toString());\n\n                while(count > 0){\n                    for(char ch : sub.toCharArray()){\n                        stack.push(ch);\n                    }\n                    count--;\n                }\n            }\n        }\n\n        StringBuilder res = new StringBuilder();\n        while(!stack.isEmpty()){\n            res.insert(0,stack.pop());\n        }\n        return res.toString();\n    }\n}\n```\n\n## 复杂度\n空间：O(n)  \n时间：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kesucaso":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085955510","body":"#思路\n\nnum数组中的每个数字与k中的对应位置的数字相加，然后如果对应位置相加大于10，则进位到高位的位置上去。\n\n#代码\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        ans = []\n        for i in range(len(num)-1,-1,-1):\n            n = num[i]+k%10\n            k=k//10\n            if n>=10:\n                ans.append(n%10)\n                k+=1\n            else:\n                ans.append(n)\n        while k>=1:\n            ans.append(k%10)\n            k=k//10\n        return ans[::-1]\n```\n\n#复杂度分析\n\n时间复杂度：O(n) （遍历数组）\n\n空间复杂度：O(n) （返回的数组大小）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086661051","body":"# 思路\n\n从后往前遍历，遇到等于C的字符就把pre指针置为当前的索引，然后对答案数组进行修改。再从前往后遍历，也是遇到等于C的字符就把pre指针置为当前的索引，对答案数组修改的时候需要对比刚刚已经修改的值和当前赋的值的中选最小值。\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = [0]*len(s)\n        pre = float(\"inf\")\n        for i in range(len(s)-1,-1,-1):\n            if s[i]==c:\n                pre = i\n            ans[i]=pre-i\n        pre = float(\"-inf\")\n        for i in range(len(s)):\n            if s[i]==c:\n                pre = i\n            ans[i]=min(abs(pre-i),ans[i])\n        return ans\n```\n\n# 复杂度分析\n\n时间：O(n)\n\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086886054","body":"# 思路\n\n因为栈的大小固定，所以可以根据索引方便定位每个元素。简单模拟就行。\n\n# 代码\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack)<self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        else:\n            x = self.stack.pop()\n            return x\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(k):\n            if i>=len(self.stack):\n                break\n            else:\n                self.stack[i]+=val\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"testeducative":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085957096","body":"```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int tmp = 0;\n        for(int i = num.size() - 1; i >= 0; i--){\n            tmp = num[i] + k % 10;\n            k /= 10;\n            if(tmp >= 10){\n                tmp = tmp % 10;\n                k++;\n            }\n            res.push_back(tmp);\n        }\n\n        for( ; k > 0; k/=10){\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hzhengzhi":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085962315","body":"##思路\r\nnum从后向前进行运行，每次都用k和对应位置上数字进行相加，若相加结果大于10，则携带进位前往下一位。\r\n如果num结束后，k中仍然剩余部分数字，直接进行求余即可。\r\n```\r\n public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ans= new ArrayList<>();\r\n        for(int i=num.length-1;i>=0;i--)\r\n        {\r\n            ans.add(0,(num[i]+k)%10);\r\n            k=(k+num[i])/10;\r\n        }\r\n        while(k!=0)\r\n        {\r\n            ans.add(0,k%10);\r\n            k=k/10;\r\n        }\r\n        return ans;\r\n    }\r\n```\r\n##复杂度\r\n时间复杂度O(n)\r\n空间复杂度O(n)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rzhao010":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085969554","body":"**Thoughts**\nAdding up by digits.\nIn the array, we start from the last element.\nFor the integer k, each time we use the last digit (k % 10),\nif the sum is bigger than 9, add 1 to k(so we don't need another var to record it).\nAfter the loop, deal with the case k > 0 (maybe k is too big or we have addup).\n\n**Code**\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0; i--) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum > 9) {\n               k += 1;\n               sum -= 10;\n            }\n            res.add(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n**Time Complexity**\nTime: O(N), one for loop\nSpace: O(1), use one arraylist as result","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086529915","body":"**Thoughts**\n1. Get all indices of c, go through s to compare i with indices of c\n2. Traverse s from left side and right side, record the last index of c , so `i - prev` and `prev - i` is the distance for each traverse, at last compare and select the smaller one\n\n**Code**\n```jave\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        ArrayList<Integer> list = new ArrayList<>();\n        int[] res = new int[n];\n        int p = 0; \n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == c) {\n                list.add(i);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (p < list.size() - 1 && Math.abs(list.get(p) - i) > Math.abs(list.get(p + 1) - i)) {\n                p++;\n            }\n            res[i] = Math.abs(list.get(p) - i);\n        }\n        return res;\n    }\n```\n**Time Complexity**\n* Time: O(n)\n* Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086767250","body":"**Thoughts**\n\nUse an array to simulate the stack, top var to record the index of the top value\nAlso, use another array to record the value needed to be added. Addition only happens with Popping, if PoP() is called, we start from the top value, add stack\\[top] with add\\[top], then we add the val in add\\[top] to the previous one add\\[top - 1], make sure the index in two array are  consistent\n\n**Code**\n```java\nclass CustomStack {\n    int[] stack;\n    int[] add;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        add = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        int ret = stack[top] + add[top];\n        if (top != 0) {\n            add[top - 1] += add[top];\n        }\n        add[top] = 0; \n        top--;\n        return ret;\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k - 1, top);\n        if (limit >= 0) {\n            add[limit] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n\n**Complexity**\nTime: O(1) for all operations\nSpace: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"antmup":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085970492","body":"### 思路\n1、首先将数组转换为对应的数字；\n2、将两个数字相加；\n3、将最终的数字拆解为数组；\n\n### 代码\n\n``` js\nfunction intSumOfArray(initNumArray, Addend) {\n  // 第一步\n  const initNum = +initNumArray.join('');\n\n  // 第二步\n  const tempSum = String(initNum + Addend);\n  console.log(tempSum, 'tempSum');\n  // 第三步\n  return  tempSum.split('').map(Number);\n}\n\nconsole.log(intSumOfArray([1, 2, 0, 0], 34));\nconsole.log(intSumOfArray([2, 7, 4], 181));\nconsole.log(intSumOfArray([2, 1, 5], 806));\n\n```\n\n** 复杂度分析 **\n- 时间复杂度：O(n)，\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086651757","body":"### 思路\n1、首先找到字符在数组中的下标数组；\n2、先处理第一个字符之前的，以及最后一个字符之后；\n3、如果当前元素等于目标字符，在数组中 push 0；\n4、处理两个字符中间的距离问题；\n\n### 代码\n\n``` js\nfunction beelineOfCharacter(targetString, targetCharacter) {\n  // 判断目标字符是否处在数组字符串的末尾\n  const isEnd = targetString[targetString.length - 1] === targetCharacter;\n  console.log(isEnd);\n\n  // 寻找目标字符在数组当中的位置\n  let targetCharIndex = [];\n  for (let i = 0; i < targetString.length; i++) {\n    if (targetString[i] === targetCharacter) {\n      targetCharIndex.push(i);\n    }\n  }\n  console.log(targetCharIndex, 'targetCharIndex');\n\n  let finalArray = [];\n  for (let j = 0; j < targetString.length; j ++) {\n    const item = targetString[j];\n    console.log(targetString[j], '1111');\n    // 等于目标元素就push0\n    if (item === targetCharacter) {\n      finalArray.push(0);\n    }\n\n    // 处理第一个目标字符之前的元素\n    const firstCharIndex = targetCharIndex[0];\n    if (j < firstCharIndex) {\n      const tempArray = numberToIndex(firstCharIndex);\n      finalArray.concat(tempArray);\n    }\n    \n  }\n  \n}\n\nfunction numberToIndex(number) {\n  let indexArray = [];\n  for (let i = 0; i < number; i++) {\n    indexArray.unshift(i);\n  }\n  indexArray.pop()\n\n  return indexArray;\n}\n\n\nbeelineOfCharacter('acd', 'c')\n\n```\n\n** 复杂度分析 **\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jax-van":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085972190","body":"## idea\n从低位往高位相加，并处理进位，可以用k同时存储进位信息，每次迭代有 k = (num[i] + k) / 10\n## code\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int len = num.length;\n        for (int i = len - 1; i >= 0; i--) {\n            res.add(0, (num[i] + k) % 10);\n            k = (num[i] + k) / 10;\n        }\n        while (k != 0) {\n            res.add(0, k % 10);\n            k /= 10;\n        }\n        return res;\n    }\n}\n```\n## complexity\n- time: O(max(len(num), digit(k))\n- space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086646210","body":"## idea\n左右遍历数组\n## code\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] res = new int[len];\n        int pre = Integer.MIN_VALUE / 2;\n        for (int i = 0; i < len; i++) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            res[i] = i - pre;\n        }\n        pre = Integer.MAX_VALUE / 2;\n        for (int i = len - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            res[i] = Math.min(res[i], pre - i);\n        }\n        return res;\n    }\n}\n```\n## complexity\n- time: O(n)\n- space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086874987","body":"## idea\n数组实现栈\n## code\n```java\nclass CustomStack {\n    int[] stack;\n    int top = 0;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if (top < stack.length) {\n            stack[top++] = x;\n        }\n    }\n    \n    public int pop() {\n        return top != 0 ? stack[--top] : -1;\n    }\n    \n    public void increment(int k, int val) {\n        for (int i = 0; i < k && i < top; i++) {\n            stack[i] += val;\n        }\n    }\n}\n```\n## complexity\n- time: push, pop = O(1), increment = O(min(k, top))\n- space: O(maxSize)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"webcoder-hk":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085977131","body":"```python\r\n# 都转成整数相加，再转成数组\r\nfrom typing import *\r\nfrom functools import reduce\r\n\r\ndef solution(a:List[int], b:int)->List[int]:\r\n    x = reduce(lambda x,y:x*10+y, a)\r\n    x += b\r\n    result = []\r\n    r = x%10\r\n    x //= 10\r\n    while x or r:\r\n        result.append(r)\r\n        r = x%10\r\n        x //= 10\r\n    result.reverse()\r\n    return result\r\n```\r\ntime: O(n)\r\nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086565255","body":"```python\r\n# 先正向遍历数组标出不等于C得字符，再反向遍历数组利用正向遍历留下得信息算出所需结果。\r\nclass Solution:\r\n    def shortestDistance(self, S:str, C:str)-> List[int]:\r\n        n = len(S)\r\n        result = [0 for _ in range(n)]\r\n        j = 0\r\n        for i in range(n):\r\n            if S[i]!=C:\r\n                j += 1\r\n                result[i] = j\r\n            else:\r\n                j = 0\r\n        j = 0\r\n        for i in range(n-1, -1, -1):\r\n            if S[i] != C:\r\n                j += 1\r\n                if i-result[i]>=0 and result[i-result[i]]==0:\r\n                    result[i] = min(result[i], j)\r\n                else:\r\n                    result[i] = j\r\n            else:\r\n                j = 0\r\n        return result\r\n```\r\ntime: O(2n)\r\nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086866910","body":"```python\nclass CustomStack:\n    def __init__(self, maxSize):\n        self.maxSize = maxSize\n        self.data = []\n        \n    def push(self, x):\n        if len(self.data) < self.maxSize:\n            self.data.append(x)\n            \n    def pop(self):\n        if len(self.data) > 0:\n            return self.data.pop()\n        else:\n            return -1\n\n    def increment(self, k, v):\n        n = min(len(self.data), k)\n        for i in range(n):\n            self.data[i] += v\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bluerui":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085981416","body":"# Problem [989. Add to Array-Form of Integer](https://leetcode.com/problems/add-to-array-form-of-integer/)\n## Algorithm\n1. Add *k* to each digit of num from the lowest digit.\n2. Then *k%10* is saved to result as the new digit, and *k/10* is used as the new *k* for next digit.\n3. The drawback of this method is if *k* is very close to MAX_VALUE (within 10), then there could be overflow.\n\n## Complexity\n* Time complexity: O(max(num.length, logK))\n* Space complexity: O(max(num.length, logK))\n\n## Code\nLanguage: Java\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> result = new ArrayList<>();\n    int cur = k;\n    int i = num.length - 1;\n    while (i >= 0 || cur > 0) {\n        if (i >= 0) {\n            cur += num[i];\n        }\n        result.add(cur % 10);\n        cur /= 10;\n        i--;\n    }\n    Collections.reverse(result);\n    return result;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086665460","body":"# Problem [821. Shortest Distance to a Character](https://leetcode.com/problems/shortest-distance-to-a-character/)\r\n\r\n## Algorithm\r\n1. Walk through the array from the left to find the closest char c to the right of each char in s.\r\n2. Then work through the array from the right to find the closest char c to the left of each char in s.\r\n3. Find the min distance of step 1 and 2.\r\n4. Step 2 and 3 can be combined.\r\n\r\n## Complexity\r\n* Time Complexity: We are going over the array exactly twice. O(N)\r\n* Space Complexity: We can use the same output array, so no extra space. O(1)\r\n\r\n## Code\r\nLanguage: Java\r\n```Java\r\npublic int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] result = new int[n];\r\n        Arrays.fill(result, n);\r\n        // Find closest c on the right of each char\r\n        int cur = 0;\r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) != c) {\r\n                continue;\r\n            }\r\n            while (cur <= i) {\r\n                result[cur] = i - cur;\r\n                cur++;\r\n            }\r\n        }\r\n\r\n        // Update to get the closest c from both sides by comparing left side\r\n        cur = n - 1;\r\n        for (int i = n - 1; i >=0; i--) {\r\n            if (s.charAt(i) != c) {\r\n                continue;\r\n            }\r\n            while (cur >= i) {\r\n                result[cur] = Math.min(result[cur], cur - i);\r\n                cur--;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086891831","body":"# Problem: [1381. Design a Stack With Increment Operation](https://leetcode.com/problems/design-a-stack-with-increment-operation/)\n\n## Algorithm\n* Use an array to implement ths stack\n* Use *index* to track the current number of elements in the array and the top of the stack.\n\n## Complexity\n* *push* operation time complexity is O(1) since we simply assign one value to the current index of the array.\n* *pop* operation time complexity is O(1).\n* *inc* operation time complexity is O(k) where k is the number of elements to increment.\n* Total space complexity of the stack is O(n) where n is the maxSize.\n\n## Code\nLanguage: Java\n```java\nclass CustomStack {\n    private int[] stack;\n    private int index = 0;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if (index == stack.length) {\n            return;\n        }\n        stack[index++] = x;\n    }\n    \n    public int pop() {\n        if (index == 0) {\n            return -1;\n        }    \n        return stack[--index];\n    }\n    \n    public void increment(int k, int val) {\n        for (int i = 0; i < k; i++) {\n            if (i + 1 > index) {\n                return;\n            }\n            stack[i] += val;\n        }\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mrorz0914":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086000216","body":" public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans= new ArrayList<>();\n        for(int i=num.length-1;i>=0;i--)\n        {\n            ans.add(0,(num[i]+k)%10);\n            k=(k+num[i])/10;\n        }\n        while(k!=0)\n        {\n            ans.add(0,k%10);\n            k=k/10;\n        }\n        return ans;\n    }\n##复杂度\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duantao74520":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086000316","body":"### 思路：\n\n小学加法，大于10进一，从个位开始加，将结果塞到数组，最终返回数组时，翻转一下数组。\n\n例如【2,1,5】 与 806\n\n1. 遍历数组，初始化进位为0\n\n   5 + 8 + 0 = 11 ，塞1， 进位1。\n\n   1 + 0 + 1 = 2    ，塞2， 进位0\n\n   2 + 8 + 0 = 10  ，塞0， 进位1\n\n   关键在遍历完数组后，k 有可能为0 ，但是进位可能为1.\n\n2. 特殊处理以上情况\n\n   k += 进位\n\n   这样的话，k为0 ，构造成1， k非0，刚好可以进位\n\n3. 遍历剩余的k，每次除10\n\n### 代码：\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> ret_vec;\n        int up = 0;\n        // 遍历num\n        for (int pos = num.size() - 1 ; pos >= 0; pos--) {\n            int a = num[pos];\n            int b = k % 10;\n            k = k / 10;\n            ret_vec.emplace_back((a + b + up) % 10);\n            up = (a + b + up) /10;\n        }\n        k = k + up; // 防止有进位 k 还等于0的情况\n        while (k > 0) {\n            ret_vec.emplace_back(k % 10 );\n            k = k /10;\n        }\n         std::reverse(ret_vec.begin(), ret_vec.end());\n         return ret_vec;\n    }\n};\n```\n\n### 复杂度：\n\n1. 空间复杂度 O(1)\n\n2. 时间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086631015","body":"### 思路：\n\n维护两个指针，一个代表着离左边的c的位置，一个代表着离右边的c的位置\n\n遍历数组：\n\n1. 从左往右遍历s1，直到找到c，然后赋值左右c。\n2. 再次从左往右遍历s2，开始记录离左右两边最近的c。\n3. 直到s2遍历到c的位置，继续遍历上一个遍历队列s1,直到数组尽头\n4. 继续遍历s2，输出位置\n\n### 代码：\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n       int c_l = -1, c_r = -1;\n        int i = 0, j = 0;\n        vector<int> ret_vec;\n        while (j < s.size()) {\n            for (i ; i < s.size(); i++) {\n                if (s[i] == c) {\n                    c_l = c_r;\n                    c_r = i;\n                    if (c_l == -1) { // 第一个c\n                        c_l = c_r;\n                    }\n\t\t\t\t\ti++;\n                    break;\n                }\n                if (i == s.size()-1) { // 最后一个c\n                    c_l = c_r;\n                }\n            }\n            for (j ; j < i; j++) {\n                ret_vec.emplace_back(min(abs(j - c_l) , abs(j-c_r)));\n            }\n\t\t\tcout << c_l << c_r << i << j <<endl;\n        }\n        return ret_vec;\n    }\n};\n```\n\n### 复杂度：\n\n时间： o(n)\n\n空间： o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086849106","body":"### 思路：\n\n正常模拟栈的操作，用top代表栈顶，maxSize代表着最大的数组长度\n\n### 代码：\n\n```c++\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        my_stack =  new vector<int>(maxSize);\n        top = -1;\n        max_size = maxSize;\n    }\n    \n    void push(int x) {\n        if (top < max_size - 1) {\n            top ++;\n            (*my_stack)[top] = x;\n        } else {\n            return;\n        }\n    }\n    \n    int pop() {\n        if (top >= 0) {\n            top --;\n            return (*my_stack)[top+1];\n        } else {\n            return -1;\n        }\n    }\n    \n    void increment(int k, int val) {\n        for (int i = 0; i <= top && i < k; i++) {\n            (*my_stack)[i] += val;\n        }\n    }\nprivate:\n    vector<int>* my_stack;\n    int max_size;\n    int top;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```\n\n### 复杂度：\n\n时间： add/top: O(1)  inc:O(N)\n\n空间复杂度： O(N);\n\n### 改进一：\n\n由于只有pop的时候才会取数，那么我们可以存一个add的数组，代表着所有增加的值。\n\n比如：\n\n- 调用了 increment(3, 2)，就把 increment[3] 增加 2。\n- 继续调用 increment(2, 5)，就把 increment[2] 增加 5。\n\n![img](https://tva1.sinaimg.cn/large/0081Kckwly1glwx1ryzxpj31jq0hijte.jpg)\n\n而当我们 pop 的时候：\n\n- 只需要将栈顶元素**加上 increment[cnt - 1]** 即可， 其中 cnt 为栈当前的大小。\n- 另外，我们需要将 increment[cnt - 1] 更新到 increment[cnt - 2]，并将 increment[cnt - 1] 重置为 0。\n\n### 代码：\n\n```\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        my_stack.resize(maxSize);\n        add_vec.resize(maxSize);\n        top = -1;\n        max_size = maxSize;\n    }\n    \n    void push(int x) {\n        if (top < max_size - 1) {\n            top ++;\n            my_stack[top] = x;\n        } else {\n            return;\n        }\n    }\n    \n    int pop() {\n        if (top >= 0) {\n            // s[top] + add[top]\n            int val = my_stack[top] + add_vec[top];\n            // add[top-1] += add[top]\n            if (top >= 1) {\n                add_vec[top -1] += add_vec[top];\n            }\n            add_vec[top] = 0;\n            top --;\n            return val;\n        } else {\n            return -1;\n        }\n    }\n    \n    void increment(int k, int val) {\n        int limit = min(k -1, top);\n        if (limit >= 0) {\n            add_vec[limit] += val;  // 只需要记录需要加的数\n        }\n    }\nprivate:\n    vector<int> my_stack;\n    vector<int> add_vec;\n    int max_size;\n    int top;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```\n\n### 复杂度：\n\n空间 O(N)\n\n时间 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"omegalzx":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086006617","body":"~~~java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int[] num2 = convertNumToArray(k);\n        List<Integer> result = new ArrayList<>();\n        int i = num.length - 1;\n        int j = num2.length - 1;\n        int carry = 0;\n        while (i >= 0 || j >= 0) {\n            int sum = carry;\n            if (i >= 0) {\n                sum += num[i];\n            }\n            if (j >= 0) {\n                sum += num2[j];\n            }\n            result.add(sum % 10);\n            carry = sum / 10;\n            i--;\n            j--;\n        }\n        if (carry > 0) {\n            result.add(carry);\n        }\n        Collections.reverse(result);\n        return result;\n    }\n\n\n    private int[] convertNumToArray(int num) {\n        List<Integer> result = new LinkedList<>();\n        while (num > 0) {\n            result.add(num % 10);\n            num /= 10;\n        }\n        Collections.reverse(result);\n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}\n~~~\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086682692","body":"~~~java\r\nclass CustomStack {\r\n\r\n    private final int maxSize;\r\n    private final int[] stack;\r\n    private final int[] inc;\r\n    private int top = -1;\r\n    private final int bottom = 0;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize;\r\n        stack = new int[maxSize];\r\n        inc = new int[maxSize];\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (top == maxSize - 1) {\r\n            return;\r\n        }\r\n        stack[++top] = x;\r\n    }\r\n\r\n    public int pop() {\r\n        if (top < bottom) {\r\n            return -1;\r\n        }\r\n        int res = stack[top] + inc[top];\r\n        if (top > bottom) {\r\n            inc[top - 1] += inc[top];\r\n        }\r\n        inc[top] = 0;\r\n        top--;\r\n        return res;\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int i = Math.min(k - 1, top);\r\n        if (i >= bottom) {\r\n            inc[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n~~~","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"vivixu-qiqi":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086007071","body":"```\r\nvar addToArrayForm = function(num, k) {\r\n    let sum = k;\r\n    let index = num.length - 1;\r\n    let result = '';\r\n    let resultArr = [];\r\n    while(index >= 0 || sum > 0) {\r\n        if(index >= 0) {\r\n            sum += num[index];\r\n        }\r\n        result += sum % 10;\r\n        sum = Math.floor(sum / 10);\r\n        index--;\r\n    }\r\n    for(let i = result.length - 1; i >= 0; i--) {\r\n        resultArr.push(+result[i]);\r\n    }\r\n    return resultArr;\r\n};\r\n```\r\nTime Complexity：O(max(n,logk))\r\nSpace Complexity：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086646668","body":"```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        result = [];\r\n        for i in range(len(s)):\r\n            if (s[i] == c):\r\n                result.append(0)\r\n                continue\r\n            for left in range(i, -1, -1):\r\n                dist1 = 0\r\n                if (s[left] == c):\r\n                    dist1 = i - left\r\n                    break\r\n            for right in range(i, len(s)):\r\n                dist2 = 0\r\n                if (s[right] == c):\r\n                    dist2 = right - i\r\n                    break\r\n            if (dist1 == 0):\r\n                result.append(dist2)\r\n            if (dist2 == 0):\r\n                result.append(dist1)   \r\n            if (dist1 <= dist2 and dist1 != 0):\r\n                result.append(dist1)\r\n            if (dist1 > dist2 and dist2 != 0):\r\n                result.append(dist2)    \r\n\r\n        return result;\r\n```\r\nTime Complexity: O(N)\r\nSpace Complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086874419","body":"```\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n  this.maxSize = maxSize\r\n  this.size = 0\r\n  this.stack = []\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.size < this.maxSize) {\r\n    this.stack.push(x)\r\n    this.size++\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n  if (this.size === 0) {\r\n    return -1\r\n  } else {\r\n    this.size--\r\n    return this.stack.pop()\r\n  }\r\n};\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n  for (let i = 0; i < Math.min(k, this.size); i++) {\r\n    this.stack[i] += val\r\n  }\r\n};\r\n```\r\nO(1) for time and space complexity","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kwdfw":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086007092","body":"Day1\n\n[989、数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n#javascript\n## 思路\n1、类似现实中的加法题，取数组和数字的对应位相加并加上进位\n\n2、若相加和大于9，则用carry记录下进位为1\n\n3、算完一直就输入到数组中一位\n\n4、不断循环，从最后一位一直到第一位\n\n5、反转数组\n\n#### 处理特殊示例\n1、相加的结果比原来的位数多一位，如990+100=1090，需要在循环结束后单独判断再加一位\n\n2、数组的位数比数字的位数少，如0+23，按照循环会造成数组越界，需要加判断条件，越界就将值置为0\n## 代码\n```javascript\nvar addToArrayForm = function(num, k) {\n    let carry=0//记录进位\n    let ru=[]//最终返回的数组\n    let i=num.length-1//循环计数器\n    let result//每一位的结果\n    while(i>-1||k!=0){//||条件保证任意位数的情况下都可以进入循环\n        const x= i>=0? num[i]:0//解决数组和数字位数不同的问题\n        const y=k!=0 ? k%10:0\n        result=x+y+carry//得到某位的值\n        if(result>9){//若大于9，则保留进位，并输入到数组中\n            carry=1\n            ru.push(result%10)\n        }\n        else{//若小于等于9，则不保留进位，并输入到数组中\n            carry=0\n            ru.push(result)\n        }\n        k=Math.floor(k/10)//下取整，有时会自动进位\n        i--//推进循环\n    }\n    if(carry==1) ru.push(1)//解决相加结果比原来多一位\n    return ru.reverse()//反转数组\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086653607","body":"Day2\n\n[821、数组形式的整数加法](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n#javascript\n## 思路\n1、遍历数组\n\n2、对于每个字符都分别向左和右查找c\n\n3、对比左和右的长度，取最小值填入数组中\n\n## 代码\n```javascript\nvar shortestToChar = function(s, c) {\n    var answer=Array(s.length).fill(0);//将数组中填满0\n    for(let i=0;i<s.length;i++){\n      if (s[i] === c) continue;//若该位置与字符相同，则不用管\n      let short=Infinity\n      for(let j=i;j<s.length;j++){\n          if(s[j]===c){\n              short=Math.min(short,j-i)\n              break\n          }\n      }  \n      for(let k=i;k>-1;k--){\n          if(s[k]===c){\n               short=Math.min(short,i-k)\n               break\n          }\n      }\n      answer[i]=short\n    }\n    return answer\n};\n```\n## 复杂度分析\n时间复杂度：O(n2)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086894389","body":"Day3\n\n[1381、设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/submissions/)\n\n#javascript\n## 思路\n1、设置一个辅助数组inc\n\n2、调用增量函数的时候，用inc记录增加的数和值\n\n3、执行pop操作的时候，通过inc实现增加的值(利用栈的操作特性，减少了时间复杂度)\n\n## 代码\n```javascript\n/**\n * @param {number} maxSize\n */\nlet increments=[]//记录inc函数的传入值\n\n\nvar CustomStack = function(maxSize) {\n    this.max=maxSize\n    this.stack=[]\n    increments=Array(this.max).fill(0)//把数组的所有元素填满为0\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.max>this.stack.length)\n    this.stack.push(x)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.stack.length==0) return -1\n    else{\n        increments[this.stack.length-2]+=increments[this.stack.length-1]\n        //inc数组的栈顶加到栈顶的下一个\n        const res=increments[this.stack.length-1]+this.stack.pop()\n        //将inc数组的栈顶加到原栈的栈顶\n        increments[this.stack.length]=0\n        //inc数组的栈顶置0\n        return res\n        //注意：stack.length的值一直在变\n    }\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    if(k>this.stack.length) increments[this.stack.length-1]+=val\n    //如果栈中元素总数小于k，赋值到inc数组的栈顶\n    else increments[k-1]+=val\n    //对应inc数组的栈加上增加的值\n};\n```\n## 复杂度分析\n时间复杂度：O(1)\n\n空间复杂度：O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mozro0327":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086012990","body":"### lc989 数组形式的整数加法\n\n#### 解法一\n\n##### 思路\n\n+ 先将数组翻转\n+ 在将 k 全部加在数组最后一位上\n+ 计算数组最后一位的进位，并作为下一次运算的 k\n+ 直到 k 为 0 且 数组遍历完成\n+ 最后将数组重新翻转\n\n##### 代码实现\n\n~~~ c++\nclass Solution1 {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int len = num.size();\n        reverse(num.begin(), num.end());\n\n        for (int i = 0; i < len; i++) {\n            num[i] += k;\n            k = num[i] / 10;\n            num[i] %= 10;\n        }\n\n        while (k > 0) {\n            num.push_back(k % 10);\n            k /= 10;\n        }\n\n        reverse(num.begin(), num.end());\n        return num;\n    }\n};\n~~~\n\n##### 复杂度\n\n+ 时间复杂度：O(n)\n+ 空间复杂度：O(1)\n\n\n\n#### 解法二\n\n##### 思路\n\n+ 将数组和 k 逐位相加\n+ 计算进位，并加在 k 的下一位上\n+ 直到 k 为 0 且数组遍历完成\n\n##### 代码实现\n\n~~~ c++\nclass Solution2 {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int len = num.size();\n        vector<int> result;\n\n        for (int i = len - 1; i >= 0; i--) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum > 9) {\n                k++;\n                sum -= 10;\n            }\n            result.push_back(sum);\n        }\n        while (k > 0) {\n            result.push_back(k % 10);\n            k /= 10;\n        }\n\n        reverse(result.begin(), result.end());\n        return result;\n    }\n};\n~~~\n\n##### 复杂度\n\n+ 时间复杂度：O(n)\n+ 空间复杂度：O(n)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"christ36":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086018719","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n       List<Integer> res= new ArrayList<Integer>();\n       Integer n = num.length;\n       for(int i = n-1 ;i>=0||k>0;--i,k/=10)\n       {\n           if(i>=0)\n           {\n               k+=num[i];\n           }\n           res.add(k%10);\n       }\n       Collections.reverse(res);\n        return res;\n    }\n}\n\n思路：将整个加数 k 加入数组表示的数的最低位。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086664444","body":"### 【Day 2】821. 字符的最短距离\n#### 思路：分别比较左边和右边距离最近的值，取最小。\n从左向右遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 i - prev。\n从右想做遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 prev - i。\n```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int pre = -10000; //最大数据范围是10000\n        int[] ans = new int[n];\n        for (int i = 0; i < s.length(); i++) { //计算左段与c最近的距离\n            if (s.charAt(i) == c) pre = i;\n            ans[i] = i - pre;\n        }\n        pre = 10000;\n        for (int i = s.length() - 1; i >= 0; i--) { //计算右段与c最近的距离,同时与之前记录的左段进行比较\n            if (s.charAt(i) == c) pre = i;\n            ans[i] = Math.min(ans[i], pre - i);\n        }\n        return ans;\n    }\n}\n```\n###\n时间复杂度：O(N)O(N)，其中 NN 是 S 的长度，我们需要遍历字符串两次。\n空间复杂度：O(N)O(N)，ans 数组的大小。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086897344","body":"### 【Day 3】1381. 设计一个支持增量操作的栈\n方法1：模拟\n```\nclass CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            ++top;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zjsuper":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086021602","body":"class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        sums = 0\n        for i,j in enumerate(num):\n            sums += j*10**(len(num)-i-1)\n        sums += k\n        ans = []\n        while sums:\n            temp = sums %10\n            sums = sums//10\n            ans.insert(0,temp)\n        return ans\n            \n            ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086548738","body":"```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        dic = []\n        for i,j in enumerate(s):\n            if j == c:\n                dic.append(i)\n        ans = []\n        \n        for i in range(len(s)):\n            temp = []\n            for j in dic:\n                temp.append(abs(j-i))\n            ans.append(min(temp))\n        return ans\n```\n                \n            ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086898887","body":"```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n        \n\n    def push(self, x: int) -> None:\n        if len(self.stack)<self.maxSize:\n            #self.stack.insert(0,x)\n            self.stack.append(x)\n        \n\n    def pop(self) -> int:\n        if len(self.stack) == 0:\n            return -1\n        else:\n            return self.stack.pop()\n        \n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack)<=k:\n            self.stack = [i+val for i in self.stack]\n        else:\n            for i in range(k):\n                self.stack[i] += val\n        \n```      ","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lskong":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086022222","body":"class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& A, int K) {\n\n        vector<int> res;\n        res.reserve(A.size() + 5);\n\n        int i = A.size() - 1;\n        int carry = 0;\n\n        while (i >= 0 || K > 0)\n        {\n            int n1 = i >= 0 ? A.at(i) : 0;\n            int n2 = K > 0 ? K % 10 : 0;\n            int sum = n1 + n2 + carry;\n            carry = sum / 10;\n            res.push_back(sum % 10);\n            --i;\n            K /= 10;\n        }\n\n        if (carry)\n        {\n            res.push_back(1);\n        }\n\n        reverse(res.begin(), res.end());\n\n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086585016","body":"class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> pos;\n        vector<int> res;\n        for(int i = 0; i < s.size(); i++) {\n            if(s[i] == c) {\n                pos.push_back(i);\n            }\n        }\n        for(int i = 0; i < s.size(); i++) {\n            int tmp = 100000000000000;\n            for(int j = 0; j < pos.size(); j++) {\n                tmp =min(tmp, abs(i -pos[j]));\n            }\n            res.push_back(tmp);\n        } \n    return res;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mapo0102":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086022435","body":"思路：\n创建一个链表，获取数组长度\n逆序从最低位开始，进行链表的加和。\n完成加和后，判断k值是否完成，如果未完成，继续向链表头部加k值，然后k/10，消耗尽k的所有位数。\n\n代码：\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> res = new LinkedList<>();\n        int n = num.length;\n\n        for (int i = n - 1; i >= 0 ; i--) {\n            int sum = k%10 + num[i];\n            k = k / 10;\n            if(sum >= 10){\n                sum -= 10;\n                k++;\n            }\n            res.add(0,sum);\n        }\n        while(k>0){\n            res.add(0,k%10);\n            k=k/10;\n        }\n        return res;\n    }\n\n    }\n\n\n复杂度：\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086646897","body":"思路：\n首先先从左向右遍历一遍，将ans数组中的所有元素标志成对应位。\n再从右往左遍历一遍，再比较大小，将ans对应位置中更小的数放入对应ans。\n\n代码：\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] ans = new int[N];\n        int prev = Integer.MIN_VALUE / 2;\n\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = i - prev;\n        }\n\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = N-1; i >= 0; --i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n\n        return ans;\n    }\n}\n\n时间复杂度：O（n）\n空间复杂度：O（n）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiradaone":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086024431","body":"### 思路\n\n数组num转换为字符串与k相加后再转换为List\n\n### 代码\n\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        tostr = ''.join([str(i) for i in num])\n        res = str(int(tostr)+ k)\n        reslist = [int(i) for i in res]\n        return reslist\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)，其中 n 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086897297","body":"\n### 代码\n\n\n```\nclass CustomStack {\n    int[] stack;\n    int size;\n    int[] increment;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        increment = new int[maxSize + 1];\n        size = 0;\n    }\n    \n    public void push(int x) {\n        if(size == stack.length){\n            return;\n        }\n        stack[size++] = x;\n    }\n    \n    public int pop() {\n        if(size == 0){\n            return -1;\n        }\n        int res = stack[size - 1];\n        if(increment[size] != 0){\n            res += increment[size];\n            increment[size - 1] += increment[size];\n            increment[size] = 0;\n        }\n        size--;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        increment[Math.min(k, size)] += val;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(maxSize)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"oneline-wsq":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086026979","body":"### 思路\n\n将num数组计算为一个数，然后再与k相加，最后再返回数组。\n\n### 代码\n\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n\n        sum1=0\n        n=len(num)\n        for i in range(n):\n            sum1=sum1+pow(10,n-i-1)*num[i]\n\n        sum2=sum1+k\n\n        return [int(x) for x in str(sum2)]\n```\n\n### 复杂度分析\n\nTime: O(n)\n\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086597093","body":"### 思路\n\n首先在s中找到所有等于c的索引；再从0开始循环，计算与索引集合相减绝对值最小的值。\n\n### 代码\n\n```python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n\n        ans=[]\n        # 首先找出所有的c的索引\n        tmp=[]\n        k=0\n        for i in s:\n            if i==c:\n                tmp.append(k)\n            k+=1\n        \n        for i in range(len(s)):\n            tmp2=[abs(j-i)for j in tmp]\n            ans.append(min(tmp2))\n\n        return ans\n```\n\n### 复杂度分析\n\n时间复杂度：O(n*m)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086844229","body":"### 思路\n\n用python的list实现。\n\n### 代码\n\n```python\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.maxsize=maxSize\n        self.stack=[]\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.stack)<self.maxsize:\n            self.stack.append(x)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.stack)==0:\n            return -1\n        else:\n            ans=self.stack[-1]\n            self.stack=self.stack[0:-1]\n            return ans\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        n=len(self.stack)\n        addn=min(k,n)\n        for i in range(addn):\n            self.stack[i]=self.stack[i]+val\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n### 复杂度分析\n\n时间复杂度: O(N)\n\n空间复杂度: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuguang520-lab":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086037440","body":"##思路\n模拟加法运算，注意将数组反转\n\n##code\n```cpp\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {//判断是否有进位\n                k++;\n                sum -= 10;\n            }\n            res.push_back(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.push_back(k % 10);//判断k是否比数组的长度要长\n        }\n        reverse(res.begin(), res.end());\n        return res;\n```\n##复杂度分析\n- 实践复杂度O(n)\n- 空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086646031","body":"#思路\n使用的是暴力解法没有使用官方的前后遍历所以时间复杂度和空间复杂度比较高\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> result;\n        vector<int > index;\n        int len = s.length();\n        for(int i = 0; i< len; i++)\n        {\n            if(s.at(i) == c)//将字符串转换成字符在进行比较\n            {\n                index.push_back(i);\n            }\n        }\n        int len_index = index.size();\n        for(int i = 0; i < len; i++)\n        {\n            int dis_min = len;//初始化为len\n            for(int j =0; j<len_index; j++)\n            {\n                dis_min = min(abs(i-index[j]),dis_min);\n            }\n            result.push_back(dis_min);\n        }\n    return result;\n    }\n};\n```\n#复杂度分析\n- 时间复杂度O(cN) c表示c字符出现的数量，n为字符串的长度\n-空间复杂度O(2N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086816450","body":"# 思路\n使用数组模拟栈的用法，定义一个容量，栈顶和栈底就很容易实现\n# code\n```cpp\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        element = new int[maxSize];\n        top_stack = -1;\n        maxsize = maxSize;\n    }\n    \n    void push(int x) {\n        if(top_stack == maxsize - 1)\n        {\n            return;//超过容量，不进行操作\n        }\n        element[++top_stack] = x;\n    }\n    \n    int pop() {\n        if(top_stack < 0)\n        {\n            return -1;\n        }\n        return element[top_stack--];\n    }\n    \n    void increment(int k, int val) {\n        if(top_stack < k - 1) //按照最短长度进行累加\n        {\n            for(int i = 0; i <= top_stack; i++)\n            {\n                element[i] += val;\n            }\n        }\n        else\n        {\n            for(int i = 0; i < k; i++)\n            {\n                element[i] +=val;\n            }\n        }\n    }\nprivate:\n    int* element;//数组\n    int top_stack;//栈顶\n    int maxsize;//最大容量\n};\n```\n# 时间复杂度分析\n- 空间复杂度O(N)\n\n- 时间复杂度O(N) 利用了一个数组进行模拟","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biscuit279":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086037807","body":"# 思路：两次遍历，两次转换\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = len(num)\n        array_num = 0\n        for i in range(n):\n            array_num += num[i] * (10 ** (n-i-1))\n        total = array_num + k\n        ans = []\n        for s in str(total):\n            ans.append(int(s))\n        return ans \n```\n时间复杂度:O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086594925","body":"#思路:笨蛋解法，第一次遍历找位置，第二次遍历求距离最小值\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = []\n        position = []\n        for i,item in enumerate(s):\n            if item == c:\n                position.append(i)\n\n        for i in range(len(s)):\n            dis = []\n            for p in position:\n                dis.append(abs(i-p))\n            ans.append(min(dis))\n        return ans\n```\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bruceleeqaq":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086039762","body":"思路:  模拟加法，先将数组转换成数字 再将结果转换为数组\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\t\ti = len(num)-1\n        while k:\n            num[i] += k\n            k, num[i] = num[i]//10, num[i]%10\n            i -= 1\n            if i<0 and k:\n                num.insert(0,0)\n                i = 0 \n        return num\n\n\n复杂度\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086661332","body":"\n\n```class Solution:\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        \n        c_pos, ans = [], []\n        for idx, i in enumerate(s):\n        class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        \n        c_pos, ans = [], []\n        for idx, i in enumerate(s):\n            if i == c:\n                c_pos.append(idx)\n        \n        p = 0\n        for i in range(len(s)):\n            if i < c_pos[0]:\n                ans.append(c_pos[0] - i)\n            elif i > c_pos[-1]:\n                ans.append(i - c_pos[-1])\n            elif i == c_pos[p]:\n                ans.append(0)\n                p += 1\n            else:\n                ans.append(min(c_pos[p] - i, i - c_pos[p-1]))\n        return ans    if i == c:\n                c_pos.append(idx)\n        \n        p = 0\n        for i in range(len(s)):\n            if i < c_pos[0]:\n                ans.append(c_pos[0] - i)\n            elif i > c_pos[-1]:\n                ans.append(i - c_pos[-1])\n            elif i == c_pos[p]:\n                ans.append(0)\n                p += 1\n            else:\n                ans.append(min(c_pos[p] - i, i - c_pos[p-1]))\n        return ans\n```\n\n复杂度\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086895082","body":"\n\n```python\nclass CustomStack {\n    int[] mStack;\n    int top = -1;\n    public CustomStack(int maxSize) {\n        mStack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(top < mStack.length-1){\n            mStack[++top] = x;\n        }\n       \n    }\n    \n    public int pop() {\n        if(top>=0){\n            return mStack[top--];\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        int temp = top<k-1?top:k-1;\n        for(int i=0;i<=temp;i++){\n            mStack[i] +=val;\n        }\n    }\n}\n```\n\n复杂度\n\n时间复杂度：O(1)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zenwangzy":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086041856","body":"## 思路\n从最低位想相加开始计算起\n\n\n```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```\n## 复杂度\ntime O(N)\nspace O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086660724","body":"## 思路\n左右遍历 问题在于初始的c位置怎么算,算到数组中间好了\n对于prev\n因为如果不除以2的话，INT_MIN= -2^31，而刚开始的时候i-INT_MIN=i+2^31就会发生溢出，但是INT_MAX-i就不会发生溢出了，所以INT_MAX就没必要除以2了，为了看起来舒服点都除以2了\n```\nclass Solution {\npublic:\n   vector<int> shortestToChar(string S, char C) {\n       vector<int> distance(S.size(), 0);\n       int prev = INT_MIN/2;\n       for(int i = 0; i < S.size(); i ++){\n           if(S[i] == C) prev = i;\n           distance[i] = i - prev;\n       }\n       prev = INT_MAX/2;\n       for(int i = S.size() - 1; i >= 0; i --){\n           if(S[i] == C) prev = i;\n           distance[i] = min(distance[i], prev - i);\n       }\n       return distance;\n   }\n};\n```\n## 复杂度\n时空O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liyubin117":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086054479","body":"思路在注释里\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] A, int K) {\n        // 初始化参数\n        List<Integer> res = new ArrayList<Integer>();\n        int n = A.length;\n\n        // 1. 从后往前逐位相加\n        for(int i = n - 1;i >= 0;i--){\n            // 1.1 逐位相加\n            int sum = A[i] + K % 10;         // 每次重置sum\n            K /= 10;    \n            // 1.2 处理两位相加 进位的情况\n            if(sum >= 10){\n                K++;                        // 进位到K的末尾\n                sum -= 10;                  // 进位清掉\n            }\n            // 1.2 当前相加的结果 添加到结果集\n            res.add(sum);\n        }\n\n        // 2. K的数字长度大于数组的数字长度\n        for(;K > 0;K /= 10){                // 每次K左移一位\n            res.add(K % 10);                // 添加到结果集\n        }\n\n        // 3. 将结果集翻转即是所求答案\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n复杂度\n空间：O(N)\n时间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086663042","body":"思路：\r\n从左向右遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 i - prev。\r\n从右想做遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 prev - i。\r\n这两个值取最小就是答案。\r\n```\r\n    public int[] shortestToChar(String S, char C) {\r\n        int N = S.length();\r\n        int[] ans = new int[N];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        for (int i = 0; i < N; ++i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = N-1; i >= 0; --i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n```\r\n复杂度\r\n时间复杂度：O(N)，其中 N 是 S 的长度，我们需要遍历字符串两次。\r\n空间复杂度：O(N)，ans 数组的大小。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"houyanlu":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086055675","body":"### 思路\n\n从最低位开始跟k的个位相加，大于10则进一位，\n\n\n### 代码\n\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> result;\n        int n = num.size();\n\n        // 从个位开始跟k的个位相加，大于10则进一位\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            result.push_back(sum);\n        }\n\n        // 最后剩下的k， 说明k是比原数组很大很大，应该是放在加和后的高位\n        for (; k > 0; k /= 10) {\n            result.push_back(k % 10);\n        }\n\n        std::reverse(result.begin(), result.end());\n\n        return result;\n    }\n};\n\n**复杂度分析**\n- 时间复杂度：O(N)，一次遍历\n- 空间复杂度：O(N) 同等大小的一个vector","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086646499","body":"### 思路\n\n先从后往前遍历一遍，\n再从前往后遍历一遍，查漏补缺以及比较出最近的值\n\n### 代码\n\n\n```cpp\n\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int length = s.length();\n        vector<int> resultVector(length, -1);\n\n        int preIndex = -1;\n\n        for (int i = length - 1; i >= 0; i--) {\n            if (s.at(i) == c) {\n                preIndex = i;\n                resultVector[i] = 0;\n            }\n\n            if (preIndex != -1) {\n                resultVector[i] = preIndex - i;        \n            }\n\n        }\n\n        preIndex = -1;\n        for (int i = 0; i < length; i++) {\n            if (s.at(i) == c) {\n                preIndex = i;\n            } else if (resultVector.at(i) == -1 && preIndex != -1) {\n                 resultVector[i] = i - preIndex;        \n            } else if (resultVector.at(i) != -1 && preIndex != -1) {\n                resultVector[i] = std::min(i - preIndex, resultVector[i]);\n            }\n        }\n\n        return resultVector;\n    }\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086895800","body":"### 思路\n\n使用数组模拟栈，用一个变量 m_topIndex 来记录当前栈顶的位置.\n\npush 操作，先判断是否到达栈顶，没有就 m_topIndex 自增1，数组的相应位置 赋值。\n\npop 操作，先判断是否为空，空返回−1， 否则m_topIndex 自减后返回自减前位置的值。\n\ninc 操作，直接对栈底的最多 k 个元素加上 val。\n\n### 代码\n\n\n```cpp\n\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        m_vector.resize(maxSize);\n    }\n    \n    void push(int x) {\n        if (m_topIndex != m_vector.size() - 1) {\n            m_topIndex++;\n            m_vector[m_topIndex] = x; \n        }\n\n        \n        \n    }\n    \n    int pop() {\n        if (m_topIndex == -1) {\n            return -1;\n        }\n\n        m_topIndex--;\n        return m_vector[m_topIndex + 1];\n    }\n    \n    void increment(int k, int val) {\n        int limit = std::min(k, m_topIndex + 1);\n\n        for (int i = 0; i < limit; i++) {\n            m_vector[i] += val;\n        }\n    }\n\nprivate:\n    vector<int> m_vector;\n    int m_topIndex {-1};\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n\n```\n\n\n**复杂度分析**\n- 时间复杂度：因为数组支持随机访问，push和pop都是O(1), inc是O(k)\n- 空间复杂度：O(maxSize)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gaominghao":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086056841","body":"### 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n\t\tList<Integer> result = new ArrayList<>();\n\t\tfor(int i = num.length - 1; i >= 0; i--) {\n\t\t\tint temp = (num[i] + k) % 10;\n\t\t\tk = (k + num[i])/10;\n\t\t\tresult.add(temp);\n\t\t}\n\t\twhile(k!=0) {\n\t\t\tresult.add(k%10);\n\t\t\tk = k/10;\n\t\t}\n\t\tCollections.reverse(result);\n\t\treturn result;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086663153","body":"### 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n\t\tint N = s.length();\n\t\tint[] ans = new int[N];\n\t\tint pre = -N;\n\t\tfor(int i = 0; i<N;i++) {\n\t\t\tif(s.charAt(i) == c) pre = i;\n\t\t\tans[i] = i-pre;\n\t\t}\n\t\tpre = 2*N;\n\t\tfor(int i = N-1; i>=0;i--) {\n\t\t\tif(s.charAt(i) == c) pre = i;\n\t\t\tans[i] = Math.min(ans[i],pre-i);\n\t\t}\n\t\treturn ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086891512","body":"```java\npublic class CustomStack {\n    int[] stack;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top =-1;\n    }\n    public void Push(int x) {\n        if(top!=stack.Length-1)\n        {\n            top++;\n            stack[top]=x;\n        }\n    }\n    public int Pop() {\n        if(top==-1)\n        {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n    public void Increment(int k, int val) {\n        int limit = Math.Min(k, top + 1);\n        for (int i = 0; i < limit; ++i)\n        {\n            stack[i] += val;\n        }\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"w-will":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086057669","body":"## Idea:\nGo through the num array, accumulate the sum of each digits. Then sum with k and convert into a list.\n\n## Code:\n'''\n\n\tclass Solution:\n\t\tdef addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\t\t\tsumArr = 0\n\t\t\tfor i, e in enumerate(num[::-1]):\n\t\t\t\tsumArr += e if i == 0 else e * (10 ** i)\n\n\t\treturn map(int, list(str(sumArr + k)))\n'''\n\nTime: O(n)\nSpace: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hohojii":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086058735","body":"##思路\n逐位相加\n##代码\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            res.add(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n##复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086665804","body":"##左右遍历\n##code\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> ans(n, 1e6);\n        int last = -1e6;\n        for(int i = 0; i < n; i++) {\n            if(s[i] == c) {\n                ans[i] = 0;\n                last = i;\n            }\n            else ans[i] = min(ans[i], i - last);\n        }\n        last = 1e6;\n        for(int i = n - 1; i >= 0; i--) {\n            if(s[i] == c) last = i;\n            else ans[i] = min(ans[i], last - i);\n        }\n        return ans;\n    }\n};\n##复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxjo":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086060234","body":"## 思路\nnum与k从右向左逐位相加，遇到进位则加到下一位上\n\n## 代码\n```\nvar addToArrayForm = function(num, k) {\n    let res = [];\n    for(let i = num.length - 1; i >= 0; i--){\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if(sum >= 10){\n            sum -= 10;\n            k += 1;\n        }\n        res.push(sum);\n    }\n    //解决k位数大于数组长度\n    while(k > 0){\n        res.push(k % 10);\n        k = Math.floor(k / 10);\n    }\n    res.reverse();\n    return res;\n};\n```\n## 复杂度分析\n时间复杂度： O(max(num.length, lgk))  \n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086652531","body":"## 思路\n\n使用不定长滑动窗口，边界字符为c，left和right维护窗口`\n\n## 代码\n```\nvar shortestToChar = function(s, c) {\n    let res = [];\n    let left = -Infinity;\n    let right = s.indexOf(c);\n    for(let i = 0; i < s.length; i++){\n        res.push(Math.min(Math.abs(i - left), Math.abs(i -right)));\n        if(i === right){\n            left = right;\n            right = s.indexOf(c, right + 1);\n        }\n    }\n    return res;\n};\n```\n\n## 复杂度分析\n\n\n时间复杂度:O(n)\n空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086886549","body":"## 思路\n使用数组，并用原生的push、pop方式实现\n\n## 代码\n\n```\n/**\n * @param {number} maxSize\n */\n var CustomStack = function(maxSize) {\n    this.maxSize = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stack.length < this.maxSize){\n        this.stack.push(x);\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    return this.stack.length > 0 ? this.stack.pop() : -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(let i = 0; i < this.stack.length; i++){\n        if(i < k){\n            this.stack[i] += val;\n        }\n    }\n};\n```\n## 复杂度分析\n时间复杂度： push(): O(1); pop():O(1); increment:O(n)  \n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ha0cheng":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086068703","body":"思路：\r\n实现数组形式的加法，逐位相加，保存进位\r\n\r\n代码：\r\n\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        Next= 0\r\n        p = len(num)- 1\r\n        while p>=0:\r\n            x = num[p]+k%10+Next\r\n            num[p] = x%10\r\n            Next = x//10\r\n\r\n            k//=10\r\n            p-=1\r\n            if k==0 and Next ==0:\r\n                break\r\n\r\n        while k>0 or Next>0:\r\n            x = k%10+Next\r\n            num.insert(0,x%10)\r\n            Next = x//10\r\n            k//=10\r\n        return num\r\n```\r\n\r\n\r\n\r\n复杂度分析：\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086159354","body":"思路：\r\n遍历两遍，第一遍确定字符的位置，第二遍确定距离每个字符位置最近的字符区间，输出结果\r\n\r\n代码：\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        P = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n              P.append(i)\r\n        r = []\r\n        left = 0\r\n        for i in range(len(P)):\r\n            if i==len(P)-1:\r\n                right = len(s)-1\r\n            else:\r\n                right = (P[i]+P[i+1]-1)//2\r\n            j = P[i] - left \r\n            while j>0:\r\n                r.append(j)\r\n                j-=1\r\n            while j<=right-P[i]:\r\n                r.append(j)\r\n                j+=1\r\n        \r\n            left = right+1\r\n        \r\n        return r\r\n```\r\n时间复杂度：需要遍历两遍，每次均是原字符数组的长度，所以复杂度为O(N)\r\n空间复杂度：需要一个空间来存储字符位置，最坏情况下是N，复杂度为O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086886712","body":"思路：\r\n\r\n入栈和出栈都是基础操作，主要要实现的是第三个功能，栈底前k个元素增加值，要访问栈底，想到使用数组，最开始的思路是循环增加前k个值，复杂度是O(k)，看了参考答案，如果用数组add来保存每个位置的增加量，并且在pop的过程中传递倒数第二个值，便可实现增加量的传递，实现复杂度为O(1)的方法\r\n\r\n代码\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.Stack = [] \r\n        self.add = []\r\n        self.maxSize = maxSize\r\n        self.length = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.length < self.maxSize:\r\n            self.Stack.append(x)\r\n            self.add.append(0)\r\n            self.length +=1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.length == 0:\r\n            return -1\r\n        else:\r\n            if self.length>1:\r\n                self.add[self.length-2] += self.add[self.length-1]\r\n            self.length-=1\r\n            return self.Stack.pop()+self.add.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        idx = min(k-1,self.length-1)\r\n        if idx>=0:\r\n            self.add[idx] += val\r\n```\r\n\r\n复杂度分析：\r\n时间复杂度：入栈，出栈和增加值的复杂度都是O(1)\r\n空间复杂度：设当前栈长度是cnt，那么需要额外存储的add数据需要空间是O(cnt)，复杂度是O(cnt)，最坏情况下复杂度是O(maxSiz)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joewx21":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086071168","body":"### 思路\n\n将k加到num的低位，大于10就取余留下个位，整除取出个位得到进位，每位循环直到最高位并且 k 为0或者i<0。如果 i 小于0，数字长度加一，再循环上过程。\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int i = num.size() - 1;\n        while(k > 0){\n            num[i] += k;\n            k = num[i] / 10;\n            num[i--] %= 10;\n            if(i < 0 && k > 0){\n                num.insert(num.begin(), 0);\n                i = 0;\n            }\n        }\n        return num;\n    }\n};\n```\n\n**复杂度分析**\n\\- 时间复杂度：O(n)\n\\- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086663863","body":"### 思路\n\n先把s中所有等于c的元素的下标值存入到数组sc中，然后利用双重循环遍历s，比较s中各个下标值与sc中元素值的大小，将当前下标值与sc[j]的差的绝对值最小值存入scret中\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> sc; // 与c相同的值得索引\n        vector<int> scret; // 距离结果\n        for(int i =0; i<s.size(); i++){\n            if(s[i] == c){\n                sc.push_back(i);\n            }\n        }\n        if(sc.size() == 1){\n            for(int i = 0; i < s.size(); i++){\n                scret.push_back(abs(i-sc[0]));\n            }\n        }\n        for (int i = 0; i<s.size(); i++){\n            for(int j = 0; j<sc.size()-1; j++){\n                if(i<=sc[j]){\n                    scret.push_back(abs(sc[j]-i));\n                    break;\n                }\n                if(i>sc[j]&&i<=sc[j+1]){\n                    scret.push_back(min(abs(i-sc[j]), abs(i-sc[j+1])));\n                    break;\n                }\n                if(i>sc[sc.size()-1]){\n                    scret.push_back(abs(i-sc[sc.size()-1]));\n                    break;\n                }\n            }\n        }\n        return scret;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086858315","body":"### 思路\n\n这里使用数组来进行栈的模拟，方便执行inc(int k, int val)操作\n\n### 代码\n\n```cpp\nclass CustomStack {\npublic:\n    int maxSize;\n    vector<int> stack;\n    CustomStack(int maxSize) {\n        this->maxSize = maxSize;\n    }\n    \n    void push(int x) {\n        if(stack.empty()||stack.size()<maxSize){\n            stack.push_back(x);\n            return ;\n        }\n    }\n    \n    int pop() {\n        if(stack.empty()){\n            return -1;\n        }\n        int val = stack.back();\n        stack.pop_back();\n        return val;\n    }\n    \n    void increment(int k, int val) {\n        for(int i = 0; i < k&&i<stack.size(); i++){\n            stack[i] += val;\n        }\n        return ;\n    }\n};\n```\n\n**时间复杂度**：O(min(k, stak.size()))\n\n**空间复杂度**：O(maxsize)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zetavi":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086072595","body":"## 思路\n\n从Num数组的**右侧开始往左遍历**数组,将遍历到的数**直接与K相加**,相加的结果取**最低位**插入到List输出链表的**头部**\n\n## 语言\n\nJava\n\n## 代码\n\n```java\npublic class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new LinkedList<>();\n        int i;\n        for (i = num.length - 1; k > 0 || i >= 0; k /= 10, i--) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            list.add(0, k % 10);\n        }\n        return list;\n    }\n}\n```\n\n## 复杂度分析\n\n- 时间复杂度:\t$O(max(num.length(),logK))$\n\n​\t\t\t\t\t\t\t时间复杂度跟输入Num的长度和K的位数有关,又因为List的插入时间复杂度为$O(1)$所以插入可以忽略不计.\n\n- 额外空间复杂度: $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086667405","body":"## 思路(法一)\n\n利用库函数**indexOf(c)**来找到**后一个出现字母的位置**,比较前一个出现和后一个出现的距离,取最小值\n\n## 语言\n\nJava\n\n## 代码\n\n```java\npublic class Solution {\n   public int[] shortestToChar_1(String s, char c) {\n        int[] ans = new int[s.length()];\n        int fir = -1, sec = Integer.MAX_VALUE / 2, cur = 0;\n        fir = s.indexOf(c);\n        for (int i = 0; i < ans.length; i++) {\n            if (fir > i) {\n                ans[i] = fir - i;\n            } else if (fir == i) {\n                ans[i] = 0;\n                sec = s.indexOf(c, fir + 1) == -1 ? Integer.MAX_VALUE / 2 : s.indexOf(c, fir + 1);\n            } else if (i < sec) {\n                ans[i] = Math.min(Math.abs(fir - i), Math.abs(sec - i));\n            } else {\n                ans[i] = 0;\n                fir = sec;\n                sec = s.indexOf(c, fir + 1) == -1 ? Integer.MAX_VALUE / 2 : s.indexOf(c, fir + 1);\n            }\n        }\n        return ans;\n    }\n}\n```\n\n## 复杂度分析\n\n- 时间复杂度:\t$O(N^2)$\n\n​\t\t\t\t\t\t\t因为String类中indexOf()方法是暴力匹配方法时间复杂度为$O(N*M)$,而我们这里M=1,所以综上总的时间复杂度为$O(N^2)$\n\n- 额外空间复杂度: $O(N)$\n\n## 思路(法二)\n\n对于每个字符 S[i]，通过**顺序遍历和逆序遍历两次**,试图找出距离向左和向右下一个字符 C 的距离。答案就是这两个值的较小值。\n\n## 语言\n\nJava\n\n## 代码\n\n```java\npublic class Solution {\n    public int[] shortestToChar_2(String S, char C) {\n        int N = S.length();\n        int[] ans = new int[N];\n        //假设上一个出现的位置为Integer.MIN_VALUE / 2\n        int prev = Integer.MIN_VALUE / 2;\n\n        //记录s[i]与前一个字符c的距离\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = i - prev;\n        }\n\n        //假设最后一个出现的位置为Integer.MAX_VALUE / 2\n        prev = Integer.MAX_VALUE / 2;\n\n        //计算s[i]与后一个字符c的距离,与原来的距离比较取最小值\n        for (int i = N - 1; i >= 0; --i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n\n        return ans;\n    }\n}\n```\n\n## 复杂度分析\n\n- 时间复杂度:\t$O(N)$\n\n- 额外空间复杂度: $O(N)$\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086885823","body":"## 思路\n\n同样用数组来模拟实现栈,但是对increment()方法进行优化\n\n再用一个辅助数组add来记录increase的值, 利用==差分思想==, 在每次pop()时把add数组和原数组arr==相加输出==\n\n## 语言\n\njava\n\n## 代码\n\n```java\nclass CustomStack_PrefixSum {\n    private int[] arr;\n    private int[] add;\n    private int top;\n\n    public CustomStack_PrefixSum(int maxSize) {\n        arr=new int[maxSize];\n        add=new int[maxSize];\n        top=-1;\n    }\n\n    public void push(int x) {\n        if (top < arr.length-1 ) {\n            arr[++top]=x;\n        }\n    }\n\n    public int pop() {\n        if (top >= 0) {\n            int res=arr[top]+add[top];\n            if (top>=1){\n                add[top-1]+=add[top];\n            }\n            add[top--]=0;\n            return res;\n        }return -1;\n    }\n\n    public void increment(int k, int val) {\n        int end= Math.min(k-1, top);\n        if (end>=0){\n            add[end]+=val;\n        }\n    }\n}\n```\n\n## 复杂度分析\n\n- 时间复杂度:CustomStack(),push(),pop(), increment()时间复杂度为都为$O(1)$\n- 空间复杂度:$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jessie725":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086074254","body":"### Idea\r\nLet carry = k; Add k with each digit of num form right to left, \r\nput units digit into res, update carry \r\nreverse res\r\n\r\n### Code\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int i = num.length - 1;\r\n        int carry = k;\r\n        List<Integer> res = new ArrayList<>();\r\n        \r\n        while (i >= 0 || carry > 0) {\r\n            if (i >= 0) {\r\n                carry += num[i];\r\n            }\r\n            res.add(carry % 10);\r\n            carry /= 10;\r\n            i--;\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### Complexity\r\nTime: O(N)  N refers to the length of num. (reach each element once) \r\nSpace: O(1)  (no extra space except result)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086670553","body":"## Idea\r\nTwo-pass: \r\n1st left to right, find shortest distant to character on left.\r\n2nd right to left, find shortest distant to character on right, and pick shorter one.\r\n\r\n## Code\r\n\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int position = -n;\r\n        int[] res = new int[n];\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) {\r\n                position = i;   \r\n            }\r\n            res[i] = i - position;\r\n            System.out.print(res[i]);\r\n        }\r\n        System.out.print(\" \");\r\n        for (int i = position - 1; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                position = i;   \r\n            }\r\n            res[i] = Math.min(res[i], position - i);\r\n            System.out.print(res[i]);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\nTime: O(N)  N refers to the length of string. Traverse string twice\r\nSpace: O(N) extra space for output","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"raingolee":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086081768","body":"### 思路\n从低位开始（从右到左），两个位置的数相加，如果超过10，则增加一个标记位，下一个位置的数字相加之后加一，因为是不等长的，所以存在相同位置的数字为空时候则设置为0，切不需要设置标记位。\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"all-sunday":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086082274","body":"### 思路\n遍历数组，把k加到最后一个元素num[n]，把num[n]对10取余的余数加到结果res数组，对10取整后的结果重新赋给k；\n\n循环上一步操作倒数第二个元素，直至数组遍历完或k值不大于0，则把剩下的数组元素或k加到res数组;\n\n最后反转数组即可。\n\n\n### 代码\n\n\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        while(true){\n                if(n>0 && k>0){\n                    num[--n] += k;\n                    res.add(num[n] % 10);\n                    k = num[n] / 10;\n                }else if(n>0){\n                    res.add(num[--n]);\n                    \n                }else if(k>0){\n                    res.add(k%10);\n                    k /= 10;\n                    \n                }else{\n                    break;\n                }    \n\n            }\n            Collections.reverse(res);\n            return res;\n        }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(max(n,k))，其中 n 为数组长度，k为k的位数。\n- 空间复杂度：O(max(n,k))，开辟了新数组\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086641183","body":"### 思路\r\n先遍历一次字符串s，获得字符串s种所有c的小标，并存在cIndexs数组；\r\n\r\n双层循环，外层遍历字符串s，内层遍历cIndexs数组，即将字符串s种每一个字字符的小标与所有的字符c小标分别求绝对值，所得值中最小的即为所求目标，存入结果answer数组。\r\n\r\n暂没有其他思路，就暴力求解了。😥\r\n### 代码\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] answer = new int[n];\r\n        int[] cIndexs = new int[n];\r\n        int cNum = 0;\r\n        for(int i = 0; i < s.length(); i++){\r\n            if(s.charAt(i) == c){\r\n                cIndexs[cNum++] = i;\r\n            }\r\n        }\r\n\r\n        for(int i = 0; i < s.length(); i++){\r\n            int minDistance = n;\r\n            for(int j = 0; j < cNum; j++){\r\n                int distance = Math.abs(i - cIndexs[j]);\r\n                if(distance < minDistance){\r\n                    minDistance = distance;\r\n                }\r\n            }\r\n            answer[i] = minDistance;\r\n        }\r\n\r\n        return answer;\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N^2)，双重循环，其中N为字符串s的长度。\r\n- 空间复杂度：O(N)，使用了额外的大小为字符串长度N的数组。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086893650","body":"### 思路\n用数组模拟栈的操作，top记录栈顶的位置。\n### 代码\n```\nclass CustomStack {\n    int[] stack;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if(top < stack.length - 1){\n            stack[++top] = x;\n        }\n    }\n    \n    public int pop() {\n        if(top > -1){\n            int res = stack[top];\n            stack[top--] = 0;\n            return res;\n        }else{\n            return -1;\n        }\n    }\n    \n    public void increment(int k, int val) {\n        if(top < k - 1){\n            k = top + 1;\n        }\n        for(int i = 0; i < k; i++){\n            stack[i] += val;\n        }\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：初始化、push、pop操作均为O(1)，inc操作为O(k)。\n- 空间复杂度：O(maxSize)，使用了额外长度为maxSize的数组stack。\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brainlds":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086082862","body":"public List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> result = new ArrayList<>();\n    int cur = k;\n    int i = num.length - 1;\n    while (i >= 0 || cur > 0) {\n        if (i >= 0) {\n            cur += num[i];\n        }\n        result.add(cur % 10);\n        cur /= 10;\n        i--;\n    }\n    Collections.reverse(result);\n    return result;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086663613","body":"class Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] res = new int[len];\n        int pre = Integer.MIN_VALUE / 2;\n        for (int i = 0; i < len; i++) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            res[i] = i - pre;\n        }\n        pre = Integer.MAX_VALUE / 2;\n        for (int i = len - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            res[i] = Math.min(res[i], pre - i);\n        }\n        return res;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jinjin680":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086083587","body":"## 思路\n\n- 直接把k加到A中\n\n```C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& A, int K) {\n        int i = A.size()-1;\n        while(K > 0){\n            A[i] += K;\n            K = A[i] / 10;\n            A[i--] %= 10;\n            \n            if(i < 0 && K > 0){\n                A.insert(A.begin(),0);\n                i = 0;\n            }\n        }\n        \n        return A;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hulichao":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086084672","body":"思路\n遍历数组，把k加到最后一个元素num[n]，把num[n]对10取余的余数加到结果res数组，对10取整后的结果重新赋给k；\n\n循环上一步操作倒数第二个元素，直至数组遍历完或k值不大于0，则把剩下的数组元素或k加到res数组;\n\n最后反转数组即可。\n\n代码\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        while(true){\n                if(n>0 && k>0){\n                    num[--n] += k;\n                    res.add(num[n] % 10);\n                    k = num[n] / 10;\n                }else if(n>0){\n                    res.add(num[--n]);\n                    \n                }else if(k>0){\n                    res.add(k%10);\n                    k /= 10;\n                    \n                }else{\n                    break;\n                }    \n\n            }\n            Collections.reverse(res);\n            return res;\n        }\n}\n复杂度分析\n\n时间复杂度：O(max(n,k))，其中 n 为数组长度，k为k的位数。\n空间复杂度：O(max(n,k))，开辟了新数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086667513","body":"### 思路\n关键点在于加一个变量，用来指出距离当前遍历到的字符的最左的目标字符的下标，和距离当前遍历到的字符的最右的目标字符的下标。\n\n### 代码\n\n\n```java\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int[] ans = new int[S.length()];\n        int pre = -100001;\n        //从左到右\n        for (int i = 0; i < S.length(); i++) {\n            if (S.charAt(i) == C)\n                pre = i;\n            ans[i] = i - pre;\n        }\n\n        pre = 100001;\n        for (int i = S.length() - 1; i >=0 ; i--) {\n            if (S.charAt(i) == C)\n                pre = i;\n            ans[i] = Math.min(ans[i], pre -i);\n        }\n\n        return ans;\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086896250","body":"### 思路\n用个数组模拟栈就好了。\n\n### 代码\n\n\n```java\nclass CustomStack {\n    int[] stack;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if(top<stack.length-1){\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if(top==-1){\n            return -1;\n        }else{\n            return stack[top--];\n        }\n    }\n    \n    public void increment(int k, int val) {\n        for(int i=0;i<k;i++){\n            if(i<=top){\n                stack[i] += val;\n            }else{\n                break;\n            }\n        }\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shin-guid":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086085454","body":"## 思路\r\n将A、K格式化为数组，反转，从低位开始相加，一直到最高位，注意处理进位\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    const numArr = num.reverse();\r\n    const kArr = String(k).split('').reverse().map(Number);\r\n\r\n    let result = [];\r\n    let i = 0;\r\n    let curr = 0;\r\n    let carry = 0;\r\n    while(i < numArr.length || i < kArr.length || carry > 0) {\r\n        sum = (numArr[i] || 0) + (kArr[i] || 0) + carry;\r\n        curr = sum % 10;\r\n        carry = parseInt(sum / 10);\r\n        result[i] = curr;\r\n        i++;\r\n    }\r\n    return result.reverse();\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度O(N)\r\n- 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086661461","body":"## 思路\n1. 遍历字符串，找出所有c的索引，成为索引数组\n2. 遍历字符串，每个字符串遍历索引数组求绝对值，取最小\n\n## code\n\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    // 转换为数组\n    // 遍历找出所有c的索引\n    // 遍历数组，比较距离，取最小值\n    const strArray = s.split('');\n    let cIndexArray = [];\n\n    strArray.forEach((s, i) => {\n        if (s === c) {\n            cIndexArray.push(i);\n        }\n    })\n    let result = [];\n    strArray.forEach((s, i) => {\n        let diff = Infinity;\n        cIndexArray.forEach((cIndex) => {\n            diff = Math.min(diff, Math.abs(cIndex - i));\n        })\n\n        result.push(diff);\n    })\n\n    return result;\n};\n\n## 复杂度\n\n- 时间复杂度：O(n2)\n- 空间复杂度：O(n)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aconcert":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086101381","body":"var addToArrayForm = function (num, k) {\r\n    let k_array = [];\r\n    let length_cal = 0;\r\n    let cal_array = [];\r\n    while (k > 0) {\r\n        let yu = k % 10;\r\n        k_array.unshift(yu);\r\n        k = (k - yu) / 10;\r\n    }\r\n\r\n    if (k_array.length < num.length) {\r\n        length_cal = num.length;\r\n        const len = k_array.length\r\n        for (let index = 0; index < length_cal - len; index++) {\r\n            k_array.unshift(0);\r\n        }\r\n    } else {\r\n        length_cal = k_array.length;\r\n        const len = num.length\r\n        for (let index = 0; index < length_cal - len; index++) {\r\n            num.unshift(0);\r\n        }\r\n    }\r\n\r\n    for (let index = 0; index < length_cal; index++) {\r\n        const m = num.pop();\r\n        const n = k_array.pop();\r\n        if (m + n >= 10) {\r\n            cal_array.unshift((m + n) % 10);\r\n            k_array[k_array.length - 1] = k_array[k_array.length - 1] + 1;\r\n            if (index === length_cal - 1) {\r\n                cal_array.unshift(1);\r\n            }\r\n        } else {\r\n            cal_array.unshift(m + n)\r\n        }\r\n    }\r\n\r\n    return cal_array;\r\n};\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086639124","body":"\n\n```JavaScript\nvar shortestToChar = function (s, c) {\n    let arr = s.split('');\n    for (let iterator in arr) {\n        if (arr[iterator] == c) {\n            arr[iterator] = 0\n        } else {\n            arr[iterator] = null;\n        }\n    }\n\n    for (let i = 0; i < arr.length; i++) {\n        for (let j = 0; j < arr.length; j++) {\n            if (arr[j] === i) {\n                if (j > 0) {\n                    if (arr[j - 1] == null || arr[j - 1] > i + 1) {\n                        arr[j - 1] = i + 1;\n                    }\n                }\n                if (j < arr.length - 1) {\n                    if (arr[j + 1] == null || arr[j + 1] > i + 1) {\n                        arr[j + 1] = i + 1;\n                    }\n                }\n            }\n        }\n    }\n    return arr;\n};\n```\n\n**复杂度分析**\n\\- 时间复杂度：O(N^2)\n\\- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086896296","body":"\n\n```JavaScript\nvar CustomStack = function (maxSize) {\n\n    this.stack = [];\n    this.maxSize = maxSize;\n\n    //for loop create array, value default null, size = maxSize\n    for (let index = 0; index < maxSize; index++) {\n        this.stack[index] = null;\n    }\n\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n\n    // stack's last one is not null, do not push\n    if (this.stack[this.maxSize - 1] !== null) {\n        return;\n    }\n\n    // for loop find the first index is null, push parameter at index\n    const indexCanPush = this.stack.findIndex(element => element === null);\n    this.stack[indexCanPush] = x;\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n    // find the first one (called lastOne) is not null from the tail of stack\n    const { lastOne, lastOneIndex } = this.lastOne();\n\n    // the index value of lastOne set to null, return last one\n    if (lastOne !== -1) {\n        this.stack[lastOneIndex] = null\n    }\n\n    return lastOne;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n\n    // from tail to head, find the first one is not null\n    const { lastOne, lastOneIndex } = this.lastOne();\n\n    for (let index = lastOneIndex; index >= 0 && k > 0; index--, k--) {\n        this.stack[lastOneIndex] += val;\n    }\n};\n\nCustomStack.prototype.lastOne = function () {\n\n    // from tail to head, find the first one is not null\n    let lastOne = -1;\n    let lastOneIndex = -1;\n    for (let tail = this.maxSize - 1; tail >= 0; tail--) {\n        if (this.stack[tail] !== null) {\n            lastOne = this.stack[tail];\n            lastOneIndex = tail;\n            return { lastOne, lastOneIndex };\n        }\n    }\n\n    return { lastOne, lastOneIndex };\n\n};\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nancychien":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086268399","body":"思路：\r\n1. 找出目標 index 位置並 save to a target list\r\n2. loop through 原來的字串和target list 並計算最小距離\r\n`\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        target = []\r\n        output = []\r\n\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                target.append(i)\r\n\r\n        for i in range(len(s)):\r\n            output.append(min(abs(i-x) for x in target))\r\n\r\n        return output\r\n`\r\n\r\nTime complexity: O(n^2)\r\nSpace complexity:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086768346","body":"思路：\r\n用 list 去模擬出 stack 的操作\r\n`\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize  = maxSize\r\n        self.cur_size = 0\r\n        self.stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cur_size == self.maxSize: \r\n            return -1\r\n        self.stack.append(x)\r\n        self.cur_size += 1\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack: \r\n            return -1\r\n        res = self.stack.pop()\r\n        self.cur_size -= 1\r\n        return res\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(self.cur_size, k)): \r\n            self.stack[i] += val\r\n`\r\nTime Complexity:\r\n- push: O(1)\r\n- pop: O(1)\r\n- increment: O(N)\r\nSpace Complexity:\r\n- push: O(1)\r\n- pop: O(1)\r\n- increment: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lannyx":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086420045","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()]; //create new array to store answer\r\n        int dummy = Integer.MIN_VALUE/2; // initiate a variable as the min value to store \r\n\r\n        for(int i = 0; i < s.length(); i++){\r\n            if(s.charAt(i) == c) dummy = i;\r\n            res[i] = i - dummy;\r\n        }\r\n\r\n        dummy = Integer.MAX_VALUE;\r\n        for(int i = s.length() - 1; i >= 0; i--){\r\n            if(s.charAt(i) == c) dummy = i;\r\n            res[i] = Math.min(res[i], dummy - i);\r\n        }\r\n        return res;\r\n\r\n    }\r\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pureryudo":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086506715","body":"### 思路\n\n进行两次遍历\n\n使用prev记录上一次出现的c的位置，初始值设为极小的负数。\n\n第一次从左到右遍历，记录当前位置i到prev的绝对值。\n\n第二次从右到左遍历，记录当前位置i到prev的绝对值，并与第一次遍历的结果取min存入结果数组，\n\n### 代码\n\n```java\npublic int[] shortestToChar(String s, char c) {\n    int[] result = new int[s.length()];\n    char[] chars = s.toCharArray();\n    /*记录当前遍历中上一个c出现的位置\n        初始值设置为极小的负数用于在比较时获得正确的值*/\n    int prev = Integer.MIN_VALUE/2;\n    /*第一次遍历 从左到右 记录与上一个c的距离*/\n    for (int i = 0; i < chars.length; i++){\n        //还没有出现过c\n        if (chars[i] == c){\n            prev = i;\n        }\n        result[i] = Math.abs(i-prev);\n    }\n    /*第二次遍历 从右到左 记录与上一个c的距离*/\n    prev = -1;\n    for (int i = chars.length-1; i >= 0; i--){\n        if (chars[i] == c){\n            prev = i;\n        }\n        result[i] = Math.min(result[i],Math.abs(prev-i));\n    }\n    return result;\n}\n```\n\n### 复杂度分析\n\n时间复杂度：O(N) N为数组长度\n\n额外空间复杂度：O(N) 新建了一个长度为N的数组用于存放结果","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaoliz":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086560188","body":"思路:   先查遍历找出C值对应的下标索引存储includesIndex中， 在进行一次循环 当前值等于C那么距离直接为0，内部进行二次循环 includesIndex arr 进行绝对值计算 \n\n\nvar shortestToChar = function(s, c) {\n\n    let includesIndex = [];\n    for(let i = 0; i < s.length; i++) {\n        if(s[i] === c) {\n            includesIndex.push(i)\n        }\n    }\n\n    var res = Array(s.length).fill(0);\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === c) {\n            res[i] = 0;\n            continue;\n        }\n\n        for(let val of includesIndex ) {\n            const dist = Math.abs(val - i)\n            \n            if (dist >= res[i]) break;\n            res[i] = dist;\n        }\n    }\n    return res;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086754886","body":"### 思路\r\n数组实现栈\r\n\r\n### 代码\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.number = maxSize\r\n    this.stack = []\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.number > this.stack.length) {\r\n        this.stack.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if(!this.stack.length) return -1;\r\n    return this.stack.pop();\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for( let i = 0; i < this.stack.length; i++) {\r\n        if (i < k) {\r\n            this.stack[i] += val\r\n        }   \r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度： push:O(1)、pop：O(1)  O(N)  N:  是k，需增量元素个数\r\n- 空间复杂度  O(N)   N: maxSize\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wenliangchen":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086565399","body":"## 思路：\r\n先从左边遍历，每次遍历中 先找到对应的目标的下标，在过程中利用i的下标去减去最小值的二分之一，（目的是在没找到的情况下，通过减去最小值留下一个最大数值，最小值为负数 i - -则变为加法）。之后进行右边遍历，同理，在过程中进行大小的比较。对比两次遍历最小的值是哪个，这样即可得到正确答案。\r\n\r\n用最小值的目的是为了避免溢出\r\n\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int len = S.length();\r\n        int[] ans = new int[len];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        for (int i = 0; i < len; i++) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = len-1; i >= 0; i--) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\n - 时间复杂度：O(N)\r\n - 空间复杂度：O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086770200","body":"## 思路\r\n利用数组进行数据的存储，在push和pop时判断情况，并记录下标和最大容量\r\n\r\n## 代码\r\n\r\n```\r\npublic class CustomStack {\r\n    int[] stack;\r\n    int top;\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top =-1;\r\n    }\r\n    public void Push(int x) {\r\n        if(top!=stack.Length-1)\r\n        {\r\n            top++;\r\n            stack[top]=x;\r\n        }\r\n    }\r\n    public int Pop() {\r\n        if(top==-1)\r\n        {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top + 1];\r\n    }\r\n    public void Increment(int k, int val) {\r\n        int limit = Math.Min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i)\r\n        {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n## 复杂度\r\n- 时间复杂度：push 和 pop 操作的时间复杂度为 O(1)，其余为O(N)\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"victorhuang99":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086566581","body":"4.2算法题：\nIdea：\n1.找到指定字符在目标字符串的下标并放进一个数组记录。\n2.循环比较字符串中每个字符距离和指定字符的距离，记录下较小的一个，放入另一个数组。\n\nCode：\n\nvar shortestToChar = function(s, c) {\n    var nearstXb = [];\n    var absDis = [];\n\n    for(var i=0;i<s.length;i++){\n      if(s[i] == c){\n      nearstXb.push(i);}    \n    };\n\n    for(var i=0;i<s.length;i++){\n        var min2 = s.length;\n        for(var j=0;j<nearstXb.length;j++){\n            var min1 = Math.abs(i-nearstXb[j])\n            if(min1<min2){\n               min2 = min1;}\n        }\n        absDis.push(min2);\n    }\n\n    return absDis;\n\n}\n \n时间复杂度：O(N^2)\n空间复杂度：（1）\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzz607":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086582373","body":"### 思路\n\n第一想法是以当前字符为中心，然后向左右两边搜索，搜索到的第一个C即可得到当前字符到C的最小距离。\n但是这样的算法复杂度是O(N^2)\n\n第二想法是首先将C在S中的索引全部找出来，这样就可以用当前字符的索引直接减到C的索引，从而得到一个最小值\n这样的算法复杂度就是O(N)。下面的代码是这个想法的实现。\n\n后来又看了一下官方的题解，发现是遍历正、反二次就可以解决了。果然是我太菜了。。。。。。\n\n### 代码\n\n\n```Go\nfunc shortestToChar(s string, c byte) []int {\n\tvar cIdx []int\n\tvar ret []int\n\n\tinitCIdx := func() {\n\t\tfor i := 0; i < len(s); i++ {\n\t\t\tif s[i] == c {\n\t\t\t\tcIdx = append(cIdx, i)\n\t\t\t}\n\t\t}\n\t}\n\n\tgetDistance := func(idx int) int {\n\t\tmin := math.MaxInt32\n\t\tfor _, ii := range cIdx {\n\t\t\ttmp := int(math.Abs(float64(ii - idx)))\n\t\t\tif tmp < min {\n\t\t\t\tmin = tmp\n\t\t\t}\n\t\t}\n\t\treturn min\n\t}\n\n\tinitCIdx()\n\tfor i := 0; i < len(s); i++ {\n\t\tret = append(ret, getDistance(i))\n\t}\n\n\treturn ret\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)，最坏时，C和S的长度一样","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086797464","body":"### 思路\n粗看还蛮简单的，直接使用数组来模拟，push和pop操作都在数组尾操作，时间上都是O(1)，inc操作是O(k)\n按此实现并提交，发现只击败40%，看来还有改进空间。\n\npush和pop都已经是O(1)了，那就只有inc可以改进。一时想不出来，查看是解后，发现只记录增量及位置，\n直到需要返回的栈顶元素的时候才计算真实的值，这样每个pop操作也只计算一次，不影响pop的执行效率。\n按此方法，inc的执行效率也改进为O(1)。\n\n### 代码\n\n\n```Go\ntype CustomStack struct {\n    data []int\n    add []int\n    idx int\n}\n\n\nfunc Constructor(maxSize int) CustomStack {\n    return CustomStack{data: make([]int, maxSize), add: make([]int, maxSize), idx: 0}\n}\n\n\nfunc (this *CustomStack) Push(x int)  {\n    if this.hasSpace() {\n        this.data[this.idx] = x\n        this.idx++\n    }\n}\n\n\nfunc (this *CustomStack) Pop() int {\n    if !this.hasElement() {\n        return -1\n    }\n    \n    this.idx--\n    element := this.data[this.idx] + this.add[this.idx]\n\n    if this.idx > 0 {\n        this.add[this.idx - 1] += this.add[this.idx]\n    }\n    this.add[this.idx] = 0\n\n    return element\n}\n\n\nfunc (this *CustomStack) Increment(k int, val int)  {\n    // for i := 0; i < this.idx && i < k; i++ {\n        // this.data[i] += val\n    // }\n    if !this.hasElement() {\n        return\n    }\n\n    if k >= this.idx {\n        this.add[this.idx - 1] += val\n    } else {\n        this.add[k - 1] += val\n    }\n}\n\nfunc (this *CustomStack) hasSpace() bool {\n    return this.idx < cap(this.data)\n}\n\nfunc (this *CustomStack) hasElement() bool {\n    return this.idx > 0\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(N), N为栈最大空间。因为需要一个额外的辅助数组add","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"winrunwang":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086593212","body":"思路:\n遍历一次，用2个临时变量存储指针信息。中间第二个for循环调整距离问题\npublic int[] shortestToChar(String s, char c) {\n        int first = -1;\n        int temp = -1;\n        int n  = s.length();\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            char t = s.charAt(i);\n            if(t == c){\n                res[i] = 0;\n                if(first == -1){\n                    first = i;\n                }\n                if(temp!= -1){\n                    for (int j = temp; j < i; j++) {\n                        res[j] = Math.min(i-j,res[j]);\n                    }\n                }\n                temp = i;\n            }\n            if(first != -1){\n                res[i] = i-temp;\n            }\n        }\n        for (int i = 0; i < first; i++) {\n            res[i] = first - i;\n        }\n        return res;\n    }\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"carterrr":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086601300","body":"class Solution {\n    public int[] shortestToChar(String s, char c) {\n            char[] array = s.toCharArray();\n            int len = s.length();\n            int[] res = new int[len];\n            Arrays.fill(res, len);\n            int idx_c = -1;\n            for(int i = 0; i < len ; i++) {\n                if(array[i] == c) {\n                    idx_c = i;\n                    res[i] = 0;\n                    continue;\n                }\n                if(idx_c != -1) {\n                    res[i] = i - idx_c;\n                }\n            }\n            for(int i = len - 1; i >= 0 ; i--) {\n                if(array[i] == c) {\n                    idx_c = i;\n                    continue;\n                }\n                if(idx_c > i) {\n                    res[i] = Math.min(res[i], idx_c - i);\n                }\n                \n            }\n            return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086802767","body":"class CustomStack {\n\n    int[] data;\n    int[] add;\n    int maxSize;\n    int curSize;\n\n    public CustomStack(int maxSize) {\n        data = new int[maxSize];\n        add = new int[maxSize];\n        this.maxSize = maxSize;\n        this.curSize = 0;\n    }\n    \n    public void push(int x) {\n        if(curSize == maxSize){\n            return;\n        }\n        data[curSize++] = x;\n    }\n    \n    public int pop() {\n        if(curSize == 0) return -1;\n        int res = data[curSize - 1] + add[curSize - 1];\n        if(curSize > 1) {\n            add[curSize - 2] += add[curSize - 1]; \n        }\n        add[curSize - 1] = 0;\n        curSize--;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        if(curSize == 0) return;\n        add[Math.min(k, curSize) - 1] += val;\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ethanwlx":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086617041","body":"思路：先从左往右，找每个index离左边最近的距离，再从右边往左，最后取左右的最小值。\n时间：O(n)\n空间：O(n)\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans_l = [float(inf)] * len(s)\n        ans_r = [float(inf)] * len(s)\n        ans = [0] * len(s)\n       \n        for i in range(len(s)):\n            if i == 0:\n                if s[i] == c:\n                    ans_l[i] = 0   \n            else:\n                ans_l[i] = ans_l[i-1] + 1 if s[i] != c else 0\n\n        for i in range(len(s) - 1, -1, -1):\n            if i == len(s) - 1:\n                if s[i] == c:\n                    ans_r[i] = 0          \n                ans[i] = min(ans_l[i], ans_r[i])\n            else:\n                ans_r[i] = ans_r[i+1] + 1 if s[i] != c else 0\n                ans[i] = min(ans_l[i], ans_r[i])\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086767347","body":"难点在于用O(1)时间处理增加量，假设我们记录增加量的值，指令分别为（1,20） （2,40） （4，40） （4，60）\n并画出图\n1##\n2####\n3\n4##########\n对于4 增加量就是 100\n对于3也是100\n对于2就是100+40=140\n对于1就是140+20= 160\n对于 i 位置就是上一个位置的值+自己本身的值\n把这张表格记录下来我们就可以做到线性时间得到每一个位置的增加量值\n时间： O（1）\n空间： O(maxsize)\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.addition = []\n        self.maxSize = maxSize\n        self.size = 0\n\n\n    def push(self, x: int) -> None:\n        if self.size < self.maxSize:\n            self.stack.append(x)\n            self.addition.append(0)\n            self.size += 1\n\n\n    def pop(self) -> int:\n        if self.size > 0:\n            if self.size > 1:\n                self.addition[-2] += self.addition[-1]\n            st = self.stack.pop() + self.addition.pop()\n            self.size -= 1\n            return st\n        return -1\n\n\n    def increment(self, k: int, val: int) -> None:\n        if self.size > 0:\n            self.addition[min(k,self.size)-1] += val\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"babbomax98":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086650773","body":"### 思路\n使用双指针，然后遍历字符串\n\n### 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] result=new int[N];\n        int indexNext=S.indexOf(C);//双指针，indexNext表示下一个C的下标， \n        int index=indexNext;//index表示前一个C的坐标\n    // 通过这里的赋值使在只有左边有C字符的时候（此时index = indexNext）的时候\n    //index也在当前字符的右边，否则在左右都有C字符的时候，当前字符必在index和indexNext的中间。\n       for(int i = 0; i < S.length(); i++){\n            if(S.charAt(i) == C){//每当遍历到C就更新index和indexNext\n                result[i] = 0;\n                index = i;\n                indexNext = S.indexOf(C, i+1);\n                //这里如果当前是最后一个C时，此时indexNext为-1，这也保证了上面的情况\n            }else{\n                result[i] = Math.min(Math.abs(index - i), Math.abs(indexNext - i));\n            }\n        }\n       return result;\n    }\n}\n```\n### 复杂度分析\n时间复杂度：O（n）\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086854030","body":"### 思路\n使用栈实现\n### 代码\n```java\nclass CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack=new int[maxSize];\n        top=-1;\n    }\n    \n    public void push(int x) {\n        if(top!=stack.length-1){\n            ++top;\n            stack[top]=x;\n        }\n\n    }\n    \n    public int pop() {\n        if(top==-1)\n            return -1;\n        --top;\n        return stack[top+1];\n\n    }\n    \n    public void increment(int k, int val) {\n        int li=Math.min(k,top+1);\n        for(int i=0;i<li;i++){\n            stack[i]+=val;\n        }\n\n    }\n}\n```\n### 复杂度分析\n时间复杂度：push和pop是0（1）,inc是O(k)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tt-fantastic":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086653492","body":"public int[] shortestDistance(String s, char c) {\n        int[] arr = new int[s.length()];\n        int distance = Integer.MIN_VALUE；\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                distance = i;\n            }\n            arr[i] = i - distance;\n        }\n\n        distance = Integer.MAX_VALUE;\n        for (int j = s.length() - 1; j >= 0; j--) {\n            if (s.charAt(j) == c) {\n                distance = j;\n            }\n            arr[j] = Math.min(arr[j], distance - j);\n        }\n       return arr;","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyh331":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086658067","body":"### **Day2**  思路  \n\n两边都遍历，最后留下较小的值  \n\n### 代码  \n\n```\nc++\nclass Solution \n{\npublic:\n    vector<int> shortestToChar(string s, char c) \n    {\n        vector<int> ans(s.size(), 0);\n        int left = INT_MAX;\n        int right = INT_MAX;\n        for(int i = 0; i < s.size(); i ++) \n        {\n            if (s[i] == c) \n            {\n                left = i;\n            }\n            ans[i] = i - left;\n        }\n        for(int i = s.size() - 1; i >= 0; i --) \n        {\n            if (s[i] == c) \n            {\n                right = i;\n            }\n            ans[i] = min(abs(ans[i]), right - i);\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086862033","body":"### Day3 思路\n考虑用vector(本质为单端动态数组)容器实现。\n1. 构造函数中用m_Maxsize接收传入进来的maxSize。\n2. void push中判断数组元素个数<m_Maxsize？然后_.push_back(x)将x压入堆栈\n3. void pop中用_.empty()判断容器是否为空,不为空时先用**int top=_.back();保留引用，后续返回top**，再进行出栈操作。\n4. increment中for保证i < k && i < _.size()就可以\n### 代码\n```c++\nclass CustomStack {\npublic:\n    vector<int> stack;\n    int m_Maxsize;\n    //构造函数\n    CustomStack(int maxSize) {\n        m_Maxsize=maxSize;\n        //stack.resize(maxSize);\n    }\n    //入栈函数\n    void push(int x) {\n        if(stack.size()<m_Maxsize){\n            stack.push_back(x);\n        }\n    }\n    //出栈函数,弹出栈顶元素，并返回栈顶的值，栈为空时返回-1\n    int pop() {\n        if(stack.empty()){\n            return -1;\n        }\n        else{\n            //要返回的是出栈前的栈顶，所以需要先把栈顶保留引用，用 int top=stack.back();接收一下\n            int top = stack.back();\n            stack.pop_back();\n            return top;\n        }\n\n    }\n    //栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val\n    void increment(int k, int val) {\n        for(int i=0 ; i<k && i<stack.size();i++){\n            stack[i]+=val;\n        }\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度\npush:O(1)\npop:O(1)\nincr:O(k)\n- 空间复杂度\npush:O(1)\npop:O(1)\nincr:O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kennethalgol":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086659398","body":"# 思路\r\n双指针\r\n# 语言\r\njava\r\n\r\n```java\r\npublic int[] shortestToChar(String S, char C) {\r\n        \r\n        int[] res = new int[S.length()];\r\n        int cur = S.indexOf(C), pre = cur;\r\n        for(int i = 0; i < S.length(); i++){\r\n            if(S.charAt(i) == C){//其实就是每当遍历到C就更新cur和pre\r\n                res[i] = 0;\r\n                pre = i;\r\n                cur = S.indexOf(C, i+1);//注意：这里如果当前是最后一个C时，此时cur为-1，这也保证了上面的情况3\r\n\r\n            }else{\r\n                res[i] = Math.min(Math.abs(pre - i), Math.abs(cur - i));//\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n```\r\n\r\n# 复杂度分析\r\n时间 O(n) 空间O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086660008","body":"# 思路\r\n模拟\r\n\r\n```java\r\nclass CustomStack {\r\n    \r\n    private int[] array;\r\n    private int maxSize;\r\n    private int curSize;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.array = new int[maxSize];\r\n        this.maxSize = maxSize;\r\n        this.curSize = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(this.curSize < this.maxSize){\r\n            array[curSize++] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(this.curSize > 0){\r\n            return array[--curSize];\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if(curSize > 0){\r\n            for(int i = 0; i < k && i < curSize; i++){\r\n                array[i] += val;\r\n            }\r\n        }\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dtldtt":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086666626","body":"### 思路\n\n把原数组str中的c的下标取出来单独放在一个数组中，作为判断的边界。相当于几个分割点，除了开头和末尾的特殊情况，每次只需要判断离前一个分界点近还是离后一个分界点近就可以了。\n\n### 代码\n\n\n```cpp\nclass Solution {\npublic:\n#define MIN(x,y) ((x)<(y) ? (x) : (y))\n    vector<int> shortestToChar(string str, char c) {\n        vector<int> flags;\n        vector<int> answer;\n        for(int i=0;i<str.size();i++){\n            if(str[i]==c) flags.push_back(i);\n        }\n        //print_vector(flags);\n        //cout<<\"end\\n\";\n        int current_flag=0;\n        for(int i=0;i<str.size();i++){\n            if(current_flag==flags.size()){\n            answer.push_back(i-flags[current_flag-1]);\n            continue;\n            }\n            if(i>flags[current_flag]) {current_flag++; i--; continue;}\n            else if(current_flag==0){\n            answer.push_back(flags[current_flag]-i);\n            continue;\n            }\n            answer.push_back(MIN(i-flags[current_flag-1],flags[current_flag]-i));\n        }\n        return answer;\n            }\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086819738","body":"### [1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n\n\n### 思路\n\n就是用数组实现一个栈，标记对栈顶元素做好标记就好\n\n### 代码\n\n\n```cpp\n\nclass CustomStack {\nprivate:\n    int maxSize;\n    int *stack;\n    int num; //当前有几个数在栈中\npublic:\n    CustomStack(int maxSize) {\n        this->maxSize=maxSize;\n        this->stack = new int[maxSize];\n        num=-1;\n    }\n    ~CustomStack(){\n        delete [] this->stack;\n    }\n    bool is_empty()\n{\n    return num==-1;\n}\n    \n    void push(int x) {\n        if(num<maxSize-1) stack[++num]=x;\n        else return;\n    }\n    \n    int pop() {\n        if(is_empty()) return -1;\n        return stack[num--];\n    }\n    \n    void increment(int k, int val) {\n        for(int i=0;i<k && i<=num;i++){\n          stack[i]+=val;\n        }\n    }\n};\n\n\n\n\n```\n\n#### **复杂度分析**\n\n- 时间复杂度：O(1)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n\n#### 备注","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"james20141606":[null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086761350","body":"# Day 3: 1381. Design a Stack With Increment Operation (stack)\n\n- Problem Link\n  - [1381. Design a Stack With Increment Operation](https://leetcode.com/problems/design-a-stack-with-increment-operation/)\n\n- Ideas\n  -  We could either use vanilla way to implement, or use an array to store the information. Use an additional array to record the increment value. inc[i] means for all elements stack[0] ~ stack[i], we should plus inc[i] when popped from the stack. Then inc[i-1]+=inc[i], so that we can accumulate the increment inc[i] for the bottom elements and the following pops.\n  \n- Complexity: hash table and bucket\n  - Time: O(1)\n  - Space: O(N)\n\n- Code\n\n```python\nclass CustomStack:\n    \n    def __init__(self, maxSize: int):\n        self.list = []\n        self.inc = [] #log inc value and add to the number when poping a number\n        self.maxsize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.list) < self.maxsize:\n            self.list.append(x)\n            self.inc.append(0)\n\n    def pop(self) -> int:\n        if not self.inc: return -1\n        if len(self.inc) >1:\n            self.inc[-2] += self.inc[-1]\n        return self.list.pop() + self.inc.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if self.inc:\n            self.inc[min(k, len(self.inc)) -1] +=val\n```\n\n- other resources:\n    - ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"floatingstarlight":[null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086764343","body":"class CustomStack {\n\n    private final int maxSize;\n    private final int[] stack;\n    private final int[] inc;\n    private int top = -1;\n    private final int bottom = 0;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        stack = new int[maxSize];\n        inc = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (top == maxSize - 1) {\n            return;\n        }\n        stack[++top] = x;\n    }\n\n    public int pop() {\n        if (top < bottom) {\n            return -1;\n        }\n        int res = stack[top] + inc[top];\n        if (top > bottom) {\n            inc[top - 1] += inc[top];\n        }\n        inc[top] = 0;\n        top--;\n        return res;\n    }\n\n    public void increment(int k, int val) {\n        int i = Math.min(k - 1, top);\n        if (i >= bottom) {\n            inc[i] += val;\n        }\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"serena9":[null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086775193","body":"### 代码\n```python\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.stack = []\n        self.cnt = 0\n        self.size = maxSize\n\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if self.cnt < self.size:\n            self.stack.append(x)\n            self.cnt += 1\n        \n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.cnt != 0:\n            self.cnt -= 1\n            return self.stack.pop()\n        else:\n            return -1\n\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        for i in range(min(k, self.cnt)):\n            self.stack[i] += val\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"currybeefer":[null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086781771","body":"题目：【Day 3】1381. 设计一个支持增量操作的栈\r\n思路： 利用数组和一个指向数组顶部的指针就可以完成。但是注意边界条件的细节问题。\r\n我这里定义的cur指针指向的是下一个需要入栈的值应该存在的位置，所以初始值为0\r\n代码：\r\n```\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) \r\n    {\r\n        max=maxSize;\r\n        arr=new int[maxSize];\r\n        cur=0;\r\n    }\r\n    \r\n    void push(int x) \r\n    {\r\n        if(cur>=max) return;\r\n        arr[cur]=x;\r\n        cur++;\r\n    }\r\n    \r\n    int pop() \r\n    {\r\n        if(cur==0) return -1;\r\n        cur--;\r\n        return arr[cur];\r\n    }\r\n    \r\n    void increment(int k, int val) \r\n    {\r\n        int count=0;\r\n        if(cur<=k-1)\r\n            count=cur;\r\n        else\r\n            count=k;\r\n        \r\n        for(int i=0;i<count;i++)\r\n            arr[i]+=val;\r\n    }\r\npublic:\r\n    int* arr;\r\n    int cur;\r\n    int max;\r\n};\r\n```\r\n\r\n复杂度：\r\n时间复杂度：O(N) 主要是在 increment()中用了一次循环\r\n空间复杂度：O(N)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"oldfashioneddog":[null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086831280","body":"class CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.max_size = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.max_size:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(len(self.stack), k)):\n            self.stack[i] += val\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingchen77":[null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086877050","body":"#### 思路\n用两个数组模拟栈，一个存放每次push的数字，另外一个存放increment的内容，注意要更新increment出栈后的内容\n\n#### 代码\n```python\n    def __init__(self, maxSize: int):\n        self.st = []\n        self.incremental = []\n        self.cur = 0\n        self.size = maxSize\n    def push(self, x: int) -> None:\n        if self.cur < self.size:\n            self.st.append(x)\n            self.cur += 1\n            self.incremental.append(0)\n    def pop(self) -> int:\n        if self.cur == 0:\n            return -1\n        if self.cur >= 2:\n            self.incremental[-2] += self.incremental[-1]\n        self.cur -= 1\n        return self.st.pop() + self.incremental.pop()\n    def increment(self, k: int, val: int) -> None:\n        if self.cur > 0:\n            self.incremental[min(self.cur, k) - 1] += val\n```\n#### 空间复杂度\n时间 O(1) \\\n空间 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eggeggliu":[null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086884935","body":"```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.size = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.stack.length < this.size) {\n        this.stack.push(x);\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (this.stack.length != 0) {\n        let tmp = this.stack.pop();\n        return tmp;\n    } else {\n        return -1;\n    }\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for (let i = 0; i < this.stack.length && i < k; ++i) {\n        this.stack[i] += val;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}